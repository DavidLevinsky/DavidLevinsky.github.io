{"version":3,"sources":["webpack://vts/webpack/bootstrap","webpack://vts/./src/core/map/geodata-import/3dtiles2.js","webpack://vts/./src/core/map/loader/worker-globals.js","webpack://vts/./src/core/map/loader/worker-main.js","webpack://vts/./src/core/map/loader/worker-mesh.js","webpack://vts/./src/core/utils/math.js","webpack://vts/./src/core/utils/matrix.js","webpack://vts/./src/core/utils/url.js","webpack://vts/./src/core/utils/utils.js"],"names":[],"mappings":";;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;;;;;;;ACjF+C;AACE;AACC;AACI;;;;AAItD;AACA,WAAW,gDAAK;AAChB,WAAW,kDAAK;AAChB,YAAY,kDAAM;AAClB,eAAe,mDAAS;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC,OAAO;AAC9C,uCAAuC,OAAO;AAC9C,uCAAuC,OAAO;AAC9C,uCAAuC,OAAO;AAC9C,iBAAiB;;AAEjB,wDAAwD;;AAExD;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;;;AAGtB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEe,uFAAwB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;ACjUxC;;AAEiB;;;;;;;;;;;;;;;;;;ACFuC;AACC;AACU;;;AAGnE;AACA,cAAc,0DAAQ;AACtB,gBAAgB,yDAAU;AAC1B,+BAA+B,gEAAyB;;AAExD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,0DAA0D;AACjG;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,qCAAqC;AAC5E;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,gFAAgF,Y;AAC3H,qBAAqB;AACrB,iBAAiB;AACjB,0CAA0C,oCAAoC;AAC9E,uCAAuC,yDAAyD;AAChG,iBAAiB;AACjB;AACA;AACA,yCAAyC,4DAA4D;AACrG,iCAAiC,4DAA4D;AAC7F,iBAAiB;AACjB,uCAAuC,uDAAuD;AAC9F;AACA;;AAEA;;AAEA;;AAEA;AACA,mCAAmC,qCAAqC;AACxE;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iCAAiC,oDAAoD;AACrF,iBAAiB;AACjB,iCAAiC,oDAAoD;AACrF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;ACtKwD;;AAExD;AACA,cAAc,0DAAQ;;AAEtB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B,kCAAkC;AAClC,gCAAgC;AAChC,SAAS;AACT,oCAAoC;AACpC;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0EAA0E;AAC1E,0EAA0E;;AAE1E;AACA;AACA;;AAEA,4DAA4D;;AAE5D;AACA;AACA;;AAEA;;AAEA,oEAAoE;AACpE,iEAAiE;;AAEjE;AACA,qB;AACA;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA,yC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;;AAEA,mBAAmB;;AAEnB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA,+BAA+B;AAC/B,4BAA4B;AAC5B,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA,4DAA4D;;AAE5D;AACA,2EAA2E;AAC3E,KAAK;AACL;AACA;;AAEA,oEAAoE;AACpE,iDAAiD;;AAEjD;AACA;;AAEA,2DAA2D;AAC3D,2DAA2D;AAC3D,2DAA2D;;AAE3D,2DAA2D;AAC3D,2DAA2D;AAC3D,2DAA2D;;AAE3D;AACA;AACA;;;AAGA;AACA;AACA;AACA,2BAA2B;;AAE3B,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kDAAkD;;AAElD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,qBAAqB;;AAErB,wBAAwB;AACxB,wBAAwB;;AAExB,SAAS;AACT;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,uC;AACA;AACA,SAAS;AACT,kC;AACA;AACA;AACA,KAAK;AACL;AACA,uC;AACA;AACA,SAAS;AACT,kC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,2BAA2B;AAC3B,6BAA6B;;AAE7B,uBAAuB;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;AAClD,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,KAAK;AACL,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,qCAAqC;AACrC;AACA;AACA,aAAa;AACb,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA,iCAAiC;AACjC;AACA;AACA,SAAS;AACT,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,qBAAqB;;AAErB,wBAAwB;AACxB,wBAAwB;;AAExB,SAAS;AACT;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;;;ACv1BoB;;AAEvC;AACA,WAAW,4CAAK;;;AAGhB;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGc;;;;;;;;;;;;;;;;;;;;;ACnLd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;;;ACpzCtC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,6B;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;;AAEA,2B;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sD;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,6B;AACA;AACA;;;AAGkB;;;;;;;;;;;;;;;;;;ACjHmB;AACO;;AAE5C;AACA,WAAW,0CAAK;AAChB,eAAe,6CAAS;;;AAGxB;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,0BAA0B,6BAA6B;AACvD;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA,wCAAwC,cAAc,mCAAmC,E;;AAEzF;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA,0BAA0B,6BAA6B;AACvD;AACA,KAAK;AACL,CAAC;;;AAGD;AACA,8BAA8B,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA,oCAAoC;AACpC,CAAC;;;AAGD;AACA;AACA,CAAC;;;AAGD;AACA;AACA,CAAC,E;;;AAGD;AACA;AACA,CAAC,E;;;AAGD;AACA;AACA,iB;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;;;AAGA,kF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGe;;AAEf;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC","file":"e3ce97cafed981159c55.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/core/map/loader/worker-main.js\");\n","\nimport {math as math_} from '../../utils/math';\nimport {vec3 as vec3_} from '../../utils/matrix';\nimport {utils as utils_} from '../../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../../utils/url';\n\n\n\n//get rid of compiler mess\nvar math = math_;\nvar vec3 = vec3_;\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\n\nvar MapGeodataImport3DTiles2 = function() {\n    this.bintree = null;\n    this.pathTable = null;\n    this.totalNodes = 0;\n    this.pathTableSize = 1;\n    this.nodesIndex = 0;\n    this.rootSize = 1;\n};\n\nMapGeodataImport3DTiles2.prototype.countNode = function(node, onlyChildren) {\n    this.totalNodes++;\n\n\n    var content = node['content'];\n\n    if (content && content['uri']) {\n        var path = content['uri'];\n\n        var tmp = path.split(\".\");\n        if (tmp.length > 1) {\n            \n            var ext = tmp[tmp.length - 1];\n            tmp.pop();\n            var stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n                this.pathTableSize += stmp.length + 1 + 4;\n            } else if (ext == \"mesh\") {\n                this.pathTableSize += stmp.length + 1;\n            }\n        }\n    }\n\n\n    var children = node['children'];\n\n    if (children) {\n        for (var i = 0, li = children.length; i < li; i++) {\n            this.countNode(children[i]);\n        }\n    }\n};\n\n/*\nMapGeodataImport3DTiles2.prototype.processNodeOctant = function(node, originalOctant) {\n    var content = node['content'];\n\n    if (content && content['uri']) {\n        var path = content['uri'];\n\n        var tmp = path.split(\".\");\n        if (tmp.length > 1) {\n\n            var ext = tmp[tmp.length - 1];\n            tmp.pop();\n            var stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n                \n                tmp = stmp.split(\"-\");\n\n            } else if (ext == \"mesh\") {\n                \n                var fname = tmp;\n                \n                tmp = stmp.split(\"/\");\n                tmp = tmp[tmp.length - 1];\n                tmp = tmp.split(\"-\");\n\n                var ix = parseInt(tmp[tmp.length - 3]);\n                var iy = parseInt(tmp[tmp.length - 2]);\n                var iz = parseInt(tmp[tmp.length - 1]);\n\n                var octant = (ix % 2) + (iy % 2)*2 + ((iz+1) % 2)*4;\n                \n                console.log(\"octant: node: \" + originalOctant + \" mesh:\" + octant + \"   \"  + fname);\n            }\n        }\n    }\n \n};\n*/\n\n\nMapGeodataImport3DTiles2.prototype.processNode = function(node, index, lod, onlyChildren) {\n\n    var index2 = index * 9;\n\n    //debugger\n    var content = node['content'];\n\n    if (content && content['uri']) {\n        var path = content['uri'];\n\n        var tmp = path.split(\".\");\n        if (tmp.length > 1) {\n            \n            var ext = tmp[tmp.length - 1];\n            tmp.pop();\n            var stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n                this.bintree[index2] = this.pathTableSize | (1<<31);\n                this.pathTableSize += 4;\n            } else if (ext == \"mesh\") {\n                this.bintree[index2] = this.pathTableSize;\n            }\n\n            for (var i = 0, li = stmp.length; i < li; i++) {\n                this.pathTable[this.pathTableSize++] = stmp.charCodeAt(i);\n            }\n            \n            this.pathTable[this.pathTableSize++] = 0;\n        }\n    }\n\n    var children = node['children'];\n\n    if (children) {\n\n        for (var i = 0, li = children.length; i < li; i++) {\n            var child = children[i];\n            var boundingVolume = child['boundingVolume'];\n\n            if (boundingVolume) {\n                \n                var extras = child['extras'];\n                var octant = 0;\n                \n                if (extras) {\n                    octant = extras['ci'];\n                }\n                \n                \n                var ix = octant & 1;\n                var iy = (octant & (1<<1)) >> 1;\n                var iz = (octant & (1<<2)) >> 2;\n                \n                /*\n                switch(octant) {\n                    case 0: octant = 4; break;\n                    case 1: octant = 5; break;\n                    case 2: octant = 6; break;\n                    case 3: octant = 7; break;\n                    case 4: octant = 0; break; //\n                    case 5: octant = 1; break; //\n                    case 6: octant = 2; break; //\n                    case 7: octant = 3; break; //\n                }*/\n                \n                //this.processNodeOctant(child, octant);*/\n\n                /*\n                if (lod > 1) {\n                    iy = 1 - iy;\n                }*/\n\n                //iz = 1 - iz;\n                \n                //octant = (ix<<0) + (iy << 1) + (iz << 2);\n                //octant = (ix<<0) + (iy << 1) + (iz << 2);\n                \n                //octant = 0;\n                \n                if (boundingVolume['region']) {\n                    \n                    this.totalNodes++;\n                    var childIndex = this.totalNodes;\n                    \n                    this.bintree[index2 + 1 + octant] = childIndex;\n\n                    this.processNode(child, childIndex, lod + 1);\n                }\n            }\n        }\n        \n        /*var testCount = 0;\n        for (var i = 0, li = 8; i < li; i++) {\n            if (this.bintree[index2 + 1 + i]) {\n                testCount++;\n            }\n        }\n\n        if (testCount != children.length) {\n            console.log('duplicit octants!!!');\n        } */       \n    }\n};\n\n\nMapGeodataImport3DTiles2.prototype.processJSON = function(json, options) {\n    if (!json) {\n        return;\n    }\n\n    this.rootPath = '';\n\n    this.countNode(json['root']);\n    //alloc memory\n    this.bintree = new Uint32Array(this.totalNodes*9);\n    this.pathTable = new Uint8Array(this.pathTableSize+1);\n\n    this.totalNodes = 0;\n    this.pathTableSize = 1;\n\n    //debugger\n\n    if (options.root) {\n        \n        var extras = json['extras'];\n        var points = extras['extents'];\n\n        var center = [ (points[0][0]+points[1][0]+points[2][0]+points[3][0]+points[4][0]+points[5][0]+points[6][0]+points[7][0])/8,\n                       (points[0][1]+points[1][1]+points[2][1]+points[3][1]+points[4][1]+points[5][1]+points[6][1]+points[7][1])/8,\n                       (points[0][2]+points[1][2]+points[2][2]+points[3][2]+points[4][2]+points[5][2]+points[6][2]+points[7][2])/8 ];\n\n       var yv = [(points[1][0] - points[0][0]), (points[1][1] - points[0][1]), (points[1][2] - points[0][2])];\n       var xv = [(points[1][0] - points[2][0]), (points[1][1] - points[2][1]), (points[1][2] - points[2][2])];\n       var zv = [(points[4][0] - points[0][0]), (points[4][1] - points[0][1]), (points[4][2] - points[0][2])];\n\n       yv[0] = -yv[0];\n       yv[1] = -yv[1];\n       yv[2] = -yv[2];\n\n       xv[0] = -xv[0];\n       xv[1] = -xv[1];\n       xv[2] = -xv[2];\n       \n       /*zv[0] = -zv[0];\n       zv[1] = -zv[1];\n       zv[2] = -zv[2];*/\n       \n\n       var p = points[1];\n\n        this.rootPoints = [\n\n            [p[0],\n             p[1],\n             p[2]],\n\n            [p[0] + xv[0],\n             p[1] + xv[1],\n             p[2] + xv[2]],\n\n            [p[0] + xv[0] + yv[0],\n             p[1] + xv[1] + yv[1],\n             p[2] + xv[2] + yv[2]],\n\n            [p[0] + yv[0],\n             p[1] + yv[1],\n             p[2] + yv[2]],\n\n            [p[0] + zv[0],\n             p[1] + zv[1],\n             p[2] + zv[2]],\n\n            [p[0] + xv[0] + zv[0],\n             p[1] + xv[1] + zv[1],\n             p[2] + xv[2] + zv[2]],\n\n            [p[0] + xv[0] + yv[0] + zv[0],\n             p[1] + xv[1] + yv[1] + zv[1],\n             p[2] + xv[2] + yv[2] + zv[2]],\n\n            [p[0] + yv[0] + zv[0],\n             p[1] + yv[1] + zv[1],\n             p[2] + yv[2] + zv[2]]\n        \n        ];\n\n        //this.rootPoints = points;\n        this.rootCenter = center;\n        this.rootRadius = vec3.distance(center, points[0]);\n        this.rootTexelSize = extras['nominalResolution'] * Math.pow(2,extras['depth']);\n    } else {\n        this.rootPoints = [];\n        this.rootCenter = [];\n        this.rootRadius = 1;\n        this.rootTexelSize = 1;\n    }\n\n    this.processNode(json['root'], 0, 0);\n    this.totalNodes++;\n};\n\n\nMapGeodataImport3DTiles2.prototype.loadJSON = function(path, options, onLoaded) {\n    utils.loadJSON(path, this.onLoaded.bind(this, options, onLoaded), null);\n};\n\nMapGeodataImport3DTiles2.prototype.onLoaded = function(options, onLoaded, json) {\n    this.processJSON(json, options);\n    \n    if (onLoaded) {\n        onLoaded(options, {\n                   'bintree': this.bintree,\n                   'pathTable': this.pathTable,\n                   'totalNodes': this.totalNodes,\n                   'rootSize': this.rootSize,\n                   'points': this.rootPoints,\n                   'center': this.rootCenter,\n                   'radius': this.rootRadius,\n                   'texelSize': this.rootTexelSize\n               });\n    }\n}\n\nexport default MapGeodataImport3DTiles2;\n\n\n\n\n\n\n\n\n\n","\nvar globals = {};\n\nexport {globals};\n","\nimport {globals as globals_} from './worker-globals.js';\nimport {parseMesh as parseMesh_} from './worker-mesh.js';\nimport MapGeodataImport3DTiles2_ from '../geodata-import/3dtiles2';\n\n\n//get rid of compiler mess\nvar globals = globals_;\nvar parseMesh = parseMesh_;\nvar MapGeodataImport3DTiles2 = MapGeodataImport3DTiles2_;\n\nvar packedEvents = [];\nvar packedTransferables = [];\n\nfunction postPackedMessage(message, transferables) {\n\n    if (globals.config.mapPackLoaderEvents) {\n\n        packedEvents.push(message);\n\n        if (transferables) {\n            packedTransferables = packedTransferables.concat(transferables);\n        }\n\n    } else {\n\n        if (transferables) {\n            postMessage(message, transferables);\n        } else {\n            postMessage(message);\n        }\n\n    }\n}\n\nfunction loadBinary(path, onLoaded, onError, withCredentials, xhrParams, responseType, kind, options) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    postPackedMessage({'command' : 'on-error', 'path': path, 'status':xhr.status});\n                }\n                break;\n            }\n    \n            var abuffer = xhr.response;\n                    \n            if (!abuffer) {\n                if (onError) {\n                    postPackedMessage({'command' : 'on-error', 'path': path});\n                }\n                break;\n            }\n    \n            if (onLoaded) {\n                if (kind == 'direct-texture') {\n                    createImageBitmap(abuffer).then((function(bitmap){\n                        postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': bitmap, 'filesize': abuffer.size}, [bitmap]);                        \n                    }).bind(this));\n                } else if (kind == 'direct-mesh') {\n                    var data = parseMesh({data:new DataView(abuffer), index:0});\n                    postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': data.mesh}, data.transferables);\n                } else if (kind == 'direct-3dtiles') {\n                    //debugger\n                    var data = parse3DTile(JSON.parse(abuffer), options);\n                    //postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': data.geodata}, data.transferables);\n                    postMessage({'command' : 'on-loaded', 'path': path, 'data': data.geodata}, data.transferables);\n                } else {\n                    postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': abuffer}, [abuffer]);\n                }\n            }\n    \n            break;\n    \n        default:\n    \n            if (onError) {\n                postPackedMessage({'command' : 'on-error', 'path': path});\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n    \n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET', path, true);\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\nfunction parse3DTile(json, options) {\n\n    var geodata = new MapGeodataImport3DTiles2();\n    geodata.processJSON(json, options);\n\n    return { geodata:{\n                'bintree': geodata.bintree,\n                'pathTable': geodata.pathTable,\n                'totalNodes': geodata.totalNodes,\n                'rootSize': geodata.rootSize,\n                'points': geodata.rootPoints,\n                'center': geodata.rootCenter,\n                'radius': geodata.rootRadius,\n                'texelSize': geodata.rootTexelSize\n             },\n             transferables:[geodata.bintree.buffer, geodata.pathTable.buffer]\n           };\n\n}\n\nself.onmessage = function (e) {\n    var message = e.data;\n    var command = message['command'];\n    //var data = message['data'];\n\n    //console.log(\"workeronmessage: \" + command);\n\n    switch(command) {\n\n        case 'config':\n            globals.config = message['data'];\n            break;\n\n        case 'tick':\n\n            if (packedEvents.length > 0) {\n                if (packedTransferables.length > 0) {\n                    postMessage({'command': 'packed-events', 'messages':packedEvents}, packedTransferables);\n                } else {\n                    postMessage({'command': 'packed-events', 'messages':packedEvents});\n                }\n            }\n\n            packedEvents = [];\n            packedTransferables = [];\n\n            break;\n\n        case 'load-binary':\n            loadBinary(message['path'], true, true, message['withCredentials'], message['xhrParams'], message['responseType'], message['kind'], message['options']);\n            break;\n\n    }\n};\n\n","\nimport {globals as globals_} from './worker-globals.js';\n\n//get rid of compiler mess\nvar globals = globals_;\n\nvar flagsInternalTexcoords =  1;\nvar flagsExternalTexcoords =  2;\nvar flagsPerVertexUndulation =  4;\nvar flagsTextureMode =  8;\n\n\nfunction parseMesh(stream) {\n    /*\n    struct MapMesh {\n        struct MapMeshHeader {\n            char magic[2];                // letters \"ME\"\n            ushort version;               // currently 1\n            double meanUndulation;        // read more about undulation below\n            ushort numSubmeshes;          // number of submeshes\n        } header;\n        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property\n    };\n    */\n\n    var mesh = {}, i, li, submesh;\n\n    //parase header\n    var streamData = stream.data;\n    var magic = '';\n\n    if (streamData.length < 2) {\n        return false;\n    }\n\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n\n    if (magic != 'ME') {\n        return false;\n    }\n\n    mesh.version = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    if (mesh.version > 3) {\n        return false;\n    }\n    \n    stream.uint8Data = new Uint8Array(stream.data.buffer);\n\n    mesh.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;\n    mesh.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    mesh.submeshes = [];\n    mesh.gpuSize = 0; \n    mesh.faces = 0;\n    mesh.size = 0;\n\n    var use16bit = globals.config.map16bitMeshes;\n\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\n        var submesh = parseSubmesh(mesh, stream);\n        if (submesh.valid) {\n            mesh.submeshes.push(submesh); \n            mesh.size += submesh.size;\n            mesh.faces += submesh.faces;\n\n            //aproximate size\n            mesh.gpuSize += submesh.size;\n        }\n    }\n    \n    mesh.numSubmeshes = mesh.submeshes.length;\n\n    //prevent minification\n\n    var submeshes = [];\n    var transferables = [];\n\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\n        submesh = mesh.submeshes[i];\n        submeshes.push({\n\n            'bboxMax': submesh.bboxMax,\n            'bboxMin': submesh.bboxMin,\n            'externalUVs': (submesh.externalUVs) ? submesh.externalUVs.buffer : null,\n            'faces': submesh.faces,\n            'flags': submesh.flags,\n            'gpuSize': submesh.gpuSize,\n            'indices': (submesh.indices) ? submesh.indices.buffer : null,\n            'internalUVs': (submesh.internalUVs) ? submesh.internalUVs.buffer : null,\n            'size': submesh.size,\n            'surfaceReference': submesh.surfaceReference,\n            'textureLayer': submesh.textureLayer,\n            'textureLayer2': submesh.textureLayer2,\n            //'valid': submesh.valid\n            'vertices': submesh.vertices.buffer\n\n        });\n\n        if (submesh.externalUVs) transferables.push(submesh.externalUVs.buffer);\n        if (submesh.internalUVs) transferables.push(submesh.internalUVs.buffer);\n        if (submesh.vertices) transferables.push(submesh.vertices.buffer);\n        if (submesh.indices) transferables.push(submesh.indices.buffer);\n    }\n\n    return { mesh:{\n               'faces': mesh.faces,\n               'gpuSize': mesh.gpuSize,\n               'meanUndulation': mesh.meanUndulation,\n               'numSubmeshes': mesh.numSubmeshes,\n               'size': mesh.size,\n               'submeshes': mesh.submeshes,\n               'version': mesh.version\n             },\n             transferables:transferables\n           };\n};\n\n\nfunction parseSubmesh(mesh, stream) {\n    /*\n    struct MapSubmesh {\n        struct MapSubmeshHeader header;\n        struct VerticesBlock vertices;\n        struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )\n        struct FacesBlock faces;\n    };\n    */\n\n    var submesh = { valid:true };\n\n    parseHeader(mesh, submesh, stream);\n    if (mesh.version >= 3) {\n        parseVerticesAndFaces2(mesh, submesh, stream);\n    } else {\n        parseVerticesAndFaces(mesh, submesh, stream);\n    }\n\n    return submesh;\n};\n\n\nfunction parseHeader(mesh, submesh, stream) {\n    /*\n    struct MapSubmeshHeader {\n        char flags;                    // bit 0 - contains internal texture coords\n                                       // bit 1 - contains external texture coords\n                                       // bit 2 - contains per vertex undulation\n                                       // bit 3 - texture mode (0 - internal, 1 - external)\n        \n        uchar surfaceReference;        // reference to the surface of origin, see bellow\n        ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id\n        double boundingBox[2][3];      // read more about bounding box bellow\n    };\n    */\n\n    //debugger\n    var streamData = stream.data;\n\n    submesh.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    if (mesh.version > 1) {\n        submesh.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;\n    } else {\n        submesh.surfaceReference = 0;\n    }\n\n    submesh.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;\n    submesh.textureLayer2 = submesh.textureLayer; //hack for presentation\n\n    var bboxMin = [];\n    var bboxMax = [];\n\n    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n\n    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    \n    submesh.bboxMin = bboxMin;\n    submesh.bboxMax = bboxMax;\n};\n\n\nfunction parseVerticesAndFaces(mesh, submesh, stream) {\n    /*\n    struct VerticesBlock {\n        ushort numVertices;              // number of vertices\n\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n            // vertex coordinates\n            ushort x;\n            ushort y;\n            ushort z;\n\n            // if header.flags & ( 1 << 1 ): external texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort eu;\n            ushort ev;\n\n            // if header.flags & ( 1 << 2 ): undulation delta\n            float16 undulationDelta;\n        } vertices[];\n    };\n    */\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n\n    var use16bit = globals.config.map16bitMeshes;\n\n    var numVertices = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        submesh.valid = false;\n    }\n\n    var internalUVs = null;\n    var externalUVs = null;\n    var onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\n    var tmpVertices, tmpExternalUVs, tmpInternalUVs;\n\n    var vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n\n    if (submesh.flags & flagsExternalTexcoords) {\n        if (onlyOneUVs) {\n            externalUVs = true;\n        } else {\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n        }\n    }\n\n    var uvfactor = use16bit ? 1.0 : (1.0 / 65535);\n    var vindex = 0;\n    var uvindex = 0;\n    var i, li;\n\n    for (i = 0; i < numVertices; i++) {\n        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;\n        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;\n        vindex += 3;\n\n        if (externalUVs) {\n            if (!onlyOneUVs) {\n                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;\n                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;\n                uvindex += 2;\n            }\n            index += 10;\n        } else {\n            index += 6;\n        }\n    }\n\n\n    tmpVertices = vertices;\n    tmpExternalUVs = externalUVs;\n   \n    /*\n    struct TexcoorsBlock {\n        ushort numTexcoords;              // number of texture coordinates\n\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n            // internal texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort u;\n            ushort v;\n        } texcoords[];\n    };\n    */\n\n    if (submesh.flags & flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n    \n        internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        //var uvfactor = 1.0 / 65535;\n    \n        for (i = 0, li = numUVs * 2; i < li; i+=2) {\n            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;\n            index += 4;\n        }\n    \n        tmpInternalUVs = internalUVs;\n    }\n\n    /*\n    struct FacesBlock {\n        ushort numFaces;              // number of faces\n\n        struct Face {                 // array of faces, size of array is defined by numFaces property\n\n            ushort v[3]; // array of indices to stored vertices\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n        } faces[];\n    };\n    */\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\n    var onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (submesh.flags & flagsInternalTexcoords) {\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = tmpVertices;\n    var eUVs = tmpExternalUVs;\n    var iUVs = tmpInternalUVs;\n    var v1, v2, v3, vv1, vv2, vv3, sindex;\n\n    if (onlyExternalIndices) {\n        vertices = tmpVertices;\n        externalUVs = tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = tmpInternalUVs;\n    }\n\n    for (i = 0; i < numFaces; i++) {\n        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));\n        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));\n        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));\n\n        if (onlyIndices) {\n            vindex = i * 3;\n\n            if (internalUVs != null) {\n                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n\n                vertices[vv1*3] = vtmp[v1*3];\n                vertices[vv1*3+1] = vtmp[v1*3+1];\n                vertices[vv1*3+2] = vtmp[v1*3+2];\n\n                vertices[vv2*3] = vtmp[v2*3];\n                vertices[vv2*3+1] = vtmp[v2*3+1];\n                vertices[vv2*3+2] = vtmp[v2*3+2];\n\n                vertices[vv3*3] = vtmp[v3*3];\n                vertices[vv3*3+1] = vtmp[v3*3+1];\n                vertices[vv3*3+2] = vtmp[v3*3+2];\n\n                indices[vindex] = vv1;\n                indices[vindex+1] = vv2;\n                indices[vindex+2] = vv3;\n\n                index += 12;\n            } else {\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n\n                index += 6;\n            }\n\n        } else {\n            vindex = i * (3 * 3);\n\n            sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n\n            if (internalUVs != null) {\n                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n                index += 12;\n\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            } else {\n                index += 6;\n            }\n        }\n    }\n\n    submesh.vertices = vertices;\n    submesh.internalUVs = internalUVs;\n    submesh.externalUVs = externalUVs;\n    submesh.indices = indices;\n\n    tmpVertices = null;\n    tmpInternalUVs = null;\n    tmpExternalUVs = null;\n\n    stream.index = index;\n\n    submesh.size = submesh.vertices.byteLength;\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\n    submesh.faces = numFaces;\n};\n\n\nfunction parseWord(data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);\n        res[1] += 2;\n    } else {\n        res[0] = value;\n        res[1] ++;\n    }\n};\n\n\nfunction parseDelta(data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        value = (value & 0x7f) | (data[res[1]+1] << 7);\n\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] += 2;\n        } else {\n            res[0] = (value >> 1); \n            res[1] += 2;\n        }\n    } else {\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] ++;\n        } else {\n            res[0] = (value >> 1); \n            res[1] ++;\n        }\n    }\n};\n\n\nfunction parseVerticesAndFaces2(mesh, submesh, stream) {\n    /*\n    struct VerticesBlock {\n        ushort numVertices;              // number of vertices\n        ushort geomQuantCoef;            // geometry quantization coefficient\n\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n            // vertex coordinates\n            delta x;\n            delta y;\n            delta z;\n        } vertices[];\n    };\n    */\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n\n    var use16bit = globals.config.map16bitMeshes;\n    var onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\n    var tmpVertices, tmpExternalUVs, tmpInternalUVs;\n\n    var numVertices = data.getUint16(index, true); index += 2;\n    var quant = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        submesh.valid = false;\n    }\n\n    var bmin = submesh.bboxMin;\n    var bmax = submesh.bboxMax;\n\n    var center = [(bmin[0] + bmax[0])*0.5, (bmin[1] + bmax[1])*0.5, (bmin[2] + bmax[2])*0.5];\n    var scale = Math.abs(Math.max(bmax[0] - bmin[0], bmax[1] - bmin[1], bmax[2] - bmin[2]));\n\n    var multiplier = 1.0 / quant;\n    var externalUVs = null;\n\n    var vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n    var vindex;\n    \n    var x = 0, y = 0,z = 0;\n    var cx = center[0], cy = center[1], cz = center[2];\n    var mx = bmin[0];\n    var my = bmin[1];\n    var mz = bmin[2];\n    var sx = 1.0 / (bmax[0] - bmin[0]);\n    var sy = 1.0 / (bmax[1] - bmin[1]);\n    var sz = 1.0 / (bmax[2] - bmin[2]);\n    \n    var res = [0, index];\n    var i, li, t;\n\n    if (use16bit) {\n        for (i = 0; i < numVertices; i++) {\n            parseDelta(uint8Data, res);\n            x += res[0];\n            parseDelta(uint8Data, res);\n            y += res[0];\n            parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            t = ((x * multiplier * scale + cx) - mx) * sx;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex] = t * 65535;\n            t = ((y * multiplier * scale + cy) - my) * sy;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+1] = t * 65535;\n            t = ((z * multiplier * scale + cz) - mz) * sz;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+2] = t * 65535;\n        }\n    } else {\n        for (i = 0; i < numVertices; i++) {\n            parseDelta(uint8Data, res);\n            x += res[0];\n            parseDelta(uint8Data, res);\n            y += res[0];\n            parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;\n            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;\n            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;\n        }\n    }\n    \n    index = res[1];\n\n    if (submesh.flags & flagsExternalTexcoords) {\n        quant = data.getUint16(index, true); index += 2;\n        res[1] = index;\n\n        if (onlyOneUVs) {\n\n            for (i = 0; i < numVertices; i++) {\n                parseDelta(uint8Data, res);\n                parseDelta(uint8Data, res);\n            }\n\n        } else {\n            multiplier = (use16bit) ? (65535 / quant) : (1.0 / quant);\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n            x = 0, y = 0;\n\n            if (use16bit) {\n                for (i = 0; i < numVertices; i++) {\n                    parseDelta(uint8Data, res);\n                    x += res[0];\n                    parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    t = x * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex] = t;\n                    t = y * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex+1] = 65535 - t;\n                }\n            } else {\n                for (i = 0; i < numVertices; i++) {\n                    parseDelta(uint8Data, res);\n                    x += res[0];\n                    parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    externalUVs[uvindex] = x * multiplier;\n                    externalUVs[uvindex+1] = 1 - (y * multiplier);\n                }\n            }\n        }\n    }\n\n    index = res[1];\n\n    tmpVertices = vertices;\n    tmpExternalUVs = externalUVs;\n    \n    /*\n    struct TexcoorsBlock {\n        ushort numTexcoords;              // number of texture coordinates\n\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n            // internal texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort u;\n            ushort v;\n        } texcoords[];\n    };\n    */\n\n    if (submesh.flags & flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n        var quantU = data.getUint16(index, true); index += 2;\n        var quantV = data.getUint16(index, true); index += 2;\n        var multiplierU = (use16bit) ? (65536.0 / quantU) : (1.0 / quantU);\n        var multiplierV = (use16bit) ? (65536.0 / quantV) : (1.0 / quantV);\n        x = 0, y = 0;\n    \n        var internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        res[1] = index;7\n\n        if (use16bit) {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                parseDelta(uint8Data, res);\n                x += res[0];\n                parseDelta(uint8Data, res);\n                y += res[0];\n\n                t = x * multiplierU;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i] = t;\n                t = y * multiplierV;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i+1] = 65535 - t;\n            }\n        } else {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                parseDelta(uint8Data, res);\n                x += res[0];\n                parseDelta(uint8Data, res);\n                y += res[0];\n\n                internalUVs[i] = x * multiplierU;\n                internalUVs[i+1] = 1 - (y * multiplierV);\n            }\n        }\n\n        index = res[1];\n    \n        tmpInternalUVs = internalUVs;\n    }\n\n    /*\n    struct FacesBlock {\n        ushort numFaces;              // number of faces\n\n        struct Face {                 // array of faces, size of array is defined by numFaces property\n\n            ushort v[3]; // array of indices to stored vertices\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n        } faces[];\n    };\n    */\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\n    var onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (submesh.flags & flagsInternalTexcoords) {\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = tmpVertices;\n    var eUVs = tmpExternalUVs;\n    var iUVs = tmpInternalUVs;\n    var high = 0;\n    var v1, v2, v3, vv1, vv2, vv3;\n    res[1] = index;\n\n    for (i = 0; i < numFaces; i++) {\n        parseWord(uint8Data, res);\n        v1 = high - res[0];\n        if (!res[0]) { high++; }\n\n        parseWord(uint8Data, res);\n        v2 = high - res[0];\n        if (!res[0]) { high++; }\n\n        parseWord(uint8Data, res);\n        v3 = high - res[0];\n        if (!res[0]) { high++; }\n\n        if (onlyIndices) {\n            vindex = i * 3;\n            indices[vindex] = v1;\n            indices[vindex+1] = v2;\n            indices[vindex+2] = v3;\n        } else {\n            vindex = i * (3 * 3);\n            var sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n        }\n    }\n\n    if (onlyExternalIndices) {\n        vertices = tmpVertices;\n        externalUVs = tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = tmpInternalUVs;\n    }\n\n    high = 0;\n\n    if (internalUVs != null) {\n        for (i = 0; i < numFaces; i++) {\n            parseWord(uint8Data, res);\n            v1 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            parseWord(uint8Data, res);\n            v2 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            parseWord(uint8Data, res);\n            v3 = high - res[0];\n            if (!res[0]) { high++; }\n\n            if (onlyInternalIndices) {\n                vindex = i * 3;\n\n                vv1 = indices[vindex] * 3;\n                vv2 = indices[vindex+1] * 3;\n                vv3 = indices[vindex+2] * 3;\n\n                vertices[v1*3] = vtmp[vv1];\n                vertices[v1*3+1] = vtmp[vv1+1];\n                vertices[v1*3+2] = vtmp[vv1+2];\n\n                vertices[v2*3] = vtmp[vv2];\n                vertices[v2*3+1] = vtmp[vv2+1];\n                vertices[v2*3+2] = vtmp[vv2+2];\n\n                vertices[v3*3] = vtmp[vv3];\n                vertices[v3*3+1] = vtmp[vv3+1];\n                vertices[v3*3+2] = vtmp[vv3+2];\n\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n            } else {\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            }\n        }\n    }\n\n    index = res[1];\n\n    submesh.vertices = vertices;\n    submesh.internalUVs = internalUVs;\n    submesh.externalUVs = externalUVs;\n    submesh.indices = indices;\n\n    //tmpVertices = null;\n    //tmpInternalUVs = null;\n    //tmpExternalUVs = null;\n\n    stream.index = index;\n\n    submesh.size = submesh.vertices.byteLength;\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\n    submesh.faces = numFaces;\n};\n\nexport {parseMesh};\n\n","\nimport {mat4 as mat4_} from './matrix';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\n\n\nvar math = {};\n\n\nmath.isEqual = function(value, value2, delta) {\n    return (Math.abs(value - value2) < delta);\n};\n\n\nmath.clamp = function(value, min, max) {\n    if (value < min) value = min;\n    else if (value > max) value = max;\n\n    return value;\n};\n\n\nmath.radians = function(degrees) {\n    return degrees * Math.PI / 180;\n};\n\n\nmath.degrees = function(radians) {\n    return (radians / Math.PI) * 180;\n};\n\n\nmath.mix = function(a, b, c) {\n    return a + (b - a) * c;\n};\n\n\nmath.frustumMatrix = function(left, right, bottom, top, near, far) {\n    var w = (right - left);\n    var h = (top - bottom);\n    var d = (far - near);\n\n    var m = mat4.create([2*near/w, 0, (right+left)/w, 0,\n        0, 2*near/h, (top+bottom)/h, 0,\n        0, 0, -(far+near)/d, -2*far*near/d,\n        0, 0, -1, 0]);\n\n    mat4.transpose(m);\n    return m;\n};\n\n\nmath.perspectiveMatrix = function(fovy, aspect, near, far) {\n    var ymax = near * Math.tan(fovy * Math.PI / 180.0);\n    var xmax = ymax * aspect;\n    return math.frustumMatrix(-xmax, xmax, -ymax, ymax, near, far);\n};\n\n\nmath.orthographicMatrix = function(vsize, aspect, near, far) {\n    //vsize *= 0.020;\n    var w = vsize* 0.5 * aspect;\n    var h = vsize * 0.5;\n    var d = (far - near);\n\n    var m = mat4.create([1/w, 0, 0, 0,\n        0, 1/h, 0, 0,\n        0, 0, -2/d, -((far+near)/d),\n        0, 0, 0, 1]);\n\n    mat4.transpose(m);\n    return m;\n};\n\n\nmath.rotationMatrix = function(axis, angle) {\n    var ca = Math.cos(angle), sa = Math.sin(angle);\n\n    /*    var m;\n    switch (axis) {\n    case 0:\n        m = [\n            1,  0,  0, 0,\n            0, ca,-sa, 0,\n            0, sa, ca, 0,\n            0,  0,  0, 1 ];\n        break;\n    case 1:\n        m = [\n            ca, 0,-sa, 0,\n            0, 1,  0,  0,\n            sa, 0, ca, 0,\n            0, 0,  0, 1 ];\n        break;\n    default:\n        m = [\n            ca,-sa, 0, 0,\n            sa, ca, 0, 0,\n            0,  0,  1, 0,\n            0,  0,  0, 1 ];\n        break;\n    }\n    mat4.transpose(m);\n    return m; */\n\n    switch (axis) {\n    case 0:\n        return [\n            1,   0,   0,  0,\n            0,  ca,  sa,  0,\n            0, -sa,  ca,  0,\n            0,   0,   0,  1 ];\n    case 1:\n        return [\n             ca,  0,  sa,  0,\n              0,  1,   0,  0,\n            -sa,  0,  ca,  0,\n              0,  0,   0,  1 ];\n    default:\n        return [\n             ca, sa,  0,  0,\n            -sa, ca,  0,  0,\n              0,  0,  1,  0,\n              0,  0,  0,  1 ];\n    }\n\n};\n\n\nmath.scaleMatrix = function(sx, sy, sz) {\n    /*var m = [\n        sx,  0,  0, 0,\n        0, sy,  0, 0,\n        0,  0, sz, 0,\n        0,  0,  0, 1 ];\n\n    mat4.transpose(m);\n    return m;*/\n    return [\n        sx,   0,   0,   0,\n        0,   sy,   0,   0,\n        0,    0,  sz,   0,\n        0,    0,   0,   1 ];\n};\n\n\nmath.scaleMatrixf = function(s) {\n    return math.scaleMatrix(s, s, s);\n};\n\n\nmath.translationMatrix = function(tx, ty, tz) {\n    /*\n    var m = [\n        1, 0, 0, tx,\n        0, 1, 0, ty,\n        0, 0, 1, tz,\n        0, 0, 0, 1 ];\n\n    mat4.transpose(m);\n    */\n\n    return [\n        1,   0,  0,  0,\n        0,   1,  0,  0,\n        0,   0,  1,  0,\n        tx, ty, tz,  1 ];\n};\n\n\nmath.translationMatrix2f = function(t) {\n    return math.translationMatrix(t[0], t[1], 0);\n};\n\n\nmath.translationMatrix3f = function(t) {\n    return math.translationMatrix(t[0], t[1], t[2]);\n};\n\n\nexport {math};\n","\n\nvar vec2 = {};\n\n\nvec2.create = function (a) {\n    var b = new Array(2);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n    }\n    return b;\n};\n\n\nvar vec4 = {};\n\n\nvec4.create = function (a) {\n    var b = new Array(4);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n    }\n    return b;\n};\n\n\nvec4.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n};\n\n\nvec4.dot2 = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3];\n};\n\n\nvec4.dot3 = function (a, b, i, x, y, z) {\n    return a[0] * (b[i]-x) + a[1] * (b[i+1]-y) + a[2] * (b[i+2]-z) + a[3];\n};\n\n\nvar vec3 = {};\n\n\nvec3.create = function (a) {\n    var b = new Array(3);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n    }\n    return b;\n};\n\n\nvec3.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    return b;\n};\n\n\nvec3.add = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] += b[0];\n        a[1] += b[1];\n        a[2] += b[2];\n        return a;\n    }\n    c[0] = a[0] + b[0];\n    c[1] = a[1] + b[1];\n    c[2] = a[2] + b[2];\n    return c;\n};\n\n\nvec3.subtract = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] -= b[0];\n        a[1] -= b[1];\n        a[2] -= b[2];\n        return a;\n    }\n    c[0] = a[0] - b[0];\n    c[1] = a[1] - b[1];\n    c[2] = a[2] - b[2];\n    return c;\n};\n\n\nvec3.negate = function (a, b) {\n    b || (b = a);\n    b[0] = -a[0];\n    b[1] = -a[1];\n    b[2] = -a[2];\n    return b;\n};\n\n\nvec3.scale = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] *= b;\n        a[1] *= b;\n        a[2] *= b;\n        return a;\n    }\n    c[0] = a[0] * b;\n    c[1] = a[1] * b;\n    c[2] = a[2] * b;\n    return c;\n};\n\n\nvec3.normalize = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return b;\n};\n\n\nvec3.normalize2 = function (a, i, b) {\n    var c = a[i],\n        d = a[i+1],\n        e = a[i+2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n};\n\n\nvec3.normalize3 = function (a, i, b, j) {\n    var c = a[i],\n        d = a[i+1],\n        e = a[i+2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[j] = c;\n            b[j+1] = d;\n            b[j+2] = e;\n            return b;\n        }\n    } else {\n        b[j] = 0;\n        b[j+1] = 0;\n        b[j+2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[j] = c * g;\n    b[j+1] = d * g;\n    b[j+2] = e * g;\n};\n\n\nvec3.normalize4 = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    var dd = g;\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return dd;\n};\n\n\nvec3.cross = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1];\n    a = a[2];\n    var g = b[0],\n        f = b[1];\n    b = b[2];\n    c[0] = e * b - a * f;\n    c[1] = a * g - d * b;\n    c[2] = d * f - e * g;\n    return c;\n};\n\n\nvec3.length = function (a) {\n    var b = a[0],\n        c = a[1];\n    a = a[2];\n    return Math.sqrt(b * b + c * c + a * a);\n};\n\n\nvec3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\n\nvec3.dot2 = function (a, b, i) {\n    return a[0] * b[i] + a[1] * b[i+1] + a[2] * b[i+2];\n};\n\n\nvec3.dot3 = function (a, i, b, j) {\n    return a[i] * b[j] + a[i+1] * b[j+1] + a[i+2] * b[j+2];\n};\n\nvec3.distance = function (a, b) {\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    var dz = b[2] - a[2];\n    return Math.sqrt(dx*dx + dy*dy + dz*dz);\n};\n\nvec3.squareDistance = function (a, b) {\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    var dz = b[2] - a[2];\n    return dx*dx + dy*dy + dz*dz;\n};\n\n\nvec3.direction = function (a, b, c) {\n    c || (c = a);\n    var d = a[0] - b[0],\n        e = a[1] - b[1];\n    a = a[2] - b[2];\n    b = Math.sqrt(d * d + e * e + a * a);\n    if (!b) {\n        c[0] = 0;\n        c[1] = 0;\n        c[2] = 0;\n        return c;\n    }\n    b = 1 / b;\n    c[0] = d * b;\n    c[1] = e * b;\n    c[2] = a * b;\n    return c;\n};\n\n\nvec3.lerp = function (a, b, c, d) {\n    d || (d = a);\n    d[0] = a[0] + c * (b[0] - a[0]);\n    d[1] = a[1] + c * (b[1] - a[1]);\n    d[2] = a[2] + c * (b[2] - a[2]);\n    return d;\n};\n\n\nvec3.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ']';\n};\n\n\nvar mat3 = {};\n\n\nmat3.create = function (a) {\n    var b = new Array(9);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n        b[4] = a[4];\n        b[5] = a[5];\n        b[6] = a[6];\n        b[7] = a[7];\n        b[8] = a[8];\n        b[9] = a[9];\n    }\n    return b;\n};\n\n\nmat3.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    return b;\n};\n\n\nmat3.identity = function (a) {\n    a[0] = 1;\n    a[1] = 0;\n    a[2] = 0;\n    a[3] = 0;\n    a[4] = 1;\n    a[5] = 0;\n    a[6] = 0;\n    a[7] = 0;\n    a[8] = 1;\n    return a;\n};\n\n\nmat3.transpose = function (a, b) {\n    if (!b || a == b) {\n        var c = a[1],\n            d = a[2],\n            e = a[5];\n        a[1] = a[3];\n        a[2] = a[6];\n        a[3] = c;\n        a[5] = a[7];\n        a[6] = d;\n        a[7] = e;\n        return a;\n    }\n    b[0] = a[0];\n    b[1] = a[3];\n    b[2] = a[6];\n    b[3] = a[1];\n    b[4] = a[4];\n    b[5] = a[7];\n    b[6] = a[2];\n    b[7] = a[5];\n    b[8] = a[8];\n    return b;\n};\n\n\nmat3.toMat4 = function (a, b) {\n    b || (b = mat4.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = 0;\n    b[4] = a[3];\n    b[5] = a[4];\n    b[6] = a[5];\n    b[7] = 0;\n    b[8] = a[6];\n    b[9] = a[7];\n    b[10] = a[8];\n    b[11] = 0;\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\nmat3.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    c[0] = a[0] * d + a[3] * e + a[6] * b;\n    c[1] = a[1] * d + a[4] * e + a[7] * b;\n    c[2] = a[2] * d + a[5] * e + a[8] * b;\n    return c;\n};\n\n\nmat3.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ']';\n};\n\n\nvar mat4 = {};\n\n\nmat4.create = function (a) {\n    var b = new Array(16);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n        b[4] = a[4];\n        b[5] = a[5];\n        b[6] = a[6];\n        b[7] = a[7];\n        b[8] = a[8];\n        b[9] = a[9];\n        b[10] = a[10];\n        b[11] = a[11];\n        b[12] = a[12];\n        b[13] = a[13];\n        b[14] = a[14];\n        b[15] = a[15];\n    }\n    return b;\n};\n\n\nmat4.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = a[12];\n    b[13] = a[13];\n    b[14] = a[14];\n    b[15] = a[15];\n    return b;\n};\n\n\nmat4.identity = function (a) {\n    a[0] = 1;\n    a[1] = 0;\n    a[2] = 0;\n    a[3] = 0;\n    a[4] = 0;\n    a[5] = 1;\n    a[6] = 0;\n    a[7] = 0;\n    a[8] = 0;\n    a[9] = 0;\n    a[10] = 1;\n    a[11] = 0;\n    a[12] = 0;\n    a[13] = 0;\n    a[14] = 0;\n    a[15] = 1;\n    return a;\n};\n\n\nmat4.transpose = function (a, b) {\n    if (!b || a == b) {\n        var c = a[1],\n            d = a[2],\n            e = a[3],\n            g = a[6],\n            f = a[7],\n            h = a[11];\n        a[1] = a[4];\n        a[2] = a[8];\n        a[3] = a[12];\n        a[4] = c;\n        a[6] = a[9];\n        a[7] = a[13];\n        a[8] = d;\n        a[9] = g;\n        a[11] = a[14];\n        a[12] = e;\n        a[13] = f;\n        a[14] = h;\n        return a;\n    }\n    b[0] = a[0];\n    b[1] = a[4];\n    b[2] = a[8];\n    b[3] = a[12];\n    b[4] = a[1];\n    b[5] = a[5];\n    b[6] = a[9];\n    b[7] = a[13];\n    b[8] = a[2];\n    b[9] = a[6];\n    b[10] = a[10];\n    b[11] = a[14];\n    b[12] = a[3];\n    b[13] = a[7];\n    b[14] = a[11];\n    b[15] = a[15];\n    return b;\n};\n\n\nmat4.determinant = function (a) {\n    var b = a[0],\n        c = a[1],\n        d = a[2],\n        e = a[3],\n        g = a[4],\n        f = a[5],\n        h = a[6],\n        i = a[7],\n        j = a[8],\n        k = a[9],\n        l = a[10],\n        o = a[11],\n        m = a[12],\n        n = a[13],\n        p = a[14];\n    a = a[15];\n    return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;\n};\n\n\nmat4.inverse = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = a[4],\n        h = a[5],\n        i = a[6],\n        j = a[7],\n        k = a[8],\n        l = a[9],\n        o = a[10],\n        m = a[11],\n        n = a[12],\n        p = a[13],\n        r = a[14],\n        s = a[15],\n        A = c * h - d * f,\n        B = c * i - e * f,\n        t = c * j - g * f,\n        u = d * i - e * h,\n        v = d * j - g * h,\n        w = e * j - g * i,\n        x = k * p - l * n,\n        y = k * r - o * n,\n        z = k * s - m * n,\n        C = l * r - o * p,\n        D = l * s - m * p,\n        E = o * s - m * r,\n        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);\n    b[0] = (h * E - i * D + j * C) * q;\n    b[1] = (-d * E + e * D - g * C) * q;\n    b[2] = (p * w - r * v + s * u) * q;\n    b[3] = (-l * w + o * v - m * u) * q;\n    b[4] = (-f * E + i * z - j * y) * q;\n    b[5] = (c * E - e * z + g * y) * q;\n    b[6] = (-n * w + r * t - s * B) * q;\n    b[7] = (k * w - o * t + m * B) * q;\n    b[8] = (f * D - h * z + j * x) * q;\n    b[9] = (-c * D + d * z - g * x) * q;\n    b[10] = (n * v - p * t + s * A) * q;\n    b[11] = (-k * v + l * t - m * A) * q;\n    b[12] = (-f * C + h * y - i * x) * q;\n    b[13] = (c * C - d * y + e * x) * q;\n    b[14] = (-n * u + p * B - r * A) * q;\n    b[15] = (k * u - l * B + o * A) * q;\n    return b;\n};\n\n\nmat4.toRotationMat = function (a, b) {\n    b || (b = mat4.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\n\nmat4.toMat3 = function (a, b) {\n    b || (b = mat3.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[4];\n    b[4] = a[5];\n    b[5] = a[6];\n    b[6] = a[8];\n    b[7] = a[9];\n    b[8] = a[10];\n    return b;\n};\n\n\nmat4.toInverseMat3 = function (a, b) {\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[4],\n        f = a[5],\n        h = a[6],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = k * f - h * j,\n        o = -k * g + h * i,\n        m = j * g - f * i,\n        n = c * l + d * o + e * m;\n    if (!n) return null;\n    n = 1 / n;\n    b || (b = mat3.create());\n    b[0] = l * n;\n    b[1] = (-k * d + e * j) * n;\n    b[2] = (h * d - e * f) * n;\n    b[3] = o * n;\n    b[4] = (k * c - e * i) * n;\n    b[5] = (-h * c + e * g) * n;\n    b[6] = m * n;\n    b[7] = (-j * c + d * i) * n;\n    b[8] = (f * c - d * g) * n;\n    return b;\n};\n\n\nmat4.multiply = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1],\n        g = a[2],\n        f = a[3],\n        h = a[4],\n        i = a[5],\n        j = a[6],\n        k = a[7],\n        l = a[8],\n        o = a[9],\n        m = a[10],\n        n = a[11],\n        p = a[12],\n        r = a[13],\n        s = a[14];\n    a = a[15];\n    var A = b[0],\n        B = b[1],\n        t = b[2],\n        u = b[3],\n        v = b[4],\n        w = b[5],\n        x = b[6],\n        y = b[7],\n        z = b[8],\n        C = b[9],\n        D = b[10],\n        E = b[11],\n        q = b[12],\n        F = b[13],\n        G = b[14];\n    b = b[15];\n    c[0] = A * d + B * h + t * l + u * p;\n    c[1] = A * e + B * i + t * o + u * r;\n    c[2] = A * g + B * j + t * m + u * s;\n    c[3] = A * f + B * k + t * n + u * a;\n    c[4] = v * d + w * h + x * l + y * p;\n    c[5] = v * e + w * i + x * o + y * r;\n    c[6] = v * g + w * j + x * m + y * s;\n    c[7] = v * f + w * k + x * n + y * a;\n    c[8] = z * d + C * h + D * l + E * p;\n    c[9] = z * e + C * i + D * o + E * r;\n    c[10] = z *\n        g + C * j + D * m + E * s;\n    c[11] = z * f + C * k + D * n + E * a;\n    c[12] = q * d + F * h + G * l + b * p;\n    c[13] = q * e + F * i + G * o + b * r;\n    c[14] = q * g + F * j + G * m + b * s;\n    c[15] = q * f + F * k + G * n + b * a;\n    return c;\n};\n\n\nmat4.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];\n    c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];\n    c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];\n    return c;\n};\n\n\nmat4.multiplyVec4 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1],\n        g = b[2];\n    b = b[3];\n    c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;\n    c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;\n    c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;\n    c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;\n    return c;\n};\n\n\nmat4.translate = function (a, b, c) {\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    if (!c || a == c) {\n        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];\n        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];\n        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];\n        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];\n        return a;\n    }\n    var g = a[0],\n        f = a[1],\n        h = a[2],\n        i = a[3],\n        j = a[4],\n        k = a[5],\n        l = a[6],\n        o = a[7],\n        m = a[8],\n        n = a[9],\n        p = a[10],\n        r = a[11];\n    c[0] = g;\n    c[1] = f;\n    c[2] = h;\n    c[3] = i;\n    c[4] = j;\n    c[5] = k;\n    c[6] = l;\n    c[7] = o;\n    c[8] = m;\n    c[9] = n;\n    c[10] = p;\n    c[11] = r;\n    c[12] = g * d + j * e + m * b + a[12];\n    c[13] = f * d + k * e + n * b + a[13];\n    c[14] = h * d + l * e + p * b + a[14];\n    c[15] = i * d + o * e + r * b + a[15];\n    return c;\n};\n\n\nmat4.scale = function (a, b, c) {\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    if (!c || a == c) {\n        a[0] *= d;\n        a[1] *= d;\n        a[2] *= d;\n        a[3] *= d;\n        a[4] *= e;\n        a[5] *= e;\n        a[6] *= e;\n        a[7] *= e;\n        a[8] *= b;\n        a[9] *= b;\n        a[10] *= b;\n        a[11] *= b;\n        return a;\n    }\n    c[0] = a[0] * d;\n    c[1] = a[1] * d;\n    c[2] = a[2] * d;\n    c[3] = a[3] * d;\n    c[4] = a[4] * e;\n    c[5] = a[5] * e;\n    c[6] = a[6] * e;\n    c[7] = a[7] * e;\n    c[8] = a[8] * b;\n    c[9] = a[9] * b;\n    c[10] = a[10] * b;\n    c[11] = a[11] * b;\n    c[12] = a[12];\n    c[13] = a[13];\n    c[14] = a[14];\n    c[15] = a[15];\n    return c;\n};\n\n\nmat4.rotate = function (a, b, c, d) {\n    var e = c[0],\n        g = c[1];\n    c = c[2];\n    var f = Math.sqrt(e * e + g * g + c * c);\n    if (!f) return null;\n    if (f != 1) {\n        f = 1 / f;\n        e *= f;\n        g *= f;\n        c *= f;\n    }\n    var h = Math.sin(b),\n        i = Math.cos(b),\n        j = 1 - i;\n    b = a[0];\n    f = a[1];\n    var k = a[2],\n        l = a[3],\n        o = a[4],\n        m = a[5],\n        n = a[6],\n        p = a[7],\n        r = a[8],\n        s = a[9],\n        A = a[10],\n        B = a[11],\n        t = e * e * j + i,\n        u = g * e * j + c * h,\n        v = c * e * j - g * h,\n        w = e * g * j - c * h,\n        x = g * g * j + i,\n        y = c * g * j + e * h,\n        z = e * c * j + g * h;\n    e = g * c * j - e * h;\n    g = c * c * j + i;\n    if (d) {\n        if (a != d) {\n            d[12] = a[12];\n            d[13] = a[13];\n            d[14] = a[14];\n            d[15] = a[15];\n        }\n    } else d = a;\n    d[0] = b * t + o * u + r * v;\n    d[1] = f * t + m * u + s * v;\n    d[2] = k * t + n * u + A * v;\n    d[3] = l * t + p * u + B *\n        v;\n    d[4] = b * w + o * x + r * y;\n    d[5] = f * w + m * x + s * y;\n    d[6] = k * w + n * x + A * y;\n    d[7] = l * w + p * x + B * y;\n    d[8] = b * z + o * e + r * g;\n    d[9] = f * z + m * e + s * g;\n    d[10] = k * z + n * e + A * g;\n    d[11] = l * z + p * e + B * g;\n    return d;\n};\n\n\nmat4.rotateX = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[4],\n        g = a[5],\n        f = a[6],\n        h = a[7],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = a[11];\n    if (c) {\n        if (a != c) {\n            c[0] = a[0];\n            c[1] = a[1];\n            c[2] = a[2];\n            c[3] = a[3];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[4] = e * b + i * d;\n    c[5] = g * b + j * d;\n    c[6] = f * b + k * d;\n    c[7] = h * b + l * d;\n    c[8] = e * -d + i * b;\n    c[9] = g * -d + j * b;\n    c[10] = f * -d + k * b;\n    c[11] = h * -d + l * b;\n    return c;\n};\n\n\nmat4.rotateY = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[0],\n        g = a[1],\n        f = a[2],\n        h = a[3],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = a[11];\n    if (c) {\n        if (a != c) {\n            c[4] = a[4];\n            c[5] = a[5];\n            c[6] = a[6];\n            c[7] = a[7];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[0] = e * b + i * -d;\n    c[1] = g * b + j * -d;\n    c[2] = f * b + k * -d;\n    c[3] = h * b + l * -d;\n    c[8] = e * d + i * b;\n    c[9] = g * d + j * b;\n    c[10] = f * d + k * b;\n    c[11] = h * d + l * b;\n    return c;\n};\n\n\nmat4.rotateZ = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[0],\n        g = a[1],\n        f = a[2],\n        h = a[3],\n        i = a[4],\n        j = a[5],\n        k = a[6],\n        l = a[7];\n    if (c) {\n        if (a != c) {\n            c[8] = a[8];\n            c[9] = a[9];\n            c[10] = a[10];\n            c[11] = a[11];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[0] = e * b + i * d;\n    c[1] = g * b + j * d;\n    c[2] = f * b + k * d;\n    c[3] = h * b + l * d;\n    c[4] = e * -d + i * b;\n    c[5] = g * -d + j * b;\n    c[6] = f * -d + k * b;\n    c[7] = h * -d + l * b;\n    return c;\n};\n\n\nmat4.frustum = function (a, b, c, d, e, g, f) {\n    f || (f = mat4.create());\n    var h = b - a,\n        i = d - c,\n        j = g - e;\n    f[0] = e * 2 / h;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = e * 2 / i;\n    f[6] = 0;\n    f[7] = 0;\n    f[8] = (b + a) / h;\n    f[9] = (d + c) / i;\n    f[10] = -(g + e) / j;\n    f[11] = -1;\n    f[12] = 0;\n    f[13] = 0;\n    f[14] = -(g * e * 2) / j;\n    f[15] = 0;\n    return f;\n};\n\n\nmat4.perspective = function (a, b, c, d, e) {\n    a = c * Math.tan(a * Math.PI / 360);\n    b = a * b;\n    return mat4.frustum(-b, b, -a, a, c, d, e);\n};\n\n\nmat4.ortho = function (a, b, c, d, e, g, f) {\n    f || (f = mat4.create());\n    var h = b - a,\n        i = d - c,\n        j = g - e;\n    f[0] = 2 / h;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = 2 / i;\n    f[6] = 0;\n    f[7] = 0;\n    f[8] = 0;\n    f[9] = 0;\n    f[10] = -2 / j;\n    f[11] = 0;\n    f[12] = -(a + b) / h;\n    f[13] = -(d + c) / i;\n    f[14] = -(g + e) / j;\n    f[15] = 1;\n    return f;\n};\n\n\nmat4.lookAt = function (a, b, c, d) {\n    d || (d = mat4.create());\n    var e = a[0],\n        g = a[1];\n    a = a[2];\n    var f = c[0],\n        h = c[1],\n        i = c[2];\n    c = b[1];\n    var j = b[2];\n    if (e == b[0] && g == c && a == j) return mat4.identity(d);\n    var k, l, o, m;\n    c = e - b[0];\n    j = g - b[1];\n    b = a - b[2];\n    m = 1 / Math.sqrt(c * c + j * j + b * b);\n    c *= m;\n    j *= m;\n    b *= m;\n    k = h * b - i * j;\n    i = i * c - f * b;\n    f = f * j - h * c;\n    m = Math.sqrt(k * k + i * i + f * f);\n    if (m) {\n        m = 1 / m;\n        k *= m;\n        i *= m;\n        f *= m;\n    } else f = i = k = 0;\n    h = j * f - b * i;\n    l = b * k - c * f;\n    o = c * i - j * k;\n    m = Math.sqrt(h * h + l * l + o * o);\n    if (m) {\n        m = 1 / m;\n        h *= m;\n        l *= m;\n        o *= m;\n    } else o = l = h = 0;\n    d[0] = k;\n    d[1] = h;\n    d[2] = c;\n    d[3] = 0;\n    d[4] = i;\n    d[5] = l;\n    d[6] = j;\n    d[7] = 0;\n    d[8] = f;\n    d[9] =\n        o;\n    d[10] = b;\n    d[11] = 0;\n    d[12] = -(k * e + i * g + f * a);\n    d[13] = -(h * e + l * g + o * a);\n    d[14] = -(c * e + j * g + b * a);\n    d[15] = 1;\n    return d;\n};\n\n\nmat4.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ']';\n};\n\n\nvar quat4 = {};\n\n\nquat4.create = function (a) {\n    var b = new Array(4);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n    }\n    return b;\n};\n\n\nquat4.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    return b;\n};\n\n\nquat4.calculateW = function (a, b) {\n    var c = a[0],\n        d = a[1],\n        e = a[2];\n    if (!b || a == b) {\n        a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n        return a;\n    }\n    b[0] = c;\n    b[1] = d;\n    b[2] = e;\n    b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n    return b;\n};\n\n\nquat4.inverse = function (a, b) {\n    if (!b || a == b) {\n        a[0] *= 1;\n        a[1] *= 1;\n        a[2] *= 1;\n        return a;\n    }\n    b[0] = -a[0];\n    b[1] = -a[1];\n    b[2] = -a[2];\n    b[3] = a[3];\n    return b;\n};\n\n\nquat4.length = function (a) {\n    var b = a[0],\n        c = a[1],\n        d = a[2];\n    a = a[3];\n    return Math.sqrt(b * b + c * c + d * d + a * a);\n};\n\n\nquat4.normalize = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = Math.sqrt(c * c + d * d + e * e + g * g);\n    if (f == 0) {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        b[3] = 0;\n        return b;\n    }\n    f = 1 / f;\n    b[0] = c * f;\n    b[1] = d * f;\n    b[2] = e * f;\n    b[3] = g * f;\n    return b;\n};\n\n\nquat4.multiply = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1],\n        g = a[2];\n    a = a[3];\n    var f = b[0],\n        h = b[1],\n        i = b[2];\n    b = b[3];\n    c[0] = d * b + a * f + e * i - g * h;\n    c[1] = e * b + a * h + g * f - d * i;\n    c[2] = g * b + a * i + d * h - e * f;\n    c[3] = a * b - d * f - e * h - g * i;\n    return c;\n};\n\n\nquat4.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1],\n        g = b[2];\n    b = a[0];\n    var f = a[1],\n        h = a[2];\n    a = a[3];\n    var i = a * d + f * g - h * e,\n        j = a * e + h * d - b * g,\n        k = a * g + b * e - f * d;\n    d = -b * d - f * e - h * g;\n    c[0] = i * a + d * -b + j * -h - k * -f;\n    c[1] = j * a + d * -f + k * -b - i * -h;\n    c[2] = k * a + d * -h + i * -f - j * -b;\n    return c;\n};\n\n\nquat4.toMat3 = function (a, b) {\n    b || (b = mat3.create());\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = c + c,\n        h = d + d,\n        i = e + e,\n        j = c * f,\n        k = c * h;\n    c = c * i;\n    var l = d * h;\n    d = d * i;\n    e = e * i;\n    f = g * f;\n    h = g * h;\n    g = g * i;\n    b[0] = 1 - (l + e);\n    b[1] = k - g;\n    b[2] = c + h;\n    b[3] = k + g;\n    b[4] = 1 - (j + e);\n    b[5] = d - f;\n    b[6] = c - h;\n    b[7] = d + f;\n    b[8] = 1 - (j + l);\n    return b;\n};\n\n\nquat4.toMat4 = function (a, b) {\n    b || (b = mat4.create());\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = c + c,\n        h = d + d,\n        i = e + e,\n        j = c * f,\n        k = c * h;\n    c = c * i;\n    var l = d * h;\n    d = d * i;\n    e = e * i;\n    f = g * f;\n    h = g * h;\n    g = g * i;\n    b[0] = 1 - (l + e);\n    b[1] = k - g;\n    b[2] = c + h;\n    b[3] = 0;\n    b[4] = k + g;\n    b[5] = 1 - (j + e);\n    b[6] = d - f;\n    b[7] = 0;\n    b[8] = c - h;\n    b[9] = d + f;\n    b[10] = 1 - (j + l);\n    b[11] = 0;\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\n\nquat4.slerp = function (a, b, c, d) {\n    d || (d = a);\n    var e = c;\n    if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;\n    d[0] = 1 - c * a[0] + e * b[0];\n    d[1] = 1 - c * a[1] + e * b[1];\n    d[2] = 1 - c * a[2] + e * b[2];\n    d[3] = 1 - c * a[3] + e * b[3];\n    return d;\n};\n\n\nquat4.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ']';\n};\n\nexport {vec2, vec3, vec4, mat3, mat4};\n\n","\nvar utilsUrl = {};\n\n\nutilsUrl.isSameOrigin = function(url) {\n    if (typeof url !== 'string') {\n        return false;\n    }\n    var docHost = document.location.hostname;\n    var parser = utilsUrl.parse(url);\n    return parser['hostname'] === docHost;\n};\n\n\nutilsUrl.parse = function(url) {\n    if (typeof url !== 'string') {\n        return null;\n    }\n\n    var parser = document.createElement('a');\n    parser['href'] = url;\n    return parser;\n};\n\n\nutilsUrl.getParamsFromUrl = function(url) {\n    var parser = utilsUrl.parse(url);\n    var queryString = {};\n    var query = parser['search'].substring(1);\n    var vars = query.split('&');\n    if (!(vars.length == 1 && vars[0] == '')) {\n        for (var i=0; i < vars.length; i++) {\n            var pair = vars[i].split('=');\n            if (typeof queryString[pair[0]] === 'undefined') {\n                queryString[pair[0]] = pair[1];\n            } else if (typeof queryString[pair[0]] === 'string') {\n                var arr = [ queryString[pair[0]], pair[1] ];\n                queryString[pair[0]] = arr;\n            } else {\n                queryString[pair[0]].push(pair[1]);\n            }\n        }\n    }\n    return queryString;\n};\n\n\nutilsUrl.getHost = function(url) {\n    var location = document.createElement('a');\n    location.href = url;\n    return location.hostname; \n};\n\n\nutilsUrl.getSchema = function(url) {\n    //if (window.location.href.indexOf(\"file://\") != -1) {\n    if (url.indexOf('http://') != -1) {\n        return 'http:';\n    } else if (url.indexOf('https://') != -1) {\n        return 'https:';\n    } else {\n        var location = document.createElement('a');\n        location.href = url;\n        return location.protocol;\n    }\n};\n\n\nutilsUrl.getOrigin = function(url) {\n    var location = document.createElement('a');\n    location.href = url;\n\n    if (!location.origin) {  //IE11 hack\n      return location.protocol + \"//\" + location.hostname + (location.port ? ':' + location.port: '');\n    }\n\n    return location.origin; \n};\n\n\nutilsUrl.getBase = function(url) {\n    return url.split('?')[0].split('/').slice(0, -1).join('/')+'/';\n};\n\n\nutilsUrl.makeAbsolute = function(href) {\n    var link = document.createElement(\"a\");\n    link.href = href;\n    return link.href;\n};\n\nutilsUrl.getProcessUrl = function(url, originUrl) {\n    if (!url || !originUrl) {\n        return url;\n    }\n\n    url = url.trim();\n    originUrl= originUrl.trim();\n    var baseUrl = utilsUrl.getBase(originUrl);\n    var baseUrlSchema = utilsUrl.getSchema(originUrl);\n    var baseUrlOrigin = utilsUrl.getOrigin(originUrl); \n   \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return baseUrlOrigin + url;\n    } else {  //relative\n        return baseUrl + url; \n    }\n};\n\n\nexport {utilsUrl};\n","\nimport {math as math_} from './math';\nimport {utilsUrl as utilsUrl_} from './url';\n\n//get rid of compiler mess\nvar math = math_;\nvar utilsUrl = utilsUrl_;\n\n\nvar utils = {};\nutils.useCredentials = false;\nutils.instanceCounter = 0;\n\n\nutils.validateBool = function(value, defaultValue) {\n    if (typeof value === 'boolean') {\n        return value;\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.validateNumber = function(value, minValue, maxValue, defaultValue) {\n    if (typeof value === 'number') {\n        return math.clamp(value, minValue, maxValue);\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.validateNumberArray = function(array, arraySize, minValues, maxValues, defaultValues) {\n    if (Array.isArray(array) && array.length == arraySize) {\n        for (var i = 0; i < arraySize; i++) {\n            array[i] = math.clamp(array[i], minValues[i], maxValues[i]);\n        }\n        return array;\n    } else {\n        return defaultValues;\n    }\n};\n\n\nutils.validateString = function(value, defaultValue) {\n    if (typeof value === 'string') {\n        return value;\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.padNumber = function(n, width) {\n    var z = '0';\n\n    if (n < 0) {\n        n = (-n) + '';\n        width--;     //7\n        return n.length >= width ? ('-' + n) : '-' + (new Array(width - n.length + 1).join(z) + n);\n    } else {\n        n = n + '';\n        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n    }\n};\n\n\nutils.decodeFloat16 = function(binary) {\n    var exponent = (binary & 0x7C00) >> 10;\n    var fraction = binary & 0x03FF;\n    return (binary >> 15 ? -1 : 1) * (\n        exponent ?\n        (\n            exponent === 0x1F ?\n            fraction ? NaN : Infinity :\n            Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n        ) :\n        6.103515625e-5 * (fraction / 0x400)\n    );\n};\n\n\nutils.simpleFmtObj = (function obj(str, obj) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    return str.replace(/\\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\\}/g, function(s, match) {\n        return (match in obj ? obj[match] : s);\n    });\n});\n\n\nutils.simpleWikiLinks = (function obj(str, plain) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    var str2 = utils.simpleFmtObj(str, {'copy':'&copy;', 'Y': (new Date().getFullYear())}); \n    \n    return str2.replace(/\\[([^\\]]*)\\]/g, function(s, match) {\n        match  = match.trim();\n        var urls = match.split(' ');//, 1);\n        \n        if (urls[0].indexOf('//') != -1) {\n            if (plain) {\n                if (urls.length > 1) {\n                    return '' + match.substring(urls[0].length);\n                } else {\n                    return '' + urls[0];\n                }\n            } else {\n                if (urls.length > 1) {\n                    return '<a href=' + urls[0] + ' target=\"blank\">' + match.substring(urls[0].length)+'</a>';\n                } else {\n                    return '<a href=' + urls[0] + ' target=\"blank\">' + urls[0]+'</a>';\n                }\n            }\n        }\n        \n        return match;\n    });\n});\n\n\nutils.simpleFmtObjOrCall = (function obj(str, obj, call) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    return str.replace(/\\{([$a-zA-Z(-9][$a-zA-Z(-9]*)\\}/g, function(s, match) {\n        return (match in obj ? obj[match] : call(match));\n    });\n});\n\n\nutils.getABGRFromHexaCode = (function(code) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(code);\n\n    return result ?\n    [ parseInt(result[4], 16),\n        parseInt(result[3], 16),\n        parseInt(result[2], 16),\n        parseInt(result[1], 16)]\n    : [0,0,0,255];\n});\n\n\nutils.stringifyFunction = (function(fn) {\n    // Stringify the code\n    return '(' + fn + ').call(self);';\n});\n\n\nutils.isPowerOfTwo = (function(value) {\n    return (value & (value - 1)) === 0 && value !== 0;\n});\n\n\nutils.nearestPowerOfTwo = (function(value) {\n    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));\n});   \n\n\nutils.fitToPowerOfTwo = (function(value) {\n    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n});   \n\n\nutils.getHash = function(str) {\n    if (!str || str.length === 0) {\n        return 0;    \n    }\n\n    var hash = 0, c;\n    for (var i = 0, li = str.length; i < li; i++) {\n        c   = str.charCodeAt(i);\n        hash  = ((hash << 5) - hash) + c;\n        hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n};\n\n\nutils.convertRGB2YCbCr = function(r, g, b) {\n  return [( .299 * r + .587 * g  +  0.114 * b) + 0,\n          ( -.169 * r + -.331 * g +  0.500 * b) + 128,\n          ( .500 * r + -.419 * g +  -0.081 * b) + 128];\n};\n\n\nutils.convertYCbCr2RGB = function(y, cb, cr) {\n  return [1 * y +  0 * (cb-128)      +  1.4 * (cr-128),\n          1 * y +  -.343 * (cb-128)  +  -.711 * (cr-128),\n          1 * y +  1.765 * (cb-128)  +  0 * (cr-128)];\n};\n\n\nutils.convertHSL2RGB = function(h, s, l){\n   var r, g, b, m, c, x;\n\n    h /= 60;\n    if (h < 0) h = 6 - (-h % 6);\n    h %= 6;\n\n    s = Math.max(0, Math.min(1, s / 100));\n    l = Math.max(0, Math.min(1, l / 100));\n\n    c = (1 - Math.abs((2 * l) - 1)) * s;\n    x = c * (1 - Math.abs((h % 2) - 1));\n\n    if (h < 1) {\n        r = c, g = x, b = 0;\n    } else if (h < 2) {\n        r = x, g = c, b = 0;\n    } else if (h < 3) {\n        r = 0, g = c, b = x;\n    } else if (h < 4) {\n        r = 0, g = x, b = c;\n    } else if (h < 5) {\n        r = x, g = 0, b = c;\n    } else {\n        r = c, g = 0, b = x;\n    }\n\n    m = l - c / 2\n    \n    return [(r + m),\n            (g + m),\n            (b + m)];\n}\n\n\nutils.getHashColor = function(str) {\n    var h = utils.getHash(str);\n    var c = utils.convertRGB2YCbCr(h&255,(h>>8)&255,(h>>16)&255);\n    c[0] = math.clamp(c[0], 50, 200);\n    return utils.convertRGB2YCbCr(c[0],c[1],c[2]);\n};\n\n\nutils.getHashColor2 = function(counter) {\n    var h = Math.floor(counter / 18);\n    var l = 50;\n\n    if (h >= 1) {\n        if (h % 2) {\n            l = 50 + ((l * 10) % 30);\n        } else {\n            l = 50 - (((l-1) * 10) % 30);\n        }\n     }\n\n    h = (counter % 18) * 20;\n\n    return utils.convertHSL2RGB(h,100,l);\n};\n\n\nutils.loadText = function(path, onLoaded, onError, withCredentials, xhrParams) {\n    utils.loadJSON(path, onLoaded, onError, true, withCredentials, xhrParams);\n};\n\n\nutils.loadXML = function(path, onLoaded, onError, withCredentials, xhrParams) {\n    var onLoaded2 = (function(data){\n        var parser = new DOMParser();\n        data = parser.parseFromString(data, 'text/xml');\n        if (onLoaded) {\n            onLoaded(data);\n        }\n    });\n\n    utils.loadJSON(path, onLoaded2, onError, true, withCredentials, xhrParams);\n};\n\n\nutils.loadJSON = function(path, onLoaded, onError, skipParse, withCredentials, xhrParams) {\n    var xhr = new XMLHttpRequest();\n\n    //xhr.onload  = (function() {\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    onError(xhr.status);\n                }\n                break;\n            }\n    \n            var data = xhr.response;\n            var parsedData = data;\n                \n            if (!skipParse) {\n                try {\n                        //var parsedData = skipParse ? data : eval(\"(\"+data+\")\");\n                    parsedData = JSON.parse(data);\n                } catch(e) {\n                    // eslint-disable-next-line\n                    console.log('JSON Parse Error ('+path+'): ' + (e['message'] ? e['message'] : ''));\n                        \n                    if (onError ) {\n                        onError(xhr.status);\n                    }\n                \n                    return;\n                }\n            }\n                \n            if (onLoaded) {\n                onLoaded(parsedData);\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n\n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET',  path, true);\n    xhr.withCredentials = withCredentials;\n    \n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    if (xhrParams && xhrParams['charset']) {\n        xhr.overrideMimeType('text/xml; charset=' + xhrParams['charset']);\n        //xhr.setRequestHeader('Content-type', xhrParams['Content-type']);\n    }\n    \n    xhr.send('');\n};\n\n\nutils.loadBinary = function(path, onLoaded, onError, withCredentials, xhrParams, responseType) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    onError(xhr.status);\n                }\n                break;\n            }\n    \n            var abuffer = xhr.response;\n                    \n            if (!abuffer) {\n                if (onError) {\n                    onError();\n                }\n                break;\n            }\n                    \n                    //if (!responseType || responseType == \"arraybuffer\") {\n                        //var data = new DataView(abuffer);\n                    //} else {\n                      //  var data = abuffer;\n                    //}\n    \n            if (onLoaded) {\n                onLoaded(abuffer);\n            }\n    \n            break;\n    \n        default:\n    \n            if (onError) {\n                onError();\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n    \n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET', path, true);\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nutils.headRequest = function(url, onLoaded, onError, withCredentials, xhrParams) { \n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n            if (onLoaded != null) {\n                onLoaded(xhr.getAllResponseHeaders(), xhr.status);\n                    //onLoaded(xhr.getResponseHeader(\"X-VE-Tile-Info\"), xhr.status);\n            }\n            break;\n    \n        default:\n    \n            if (onError != null) {\n                onError();\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n\n    xhr.onerror  = (function() {\n        if (onError != null) {\n            onError();\n        }\n    }).bind(this);\n\n    xhr.open('HEAD', url, true);\n    //xhr.responseType = responseType ? responseType : \"arraybuffer\";\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nutils.loadImage = function(url, onload, onerror, withCredentials, direct) {\n    var image = new Image();\n    image.onerror = onerror;\n    image.onload = onload;\n\n    if (!direct){\n        image.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';\n    }\n\n    image.src = url;\n    return image;\n};\n\n\nutils.getParamsFromUrl = function(url) {\n    return utilsUrl.getParamsFromUrl(url);\n};\n\n\n//var textDecoderUtf8 = null; //(typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\nvar textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\n\nutils.unint8ArrayToString = function(array) {\n    if (textDecoderUtf8) {\n        return textDecoderUtf8.decode(array);\n    } else {\n//        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\n\n        /*\n        var buff = new Uint16Array(array.buffer, array.byteOffset, array.byteLength);\n        var getChar = String.fromCharCode;\n        //var buff2 = new Array(buff.length);\n        var str = '';\n\n        for (var i = 0, li = buff.length; i < li; i++) {\n            //buff2[i] = getChar(buff[i]);\n            str += getChar(buff[i]);\n        }\n\n        return str;\n        //return buff2.join('');\n        */\n\n        var s = '';\n        //var code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        var code_points2 = new Uint8Array(array.byteLength);\n        code_points2.set(array);\n        var code_points = new Uint32Array(code_points2.buffer);\n\n        for (var i = 0, li = code_points.length; i < li; ++i) {\n          var cp = code_points[i];\n          if (cp <= 0xFFFF) {\n            s += String.fromCharCode(cp);\n          } else {\n            cp -= 0x10000;\n            s += String.fromCharCode((cp >> 10) + 0xD800,\n                                     (cp & 0x3FF) + 0xDC00);\n          }\n        }\n        return s;\n\n    }\n}\n\n\nexport {utils};\n\n// only implement if no native implementation is available\n/*\nif (typeof Array.isArray === 'undefined') {\n  Array.isArray = (function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  });\n}*/\n"],"sourceRoot":""}