{"version":3,"sources":["webpack://vts/webpack/bootstrap","webpack://vts/./node_modules/earcut/src/earcut.js","webpack://vts/./node_modules/geographiclib/geographiclib.js","webpack://vts/./node_modules/melowntech-proj4/lib/Point.js","webpack://vts/./node_modules/melowntech-proj4/lib/Proj.js","webpack://vts/./node_modules/melowntech-proj4/lib/adjust_axis.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/adjust_lat.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/adjust_lon.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/adjust_zone.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/asinhy.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/asinz.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/clens.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/clens_cmplx.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/cosh.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/e0fn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/e1fn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/e2fn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/e3fn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/gN.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/gatg.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/hypot.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/imlfn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/iqsfnz.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/log1py.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/mlfn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/msfnz.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/phi2z.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/pj_enfn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/pj_inv_mlfn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/pj_mlfn.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/qsfnz.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/sign.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/sinh.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/srat.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/toPoint.js","webpack://vts/./node_modules/melowntech-proj4/lib/common/tsfnz.js","webpack://vts/./node_modules/melowntech-proj4/lib/constants/Datum.js","webpack://vts/./node_modules/melowntech-proj4/lib/constants/Ellipsoid.js","webpack://vts/./node_modules/melowntech-proj4/lib/constants/PrimeMeridian.js","webpack://vts/./node_modules/melowntech-proj4/lib/constants/units.js","webpack://vts/./node_modules/melowntech-proj4/lib/constants/values.js","webpack://vts/./node_modules/melowntech-proj4/lib/core.js","webpack://vts/./node_modules/melowntech-proj4/lib/datum.js","webpack://vts/./node_modules/melowntech-proj4/lib/datumUtils.js","webpack://vts/./node_modules/melowntech-proj4/lib/datum_transform.js","webpack://vts/./node_modules/melowntech-proj4/lib/defs.js","webpack://vts/./node_modules/melowntech-proj4/lib/deriveConstants.js","webpack://vts/./node_modules/melowntech-proj4/lib/extend.js","webpack://vts/./node_modules/melowntech-proj4/lib/global.js","webpack://vts/./node_modules/melowntech-proj4/lib/index.js","webpack://vts/./node_modules/melowntech-proj4/lib/match.js","webpack://vts/./node_modules/melowntech-proj4/lib/parseCode.js","webpack://vts/./node_modules/melowntech-proj4/lib/projString.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/aea.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/aeqd.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/cass.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/cea.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/eqc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/eqdc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/etmerc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/gauss.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/geocent.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/gnom.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/krovak.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/laea.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/lcc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/longlat.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/merc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/mill.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/moll.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/nzmg.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/omerc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/ortho.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/poly.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/qsc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/sinu.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/somerc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/stere.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/sterea.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/tmerc.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/utm.js","webpack://vts/./node_modules/melowntech-proj4/lib/projections/vandg.js","webpack://vts/./node_modules/melowntech-proj4/lib/transform.js","webpack://vts/./node_modules/melowntech-proj4/lib/version.js","webpack://vts/./node_modules/melowntech-proj4/projs.js","webpack://vts/./node_modules/mgrs/mgrs.js","webpack://vts/./node_modules/wkt-parser/index.js","webpack://vts/./node_modules/wkt-parser/parser.js","webpack://vts/./node_modules/wkt-parser/process.js","webpack://vts/./src/core/map/geodata-processor/worker-main.js","webpack://vts/./src/core/map/loader/worker-main.js","webpack://vts/./node_modules/worker-loader/dist/workers/InlineWorker.js","webpack://vts/./src/core/core.js","webpack://vts/./src/core/index.js","webpack://vts/./src/core/inspector/graphs.js","webpack://vts/./src/core/inspector/input.js","webpack://vts/./src/core/inspector/inspector.js","webpack://vts/./src/core/inspector/layers.js","webpack://vts/./src/core/inspector/replay.js","webpack://vts/./src/core/inspector/stats.js","webpack://vts/./src/core/inspector/stylesheets.js","webpack://vts/./src/core/interface.js","webpack://vts/./src/core/map/body.js","webpack://vts/./src/core/map/bound-layer.js","webpack://vts/./src/core/map/cache.js","webpack://vts/./src/core/map/camera.js","webpack://vts/./src/core/map/config.js","webpack://vts/./src/core/map/convert.js","webpack://vts/./src/core/map/credit.js","webpack://vts/./src/core/map/division-node.js","webpack://vts/./src/core/map/draw-tiles.js","webpack://vts/./src/core/map/draw.js","webpack://vts/./src/core/map/geodata-builder.js","webpack://vts/./src/core/map/geodata-geometry.js","webpack://vts/./src/core/map/geodata-import/3dtiles.js","webpack://vts/./src/core/map/geodata-import/3dtiles2.js","webpack://vts/./src/core/map/geodata-import/geojson.js","webpack://vts/./src/core/map/geodata-import/vts-geodata.js","webpack://vts/./src/core/map/geodata-processor/processor.js","webpack://vts/./src/core/map/geodata-view.js","webpack://vts/./src/core/map/geodata.js","webpack://vts/./src/core/map/interface.js","webpack://vts/./src/core/map/loader/loader.js","webpack://vts/./src/core/map/map.js","webpack://vts/./src/core/map/measure.js","webpack://vts/./src/core/map/mesh.js","webpack://vts/./src/core/map/metanode.js","webpack://vts/./src/core/map/metatile.js","webpack://vts/./src/core/map/position.js","webpack://vts/./src/core/map/refframe.js","webpack://vts/./src/core/map/render-slots.js","webpack://vts/./src/core/map/resource-node.js","webpack://vts/./src/core/map/resource-tree.js","webpack://vts/./src/core/map/srs.js","webpack://vts/./src/core/map/stats.js","webpack://vts/./src/core/map/stylesheet.js","webpack://vts/./src/core/map/submesh.js","webpack://vts/./src/core/map/subtexture.js","webpack://vts/./src/core/map/surface-sequence.js","webpack://vts/./src/core/map/surface-tile.js","webpack://vts/./src/core/map/surface-tree.js","webpack://vts/./src/core/map/surface.js","webpack://vts/./src/core/map/texture.js","webpack://vts/./src/core/map/trajectory.js","webpack://vts/./src/core/map/url.js","webpack://vts/./src/core/map/view.js","webpack://vts/./src/core/map/virtual-surface.js","webpack://vts/./src/core/renderer/bbox.js","webpack://vts/./src/core/renderer/camera.js","webpack://vts/./src/core/renderer/draw.js","webpack://vts/./src/core/renderer/geometry.js","webpack://vts/./src/core/renderer/gmap.js","webpack://vts/./src/core/renderer/gpu/bbox.js","webpack://vts/./src/core/renderer/gpu/device.js","webpack://vts/./src/core/renderer/gpu/font.js","webpack://vts/./src/core/renderer/gpu/group.js","webpack://vts/./src/core/renderer/gpu/mesh.js","webpack://vts/./src/core/renderer/gpu/pixel-line3.js","webpack://vts/./src/core/renderer/gpu/program.js","webpack://vts/./src/core/renderer/gpu/shaders.js","webpack://vts/./src/core/renderer/gpu/texture.js","webpack://vts/./src/core/renderer/init.js","webpack://vts/./src/core/renderer/interface.js","webpack://vts/./src/core/renderer/octree.js","webpack://vts/./src/core/renderer/renderer.js","webpack://vts/./src/core/renderer/rmap.js","webpack://vts/./src/core/utils/math.js","webpack://vts/./src/core/utils/matrix.js","webpack://vts/./src/core/utils/platform.js","webpack://vts/./src/core/utils/url.js","webpack://vts/./src/core/utils/utils.js"],"names":[],"mappings":";;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0EAA0E;AAC1E;AACA;AACA;;AAEA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS;AAChC,KAAK;AACL,2BAA2B,YAAY;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC;;AAEzC,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,4BAA4B,+BAA+B;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C;;AAE5C,uDAAuD;AACvD,uDAAuD;AACvD,uDAAuD;AACvD,uDAAuD;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;;AAEA,mBAAmB,iBAAiB;AACpC,uBAAuB,oBAAoB;AAC3C,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,2DAA2D;AACjE;AACA,MAAM,sDAAsD;AAC5D,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM,iDAAiD;AACvD;AACA;AACA,MAAM,6DAA6D;AACnE;AACA;AACA;AACA;AACA,MAAM,mDAAmD;AACzD;AACA,MAAM;AACN;AACA,MAAM,+DAA+D;AACrE,MAAM,+DAA+D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA,sBAAsB,cAAc;;AAEpC;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO,iBAAiB;AACvC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO,oCAAoC;AACzD;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO,wCAAwC,QAAQ;AACtE,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO,iCAAiC,OAAO,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE,QAAQ;AAC5E,eAAe;AACf,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO,qCAAqC;AAC1D;AACA,gCAAgC,+BAA+B,QAAQ;AACvE,aAAa,EAAE;AACf,8BAA8B,gBAAgB,GAAG,wBAAwB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,yBAAyB,WAAW;AACpC,yBAAyB,WAAW;AACpC,yBAAyB,WAAW;AACpC,yBAAyB,WAAW,OAAO;AAC3C;AACA,kBAAkB,WAAW,WAAW;AACxC,YAAY;AACZ;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,2DAA2D;AAC3D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,OAAO,OAAO,OAAO;AAChE,gBAAgB,QAAQ,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,gDAAgD;AAChD,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,QAAQ,+DAA+D;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,sDAAsD;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,uCAAuC;AACvC,6BAA6B;AAC7B;AACA;AACA,6CAA6C;AAC7C,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa,OAAO;AACnC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc,OAAO;AACpC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa,OAAO;AACnC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,OAAO;AACrC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,YAAY,OAAO;AAClC,0BAA0B,QAAQ,OAAO;AACzC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY,OAAO;AAClC,0BAA0B,QAAQ,OAAO;AACzC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY,OAAO;AAClC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY,OAAO;AAClC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,KAAK;AACL,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4CAA4C;AAC5C,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D,KAAK;AACL,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA,uBAAuB;AACvB;AACA;AACA,wCAAwC,iBAAiB;AACzD,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,wCAAwC,iBAAiB;AACzD,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA,+DAA+D;AAC/D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA,uBAAuB;AACvB,KAAK;AACL,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC,gBAAgB,WAAW;;AAE3B;AACA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,yBAAyB,YAAY,kBAAkB;AACvD,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,WAAW;AACX;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;;AAE1B;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B,6BAA6B;;AAE7B,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA,WAAW;AACX,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA,+DAA+D;AAC/D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA,+DAA+D;AAC/D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB,0DAA0D;AAC1D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,OAAO,uDAAuD;AAC3E;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,KAAK;AAClB;AACA,aAAa,OAAO;AACpB,oCAAoC;AACpC,qCAAqC;AACrC,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,mBAAmB;AACnB,aAAa,KAAK;AAClB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,sDAAsD;AACvE;AACA,gBAAgB;AAChB;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA,QAAQ,gEAAgE;AACxE;AACA,QAAQ;AACR,2BAA2B;AAC3B,QAAQ;AACR,4BAA4B;AAC5B;AACA,aAAa,OAAO,SAAS;AAC7B,gBAAgB;AAChB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D,KAAK;AACL,uBAAuB,oBAAoB;AAC3C;AACA,yCAAyC,wBAAwB;AACjE;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,sCAAsC;AACtC;AACA,qBAAqB;AACrB,sCAAsC;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ,+CAA+C;AACpE;AACA,eAAe,OAAO;AACtB;AACA,kBAAkB;AAClB,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;;AAErD;AACA;;AAEA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ,+CAA+C;AACpE;AACA,eAAe,OAAO;AACtB;AACA,kBAAkB;AAClB,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ,+CAA+C;AACpE;AACA,eAAe,OAAO;AACtB;AACA,+DAA+D;AAC/D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,iBAAiB;AACjB;AACA,aAAa,OAAO;AACpB,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO,mDAAmD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,KAAK;AACrB;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,QAAQ,sEAAsE;AAC9E,aAAa,OAAO,SAAS;AAC7B,gBAAgB;AAChB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB;AACA,aAAa,KAAK;AAClB;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB;AACA,aAAa,KAAK;AAClB;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB;AACA,aAAa,KAAK;AAClB;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAA6C;AACzD;AACA,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE;AACvE,gBAAgB;AAChB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA,6BAA6B;AAC7B;AACA,2CAA2C;AAC3C;AACA,4CAA4C;AAC5C,mDAAmD;AACnD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA,CAAC;AACD,MAAM,KAA0B;AAChC;AACA;AACA,GAAG,UAAU,IAA0C;AACvD;AACA,IAAI,iCAAwB,EAAE,mCAAE,YAAY,YAAY,EAAE;AAAA,oGAAC;AAC3D,GAAG,MAAM,EAGN;AACH,CAAC;;;;;;;;;;;;;ACtiGD;AAAA;AAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oDAAO;AAC1B;AACA;AACA,SAAS,oDAAO;AAChB;AACe,oEAAK,EAAC;;;;;;;;;;;;;ACjCrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACN;AACU;AAC+C;AACjD;AACV;AACA;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAK,CAAC,wDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAS;AACzB,YAAY,qEAAe;AAC3B,+BAA+B,sDAAK;;AAEpC,EAAE,uDAAM,aAAa;AACrB,EAAE,uDAAM,gBAAgB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,oDAAW;AACpC;AACe,yEAAU,EAAC;;;;;;;;;;;;;ACpE1B;AAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACnDD;AAAA;AAAA;AAA4C;AAClB;;AAEX;AACf,wBAAwB,yDAAO,cAAc,qDAAI;AACjD,CAAC;;;;;;;;;;;;;;;;;ACJ+C;AACtB;;AAEX;AACf,yBAAyB,qDAAG,cAAc,qDAAI,MAAM,wDAAM;AAC1D,CAAC;;;;;;;;;;;;;ACND;AAAA;AAAsC;;AAEvB;AACf;AACA,uBAAuB,2DAAU;;AAEjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACbD;AAAA;AAAA;AAA4B;AACE;;AAEf;AACf;AACA,MAAM,uDAAM,eAAe,sDAAK;;AAEhC;AACA,CAAC;;;;;;;;;;;;;ACRD;AAAe;AACf;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACLA;AAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACdD;AAAA;AAAA;AAA0B;AACA;;AAEX;AACf;AACA;AACA,mBAAmB,qDAAI;AACvB,mBAAmB,qDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC/BD;AAAe;AACf;AACA;AACA;AACA,C;;;;;;;;;;;;ACJA;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAe;AACf;AACA;AACA,C;;;;;;;;;;;;ACHA;AAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACdD;AAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACPD;AAAe;AACf;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACfA;AAAA;AAA4C;;AAE7B;AACf;AACA;AACA;AACA,mBAAmB,yDAAO;AAC1B;AACA;AACA,aAAa,yDAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;AC/BD;AAAe;AACf;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACLD;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAe;AACf;AACA;AACA,C;;;;;;;;;;;;ACHA;AAAA;AAA4C;;AAE7B;AACf;AACA;AACA,YAAY,yDAAO;AACnB,iBAAiB,SAAS;AAC1B;AACA,WAAW,yDAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AChBD;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAgC;AACU;;AAE1C;;AAEe;AACf;AACA;AACA,wBAAwB,GAAG,OAAO;AAClC;AACA;AACA;AACA;AACA,SAAS,wDAAO;AAChB;AACA,sBAAsB,uDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACrBD;AAAe;AACf;AACA;AACA;AACA,C;;;;;;;;;;;;ACJA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACTA;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAe;AACf;AACA;AACA;AACA,C;;;;;;;;;;;;ACJA;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACZA;AAAA;AAA4C;;AAE7B;AACf;AACA;AACA;AACA,0BAA0B,yDAAO;AACjC,CAAC;;;;;;;;;;;;;ACPD;AAAA;AAAA;AAC4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAA;AAC4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClQA;AAAA;AAAA;AAC4B;;AAE5B,wBAAwB;AACxB,iCAAiC;AACjC,+BAA+B;AAC/B,kCAAkC;AAClC,iCAAiC;AACjC,+BAA+B;AAC/B,8BAA8B;AAC9B,mCAAmC;AACnC,iCAAiC;AACjC,4BAA4B;AAC5B,oCAAoC;AACpC,4BAA4B;AAC5B,+BAA+B;;;;;;;;;;;;;ACf/B;AAAe;AACf,OAAO,iBAAiB;AACxB,YAAY;AACZ,CAAC,EAAC;;;;;;;;;;;;;ACHF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB;AACA;AACP;AACO;AACP;AACO;AACP;AACO;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACO;;;;;;;;;;;;;ACrBP;AAAA;AAAA;AAA0B;AACU;AACpC,YAAY,qDAAI;;AAEhB;AACA;AACA;AACA,uBAAuB,0DAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAS;AACpB;AACA;;AAEA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS,qDAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,oEAAK,E;;;;;;;;;;;;AC1EpB;AAAA;AAA8F;;AAE9F;AACA;;AAEA;AACA,qBAAqB,6DAAW;AAChC,GAAG;AACH,qBAAqB,2DAAS;AAC9B;;AAEA;AACA;AACA;AACA,uBAAuB,4DAAU;AACjC;AACA;AACA;AACA,yBAAyB,4DAAU;AACnC,+BAA+B,4DAAU;AACzC,+BAA+B,4DAAU;AACzC,+BAA+B,4DAAU;AACzC;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;AClCrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAa;AACsD;AAC5D;AACP;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,GAAG,gCAAgC,4DAAU;AAC7C;AACA,GAAG,gCAAgC,4DAAU;AAC7C;AACA,GAAG;AACH,gBAAgB;AAChB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,6BAA6B;;AAE7B,SAAS;AACT,cAAc;AACd,eAAe;AACf,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAO,wBAAwB,yDAAO;AACxD,gBAAgB,yDAAO;AACvB,GAAG,qBAAqB,yDAAO,uBAAuB,yDAAO;AAC7D,eAAe,yDAAO;AACtB,GAAG,uBAAuB,yDAAO,iBAAiB,yDAAO;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;;AAEA,QAAQ;AACR,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA;AACA,SAAS;AACT,YAAY;AACZ,YAAY;AACZ,WAAW;AACX,WAAW;AACX,YAAY;AACZ,WAAW;;AAEX;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,yDAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACO;;AAEP,qBAAqB,4DAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,yBAAyB,4DAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACO;;AAEP,qBAAqB,4DAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG,yBAAyB,4DAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACjPA;AAAA;AAAA;AAAuE;;AAEwD;AAC/H;AACA,mBAAmB,4DAAU,aAAa,4DAAU;AACpD;;AAEe;AACf;AACA,MAAM,iEAAa;AACnB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,4BAA4B,6DAAW,wBAAwB,6DAAW;AAC1E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU,wEAAoB;AAC9B;AACA;AACA,YAAY,qEAAiB;AAC7B;AACA;AACA,YAAY,uEAAmB;AAC/B;AACA,SAAS,wEAAoB;;AAE7B,CAAC;;;;;;;;;;;;;ACtCD;AAAA;AAAA;AAAA;AAA+B;AACM;AACR;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAS;AAC9B;AACA;AACA,qBAAqB,0DAAG;AACxB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,uDAAO;AACQ,mEAAI,EAAC;;;;;;;;;;;;;ACtDpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0D;AACQ;AACtC;;AAErB;AACP,iBAAiB;AACjB,iBAAiB;AACjB,0BAA0B;AAC1B;AACA;AACA,mBAAmB,uDAAK,SAAS,qDAAG,QAAQ,qDAAG;AAC/C;AACA;AACA,GAAG;AACH,sBAAsB;AACtB;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW;AACX,kBAAkB,sDAAK,CAAC,4DAAS;AACjC;AACA,gBAAgB,0DAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,uDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/CA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACbD;AAAe;AACf;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACVD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2B;AACD;AACE;AACU;AACZ;AACU;AACZ;AACQ;AACW;;AAE3C,6CAAK,wBAAwB;AAC7B,6CAAK,QAAQ,6CAAI;AACjB,6CAAK,aAAa,6CAAK;AACvB,6CAAK,SAAS,8CAAK;AACnB,6CAAK,WAAW,uDAAM;AACtB,6CAAK,QAAQ,6CAAI;AACjB,6CAAK,aAAa,kDAAS;AAC3B,6CAAK,QAAQ,4CAAI;AACjB,6CAAK,WAAW,gDAAO;AACvB,sDAAmB,CAAC,6CAAK;AACV,4GAAK,EAAC;;;;;;;;;;;;;ACpBrB;AAAA;AAAA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAA0B;AACG;AACM;AACnC;AACA;AACA;AACA;AACA,iBAAiB,6CAAI;AACrB;AACA,2J;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6CAAI;AACjB;AACA;AACA,aAAa,0DAAG;AAChB;AACA;AACA,aAAa,2DAAO;AACpB;AACA,GAAG;AACH;AACA;AACA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACnCrB;AAAA;AAAA;AAAA;AAAA;AAAuC;AACe;AAChB;AACV;;AAEb;AACf;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,qDAAG;AACzB,KAAK;AACL;AACA,sBAAsB,qDAAG;AACzB,KAAK;AACL;AACA,sBAAsB,qDAAG;AACzB,KAAK;AACL;AACA,wBAAwB,qDAAG;AAC3B,KAAK;AACL;AACA,uBAAuB,qDAAG;AAC1B,KAAK;AACL;AACA,uBAAuB,qDAAG;AAC1B,KAAK;AACL;AACA,uBAAuB,qDAAG;AAC1B,KAAK;AACL;AACA,mCAAmC,qDAAG;AACtC,KAAK;AACL;AACA,uBAAuB,qDAAG;AAC1B,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,sDAAK,CAAC,wDAAK;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC,qDAAG;AACnC,KAAK;AACL;AACA,eAAe,sDAAK,CAAC,gEAAa;AAClC,wDAAwD,qDAAG;AAC3D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACtID;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACM;AAC5C,aAAa,yDAAI,EAAE,4DAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEa;;AAEN;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACe;AACf;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACtCF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACA;AACU;AACV;AACM;;AAEnC;;AAEP,wCAAwC,uDAAK;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,6DAAK;AAClB,aAAa,6DAAK;;AAElB;AACA;AACA;AACA,aAAa,6DAAK;AAClB,aAAa,6DAAK;;AAElB;AACA;AACA;AACA,aAAa,6DAAK;;AAElB,wCAAwC,uDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;;AAEP;AACA;;AAEA;AACA;;AAEA,WAAW,6DAAK;AAChB;AACA,yBAAyB,kEAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,kEAAU;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA,YAAY,6DAAK;AACjB,eAAe,uDAAK;AACpB;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AChIF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACK;;AAEjB;AACA;AACA;AACA;AACA;AACJ;AACM;AACA;;;;AAI7B;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,aAAa,kEAAU;AACvB;AACA;AACA,sCAAsC,uDAAK;AAC3C;AACA,gCAAgC,yDAAO;AACvC,gCAAgC,yDAAO;AACvC;AACA;AACA,2CAA2C,uDAAK;AAChD;AACA,gCAAgC,yDAAO;AACvC,gCAAgC,yDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4DAAI;AACb,SAAS,4DAAI;AACb,SAAS,4DAAI;AACb,SAAS,4DAAI;AACb,sCAAsC,uDAAK;AAC3C;AACA,qBAAqB,4DAAI,iBAAiB,yDAAO;AACjD,oBAAoB,4DAAI;AACxB;AACA;AACA;AACA;AACA,2CAA2C,uDAAK;AAChD;AACA,qBAAqB,4DAAI,iBAAiB,yDAAO;AACjD,oBAAoB,4DAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAE;AACd,WAAW,0DAAE;AACb;AACA;AACA;AACA;AACA;AACA,mDAAmD,uDAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAO;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,uDAAK;AAC7B;AACA;AACA;AACA,YAAY,6DAAK;AACjB,kCAAkC,yDAAO;AACzC,2BAA2B,uDAAK;AAChC;AACA,gBAAgB,kEAAU;AAC1B;AACA;AACA,gBAAgB,kEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,cAAc,kEAAU;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,4DAAI;AACb,SAAS,4DAAI;AACb,SAAS,4DAAI;AACb,SAAS,4DAAI;AACb,sCAAsC,uDAAK;AAC3C;AACA,qBAAqB,4DAAI,iBAAiB,yDAAO;AACjD;AACA;AACA,YAAY,6DAAK;AACjB,YAAY,kEAAU;AACtB;AACA;AACA;AACA;AACA,2CAA2C,uDAAK;AAChD;AACA,qBAAqB,4DAAI,iBAAiB,yDAAO;AACjD;AACA;;AAEA,YAAY,6DAAK;AACjB,YAAY,kEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC9MF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACA;AACA;AACA;AACA;AACJ;AACgB;AACA;AACV;AACe;;AAE5C;AACP;AACA,cAAc,4DAAI;AAClB,cAAc,4DAAI;AAClB,cAAc,4DAAI;AAClB,cAAc,4DAAI;AAClB,wBAAwB,4DAAI;AAC5B;AACA;;AAEA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAU;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAE;AACf;AACA;AACA;AACA;AACA,sBAAsB,4DAAI;;AAE1B;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAK;AACpB,kCAAkC,yDAAO,KAAK,uDAAK;AACnD;AACA,YAAY,yDAAO;AACnB;AACA;AACA;AACA;AACA;AACA,cAAc,0DAAE;;AAEhB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAQ,kEAAU;AAClB,QAAQ,kEAAU;AAClB;;AAEA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC3GF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACV;AACA;AACE;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,6DAAK;AACnB;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAU;AACvB;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAK;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA,UAAU,kEAAU;AACpB;AACA;AACA;AACA,UAAU,8DAAM;AAChB,UAAU,kEAAU;AACpB;;AAEA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACrEF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACA;;AAEvC;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACO;;AAEP;AACA;;AAEA,aAAa,kEAAU;AACvB,aAAa,kEAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACO;;AAEP;AACA;;AAEA,QAAQ,kEAAU;AAClB,QAAQ,kEAAU;AAClB;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC/CF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACA;AACA;AACA;AACE;AACF;AACY;AACA;AACV;AACM;;AAEnC;;AAEP;AACA;AACA;AACA,wCAAwC,uDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAI;AAChB,YAAY,4DAAI;AAChB,YAAY,4DAAI;AAChB,YAAY,4DAAI;;AAEhB;AACA;;AAEA,aAAa,6DAAK;AAClB,aAAa,4DAAI;;AAEjB,wCAAwC,uDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAK;AACpB,eAAe,4DAAI;AACnB;AACA;AACA;AACA,aAAa,4DAAI;AACjB;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAI;AACjB;AACA;AACA,wBAAwB,kEAAU;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,kEAAU;AACpB,UAAU,kEAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,6DAAK;AACf,UAAU,kEAAU;AACpB;AACA;AACA;AACA;;AAEA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACpHF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEkC;AACE;AACE;AACJ;AACE;AACY;AACF;;AAEvC;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,4DAAI;AACd,4BAA4B,6DAAK;AACjC;;AAEO;AACP,WAAW,kEAAU;AACrB;;AAEA,OAAO,4DAAI;AACX;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,6DAAK;AACxC,OAAO,8DAAM;;AAEb,YAAY,mEAAW;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc,mEAAW;;AAEzB;AACA;AACA,mBAAmB,4DAAI;;AAEvB;AACA;AACA;AACA;;AAEA,qCAAqC,6DAAK;AAC1C;;AAEA,UAAU,kEAAU;AACpB,UAAU,4DAAI;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACpKF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AAClC;AACoD;;AAE7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAM,yCAAyC,wDAAM,aAAa,4DAAI;AAC7G;;AAEO;AACP;AACA;;AAEA,6DAA6D,wDAAM,aAAa,4DAAI,yCAAyC,yDAAO;AACpI;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,0CAA0C,wDAAM;AAChD,wBAAwB,OAAO;AAC/B,8BAA8B,4DAAI,4CAA4C,yDAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACnDF;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;;AAEA;AACA;AACA;AAC6B;AACA;AACtB;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACfD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACV;AACM;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP,qBAAqB;AACrB,WAAW;AACX,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kEAAU;;AAEnB;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,uDAAK;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,6DAAK;AACf;AACA,UAAU,kEAAU;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACvGF;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;;AAEvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,kEAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGyD;;AAEvB;AACU;;AAE9C;AACA;AACA;AACA;AACA;;AAEO;;AAEA;AACA;AACA;;AAEP;AACA;AACO;AACP;AACA,mBAAmB,yDAAO,IAAI,uDAAK;AACnC;AACA;AACA,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,6DAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;;AAEA,QAAQ,kEAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAK;AAC3C;AACA;AACA,UAAU,wDAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,yDAAO;AACjB;AACA;AACA;AACA,gBAAgB,yDAAO;AACvB;AACA;AACA;AACA,sBAAsB,uDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAK;AAClC;AACA;AACA;AACA;AACA,6BAA6B,uDAAK;AAClC;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAO;AACnB;AACA;AACA,aAAa,yDAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,kEAAU;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACzSF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACA;AACF;AACY;AACV;AACe;AAC5C;;AAEP;AACA,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB;AAChB,gBAAgB;AAChB,iBAAiB;AACjB,iBAAiB;AACjB,sBAAsB;AACtB,uBAAuB;;AAEvB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uDAAK;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,6DAAK;AACjB,YAAY,6DAAK;;AAEjB;AACA;AACA,YAAY,6DAAK;AACjB,YAAY,6DAAK;;AAEjB,YAAY,6DAAK;;AAEjB,wCAAwC,uDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;;AAEP;AACA;;AAEA;AACA,+CAA+C,uDAAK;AACpD,UAAU,4DAAI,SAAS,yDAAO,OAAO,uDAAK;AAC1C;;AAEA,qCAAqC,yDAAO;AAC5C;AACA,YAAY,uDAAK;AACjB,SAAS,6DAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAU;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,6DAAK;AACf;AACA;AACA;AACA;AACA;AACA,WAAW,yDAAO;AAClB;AACA,QAAQ,kEAAU;;AAElB;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC1IF;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;;AAEA;AACA;AACA;AAC6B;AACA;AACtB;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACfF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;;AAEU;AACV;AACA;AAC4B;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA,YAAY,qDAAG,eAAe,qDAAG,gBAAgB,qDAAG,gBAAgB,qDAAG;AACvE;AACA;;AAEA;AACA,+BAA+B,yDAAO,KAAK,uDAAK;AAChD;AACA;AACA;AACA;AACA,uCAAuC,kEAAU;AACjD,yDAAyD,wDAAM;AAC/D;AACA;AACA;AACA,eAAe,6DAAK;AACpB,uCAAuC,kEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;;AAEP;AACA;AACA;;AAEA;AACA,UAAU,yDAAO;AACjB;AACA;AACA;AACA,UAAU,6DAAK;AACf;AACA;AACA;AACA;AACA,QAAQ,kEAAU;;AAElB;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACnGF;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;;AAE9C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,aAAa,kEAAU;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;;AAEA,YAAY,kEAAU;AACtB;;AAEA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACnDF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACvC;AACmC;AAC1C;AACA;AACO;;AAEP;AACA;AACA;AACA;;AAEA,kBAAkB,kEAAU;AAC5B;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA,gCAAgC,uDAAK;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,uDAAK;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AClFF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,4DAAU;AACpC;AACA,kBAAkB;;AAElB;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,4DAAU;AAC3C;;AAEA;AACA;;AAEA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACjOF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACU;AACV;AACuB;;AAE3D;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,6DAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,6DAAK;AAClB,aAAa,6DAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kEAAU;AAC3B;AACA,iBAAiB,kEAAU;AAC3B,iBAAiB,kEAAU;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACO;AACP;AACA;AACA,aAAa,kEAAU;AACvB;AACA;AACA,+BAA+B,yDAAO,KAAK,uDAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wDAAM;AACrD,oBAAoB,yDAAO;AAC3B;AACA;AACA,YAAY,6DAAK;AACjB;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAK;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAK;AAC9B;AACA,UAAU,yDAAO;AACjB;AACA,8BAA8B,uDAAK;AACnC;AACA,eAAe,yDAAO;AACtB;AACA;AACA,UAAU,6DAAK;AACf,UAAU,kEAAU;AACpB;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC1KF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACV;AACe;;AAE5C;AACP,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP,qBAAqB;AACrB,WAAW;AACX,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,SAAS,kEAAU;;AAEnB;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,uDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS;AACT,QAAQ;AACR,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,6DAAK;;AAEX;AACA;;AAEA;AACA,sBAAsB,uDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAK;AACb,8BAA8B,yDAAO;AACrC,uBAAuB,uDAAK;AAC5B;AACA,YAAY,kEAAU;AACtB;AACA;AACA,YAAY,kEAAU;AACtB;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAU;AAClB;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC1FF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACA;AACA;AACA;AACY;AACA;AACZ;AACQ;;AAEZ;AAC9B;;AAEO;AACP;AACA;AACA;AACA,uCAAuC;AACvC;AACA,YAAY,4DAAI;AAChB,YAAY,4DAAI;AAChB,YAAY,4DAAI;AAChB,YAAY,4DAAI;AAChB,sBAAsB,4DAAI,gDAAgD;AAC1E;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA,aAAa,kEAAU;AACvB;AACA;AACA,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA,oBAAoB,kEAAU;AAC9B;AACA;AACA;AACA,yBAAyB,uDAAK;AAC9B;AACA;AACA;AACA;AACA,eAAe,0DAAE;AACjB;AACA,mBAAmB,4DAAI;AACvB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,uDAAK;AACjD,YAAY,kEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA;AACA,8BAA8B,uDAAK;AACnC;AACA;AACA;AACA;AACA,YAAY,kEAAU;AACtB;AACA;AACA;AACA,kCAAkC,uDAAK;AACvC;AACA,YAAY,kEAAU;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA,uBAAuB,4DAAI;AAC3B;AACA;AACA;AACA;AACA,8BAA8B,uDAAK;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kEAAU;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACtIF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEwE;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yDAAO,GAAG,wDAAM;AACnC;AACA,GAAG,yBAAyB,yDAAO,GAAG,wDAAM;AAC5C;AACA,GAAG,kCAAkC,wDAAM;AAC3C;AACA,GAAG,kCAAkC,yDAAO,GAAG,wDAAM;AACrD;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU,yDAAO;AACjB,eAAe,wDAAM,WAAW,yDAAO,GAAG,wDAAM;AAChD;AACA,oBAAoB,yDAAO;AAC3B,KAAK,gBAAgB,yDAAO,GAAG,wDAAM,aAAa,yDAAO,GAAG,wDAAM;AAClE;AACA,iCAAiC,qDAAG,SAAS,qDAAG;AAChD,KAAK,kBAAkB,yDAAO,GAAG,wDAAM,aAAa,wDAAM;AAC1D;AACA,oBAAoB,yDAAO;AAC3B,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,UAAU,yDAAO;AACjB,eAAe,wDAAM,WAAW,yDAAO,GAAG,wDAAM;AAChD;AACA,qBAAqB,yDAAO;AAC5B,KAAK,gBAAgB,wDAAM,YAAY,wDAAM;AAC7C;AACA;AACA,KAAK,iBAAiB,wDAAM,aAAa,yDAAO,GAAG,wDAAM;AACzD;AACA,qBAAqB,yDAAO;AAC5B,KAAK;AACL;AACA,kCAAkC,qDAAG,UAAU,qDAAG;AAClD;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,uCAAuC,yDAAO;AAC9C,KAAK;AACL,uCAAuC,qDAAG;AAC1C,KAAK;AACL,uCAAuC,yDAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,qDAAG,kDAAkD,wDAAM,KAAK,yDAAO;AAC9F;;AAEA;AACA;AACA,UAAU,yDAAO;AACjB,GAAG;AACH,UAAU,qDAAG;AACb,GAAG;AACH,gBAAgB,qDAAG;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP,YAAY;AACZ;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,UAAU,yDAAO;AACjB,GAAG;AACH;AACA,0BAA0B,qDAAG,QAAQ,qDAAG;AACxC,GAAG;AACH;AACA,UAAU,yDAAO;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,qDAAG;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yDAAO;AACpB;AACA,uBAAuB,yDAAO;AAC9B,KAAK;AACL,sCAAsC,qDAAG,WAAW,qDAAG;AACvD,KAAK;AACL,uBAAuB,yDAAO;AAC9B,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,mBAAmB,yDAAO;AAC1B;AACA,wBAAwB,yDAAO;AAC/B,KAAK;AACL;AACA,KAAK;AACL,wBAAwB,yDAAO;AAC/B,KAAK;AACL,uCAAuC,qDAAG,YAAY,qDAAG;AACzD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAO;AACpC;AACA;AACA,6CAA6C,yDAAO;AACpD,KAAK;AACL,6CAA6C,qDAAG;AAChD,KAAK;AACL,6CAA6C,yDAAO;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,uDAAK;AACjB;AACA;AACA,GAAG;AACH;AACA,2BAA2B,wDAAM;AACjC;AACA,KAAK,kBAAkB,wDAAM,aAAa,yDAAO,GAAG,wDAAM;AAC1D;AACA,eAAe,yDAAO;AACtB,KAAK,kBAAkB,yDAAO,GAAG,wDAAM,eAAe,yDAAO,GAAG,wDAAM;AACtE;AACA,sCAAsC,qDAAG,WAAW,qDAAG;AACvD,KAAK;AACL;AACA,eAAe,yDAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,qDAAG;AACjB,YAAY,wDAAM;AAClB,GAAG,kBAAkB,qDAAG;AACxB,YAAY,wDAAM;AAClB;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;AC9WF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACA;AACN;AACxC;AACwC;AACQ;AACG;;AAEf;;;AAG7B;AACP;AACA;;;AAGA;AACA,cAAc,+DAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAU;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,GAAG;AAC/B;AACA;AACA,0BAA0B,uDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,+DAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,6DAAK;AACjB;AACA;AACA,YAAY,6DAAK;AACjB;AACA,UAAU,kEAAU;AACpB,UAAU,kEAAU;AACpB;AACA;AACA,UAAU,mEAAW;AACrB;AACA,YAAY,yDAAO;AACnB;AACA;AACA;AACA,YAAY,kEAAU;AACtB;AACA,kBAAkB,uDAAK,IAAI,yDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AClHF;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACrFF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmD;;AAEjB;AACE;AACA;AACA;AACU;;AAEvC;AACP;AACA,0BAA0B,yDAAO;AACjC;;AAEO;AACP;AACA;AACA;AACA,0EAA0E,uDAAK;AAC/E,2BAA2B,4DAAI;AAC/B;AACA;AACA;AACA,kCAAkC,uDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,uDAAK;AAC/E,kCAAkC,6DAAK,yDAAyD,6DAAK;AACrG;AACA,eAAe,6DAAK;AACpB,2EAA2E,yDAAO;AAClF;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAU;;AAEvB,wDAAwD,uDAAK,iCAAiC,uDAAK;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yDAAO;AAChE;AACA;AACA,kCAAkC,uDAAK;AACvC,WAAW,6DAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAK;AACnB;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAK;AACtC;AACA,cAAc,kEAAU;AACxB;AACA;AACA,cAAc,kEAAU;AACxB;AACA;AACA;AACA,YAAY,kEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAK;AACvC,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAK;AAC5B,uBAAuB,kEAAU;AACjC;AACA;AACA;AACA;AACA,gBAAgB,uDAAK;AACrB;AACA;AACA;AACA;AACA,cAAc,kEAAU;AACxB;AACA,iBAAiB,6DAAK,yBAAyB,yDAAO;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC7KF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACkB;;AAEvC;AACP,EAAE,8CAAK;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,QAAQ,kEAAU;AAClB,EAAE,8CAAK;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,8CAAK;AACP,QAAQ,kEAAU;AAClB;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC/DF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEwC;AACA;AACQ;AACF;;AAEK;AACjB;;AAE3B;AACP;AACA;AACA;AACA;;AAEA;AACA,cAAc,+DAAO;AACrB,eAAe,+DAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA,kBAAkB,kEAAU;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,uDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,uDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAK;AACtC;AACA;AACA;AACA;AACA,aAAa,+DAAO;;AAEpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kEAAU;AACtB;AACA;AACA,QAAQ;AACR;AACA,UAAU,mEAAW;;AAErB,wBAAwB,yDAAO;AAC/B;AACA;AACA,wCAAwC,uDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,kEAAU;AACtB;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAO,GAAG,4DAAI;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC5KF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AAClB;AACvB;AACiC;;;AAGjC;AACP,aAAa,mEAAW;AACxB;AACA;AACA;AACA;AACA,+CAA+C,qDAAG;AAClD;AACA;AACA;;AAEA,EAAE,+CAAM;AACR,iBAAiB,+CAAM;AACvB,iBAAiB,+CAAM;AACvB;;AAEO;AACQ;AACf;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC3BF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;;AAEK;;AAEf;;AAEpC;AACA;AACO;AACP,qBAAqB;AACrB;AACA;;AAEO;;AAEP;AACA;;AAEA;AACA;AACA,aAAa,kEAAU;AACvB;;AAEA,uBAAuB,uDAAK;AAC5B;AACA;AACA;AACA,cAAc,6DAAK;AACnB,yBAAyB,uDAAK,+BAA+B,yDAAO,KAAK,uDAAK;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,uDAAK;AAC1B;AACA;AACA;AACA,UAAU,kEAAU;AACpB;;AAEA;AACA;AACA;AACA;;AAEO;AACQ;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AChIF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoE;AACpB;AACwB;AAChC;AACd;AACa;AACvC;AACA,uCAAuC,4DAAU,gCAAgC,4DAAU,gEAAgE,4DAAU,8BAA8B,4DAAU;AAC7M;;AAEe;AACf;AACA;AACA,YAAY,+DAAO;AACnB;;AAEA;AACA;AACA,gBAAgB,6CAAI;AACpB;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAW;AACvB;AACA;AACA;AACA,eAAe,qDAAG;AAClB,eAAe,qDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wEAAoB;AAClC,KAAK;AACL;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,gEAAe;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,qDAAG;AAClB,eAAe,qDAAG;AAClB,GAAG,OAAO;AACV;AACA,cAAc,wEAAoB;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,4DAAW;AACtB;;AAEA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAmD;;;;;;;;;;;;;;;;;;;;;;;;ACAnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACE;AACN;AACM;AACF;AACE;AACF;AACJ;AACM;AACJ;AACA;AACF;AACE;AACF;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACE;AACF;AACE;AACI;AACR;AACzB;AACf,6BAA6B,8DAAK;AAClC,6BAA6B,+DAAM;AACnC,6BAA6B,4DAAG;AAChC,6BAA6B,+DAAM;AACnC,6BAA6B,8DAAK;AAClC,6BAA6B,+DAAM;AACnC,6BAA6B,8DAAK;AAClC,6BAA6B,4DAAG;AAChC,6BAA6B,+DAAM;AACnC,6BAA6B,6DAAI;AACjC,6BAA6B,8DAAI;AACjC,6BAA6B,6DAAG;AAChC,6BAA6B,8DAAI;AACjC,6BAA6B,6DAAG;AAChC,6BAA6B,6DAAG;AAChC,6BAA6B,8DAAI;AACjC,6BAA6B,8DAAI;AACjC,6BAA6B,8DAAI;AACjC,6BAA6B,8DAAI;AACjC,6BAA6B,8DAAI;AACjC,6BAA6B,8DAAI;AACjC,6BAA6B,+DAAK;AAClC,6BAA6B,8DAAI;AACjC,6BAA6B,+DAAK;AAClC,6BAA6B,iEAAO;AACpC,6BAA6B,6DAAG;AAChC,C;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;;AAEA,WAAW;AACX,WAAW;AACX,WAAW;AACX,WAAW;AACX,WAAW;AACI;AACf;AACA;AACA;AACA,CAAC,EAAC;AACF;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,IAAI;AACf;AACA,YAAY,OAAO;AACnB;AACO;AACP,2BAA2B;AAC3B;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzuBA;AAAA;AAAA;AAAA;AAC8B;AACE;;;;AAIhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,aAAa,uDAAM;AACnB;AACA;AACA;AACA;AACA;AACA,EAAE,sDAAK;AACP;AACA;AACA,CAAC;;;;;;;;;;;;;AChMD;AAAe,0EAAW,EAAC;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChHA;AACA,SAAS,mBAAO,CAAC,6HAA0F,uNAAuN,2FAA2F,mGAAmG,sGAAsG,2DAA2D,gBAAgB,2HAA2H,mFAAmF,iBAAiB,0JAA0J,oFAAoF,iGAAiG,cAAc,gIAAgI,uGAAuG,0IAA0I,0DAA0D,uDAAuD,gCAAgC,EAAE,gBAAgB,eAAe,8GAA8G,wEAAwE,qEAAqE,kBAAkB,EAAE,gBAAgB,6DAA6D,cAAc,EAAE,eAAe,6VAA6V,+DAA+D,yCAAyC,qGAAqG,4CAA4C,yCAAyC,qDAAqD,iCAAiC,EAAE,4HAA4H,mBAAmB,EAAE,kBAAkB,yBAAyB,eAAe,qJAAqJ,iGAAiG,0BAA0B,EAAE,gDAAgD,eAAe,GAAG,0DAA0D,6BAA6B,eAAe,+HAA+H,+DAA+D,GAAG,2FAA2F,6LAA6L,YAAY,0FAA0F,6VAA6V,mBAAmB,6CAA6C,kGAAkG,aAAa,EAAE,EAAE,gHAAgH,mkEAAmkE,ohEAAohE,uBAAuB,yBAAyB,GAAG,wBAAwB,yBAAyB,GAAG,6CAA6C,wCAAwC,QAAQ,OAAO,6BAA6B,iBAAiB,OAAO,KAAK,aAAa,GAAG,gDAAgD,uBAAuB,SAAS,OAAO,qBAAqB,KAAK,GAAG,mDAAmD,oCAAoC,OAAO,YAAY,wBAAwB,sBAAsB,oBAAoB,qBAAqB,wBAAwB,qBAAqB,KAAK,GAAG,mDAAmD,YAAY,wHAAwH,GAAG,+IAA+I,iBAAiB,mBAAmB,8CAA8C,qBAAqB,+BAA+B,sCAAsC,kDAAkD,KAAK,+DAA+D,6BAA6B,oBAAoB,gBAAgB,eAAe,eAAe,OAAO,+BAA+B,qBAAqB,yCAAyC,yBAAyB,+BAA+B,uCAAuC,OAAO,qDAAqD,uBAAuB,OAAO,qDAAqD,gDAAgD,wBAAwB,oFAAoF,SAAS,OAAO,qDAAqD,wBAAwB,OAAO,uEAAuE,kBAAkB,OAAO,0BAA0B,KAAK,0PAA0P,mBAAmB,wCAAwC,KAAK,8BAA8B,wCAAwC,qBAAqB,uBAAuB,OAAO,OAAO,sBAAsB,uBAAuB,OAAO,KAAK,sBAAsB,eAAe,eAAe,OAAO,6BAA6B,KAAK,iIAAiI,gBAAgB,kBAAkB,4PAA4P,eAAe,eAAe,OAAO,+BAA+B,4BAA4B,OAAO,OAAO,4BAA4B,OAAO,KAAK,iPAAiP,UAAU,eAAe,eAAe,OAAO,mBAAmB,uBAAuB,qDAAqD,OAAO,iDAAiD,qBAAqB,OAAO,KAAK,2DAA2D,eAAe,OAAO,mBAAmB,uBAAuB,uBAAuB,OAAO,KAAK,0NAA0N,mBAAmB,OAAO,gFAAgF,wBAAwB,OAAO,qIAAqI,gCAAgC,OAAO,KAAK,2IAA2I,eAAe,OAAO,8BAA8B,kCAAkC,uBAAuB,QAAQ,OAAO,kCAAkC,kBAAkB,WAAW,0BAA0B,SAAS,0CAA0C,eAAe,OAAO,kCAAkC,kBAAkB,WAAW,0BAA0B,SAAS,OAAO,KAAK,qGAAqG,eAAe,OAAO,mBAAmB,iEAAiE,wBAAwB,OAAO,KAAK,qOAAqO,eAAe,eAAe,OAAO,mBAAmB,uBAAuB,qDAAqD,OAAO,mCAAmC,qBAAqB,OAAO,KAAK,mUAAmU,eAAe,OAAO,8BAA8B,kDAAkD,yBAAyB,oBAAoB,gCAAgC,SAAS,0BAA0B,kCAAkC,iCAAiC,SAAS,6BAA6B,uBAAuB,SAAS,4BAA4B,sBAAsB,SAAS,+BAA+B,2CAA2C,SAAS,oBAAoB,oDAAoD,KAAK,2FAA2F,eAAe,OAAO,8BAA8B,qBAAqB,OAAO,KAAK,2TAA2T,eAAe,OAAO,mBAAmB,8BAA8B,wBAAwB,yBAAyB,SAAS,qCAAqC,yBAAyB,SAAS,OAAO,OAAO,6DAA6D,yBAAyB,SAAS,OAAO,KAAK,upBAAupB,4BAA4B,cAAc,mCAAmC,QAAQ,OAAO,wBAAwB,iCAAiC,6BAA6B,OAAO,mDAAmD,+BAA+B,OAAO,KAAK,uEAAuE,yBAAyB,WAAW,sDAAsD,qCAAqC,QAAQ,OAAO,gCAAgC,2BAA2B,oDAAoD,uBAAuB,WAAW,SAAS,sBAAsB,oBAAoB,SAAS,OAAO,uBAAuB,4DAA4D,OAAO,KAAK,2qBAA2qB,QAAQ,OAAO,wBAAwB,qCAAqC,sBAAsB,OAAO,KAAK,iDAAiD,GAAG,mBAAmB,+VAA+V,mBAAmB,6CAA6C,kGAAkG,aAAa,EAAE,EAAE,2KAA2K,wGAAwG,oBAAoB,iCAAiC,0BAA0B,sCAAsC,qBAAqB,2DAA2D,kBAAkB,mDAAmD,kBAAkB,qDAAqD,kBAAkB,uDAAuD,kBAAkB,oDAAoD,kBAAkB,waAAwa,uBAAuB,YAAY,qFAAqF,0BAA0B,2BAA2B,wBAAwB,aAAa,OAAO,mDAAmD,eAAe,oDAAoD,cAAc,mDAAmD,eAAe,kDAAkD,gBAAgB,uBAAuB,+BAA+B,0CAA0C,wEAAwE,OAAO,wBAAwB,gBAAgB,OAAO,0BAA0B,2BAA2B,uEAAuE,sGAAsG,OAAO,yBAAyB,2DAA2D,iDAAiD,iBAAiB,gEAAgE,mCAAmC,iCAAiC,iCAAiC,iCAAiC,uCAAuC,2BAA2B,mBAAmB,QAAQ,sCAAsC,8BAA8B,+JAA+J,2BAA2B,QAAQ,6DAA6D,wEAAwE,4CAA4C,gFAAgF,OAAO,gFAAgF,OAAO,gFAAgF,OAAO,gFAAgF,OAAO,+BAA+B,2BAA2B,uBAAuB,8BAA8B,qGAAqG,2BAA2B,QAAQ,6DAA6D,wEAAwE,mEAAmE,2BAA2B,uBAAuB,8BAA8B,eAAe,aAAa,OAAO,sBAAsB,GAAG,4DAA4D,gCAAgC,YAAY,2DAA2D,YAAY,2DAA2D,YAAY,6BAA6B,YAAY,8BAA8B,YAAY,8BAA8B,gCAAgC,gCAAgC,sBAAsB,2BAA2B,wBAAwB,mDAAmD,qDAAqD,2CAA2C,kEAAkE,yFAAyF,+CAA+C,+BAA+B,+CAA+C,QAAQ,OAAO,wFAAwF,OAAO,0BAA0B,4CAA4C,QAAQ,OAAO,sCAAsC,0BAA0B,WAAW,8FAA8F,wBAAwB,OAAO,4BAA4B,GAAG,gGAAgG,uGAAuG,mIAAmI,iCAAiC,oEAAoE,oEAAoE,gDAAgD,8BAA8B,iFAAiF,OAAO,OAAO,yDAAyD,OAAO,yEAAyE,4DAA4D,wDAAwD,sGAAsG,OAAO,2HAA2H,OAAO,mGAAmG,OAAO,mGAAmG,OAAO,OAAO,gBAAgB,yPAAyP,GAAG,2CAA2C,0BAA0B,8CAA8C,sBAAsB,kBAAkB,aAAa,OAAO,mDAAmD,eAAe,oDAAoD,cAAc,mDAAmD,eAAe,kDAAkD,gBAAgB,sCAAsC,OAAO,eAAe,GAAG,uBAAuB,qCAAqC,wFAAwF,OAAO,0CAA0C,iDAAiD,6BAA6B,+EAA+E,sDAAsD,OAAO,sCAAsC,+CAA+C,oCAAoC,2BAA2B,2BAA2B,2BAA2B,yBAAyB,sCAAsC,OAAO,2CAA2C,+CAA+C,oCAAoC,yBAAyB,qCAAqC,OAAO,wCAAwC,+CAA+C,oCAAoC,yBAAyB,kBAAkB,sCAAsC,OAAO,yCAAyC,+CAA+C,0CAA0C,OAAO,+CAA+C,uBAAuB,sBAAsB,OAAO,kDAAkD,qBAAqB,OAAO,uCAAuC,+CAA+C,oCAAoC,yBAAyB,mBAAmB,mBAAmB,mBAAmB,uCAAuC,OAAO,yCAAyC,+CAA+C,8FAA8F,OAAO,2CAA2C,yFAAyF,uBAAuB,wBAAwB,OAAO,0CAA0C,mBAAmB,OAAO,6CAA6C,+CAA+C,uBAAuB,wBAAwB,OAAO,kBAAkB,iDAAiD,0CAA0C,WAAW,mBAAmB,OAAO,2CAA2C,+CAA+C,uBAAuB,sBAAsB,KAAK,0BAA0B,qBAAqB,OAAO,gDAAgD,wFAAwF,qBAAqB,wBAAwB,OAAO,4DAA4D,mBAAmB,OAAO,IAAI,mBAAmB,mCAAmC,yDAAyD,yDAAyD,yDAAyD,yDAAyD,yDAAyD,yDAAyD,uEAAuE,mEAAmE,0BAA0B,mBAAmB,2BAA2B,qDAAqD,cAAc,8DAA8D,cAAc,wDAAwD,cAAc,wDAAwD,cAAc,8FAA8F,mFAAmF,wFAAwF,uBAAuB,GAAG,8DAA8D,0BAA0B,2BAA2B,mBAAmB,+CAA+C,YAAY,oBAAoB,SAAS,aAAa,kDAAkD,YAAY,2EAA2E,wBAAwB,OAAO,iBAAiB,GAAG,+DAA+D,sDAAsD,0BAA0B,2BAA2B,iBAAiB,SAAS,qDAAqD,YAAY,+CAA+C,YAAY,+CAA+C,YAAY,wBAAwB,OAAO,OAAO,kDAAkD,YAAY,0DAA0D,uCAAuC,6BAA6B,OAAO,iBAAiB,GAAG,wCAAwC,kBAAkB,kBAAkB,MAAM,iCAAiC,iBAAiB,GAAG,sDAAsD,0BAA0B,iBAAiB,8BAA8B,gDAAgD,YAAY,uBAAuB,yDAAyD,YAAY,yDAAyD,YAAY,sBAAsB,cAAc,OAAO,2CAA2C,2CAA2C,2DAA2D,YAAY,WAAW,OAAO,uBAAuB,mDAAmD,YAAY,sBAAsB,SAAS,OAAO,2DAA2D,YAAY,2DAA2D,YAAY,2DAA2D,YAAY,WAAW,OAAO,iBAAiB,GAAG,iEAAiE,0BAA0B,mBAAmB,+DAA+D,+BAA+B,+DAA+D,+BAA+B,+DAA+D,+BAA+B,+DAA+D,+BAA+B,iBAAiB,GAAG,sDAAsD,0BAA0B,mBAAmB,+CAA+C,YAAY,+CAA+C,YAAY,mEAAmE,oEAAoE,uEAAuE,yEAAyE,wBAAwB,wBAAwB,wBAAwB,cAAc,OAAO,6BAA6B,mCAAmC,mCAAmC,WAAW,OAAO,wBAAwB,sBAAsB,cAAc,QAAQ,iDAAiD,2CAA2C,2CAA2C,uCAAuC,uCAAuC,WAAW,OAAO,sBAAsB,oBAAoB,mBAAmB,GAAG,mDAAmD,2CAA2C,oBAAoB,OAAO,0BAA0B,6CAA6C,wBAAwB,cAAc,QAAQ,+DAA+D,gEAAgE,OAAO,gBAAgB,GAAG,yDAAyD,0BAA0B,2BAA2B,mBAAmB,qDAAqD,YAAY,wBAAwB,SAAS,OAAO,mDAAmD,YAAY,kDAAkD,YAAY,oBAAoB,uEAAuE,EAAE,OAAO,iBAAiB,GAAG,0DAA0D,0BAA0B,6DAA6D,YAAY,8DAA8D,YAAY,6BAA6B,kBAAkB,eAAe,qDAAqD,qBAAqB,GAAG,0DAA0D,0BAA0B,2BAA2B,mBAAmB,qDAAqD,YAAY,wBAAwB,SAAS,OAAO,mDAAmD,YAAY,kDAAkD,YAAY,6EAA6E,OAAO,iBAAiB,GAAG,yDAAyD,0BAA0B,2BAA2B,mBAAmB,6DAA6D,YAAY,+EAA+E,4DAA4D,YAAY,wBAAwB,gBAAgB,OAAO,mDAAmD,YAAY,wDAAwD,YAAY,oFAAoF,OAAO,iBAAiB,GAAG,0DAA0D,0BAA0B,mBAAmB,2DAA2D,YAAY,wDAAwD,oDAAoD,YAAY,yEAAyE,uDAAuD,4DAA4D,YAAY,iEAAiE,iBAAiB,GAAG,qBAAqB,oDAAoD,yDAAyD,iBAAiB,6BAA6B,0BAA0B,mBAAmB,mDAAmD,cAAc,mDAAmD,cAAc,8CAA8C,0BAA0B,sBAAsB,8BAA8B,aAAa,OAAO,wDAAwD,cAAc,wDAAwD,cAAc,mDAAmD,mBAAmB,+DAA+D,sFAAsF,6DAA6D,kCAAkC,uCAAuC,uBAAuB,iCAAiC,yDAAyD,yEAAyE,yEAAyE,yEAAyE,yEAAyE,6FAA6F,oCAAoC,WAAW,0FAA0F,yBAAyB,OAAO,iBAAiB,GAAG,+CAA+C,0BAA0B,mBAAmB,gDAAgD,cAAc,gDAAgD,cAAc,gDAAgD,cAAc,mBAAmB,kBAAkB,SAAS,mCAAmC,iBAAiB,GAAG,+CAA+C,0BAA0B,2BAA2B,mBAAmB,sDAAsD,YAAY,gDAAgD,YAAY,kDAAkD,YAAY,oDAAoD,YAAY,kCAAkC,qDAAqD,YAAY,uDAAuD,YAAY,oDAAoD,YAAY,+DAA+D,uBAAuB,gBAAgB,+DAA+D,uBAAuB,uBAAuB,kBAAkB,YAAY,OAAO,8CAA8C,aAAa,kEAAkE,uBAAuB,4BAA4B,qCAAqC,oDAAoD,aAAa,iBAAiB,GAAG,+CAA+C,0BAA0B,2BAA2B,mBAAmB,sDAAsD,YAAY,gDAAgD,YAAY,kDAAkD,YAAY,mDAAmD,YAAY,oDAAoD,YAAY,4BAA4B,kBAAkB,cAAc,OAAO,oDAAoD,aAAa,uBAAuB,GAAG,gDAAgD,0BAA0B,2BAA2B,mBAAmB,sDAAsD,YAAY,kBAAkB,8CAA8C,YAAY,8CAA8C,YAAY,8CAA8C,YAAY,sBAAsB,wBAAwB,WAAW,OAAO,oCAAoC,wDAAwD,wDAAwD,wDAAwD,0EAA0E,OAAO,iBAAiB,GAAG,uBAAuB,0DAA0D,sEAAsE,GAAG,wDAAwD,8CAA8C,4DAA4D,uDAAuD,YAAY,iDAAiD,YAAY,mEAAmE,iDAAiD,YAAY,iDAAiD,YAAY,oDAAoD,oDAAoD,2BAA2B,4BAA4B,mDAAmD,YAAY,gCAAgC,SAAS,OAAO,uDAAuD,YAAY,+BAA+B,wDAAwD,WAAW,2BAA2B,4BAA4B,WAAW,OAAO,yDAAyD,WAAW,qCAAqC,sCAAsC,gEAAgE,iBAAiB,GAAG,sCAAsC,gEAAgE,iBAAiB,GAAG,4BAA4B,oCAAoC,EAAE,eAAe,qCAAqC,WAAW,OAAO,2BAA2B,uDAAuD,YAAY,uDAAuD,YAAY,yDAAyD,YAAY,yDAAyD,YAAY,uFAAuF,6EAA6E,oCAAoC,sBAAsB,eAAe,OAAO,2BAA2B,0BAA0B,eAAe,OAAO,mDAAmD,sCAAsC,gEAAgE,kBAAkB,EAAE,sCAAsC,gEAAgE,kBAAkB,EAAE,4BAA4B,yBAAyB,EAAE,eAAe,mCAAmC,WAAW,OAAO,iBAAiB,GAAG,mBAAmB,0DAA0D,sEAAsE,GAAG,sDAAsD,qEAAqE,iDAAiD,oDAAoD,YAAY,iDAAiD,YAAY,mEAAmE,yDAAyD,yBAAyB,0BAA0B,sDAAsD,YAAY,WAAW,+BAA+B,qDAAqD,YAAY,4DAA4D,4BAA4B,WAAW,OAAO,yBAAyB,wBAAwB,iDAAiD,YAAY,sBAAsB,OAAO,OAAO,sDAAsD,YAAY,2EAA2E,WAAW,sCAAsC,kCAAkC,OAAO,wBAAwB,GAAG,6DAA6D,uDAAuD,6CAA6C,YAAY,kBAAkB,OAAO,OAAO,kDAAkD,YAAY,yEAAyE,OAAO,kBAAkB,GAAG,6DAA6D,uDAAuD,0DAA0D,mBAAmB,eAAe,QAAQ,iDAAiD,YAAY,kBAAkB,2DAA2D,kCAAkC,OAAO,6CAA6C,YAAY,wDAAwD,gCAAgC,kBAAkB,GAAG,wDAAwD,uDAAuD,8CAA8C,YAAY,kBAAkB,QAAQ,OAAO,kDAAkD,YAAY,gEAAgE,OAAO,kBAAkB,GAAG,qDAAqD,kCAAkC,UAAU,gDAAgD,YAAY,8CAA8C,YAAY,kBAAkB,UAAU,OAAO,+CAA+C,YAAY,GAAG,iBAAiB,GAAG,uBAAuB,oDAAoD,0BAA0B,mBAAmB,qDAAqD,cAAc,qDAAqD,cAAc,0DAA0D,cAAc,mDAAmD,cAAc,+CAA+C,cAAc,oDAAoD,cAAc,kDAAkD,cAAc,kDAAkD,cAAc,6CAA6C,cAAc,6CAA6C,cAAc,6CAA6C,cAAc,6CAA6C,cAAc,kDAAkD,cAAc,uDAAuD,cAAc,0DAA0D,cAAc,0DAA0D,cAAc,0DAA0D,cAAc,iBAAiB,GAAG,qBAAqB,oDAAoD,0BAA0B,mBAAmB,qDAAqD,cAAc,kDAAkD,cAAc,kDAAkD,cAAc,gDAAgD,cAAc,+DAA+D,cAAc,4DAA4D,cAAc,4DAA4D,cAAc,mDAAmD,cAAc,6DAA6D,cAAc,uDAAuD,cAAc,uDAAuD,cAAc,0BAA0B,gEAAgE,cAAc,0DAA0D,cAAc,iBAAiB,GAAG,qBAAqB,0DAA0D,0BAA0B,mBAAmB,4BAA4B,yBAAyB,oCAAoC,wBAAwB,uBAAuB,OAAO,4CAA4C,kCAAkC,cAAc,kCAAkC,YAAY,GAAG,8BAA8B,kCAAkC,OAAO,uBAAuB,GAAG,qBAAqB,0DAA0D,0BAA0B,uDAAuD,YAAY,4EAA4E,iDAAiD,YAAY,uBAAuB,qBAAqB,kBAAkB,WAAW,OAAO,oBAAoB,sEAAsE,YAAY,sDAAsD,YAAY,oCAAoC,2EAA2E,0EAA0E,4DAA4D,OAAO,iBAAiB,GAAG,8DAA8D,0BAA0B,sDAAsD,YAAY,+CAA+C,YAAY,uBAAuB,qBAAqB,kBAAkB,WAAW,OAAO,kDAAkD,aAAa,sDAAsD,YAAY,wDAAwD,YAAY,oCAAoC,2EAA2E,0EAA0E,4DAA4D,OAAO,iBAAiB,GAAG,yDAAyD,0BAA0B,qBAAqB,uDAAuD,YAAY,uDAAuD,YAAY,uDAAuD,YAAY,uDAAuD,YAAY,kBAAkB,UAAU,OAAO,mDAAmD,YAAY,mDAAmD,YAAY,mDAAmD,YAAY,2BAA2B,uBAAuB,iBAAiB,qBAAqB,GAAG,iDAAiD,kCAAkC,yBAAyB,uBAAuB,OAAO,oBAAoB,GAAG,uBAAuB,oDAAoD,iDAAiD,gCAAgC,mBAAmB,mFAAmF,aAAa,mDAAmD,cAAc,oDAAoD,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,OAAO,uBAAuB,GAAG,kBAAkB,+CAA+C,2BAA2B,gCAAgC,2CAA2C,gDAAgD,gDAAgD,sEAAsE,wCAAwC,gCAAgC,4CAA4C,+BAA+B,OAAO,yBAAyB,wBAAwB,sBAAsB,uBAAuB,kCAAkC,SAAS,QAAQ,GAAG,iCAAiC,iDAAiD,gCAAgC,8JAA8J,wEAAwE,8BAA8B,OAAO,0BAA0B,+DAA+D,sBAAsB,qBAAqB,OAAO,sCAAsC,6EAA6E,WAAW,mBAAmB,OAAO,2DAA2D,GAAG,+CAA+C,kBAAkB,mBAAmB,sEAAsE,eAAe,GAAG,uDAAuD,qBAAqB,0BAA0B,wBAAwB,kCAAkC,OAAO,gDAAgD,iEAAiE,iBAAiB,8GAA8G,WAAW,oBAAoB,4BAA4B,sBAAsB,OAAO,yCAAyC,uEAAuE,wCAAwC,8BAA8B,sCAAsC,oDAAoD,mCAAmC,gBAAgB,4CAA4C,8CAA8C,mBAAmB,0BAA0B,wEAAwE,wEAAwE,+CAA+C,mBAAmB,qCAAqC,eAAe,WAAW,OAAO,qBAAqB,kDAAkD,wBAAwB,iEAAiE,kEAAkE,WAAW,OAAO,qBAAqB,GAAG,sCAAsC,mVAAmV,qCAAqC,IAAI,qCAAqC,UAAU,kGAAkG,+KAA+K,mwBAAmwB,oDAAoD,0FAA0F,+EAA+E,8CAA8C,mCAAmC,mCAAmC,QAAQ,OAAO,gCAAgC,yBAAyB,6BAA6B,iGAAiG,qCAAqC,WAAW,sBAAsB,wCAAwC,WAAW,oBAAoB,4JAA4J,oCAAoC,eAAe,WAAW,mCAAmC,iDAAiD,oCAAoC,eAAe,WAAW,OAAO,yDAAyD,QAAQ,OAAO,wBAAwB,qCAAqC,0CAA0C,mCAAmC,mEAAmE,wEAAwE,sCAAsC,0BAA0B,+BAA+B,mBAAmB,eAAe,WAAW,OAAO,0EAA0E,QAAQ,OAAO,wBAAwB,0CAA0C,QAAQ,OAAO,8BAA8B,8CAA8C,sBAAsB,wBAAwB,eAAe,WAAW,wBAAwB,iCAAiC,OAAO,uBAAuB,kBAAkB,iCAAiC,iBAAiB,QAAQ,uBAAuB,qCAAqC,uCAAuC,kCAAkC,WAAW,uBAAuB,uBAAuB,WAAW,kFAAkF,4CAA4C,qDAAqD,qDAAqD,2CAA2C,qDAAqD,2CAA2C,qCAAqC,qBAAqB,yEAAyE,mBAAmB,OAAO,yEAAyE,uBAAuB,oCAAoC,yBAAyB,uBAAuB,QAAQ,0CAA0C,8BAA8B,gBAAgB,OAAO,wCAAwC,2EAA2E,6CAA6C,6CAA6C,mDAAmD,uBAAuB,OAAO,2CAA2C,2CAA2C,oFAAoF,2BAA2B,OAAO,uDAAuD,2BAA2B,uBAAuB,mBAAmB,eAAe,WAAW,OAAO,oBAAoB,yBAAyB,eAAe,QAAQ,uBAAuB,qCAAqC,uCAAuC,kCAAkC,WAAW,uBAAuB,uBAAuB,WAAW,+CAA+C,4BAA4B,sDAAsD,2BAA2B,uBAAuB,QAAQ,0CAA0C,8BAA8B,gBAAgB,OAAO,wCAAwC,4EAA4E,2CAA2C,oDAAoD,oDAAoD,eAAe,OAAO,mEAAmE,uBAAuB,0CAA0C,sCAAsC,MAAM,iDAAiD,6CAA6C,6CAA6C,sCAAsC,MAAM,qBAAqB,qFAAqF,uBAAuB,mBAAmB,eAAe,WAAW,OAAO,yCAAyC,6BAA6B,iCAAiC,mCAAmC,oCAAoC,QAAQ,OAAO,yBAAyB,2BAA2B,+BAA+B,iCAAiC,OAAO,uCAAuC,GAAG,yBAAyB,4eAA4e,mBAAmB,6CAA6C,qGAAqG,gBAAgB,EAAE,EAAE,mGAAmG,cAAc,EAAE,EAAE,2GAA2G,sBAAsB,EAAE,EAAE,wGAAwG,mBAAmB,EAAE,EAAE,uGAAuG,kBAAkB,EAAE,EAAE,2GAA2G,sBAAsB,EAAE,EAAE,qGAAqG,gBAAgB,EAAE,EAAE,gHAAgH,2BAA2B,EAAE,EAAE,iHAAiH,4BAA4B,EAAE,EAAE,4GAA4G,uBAAuB,EAAE,EAAE,mBAAmB,yBAAyB,4BAA4B,6BAA6B,2BAA2B,+BAA+B,+BAA+B,2FAA2F,oBAAoB,wBAAwB,oxBAAoxB,uCAAuC,wBAAwB,sBAAsB,OAAO,0BAA0B,sBAAsB,OAAO,qBAAqB,GAAG,oCAAoC,mBAAmB,wGAAwG,cAAc,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,WAAW,OAAO,OAAO,mBAAmB,mBAAmB,mBAAmB,mBAAmB,OAAO,gBAAgB,mBAAmB,mBAAmB,mBAAmB,eAAe,GAAG,8BAA8B,sCAAsC,eAAe,8CAA8C,GAAG,mCAAmC,mBAAmB,sCAAsC,eAAe,sCAAsC,eAAe,2BAA2B,2BAA2B,2BAA2B,eAAe,GAAG,6BAA6B,qCAAqC,mBAAmB,WAAW,wBAAwB,sCAAsC,QAAQ,OAAO,kCAAkC,2CAA2C,oBAAoB,mCAAmC,oBAAoB,GAAG,oDAAoD,8BAA8B,oBAAoB,OAAO,8BAA8B,aAAa,sBAAsB,qBAAqB,OAAO,OAAO,kDAAkD,OAAO,wBAAwB,qBAAqB,6BAA6B,QAAQ,OAAO,gCAAgC,uBAAuB,IAAI,iCAAiC,4BAA4B,eAAe,0BAA0B,WAAW,iBAAiB,IAAI,wBAAwB,mCAAmC,0DAA0D,eAAe,yBAAyB,yBAAyB,wBAAwB,WAAW,OAAO,oBAAoB,GAAG,EAAE,wDAAwD,wCAAwC,QAAQ,OAAO,2CAA2C,YAAY,OAAO,qBAAqB,GAAG,2DAA2D,kBAAkB,6CAA6C,YAAY,8CAA8C,QAAQ,OAAO,+CAA+C,YAAY,WAAW,OAAO,OAAO,kCAAkC,YAAY,OAAO,qBAAqB,GAAG,mEAAmE,kBAAkB,8CAA8C,YAAY,8CAA8C,QAAQ,OAAO,sCAAsC,kDAAkD,QAAQ,OAAO,qDAAqD,YAAY,eAAe,WAAW,OAAO,OAAO,mCAAmC,YAAY,OAAO,qBAAqB,GAAG,4CAA4C,mBAAmB,0CAA0C,QAAQ,OAAO,kCAAkC,OAAO,oBAAoB,GAAG,qCAAqC,4EAA4E,iGAAiG,sCAAsC,4BAA4B,6CAA6C,OAAO,OAAO,2DAA2D,yDAAyD,6CAA6C,0CAA0C,QAAQ,OAAO,0CAA0C,WAAW,wCAAwC,2FAA2F,sEAAsE,wDAAwD,kGAAkG,uDAAuD,+FAA+F,oIAAoI,6FAA6F,aAAa,sFAAsF,yFAAyF,aAAa,sFAAsF,gIAAgI,+BAA+B,eAAe,2DAA2D,2GAA2G,sGAAsG,+EAA+E,iFAAiF,gKAAgK,gEAAgE,iBAAiB,iJAAiJ,iCAAiC,iBAAiB,eAAe,aAAa,oDAAoD,WAAW,wFAAwF,eAAe,GAAG,8EAA8E,yCAAyC,4BAA4B,+CAA+C,OAAO,OAAO,+EAA+E,OAAO,GAAG,yGAAyG,+CAA+C,qCAAqC,+CAA+C,OAAO,OAAO,kFAAkF,sDAAsD,gGAAgG,8DAA8D,kCAAkC,iEAAiE,oDAAoD,QAAQ,OAAO,oCAAoC,+BAA+B,2CAA2C,aAAa,OAAO,4BAA4B,yHAAyH,aAAa,WAAW,mBAAmB,SAAS,GAAG,4CAA4C,uDAAuD,+CAA+C,OAAO,OAAO,+BAA+B,2BAA2B,0CAA0C,uBAAuB,6BAA6B,gBAAgB,4BAA4B,6BAA6B,gCAAgC,6JAA6J,wBAAwB,gHAAgH,iFAAiF,wBAAwB,iHAAiH,qCAAqC,iLAAiL,wBAAwB,eAAe,WAAW,uBAAuB,OAAO,GAAG,iBAAiB,qbAAqb,mBAAmB,6CAA6C,mHAAmH,8BAA8B,EAAE,EAAE,8GAA8G,yBAAyB,EAAE,EAAE,uHAAuH,kCAAkC,EAAE,EAAE,oLAAoL,8KAA8K,2KAA2K,oLAAoL,6LAA6L,4RAA4R,wSAAwS,6cAA6c,wLAAwL,0FAA0F,2FAA2F,MAAM,mGAAmG,iCAAiC,wCAAwC,0CAA0C,iBAAiB,OAAO,yEAAyE,kFAAkF,kCAAkC,iBAAiB,OAAO,sFAAsF,oFAAoF,kFAAkF,oFAAoF,oFAAoF,sFAAsF,4FAA4F,kDAAkD,SAAS,OAAO,oFAAoF,OAAO,oFAAoF,wFAAwF,6FAA6F,oFAAoF,iGAAiG,uGAAuG,6FAA6F,kDAAkD,qDAAqD,yCAAyC,+DAA+D,OAAO,8CAA8C,4BAA4B,2BAA2B,0FAA0F,OAAO,OAAO,mFAAmF,eAAe,gFAAgF,yBAAyB,gCAAgC,iCAAiC,8BAA8B,8BAA8B,kEAAkE,2BAA2B,iBAAiB,OAAO,oEAAoE,uCAAuC,4BAA4B,WAAW,qDAAqD,yCAAyC,OAAO,4BAA4B,oBAAoB,mBAAmB,QAAQ,yCAAyC,8CAA8C,WAAW,OAAO,+BAA+B,iBAAiB,OAAO,uBAAuB,0BAA0B,OAAO,mHAAmH,oHAAoH,uGAAuG,0BAA0B,2HAA2H,OAAO,4DAA4D,sCAAsC,kEAAkE,yGAAyG,OAAO,6BAA6B,8BAA8B,4CAA4C,oCAAoC,oCAAoC,gCAAgC,gCAAgC,0CAA0C,4CAA4C,oBAAoB,mBAAmB,QAAQ,+DAA+D,uBAAuB,WAAW,2CAA2C,4BAA4B,6DAA6D,8DAA8D,iDAAiD,mDAAmD,EAAE,WAAW,8BAA8B,kCAAkC,kCAAkC,yDAAyD,WAAW,yCAAyC,yFAAyF,WAAW,qCAAqC,gCAAgC,0BAA0B,mCAAmC,kCAAkC,oEAAoE,QAAQ,OAAO,mCAAmC,+BAA+B,kCAAkC,6DAA6D,6DAA6D,eAAe,yCAAyC,6FAA6F,6FAA6F,eAAe,sCAAsC,gDAAgD,yDAAyD,yDAAyD,yDAAyD,8FAA8F,yDAAyD,yDAAyD,gCAAgC,eAAe,iEAAiE,0GAA0G,gHAAgH,wHAAwH,qCAAqC,2DAA2D,sDAAsD,kCAAkC,mCAAmC,uEAAuE,2CAA2C,qCAAqC,sCAAsC,uBAAuB,4CAA4C,oCAAoC,uBAAuB,uGAAuG,mBAAmB,OAAO,oGAAoG,4GAA4G,qCAAqC,mEAAmE,iDAAiD,qCAAqC,uDAAuD,uBAAuB,4CAA4C,qDAAqD,uBAAuB,mBAAmB,8GAA8G,uDAAuD,uDAAuD,6DAA6D,uDAAuD,uDAAuD,6DAA6D,uDAAuD,uDAAuD,4FAA4F,wDAAwD,wDAAwD,8DAA8D,wDAAwD,wDAAwD,8DAA8D,wDAAwD,wDAAwD,oCAAoC,iBAAiB,OAAO,mGAAmG,uCAAuC,mLAAmL,8CAA8C,qDAAqD,+FAA+F,uBAAuB,wHAAwH,wHAAwH,oIAAoI,yCAAyC,mEAAmE,0DAA0D,sCAAsC,uCAAuC,yCAAyC,0CAA0C,2BAA2B,gDAAgD,wCAAwC,2BAA2B,+EAA+E,+CAA+C,iHAAiH,iDAAiD,uBAAuB,OAAO,4GAA4G,wHAAwH,yCAAyC,2EAA2E,iDAAiD,yCAAyC,2DAA2D,2BAA2B,gDAAgD,yDAAyD,2BAA2B,uBAAuB,uFAAuF,oDAAoD,oDAAoD,uDAAuD,kDAAkD,oDAAoD,oDAAoD,yDAAyD,0DAA0D,oDAAoD,oDAAoD,wDAAwD,qDAAqD,qDAAqD,qDAAqD,yDAAyD,0DAA0D,oDAAoD,qDAAqD,yDAAyD,oDAAoD,oDAAoD,qDAAqD,0DAA0D,8FAA8F,qDAAqD,qDAAqD,yDAAyD,sDAAsD,sDAAsD,sDAAsD,0DAA0D,2DAA2D,qDAAqD,qDAAqD,0DAA0D,sDAAsD,sDAAsD,sDAAsD,0DAA0D,2DAA2D,qDAAqD,qDAAqD,yDAAyD,qDAAqD,qDAAqD,qDAAqD,0DAA0D,wCAAwC,mCAAmC,yCAAyC,OAAO,sGAAsG,4GAA4G,qCAAqC,2FAA2F,oDAAoD,oDAAoD,uDAAuD,mDAAmD,qDAAqD,qDAAqD,yDAAyD,0DAA0D,oDAAoD,oDAAoD,wDAAwD,qDAAqD,qDAAqD,qDAAqD,0DAA0D,0DAA0D,oDAAoD,qDAAqD,0DAA0D,qDAAqD,qDAAqD,sDAAsD,0DAA0D,8FAA8F,qDAAqD,qDAAqD,wDAAwD,sDAAsD,sDAAsD,sDAAsD,0DAA0D,2DAA2D,qDAAqD,qDAAqD,0DAA0D,sDAAsD,sDAAsD,sDAAsD,0DAA0D,2DAA2D,qDAAqD,qDAAqD,yDAAyD,sDAAsD,sDAAsD,sDAAsD,2DAA2D,wCAAwC,mCAAmC,mBAAmB,eAAe,yCAAyC,sBAAsB,6BAA6B,wCAAwC,oEAAoE,QAAQ,OAAO,sCAAsC,6DAA6D,eAAe,6CAA6C,6FAA6F,eAAe,uCAAuC,iCAAiC,iCAAiC,6CAA6C,qCAAqC,2CAA2C,+BAA+B,qCAAqC,0CAA0C,mFAAmF,iEAAiE,iEAAiE,iEAAiE,sHAAsH,iEAAiE,iEAAiE,wCAAwC,uBAAuB,kDAAkD,8DAA8D,8CAA8C,wEAAwE,2BAA2B,OAAO,8EAA8E,2BAA2B,wCAAwC,+EAA+E,2BAA2B,OAAO,kEAAkE,2BAA2B,yCAAyC,iHAAiH,4DAA4D,4DAA4D,gFAAgF,gFAAgF,gFAAgF,sFAAsF,oFAAoF,oFAAoF,yGAAyG,8DAA8D,8DAA8D,oFAAoF,kFAAkF,kFAAkF,wFAAwF,sFAAsF,sFAAsF,2BAA2B,0BAA0B,gHAAgH,4DAA4D,4DAA4D,mFAAmF,iFAAiF,iFAAiF,oFAAoF,kFAAkF,kFAAkF,yGAAyG,8DAA8D,8DAA8D,qFAAqF,mFAAmF,mFAAmF,sFAAsF,oFAAoF,oFAAoF,2BAA2B,OAAO,qGAAqG,4DAA4D,4DAA4D,gFAAgF,gFAAgF,gFAAgF,sFAAsF,oFAAoF,oFAAoF,yGAAyG,8DAA8D,8DAA8D,oFAAoF,kFAAkF,kFAAkF,wFAAwF,sFAAsF,sFAAsF,2BAA2B,wCAAwC,yBAAyB,OAAO,8CAA8C,4EAA4E,2BAA2B,OAAO,mFAAmF,2BAA2B,8CAA8C,wEAAwE,2BAA2B,OAAO,kFAAkF,2BAA2B,wCAAwC,mFAAmF,2BAA2B,OAAO,kEAAkE,2BAA2B,+FAA+F,wDAAwD,wDAAwD,2DAA2D,0DAA0D,wDAAwD,wDAAwD,2DAA2D,0DAA0D,wDAAwD,yDAAyD,4DAA4D,kGAAkG,2DAA2D,2DAA2D,8DAA8D,6DAA6D,2DAA2D,2DAA2D,+DAA+D,6DAA6D,2DAA2D,4DAA4D,gEAAgE,yCAAyC,gHAAgH,yDAAyD,yDAAyD,kEAAkE,6FAA6F,iFAAiF,iFAAiF,iEAAiE,gFAAgF,kEAAkE,mEAAmE,mEAAmE,0GAA0G,4DAA4D,4DAA4D,qEAAqE,qFAAqF,qFAAqF,qFAAqF,oEAAoE,mFAAmF,qEAAqE,sEAAsE,sEAAsE,2BAA2B,0BAA0B,+GAA+G,yDAAyD,yDAAyD,kEAAkE,8FAA8F,kFAAkF,kFAAkF,iEAAiE,6EAA6E,+DAA+D,gEAAgE,mEAAmE,0GAA0G,4DAA4D,4DAA4D,qEAAqE,sFAAsF,sFAAsF,sFAAsF,oEAAoE,gFAAgF,kEAAkE,mEAAmE,sEAAsE,2BAA2B,OAAO,uDAAuD,yDAAyD,yDAAyD,kEAAkE,6FAA6F,iFAAiF,iFAAiF,iEAAiE,8FAA8F,kFAAkF,mFAAmF,kEAAkE,uGAAuG,4DAA4D,4DAA4D,qEAAqE,qFAAqF,qFAAqF,qFAAqF,oEAAoE,kGAAkG,sFAAsF,uFAAuF,qEAAqE,2BAA2B,wCAAwC,uCAAuC,yBAAyB,qBAAqB,OAAO,uEAAuE,uCAAuC,iBAAiB,OAAO,yDAAyD,uEAAuE,mEAAmE,qEAAqE,qEAAqE,0CAA0C,2BAA2B,qFAAqF,uGAAuG,wDAAwD,wDAAwD,2DAA2D,mDAAmD,qDAAqD,qDAAqD,qDAAqD,kEAAkE,wDAAwD,wDAAwD,2DAA2D,kFAAkF,kFAAkF,iFAAiF,qDAAqD,kEAAkE,wDAAwD,yDAAyD,4DAA4D,oFAAoF,oFAAoF,oFAAoF,sDAAsD,gDAAgD,uCAAuC,uBAAuB,mBAAmB,eAAe,oCAAoC,gEAAgE,yCAAyC,mDAAmD,eAAe,uCAAuC,mCAAmC,eAAe,WAAW,wCAAwC,OAAO,8BAA8B,mCAAmC,mCAAmC,mCAAmC,OAAO,4CAA4C,0CAA0C,0CAA0C,iFAAiF,mBAAmB,kHAAkH,+BAA+B,8XAA8X,8LAA8L,+BAA+B,+DAA+D,WAAW,OAAO,2CAA2C,WAAW,mCAAmC,6CAA6C,sIAAsI,kEAAkE,eAAe,WAAW,4CAA4C,kLAAkL,EAAE,yFAAyF,8BAA8B,0CAA0C,WAAW,mFAAmF,OAAO,wBAAwB,iDAAiD,QAAQ,OAAO,qJAAqJ,WAAW,OAAO,MAAM,yIAAyI,uFAAuF,yFAAyF,2FAA2F,6FAA6F,2FAA2F,uFAAuF,6FAA6F,oGAAoG,2FAA2F,yFAAyF,gGAAgG,6GAA6G,6GAA6G,2CAA2C,iBAAiB,OAAO,iGAAiG,4FAA4F,uFAAuF,sCAAsC,oDAAoD,sDAAsD,qCAAqC,yEAAyE,uGAAuG,uGAAuG,+DAA+D,4FAA4F,yCAAyC,8DAA8D,eAAe,WAAW,OAAO,4CAA4C,iBAAiB,OAAO,sFAAsF,oFAAoF,kFAAkF,oFAAoF,oFAAoF,sFAAsF,4FAA4F,mFAAmF,sDAAsD,oCAAoC,6CAA6C,sDAAsD,uDAAuD,OAAO,OAAO,qEAAqE,sDAAsD,yDAAyD,OAAO,wBAAwB,yEAAyE,wCAAwC,kCAAkC,mCAAmC,kLAAkL,gDAAgD,qCAAqC,8MAA8M,iDAAiD,qBAAqB,6EAA6E,6BAA6B,oGAAoG,8CAA8C,+CAA+C,8LAA8L,4DAA4D,iDAAiD,0NAA0N,6DAA6D,oDAAoD,4BAA4B,mBAAmB,eAAe,WAAW,yBAAyB,qBAAqB,WAAW,OAAO,wQAAwQ,6EAA6E,mFAAmF,mFAAmF,4CAA4C,oCAAoC,8CAA8C,QAAQ,OAAO,iCAAiC,iCAAiC,iCAAiC,iCAAiC,kCAAkC,iCAAiC,iCAAiC,iCAAiC,WAAW,wFAAwF,oCAAoC,kDAAkD,+BAA+B,6CAA6C,sLAAsL,oDAAoD,6BAA6B,wBAAwB,eAAe,6CAA6C,sNAAsN,qDAAqD,oDAAoD,QAAQ,OAAO,qCAAqC,qCAAqC,qCAAqC,qCAAqC,sCAAsC,qCAAqC,qCAAqC,qCAAqC,eAAe,4FAA4F,WAAW,0CAA0C,mDAAmD,iCAAiC,6CAA6C,sLAAsL,oDAAoD,6CAA6C,wBAAwB,eAAe,6CAA6C,sLAAsL,qDAAqD,oDAAoD,QAAQ,OAAO,qCAAqC,qCAAqC,qCAAqC,qCAAqC,sCAAsC,qCAAqC,qCAAqC,qCAAqC,eAAe,+FAA+F,2BAA2B,WAAW,wCAAwC,kCAAkC,kCAAkC,kCAAkC,OAAO,4CAA4C,+CAA+C,qCAAqC,QAAQ,OAAO,6BAA6B,OAAO,iCAAiC,wCAAwC,oCAAoC,2BAA2B,uCAAuC,4DAA4D,+DAA+D,gDAAgD,mCAAmC,eAAe,WAAW,0CAA0C,OAAO,wCAAwC,wNAAwN,EAAE,6BAA6B,oDAAoD,8CAA8C,6CAA6C,qDAAqD,YAAY,qDAAqD,OAAO,eAAe,oDAAoD,WAAW,0EAA0E,OAAO,kEAAkE,myBAAmyB,6DAA6D,sGAAsG,IAAI,4DAA4D,iCAAiC,wCAAwC,yCAAyC,iBAAiB,OAAO,4CAA4C,wDAAwD,mBAAmB,kBAAkB,OAAO,yCAAyC,0CAA0C,6CAA6C,WAAW,OAAO,+DAA+D,gDAAgD,gCAAgC,gCAAgC,4CAA4C,mCAAmC,uBAAuB,kBAAkB,OAAO,6DAA6D,uBAAuB,WAAW,0CAA0C,6BAA6B,kCAAkC,wEAAwE,QAAQ,OAAO,oCAAoC,6DAA6D,eAAe,+CAA+C,6FAA6F,eAAe,8CAA8C,8CAA8C,8CAA8C,yBAAyB,oCAAoC,wBAAwB,eAAe,qCAAqC,WAAW,OAAO,mCAAmC,qCAAqC,iCAAiC,oEAAoE,IAAI,qBAAqB,4VAA4V,mBAAmB,6CAA6C,oLAAoL,2KAA2K,8KAA8K,6LAA6L,6LAA6L,oLAAoL,oLAAoL,6HAA6H,0EAA0E,2LAA2L,wKAAwK,oWAAoW,4GAA4G,4GAA4G,0HAA0H,mGAAmG,oHAAoH,+TAA+T,iSAAiS,iHAAiH,gCAAgC,0JAA0J,kGAAkG,sCAAsC,sBAAsB,iKAAiK,0FAA0F,WAAW,wFAAwF,gBAAgB,iHAAiH,gBAAgB,sHAAsH,gBAAgB,YAAY,KAAK,uEAAuE,8CAA8C,sEAAsE,oDAAoD,wCAAwC,0DAA0D,6IAA6I,6CAA6C,eAAe,kFAAkF,+CAA+C,+CAA+C,qJAAqJ,qGAAqG,gCAAgC,uHAAuH,gCAAgC,uHAAuH,gCAAgC,sOAAsO,2KAA2K,wGAAwG,uGAAuG,0FAA0F,gCAAgC,mBAAmB,eAAe,WAAW,0CAA0C,sDAAsD,yBAAyB,wCAAwC,4BAA4B,uEAAuE,4CAA4C,eAAe,WAAW,2FAA2F,6CAA6C,QAAQ,OAAO,wCAAwC,+DAA+D,oCAAoC,4DAA4D,gBAAgB,iIAAiI,+BAA+B,gEAAgE,0CAA0C,mBAAmB,OAAO,wEAAwE,mBAAmB,eAAe,WAAW,yBAAyB,sCAAsC,uCAAuC,oCAAoC,qJAAqJ,2EAA2E,kEAAkE,oCAAoC,2BAA2B,uBAAuB,4HAA4H,+EAA+E,mDAAmD,4DAA4D,2BAA2B,4DAA4D,wDAAwD,2BAA2B,kEAAkE,+CAA+C,wGAAwG,gCAAgC,2GAA2G,+EAA+E,mEAAmE,QAAQ,OAAO,4DAA4D,wDAAwD,6DAA6D,2FAA2F,uCAAuC,OAAO,qHAAqH,uCAAuC,0DAA0D,mCAAmC,OAAO,0DAA0D,mCAAmC,0KAA0K,kEAAkE,2FAA2F,uCAAuC,4FAA4F,+DAA+D,2DAA2D,mCAAmC,+BAA+B,6DAA6D,6CAA6C,6BAA6B,6BAA6B,uBAAuB,8BAA8B,mJAAmJ,QAAQ,QAAQ,oDAAoD,8EAA8E,mDAAmD,uBAAuB,yFAAyF,oDAAoD,uBAAuB,2DAA2D,QAAQ,cAAc,oDAAoD,8EAA8E,mDAAmD,uBAAuB,8BAA8B,eAAe,gGAAgG,QAAQ,OAAO,iDAAiD,iFAAiF,eAAe,aAAa,SAAS,GAAG,iGAAiG,8EAA8E,oBAAoB,gCAAgC,gDAAgD,QAAQ,OAAO,2CAA2C,sEAAsE,2FAA2F,2BAA2B,eAAe,qGAAqG,iHAAiH,gHAAgH,gIAAgI,+FAA+F,wGAAwG,yJAAyJ,oDAAoD,4CAA4C,+CAA+C,8GAA8G,eAAe,iDAAiD,+CAA+C,mHAAmH,eAAe,yCAAyC,+CAA+C,2GAA2G,eAAe,+DAA+D,oGAAoG,gDAAgD,WAAW,OAAO,GAAG,uFAAuF,mEAAmE,iBAAiB,OAAO,oCAAoC,2CAA2C,0CAA0C,kCAAkC,iDAAiD,EAAE,iFAAiF,iDAAiD,iGAAiG,yDAAyD,kDAAkD,OAAO,OAAO,sCAAsC,+EAA+E,oFAAoF,mBAAmB,6DAA6D,eAAe,4CAA4C,qBAAqB,WAAW,OAAO,iDAAiD,oCAAoC,wCAAwC,6EAA6E,sCAAsC,mFAAmF,OAAO,2EAA2E,sHAAsH,6CAA6C,8BAA8B,sFAAsF,wBAAwB,wFAAwF,wBAAwB,2EAA2E,oBAAoB,mDAAmD,WAAW,OAAO,2CAA2C,2FAA2F,yGAAyG,sGAAsG,wHAAwH,qFAAqF,gGAAgG,iJAAiJ,oCAAoC,uCAAuC,sGAAsG,mGAAmG,OAAO,yCAAyC,uCAAuC,2GAA2G,wGAAwG,OAAO,iCAAiC,uCAAuC,mGAAmG,gGAAgG,OAAO,qCAAqC,0FAA0F,uFAAuF,GAAG,uCAAuC,gBAAgB,sCAAsC,gCAAgC,iCAAiC,sBAAsB,iBAAiB,OAAO,wCAAwC,4BAA4B,gCAAgC,gCAAgC,sHAAsH,uDAAuD,0CAA0C,2IAA2I,oCAAoC,iEAAiE,YAAY,iEAAiE,oCAAoC,oEAAoE,8DAA8D,mCAAmC,kEAAkE,uEAAuE,sCAAsC,oEAAoE,oCAAoC,oCAAoC,kCAAkC,OAAO,GAAG,uCAAuC,gBAAgB,+DAA+D,6EAA6E,YAAY,0CAA0C,4DAA4D,QAAQ,OAAO,sCAAsC,yCAAyC,mBAAmB,iBAAiB,OAAO,wCAAwC,sCAAsC,QAAQ,OAAO,qCAAqC,OAAO,sCAAsC,YAAY,GAAG,wCAAwC,wCAAwC,uEAAuE,eAAe,6CAA6C,WAAW,YAAY,6BAA6B,WAAW,OAAO,OAAO,yBAAyB,OAAO,sBAAsB,iDAAiD,yEAAyE,QAAQ,OAAO,2CAA2C,WAAW,+CAA+C,8CAA8C,QAAQ,OAAO,2CAA2C,YAAY,yCAAyC,0CAA0C,WAAW,OAAO,gDAAgD,GAAG,mCAAmC,2BAA2B,uCAAuC,iCAAiC,yBAAyB,2BAA2B,uDAAuD,yBAAyB,sDAAsD,gBAAgB,kDAAkD,gDAAgD,mDAAmD,sDAAsD,0DAA0D,wCAAwC,kDAAkD,8CAA8C,WAAW,yBAAyB,oBAAoB,EAAE,gBAAgB,+CAA+C,yBAAyB,oBAAoB,EAAE,gBAAgB,qDAAqD,uBAAuB,wBAAwB,EAAE,uBAAuB,oBAAoB,EAAE,gBAAgB,0DAA0D,2DAA2D,gDAAgD,+BAA+B,uEAAuE,uEAAuE,oCAAoC,kCAAkC,eAAe,WAAW,wCAAwC,8EAA8E,8CAA8C,8CAA8C,sDAAsD,wDAAwD,oDAAoD,6DAA6D,kEAAkE,6DAA6D,kCAAkC,2BAA2B,yDAAyD,WAAW,OAAO,sCAAsC,gEAAgE,WAAW,uCAAuC,oDAAoD,4EAA4E,WAAW,uCAAuC,2BAA2B,EAAE,0BAA0B,iCAAiC,wCAAwC,aAAa,WAAW,OAAO,iCAAiC,oBAAoB,EAAE,WAAW,qDAAqD,mCAAmC,WAAW,kBAAkB,uDAAuD,kBAAkB,SAAS,IAAI,eAAe,+cAA+c,mBAAmB,6CAA6C,mHAAmH,8BAA8B,EAAE,EAAE,kHAAkH,6BAA6B,EAAE,EAAE,kHAAkH,6BAA6B,EAAE,EAAE,+GAA+G,0BAA0B,EAAE,EAAE,gHAAgH,2BAA2B,EAAE,EAAE,oLAAoL,6MAA6M,sDAAsD,uDAAuD,wBAAwB,+BAA+B,0DAA0D,iDAAiD,uCAAuC,gCAAgC,8EAA8E,WAAW,SAAS,OAAO,gCAAgC,kDAAkD,WAAW,OAAO,mCAAmC,WAAW,OAAO,GAAG,iFAAiF,mEAAmE,yDAAyD,wCAAwC,QAAQ,OAAO,iDAAiD,OAAO,+CAA+C,kEAAkE,sCAAsC,YAAY,iCAAiC,YAAY,iDAAiD,YAAY,gCAAgC,8BAA8B,qBAAqB,wCAAwC,QAAQ,OAAO,mDAAmD,YAAY,8DAA8D,gCAAgC,OAAO,yJAAyJ,GAAG,4DAA4D,yCAAyC,gDAAgD,+CAA+C,sCAAsC,YAAY,iCAAiC,YAAY,mDAAmD,YAAY,iEAAiE,GAAG,oHAAoH,sEAAsE,iDAAiD,8CAA8C,uEAAuE,oEAAoE,QAAQ,OAAO,sDAAsD,WAAW,OAAO,iEAAiE,yJAAyJ,mCAAmC,oDAAoD,GAAG,uDAAuD,qEAAqE,+DAA+D,8DAA8D,iCAAiC,2BAA2B,6BAA6B,wCAAwC,WAAW,OAAO,uCAAuC,WAAW,OAAO,oCAAoC,GAAG,wCAAwC,kEAAkE,sHAAsH,0DAA0D,QAAQ,OAAO,oCAAoC,gCAAgC,kCAAkC,4CAA4C,mFAAmF,0GAA0G,0CAA0C,uEAAuE,wKAAwK,0GAA0G,oGAAoG,sCAAsC,mCAAmC,QAAQ,OAAO,6CAA6C,8DAA8D,kDAAkD,kCAAkC,+JAA+J,iLAAiL,uHAAuH,+CAA+C,uBAAuB,mBAAmB,oCAAoC,sJAAsJ,yDAAyD,0FAA0F,6EAA6E,kHAAkH,0EAA0E,mEAAmE,kDAAkD,mBAAmB,0BAA0B,oHAAoH,oCAAoC,oKAAoK,kHAAkH,8BAA8B,0CAA0C,4GAA4G,kHAAkH,oGAAoG,6GAA6G,sCAAsC,mCAAmC,QAAQ,OAAO,6CAA6C,8DAA8D,kDAAkD,6EAA6E,kCAAkC,2JAA2J,uSAAuS,sCAAsC,kDAAkD,mLAAmL,uHAAuH,0LAA0L,gIAAgI,+CAA+C,6CAA6C,gEAAgE,kEAAkE,+DAA+D,QAAQ,OAAO,kDAAkD,oDAAoD,mCAAmC,0EAA0E,QAAQ,OAAO,iFAAiF,sEAAsE,uCAAuC,mCAAmC,+BAA+B,2BAA2B,uBAAuB,mBAAmB,oCAAoC,0GAA0G,qHAAqH,+FAA+F,wEAAwE,kEAAkE,YAAY,qDAAqD,YAAY,oEAAoE,YAAY,qDAAqD,6BAA6B,yDAAyD,uBAAuB,OAAO,yFAAyF,6DAA6D,8FAA8F,uBAAuB,6EAA6E,kHAAkH,8FAA8F,qIAAqI,0EAA0E,mEAAmE,kDAAkD,qBAAqB,0BAA0B,eAAe,qBAAqB,OAAO,wEAAwE,wDAAwD,QAAQ,OAAO,iDAAiD,mCAAmC,6DAA6D,+DAA+D,WAAW,OAAO,+CAA+C,2BAA2B,kDAAkD,mBAAmB,uCAAuC,kCAAkC,GAAG,sCAAsC,oCAAoC,+CAA+C,2BAA2B,oDAAoD,uBAAuB,WAAW,OAAO,2BAA2B,oDAAoD,EAAE,WAAW,8BAA8B,mCAAmC,OAAO,GAAG,qBAAqB,+cAA+c,mBAAmB,6CAA6C,mHAAmH,8BAA8B,EAAE,EAAE,uHAAuH,kCAAkC,EAAE,EAAE,0HAA0H,qCAAqC,EAAE,EAAE,0GAA0G,qBAAqB,EAAE,EAAE,oLAAoL,8KAA8K,2KAA2K,oLAAoL,yLAAyL,2MAA2M,8vBAA8vB,uGAAuG,+CAA+C,4BAA4B,uCAAuC,8DAA8D,oHAAoH,mEAAmE,8CAA8C,QAAQ,OAAO,2CAA2C,qFAAqF,oCAAoC,+EAA+E,yDAAyD,yDAAyD,uDAAuD,QAAQ,OAAO,0CAA0C,yCAAyC,2EAA2E,yEAAyE,yEAAyE,uBAAuB,mBAAmB,eAAe,WAAW,yCAAyC,4DAA4D,4CAA4C,WAAW,OAAO,0DAA0D,2CAA2C,WAAW,OAAO,IAAI,qGAAqG,4BAA4B,uCAAuC,iCAAiC,kCAAkC,oEAAoE,OAAO,OAAO,gDAAgD,OAAO,4DAA4D,iBAAiB,OAAO,wQAAwQ,6EAA6E,oFAAoF,oFAAoF,kFAAkF,oFAAoF,oFAAoF,wFAAwF,oFAAoF,4FAA4F,2EAA2E,kFAAkF,oFAAoF,4FAA4F,wEAAwE,yGAAyG,6CAA6C,QAAQ,OAAO,mCAAmC,2DAA2D,2CAA2C,WAAW,OAAO,yEAAyE,iBAAiB,gFAAgF,iCAAiC,gEAAgE,qEAAqE,oCAAoC,o+BAAo+B,sCAAsC,uEAAuE,wEAAwE,0EAA0E,eAAe,OAAO,+DAA+D,eAAe,aAAa,OAAO,2BAA2B,WAAW,OAAO,2EAA2E,kBAAkB,iFAAiF,sFAAsF,iFAAiF,iFAAiF,sFAAsF,0CAA0C,qDAAqD,4CAA4C,wEAAwE,iGAAiG,4FAA4F,+DAA+D,mFAAmF,mCAAmC,kEAAkE,mBAAmB,eAAe,WAAW,8DAA8D,4FAA4F,gGAAgG,qGAAqG,yDAAyD,+BAA+B,kGAAkG,mEAAmE,eAAe,iCAAiC,w8DAAw8D,sCAAsC,4DAA4D,+CAA+C,iDAAiD,eAAe,aAAa,OAAO,4BAA4B,WAAW,OAAO,sBAAsB,qBAAqB,mCAAmC,4CAA4C,oCAAoC,gCAAgC,gCAAgC,0CAA0C,kDAAkD,+CAA+C,gDAAgD,oDAAoD,oCAAoC,WAAW,kDAAkD,sDAAsD,qCAAqC,WAAW,wBAAwB,+BAA+B,iBAAiB,OAAO,oCAAoC,uFAAuF,oDAAoD,oDAAoD,yFAAyF,uFAAuF,oDAAoD,2FAA2F,yFAAyF,oDAAoD,mCAAmC,qBAAqB,OAAO,uFAAuF,oDAAoD,oDAAoD,gDAAgD,+CAA+C,iDAAiD,iDAAiD,iDAAiD,sDAAsD,oDAAoD,oDAAoD,gDAAgD,gFAAgF,gFAAgF,iDAAiD,iDAAiD,sDAAsD,oDAAoD,qDAAqD,iDAAiD,kFAAkF,kFAAkF,kDAAkD,kDAAkD,oCAAoC,mCAAmC,mBAAmB,eAAe,WAAW,OAAO,EAAE,gDAAgD,uBAAuB,qBAAqB,0BAA0B,kCAAkC,8BAA8B,yDAAyD,WAAW,qCAAqC,yFAAyF,WAAW,8BAA8B,wBAAwB,WAAW,mDAAmD,QAAQ,OAAO,8BAA8B,sCAAsC,kCAAkC,6DAA6D,eAAe,yCAAyC,6FAA6F,eAAe,+EAA+E,oDAAoD,wBAAwB,sBAAsB,mDAAmD,4CAA4C,6EAA6E,eAAe,wBAAwB,WAAW,SAAS,EAAE,mEAAmE,+CAA+C,QAAQ,OAAO,mCAAmC,qEAAqE,oDAAoD,kDAAkD,qDAAqD,iCAAiC,eAAe,0EAA0E,QAAQ,OAAO,gCAAgC,0CAA0C,sCAAsC,iEAAiE,mBAAmB,qDAAqD,iGAAiG,mBAAmB,qDAAqD,sCAAsC,8CAA8C,0CAA0C,qEAAqE,uBAAuB,6DAA6D,qGAAqG,uBAAuB,uFAAuF,4DAA4D,sCAAsC,yCAAyC,uBAAuB,yCAAyC,mBAAmB,+CAA+C,qCAAqC,qCAAqC,sDAAsD,4DAA4D,2CAA2C,mBAAmB,eAAe,kFAAkF,6CAA6C,kDAAkD,sDAAsD,4CAA4C,4CAA4C,mBAAmB,sCAAsC,8EAA8E,6DAA6D,+CAA+C,uBAAuB,mBAAmB,OAAO,sCAAsC,iBAAiB,eAAe,6EAA6E,iEAAiE,mDAAmD,2BAA2B,uBAAuB,mBAAmB,eAAe,+CAA+C,qEAAqE,uCAAuC,eAAe,6CAA6C,+EAA+E,uCAAuC,eAAe,mDAAmD,qEAAqE,uCAAuC,+EAA+E,uCAAuC,eAAe,+EAA+E,qFAAqF,uCAAuC,eAAe,WAAW,OAAO,yGAAyG,oBAAoB,gCAAgC,gEAAgE,8DAA8D,uBAAuB,iBAAiB,OAAO,oEAAoE,4BAA4B,WAAW,iDAAiD,yDAAyD,mDAAmD,6EAA6E,kDAAkD,4EAA4E,WAAW,OAAO,mDAAmD,6EAA6E,WAAW,OAAO,kCAAkC,iBAAiB,OAAO,uCAAuC,4EAA4E,SAAS,yEAAyE,mBAAmB,wBAAwB,OAAO,+BAA+B,2BAA2B,OAAO,8BAA8B,mCAAmC,mCAAmC,mCAAmC,OAAO,gCAAgC,iBAAiB,8BAA8B,iBAAiB,8BAA8B,iBAAiB,2EAA2E,+BAA+B,mCAAmC,sDAAsD,uDAAuD,oCAAoC,OAAO,oBAAoB,0BAA0B,0CAA0C,+cAA+c,sEAAsE,6BAA6B,WAAW,OAAO,0CAA0C,mbAAmb,sEAAsE,2CAA2C,WAAW,OAAO,0CAA0C,uBAAuB,2CAA2C,0DAA0D,yCAAyC,wDAAwD,4DAA4D,4DAA4D,2DAA2D,6DAA6D,YAAY,6DAA6D,OAAO,uBAAuB,kEAAkE,mBAAmB,0JAA0J,eAAe,iJAAiJ,8EAA8E,8oBAA8oB,2HAA2H,qLAAqL,eAAe,WAAW,SAAS,EAAE,2CAA2C,wBAAwB,yCAAyC,0DAA0D,0CAA0C,yDAAyD,4DAA4D,6DAA6D,4DAA4D,6DAA6D,YAAY,6DAA6D,OAAO,uBAAuB,mEAAmE,mBAAmB,8JAA8J,eAAe,qJAAqJ,+EAA+E,83BAA83B,oDAAoD,0LAA0L,eAAe,WAAW,SAAS,EAAE,4CAA4C,uBAAuB,4BAA4B,OAAO,8CAA8C,uBAAuB,6BAA6B,OAAO,8EAA8E,QAAQ,OAAO,uCAAuC,6EAA6E,+CAA+C,8DAA8D,oCAAoC,gCAAgC,WAAW,iDAAiD,iEAAiE,qCAAqC,iCAAiC,WAAW,OAAO,MAAM,4GAA4G,4BAA4B,iBAAiB,iCAAiC,kCAAkC,oEAAoE,OAAO,OAAO,gDAAgD,OAAO,4DAA4D,iBAAiB,OAAO,0QAA0Q,6EAA6E,mFAAmF,2CAA2C,6CAA6C,QAAQ,OAAO,mCAAmC,2DAA2D,2CAA2C,WAAW,OAAO,6BAA6B,4CAA4C,oCAAoC,gCAAgC,gCAAgC,0CAA0C,gBAAgB,6CAA6C,QAAQ,OAAO,mCAAmC,qEAAqE,iFAAiF,QAAQ,OAAO,gCAAgC,0CAA0C,8CAA8C,iEAAiE,mBAAmB,qDAAqD,iGAAiG,mBAAmB,+CAA+C,qCAAqC,qCAAqC,eAAe,WAAW,OAAO,iCAAiC,mCAAmC,mCAAmC,mCAAmC,OAAO,gCAAgC,iBAAiB,8BAA8B,iBAAiB,8BAA8B,iBAAiB,mCAAmC,sDAAsD,qCAAqC,+IAA+I,qEAAqE,uFAAuF,iBAAiB,IAAI,6DAA6D,8CAA8C,4CAA4C,iDAAiD,qDAAqD,sDAAsD,2DAA2D,+DAA+D,kDAAkD,uDAAuD,2DAA2D,OAAO,IAAI,iEAAiE,2BAA2B,6BAA6B,8BAA8B,mHAAmH,mHAAmH,mHAAmH,OAAO,mCAAmC,iCAAiC,mCAAmC,4BAA4B,6DAA6D,4DAA4D,6FAA6F,yDAAyD,yDAAyD,oCAAoC,wCAAwC,2BAA2B,gBAAgB,yBAAyB,yBAAyB,mCAAmC,gBAAgB,iCAAiC,yBAAyB,mCAAmC,yBAAyB,kCAAkC,kCAAkC,4BAA4B,0BAA0B,0BAA0B,kCAAkC,wGAAwG,OAAO,iDAAiD,qDAAqD,+CAA+C,mDAAmD,gCAAgC,gCAAgC,gCAAgC,sCAAsC,gCAAgC,gCAAgC,gCAAgC,sCAAsC,sCAAsC,iCAAiC,iCAAiC,yCAAyC,yCAAyC,mCAAmC,mCAAmC,mDAAmD,yCAAyC,mCAAmC,mCAAmC,mDAAmD,iDAAiD,oCAAoC,oCAAoC,oBAAoB,mDAAmD,gCAAgC,gCAAgC,gCAAgC,kCAAkC,sCAAsC,gCAAgC,gCAAgC,sCAAsC,sCAAsC,iCAAiC,iCAAiC,yCAAyC,yCAAyC,mCAAmC,mCAAmC,2CAA2C,iDAAiD,mCAAmC,mCAAmC,mDAAmD,iDAAiD,oCAAoC,oCAAoC,wBAAwB,0BAA0B,wBAAwB,wBAAwB,yEAAyE,WAAW,QAAQ,qCAAqC,uCAAuC,sCAAsC,wCAAwC,wCAAwC,sBAAsB,OAAO,+BAA+B,+BAA+B,oGAAoG,IAAI,mEAAmE,2BAA2B,8BAA8B,+BAA+B,sHAAsH,sHAAsH,sHAAsH,OAAO,kDAAkD,sDAAsD,gDAAgD,gDAAgD,kCAAkC,oCAAoC,4BAA4B,qCAAqC,kCAAkC,qBAAqB,QAAQ,0CAA0C,gCAAgC,+BAA+B,uCAAuC,6CAA6C,wCAAwC,qHAAqH,4GAA4G,WAAW,OAAO,6CAA6C,WAAW,SAAS,mBAAmB,+EAA+E,QAAQ,OAAO,8CAA8C,qDAAqD,yHAAyH,uCAAuC,iDAAiD,kDAAkD,wBAAwB,eAAe,6IAA6I,mIAAmI,aAAa,aAAa,SAAS,yBAAyB,kFAAkF,uBAAuB,0BAA0B,qEAAqE,QAAQ,OAAO,4GAA4G,uDAAuD,OAAO,qEAAqE,QAAQ,OAAO,wCAAwC,qCAAqC,6BAA6B,OAAO,iDAAiD,OAAO,wDAAwD,OAAO,WAAW,oLAAoL,0BAA0B,OAAO,6FAA6F,0DAA0D,0DAA0D,8BAA8B,wBAAwB,wBAAwB,sEAAsE,6BAA6B,WAAW,QAAQ,yCAAyC,2CAA2C,0CAA0C,4CAA4C,4CAA4C,0BAA0B,WAAW,OAAO,OAAO,6BAA6B,WAAW,QAAQ,yCAAyC,2CAA2C,2CAA2C,2CAA2C,WAAW,uCAAuC,yEAAyE,OAAO,wCAAwC,gDAAgD,qCAAqC,QAAQ,OAAO,kCAAkC,OAAO,iCAAiC,wCAAwC,oCAAoC,2BAA2B,uCAAuC,4DAA4D,+DAA+D,4DAA4D,mCAAmC,eAAe,WAAW,+CAA+C,OAAO,gCAAgC,gCAAgC,4GAA4G,IAAI,0DAA0D,gBAAgB,iCAAiC,kCAAkC,oEAAoE,OAAO,OAAO,gDAAgD,OAAO,4DAA4D,iBAAiB,OAAO,4BAA4B,+DAA+D,mBAAmB,yBAAyB,OAAO,yCAAyC,iDAAiD,oDAAoD,WAAW,OAAO,+DAA+D,gDAAgD,gCAAgC,gCAAgC,4CAA4C,mCAAmC,uBAAuB,yBAAyB,OAAO,2EAA2E,uBAAuB,WAAW,iDAAiD,6BAA6B,kCAAkC,wEAAwE,QAAQ,OAAO,oCAAoC,6DAA6D,eAAe,+CAA+C,6FAA6F,eAAe,8CAA8C,8CAA8C,8CAA8C,yBAAyB,oCAAoC,wBAAwB,eAAe,qCAAqC,WAAW,OAAO,mCAAmC,kCAAkC,iCAAiC,oEAAoE,IAAI,qBAAqB,yXAAyX,mBAAmB,6CAA6C,gHAAgH,2BAA2B,EAAE,EAAE,oLAAoL,8KAA8K,oLAAoL,6LAA6L,6LAA6L,2MAA2M,uGAAuG,uGAAuG,4GAA4G,4GAA4G,6FAA6F,+CAA+C,iCAAiC,iBAAiB,OAAO,gKAAgK,qGAAqG,OAAO,mKAAmK,oGAAoG,OAAO,iFAAiF,4BAA4B,iBAAiB,OAAO,mDAAmD,gCAAgC,iBAAiB,OAAO,uFAAuF,iFAAiF,+EAA+E,iFAAiF,iFAAiF,mFAAmF,yFAAyF,2FAA2F,qFAAqF,6FAA6F,yFAAyF,yFAAyF,iEAAiE,0DAA0D,sCAAsC,wCAAwC,oCAAoC,8EAA8E,sCAAsC,2DAA2D,6BAA6B,oBAAoB,iEAAiE,0BAA0B,kCAAkC,gCAAgC,4CAA4C,0CAA0C,kFAAkF,qCAAqC,iBAAiB,OAAO,yCAAyC,oEAAoE,8BAA8B,yDAAyD,WAAW,qCAAqC,yFAAyF,WAAW,kCAAkC,4BAA4B,iGAAiG,iDAAiD,iDAAiD,iDAAiD,eAAe,OAAO,0CAA0C,eAAe,WAAW,+BAA+B,6BAA6B,6BAA6B,gEAAgE,wCAAwC,wCAAwC,OAAO,+DAA+D,kCAAkC,oCAAoC,yBAAyB,yBAAyB,yBAAyB,OAAO,4CAA4C,0CAA0C,0CAA0C,+CAA+C,+BAA+B,+BAA+B,4CAA4C,QAAQ,OAAO,sCAAsC,oDAAoD,WAAW,6CAA6C,sFAAsF,0CAA0C,4CAA4C,QAAQ,OAAO,8CAA8C,+CAA+C,QAAQ,OAAO,yCAAyC,6CAA6C,mBAAmB,OAAO,gDAAgD,mBAAmB,6CAA6C,6CAA6C,6CAA6C,6CAA6C,6CAA6C,6CAA6C,qCAAqC,6CAA6C,mDAAmD,uBAAuB,OAAO,sDAAsD,uBAAuB,mBAAmB,OAAO,2CAA2C,iDAAiD,uBAAuB,OAAO,oDAAoD,uBAAuB,mBAAmB,6CAA6C,6CAA6C,6CAA6C,6CAA6C,6CAA6C,6CAA6C,sCAAsC,iEAAiE,iEAAiE,iEAAiE,iEAAiE,mBAAmB,6CAA6C,iGAAiG,iGAAiG,iGAAiG,iGAAiG,mBAAmB,yCAAyC,oCAAoC,yGAAyG,6HAA6H,2GAA2G,6HAA6H,uBAAuB,OAAO,kDAAkD,kDAAkD,uBAAuB,mBAAmB,gDAAgD,gDAAgD,gDAAgD,kDAAkD,gDAAgD,gDAAgD,kDAAkD,gDAAgD,gDAAgD,kDAAkD,iDAAiD,iDAAiD,mDAAmD,iDAAiD,iDAAiD,mDAAmD,iDAAiD,iDAAiD,gCAAgC,eAAe,WAAW,OAAO,+EAA+E,4CAA4C,wOAAwO,EAAE,uDAAuD,0YAA0Y,0JAA0J,6BAA6B,IAAI,2DAA2D,uBAAuB,+BAA+B,yEAAyE,0CAA0C,WAAW,OAAO,qBAAqB,IAAI,sHAAsH,6CAA6C,gCAAgC,iBAAiB,OAAO,yFAAyF,2DAA2D,wCAAwC,0CAA0C,6BAA6B,kCAAkC,gCAAgC,4CAA4C,0CAA0C,sFAAsF,wCAAwC,oCAAoC,uBAAuB,kBAAkB,OAAO,0CAA0C,0CAA0C,+BAA+B,gCAAgC,8CAA8C,iCAAiC,sDAAsD,uDAAuD,eAAe,OAAO,kDAAkD,mDAAmD,eAAe,yBAAyB,iBAAiB,OAAO,uCAAuC,6CAA6C,qCAAqC,yDAAyD,OAAO,gDAAgD,mBAAmB,yCAAyC,qFAAqF,qCAAqC,0CAA0C,qEAAqE,uBAAuB,iDAAiD,qGAAqG,uBAAuB,sCAAsC,yGAAyG,mLAAmL,uBAAuB,OAAO,kDAAkD,uBAAuB,sCAAsC,sCAAsC,6CAA6C,iDAAiD,uBAAuB,qBAAqB,OAAO,6FAA6F,mBAAmB,iDAAiD,sDAAsD,wDAAwD,mBAAmB,eAAe,sDAAsD,oDAAoD,yBAAyB,+HAA+H,iBAAiB,OAAO,uCAAuC,sDAAsD,6CAA6C,2DAA2D,uBAAuB,6BAA6B,mBAAmB,eAAe,uCAAuC,sDAAsD,qCAAqC,0CAA0C,0DAA0D,eAAe,aAAa,OAAO,kDAAkD,uCAAuC,sFAAsF,OAAO,iCAAiC,yCAAyC,sFAAsF,OAAO,MAAM,kBAAkB,0fAA0f,mBAAmB,6CAA6C,6GAA6G,wBAAwB,EAAE,EAAE,+GAA+G,0BAA0B,EAAE,EAAE,sGAAsG,iBAAiB,EAAE,EAAE,mHAAmH,8BAA8B,EAAE,EAAE,oHAAoH,+BAA+B,EAAE,EAAE,wHAAwH,mCAAmC,EAAE,EAAE,8GAA8G,yBAAyB,EAAE,EAAE,8GAA8G,yBAAyB,EAAE,EAAE,oLAAoL,2KAA2K,iHAAiH,yEAAyE,yFAAyF,6EAA6E,6IAA6I,gHAAgH,4DAA4D,yDAAyD,0BAA0B,2EAA2E,oBAAoB,OAAO,OAAO,uBAAuB,OAAO,IAAI,qFAAqF,qBAAqB,mBAAmB,oBAAoB,OAAO,wBAAwB,yBAAyB,OAAO,gCAAgC,uDAAuD,0CAA0C,0PAA0P,+DAA+D,mHAAmH,uBAAuB,0CAA0C,eAAe,6DAA6D,2CAA2C,gDAAgD,wSAAwS,uEAAuE,2HAA2H,+BAA+B,0DAA0D,uBAAuB,0CAA0C,WAAW,iCAAiC,4DAA4D,2DAA2D,2BAA2B,WAAW,uHAAuH,0CAA0C,2BAA2B,mEAAmE,uHAAuH,0CAA0C,2BAA2B,OAAO,iHAAiH,2BAA2B,yBAAyB,OAAO,qCAAqC,uBAAuB,qBAAqB,iBAAiB,GAAG,WAAW,kBAAkB,OAAO,yBAAyB,IAAI,mDAAmD,iDAAiD,IAAI,sEAAsE,uEAAuE,yEAAyE,IAAI,+FAA+F,6BAA6B,sFAAsF,qEAAqE,OAAO,oEAAoE,OAAO,8EAA8E,OAAO,iEAAiE,OAAO,6CAA6C,6BAA6B,uDAAuD,gEAAgE,4DAA4D,4DAA4D,2DAA2D,2DAA2D,6DAA6D,8DAA8D,gEAAgE,gEAAgE,6DAA6D,eAAe,oBAAoB,OAAO,qCAAqC,kDAAkD,wCAAwC,sDAAsD,yDAAyD,yGAAyG,mBAAmB,OAAO,8DAA8D,iHAAiH,uBAAuB,mBAAmB,iEAAiE,eAAe,WAAW,OAAO,OAAO,0DAA0D,iGAAiG,WAAW,OAAO,gFAAgF,yGAAyG,eAAe,WAAW,SAAS,0BAA0B,IAAI,uFAAuF,6DAA6D,mBAAmB,mDAAmD,uCAAuC,6DAA6D,uBAAuB,OAAO,iCAAiC,WAAW,iCAAiC,wBAAwB,oBAAoB,OAAO,OAAO,4BAA4B,6BAA6B,WAAW,OAAO,8BAA8B,uDAAuD,oGAAoG,wDAAwD,oCAAoC,eAAe,OAAO,sGAAsG,+CAA+C,+DAA+D,mBAAmB,OAAO,qCAAqC,mBAAmB,eAAe,WAAW,yBAAyB,iFAAiF,yBAAyB,2DAA2D,eAAe,OAAO,iCAAiC,eAAe,WAAW,iFAAiF,2CAA2C,4BAA4B,oEAAoE,gGAAgG,mCAAmC,mEAAmE,uBAAuB,OAAO,yCAAyC,uBAAuB,mBAAmB,eAAe,sCAAsC,qDAAqD,sDAAsD,QAAQ,OAAO,8GAA8G,mBAAmB,oCAAoC,eAAe,6BAA6B,WAAW,uEAAuE,yCAAyC,oBAAoB,WAAW,gCAAgC,yBAAyB,2DAA2D,eAAe,OAAO,iCAAiC,eAAe,WAAW,gDAAgD,mCAAmC,6GAA6G,2CAA2C,mBAAmB,OAAO,iIAAiI,yHAAyH,uBAAuB,OAAO,yHAAyH,uBAAuB,gEAAgE,+CAA+C,uBAAuB,OAAO,4CAA4C,uBAAuB,mBAAmB,0BAA0B,iUAAiU,2CAA2C,mBAAmB,OAAO,+GAA+G,6GAA6G,+EAA+E,+CAA+C,uBAAuB,OAAO,iDAAiD,4DAA4D,4DAA4D,4DAA4D,4DAA4D,4DAA4D,qEAAqE,uEAAuE,oEAAoE,iFAAiF,2BAA2B,uBAAuB,mBAAmB,0BAA0B,kHAAkH,2CAA2C,mBAAmB,OAAO,+GAA+G,6GAA6G,6GAA6G,yGAAyG,+CAA+C,uBAAuB,OAAO,mDAAmD,uBAAuB,mBAAmB,0BAA0B,mJAAmJ,2CAA2C,mBAAmB,OAAO,+GAA+G,6GAA6G,uCAAuC,uDAAuD,iHAAiH,iFAAiF,mDAAmD,2BAA2B,uBAAuB,uDAAuD,iHAAiH,iFAAiF,mDAAmD,2BAA2B,uBAAuB,gGAAgG,+CAA+C,uBAAuB,OAAO,4EAA4E,mDAAmD,oEAAoE,yDAAyD,qCAAqC,uBAAuB,mBAAmB,0BAA0B,+fAA+f,4DAA4D,2CAA2C,mBAAmB,OAAO,6CAA6C,yEAAyE,sEAAsE,sEAAsE,sEAAsE,uEAAuE,uEAAuE,uEAAuE,uEAAuE,sEAAsE,sEAAsE,yEAAyE,yEAAyE,wEAAwE,kFAAkF,kFAAkF,uBAAuB,mBAAmB,0BAA0B,8XAA8X,4DAA4D,8DAA8D,+CAA+C,uBAAuB,OAAO,+CAA+C,uBAAuB,mBAAmB,OAAO,6CAA6C,yEAAyE,yEAAyE,8EAA8E,gFAAgF,gFAAgF,wGAAwG,wBAAwB,EAAE,EAAE,8FAA8F,4EAA4E,yEAAyE,wBAAwB,mBAAmB,0BAA0B,yKAAyK,+GAA+G,6GAA6G,yGAAyG,gDAAgD,uBAAuB,qFAAqF,mHAAmH,6GAA6G,uDAAuD,2BAA2B,uBAAuB,uDAAuD,4DAA4D,qFAAqF,uDAAuD,+BAA+B,2BAA2B,OAAO,qHAAqH,iHAAiH,0DAA0D,+BAA+B,2BAA2B,uBAAuB,qBAAqB,yCAAyC,wBAAwB,4GAA4G,2CAA2C,mBAAmB,OAAO,uHAAuH,kEAAkE,QAAQ,OAAO,uHAAuH,+DAA+D,mDAAmD,oCAAoC,2BAA2B,wDAAwD,0EAA0E,2BAA2B,OAAO,0EAA0E,2BAA2B,uBAAuB,0CAA0C,mBAAmB,0BAA0B,mFAAmF,2CAA2C,mBAAmB,OAAO,uHAAuH,wDAAwD,uDAAuD,+CAA+C,uBAAuB,OAAO,iEAAiE,QAAQ,OAAO,qDAAqD,2DAA2D,uDAAuD,wCAAwC,+BAA+B,OAAO,6HAA6H,kEAAkE,sHAAsH,mCAAmC,+BAA+B,2BAA2B,uBAAuB,iHAAiH,mBAAmB,0BAA0B,oOAAoO,4CAA4C,0CAA0C,sDAAsD,sDAAsD,4DAA4D,iFAAiF,uBAAuB,yCAAyC,6CAA6C,qBAAqB,8DAA8D,yEAAyE,uCAAuC,gHAAgH,mBAAmB,OAAO,mEAAmE,mBAAmB,8CAA8C,8CAA8C,qDAAqD,2CAA2C,iDAAiD,sDAAsD,SAAS,OAAO,sCAAsC,+CAA+C,gCAAgC,uBAAuB,0DAA0D,oHAAoH,sEAAsE,oCAAoC,2BAA2B,OAAO,uEAAuE,yDAAyD,4DAA4D,+EAA+E,+BAA+B,mDAAmD,+GAA+G,mEAAmE,2IAA2I,6EAA6E,wCAAwC,yLAAyL,wCAAwC,8FAA8F,yEAAyE,QAAQ,OAAO,2JAA2J,mCAAmC,0CAA0C,+BAA+B,sCAAsC,2BAA2B,uBAAuB,8CAA8C,8CAA8C,mBAAmB,iDAAiD,mGAAmG,mBAAmB,oCAAoC,gEAAgE,wBAAwB,WAAW,gCAAgC,yBAAyB,2DAA2D,eAAe,OAAO,iCAAiC,eAAe,WAAW,oEAAoE,OAAO,mBAAmB,mDAAmD,OAAO,OAAO,yBAAyB,OAAO,IAAI,2FAA2F,wBAAwB,2EAA2E,iBAAiB,OAAO,6EAA6E,mHAAmH,yCAAyC,wDAAwD,2GAA2G,eAAe,gGAAgG,mDAAmD,eAAe,WAAW,OAAO,oFAAoF,uDAAuD,WAAW,OAAO,IAAI,iFAAiF,2EAA2E,2EAA2E,OAAO,yIAAyI,sCAAsC,OAAO,4DAA4D,IAAI,8EAA8E,+BAA+B,iBAAiB,OAAO,yCAAyC,wCAAwC,OAAO,2BAA2B,2BAA2B,yKAAyK,gBAAgB,wLAAwL,gBAAgB,mIAAmI,gBAAgB,gJAAgJ,gBAAgB,8IAA8I,gBAAgB,4FAA4F,gBAAgB,0DAA0D,gBAAgB,OAAO,qCAAqC,kEAAkE,sBAAsB,OAAO,IAAI,4EAA4E,sCAAsC,0DAA0D,iCAAiC,oCAAoC,uFAAuF,6CAA6C,uEAAuE,OAAO,+DAA+D,OAAO,2DAA2D,OAAO,gEAAgE,OAAO,2FAA2F,OAAO,6FAA6F,OAAO,+EAA+E,OAAO,gGAAgG,0GAA0G,uBAAuB,OAAO,mDAAmD,uBAAuB,iBAAiB,8EAA8E,aAAa,OAAO,wEAAwE,WAAW,SAAS,sCAAsC,uBAAuB,OAAO,GAAG,gGAAgG,gBAAgB,2GAA2G,gEAAgE,mDAAmD,OAAO,6DAA6D,uJAAuJ,oEAAoE,uDAAuD,WAAW,OAAO,iDAAiD,gUAAgU,2BAA2B,WAAW,iJAAiJ,+FAA+F,+CAA+C,iQAAiQ,gFAAgF,mEAAmE,uBAAuB,sBAAsB,oCAAoC,2DAA2D,wDAAwD,uBAAuB,ilBAAilB,gFAAgF,mEAAmE,uBAAuB,mBAAmB,4BAA4B,iEAAiE,+IAA+I,oFAAoF,uEAAuE,2BAA2B,uBAAuB,mBAAmB,6CAA6C,iFAAiF,gFAAgF,mEAAmE,uBAAuB,mBAAmB,iBAAiB,OAAO,wEAAwE,2DAA2D,eAAe,WAAW,+FAA+F,yDAAyD,6DAA6D,+BAA+B,QAAQ,OAAO,+CAA+C,qVAAqV,uFAAuF,mEAAmE,uBAAuB,OAAO,2IAA2I,oGAAoG,6FAA6F,2EAA2E,+BAA+B,OAAO,2FAA2F,+BAA+B,2BAA2B,uBAAuB,mBAAmB,iBAAiB,OAAO,wEAAwE,2DAA2D,eAAe,WAAW,kEAAkE,gEAAgE,6EAA6E,2DAA2D,eAAe,OAAO,gDAAgD,QAAQ,OAAO,oFAAoF,qFAAqF,mEAAmE,uBAAuB,mBAAmB,eAAe,6BAA6B,WAAW,6DAA6D,4IAA4I,mEAAmE,8EAA8E,wDAAwD,qFAAqF,mEAAmE,uBAAuB,0EAA0E,wFAAwF,mEAAmE,uBAAuB,8BAA8B,mBAAmB,2CAA2C,QAAQ,OAAO,wDAAwD,qFAAqF,mEAAmE,uBAAuB,mBAAmB,sFAAsF,mCAAmC,mBAAmB,iCAAiC,eAAe,OAAO,wEAAwE,2DAA2D,eAAe,WAAW,yBAAyB,kFAAkF,6BAA6B,qGAAqG,8FAA8F,2DAA2D,eAAe,WAAW,2CAA2C,6BAA6B,yEAAyE,8FAA8F,2DAA2D,eAAe,WAAW,0EAA0E,6BAA6B,sEAAsE,8FAA8F,2DAA2D,eAAe,WAAW,4CAA4C,6BAA6B,sEAAsE,8FAA8F,2DAA2D,eAAe,WAAW,4CAA4C,6BAA6B,6HAA6H,8FAA8F,2DAA2D,eAAe,WAAW,gGAAgG,6BAA6B,yTAAyT,8FAA8F,2DAA2D,eAAe,WAAW,sEAAsE,6BAA6B,gGAAgG,8FAA8F,2DAA2D,eAAe,WAAW,yBAAyB,mEAAmE,oEAAoE,uDAAuD,WAAW,yBAAyB,8CAA8C,OAAO,IAAI,sEAAsE,qBAAqB,oFAAoF,kFAAkF,kFAAkF,kFAAkF,uFAAuF,oFAAoF,qFAAqF,oHAAoH,oFAAoF,+FAA+F,oFAAoF,gIAAgI,mGAAmG,wFAAwF,qFAAqF,qFAAqF,gGAAgG,gGAAgG,2HAA2H,gIAAgI,qHAAqH,yHAAyH,0FAA0F,+FAA+F,+HAA+H,kFAAkF,+EAA+E,gFAAgF,+GAA+G,+EAA+E,4FAA4F,sFAAsF,2HAA2H,mHAAmH,2HAA2H,mFAAmF,2HAA2H,8FAA8F,oFAAoF,yFAAyF,iIAAiI,uFAAuF,+FAA+F,+FAA+F,oFAAoF,oHAAoH,oFAAoF,oHAAoH,oHAAoH,4HAA4H,oFAAoF,oFAAoF,4HAA4H,oHAAoH,qFAAqF,0FAA0F,kIAAkI,yFAAyF,sFAAsF,uFAAuF,sFAAsF,iGAAiG,8HAA8H,8HAA8H,yGAAyG,0FAA0F,kFAAkF,mFAAmF,kFAAkF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,uFAAuF,qHAAqH,kHAAkH,kHAAkH,oFAAoF,gFAAgF,gGAAgG,8EAA8E,uFAAuF,gHAAgH,SAAS,qBAAqB,sBAAsB,wDAAwD,mBAAmB,yCAAyC,2CAA2C,2CAA2C,2CAA2C,uDAAuD,8CAA8C,+CAA+C,4CAA4C,wCAAwC,+CAA+C,wDAAwD,8CAA8C,gDAAgD,qDAAqD,gDAAgD,+CAA+C,iBAAiB,qDAAqD,0DAA0D,oDAAoD,4DAA4D,gDAAgD,0CAA0C,0CAA0C,0CAA0C,8CAA8C,iDAAiD,uDAAuD,sDAAsD,0CAA0C,2CAA2C,wCAAwC,oCAAoC,0CAA0C,oDAAoD,0CAA0C,uCAAuC,oCAAoC,wCAAwC,kDAAkD,4DAA4D,oDAAoD,4CAA4C,iDAAiD,kDAAkD,+CAA+C,oDAAoD,yDAAyD,mDAAmD,2DAA2D,+CAA+C,0CAA0C,gDAAgD,yCAAyC,yCAAyC,6CAA6C,uDAAuD,gDAAgD,iEAAiE,2CAA2C,4CAA4C,kDAAkD,mDAAmD,wDAAwD,iDAAiD,8CAA8C,gDAAgD,2DAA2D,2CAA2C,wCAAwC,4CAA4C,gDAAgD,wCAAwC,2CAA2C,wCAAwC,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,8CAA8C,4CAA4C,4CAA4C,4CAA4C,4CAA4C,4CAA4C,yCAAyC,0CAA0C,+CAA+C,+CAA+C,OAAO,IAAI,mGAAmG,wBAAwB,gDAAgD,uBAAuB,OAAO,0BAA0B,uBAAuB,OAAO,2BAA2B,mEAAmE,QAAQ,OAAO,qHAAqH,kCAAkC,mCAAmC,mBAAmB,eAAe,2CAA2C,6FAA6F,QAAQ,OAAO,8GAA8G,iCAAiC,kCAAkC,mBAAmB,eAAe,4CAA4C,8FAA8F,QAAQ,OAAO,8GAA8G,iCAAiC,mCAAmC,mBAAmB,eAAe,2CAA2C,oEAAoE,QAAQ,0BAA0B,gCAAgC,4BAA4B,OAAO,OAAO,2EAA2E,qFAAqF,qCAAqC,OAAO,2BAA2B,sIAAsI,+CAA+C,2BAA2B,WAAW,uCAAuC,uFAAuF,WAAW,kBAAkB,OAAO,2BAA2B,0CAA0C,0CAA0C,0CAA0C,0CAA0C,wCAAwC,wCAAwC,iEAAiE,wDAAwD,8EAA8E,QAAQ,OAAO,uCAAuC,8BAA8B,eAAe,WAAW,wBAAwB,+EAA+E,QAAQ,OAAO,uCAAuC,+BAA+B,eAAe,WAAW,uBAAuB,OAAO,iCAAiC,OAAO,qCAAqC,4BAA4B,sCAAsC,4EAA4E,2CAA2C,6JAA6J,qGAAqG,WAAW,0CAA0C,2BAA2B,kCAAkC,mBAAmB,eAAe,OAAO,8BAA8B,eAAe,sBAAsB,OAAO,qBAAqB,GAAG,yCAAyC,8CAA8C,wBAAwB,OAAO,uDAAuD,2BAA2B,gHAAgH,QAAQ,OAAO,sDAAsD,WAAW,0BAA0B,OAAO,8BAA8B,2CAA2C,2BAA2B,8HAA8H,+CAA+C,gBAAgB,8EAA8E,QAAQ,OAAO,sCAAsC,WAAW,UAAU,sBAAsB,GAAG,2EAA2E,oBAAoB,aAAa,iHAAiH,6EAA6E,+BAA+B,oFAAoF,qCAAqC,8EAA8E,0GAA0G,yIAAyI,2BAA2B,OAAO,8FAA8F,mJAAmJ,2BAA2B,gCAAgC,sIAAsI,gEAAgE,kEAAkE,+BAA+B,wEAAwE,wIAAwI,6BAA6B,OAAO,8FAA8F,mJAAmJ,2BAA2B,gCAAgC,mBAAmB,eAAe,WAAW,iFAAiF,6DAA6D,oDAAoD,QAAQ,OAAO,+CAA+C,wCAAwC,mHAAmH,uCAAuC,uBAAuB,OAAO,iGAAiG,oGAAoG,+CAA+C,+BAA+B,OAAO,2FAA2F,+BAA+B,2BAA2B,mIAAmI,2CAA2C,2BAA2B,uBAAuB,oCAAoC,qFAAqF,uBAAuB,mBAAmB,iBAAiB,OAAO,wEAAwE,2DAA2D,eAAe,WAAW,SAAS,qBAAqB,IAAI,8DAA8D,cAAc,qCAAqC,mCAAmC,4EAA4E,4EAA4E,oCAAoC,+EAA+E,+CAA+C,oCAAoC,6BAA6B,8CAA8C,wBAAwB,wCAAwC,WAAW,sCAAsC,0CAA0C,0CAA0C,gDAAgD,eAAe,OAAO,0DAA0D,eAAe,WAAW,OAAO,4CAA4C,WAAW,oDAAoD,OAAO,yCAAyC,8DAA8D,EAAE,+DAA+D,8BAA8B,gCAAgC,+BAA+B,OAAO,yEAAyE,6CAA6C,gCAAgC,4CAA4C,sBAAsB,YAAY,WAAW,oCAAoC,wCAAwC,8CAA8C,eAAe,WAAW,OAAO,0CAA0C,WAAW,gDAAgD,OAAO,uCAAuC,wDAAwD,EAAE,sDAAsD,qBAAqB,QAAQ,0DAA0D,iEAAiE,mDAAmD,oGAAoG,OAAO,IAAI,mBAAmB,okBAAokB,mBAAmB,6CAA6C,iHAAiH,4BAA4B,EAAE,EAAE,2GAA2G,sBAAsB,EAAE,EAAE,2GAA2G,sBAAsB,EAAE,EAAE,2GAA2G,sBAAsB,EAAE,EAAE,2GAA2G,sBAAsB,EAAE,EAAE,wHAAwH,mCAAmC,EAAE,EAAE,qGAAqG,gBAAgB,EAAE,EAAE,2GAA2G,sBAAsB,EAAE,EAAE,qGAAqG,gBAAgB,EAAE,EAAE,wGAAwG,mBAAmB,EAAE,EAAE,kHAAkH,6BAA6B,EAAE,EAAE,sGAAsG,iBAAiB,EAAE,EAAE,6GAA6G,wBAAwB,EAAE,EAAE,sGAAsG,iBAAiB,EAAE,EAAE,mGAAmG,cAAc,EAAE,EAAE,2GAA2G,sBAAsB,EAAE,EAAE,oLAAoL,2KAA2K,ibAAib,wCAAwC,kDAAkD,iBAAiB,gDAAgD,qDAAqD,IAAI,0CAA0C,iCAAiC,8BAA8B,gEAAgE,OAAO,iCAAiC,IAAI,iIAAiI,qGAAqG,qBAAqB,mCAAmC,iCAAiC,qCAAqC,qCAAqC,sCAAsC,QAAQ,oDAAoD,8DAA8D,gDAAgD,sBAAsB,qCAAqC,sCAAsC,QAAQ,8BAA8B,8DAA8D,+CAA+C,qCAAqC,uBAAuB,qCAAqC,QAAQ,OAAO,8DAA8D,+CAA+C,qCAAqC,qCAAqC,sBAAsB,OAAO,6BAA6B,GAAG,sLAAsL,qCAAqC,uBAAuB,uCAAuC,sBAAsB,6CAA6C,gCAAgC,OAAO,OAAO,iCAAiC,OAAO,8BAA8B,0CAA0C,qCAAqC,iCAAiC,uCAAuC,eAAe,0BAA0B,yCAAyC,OAAO,kBAAkB,6BAA6B,6BAA6B,6BAA6B,sCAAsC,yCAAyC,6BAA6B,8DAA8D,8DAA8D,iCAAiC,WAAW,OAAO,OAAO,2BAA2B,oEAAoE,oEAAoE,iCAAiC,WAAW,OAAO,gDAAgD,gDAAgD,6BAA6B,2CAA2C,6CAA6C,mBAAmB,oEAAoE,eAAe,6CAA6C,2CAA2C,mCAAmC,4EAA4E,gEAAgE,8DAA8D,8DAA8D,0EAA0E,0EAA0E,0EAA0E,oGAAoG,wGAAwG,4DAA4D,4DAA4D,4DAA4D,8LAA8L,0LAA0L,iDAAiD,mDAAmD,wDAAwD,wDAAwD,wDAAwD,6EAA6E,0DAA0D,0DAA0D,uBAAuB,sDAAsD,kEAAkE,yDAAyD,gDAAgD,UAAU,2DAA2D,sIAAsI,6EAA6E,6EAA6E,+IAA+I,maAAma,oCAAoC,qBAAqB,OAAO,mEAAmE,mFAAmF,4EAA4E,8EAA8E,oDAAoD,iEAAiE,oDAAoD,iEAAiE,mCAAmC,mBAAmB,iBAAiB,OAAO,gGAAgG,oGAAoG,4EAA4E,0DAA0D,0DAA0D,sEAAsE,sEAAsE,sEAAsE,qDAAqD,mDAAmD,mDAAmD,yFAAyF,wDAAwD,wDAAwD,6CAA6C,oDAAoD,kEAAkE,iDAAiD,iDAAiD,0DAA0D,wDAAwD,wDAAwD,6CAA6C,sDAAsD,kEAAkE,iDAAiD,iDAAiD,0DAA0D,wDAAwD,yDAAyD,8CAA8C,sDAAsD,kEAAkE,kDAAkD,kDAAkD,6FAA6F,yDAAyD,yDAAyD,8CAA8C,uDAAuD,mEAAmE,kDAAkD,kDAAkD,2DAA2D,yDAAyD,yDAAyD,8CAA8C,uDAAuD,mEAAmE,kDAAkD,kDAAkD,2DAA2D,yDAAyD,yDAAyD,8CAA8C,uDAAuD,mEAAmE,kDAAkD,kDAAkD,gCAAgC,+BAA+B,eAAe,sEAAsE,oEAAoE,iCAAiC,WAAW,OAAO,iDAAiD,IAAI,mDAAmD,sCAAsC,IAAI,iJAAiJ,+BAA+B,wCAAwC,6EAA6E,0BAA0B,0BAA0B,2CAA2C,QAAQ,OAAO,gCAAgC,sCAAsC,uBAAuB,qDAAqD,+KAA+K,8EAA8E,+DAA+D,8BAA8B,+BAA+B,WAAW,OAAO,qBAAqB,IAAI,qLAAqL,+BAA+B,+BAA+B,OAAO,2BAA2B,sDAAsD,sCAAsC,mCAAmC,uBAAuB,6EAA6E,0BAA0B,0BAA0B,wCAAwC,2CAA2C,QAAQ,OAAO,sDAAsD,6BAA6B,wDAAwD,4CAA4C,sCAAsC,uBAAuB,WAAW,4BAA4B,8BAA8B,WAAW,8CAA8C,sCAAsC,uBAAuB,qDAAqD,8BAA8B,0CAA0C,uBAAuB,kDAAkD,eAAe,uEAAuE,yEAAyE,sNAAsN,mCAAmC,4NAA4N,8BAA8B,+BAA+B,kCAAkC,sBAAsB,WAAW,OAAO,yCAAyC,qBAAqB,IAAI,qKAAqK,4EAA4E,6CAA6C,iDAAiD,sBAAsB,oBAAoB,OAAO,sCAAsC,iBAAiB,OAAO,iGAAiG,sCAAsC,oFAAoF,sCAAsC,2KAA2K,IAAI,gDAAgD,oDAAoD,IAAI,6DAA6D,iDAAiD,mCAAmC,gDAAgD,IAAI,2EAA2E,gBAAgB,6EAA6E,0BAA0B,0BAA0B,2CAA2C,QAAQ,OAAO,gCAAgC,sCAAsC,uBAAuB,+DAA+D,0CAA0C,yBAAyB,oCAAoC,0CAA0C,mBAAmB,OAAO,4CAA4C,mBAAmB,eAAe,WAAW,OAAO,iBAAiB,IAAI,kFAAkF,gBAAgB,6EAA6E,0BAA0B,0BAA0B,yBAAyB,2CAA2C,QAAQ,OAAO,gCAAgC,8BAA8B,qBAAqB,uEAAuE,uBAAuB,WAAW,6BAA6B,kCAAkC,WAAW,wCAAwC,uBAAuB,+DAA+D,0CAA0C,yBAAyB,oCAAoC,0CAA0C,mBAAmB,OAAO,4CAA4C,mBAAmB,eAAe,WAAW,OAAO,kBAAkB,IAAI,4CAA4C,gBAAgB,6CAA6C,QAAQ,OAAO,6BAA6B,+BAA+B,kEAAkE,iCAAiC,OAAO,iBAAiB,IAAI,oEAAoE,gBAAgB,uBAAuB,wBAAwB,6CAA6C,QAAQ,OAAO,yBAAyB,+BAA+B,8DAA8D,qCAAqC,sCAAsC,mDAAmD,oIAAoI,mCAAmC,gCAAgC,WAAW,oBAAoB,OAAO,yBAAyB,IAAI,8FAA8F,gBAAgB,uBAAuB,wBAAwB,4BAA4B,4BAA4B,iFAAiF,oCAAoC,oCAAoC,6CAA6C,QAAQ,OAAO,yBAAyB,+BAA+B,8DAA8D,iCAAiC,gCAAgC,iCAAiC,mCAAmC,mCAAmC,mCAAmC,WAAW,8BAA8B,qCAAqC,8BAA8B,mCAAmC,6CAA6C,6CAA6C,4BAA4B,eAAe,OAAO,qDAAqD,eAAe,WAAW,OAAO,uBAAuB,IAAI,yEAAyE,gCAAgC,uBAAuB,OAAO,6EAA6E,0BAA0B,4BAA4B,sCAAsC,uBAAuB,OAAO,oBAAoB,IAAI,oCAAoC,sCAAsC,QAAQ,OAAO,oCAAoC,sKAAsK,0BAA0B,WAAW,OAAO,qBAAqB,IAAI,iCAAiC,sCAAsC,QAAQ,OAAO,oCAAoC,k7BAAk7B,qCAAqC,WAAW,OAAO,oBAAoB,IAAI,sCAAsC,wBAAwB,wCAAwC,QAAQ,OAAO,iDAAiD,OAAO,wBAAwB,IAAI,6CAA6C,wBAAwB,wCAAwC,QAAQ,OAAO,oDAAoD,OAAO,wBAAwB,IAAI,iDAAiD,gDAAgD,IAAI,uBAAuB,eAAe,EAAE;AACxpuT,E;;;;;;;;;;;ACFA;AACA,SAAS,mBAAO,CAAC,6HAA0F,uNAAuN,2FAA2F,mGAAmG,sGAAsG,2DAA2D,gBAAgB,2HAA2H,mFAAmF,iBAAiB,0JAA0J,oFAAoF,iGAAiG,cAAc,gIAAgI,uGAAuG,0IAA0I,0DAA0D,uDAAuD,gCAAgC,EAAE,gBAAgB,eAAe,8GAA8G,wEAAwE,qEAAqE,kBAAkB,EAAE,gBAAgB,6DAA6D,cAAc,EAAE,eAAe,6VAA6V,+DAA+D,yCAAyC,qGAAqG,4CAA4C,yCAAyC,qDAAqD,iCAAiC,EAAE,4HAA4H,mBAAmB,EAAE,kBAAkB,yBAAyB,eAAe,qJAAqJ,iGAAiG,0BAA0B,EAAE,gDAAgD,eAAe,GAAG,0DAA0D,6BAA6B,eAAe,+HAA+H,+DAA+D,GAAG,2FAA2F,kLAAkL,YAAY,0FAA0F,wUAAwU,mBAAmB,6CAA6C,gJAAgJ,sJAAsJ,mJAAmJ,6IAA6I,4GAA4G,kEAAkE,mEAAmE,uEAAuE,+CAA+C,0BAA0B,4BAA4B,0BAA0B,6BAA6B,0BAA0B,wBAAwB,IAAI,iFAAiF,wBAAwB,wCAAwC,wCAAwC,oCAAoC,wCAAwC,+BAA+B,0DAA0D,wBAAwB,uCAAuC,sCAAsC,4DAA4D,eAAe,4BAA4B,wDAAwD,eAAe,WAAW,OAAO,0CAA0C,uBAAuB,+CAA+C,QAAQ,OAAO,0CAA0C,WAAW,OAAO,IAAI,+FAA+F,oCAAoC,wCAAwC,oCAAoC,wCAAwC,+BAA+B,8CAA8C,wBAAwB,uCAAuC,sCAAsC,4DAA4D,iBAAiB,4BAA4B,oDAAoD,4DAA4D,4CAA4C,yCAAyC,2DAA2D,yDAAyD,yDAAyD,wEAAwE,8HAA8H,eAAe,WAAW,OAAO,OAAO,qGAAqG,+BAA+B,sDAAsD,wCAAwC,oCAAoC,wCAAwC,+BAA+B,0DAA0D,wBAAwB,uCAAuC,sCAAsC,sEAAsE,0CAA0C,eAAe,4BAA4B,4DAA4D,eAAe,iDAAiD,QAAQ,OAAO,4EAA4E,eAAe,qEAAqE,WAAW,OAAO,wCAAwC,uBAAuB,iDAAiD,QAAQ,OAAO,sCAAsC,2DAA2D,qCAAqC,iEAAiE,iCAAiC,iDAAiD,4CAA4C,mBAAmB,0EAA0E,kDAAkD,kDAAkD,wEAAwE,yCAAyC,OAAO,yCAAyC,OAAO,yCAAyC,OAAO,yCAAyC,OAAO,yCAAyC,OAAO,4CAA4C,OAAO,4CAA4C,OAAO,4CAA4C,OAAO,sBAAsB,8EAA8E,wDAAwD,kCAAkC,mBAAmB,oCAAoC,+EAA+E,6DAA6D,iDAAiD,mEAAmE,8DAA8D,uDAAuD,2FAA2F,qEAAqE,mBAAmB,eAAe,WAAW,wCAAwC,iCAAiC,QAAQ,OAAO,iDAAiD,8BAA8B,eAAe,WAAW,+CAA+C,iDAAiD,WAAW,iBAAiB,IAAI,gFAAgF,kBAAkB,iBAAiB,OAAO,2BAA2B,qCAAqC,4EAA4E,4DAA4D,4BAA4B,6BAA6B,6CAA6C,gDAAgD,yCAAyC,mZAAmZ,kHAAkH,gHAAgH,gHAAgH,0BAA0B,wBAAwB,wBAAwB,0BAA0B,wBAAwB,wBAAwB,mCAAmC,wBAAwB,wBAAwB,wCAAwC,40BAA40B,uCAAuC,mCAAmC,6DAA6D,yFAAyF,OAAO,OAAO,+BAA+B,+BAA+B,8BAA8B,iCAAiC,OAAO,6CAA6C,wBAAwB,IAAI,uFAAuF,8EAA8E,IAAI,qFAAqF,sCAAsC,2BAA2B,6BAA6B,mZAAmZ,EAAE,OAAO,GAAG,+FAA+F,+BAA+B,kUAAkU,mBAAmB,6CAA6C,qGAAqG,gBAAgB,EAAE,EAAE,qBAAqB,iBAAiB,gTAAgT,mBAAmB,6CAA6C,yKAAyK,gKAAgK,wLAAwL,qHAAqH,8EAA8E,oGAAoG,0BAA0B,+BAA+B,wDAAwD,iDAAiD,uCAAuC,gCAAgC,8EAA8E,WAAW,SAAS,OAAO,gCAAgC,kDAAkD,WAAW,OAAO,mCAAmC,WAAW,SAAS,GAAG,2GAA2G,qCAAqC,8CAA8C,qCAAqC,iJAAiJ,8FAA8F,gCAAgC,yCAAyC,0DAA0D,EAAE,mBAAmB,wBAAwB,eAAe,+CAA+C,mDAAmD,gCAAgC,yCAAyC,qCAAqC,EAAE,mBAAmB,wBAAwB,eAAe,mCAAmC,iDAAiD,wEAAwE,6CAA6C,gFAAgF,YAAY,+CAA+C,cAAc,mBAAmB,kCAAkC,4CAA4C,oCAAoC,EAAE,yCAAyC,yDAAyD,sBAAsB,mBAAmB,qCAAqC,2GAA2G,2CAA2C,4DAA4D,sBAAsB,mCAAmC,4DAA4D,sBAAsB,mBAAmB,OAAO,yCAAyC,uDAAuD,aAAa,mBAAmB,eAAe,0BAA0B,0DAA0D,qCAAqC,qCAAqC,EAAE,eAAe,0BAA0B,WAAW,SAAS,aAAa,gDAAgD,wBAAwB,wBAAwB,WAAW,OAAO,aAAa,sCAAsC,qEAAqE,4CAA4C,gFAAgF,mFAAmF,4FAA4F,OAAO,qBAAqB,IAAI,yCAAyC,qDAAqD,yCAAyC,gBAAgB,UAAU,iZAAiZ,+FAA+F,KAAK,mCAAmC,2BAA2B,uCAAuC,mCAAmC,uDAAuD,yBAAyB,yEAAyE,oBAAoB,sEAAsE,uDAAuD,mCAAmC,oDAAoD,uBAAuB,mBAAmB,OAAO,mCAAmC,oDAAoD,EAAE,mBAAmB,eAAe,kCAAkC,uCAAuC,sBAAsB,qMAAqM,oBAAoB,SAAS,IAAI,eAAe,wTAAwT,mBAAmB,6CAA6C,uGAAuG,kBAAkB,EAAE,EAAE,yKAAyK,+GAA+G,oCAAoC,kCAAkC,oCAAoC,4BAA4B,kCAAkC,8BAA8B,gCAAgC,4BAA4B,8DAA8D,iEAAiE,6EAA6E,2CAA2C,QAAQ,sCAAsC,sFAAsF,6BAA6B,iBAAiB,0DAA0D,qBAAqB,oCAAoC,uBAAuB,OAAO,8EAA8E,mBAAmB,4EAA4E,mBAAmB,4BAA4B,uBAAuB,OAAO,gEAAgE,mBAAmB,+BAA+B,uBAAuB,OAAO,kEAAkE,wEAAwE,mBAAmB,mEAAmE,mBAAmB,4BAA4B,uBAAuB,sBAAsB,oBAAoB,qDAAqD,2CAA2C,QAAQ,OAAO,mDAAmD,8BAA8B,2CAA2C,yCAAyC,0CAA0C,4EAA4E,WAAW,OAAO,sDAAsD,yDAAyD,6BAA6B,2CAA2C,QAAQ,OAAO,sCAAsC,0BAA0B,0uBAA0uB,EAAE,oFAAoF,kFAAkF,4EAA4E,0EAA0E,OAAO,gBAAgB,OAAO,gUAAgU,0DAA0D,IAAI,2CAA2C,iCAAiC,yCAAyC,wCAAwC,kDAAkD,oEAAoE,QAAQ,+BAA+B,cAAc,2CAA2C,8BAA8B,wDAAwD,OAAO,OAAO,uDAAuD,OAAO,uBAAuB,IAAI,mDAAmD,uCAAuC,qBAAqB,6WAA6W,uFAAuF,iHAAiH,oDAAoD,6DAA6D,gEAAgE,mBAAmB,+BAA+B,6EAA6E,mBAAmB,OAAO,OAAO,uCAAuC,OAAO,wEAAwE,mBAAmB,mDAAmD,iDAAiD,uBAAuB,+DAA+D,mBAAmB,6DAA6D,mBAAmB,6DAA6D,mBAAmB,+DAA+D,mBAAmB,6DAA6D,mBAAmB,6DAA6D,mBAAmB,sCAAsC,gCAAgC,IAAI,6DAA6D,oCAAoC,6BAA6B,8DAA8D,kJAAkJ,uBAAuB,uBAAuB,wLAAwL,wBAAwB,uGAAuG,WAAW,YAAY,QAAQ,uCAAuC,+BAA+B,uCAAuC,qDAAqD,sDAAsD,YAAY,2BAA2B,gCAAgC,OAAO,+BAA+B,6BAA6B,gGAAgG,sDAAsD,2GAA2G,qDAAqD,2BAA2B,iCAAiC,WAAW,OAAO,gHAAgH,WAAW,OAAO,sDAAsD,qBAAqB,sBAAsB,gBAAgB,mBAAmB,iBAAiB,OAAO,uFAAuF,2FAA2F,2FAA2F,sBAAsB,8BAA8B,gCAAgC,qGAAqG,iHAAiH,+BAA+B,eAAe,0BAA0B,WAAW,OAAO,yBAAyB,WAAW,OAAO,iCAAiC,mCAAmC,yCAAyC,8BAA8B,gFAAgF,uPAAuP,uBAAuB,WAAW,aAAa,QAAQ,6DAA6D,mDAAmD,YAAY,wGAAwG,uCAAuC,4CAA4C,QAAQ,QAAQ,yFAAyF,uGAAuG,yBAAyB,WAAW,6CAA6C,OAAO,mCAAmC,0BAA0B,yDAAyD,6GAA6G,iEAAiE,iGAAiG,SAAS,QAAQ,2DAA2D,YAAY,yBAAyB,2BAA2B,yBAAyB,gJAAgJ,6IAA6I,mEAAmE,0BAA0B,kDAAkD,OAAO,OAAO,2GAA2G,yDAAyD,kHAAkH,WAAW,0EAA0E,kHAAkH,WAAW,OAAO,+BAA+B,gCAAgC,gCAAgC,4CAA4C,kCAAkC,iCAAiC,uCAAuC,OAAO,kCAAkC,qHAAqH,uCAAuC,OAAO,mBAAmB,cAAc,OAAO,8DAA8D,gEAAgE,gEAAgE,8BAA8B,6BAA6B,0CAA0C,yEAAyE,yEAAyE,2EAA2E,iDAAiD,mDAAmD,mDAAmD,iDAAiD,mDAAmD,mDAAmD,iDAAiD,mDAAmD,mDAAmD,0CAA0C,0CAA0C,0CAA0C,gCAAgC,eAAe,OAAO,uCAAuC,yCAAyC,yCAAyC,+BAA+B,eAAe,aAAa,OAAO,mCAAmC,gCAAgC,8CAA8C,kDAAkD,kDAAkD,gCAAgC,gDAAgD,kDAAkD,kDAAkD,gCAAgC,gDAAgD,kDAAkD,kDAAkD,0CAA0C,uCAAuC,mDAAmD,uDAAuD,qDAAqD,uDAAuD,qDAAqD,uDAAuD,eAAe,0CAA0C,wEAAwE,wEAAwE,0EAA0E,8BAA8B,yCAAyC,mDAAmD,uDAAuD,qDAAqD,uDAAuD,qDAAqD,uDAAuD,eAAe,OAAO,6BAA6B,eAAe,WAAW,OAAO,oCAAoC,wCAAwC,wCAAwC,gCAAgC,2BAA2B,4BAA4B,4BAA4B,6BAA6B,mDAAmD,8EAA8E,8EAA8E,sEAAsE,+BAA+B,IAAI,qCAAqC,+BAA+B,+BAA+B,0DAA0D,sBAAsB,OAAO,OAAO,yBAAyB,oBAAoB,OAAO,IAAI,sCAAsC,+BAA+B,+BAA+B,yDAAyD,4BAA4B,yCAAyC,2BAA2B,WAAW,OAAO,oCAAoC,2BAA2B,WAAW,OAAO,OAAO,0BAA0B,yCAAyC,yBAAyB,WAAW,OAAO,oCAAoC,yBAAyB,WAAW,OAAO,IAAI,8DAA8D,oCAAoC,6BAA6B,kEAAkE,2EAA2E,iJAAiJ,sBAAsB,sBAAsB,WAAW,YAAY,QAAQ,uCAAuC,+BAA+B,uCAAuC,qDAAqD,gGAAgG,sDAAsD,sDAAsD,YAAY,8CAA8C,YAAY,2BAA2B,gCAAgC,OAAO,mCAAmC,iCAAiC,iGAAiG,8FAA8F,qCAAqC,6BAA6B,2GAA2G,iBAAiB,mCAAmC,yDAAyD,uBAAuB,uBAAuB,uBAAuB,yCAAyC,yCAAyC,yCAAyC,iCAAiC,mBAAmB,uBAAuB,qBAAqB,iBAAiB,OAAO,yCAAyC,0BAA0B,yCAAyC,0BAA0B,yCAAyC,0BAA0B,2CAA2C,4DAA4D,+BAA+B,sBAAsB,2CAA2C,4DAA4D,+BAA+B,sBAAsB,6CAA6C,4DAA4D,+BAA+B,sBAAsB,6CAA6C,WAAW,OAAO,OAAO,qBAAqB,iBAAiB,OAAO,yCAAyC,0BAA0B,yCAAyC,0BAA0B,yCAAyC,0BAA0B,2CAA2C,2EAA2E,6EAA6E,6EAA6E,WAAW,OAAO,2BAA2B,qDAAqD,8CAA8C,YAAY,yBAAyB,6BAA6B,2BAA2B,iBAAiB,OAAO,6CAA6C,6CAA6C,eAAe,aAAa,OAAO,wEAAwE,gHAAgH,2BAA2B,+BAA+B,6BAA6B,iBAAiB,OAAO,iDAAiD,kCAAkC,iDAAiD,kCAAkC,4CAA4C,yCAAyC,uCAAuC,0BAA0B,+CAA+C,yCAAyC,uCAAuC,0BAA0B,yDAAyD,mBAAmB,eAAe,OAAO,6BAA6B,iBAAiB,OAAO,iDAAiD,kCAAkC,iDAAiD,kCAAkC,4CAA4C,4DAA4D,oEAAoE,mBAAmB,eAAe,WAAW,OAAO,uBAAuB,+BAA+B,mCAAmC,0CAA0C,8BAA8B,gFAAgF,uPAAuP,uBAAuB,WAAW,aAAa,QAAQ,6DAA6D,mDAAmD,YAAY,mDAAmD,YAAY,mDAAmD,YAAY,6EAA6E,6EAA6E,uBAAuB,4GAA4G,yBAAyB,4BAA4B,0CAA0C,QAAQ,QAAQ,6CAA6C,8BAA8B,6CAA6C,8BAA8B,wCAAwC,mCAAmC,0BAA0B,qCAAqC,sCAAsC,mCAAmC,0BAA0B,+CAA+C,eAAe,WAAW,OAAO,0CAA0C,QAAQ,QAAQ,6CAA6C,8BAA8B,6CAA6C,8BAA8B,qDAAqD,2DAA2D,eAAe,WAAW,2BAA2B,6CAA6C,OAAO,mCAAmC,0BAA0B,yDAAyD,6GAA6G,iEAAiE,iGAAiG,SAAS,QAAQ,2DAA2D,YAAY,yBAAyB,2BAA2B,yBAAyB,gJAAgJ,6IAA6I,mEAAmE,0BAA0B,kDAAkD,OAAO,OAAO,2GAA2G,yDAAyD,kHAAkH,WAAW,0EAA0E,kHAAkH,WAAW,OAAO,+BAA+B,gCAAgC,gCAAgC,mBAAmB,oCAAoC,qBAAqB,mBAAmB,cAAc,OAAO,oCAAoC,6BAA6B,wBAAwB,QAAQ,EAAE,sCAAsC,6BAA6B,wBAAwB,QAAQ,EAAE,sCAAsC,6BAA6B,wBAAwB,QAAQ,EAAE,8BAA8B,6BAA6B,mCAAmC,qCAAqC,qCAAqC,WAAW,OAAO,mCAAmC,kCAAkC,8CAA8C,kDAAkD,kDAAkD,gCAAgC,gDAAgD,kDAAkD,kDAAkD,gCAAgC,gDAAgD,kDAAkD,kDAAkD,0CAA0C,uCAAuC,mDAAmD,uDAAuD,qDAAqD,uDAAuD,qDAAqD,uDAAuD,eAAe,WAAW,OAAO,kCAAkC,iCAAiC,uCAAuC,OAAO,kCAAkC,qHAAqH,uCAAuC,OAAO,iBAAiB,kCAAkC,qBAAqB,cAAc,OAAO,wCAAwC,iCAAiC,4BAA4B,QAAQ,EAAE,8CAA8C,iCAAiC,4BAA4B,QAAQ,EAAE,8CAA8C,iCAAiC,4BAA4B,QAAQ,EAAE,0CAA0C,iCAAiC,8CAA8C,8CAA8C,8CAA8C,+CAA+C,iDAAiD,iDAAiD,+CAA+C,iDAAiD,iDAAiD,+CAA+C,iDAAiD,iDAAiD,yCAAyC,yCAAyC,yCAAyC,eAAe,OAAO,uCAAuC,mDAAmD,uDAAuD,qDAAqD,uDAAuD,qDAAqD,uDAAuD,eAAe,WAAW,OAAO,uBAAuB,oCAAoC,wCAAwC,wCAAwC,gCAAgC,6BAA6B,8BAA8B,8BAA8B,6BAA6B,mDAAmD,8EAA8E,8EAA8E,sEAAsE,+BAA+B,IAAI,mBAAmB,mQAAmQ,mBAAmB,6CAA6C,kGAAkG,aAAa,EAAE,EAAE,sIAAsI,8FAA8F,oBAAoB,qDAAqD,gDAAgD,IAAI,8CAA8C,mCAAmC,wCAAwC,qBAAqB,IAAI,wCAAwC,qCAAqC,IAAI,wCAAwC,uCAAuC,IAAI,oCAAoC,6BAA6B,IAAI,0EAA0E,6BAA6B,6BAA6B,2BAA2B,0KAA0K,0BAA0B,eAAe,IAAI,kEAAkE,yDAAyD,+BAA+B,qEAAqE,IAAI,oEAAoE,uBAAuB,kCAAkC,0BAA0B,2BAA2B,8HAA8H,0BAA0B,eAAe,IAAI,mDAAmD,qDAAqD,oBAAoB,qBAAqB,0IAA0I,gBAAgB,yIAAyI,gBAAgB,2IAA2I,gBAAgB,OAAO,wBAAwB,eAAe,0BAA0B,yJAAyJ,6JAA6J,0JAA0J,OAAO,MAAM,+CAA+C,gHAAgH,0BAA0B,eAAe,kIAAkI,IAAI,uCAAuC,uCAAuC,IAAI,qDAAqD,gHAAgH,0BAA0B,8HAA8H,IAAI,8CAA8C,mDAAmD,IAAI,8CAA8C,sDAAsD,IAAI,mBAAmB,mSAAmS,mBAAmB,6CAA6C,kGAAkG,aAAa,EAAE,EAAE,kGAAkG,aAAa,EAAE,EAAE,kGAAkG,aAAa,EAAE,EAAE,kGAAkG,aAAa,EAAE,EAAE,kGAAkG,aAAa,EAAE,EAAE,oBAAoB,kCAAkC,2BAA2B,cAAc,sBAAsB,sBAAsB,OAAO,eAAe,IAAI,oBAAoB,kCAAkC,2BAA2B,cAAc,sBAAsB,sBAAsB,sBAAsB,sBAAsB,OAAO,eAAe,IAAI,kCAAkC,mEAAmE,IAAI,mCAAmC,4DAA4D,IAAI,+CAA+C,4EAA4E,IAAI,oBAAoB,kCAAkC,2BAA2B,cAAc,sBAAsB,sBAAsB,sBAAsB,OAAO,eAAe,IAAI,kCAAkC,kBAAkB,kBAAkB,kBAAkB,eAAe,IAAI,qCAAqC,yBAAyB,uBAAuB,uBAAuB,uBAAuB,mBAAmB,OAAO,yBAAyB,yBAAyB,yBAAyB,eAAe,IAAI,0CAA0C,yBAAyB,uBAAuB,uBAAuB,uBAAuB,mBAAmB,OAAO,yBAAyB,yBAAyB,yBAAyB,eAAe,IAAI,qCAAqC,mBAAmB,mBAAmB,mBAAmB,mBAAmB,eAAe,IAAI,uCAAuC,yBAAyB,oBAAoB,oBAAoB,oBAAoB,mBAAmB,OAAO,sBAAsB,sBAAsB,sBAAsB,eAAe,IAAI,wCAAwC,mBAAmB,wGAAwG,cAAc,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,WAAW,OAAO,OAAO,mBAAmB,mBAAmB,mBAAmB,mBAAmB,OAAO,gBAAgB,mBAAmB,mBAAmB,mBAAmB,eAAe,IAAI,4CAA4C,4GAA4G,cAAc,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,WAAW,OAAO,OAAO,mBAAmB,mBAAmB,mBAAmB,mBAAmB,OAAO,gBAAgB,mBAAmB,mBAAmB,mBAAmB,IAAI,+CAA+C,4GAA4G,cAAc,uBAAuB,uBAAuB,yBAAyB,yBAAyB,uBAAuB,WAAW,OAAO,OAAO,mBAAmB,qBAAqB,qBAAqB,mBAAmB,OAAO,gBAAgB,mBAAmB,qBAAqB,qBAAqB,IAAI,yCAAyC,mBAAmB,wGAAwG,cAAc,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,WAAW,OAAO,OAAO,mBAAmB,mBAAmB,mBAAmB,mBAAmB,OAAO,iBAAiB,gBAAgB,mBAAmB,mBAAmB,mBAAmB,gBAAgB,IAAI,uCAAuC,mBAAmB,sCAAsC,eAAe,sCAAsC,eAAe,2BAA2B,2BAA2B,2BAA2B,eAAe,IAAI,kCAAkC,sCAAsC,eAAe,8CAA8C,IAAI,kCAAkC,qDAAqD,IAAI,sCAAsC,yDAAyD,IAAI,yCAAyC,6DAA6D,IAAI,qCAAqC,2BAA2B,2BAA2B,2BAA2B,8CAA8C,IAAI,2CAA2C,2BAA2B,2BAA2B,2BAA2B,mCAAmC,IAAI,2CAA2C,mBAAmB,oDAAoD,sBAAsB,2CAA2C,eAAe,mBAAmB,mBAAmB,mBAAmB,mBAAmB,OAAO,gBAAgB,mBAAmB,mBAAmB,mBAAmB,eAAe,IAAI,yCAAyC,mBAAmB,sCAAsC,sCAAsC,sCAAsC,eAAe,IAAI,+BAA+B,0DAA0D,IAAI,oBAAoB,kCAAkC,2BAA2B,cAAc,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,OAAO,eAAe,IAAI,kCAAkC,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,eAAe,IAAI,oCAAoC,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,IAAI,wCAAwC,yBAAyB,qEAAqE,sBAAsB,sBAAsB,mBAAmB,sBAAsB,mBAAmB,mBAAmB,mBAAmB,OAAO,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,eAAe,IAAI,qCAAqC,+BAA+B,kBAAkB,kBAAkB,kBAAkB,eAAe,kBAAkB,kBAAkB,kBAAkB,eAAe,kBAAkB,kBAAkB,mBAAmB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,eAAe,IAAI,4CAA4C,mBAAmB,sCAAsC,eAAe,4CAA4C,4CAA4C,4CAA4C,eAAe,IAAI,+BAA+B,8IAA8I,IAAI,oBAAoB,kCAAkC,4BAA4B,cAAc,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,wBAAwB,OAAO,eAAe,IAAI,kCAAkC,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,eAAe,IAAI,oCAAoC,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,gBAAgB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,eAAe,IAAI,wCAAwC,yBAAyB,2IAA2I,sBAAsB,sBAAsB,uBAAuB,mBAAmB,sBAAsB,uBAAuB,mBAAmB,mBAAmB,wBAAwB,oBAAoB,oBAAoB,oBAAoB,mBAAmB,OAAO,kBAAkB,kBAAkB,kBAAkB,mBAAmB,kBAAkB,kBAAkB,kBAAkB,mBAAmB,kBAAkB,kBAAkB,oBAAoB,oBAAoB,mBAAmB,mBAAmB,oBAAoB,oBAAoB,eAAe,IAAI,uCAAuC,kSAAkS,gBAAgB,2YAA2Y,IAAI,sCAAsC,mBAAmB,wsBAAwsB,yCAAyC,0CAA0C,yCAAyC,0CAA0C,0CAA0C,yCAAyC,0CAA0C,yCAAyC,yCAAyC,0CAA0C,0CAA0C,2CAA2C,2CAA2C,0CAA0C,2CAA2C,0CAA0C,eAAe,IAAI,4CAA4C,+BAA+B,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,oBAAoB,oBAAoB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,eAAe,IAAI,qCAAqC,+BAA+B,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,mBAAmB,eAAe,IAAI,4CAA4C,qSAAqS,0BAA0B,gBAAgB,+BAA+B,mBAAmB,kCAAkC,iCAAiC,mBAAmB,iCAAiC,kCAAkC,mBAAmB,kCAAkC,iCAAiC,eAAe,IAAI,0CAA0C,mBAAmB,kSAAkS,gBAAgB,kSAAkS,gBAAgB,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,qDAAqD,4CAA4C,4CAA4C,4CAA4C,4CAA4C,4CAA4C,eAAe,IAAI,8CAA8C,mBAAmB,sCAAsC,eAAe,oDAAoD,oDAAoD,qDAAqD,eAAe,IAAI,8CAA8C,mBAAmB,yDAAyD,eAAe,wDAAwD,wDAAwD,yDAAyD,yDAAyD,eAAe,IAAI,2CAA2C,sCAAsC,eAAe,yBAAyB,yDAAyD,yDAAyD,0DAA0D,0DAA0D,mBAAmB,OAAO,sOAAsO,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,gBAAgB,gBAAgB,4CAA4C,4CAA4C,4CAA4C,4CAA4C,eAAe,IAAI,uCAAuC,sCAAsC,eAAe,yBAAyB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,qBAAqB,qBAAqB,mBAAmB,OAAO,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB,wBAAwB,wBAAwB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,eAAe,IAAI,2CAA2C,sCAAsC,eAAe,+CAA+C,0BAA0B,mBAAmB,oBAAoB,iBAAiB,iBAAiB,iBAAiB,OAAO,wEAAwE,eAAe,eAAe,wZAAwZ,4BAA4B,wBAAwB,cAAc,uBAAuB,4BAA4B,4BAA4B,4BAA4B,4BAA4B,WAAW,OAAO,YAAY,mCAAmC,mCAAmC,mCAAmC,4CAA4C,mCAAmC,mCAAmC,mCAAmC,mCAAmC,mCAAmC,mCAAmC,oCAAoC,oCAAoC,eAAe,IAAI,yCAAyC,0BAA0B,sBAAsB,0JAA0J,cAAc,uBAAuB,0BAA0B,0BAA0B,0BAA0B,0BAA0B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,WAAW,OAAO,YAAY,2BAA2B,2BAA2B,2BAA2B,2BAA2B,4BAA4B,4BAA4B,6BAA6B,6BAA6B,eAAe,IAAI,yCAAyC,0BAA0B,sBAAsB,0JAA0J,cAAc,uBAAuB,0BAA0B,0BAA0B,0BAA0B,0BAA0B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,WAAW,OAAO,YAAY,4BAA4B,4BAA4B,4BAA4B,4BAA4B,2BAA2B,2BAA2B,4BAA4B,4BAA4B,eAAe,IAAI,yCAAyC,0BAA0B,sBAAsB,wJAAwJ,cAAc,uBAAuB,0BAA0B,0BAA0B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,WAAW,OAAO,YAAY,2BAA2B,2BAA2B,2BAA2B,2BAA2B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,eAAe,IAAI,qDAAqD,+BAA+B,4DAA4D,uBAAuB,eAAe,eAAe,eAAe,eAAe,uBAAuB,eAAe,eAAe,yBAAyB,yBAAyB,2BAA2B,iBAAiB,gBAAgB,gBAAgB,+BAA+B,gBAAgB,eAAe,IAAI,mDAAmD,0CAA0C,gBAAgB,iDAAiD,IAAI,mDAAmD,+BAA+B,4DAA4D,mBAAmB,eAAe,eAAe,eAAe,eAAe,mBAAmB,eAAe,eAAe,eAAe,eAAe,qBAAqB,gBAAgB,2BAA2B,2BAA2B,2BAA2B,gBAAgB,eAAe,IAAI,2CAA2C,+BAA+B,sCAAsC,eAAe,yDAAyD,eAAe,mBAAmB,iEAAiE,qBAAqB,mBAAmB,mBAAmB,mBAAmB,+CAA+C,aAAa,aAAa,aAAa,wBAAwB,wBAAwB,wBAAwB,2CAA2C,cAAc,oBAAoB,iBAAiB,iBAAiB,iBAAiB,OAAO,oBAAoB,wBAAwB,wBAAwB,wBAAwB,2CAA2C,cAAc,oBAAoB,iBAAiB,iBAAiB,iBAAiB,OAAO,oBAAoB,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,wBAAwB,gBAAgB,gBAAgB,uCAAuC,uCAAuC,uCAAuC,gBAAgB,eAAe,IAAI,+BAA+B,sPAAsP,IAAI,qBAAqB,mCAAmC,2BAA2B,cAAc,sBAAsB,sBAAsB,sBAAsB,sBAAsB,OAAO,eAAe,IAAI,mCAAmC,kBAAkB,kBAAkB,kBAAkB,kBAAkB,eAAe,IAAI,0CAA0C,yDAAyD,yBAAyB,iEAAiE,mBAAmB,OAAO,eAAe,eAAe,eAAe,6DAA6D,eAAe,IAAI,uCAAuC,yBAAyB,oBAAoB,oBAAoB,oBAAoB,mBAAmB,OAAO,mBAAmB,mBAAmB,mBAAmB,kBAAkB,eAAe,IAAI,mCAAmC,yDAAyD,eAAe,sDAAsD,IAAI,yCAAyC,mBAAmB,mIAAmI,mBAAmB,mBAAmB,mBAAmB,mBAAmB,mBAAmB,mBAAmB,OAAO,gBAAgB,mBAAmB,mBAAmB,mBAAmB,mBAAmB,eAAe,IAAI,2CAA2C,mBAAmB,yDAAyD,eAAe,yDAAyD,eAAe,2CAA2C,2CAA2C,2CAA2C,2CAA2C,eAAe,IAAI,+CAA+C,mBAAmB,yDAAyD,eAAe,sCAAsC,eAAe,4GAA4G,iCAAiC,8CAA8C,8CAA8C,8CAA8C,eAAe,IAAI,sCAAsC,+BAA+B,gLAAgL,gBAAgB,oBAAoB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,yBAAyB,mBAAmB,mBAAmB,mBAAmB,yBAAyB,mBAAmB,mBAAmB,mBAAmB,yBAAyB,eAAe,IAAI,sCAAsC,+BAA+B,gLAAgL,gBAAgB,oBAAoB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,yBAAyB,mBAAmB,mBAAmB,eAAe,mBAAmB,yBAAyB,mBAAmB,eAAe,mBAAmB,mBAAmB,0BAA0B,gBAAgB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,eAAe,IAAI,2CAA2C,mBAAmB,gBAAgB,gFAAgF,qCAAqC,qCAAqC,qCAAqC,qCAAqC,eAAe,IAAI,gCAAgC,wEAAwE,IAAI,mBAAmB,mQAAmQ,mBAAmB,6CAA6C,sGAAsG,iBAAiB,EAAE,EAAE,sBAAsB,6CAA6C,oCAAoC,uBAAuB,OAAO,+CAA+C,uCAAuC,4CAA4C,IAAI,sCAAsC,oCAAoC,sBAAsB,OAAO,iDAAiD,2BAA2B,oBAAoB,IAAI,iDAAiD,uCAAuC,2BAA2B,gDAAgD,kCAAkC,iDAAiD,uBAAuB,iBAAiB,OAAO,4CAA4C,gEAAgE,iDAAiD,eAAe,qDAAqD,8DAA8D,6CAA6C,eAAe,OAAO,qDAAqD,eAAe,WAAW,OAAO,yBAAyB,IAAI,wCAAwC,iDAAiD,0BAA0B,+BAA+B,KAAK,0CAA0C,8DAA8D,yCAAyC,yBAAyB,OAAO,0CAA0C,0BAA0B,OAAO,OAAO,qDAAqD,8BAA8B,mCAAmC,OAAO,IAAI,0CAA0C,iDAAiD,0BAA0B,+BAA+B,uHAAuH,OAAO,+BAA+B,KAAK,wCAAwC,qEAAqE,IAAI,8CAA8C,+CAA+C,uBAAuB,uBAAuB,IAAI,uDAAuD,+BAA+B,qBAAqB,OAAO,yBAAyB,kCAAkC,gDAAgD,wDAAwD,wDAAwD,2CAA2C,gCAAgC,OAAO,mCAAmC,gEAAgE,OAAO,kCAAkC,8DAA8D,OAAO,OAAO,2CAA2C,QAAQ,IAAI,mBAAmB,wQAAwQ,mBAAmB,6CAA6C,mGAAmG,cAAc,EAAE,EAAE,gIAAgI,6HAA6H,8FAA8F,iEAAiE,qBAAqB,+BAA+B,4BAA4B,0DAA0D,uCAAuC,uBAAuB,OAAO,OAAO,8BAA8B,OAAO,IAAI,gFAAgF,sCAAsC,uDAAuD,OAAO,OAAO,8BAA8B,OAAO,IAAI,mGAAmG,8DAA8D,yBAAyB,eAAe,OAAO,0EAA0E,WAAW,uBAAuB,OAAO,OAAO,+BAA+B,OAAO,IAAI,4DAA4D,sCAAsC,uBAAuB,OAAO,OAAO,8BAA8B,OAAO,IAAI,4CAA4C,kBAAkB,oBAAoB,wBAAwB,kBAAkB,6GAA6G,OAAO,OAAO,qBAAqB,qFAAqF,OAAO,IAAI,8CAA8C,6CAA6C,qCAAqC,oRAAoR,IAAI,oDAAoD,8BAA8B,oBAAoB,OAAO,+BAA+B,8BAA8B,wBAAwB,iDAAiD,OAAO,EAAE,GAAG,EAAE,yDAAyD,8BAA8B,oBAAoB,OAAO,4CAA4C,cAAc,mCAAmC,EAAE,yEAAyE,gCAAgC,sCAAsC,OAAO,sDAAsD,0BAA0B,wCAAwC,kEAAkE,mBAAmB,OAAO,0CAA0C,mBAAmB,eAAe,OAAO,wCAAwC,kHAAkH,mBAAmB,OAAO,0FAA0F,mBAAmB,eAAe,WAAW,iCAAiC,OAAO,EAAE,GAAG,EAAE,gEAAgE,8BAA8B,oBAAoB,OAAO,+BAA+B,8BAA8B,wBAAwB,2DAA2D,OAAO,EAAE,GAAG,EAAE,mDAAmD,iCAAiC,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,gBAAgB,iLAAiL,GAAG,EAAE,+CAA+C,iEAAiE,EAAE,GAAG,EAAE,6CAA6C,wDAAwD,GAAG,EAAE,kDAAkD,iEAAiE,GAAG,EAAE,mDAAmD,gEAAgE,GAAG,EAAE,wCAAwC,qCAAqC,mBAAmB,WAAW,wBAAwB,sCAAsC,QAAQ,OAAO,kCAAkC,2CAA2C,oBAAoB,mCAAmC,oBAAoB,IAAI,kDAAkD,sKAAsK,IAAI,oDAAoD,4KAA4K,IAAI,+CAA+C,0BAA0B,gBAAgB,kCAAkC,aAAa,8CAA8C,4CAA4C,4CAA4C,0CAA0C,oBAAoB,8BAA8B,OAAO,kBAAkB,8BAA8B,OAAO,kBAAkB,8BAA8B,OAAO,kBAAkB,8BAA8B,OAAO,kBAAkB,8BAA8B,OAAO,OAAO,8BAA8B,OAAO,8FAA8F,GAAG,0CAA0C,iCAAiC,mEAAmE,uCAAuC,oDAAoD,IAAI,+CAA+C,uCAAuC,iBAAiB,qBAAqB,sBAAsB,uCAAuC,WAAW,OAAO,2CAA2C,WAAW,QAAQ,gCAAgC,6CAA6C,IAAI,sFAAsF,gFAAgF,IAAI,qFAAqF,sCAAsC,uCAAuC,0DAA0D,yBAAyB,6BAA6B,WAAW,OAAO,EAAE,mFAAmF,IAAI,iGAAiG,qCAAqC,qCAAqC,4CAA4C,qCAAqC,iJAAiJ,8FAA8F,gCAAgC,0CAA0C,mBAAmB,wBAAwB,eAAe,4CAA4C,oCAAoC,iDAAiD,uBAAuB,uFAAuF,oDAAoD,mBAAmB,WAAW,yJAAyJ,+DAA+D,8CAA8C,uBAAuB,+CAA+C,mBAAmB,eAAe,+CAA+C,uCAAuC,eAAe,0BAA0B,WAAW,SAAS,aAAa,4CAA4C,wBAAwB,wBAAwB,WAAW,OAAO,aAAa,uCAAuC,4CAA4C,oFAAoF,mFAAmF,4FAA4F,OAAO,gDAAgD,yCAAyC,mCAAmC,4EAA4E,OAAO,yBAAyB,IAAI,sGAAsG,qCAAqC,8CAA8C,qCAAqC,iJAAiJ,8FAA8F,gCAAgC,0CAA0C,mBAAmB,wBAAwB,eAAe,+CAA+C,mDAAmD,gCAAgC,gCAAgC,mBAAmB,wBAAwB,eAAe,qGAAqG,6DAA6D,yBAAyB,OAAO,+CAA+C,yBAAyB,mCAAmC,oCAAoC,eAAe,0BAA0B,0DAA0D,4BAA4B,eAAe,0BAA0B,WAAW,SAAS,aAAa,gDAAgD,wBAAwB,wBAAwB,WAAW,OAAO,aAAa,sCAAsC,qEAAqE,4CAA4C,gFAAgF,mFAAmF,4FAA4F,OAAO,qBAAqB,IAAI,wFAAwF,sCAAsC,8CAA8C,qCAAqC,iJAAiJ,oEAAoE,oEAAoE,wFAAwF,eAAe,oBAAoB,kEAAkE,4BAA4B,eAAe,0BAA0B,WAAW,SAAS,aAAa,oCAAoC,gCAAgC,wBAAwB,WAAW,OAAO,aAAa,oCAAoC,yEAAyE,4CAA4C,gFAAgF,mFAAmF,4FAA4F,OAAO,qBAAqB,IAAI,iFAAiF,8BAA8B,8BAA8B,4BAA4B,qBAAqB,gFAAgF,OAAO,wBAAwB,mBAAmB,IAAI,8CAA8C,4CAA4C,IAAI,mCAAmC,4EAA4E,iGAAiG,iDAAiD,4BAA4B,+CAA+C,OAAO,OAAO,iFAAiF,qGAAqG,4CAA4C,+CAA+C,uBAAuB,6CAA6C,QAAQ,OAAO,4CAA4C,sCAAsC,WAAW,uBAAuB,kCAAkC,mCAAmC,gGAAgG,8DAA8D,kCAAkC,iEAAiE,oDAAoD,QAAQ,OAAO,oCAAoC,+BAA+B,2CAA2C,aAAa,OAAO,4BAA4B,yHAAyH,aAAa,WAAW,mBAAmB,SAAS,GAAG,qHAAqH,oCAAoC,sEAAsE,KAAK,EAAE,GAAG,eAAe,eAAe,EAAE;AACtqnG,E;;;;;;;;;;;;ACFa;;AAEb;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqC;AACR;AACkB;AACH;AACU;AACZ;AACE;AACE;AACI;AACK;;AAEvD;AACA,UAAU,gDAAI;AACd,gBAAgB,4DAAU;AAC1B,eAAe,0DAAS;AACxB,wBAAwB,2DAAkB;AAC1C,kBAAkB,qDAAY;AAC9B,mBAAmB,sDAAa;AAChC,YAAY,kDAAM;AAClB,eAAe,mDAAS;AACxB,eAAe,wDAAS;;;AAGxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,wDAAK;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,KAAK;;AAEL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK,aAAa;;AAElB;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,iGAAiG;;AAE1H,yBAAyB,yBAAyB,EAAE;AACpD;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,0CAA0C;AACvF;;AAEA;AACA;;AAEA;AACA,wCAAwC;AACxC,wEAAwE;;AAExE,0CAA0C,yDAAyD;;AAEnG,gCAAgC;;AAEhC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA,yEAAyE;AACzE;AACA,6FAA6F;AAC7F;AACA,0FAA0F;AAC1F;AACA,uFAAuF;AACvF;AACA,sEAAsE;AACtE;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,kHAAkH,8EAA8E;AAChM,0GAA0G;AAC1G,+GAA+G;AAC/G;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAG0C;;;;;;;;;;;;;ACznB1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqC;AACT;AAC4D;AAC5B;AAC6C;AAC3D;AACH;AACY;;AAEvD;AACA,qBAAqB,oDAAe,iBAAiB,kDAAa;AAClE,oBAAoB,wDAAc;AAClC,WAAW,kDAAK,SAAS,kDAAK,SAAS,kDAAK,SAAS,kDAAK,SAAS,kDAAK;AACxE,YAAY,kDAAM;AAClB,WAAW,gDAAK;AAChB,YAAY,wDAAK;AACjB,eAAe,wDAAS;;;AAGxB;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGoG;;;;;;;;;;;;;;;;AC7BpG;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,yBAAyB;AACzB,wBAAwB;AACxB,0BAA0B;AAC1B,yCAAyC;AACzC,4BAA4B;AAC5B,kCAAkC;AAClC,2EAA2E;AAC3E,6BAA6B;AAC7B,gCAAgC;AAChC,+BAA+B;AAC/B,4BAA4B;AAC5B,YAAY;;AAEZ,+BAA+B;AAC/B,sCAAsC;AACtC,2CAA2C;AAC3C,YAAY;;AAEZ,6BAA6B;AAC7B,gCAAgC;AAChC,+BAA+B;AAC/B,YAAY;;AAEZ,+BAA+B;AAC/B,gCAAgC;AAChC,oCAAoC;AACpC,iCAAiC;AACjC,kCAAkC;AAClC,8BAA8B;AAC9B,YAAY;;AAEZ,qCAAqC;AACrC,2CAA2C;AAC3C,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,iFAAiF,kEAAkE,0EAA0E,4EAA4E,wEAAwE;AACjX;AACA,kFAAkF,kEAAkE,uEAAuE,4EAA4E;AACvS;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,sCAAsC;AACtC;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,+CAA+C;AAC/C,iDAAiD;AACjD,2CAA2C;AAC3C,2CAA2C;AAC3C,4CAA4C;AAC5C;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC,qEAAqE;AACrE,qEAAqE;AACrE,qEAAqE;AACrE,qEAAqE;AACrE,KAAK;AACL,kCAAkC;AAClC,qEAAqE;AACrE,qEAAqE;AACrE,qEAAqE;AACrE,qEAAqE;AACrE;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,aAAa;AACb,mEAAmE;AACnE,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE;AACtE,aAAa;AACb,sEAAsE;AACtE;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;AACA;;AAEA;;AAEA,wC;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wC;;AAEA,6CAA6C,QAAQ;AACrD;AACA,sGAAsG;AACtG;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,sEAAsE;AACtE;AACA,8EAA8E;AAC9E;AACA,8EAA8E;AAC9E;AACA;AACA,aAAa;AACb,sEAAsE;AACtE;AACA,8EAA8E;AAC9E;AACA,8EAA8E;AAC9E;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGe,8EAAe,EAAC;;;;;;;;;;;;;;;;;AC5rB/B;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;AACA,SAAS,wBAAwB;AACjC;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kCAAkC,kCAAkC,QAAQ,UAAU;;AAEtF;AACA;AACA,kCAAkC,sCAAsC,QAAQ,SAAS;AACzF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,YAAY,OAAO;AAClE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0HAA0H;;AAE1H,0BAA0B;;AAE1B,8DAA8D,QAAQ,UAAU;AAChF,6DAA6D,QAAQ,WAAW;AAChF,gEAAgE,QAAQ,SAAS;;AAEjF;AACA,+GAA+G;AAC/G;;AAEA;AACA;AACA;AACA,wHAAwH;AACxH,+CAA+C;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;;AAE7C,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;;AAEA,0BAA0B;;AAE1B;AACA;AACA,qFAAqF,OAAO;;AAE5F;AACA;AACA,kDAAkD,OAAO;;AAEzD;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,wDAAwD,OAAO;;AAE/D;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,iEAAiE,OAAO;;AAExE;AACA;AACA,8DAA8D,OAAO;;AAErE;AACA;AACA,qEAAqE,OAAO;AAC5E,iEAAiE,OAAO;;AAExE;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA,uDAAuD;AACvD,0BAA0B;;AAE1B;AACA;AACA,+D;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA,uDAAuD,YAAY,OAAO;;AAE1E;AACA;AACA,mDAAmD,YAAY,OAAO;;AAEtE;AACA;AACA,uEAAuE,YAAY,OAAO;;AAE1F;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,8EAA8E,OAAO;;AAErF;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,a;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD,qCAAqC,6CAA6C,SAAS;;AAE3F;AACA;AACA,iDAAiD;AACjD,sEAAsE,6CAA6C,SAAS;;AAE5H;AACA;AACA,0CAA0C,iCAAiC,SAAS;;AAEpF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,OAAO;;AAExD;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA,uDAAuD,OAAO;;AAE9D;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,uDAAuD,OAAO;;AAE9D;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA,uDAAuD,OAAO;;AAE9D;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,+EAA+E,OAAO;;AAEtF;AACA;AACA,+EAA+E,OAAO;;AAEtF;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA,uFAAuF,OAAO;;AAE9F;AACA;AACA,6DAA6D,OAAO;;AAEpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,6DAA6D;;AAE5F;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,+DAA+D;AAC/D,kEAAkE;AAClE,oEAAoE;AACpE,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA;;AAEA;AACA;;AAEe,6EAAc,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;AC/egB;AACF;AACG;AACT;AACA;AACE;AACA;AACA;AACU;;AAElD;AACA,WAAW,kDAAK;AAChB,WAAW,gDAAK;AAChB,YAAY,kDAAM;AAClB,qBAAqB,8CAAe;AACpC,qBAAqB,8CAAe;AACpC,sBAAsB,+CAAgB;AACtC,sBAAsB,+CAAgB;AACtC,sBAAsB,+CAAgB;AACtC,2BAA2B,oDAAqB;;;AAGhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6B;AACA,kC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,6FAA6F,6BAA6B;AAC1H,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oB;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,E;;AAET;AACA,sCAAsC,QAAQ;AAC9C,wB;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb;;AAEA;AACA,sCAAsC,QAAQ;AAC9C,wB;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,WAAW;AAClC,2BAA2B,WAAW;AACtC;AACA;;AAEA;AACA,a;AACA;AACA;;;AAGA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,a;AACA;;;AAGA;;AAEA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb;;;AAGA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;AAGe,wEAAS,EAAC;;;;;;;;;;;;;;;AC/TzB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,4BAA4B;AAC5B,2EAA2E;AAC3E,6BAA6B;AAC7B,4BAA4B;AAC5B,+BAA+B;AAC/B,kCAAkC;AAClC,2BAA2B;AAC3B,4BAA4B;AAC5B,+BAA+B;AAC/B,wDAAwD;AACxD,kCAAkC;AAClC,sCAAsC;AACtC,gCAAgC;AAChC,0BAA0B;AAC1B,6BAA6B;AAC7B,YAAY;;AAEZ,qCAAqC;AACrC,+BAA+B;AAC/B,gCAAgC;AAChC,YAAY;;AAEZ,oCAAoC;AACpC,kCAAkC;AAClC,YAAY;;AAEZ,oCAAoC;AACpC,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,oCAAoC;AACpC,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,sCAAsC;AACtC,YAAY;;AAEZ,uCAAuC;AACvC,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,uCAAuC;AACvC,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,0CAA0C;AAC1C,6CAA6C;AAC7C,YAAY;;AAEZ,0CAA0C;AAC1C,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,0CAA0C;AAC1C,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,sCAAsC;AACtC,kCAAkC;AAClC,YAAY;;AAEZ,yCAAyC;AACzC,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,yCAAyC;AACzC,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,sCAAsC;AACtC,YAAY;;AAEZ,4CAA4C;AAC5C,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,4CAA4C;AAC5C,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,sCAAsC;AACtC,kCAAkC;AAClC,YAAY;;AAEZ,mCAAmC;AACnC,+BAA+B;AAC/B,4BAA4B;AAC5B,YAAY;;AAEZ,kCAAkC;AAClC,4BAA4B;AAC5B,4BAA4B;AAC5B,6BAA6B;AAC7B,sCAAsC;AACtC,gCAAgC;AAChC,4BAA4B;AAC5B,YAAY;;AAEZ,mCAAmC;AACnC,4BAA4B;AAC5B,4BAA4B;AAC5B,sCAAsC;AACtC,YAAY;;AAEZ,oCAAoC;AACpC,2BAA2B;AAC3B,kCAAkC;AAClC,YAAY;;AAEZ,6BAA6B;AAC7B,2BAA2B;AAC3B,YAAY;;AAEZ,+CAA+C;AAC/C,2BAA2B;AAC3B,YAAY;;AAEZ,6BAA6B;AAC7B,4BAA4B;AAC5B,qCAAqC;AACrC,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,YAAY;;AAEZ,8BAA8B;AAC9B,4BAA4B;AAC5B,qCAAqC;AACrC,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,YAAY;;AAEZ,4CAA4C;AAC5C,4BAA4B;AAC5B,4BAA4B;AAC5B,YAAY;;AAEZ,8BAA8B;AAC9B,2BAA2B;AAC3B,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,qBAAqB;AACrB,uBAAuB;AACvB,oBAAoB;AACpB;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,yBAAyB;AACzB,2BAA2B;AAC3B,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qC;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA,wB;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,S;;AAEA,6C;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA,wB;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iBAAiB;AACjB;;AAEA;AACA,oD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kD;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,yB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6HAA6H;AAC7H;AACA,yB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,yB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,+HAA+H;AAC/H;AACA,yB;AACA;AACA;AACA;AACA,S;AACA;AACA;;;AAGA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,S;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;AACA,oHAAoH;AACpH,qHAAqH;AACrH;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA;AACA;AACA;AACA,2HAA2H;AAC3H,4HAA4H;AAC5H;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mGAAmG,2B;;AAEnG,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE;AACvE,wEAAwE;AACxE,wEAAwE;AACxE,oDAAoD;AACpD;;AAEA;AACA;;;AAGA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,0CAA0C;;AAE1C,2CAA2C,QAAQ;AACnD;;AAEA;AACA;;AAEA;AACA,oCAAoC;AACpC,2CAA2C;AAC3C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4CAA4C;;AAE5C,2CAA2C,QAAQ;AACnD;;AAEA;AACA,oCAAoC;AACpC,2CAA2C;AAC3C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,a;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGe,8EAAe,EAAC;;;;;;;;;;;;;;;;;;ACz6BmB;AACN;AACiB;;AAE7D;AACA,WAAW,gDAAK;AAChB,iBAAiB,6DAAW;AAC5B,WAAW,kDAAK,SAAS,kDAAK;;;AAG9B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,4BAA4B;AAC5B,6EAA6E;AAC7E,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,+BAA+B;AAC/B,kCAAkC;AAClC,2BAA2B;AAC3B,yBAAyB;AACzB,+BAA+B;AAC/B,wDAAwD;AACxD,kCAAkC;AAClC,sCAAsC;AACtC,gCAAgC;AAChC,0BAA0B;AAC1B,6BAA6B;AAC7B,YAAY;;AAEZ,mCAAmC;AACnC,4BAA4B;AAC5B,4BAA4B;AAC5B,2BAA2B;AAC3B,YAAY;;AAEZ,oCAAoC;AACpC,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,YAAY;;AAEZ,8BAA8B;AAC9B,4BAA4B;AAC5B,kCAAkC;AAClC,sCAAsC;AACtC,kCAAkC;AAClC,YAAY;;AAEZ,6BAA6B;AAC7B,2BAA2B;AAC3B,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,YAAY;;AAEZ,mCAAmC;AACnC,4BAA4B;AAC5B,YAAY;;AAEZ,iCAAiC;AACjC,2BAA2B;AAC3B,iCAAiC;AACjC,kCAAkC;AAClC,YAAY;;AAEZ,mCAAmC;AACnC,iCAAiC;AACjC,YAAY;;AAEZ,oCAAoC;AACpC,4BAA4B;AAC5B,YAAY;;AAEZ,kCAAkC;AAClC,2BAA2B;AAC3B,iCAAiC;AACjC,kCAAkC;AAClC,YAAY;;AAEZ,oCAAoC;AACpC,iCAAiC;AACjC,YAAY;;AAEZ,0CAA0C;AAC1C,sCAAsC;AACtC,YAAY;;AAEZ,wCAAwC;AACxC,+BAA+B;AAC/B,YAAY;;AAEZ,6BAA6B;AAC7B,4BAA4B;AAC5B,6BAA6B;AAC7B,kCAAkC;AAClC,sCAAsC;AACtC,kCAAkC;AAClC,gCAAgC;AAChC,+BAA+B;AAC/B,qCAAqC;AACrC,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0F;AACA;AACA,8F;AACA;AACA,gG;AACA;AACA,4F;AACA;AACA,gG;AACA;AACA,gG;AACA;AACA,4F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,sD;AACA;;AAEA;AACA;AACA,sD;AACA;;AAEA;AACA,sD;AACA,S;AACA,KAAK;AACL;AACA;AACA;AACA,wD;AACA;;AAEA;AACA;AACA,wD;AACA;;AAEA;AACA,wD;AACA,S;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,kD;AACA,KAAK;AACL,oD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,6CAA6C;AAC9E;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C,uCAAuC,mBAAmB;;AAE1D;AACA;AACA;;AAEA;AACA;AACA,K;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,4CAA4C,uDAAuD;AACnG;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,iC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,y7D;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wC;;AAEA,Y;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA,oDAAoD;AACpD,sDAAsD;AACtD,uDAAuD;AACvD,qDAAqD;AACrD,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;;AAEA,+C;AACA;;AAEA;AACA;AACA;AACA,2C;AACA;;AAEA;AACA;AACA,oE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,QAAQ;AACvB;;AAEA;;AAEA;AACA;AACA,yE;AACA,yE;AACA;AACA,iC;AACA;;AAEA;AACA,6E;AACA,6E;AACA;AACA,mC;AACA;;AAEA;AACA,+E;AACA,+E;AACA;AACA,oC;AACA;;AAEA;AACA,2E;AACA,2E;AACA;AACA,kC;AACA;;AAEA;AACA,+E;AACA,+E;AACA;AACA,oC;AACA;;AAEA;AACA;AACA;;AAEA,qE;AACA,qE;AACA;AACA,8B;;AAEA,yE;AACA,yE;AACA;AACA,gC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,8BAA8B;AACxD,4BAA4B,kCAAkC;AAC9D,6BAA6B,oCAAoC;AACjE,2BAA2B,gCAAgC;AAC3D,6BAA6B,oCAAoC;AACjE,2BAA2B,gCAAgC;AAC3D,6BAA6B,oCAAoC;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uJ;AACA,uH;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,6EAA6E,MAAM;;AAEnF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGe,8EAAe,EAAC;;;;;;;;;;;;;;;;;;AC14BQ;;;AAGvC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,2BAA2B;AAC3B,2EAA2E;AAC3E,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,+BAA+B;AAC/B,kCAAkC;AAClC,2BAA2B;AAC3B,yBAAyB;AACzB,+BAA+B;AAC/B,wDAAwD;AACxD,kCAAkC;AAClC,sCAAsC;AACtC,gCAAgC;AAChC,0BAA0B;AAC1B,6BAA6B;AAC7B,YAAY;;AAEZ,kCAAkC;AAClC,+BAA+B;AAC/B,kCAAkC;AAClC,gCAAgC;AAChC,YAAY;;AAEZ,wCAAwC;AACxC,6BAA6B;AAC7B,gCAAgC;AAChC,+BAA+B;AAC/B,YAAY;;AAEZ,2CAA2C;AAC3C,mCAAmC;AACnC,YAAY;;AAEZ,iCAAiC;AACjC,2BAA2B;AAC3B,YAAY;AACZ;;AAEA;AACA;AACA;AACA,kEAAkE,MAAM,MAAM,KAAK,4DAAc;AACjG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGe,6EAAc,EAAC;;;;;;;;;;;;;;;;ACvM9B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,mCAAmC;AACnC,4BAA4B;AAC5B,YAAY;;AAEZ,mCAAmC;AACnC,2EAA2E;AAC3E,6BAA6B;AAC7B,4BAA4B;AAC5B,6BAA6B;AAC7B,6BAA6B;AAC7B,+BAA+B;AAC/B,kCAAkC;AAClC,2BAA2B;AAC3B,4BAA4B;AAC5B,+BAA+B;AAC/B,wDAAwD;AACxD,kCAAkC;AAClC,sCAAsC;AACtC,gCAAgC;AAChC,0BAA0B;AAC1B,6BAA6B;AAC7B,YAAY;;AAEZ,0CAA0C;AAC1C,2BAA2B;AAC3B,4BAA4B;AAC5B,YAAY;;AAEZ,yCAAyC;AACzC,2EAA2E;AAC3E,+BAA+B;AAC/B,yCAAyC;AACzC,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,kCAAkC;AAClC,4CAA4C;AAC5C,yCAAyC;AACzC,YAAY;;AAEZ,gDAAgD;AAChD,2EAA2E;AAC3E,+BAA+B;AAC/B,YAAY;;AAEZ,iDAAiD;AACjD,2EAA2E;AAC3E,+BAA+B;AAC/B,4BAA4B;AAC5B,yCAAyC;AACzC,wCAAwC;AACxC,yCAAyC;AACzC,kCAAkC;AAClC,iCAAiC;AACjC,YAAY;;AAEZ,+CAA+C;AAC/C,2EAA2E;AAC3E,+BAA+B;AAC/B,4BAA4B;AAC5B,yCAAyC;AACzC,wCAAwC;AACxC,yCAAyC;AACzC,kCAAkC;AAClC,YAAY;;AAEZ,wCAAwC;AACxC,sCAAsC;AACtC,yCAAyC;AACzC,wCAAwC;AACxC,2BAA2B;AAC3B,6BAA6B;AAC7B,4BAA4B;AAC5B,gCAAgC;AAChC,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA,K;;AAEA,yCAAyC,QAAQ;AACjD;AACA,mCAAmC;;AAEnC;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD;;AAEhD,kDAAkD,QAAQ;AAC1D;AACA;;AAEA,6BAA6B;AAC7B,aAAa;AACb;AACA;AACA;;AAEA,qBAAqB;AACrB;;AAEA,eAAe;;AAEf;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA,K;;AAEA;;AAEA;AACA;AACA;;;AAGe,mFAAoB,EAAC;;;;;;;;;;;;;;;;;;;;;AC/PC;AACT;AACS;AACrC,UAAU,gCAAgC;;AAE1C;AACA;AACA,WAAW,0CAAK;AAChB,YAAY,wDAAK;;;AAGjB;AACA;;AAEA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,KAAK;;AAEL;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,KAAK;;AAEL;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,KAAK;;AAEL;AACA;AACA,6BAA6B,aAAa;AAC1C,mBAAmB,6CAAM;AACzB;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA,EAAE;;;AAGF;AACA,qBAAqB,aAAa;AAClC;AACA;;AAEA;AACA,qBAAqB,aAAa;AAClC;AACA;;AAEA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGuB;;;;;;;;;;;;;;;AChGvB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGe,sEAAO,E;;;;;;;;;;;;;;;;;AChCY;AACa;AACI;;AAEnD;AACA,YAAY,kDAAM;AAClB,eAAe,mDAAS;AACxB,gBAAgB,+CAAU;;;AAG1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,CAAqB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,U;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iC;AACA;AACA;AACA,SAAS;;AAET,kCAAkC,EAAE;;AAEpC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+CAA+C,CAAqB,CAAC;AACrE,+CAA+C,CAAsB,CAAC;AACtE,+CAA+C,CAAqB,CAAC;AACrE;;AAEA,wJ;;AAEA,iDAAiD;;AAEjD;AACA;;AAEA;AACA,2DAA2D,CAAqB,CAAC;AACjF,2DAA2D,CAAqB,CAAC;AACjF,2DAA2D,CAAqB,CAAC;AACjF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,CAA0B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,QAAQ;AACzD;AACA,sE;AACA,SAAS;;AAET;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,kC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,2CAA2C,+BAA+B;AAC1E;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGe,4EAAa,EAAC;;;;;;;;;;;;;;;;;;AChP7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe,uEAAQ,E;;;;;;;;;;;;;;;;AC9MuB;AACF;;AAE5C;AACA,WAAW,kDAAK;AAChB,WAAW,gDAAK;;;AAGhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,4E;;AAEA;;AAEA,sDAAsD;AACtD,gDAAgD;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;;AAEA;;AAEA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGe,wEAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;ACjKkB;AACT;AACI;AACR;AACF;AACE;AACM;AACe;AACT;;AAE1C;AACA,gBAAgB,+CAAU;AAC1B,oBAAoB,oDAAc;AAClC,kBAAkB,iDAAY;AAC9B,cAAc,6CAAQ;AACtB,aAAa,4CAAO;AACpB,cAAc,6CAAQ;AACtB,iBAAiB,gDAAW;AAC5B,wBAAwB,wDAAkB;AAC1C,oBAAoB,mDAAc;;;AAGlC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA,2CAA2C;AAC3C;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGe,wEAAS,EAAC;;;;;;;;;;;;;;;;;;;ACtRqB;AACF;AACD;;AAE3C;AACA,WAAW,kDAAK;AAChB,WAAW,gDAAK;AAChB,oBAAoB,oDAAc;;;AAGlC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA,8F;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,8C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA,yEAAyE;AACzE;;AAEA;AACA;;AAEA,UAAU,kBAAkB;AAC5B;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEe,yEAAU,EAAC;;;;;;;;;;;;;;;;ACzWqB;;AAE/C;AACA,YAAY,kDAAM;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGe,wEAAS,EAAC;;;;;;;;;;;;;;;;AC5BzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGe,8EAAe,EAAC;;;;;;;;;;;;;;;;;ACpCc;AACE;;AAE/C;AACA,qBAAqB,qDAAe;AACpC,YAAY,kDAAM;;;AAGlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kFAAkF;;AAElF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kHAAkH,GAAqB;AACvI;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6D;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA,aAAa;;AAEb;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,gCAAgC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;;AAEhD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,K;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA,8BAA8B;;AAE9B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,sC;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,QAAQ;AACzD,uE;AACA;;AAEA,SAAS;;AAET;;AAEA;AACA,iDAAiD,QAAQ;AACzD,mE;AACA;AACA;;;AAGA,0CAA0C,QAAQ;;AAElD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qFAAqF;AACrF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,sGAAsG,CAAqB;AAC3H;;AAEA;AACA,mDAAmD,CAAuB;AAC1E;AACA;AACA;AACA,uDAAuD,CAA2B;AAClF,yCAAyC;AACzC;;AAEA;AACA,+CAA+C,CAAqB;AACpE;AACA,qCAAqC,E;;AAErC;AACA,mEAAmE,QAAQ;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF,oG;AACA;;AAEA;AACA,uDAAuD,CAAuB;AAC9E;AACA;AACA;AACA;AACA,2DAA2D,CAA2B;AACtF;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA,+CAA+C,CAAuB;AACtE;AACA;AACA;AACA,mDAAmD,CAAgB;AACnE,qCAAqC,E;;AAErC;AACA,+CAA+C,CAAqB;AACpE;AACA,qCAAqC,E;AACrC,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF,gG;AACA;;AAEA;AACA,mDAAmD,CAAuB;AAC1E;AACA;AACA;AACA,uDAAuD,CAAqB;AAC5E;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA,6BAA6B;AAC7B;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF,oG;AACA;;AAEA;AACA;AACA,uDAAuD,CAAuB;AAC9E;AACA;AACA;AACA,2DAA2D,CAAqB;AAChF;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA,iCAAiC;;AAEjC,8DAA8D;AAC9D;AACA;AACA,sGAAsG,CAAqB;AAC3H;;AAEA;AACA;AACA,mDAAmD,CAAuB;AAC1E;AACA;AACA;AACA,uDAAuD,CAAqB;AAC5E,yCAAyC;AACzC,qCAAqC;AACrC;AACA,mDAAmD,CAAuB;AAC1E;AACA;AACA;AACA,uDAAuD,CAAiB;AACxE,yCAAyC;AACzC;;AAEA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA,0FAA0F,CAAqB;AAC/G,6BAA6B;AAC7B;AACA,uCAAuC,CAAuB;AAC9D;AACA;AACA;AACA,2CAA2C,CAAqB;AAChE,6BAA6B,E;AAC7B;AACA;AACA,qB;AACA;AACA,aAAa;;AAEb;AACA;AACA,8EAA8E,CAAqB;AACnG,iBAAiB;AACjB;AACA,2BAA2B,CAAuB;AAClD;AACA;AACA;AACA,+BAA+B,CAAqB;AACpD,iBAAiB,E;AACjB;AACA;;AAEA;AACA;AACA,uBAAuB,CAAuB;AAC9C;AACA;AACA,2BAA2B,CAAkB;AAC7C,aAAa;;AAEb;;AAEA,+BAA+B,CAAkB;AACjD;;AAEA,uBAAuB,OAAO;AAC9B;AACA,iDAAiD,QAAQ;AACzD,4CAA4C,CAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,S;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C;AAC9C;;AAEA;AACA,2EAA2E;AAC3E,kGAAkG;AAClG,mEAAmE,+B;AACnE;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAA+D,gCAAgC;AAC/F;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yFAAyF,gCAAgC;AACzH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,iDAAiD,QAAQ;AACzD,+D;AACA;;AAEA;AACA,mBAAmB,CAAuB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,oD;;AAEA,qDAAqD;AACrD,yBAAyB;AACzB;;AAEA,+CAA+C;AAC/C,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,8B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2EAA2E,uBAAuB;;AAElG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;;AAEA,8CAA8C;AAC9C;AACA;;AAEA,4CAA4C;AAC5C;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iB;;AAEA;AACA;AACA;AACA,iB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAmE,QAAQ;AAC3E;;AAEA;AACA,sC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,+FAA+F,yBAAyB;;AAExH,iDAAiD,CAA0B;AAC3E;AACA;;AAEA,8CAA8C;AAC9C,+D;AACA,qB;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;;AAEA;AACA,qD;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA,yD;AACA;AACA;AACA;;AAEA,6C;AACA;;AAEA;AACA,KAAK,yCAAyC;AAC9C;AACA;AACA;AACA,kC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gHAAgH,yBAAyB;AACzI;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;;AAEA;AACA,kC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gHAAgH,yBAAyB;AACzI;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,+C;AACA,+C;AACA,+C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oIAAoI;AACpI;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+B;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;;AAEA;AACA;AACA;AACA,kD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,QAAQ;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;;AAGe,2EAAY,EAAC;;;;;;;;;;;;;;;;;;;;;ACjjCkB;AACF;AACR;AACS;AACJ;;AAEzC;AACA,WAAW,kDAAK;AAChB,WAAW,gDAAK;AAChB,mBAAmB,mDAAa;AAChC,qBAAqB,qDAAe;AACpC,iBAAiB,gDAAW;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,8CAA8C,0BAA0B;AACxE,iDAAiD,wBAAwB;AACzE,0CAA0C,yBAAyB;AACnE,0CAA0C,sCAAsC;AAChF,2CAA2C,sCAAsC;;AAEjF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;AACxB,4BAA4B;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD,uBAAuB,wBAAwB;AAClG,oDAAoD,sBAAsB,wBAAwB;AAClG,oDAAoD,uBAAuB,uBAAuB;AAClG,oDAAoD,uBAAuB,wBAAwB;AACnG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gC;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,kD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA,qD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK,OAAO;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,qF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4EAA4E;;AAE5E,iC;AACA,0C;;AAEA;AACA;AACA,8CAA8C,QAAQ;AACtD,uCAAuC;AACvC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,iD;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,QAAQ;AACtD,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wC;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wC;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2C;AACA,sD;;AAEA;AACA;AACA,wC;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;;AAEA;AACA,S;;AAEA,gDAAgD,QAAQ,OAAO;AAC/D,sC;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;AAChC;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;;AAEA,yC;AACA;AACA,sC;AACA;;AAEA,gCAAgC;AAChC,4B;;AAEA,sDAAsD,QAAQ;AAC9D;AACA;AACA;;AAEA,yC;AACA;AACA,sC;AACA;;AAEA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC;AACpC;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;;AAEA,yC;AACA;AACA,0C;AACA;;AAEA,oCAAoC;AACpC,4B;;AAEA,sDAAsD,QAAQ;AAC9D;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA,yC;AACA;AACA,0C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,2CAA2C;AAC3C;AACA,SAAS;;AAET;AACA;AACA,+KAA+K;;AAE/K,+B;AACA;AACA,yD;AACA;;AAEA;AACA,0DAA0D;;AAE1D;AACA;;AAEA;AACA,wCAAwC;;AAExC;;AAEA;;AAEA;AACA;AACA,iKAAiK;;AAEjK;AACA;;AAEA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA,aAAa,CAAuB;;AAEpC,oC;AACA,0E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,CAAuB;;AAEpC,kD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA,aAAa,CAAuB;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kD;AACA;;AAEA;AACA,sC;AACA;AACA;;AAEA;AACA;;AAEA,oC;AACA,0C;;AAEA;AACA;;AAEA;AACA,8B;AACA;;AAEA;;AAEA,aAAa,CAAuB;;AAEpC,kD;;AAEA;AACA,8B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA,aAAa,CAAqB;AAClC;AACA;;AAEA,aAAa,CAAuB;;AAEpC;AACA;AACA;;AAEA;AACA,kD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,CAAqB;AAC9C,yBAAyB,CAAqB;AAC9C,mCAAmC,CAAiB;AACpD,8B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,CAAuB;;AAEpC,kD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,8DAA8D,2BAA2B;AACzF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yFAAyF,2BAA2B;AACpH;;AAEA;AACA;;AAEA,wDAAwD,QAAQ;AAChE;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uC;AACA;;;AAGA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C,4B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,4C;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8B;AACA;;AAEA,qBAAqB;;AAErB,oF;AACA;;;AAGe,sEAAO,EAAC;;;;;;;;;;;;;;;;;;;;;ACj4BvB;AACqD;AACW;AACO;AACP;AAChE;AAC8D;;AAE9D;AACA;AACA,yBAAyB,yDAAmB;AAC5C,8BAA8B,+DAAwB;AACtD,iCAAiC,mEAA2B;AAC5D,8BAA8B,+DAAwB;;AAEtD;AACA,WAAW,kDAAK;AAChB,WAAW,kDAAK;;;AAGhB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,SAAS;AACT,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA,SAAS;AACT,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA,aAAa;AACb,gDAAgD,QAAQ;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gEAAgE,QAAQ;AACxE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,E;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,kCAAkC,QAAQ;AAC1C,uCAAuC;AACvC;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA,qCAAqC,QAAQ;AAC7C,yCAAyC;AACzC;AACA;;AAEA;;AAEA,2CAA2C;;AAE3C;;AAEA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C,uCAAuC;AACvC;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA,qCAAqC,QAAQ;AAC7C,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,gC;AACA,kC;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA,iC;AACA,mC;AACA,mC;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA,oC;AACA,sC;AACA,sC;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;;AAGA,qC;AACA,uC;AACA,uC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C,uCAAuC;AACvC;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA,qCAAqC,QAAQ;AAC7C,yCAAyC;AACzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,2C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,gC;AACA,kC;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iC;AACA,mC;AACA,mC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kEAAkE;AAClE;AACA;;AAEA;;AAEA;AACA;;AAEA,0BAA0B,aAAa;AACvC;AACA;;AAEA,8BAA8B,aAAa;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,8DAA8D;AAC9D;AACA;AACA;;AAEA,kB;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,QAAQ;AACjD;AACA,wC;AACA,0C;AACA,0C;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,yC;AACA,2C;AACA,2C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB;;AAElB;;AAEA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;;;AAG3B;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C,uCAAuC;AACvC;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA,qCAAqC,QAAQ;AAC7C,yCAAyC;AACzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,gC;AACA,kC;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iC;AACA,mC;AACA,mC;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C,0B;AACA,4B;;AAEA;AACA,gC;AACA,gC;AACA,SAAS;AACT,8B;AACA,8B;AACA;;AAEA;AACA;AACA;AACA,K;;AAEA,oBAAoB;AACpB;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA,oC;AACA,sC;AACA,sC;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,qC;AACA,uC;AACA,uC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD,sC;AACA,wC;;AAEA;AACA,4C;AACA,4C;AACA,aAAa;AACb,0C;AACA,0C;AACA;;AAEA;AACA;AACA;AACA,S;;AAEA,wBAAwB;AACxB;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,2EAA2E;AAC3E,6DAA6D;AAC7D;;AAEA;;AAEA;AACA,sD;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA,qCAAqC,QAAQ,S;AAC7C;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA,oCAAoC,QAAQ,S;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,QAAQ,O;AAChD;AACA;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,wC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;;;AAG7G;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;;AAE7G,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;;AAE7G;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;;AAE7G,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;;AAE7G,kD;AACA,qE;AACA;AACA;AACA;AACA;AACA,6GAA6G;;AAE7G;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,6EAA6E,YAAY;AACzF;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,yCAAyC,QAAQ;;AAEjD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA,qCAAqC;AACrC;AACA;AACA;;AAEA,mCAAmC;;AAEnC;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA,sDAAsD;AACtD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA,kCAAkC;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,2EAA2E;;AAEhI,SAAS;;AAET;;AAEA;;AAEA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,QAAQ;;AAEtD;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,wGAAwG;AAC7J,SAAS;;AAET;AACA;AACA,6CAA6C;;AAE7C,qDAAqD,6GAA6G;AAClK;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;;AAEvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;;AAE3D,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;AAC3D;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;;AAEvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,QAAQ;AAChD,iC;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C,gC;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA,0CAA0C,QAAQ;AAClD,mC;AACA;;AAEA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,uCAAuC,8BAA8B;AACrE,uCAAuC,8BAA8B;AACrE,uCAAuC,8BAA8B;;AAErE,uCAAuC,8BAA8B;AACrE,uCAAuC,8BAA8B;AACrE,uCAAuC,8BAA8B;;AAErE;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,qB;AACA;;AAEe,gFAAiB,EAAC;;;;;;;;;;;;;;;;;AC/8Da;AAC9C,UAAU,cAAc,sBAAsB;;AAE9C;AACA,WAAW,kDAAK;AAChB,mBAAmB;;;AAGnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C,2EAA2E;AAC3E;AACA;AACA;AACA,sHAAsH;AACtH;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8C;;AAEA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA;AACA,0BAA0B;;AAE1B;AACA,gCAAgC;AAChC;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2B;;AAEA;AACA,+B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,M;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,kD;;AAEA;AACA;AACA;AACA,kD;;AAEA;AACA;AACA;AACA,kD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEe,iFAAkB,EAAC;;;;;;;;;;;;;;;;;;;;;AClUa;AACE;AACC;AACI;;;;AAItD;AACA,WAAW,gDAAK;AAChB,WAAW,kDAAK;AAChB,YAAY,kDAAM;AAClB,eAAe,mDAAS;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb,qCAAqC,oCAAoC;AACzE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGe,sFAAuB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5JQ;AACE;AACC;AACI;;;;AAItD;AACA,WAAW,gDAAK;AAChB,WAAW,kDAAK;AAChB,YAAY,kDAAM;AAClB,eAAe,mDAAS;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC,OAAO;AAC9C,uCAAuC,OAAO;AAC9C,uCAAuC,OAAO;AAC9C,uCAAuC,OAAO;AAC9C,iBAAiB;;AAEjB,wDAAwD;;AAExD;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;;;AAGtB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEe,uFAAwB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;ACjUxC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,sFAAuB,EAAC;;;;;;;;;;;;;;;;ACnIvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;;AAEA,wDAAwD,QAAQ;AAChE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;;AAE7B,qDAAqD,QAAQ;AAC7D;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEe,yFAA0B,EAAC;;;;;;;;;;;;;;;;;ACzG1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,iBAAiB,mBAAO,CAAC,yKAAmD;AAC5E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC,4CAA4C;AAChF;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,QAAQ;AACzD;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB;;AAEnB;;AAEA,0B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,2EAA2E;;AAE3E;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,kBAAkB;AACtD;;;AAGA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE;AACA;;;AAGe,kFAAmB,EAAC;;;;;;;;;;;;;;;;;;;;AC/PW;AACF;AACG;AACD;AACmB;;AAEjE;AACA,WAAW,kDAAK,SAAS,gDAAK,UAAU,kDAAM;AAC9C,eAAe,2DAAS;AACxB,0BAA0B,oEAAoB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oCAAoC;;AAEpC;AACA,iBAAiB,CAA6B;AAC9C;AACA,+CAA+C;AAC/C,8FAA8F;AAC9F;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,EAA2B;AAC5C,uDAAuD;AACvD;AACA;;AAEA,iBAAiB,CAAgC;AACjD;AACA;;AAEA,iBAAiB,CAA+B;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;;AAGL,oD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA,+DAA+D,OAAO,EAA0B,SAAS,8EAA8E;;AAEvL;AACA;;AAEA;AACA,mCAAmC,QAAQ;AAC3C,mEAAmE,OAAO,EAAoB,SAAS,mBAAmB,EAAE;AAC5H;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;AAC9C,mEAAmE,OAAO,EAAyB,SAAS,sBAAsB,EAAE;AACpI;;AAEA,+DAA+D,OAAO,EAAwB,UAAU,EAAE;;AAE1G;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;;AAE9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,+DAA+D;AAC/D;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA,iBAAiB,UAAU,UAAU;AACrC,iBAAiB,UAAU,UAAU;AACrC,iBAAiB,UAAU,WAAW;AACtC,wCAAwC,iCAAiC,iCAAiC;AAC1G,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAmD,QAAQ;AAC3D,0C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA,aAAa;AACb;AACA,a;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEe,6EAAc,EAAC;;;;;;;;;;;;;;;;;;AC1XO;AACU;AACI;;AAEnD;AACA,WAAW,sDAAK;AAChB,YAAY,kDAAM;AAClB,wBAAwB,wDAAkB;;;AAG1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA,KAAK;AACL,kC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,4G;;AAEA;AACA,8DAA8D,c;;AAE9D;AACA,qBAAqB;;AAErB;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;;AAEA,4C;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA,+EAA+E,6DAA6D;AAC5I;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEe,yEAAU,EAAC;;;;;;;;;;;;;;;;;;;;;;ACxLgB;AACC;AACP;AACE;AACa;;AAEnD;AACA,oBAAoB,mDAAc;AAClC,oBAAoB,oDAAc;AAClC,iBAAiB,gDAAW;AAC5B,kBAAkB,iDAAY;AAC9B,wBAAwB,wDAAkB;;;AAG1C;AACA;AACA;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,iC;AACA;;;AAGA;AACA,8C;AACA;;;AAGA;AACA,4C;AACA,EAAE;;;AAGF;AACA;AACA,sC;AACA;;;AAGA;AACA,kC;AACA;;;AAGA;AACA,+C;AACA;;;AAGA;AACA,6C;AACA,EAAE;;AAEF;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,sD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,+CAA+C,yBAAyB;AACxE;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA,S;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGe,2EAAY,EAAC;;;;;;;;;;;;;;;;ACpfsB;;AAElD;AACA,YAAY,kDAAM;;;AAGlB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,mBAAO,CAAC,8JAAmD;;AAEhF;;AAEA;AACA;AACA;;AAEA;;AAEA,wCAAwC,wCAAwC;AAChF;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC;AACzC,gDAAgD,6KAA6K;AAC7N;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2C;AACA,KAAK;AACL,yBAAyB,iFAAiF;AAC1G;;AAEA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA;AACA,a;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,oB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,iBAAiB;AACzD;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;;;AAGe,wEAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClWqB;AACC;AACS;AAC1B;AACe;AACE;AACnB;AACI;AACE;AACA;AACE;AACA;AACN;AACW;AACH;AACO;AACb;AACqB;AACzB;AACsB;;AAElD;AACA,WAAW,kDAAK;AAChB,YAAY,kDAAM;AAClB,eAAe,wDAAS;AACxB,cAAc,6CAAQ;AACtB,qBAAqB,qDAAe;AACpC,sBAAsB,sDAAgB;AACtC,aAAa,4CAAO;AACpB,eAAe,8CAAS;AACxB,gBAAgB,+CAAU;AAC1B,gBAAgB,+CAAU;AAC1B,iBAAiB,iDAAW;AAC5B,iBAAiB,iDAAW;AAC5B,cAAc,8CAAQ;AACtB,gBAAgB,uDAAU;AAC1B,kBAAkB,kDAAY;AAC9B,qBAAqB,sDAAe;AACpC,eAAe,+CAAS;AACxB,yBAAyB,0DAAmB;AAC5C,aAAa,6CAAO;AACpB,iBAAiB,8DAAW;;;AAG5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB;AACpB,wBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,0C;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA,0B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8C;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA,KAAK;;AAEL;AACA,0B;AACA,gC;;AAEA;AACA;AACA,8C;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,6C;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa;AAC9C;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA,aAAa;AACb,uB;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,+C;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B,wCAAwC;AACxC;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA,YAAY;AACZ;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,8FAA8F;AAC9F,yHAAyH,mBAAmB;AAC5I,4HAA4H,mBAAmB;AAC/I,gIAAgI,mBAAmB;AACnJ,oIAAoI;AACpI,gIAAgI;AAChI,wIAAwI;AACxI,0IAA0I;AAC1I,uGAAuG,wBAAwB;AAC/H,+GAA+G;AAC/G,wIAAwI;AACxI,oJAAoJ;AACpJ,gGAAgG,eAAe,8CAA8C,mBAAmB,EAAE;AAClL,sGAAsG,eAAe,kEAAkE,mBAAmB,EAAE;AAC5M,2GAA2G;AAC3G,sGAAsG;AACtG,uGAAuG;AACvG,+GAA+G;AAC/G,2GAA2G;AAC3G,2GAA2G;AAC3G,0GAA0G;AAC1G,2GAA2G;AAC3G,6GAA6G;AAC7G,4GAA4G;AAC5G,0GAA0G,kGAAkG;AAC5M,yGAAyG;AACzG,2GAA2G;AAC3G,8GAA8G;AAC9G,0GAA0G;AAC1G,2GAA2G;AAC3G,kJAAkJ;AAClJ,mJAAmJ;AACnJ,4GAA4G;AAC5G,2GAA2G;AAC3G,gHAAgH;AAChH,oHAAoH;AACpH,4GAA4G;AAC5G,2GAA2G;AAC3G,0GAA0G;AAC1G,+MAA+M;AAC/M,8HAA8H;AAC9H,uGAAuG;AACvG,uGAAuG;AACvG,sGAAsG;AACtG,uIAAuI;AACvI,gIAAgI;AAChI,8HAA8H;AAC9H,kJAAkJ;AAClJ,6IAA6I;AAC7I,8GAA8G;AAC9G,sFAAsF;AACtF,4GAA4G;AAC5G,wGAAwG;AACxG,uGAAuG;AACvG,yGAAyG;AACzG,0GAA0G;AAC1G,4KAA4K;AAC5K,qKAAqK;AACrK,0GAA0G;AAC1G,6GAA6G;AAC7G,4GAA4G;AAC5G,6GAA6G;AAC7G,6GAA6G;AAC7G,2GAA2G;AAC3G,+HAA+H;AAC/H,8GAA8G;AAC9G,6GAA6G;AAC7G,8GAA8G;AAC9G,oHAAoH;AACpH,4HAA4H,O;AAC5H,yHAAyH;AACzH,4EAA4E;AAC5E,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yE;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yC;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;;AAGA;;AAEA;;AAEA;AACA;;AAEA,oDAAoD;AACpD;AACA;;AAEA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS,OAAO;AAChB;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,6BAA6B,UAAU,UAAU;AACjD,qBAAqB,oBAAoB,UAAU;AACnD,qBAAqB,UAAU,WAAW;AAC1C,oCAAoC,0BAA0B,WAAW;;AAEzE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,6B;AACA;AACA;;AAEA;;AAEA,gDAAgD;AAChD;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA,sE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK,sBAAsB;AAC3B;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,gFAAgF;AACxI;;AAEA;AACA,qEAAqE,gFAAgF;AACrJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,mCAAmC;AACnC,sCAAsC;;AAEtC;;AAEA;;AAEA,+CAA+C;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,yDAAyD,QAAQ;AACjE;;AAEA;AACA;AACA;AACA,qEAAqE;AACrE,yJAAyJ;AACzJ;;AAEA;AACA;AACA,qEAAqE;AACrE,yJAAyJ;AACzJ;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D,gJAAgJ;AAChJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D,iJAAiJ;AACjJ;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEe,kEAAG,EAAC;;;;;;;;;;;;;;;;;;;ACvhD0C;AACjB;AACD;;AAE3C;AACA,WAAW,kDAAK,SAAS,kDAAK;AAC9B,WAAW,gDAAK;AAChB,oBAAoB,oDAAc;;;AAGlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oG;AACA,+E;AACA;AACA;;AAEA;AACA;;AAEA,wDAAwD,QAAQ;AAChE,yDAAyD;AACzD,6G;AACA,wF;;AAEA;AACA;AACA;;AAEA,uG;AACA,aAAa;AACb,8E;;AAEA;AACA;;AAEA,wDAAwD,QAAQ;AAChE,2F;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;;AAEA,+D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA,iD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD,QAAQ;AAC5D;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+I;AACA;AACA;AACA,6N;AACA,aAAa;;AAEb,uE;AACA,SAAS;AACT,wE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,+BAA+B;;AAE/B,+CAA+C;AAC/C;AACA;AACA,aAAa;AACb;AACA;;AAEA,oG;;AAEA;AACA;AACA;AACA,kD;AACA;;AAEA;AACA;;AAEA,iEAAiE;AACjE;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA,4G;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,4C;;AAEA;AACA;AACA;AACA,6B;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,mBAAmB,UAAU;AAC7B,mBAAmB,UAAU;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,sC;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA,S;;AAEA;AACA;AACA,S;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC;;AAEA;;AAEA,sEAAsE;AACtE;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA,mB;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uC;;AAEA;AACA;AACA,0C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uC;;AAEA;AACA;AACA,0C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,U;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC,kBAAkB,eAAe;AACjC,qBAAqB,qBAAqB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gF;AACA,iCAAiC;;AAEjC;AACA,uC;;AAEA,KAAK,OAAO;;;AAGZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6EAA6E;AAC7E;;AAEA;;AAEA;AACA;AACA,4E;;AAEA;;AAEA,qCAAqC;AACrC;;AAEA;AACA;AACA,e;AACA;;;AAGe,yEAAU,EAAC;;;;;;;;;;;;;;;;;;;;;;ACn9BoB;AACC;AACX;AACC;AACa;AACA;;AAElD;AACA,WAAW,kDAAK;AAChB,WAAW,sDAAK;AAChB,iBAAiB,gDAAW;AAC5B,YAAY,kDAAM;AAClB,iBAAiB,6DAAW;AAC5B,iBAAiB,6DAAW;;AAE5B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA,qFAAqF,6DAA6D;AAClJ;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,sBAAsB;AACtB;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B,kCAAkC;AAClC,gCAAgC;AAChC,SAAS;AACT,oCAAoC;AACpC;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0EAA0E;AAC1E,0EAA0E;;AAE1E;AACA;AACA;;AAEA,4DAA4D;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAoE;AACpE,iEAAiE;;AAEjE;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,uCAAuC,oCAAoC,OAAO;AAClF,SAAS;AACT,uCAAuC,2BAA2B,OAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,CAAkB;;AAEpD;AACA,aAAa,CAAqB;;AAElC,oBAAoB,CAAqB,YAAY,CAA2B;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,CAAkB;AAClC;;AAEA;AACA;AACA;;AAEA,KAAK,kBAAkB,CAAiB;AACxC;;AAEA;AACA;AACA;;AAEA,KAAK;AACL,yCAAyC,CAAgB;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA,iBAAiB,CAAqB;AACtC,iBAAiB,CAA2B;;AAE5C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,CAAqB;AACtC,iBAAiB,CAA2B;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,CAAgB;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,KAAK,kBAAkB,CAAgB,YAAY,CAAkB,YAAY,CAAiB;AAClG;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,uBAAuB;AACzD,qCAAqC,0BAA0B;AAC/D,qCAAqC,0BAA0B;AAC/D,wCAAwC,2BAA2B;AACnE,sCAAsC,2BAA2B;;AAEjE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,CAAqB;AAClC,aAAa,CAAgB;AAC7B,aAAa,CAA2B;;AAExC,iDAAiD,CAA2B;AAC5E;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,aAAa,CAAqB;AAClC,aAAa,CAA2B;;AAExC;;AAEA,iDAAiD,CAAqB;AACtE;AACA;AACA;AACA;;AAEA;;AAEA,kDAAkD,iBAAiB,CAAqB;AACxF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA,mDAAmD;AACnD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA,SAAS;AACT,oEAAoE,QAAQ;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGe,sEAAO,EAAC;;;;;;;;;;;;;;;;;;;AClxBsC;AACd;AACH;AACP;;AAErC;AACA,WAAW,kDAAK,SAAS,kDAAK;AAC9B,WAAW,sDAAK;AAChB,WAAW,gDAAK;AAChB,YAAY,kDAAM;;;AAGlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0B;AACA,mC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,qC;AACA;;AAEA;AACA,uC;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;AACA,uBAAuB;AACvB;AACA,+BAA+B;AAC/B,qBAAqB;AACrB,uBAAuB;AACvB,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD;;AAEzD;AACA;AACA,mDAAmD;;AAEnD,yCAAyC,QAAQ;AACjD,sEAAsE;AACtE;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,K;;AAEA;;AAEA;AACA,8DAA8D;AAC9D,8DAA8D;AAC9D,oEAAoE;;AAEpE;AACA,sDAAsD;AACtD;AACA;;;;AAIA,wEAAwE;;AAExE,qFAAqF;AACrF,gEAAgE;AAChE,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6DAA6D;AAC7D,6DAA6D;;AAE7D;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,4EAA4E;AAC5E,SAAS;AACT,2EAA2E;AAC3E;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,O;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,sC;AACA;AACA;AACA;AACA,0C;AACA,4B;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;AACA,+C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kC;AACA,kC;AACA,mB;;AAEA;;AAEA;AACA,0D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mC;AACA;;;AAGA,+FAA+F;AAC/F;AACA;AACA;;AAEA,qB;AACA,qB;AACA,mB;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA,qB;AACA;;AAEA,qB;AACA;;AAEA,qB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mB;AACA;;AAEA;AACA;AACA;;AAEA,4D;AACA,qB;AACA;;AAEA,kCAAkC;AAClC,4C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,0C;AACA,6B;AACA,2B;;AAEA;;AAEA,6B;AACA;;AAEA,6B;AACA,0C;AACA;;AAEA,6B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oD;AACA,8C;;AAEA;;AAEA,oD;AACA;;AAEA,8C;AACA,oD;AACA;;AAEA,oD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC;AAClC;;AAEA,+BAA+B,gBAAgB;AAC/C,+BAA+B,gBAAgB;AAC/C,+BAA+B,gBAAgB;AAC/C,+BAA+B,iBAAiB;;AAEhD,gCAAgC,iBAAiB;AACjD,gCAAgC,iBAAiB;AACjD,gCAAgC,iBAAiB;AACjD,gCAAgC,iBAAiB;AACjD,aAAa;;AAEb,4C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,sCAAsC;AACtC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT,wC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA,+C;AACA,6I;AACA,K;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,UAAU,UAAU;AACrD,iBAAiB,0BAA0B,UAAU;AACrD,iBAAiB,UAAU,2BAA2B;AACtD,6CAA6C,sCAAsC,sCAAsC;AACzH,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA,uB;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA,2C;AACA,+C;AACA,+C;AACA;;AAEA,kC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,mBAAmB,UAAU;AAC7B,mBAAmB,UAAU;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,0EAAW,EAAC;;;;;;;;;;;;;;;;;;ACjxBoB;AACT;;AAEtC;AACA,YAAY,kDAAM;AAClB,kBAAkB,iDAAY;;;AAG9B;AACA,sCAAsC;AACtC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA,KAAK;;AAEL,kC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA,gD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sBAAsB;AACtB,wJ;AACA;AACA;AACA,4C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,0BAA0B,oBAAoB;AAC9C,wD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA,sBAAsB;AACtB,uBAAuB;AACvB,kBAAkB;AAClB,sCAAsC;AACtC,gCAAgC;AAChC,4BAA4B;AAC5B,uBAAuB;AACvB,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;;AAEA;AACA;;AAEA,0EAA0E;AAC1E,0EAA0E;;AAE1E;AACA;AACA;;AAEA,4DAA4D;;AAE5D;AACA;AACA;;AAEA,uDAAuD;;AAEvD,gEAAgE;AAChE,gEAAgE;;AAEhE,4DAA4D;AAC5D,4DAA4D;;AAE5D,0DAA0D;AAC1D,0DAA0D;;AAE1D;;AAEA;AACA,gEAAgE;AAChE,KAAK;AACL,6DAA6D;AAC7D,mEAAmE;AACnE;AACA;;AAEA;AACA;;AAEA,kG;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;;AAEA,2BAA2B,kBAAkB;AAC7C,sEAAsE;AACtE;;AAEA,0C;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA,mEAAmE;AACnE,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,6CAA6C,QAAQ;AACrD,gEAAgE;AAChE;;AAEA,uBAAuB,kBAAkB;AACzC,kEAAkE;AAClE;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;AACA;;;AAGA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,8C;;AAEA,2BAA2B,gBAAgB;AAC3C,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,OAAO;AAC1B;AACA,8C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,gBAAgB;AACnC,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;AAEA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGe,0EAAW,EAAC;;;;;;;;;;;;;;;;AC3diB;;AAE5C;AACA,WAAW,gDAAK;;AAEhB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,6D;AACA;;;AAGA;AACA;AACA;;;AAGe,0EAAW,EAAC;;;;;;;;;;;;;;;;ACpLoB;;AAE/C;AACA,sBAAsB,sDAAgB;;;AAGtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gD;;AAEA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qC;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,wDAAwD;AACxD,0DAA0D;AAC1D,4DAA4D;AAC5D;;AAEA;AACA,6DAA6D;AAC7D,+DAA+D;AAC/D,iEAAiE;AACjE;;AAEA;AACA;;;AAGe,0EAAW,EAAC;;;;;;;;;;;;;;;;;;AC/J3B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY;AACZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,+D;AACA;;;AAGA;AACA;AACA,qB;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,iD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,wCAAwC;AACxC;;AAEA,iDAAiD,QAAQ;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGe,6EAAc,EAAC;;;;;;;;;;;;;;;;;;;;;AClGM;AACM;AACJ;AACR;AACM;;AAEpC;AACA,iBAAiB,gDAAW;AAC5B,oBAAoB,mDAAc;AAClC,kBAAkB,iDAAY;AAC9B,cAAc,6CAAQ;AACtB,iBAAiB,gDAAW;;;AAG5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB,cAAc;AACvC;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,6C;AACA;AACA;AACA;AACA,S;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wB;AACA,KAAK;AACL;AACA;AACA;;;AAGe,8EAAe,EAAC;;;;;;;;;;;;;;;;;;ACpMgB;;AAE/C;AACA,sBAAsB,sDAAgB;;;AAGtC;AACA;AACA,wD;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,yBAAyB;;AAEzB;;AAEA,uBAAuB,cAAc;AACrC,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,S;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,sBAAsB;AACtB;AACA;AACA;;;AAGA,2BAA2B,eAAe;AAC1C;AACA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,S;;AAEA;AACA;;AAEA;AACA;;;AAGe,8EAAe,EAAC;;;;;;;;;;;;;;;;;;;;;AC1FK;AACQ;AACD;;AAE3C;AACA,iBAAiB,gDAAW;AAC5B,WAAW,gDAAK;AAChB,oBAAoB,oDAAc;;;AAGlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8D;AACA,4B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE;AACA;;AAEA;AACA,+F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wE;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;;AAEjC,WAAW;AACX,eAAe;AACf,gBAAgB;AAChB,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGe,qEAAM,EAAC;;;;;;;;;;;;;;;;ACrbtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;AACA,uB;AACA,4B;AACA,gC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wBAAwB,kCAAkC,IAAI;AACrF,4B;AACA,kCAAkC;AAClC;AACA,GAAG;;;AAGH;AACA;;AAEA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,2B;AACA;AACA;AACA;AACA,2B;AACA,gC;AACA,oC;AACA;AACA;;AAEA,sDAAsD,QAAQ;AAC9D;AACA,S;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,gB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGe,uEAAQ,EAAC;;;;;;;;;;;;;;;;;ACxNuB;;AAE/C;AACA,YAAY,kDAAM;;;AAGlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA,SAAS;AACT;AACA;;AAEA,KAAK;AACL,kC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEe,4EAAa,EAAC;;;;;;;;;;;;;;AC/I7B;AAAA;AAAA;AAAA;AAAA;AAAA;;AAE8C;AACF;AACA;AACP;;AAErC;AACA,WAAW,kDAAK;AAChB,WAAW,gDAAK;AAChB,cAAc,0DAAQ;AACtB,WAAW,sDAAK;;;AAGhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA,2BAA2B;AAC3B,wBAAwB;AACxB,6BAA6B;AAC7B;AACA;;AAEA;;AAEA,yDAAyD;;AAEzD;AACA,wEAAwE;AACxE,KAAK;AACL;AACA;;AAEA,iEAAiE;AACjE,2CAA2C;;AAE3C;AACA;;AAEA,2DAA2D;AAC3D,2DAA2D;AAC3D,2DAA2D;;AAE3D,2DAA2D;AAC3D,2DAA2D;AAC3D,2DAA2D;;AAE3D;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB;;AAEvB,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB,iBAAiB;;AAEjB,oBAAoB;AACpB,oBAAoB;;AAEpB,KAAK;AACL;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,uC;AACA;AACA,SAAS;AACT,kC;AACA;AACA;AACA,KAAK;AACL;AACA,uC;AACA;AACA,SAAS;AACT,kC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;;AAEzB,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,KAAK;AACL,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,qCAAqC;AACrC;AACA;AACA,aAAa;AACb,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA,iCAAiC;AACjC;AACA;AACA,SAAS;AACT,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB,iBAAiB;;AAEjB,oBAAoB;AACpB,oBAAoB;;AAEpB,KAAK;AACL;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA,SAAS;AACT,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,UAAU,UAAU;AACrD,iBAAiB,0BAA0B,UAAU;AACrD,iBAAiB,UAAU,2BAA2B;AACtD,6CAA6C,sCAAsC,sCAAsC;AACzH,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA,iBAAiB,UAAU,UAAU;AACrC,iBAAiB,UAAU,UAAU;AACrC,iBAAiB,UAAU,WAAW;AACtC,6CAA6C,sCAAsC,sCAAsC;AACzH,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGe,yEAAU,EAAC;;;;;;;;;;;;;;;;;ACv4BqB;AACG;;AAElD;AACA,YAAY,kDAAM;AAClB,iBAAiB,6DAAW;;;AAG5B;AACA;AACA;AACA,qBAAqB;AACrB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B;;;AAGA;AACA;AACA;;AAEA;AACA,8B;AACA,mC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8B;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,CAAqB;AAC9B,SAAS,CAAqB;AAC9B,SAAS,CAAqB;;AAE9B;AACA;AACA;;AAEA;AACA,sEAAsE,CAAqB;AAC3F,aAAa,kCAAkC;AAC/C;AACA;AACA,0EAA0E,CAAqB;AAC/F;AACA,aAAa;;AAEb,wCAAwC;AACxC;AACA,8CAA8C;AAC9C,0G;AACA;;AAEA;AACA;AACA,gH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8BAA8B;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6BAA6B,CAAsB;AACnD;AACA;AACA;AACA,oE;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,CAAsB;AAC/C;AACA;AACA;AACA,gE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gE;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,KAAK;AACL,kC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;;AAEA,4C;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA,oEAAoE,CAA0B;AAC9F;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0EAA0E;;AAE1E;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,CAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,CAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,CAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA,aAAa,CAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,CAAqB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,CAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,UAAU;AACjC,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2D;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,8DAA8D,CAAqB;AACnF;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,4EAAa,EAAC;;;;;;;;;;;;;;;;AC7hB7B;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA,sBAAsB,gB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C,mE;AACA,sEAAsE;AACtE;AACA;;;AAGA,6BAA6B;AAC7B,qB;AACA,6BAA6B;;AAE7B;AACA;AACA,sEAAsE;AACtE;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6B;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;;AAEA,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA,gC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;;AAEA,gEAAgE,QAAQ;AACxE;AACA;AACA,8B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iB;AACA;;AAEA,SAAS;;AAET;;AAEA;AACA,qCAAqC,QAAQ;AAC7C,gEAAgE;AAChE,oD;AACA,oD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;;;AAGe,iFAAkB,EAAC;;;;;;;;;;;;;;;;;;;ACrTY;AACI;AACN;;AAE5C;AACA,WAAW,kDAAK;AAChB,iBAAiB,6DAAW;AAC5B,WAAW,gDAAK;;AAEhB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA,mCAAmC;;AAEnC,wBAAwB;AACxB;AACA,+BAA+B;AAC/B,mCAAmC;AACnC;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;AAC/D,+EAA+E;AAC/E,gFAAgF;;AAEhF;AACA;;;AAGA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,M;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,0D;AACA;AACA;AACA;AACA,0D;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB,cAAc;AACvC;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,6B;AACA;;AAEA;;AAEA;AACA,4GAA4G;AAC5G;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4EAA4E;AAC5E;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA,gCAAgC,sBAAsB;AACtD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA,e;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,6B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,wD;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iC;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA,iC;;AAEA,2BAA2B,OAAO;AAClC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oB;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qC;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,4BAA4B;AAC5B;AACA;AACA,iBAAiB;AACjB,6D;;AAEA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA,yB;AACA,qBAAqB;;AAErB;AACA;AACA,4F;AACA,4F;AACA,4F;AACA,4F;AACA,4F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;AACxB,4BAA4B;AAC5B,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,0BAA0B;AACnC,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,OAAO;AAChB,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,KAAK,0BAA0B;AAC/B,4BAA4B;AAC5B,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,0BAA0B;AACnC,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,OAAO;AAChB,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,KAAK,OAAO;AACZ,4BAA4B;AAC5B,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,0BAA0B;AACnC,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,OAAO;AAChB,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;;AAEA;AACA,8B;AACA;AACA,qB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD,4DAA4D;AAC5D,+EAA+E;;AAE/E,8BAA8B;;AAE9B;AACA,8B;AACA;AACA,qB;AACA,kDAAkD;;AAElD,oBAAoB;AACpB;AACA,yBAAyB;AACzB;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS;AACT;AACA;;AAEA,KAAK;AACL,oBAAoB;AACpB;AACA,yBAAyB;AACzB;AACA,aAAa,OAAO;AACpB;AACA;AACA,S;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,+B;;AAEA;AACA;AACA,mC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kH;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET,yC;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC;AACtC;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA,sCAAsC;AACtC;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kF;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB;AACnB;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA,0B;AACA;AACA;AACA,KAAK;AACL;AACA,sB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,iD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA,yC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,kC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,QAAQ;AACxD;;AAEA,+BAA+B,OAAO;AACtC;;AAEA;AACA;AACA;AACA;AACA,6B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;;AAEA;AACA;;AAEA;AACA,kEAAkE;AAClE,kFAAkF;AAClF,kEAAkE;;AAElE,kFAAkF;AAClF,kFAAkF;;AAElF,kEAAkE;AAClE,kFAAkF;AAClF,kEAAkE;AAClE;;AAEA;AACA;AACA;;AAEA;AACA,mI;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wD;AACA,0E;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,4GAA4G,iDAAiD;AAC7J;AACA;;AAEA;;AAEA,uEAAuE;AACvE,+B;AACA,S;AACA;;AAEA;;AAEA;AACA,sC;AACA,wE;AACA;AACA;AACA,KAAK;;AAEL;AACA,6E;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA,SAAS;AACT,0E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,4D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4D;;AAEA;AACA,E;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0B;AACA;AACA;AACA,KAAK;AACL;AACA,sB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA,yC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wD;AACA,0E;AACA;;AAEA,8B;AACA;;AAEA;;AAEA;AACA,sC;AACA,mC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,kDAAkD;AAClD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;;AAEnD,mDAAmD;AACnD,6FAA6F;AAC7F;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,mC;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,oC;;AAEA;AACA,+D;AACA,gD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA,E;;;AAGe,6EAAc,EAAC;;;;;;;;;;;;;;;;;;;ACpzDgB;AACD;;AAE7C;AACA,WAAW,kDAAK;AAChB,qBAAqB,qDAAe;;;AAGpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qDAAqD,2CAA2C,EAAE;AAClG;;AAEA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;;AAEA,uBAAuB,cAAc;AACrC;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,uBAAuB,cAAc;AACrC;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA,iD;AACA,SAAS;AACT,0C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA,yEAAyE;AACzE,qEAAqE;AACrE,yEAAyE;AACzE;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6C;;AAEA;;AAEA;AACA,8B;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,2EAA2E;AAC3E;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,iC;AACA;;AAEA,yBAAyB;;;AAGzB;AACA,+DAA+D,QAAQ;;AAEvE;AACA,iFAAiF;AACjF;AACA;AACA,+BAA+B;;AAE/B;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gC;AACA,yC;AACA,iD;AACA,gC;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6C;;AAEA;;AAEA;AACA,8B;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;;AAEA,2EAA2E;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,iC;AACA;;AAEA,yBAAyB;;;AAGzB;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gC;AACA,yC;AACA,iD;AACA,gC;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,iDAAiD;;AAEjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,6C;;AAEA;;AAEA;AACA;AACA,8B;AACA;AACA,sB;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,OAAO;;AAExB;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,2EAA2E;;AAE3E;AACA;;AAEA;AACA;;AAEA,6BAA6B,gCAAgC;AAC7D;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,iC;AACA;;AAEA,yBAAyB;;AAEzB;AACA,+DAA+D,QAAQ;;AAEvE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,qD;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,gC;AACA,yC;AACA,iD;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB,0BAA0B;;AAE1B;AACA,qBAAqB;AACrB,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,6C;;AAEA;;AAEA;AACA;AACA,8B;AACA;AACA;AACA,sB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA,4C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uI;AACA;;AAEA,qEAAqE;AACrE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;;AAEA,sF;;AAEA;;AAEA,gCAAgC;;AAEhC,mCAAmC,OAAO;AAC1C;AACA;;AAEA,qFAAqF;;AAErF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oC;AACA;;AAEA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,2EAA2E;;AAE3E;AACA;;AAEA,oG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,iC;AACA;;AAEA,yBAAyB;;AAEzB;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,0F;;AAEA;AACA;;AAEA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA,mFAAmF;AACnF,4G;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,mFAAmF;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yB;AACA;;AAEA,iBAAiB,SAAS;;;AAG1B,+BAA+B,OAAO;AACtC;AACA;;AAEA,2EAA2E;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA,qB;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,wC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uE;AACA;;AAEA,iEAAiE;AACjE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,gC;AACA,yC;AACA,iD;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sB;AACA,yC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,6C;;AAEA;AACA;AACA,8B;AACA;AACA,iC;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,OAAO;;AAExB;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,2EAA2E;;AAE3E;AACA;;AAEA;AACA;;AAEA,6BAA6B,gCAAgC;AAC7D;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,iC;AACA;;AAEA,yBAAyB;;AAEzB;AACA,+DAA+D,QAAQ;;AAEvE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,K;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;AAGA,KAAK;;;AAGL;AACA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;;AAEA,0DAA0D;AAC1D;AACA;;AAEA;AACA,yB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,sBAAsB;AACrC;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kC;AACA,2C;AACA,mD;;AAEA;AACA;;;AAGA;;AAEA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA,yFAAyF;AACzF;AACA;AACA,8F;;AAEA;;AAEA;;AAEA;AACA;AACA,qCAAqC,QAAQ;AAC7C,iD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;AACA;;AAEA,6C;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,2C;;AAEA,4BAA4B,QAAQ;AACpC;;AAEA;AACA;;AAEA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;;AAEA,gC;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,+F;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0D;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD,6BAA6B;AAC7B;;AAEA,kDAAkD;AAClD,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,S;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,S;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;;;AAIe,6EAAc,EAAC;;;;;;;;;;;;;ACziE9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACQ;AACG;AACR;AACU;AACI;;AAEnD;AACA,gBAAgB,+CAAU;AAC1B,oBAAoB,mDAAc;AAClC,qBAAqB,qDAAe;AACpC,WAAW,sDAAK;AAChB,YAAY,kDAAM;AAClB,eAAe,mDAAS;;;AAGxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iC;AACA;AACA;AACA,SAAS;;AAET,kCAAkC,EAAE;;AAEpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,0BAA0B;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,wJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA,gE;AACA;;AAEA;AACA,K;;;AAGA,8FAA8F,WAAW;AACzG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,kC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,uC;AACA;;AAEA;;AAEA;AACA;AACA,oD;AACA,K;;AAEA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGA;AACA,8CAA8C,+BAA+B;AAC7E;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;AAEA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGA;AACA,kDAAkD,+BAA+B;AACjF;;;AAGA;AACA,yDAAyD,+BAA+B;AACxF,kDAAkD,+BAA+B;AACjF;;;AAGA;AACA,mDAAmD;AACnD;;;AAGe,yEAAU,EAAC;;;;;;;;;;;;;;;;;;;AC5YgB;;AAE1C;AACA,oBAAoB,mDAAc;;;AAGlC;AACA;AACA;AACA,qBAAqB;AACrB,6BAA6B;;AAE7B;AACA,0F;AACA,KAAK;AACL,8E;AACA;;AAEA,4B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,CAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,CAAqB,4CAA4C;AAClF,iBAAiB,CAAqB,6CAA6C;AACnF,iBAAiB,CAAqB,4CAA4C;AAClF;AACA,S;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,qC;AACA,0C;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,qC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,0C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,uBAAuB;AAChG;;AAEA,gD;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,4FAA4F,yBAAyB;AACrH;;AAEA,mE;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT,0G;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,SAAS,CAA0B;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,CAA0B;AACvD;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,CAA0B;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;;;AAGe,yEAAU,EAAC;;;;;;;;;;;;;;;;;ACxXkB;;AAE5C;AACA,WAAW,gDAAK;;;AAGhB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,K;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,K;;AAEA,kG;AACA,kG;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,K;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kD;AACA;AACA,yC;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mD;AACA;;AAEA;AACA;AACA;AACA,S;AACA,K;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC,uCAAuC;AACvC,yCAAyC;AACzC,2CAA2C;AAC3C,6CAA6C;AAC7C,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C,6CAA6C;AAC7C,+CAA+C;AAC/C,iDAAiD;AACjD,mDAAmD;AACnD,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C,+DAA+D;AAC/D,+CAA+C,YAAY,wBAAwB;AACnF,+DAA+D,YAAY,wCAAwC;AACnH,+CAA+C,YAAY,wBAAwB,YAAY,wBAAwB;AACvH,+DAA+D,YAAY,wCAAwC,YAAY,wCAAwC;AACvK;AACA;AACA;;AAEA;AACA;;AAEA,+C;AACA,+C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,iD;AACA,iD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oC;AACA,aAAa;;AAEb;;AAEA;AACA,wD;AACA;;AAEA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA,kC;AACA,kC;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,+B;AACA,+B;AACA;AACA;;;AAGA;AACA,sC;AACA,sC;AACA;AACA;;;AAGA;AACA,kC;AACA,kC;AACA;AACA;;;AAGA;AACA,kC;AACA,kC;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA,KAAK,yDAAyD;AAC9D;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA,K;;AAEA;AACA;;;AAGe,4EAAa,EAAC;;;;;;;;;;;;;;;;;;;;ACvakB;AACI;;AAEnD;AACA,eAAe,mDAAS;AACxB,YAAY,kDAAM;;;AAGlB;AACA;;AAEA;AACA;AACA;AACA,kD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,2DAA2D,mDAAmD;;AAE9G;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,uDAAuD,yDAAyD;;AAEhH;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT,oDAAoD,iDAAiD;;AAErG;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT,oDAAoD,iDAAiD;;AAErG;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT;AACA;;AAEA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA,wB;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA,kC;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA,qC;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA,mBAAmB,IAAI,EAAE,QAAQ,EAAE,SAAS;AAC5C,mBAAmB,IAAI,EAAE,EAAE,EAAE,EAAE;AAC/B,mBAAmB,cAAc;AACjC,mBAAmB,kBAAkB;AACrC,mBAAmB,IAAI,EAAE,aAAa;AACtC;AACA,oBAAoB,aAAa,kCAAkC,IAAI,EAAE,EAAE,EAAE,EAAE;;AAE/E;AACA;AACA;;AAEA;AACA,mE;AACA;AACA;AACA;AACA,4B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C;AAC/C;AACA,oDAAoD;AACpD;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,kC;AACA;AACA;;;AAGe,qEAAM,EAAC;;;;;;;;;;;;;;;;ACvPtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,uB;AACA,yC;;AAEA;AACA,wC;AACA,sCAAsC;AACtC,iDAAiD,QAAQ;AACzD;AACA;AACA,SAAS;AACT,qC;AACA;AACA;;AAEA,6DAA6D;AAC7D;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,0C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGe,sEAAO,EAAC;;;;;;;;;;;;;;;;;;AC3FwB;AACV;;AAErC;AACA,WAAW,sDAAK;AAChB,YAAY,kDAAM;;;AAGlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA,mB;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,wJ;;AAEA;AACA;;;AAGA;AACA,8C;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;AAEA;AACA,6DAA6D;AAC7D,6DAA6D;;AAE7D;AACA;AACA;;AAEA,4CAA4C;;AAE5C,mBAAmB,WAAW;AAC9B,8CAA8C;AAC9C;;AAEA,uBAAuB,UAAU;AACjC,gDAAgD;AAChD;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA,SAAS,OAAO;AAChB,0DAA0D;AAC1D;AACA;;AAEA,gB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,kC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGe,gFAAiB,EAAC;;;;;;;;;;;;;;;;AC7NjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,S;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGe,mEAAI,EAAC;;;;;;;;;;;;;;;;;;ACnEwD;AAChC;;AAE5C;AACA,WAAW,kDAAK,SAAS,kDAAK,SAAS,kDAAK;AAC5C,WAAW,gDAAK;;;AAGhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,0CAA0C,+DAA+D;AACzG,6CAA6C,wEAAwE;AACrH,wCAAwC,oBAAoB;AAC5D,qCAAqC,iBAAiB;AACtD,sCAAsC,kBAAkB;AACxD,qCAAqC,iBAAiB;AACtD,4CAA4C,wBAAwB;AACpE,uCAAuC,mBAAmB;;;AAG1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iD;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA,6CAA6C;AAC7C;;;AAGA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iC;AACA,iC;AACA,iC;;AAEA,iC;AACA,iC;AACA,iC;AACA,KAAK;AACL,sB;AACA,sB;AACA,sB;;AAEA,sB;AACA,sB;AACA,sB;AACA;;AAEA;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;;AAE9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;;;AAG9B;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;;AAE3C;AACA,8DAA8D,GAAG;AACjE,UAAU,GAAG;AACb;AACA,mCAAmC;AACnC,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGe,qEAAM,EAAC;;;;;;;;;;;;;;;;;;AC7asD;AAChC;AAE4F;;AAExI;AACA,WAAW,kDAAK,SAAS,kDAAK,SAAS,kDAAK;AAC5C,WAAW,gDAAK;AAChB,kBAAkB,iDAAY;AAC9B,mBAAmB,kDAAa;AAChC,mBAAmB,kDAAa;AAChC,mBAAmB,kDAAa;AAChC,mBAAmB,kDAAa;AAChC,6BAA6B,4DAAuB;;;AAGpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,oC;;AAEA;AACA,mBAAmB,iBAAiB;AACpC,wC;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,sB;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK,OAAO;;AAEZ;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;;AAEA,sB;AACA;AACA,KAAK;AACL,yEAAyE;AACzE;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,uBAAuB,QAAQ;;AAE/B;AACA;AACA;;AAEA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;;AAEA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2G;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qB;;AAEA;;AAEA;;AAEA;AACA;;AAEA,qBAAqB;;AAErB;AACA,iCAAiC,EAAe;AAChD;AACA;;AAEA;AACA;;AAEA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iCAAiC,CAAkB;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA,qBAAqB,EAAe;AACpC;AACA;;AAEA;AACA;;AAEA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,CAAkB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;;;AAGA,6CAA6C;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,e;AACA;AACA;;AAEA;;AAEA,mD;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,CAAkB;AAC1C;AACA;AACA;AACA;AACA,aAAa,M;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,CAAqB;AAC9C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA,kGAAkG;AAClG;AACA;AACA,a;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,CAAkB;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mCAAmC;;AAEnC,8DAA8D;;AAE9D,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAiC;;AAE9C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA,iB;AACA;;AAEA,SAAS,iCAAiC;;AAE1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,a;AACA;;AAEA,KAAK;AACL;AACA;AACA,S;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,CAAiB;AAC1B,SAAS,EAAe;;AAExB,wBAAwB,EAAe;AACvC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA,SAAS,O;AACT;AACA;;AAEA,yDAAyD,EAAe;;AAExE,wB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;;AAEA;AACA;;AAEA,wB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0DAA0D,SAAS;;AAEnE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,qEAAqE,QAAQ;AAC7E;AACA;;;AAGA;;AAEA;;AAEA,SAAS,CAAkB;AAC3B,SAAS,CAAkB;AAC3B,SAAS,CAAkB;AAC3B,SAAS,CAAmB;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,CAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,CAAkB;;AAE1C,4BAA4B,CAAkB;AAC9C;AACA,aAAa;AACb;AACA;;AAEA,oCAAoC,CAAkB,gBAAgB,CAAkB;AACxF;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,CAAkB,gBAAgB,CAAkB;AACxF;AACA;AACA,yBAAyB;AACzB,oF;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA,S;;AAEA;AACA;AACA;;AAEA,wBAAwB,CAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,SAAS,CAAkB;AAC3B;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mC;AACA,mC;AACA,mC;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iHAAiH;;AAEjH;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,+BAA+B,kCAAkC,EAAE;AAC9F,2BAA2B,8BAA8B,iCAAiC,EAAE;AAC5F,2BAA2B,8BAA8B,iCAAiC,EAAE;AAC5F,2BAA2B,8BAA8B,iCAAiC,EAAE;AAC5F,0BAA0B,8BAA8B,iCAAiC;AACzF,kBAAkB,8BAA8B,iCAAiC;;AAEjF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;;AAEA;AACA,S;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,CAAY;AACrB,SAAS,CAAa;AACtB,SAAS,CAAY;AACrB,SAAS,EAAe;;;AAGxB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,qB;AACA,6BAA6B;AAC7B,iBAAiB;AACjB,gEAAgE,GAAqB,E;AACrF;;AAEA;AACA;AACA,qB;AACA,6BAA6B;AAC7B;;AAEA,aAAa;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA,iB;AACA,kCAAkC;AAClC;AACA;;AAEA;;AAEA,wBAAwB,EAAe;AACvC,4BAA4B,CAAY;;AAExC;;AAEA,wDAAwD,QAAQ;AAChE;;AAEA;;AAEA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+B;AACA,+B;AACA,+B;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,EAAe;AACvC;AACA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;;AAEA;AACA;;AAEA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,CAAY;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET,2BAA2B;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,gCAAgC;AAChC,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;;AAEb;;AAEA,+BAA+B,+BAA+B,8BAA8B,EAAE;AAC9F,+BAA+B,8BAA8B,6BAA6B,EAAE;AAC5F,+BAA+B,8BAA8B,6BAA6B,EAAE;AAC5F,+BAA+B,8BAA8B,6BAA6B,EAAE;AAC5F,8BAA8B,8BAA8B,6BAA6B;AACzF,sBAAsB,8BAA8B,6BAA6B;;AAEjF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;;AAEA,sDAAsD,QAAQ;AAC9D;;AAEA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mB;AACA;;AAEA;AACA;AACA;AACA,qFAAqF,CAAa;;AAElG;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB,CAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;;AAET;;AAEA,2BAA2B,+BAA+B,8BAA8B,EAAE;AAC1F,2BAA2B,8BAA8B,6BAA6B,EAAE;AACxF,2BAA2B,8BAA8B,6BAA6B,EAAE;AACxF,2BAA2B,8BAA8B,6BAA6B,EAAE;AACxF,0BAA0B,8BAA8B,6BAA6B;AACrF,kBAAkB,8BAA8B,6BAA6B;;AAE7E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,e;AACA;;AAEA;AACA;AACA;AACA,iFAAiF,CAAa;;AAE9F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,KAAK;AACd;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;;AAEA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,oG;AACA;;AAEA,6C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA,sB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,+BAA+B,kCAAkC,EAAE;AAC1F,uBAAuB,8BAA8B,iCAAiC,EAAE;AACxF,uBAAuB,8BAA8B,iCAAiC,EAAE;AACxF,uBAAuB,8BAA8B,iCAAiC,EAAE;AACxF,sBAAsB,8BAA8B,iCAAiC;AACrF,cAAc,8BAA8B,iCAAiC;;AAE7E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+F;AACA;AACA;;AAEA;;AAEA;AACA,wG;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEe,2EAAY,EAAC;;;;;;;;;;;;;;;;AC54FD;;AAE3B;AACA,WAAW,6CAAK;;;AAGhB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD,iDAAiD;;AAEjD;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C,yBAAyB,sBAAsB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,2BAA2B;AAChD,yBAAyB,sBAAsB;;AAE/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL,yBAAyB,qBAAqB;AAC9C,6BAA6B,sBAAsB;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGe,+EAAgB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;ACtPhC;AACA;AACA;AACA;;AAEA,+DAA+D,MAAM;AACrE,2EAA2E,UAAU;AACrF;AACA;AACA;AACA,sF;AACA;;AAEA;AACA,qCAAqC,MAAM;AAC3C,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;AAC9C,0CAA0C,QAAQ;AAClD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA;;AAEA,wCAAwC,CAAkB;AAC1D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;;AAEA,4CAA4C,CAAkB;AAC9D;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,UAAU;AACpB,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,qEAAqE;AACrE,iEAAiE,UAAU;;AAE3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA,8D;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,iD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;;AAEA;;AAEA,6BAA6B,QAAQ;;AAErC;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;;AAEA,wCAAwC,CAAkB;AAC1D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;;AAEA,4CAA4C,CAAkB;AAC9D;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA,8D;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,iD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,6BAA6B,QAAQ;;AAErC;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD;AACnD;AACA;;AAEA,oCAAoC,CAAkB;AACtD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;;AAEA,wCAAwC,CAAkB;AAC1D;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;;;AAGA;AACA,kG;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,OAAO;AACZ,mBAAmB,aAAa;AAChC;AACA;AACA;;AAEA;AACA,eAAe,eAAe;AAC9B;AACA;;AAEA;AACA,uB;AACA;AACA;AACA;;AAEA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,UAAU;AACrF;AACA;AACA;AACA,qF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;;AAEA;AACA,2CAA2C;AAC3C;AACA;;AAEA;;AAEA,4BAA4B,CAAkB;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,aAAa;AACb;;AAEA,gCAAgC,CAAkB;AAClD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,kG;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK,OAAO;AACZ,mBAAmB,aAAa;AAChC;AACA;AACA;;AAEA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC,gCAAgC,QAAQ;;AAExC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,mBAAmB,UAAU;AAC7B,mBAAmB,UAAU;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,kG;AACA;;AAEA;AACA;AACA,KAAK,OAAO;AACZ,mBAAmB,aAAa;AAChC;AACA;AACA;;AAEA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qF;AACA,gE;AACA,yD;AACA,oE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oCAAoC,CAAkB;AACtD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA,0CAA0C,QAAQ;;AAElD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;;AAGA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,2DAA2D;AAC3D;AACA;;AAEA;;AAEA,wCAAwC,CAAkB;AAC1D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;;AAGA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;;AAEA,4CAA4C,CAAkB;AAC9D;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;;AAEA;AACA,2DAA2D;AAC3D;AACA;;AAEA;;AAEA,wCAAwC,CAAkB;AAC1D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;;AAEA,4CAA4C,CAAkB;AAC9D;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,4BAA4B,QAAQ;AACpC,gCAAgC,QAAQ;AACxC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGqG;;;;;;;;;;;;;;;;;AChvCrG;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGe,sEAAO,EAAC;;;;;;;;;;;;;;;;;AChFvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,qFAAqF,E;AAC/H;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,yCAAyC,sFAAsF,8CAA8C,4CAA4C;AACzN,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,0DAA0D;AAC1D;;;AAGA;AACA,8DAA8D;AAC9D;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uD;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;AACA;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA,8BAA8B,qBAAqB;AACnD,gCAAgC,uBAAuB;AACvD,+BAA+B,qBAAqB;AACpD,8BAA8B,oBAAoB;AAClD,+BAA+B,sBAAsB;AACrD,gCAAgC,sBAAsB;;AAEtD;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;;AAGe,wEAAS,EAAC;;;;;;;;;;;;;;;;;;;;;AC1TW;AACc;;AAElD;AACA,iBAAiB,gDAAW;AAC5B,YAAY,kDAAM;;;AAGlB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,uBAAuB;;AAE3C;AACA;AACA,uB;AACA,qB;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,uCAAuC,kBAAkB;;;AAGzD;AACA;AACA;;AAEA;AACA;AACA,sB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,sEAAO,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;ACvFyC;AACpC;AACmB;AACG;AACI;AACC;AACiB;AACE;AACf;;AAE3D;AACA,WAAW,kDAAK,SAAS,kDAAK;AAC9B,WAAW,6CAAK;AAChB,WAAW,gDAAK;AAChB,YAAY,kDAAM;AAClB,sBAAsB,0DAAgB;AACtC,8BAA8B,mEAAwB;AACtD,+BAA+B,oEAAyB;AACxD,wBAAwB,4DAAkB;AAC1C,eAAe,mDAAS;;AAExB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,QAAQ;AAClD,+B;;AAEA;AACA,aAAa,CAAiB;AAC9B,aAAa,EAAe;AAC5B;AACA;AACA;;AAEA,aAAa,CAAkB;AAC/B,aAAa,CAAkB;AAC/B,aAAa,CAAkB;AAC/B,aAAa,CAAmB;AAChC;AACA;AACA;AACA;;AAEA,aAAa,CAAkB;AAC/B;AACA;AACA;AACA;;AAEA,aAAa,CAAY;AACzB,aAAa,CAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,qBAAqB,EAAuB;AAC5C,mBAAmB,EAAe;AAClC,KAAK;AACL,mBAAmB,CAAiB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,SAAS,CAAyB,cAAc,CAAkB,CAAC;AACnE,SAAS,CAA0B,cAAc,CAAkB,CAAC;AACpE,SAAS,CAA0B,cAAc,CAAkB,CAAC;AACpE,SAAS,EAA2B,aAAa,CAAmB,CAAC;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,CAAkB,4FAA4F;AACvH,SAAS,CAAkB,0CAA0C;AACrE,SAAS,CAAkB,0CAA0C;AACrE,SAAS,CAAmB,6FAA6F;AACzH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,CAAkB,4CAA4C;AAC3E,aAAa,CAAkB,4CAA4C;AAC3E,aAAa,CAAkB,4CAA4C;AAC3E,aAAa,CAAmB,4CAA4C;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD,4CAA4C;AAC7F,iDAAiD,4CAA4C;AAC7F,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD,kDAAkD;AAClD,kDAAkD;AAClD;;AAEA,0BAA0B;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wDAAwD;;AAExD,wEAAwE;AACxE;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,eAAe,CAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf,uBAAuB,CAAa,GAAG,CAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,CAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA,eAAe;AACf,eAAe,EAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,EAAY;AAC3B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B;;AAE7B,oBAAoB,EAA0B,YAAY,EAAwB;AAClF,oBAAoB,EAA6B,YAAY,EAA2B,YAAY,EAA6B;;AAEjI,2CAA2C;AAC3C,0FAA0F;AAC1F;AACA;AACA;;AAEA;AACA,aAAa,EAAuB;AACpC,aAAa,CAAyB;AACtC;AACA,2CAA2C;AAC3C,yFAAyF;;AAEzF;AACA,+CAA+C;AAC/C,8FAA8F;AAC9F;;AAEA;AACA;;AAEA,aAAa,CAA0B;AACvC,aAAa,CAA0B;AACvC,aAAa,CAA0B;AACvC,aAAa,EAA2B;AACxC;AACA,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,yFAAyF;;AAEzF;AACA,+CAA+C;AAC/C,8FAA8F;AAC9F;;AAEA;AACA;;AAEA,aAAa,EAA0B;;AAEvC,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,4FAA4F;AAC5F;AACA;;AAEA,aAAa,EAA2B;;AAExC,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,0FAA0F;AAC1F;AACA;;AAEA,aAAa,CAAoB;AACjC,aAAa,CAAqB;;AAElC,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C,CAAqB;AAChE;;AAEA,aAAa,CAAqB;AAClC,aAAa,CAAsB;;AAEnC,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,4FAA4F;AAC5F,2CAA2C,CAAsB;AACjE;;AAEA,aAAa,CAA8B;AAC3C,aAAa,EAA6B;;AAE1C,2CAA2C;AAC3C,2FAA2F;AAC3F,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C;AACA;;AAEA,aAAa,EAA0B;AACvC,8BAA8B;AAC9B;;AAEA,aAAa,EAAwB;AACrC,2BAA2B;AAC3B;;AAEA,aAAa,EAAuB;AACpC;AACA;;AAEA,aAAa,EAA6B;AAC1C,6BAA6B,mBAAmB;AAChD;;AAEA,aAAa,EAA2B;AACxC,8BAA8B;AAC9B;;AAEA,aAAa,EAA6B;AAC1C,oBAAoB,qCAAqC;AACzD;AACA;;AAEA,aAAa,EAA0B;;AAEvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,aAAa,EAAwB;;AAErC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA,aAAa,EAAoB;AACjC;AACA;;AAEA,aAAa,EAAyB;AACtC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,yDAAyD;AACzD,sDAAsD;AACtD,iDAAiD;AACjD,6DAA6D;AAC7D,kDAAkD;AAClD,kDAAkD;AAClD,6CAA6C;AAC7C,0CAA0C;AAC1C,uDAAuD;AACvD,4CAA4C,mBAAmB;AAC/D,kDAAkD;AAClD,6CAA6C;AAC7C,4CAA4C;AAC5C,0CAA0C;AAC1C,0CAA0C;AAC1C;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,EAAY;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mDAAmD,EAAY;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,EAAY;AAC/D;AACA;AACA,kDAAkD,QAAQ;;AAE1D;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;;AAEA,wBAAwB,EAAY;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,oEAAoE,CAAqB;AACzF;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,CAAqB;AAC9F,qB;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA,gEAAgE,CAAqB;AACrF;AACA,SAAS;AACT;AACA,gEAAgE,CAAqB;AACrF;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA,e;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,gCAAgC;AAChC;;AAEA,kCAAkC;AAClC,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,mC;;AAEA,6BAA6B;;AAE7B;;AAEA;AACA;;AAEA;;AAEA,mI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,kCAAkC,EAAY;AAC9C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,QAAQ;;AAE3C;;AAEA;AACA;;AAEA;AACA,0DAA0D;AAC1D,yDAAyD;AACzD,yDAAyD;AACzD,wDAAwD;AACxD,yDAAyD;AACzD,wDAAwD;AACxD,wDAAwD;AACxD,uDAAuD;AACvD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D;AAC3D,yBAAyB;AACzB,4DAA4D;AAC5D;AACA;;AAEA;AACA,uDAAuD;AACvD,qBAAqB;AACrB,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,sCAAsC,EAAY;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;;AAEA,kCAAkC;AAClC,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,sC;AACA;;AAEA,qCAAqC;;AAErC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,sFAAsF;AAC7I,iBAAiB;AACjB,sGAAsG,uFAAuF,oCAAoC,YAAY;AAC7O;AACA;;AAEA;AACA;AACA;;AAEA,mC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,qBAAqB;AACtE,aAAa;AACb,2FAA2F,oBAAoB,oCAAoC,WAAW;AAC9J;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA,+C;;AAEA;AACA,0CAA0C,8CAA8C;AACxF,0CAA0C,O;AAC1C,0CAA0C;AAC1C;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA,yBAAyB,CAAY,gBAAgB,CAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGe,uEAAQ,EAAC;;;;;;;;;;;;;;;AC5vDxB;AACA;AACA;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA,uCAAuC,kBAAkB;;;AAGzD,uCAAuC,kBAAkB;;;AAGzD,2CAA2C,sBAAsB;;;AAGlD,sEAAO,EAAC;;;;;;;;;;;;;;;;ACnLvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,kBAAkB;;;AAG/D,6CAA6C,kBAAkB;;;AAG/D,iDAAiD,sBAAsB;;;AAGxD,4EAAa,E;;;;;;;;;;;;;;AClK5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,uCAAuC;AAC7G;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE,oBAAoB;AAC1F;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yB;AACA,yB;AACA,mC;AACA,yB;;AAEA,yB;AACA,yB;AACA,mC;AACA,yB;;AAEA;AACA;AACA,qC;AACA;;AAEA,2B;AACA,2B;AACA,qC;AACA,2B;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGe,yEAAU,EAAC;;;;;;;;;;;;;;;AC/N1B;;AAEA;AACA,8BAA8B;AAC9B,uBAAuB;AACvB,iBAAiB;AACjB,mDAAmD;AACnD,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,uBAAuB;AACvB,gCAAgC;AAChC,iBAAiB;AACjB,0CAA0C;AAC1C,4FAA4F;AAC5F,MAAM;;;AAGN,yDAAyD;AACzD,kBAAkB;AAClB,iDAAiD;AACjD,MAAM;;AAEN;AACA,8BAA8B;AAC9B,iBAAiB;AACjB,MAAM;;;AAGN;AACA;AACA,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA,sCAAsC;AACtC,oCAAoC;AACpC;;AAEA;AACA,iCAAiC;AACjC,sCAAsC;AACtC;AACA,iCAAiC;AACjC;;AAEA;;AAEA,uEAAuE;AACvE,8BAA8B;AAC9B,4DAA4D;AAC5D,mDAAmD;AACnD,+DAA+D;AAC/D,kCAAkC;AAClC,mDAAmD;AACnD,oEAAoE;AACpE,mCAAmC;AACnC,kDAAkD;AAClD,oIAAoI;AACpI,cAAc,OAAO;AACrB,kDAAkD;AAClD,sDAAsD;AACtD,qCAAqC;AACrC,oDAAoD;AACpD,2CAA2C;AAC3C,0CAA0C;AAC1C,gDAAgD;AAChD,uFAAuF;AACvF,4DAA4D;AAC5D,2EAA2E;AAC3E,mDAAmD;AACnD,kBAAkB;AAClB,mCAAmC;AACnC,mCAAmC;AACnC,sCAAsC;AACtC,sCAAsC;AACtC,gCAAgC;AAChC,gCAAgC;AAChC,0CAA0C;AAC1C,kIAAkI;AAClI,cAAc;AACd,UAAU;;AAEV;;AAEA;;AAEA;;AAEA,sCAAsC;AACtC,uCAAuC;AACvC,iCAAiC;AACjC,oCAAoC;;AAEpC;;AAEA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,mCAAmC;AACnC,qCAAqC;AACrC,wCAAwC;AACxC;AACA,0CAA0C;AAC1C;;AAEA;AACA,wCAAwC;AACxC,sCAAsC;AACtC;;AAEA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA,kCAAkC;AAClC,gCAAgC;AAChC;;;AAGA,kBAAkB;;AAElB;AACA,iCAAiC;AACjC;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA,yFAAyF;AACzF,yFAAyF;AACzF,yCAAyC;AACzC,uCAAuC;AACvC,iDAAiD;AACjD,4CAA4C;AAC5C,mEAAmE;AACnE,0BAA0B;AAC1B,mGAAmG;AACnG,yCAAyC;;AAEzC;;AAEA,sDAAsD;;AAEtD,wCAAwC;AACxC,oHAAoH;AACpH,kBAAkB,OAAO;AACzB,4FAA4F;AAC5F,4FAA4F;AAC5F,iDAAiD;AACjD,yCAAyC;AACzC,oDAAoD;AACpD,8CAA8C;AAC9C,qEAAqE;AACrE,4BAA4B;AAC5B,2GAA2G;AAC3G,iDAAiD;;AAEjD,0DAA0D;AAC1D,+CAA+C;AAC/C,+CAA+C;AAC/C,mDAAmD;AACnD,6HAA6H;AAC7H,kBAAkB;;AAElB;;AAEA;;AAEA,8CAA8C;AAC9C,4FAA4F;AAC5F,uEAAuE;AACvE,sBAAsB,KAAK;AAC3B,6DAA6D;AAC7D,4DAA4D;AAC5D,oDAAoD;AACpD,2EAA2E;AAC3E,0BAA0B,KAAK;AAC/B,qEAAqE;AACrE,0BAA0B;AAC1B,sBAAsB;;AAEtB;;AAEA,6DAA6D;;AAE7D;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,yDAAyD;AACzD,2FAA2F;;AAE3F;;AAEA,2DAA2D;;AAE3D;;AAEA,iDAAiD;AACjD,uDAAuD;AACvD,mDAAmD;AACnD,8BAA8B,OAAO;AACrC,qJAAqJ;AACrJ,8BAA8B;AAC9B,0BAA0B,OAAO;AACjC,iEAAiE;AACjE,mEAAmE;AACnE,uDAAuD;AACvD,uDAAuD;AACvD,2DAA2D;AAC3D,+IAA+I;AAC/I,0BAA0B;;AAE1B;;AAEA,gDAAgD;AAChD,4HAA4H;AAC5H,0BAA0B,OAAO;AACjC,mEAAmE;AACnE,uDAAuD;AACvD,uDAAuD;AACvD,2DAA2D;AAC3D,qIAAqI;AACrI,0BAA0B;;AAE1B;;AAEA;;AAEA;;AAEA;;AAEA,sDAAsD;AACtD,8CAA8C;AAC9C,iDAAiD;AACjD,iDAAiD;;AAEjD,8DAA8D;AAC9D,uEAAuE;AACvE,2DAA2D;AAC3D,uDAAuD;AACvD,0CAA0C;AAC1C,mDAAmD;AACnD,sDAAsD;;AAEtD;AACA,0DAA0D;AAC1D,6EAA6E;AAC7E,gFAAgF;;AAEhF,2EAA2E;AAC3E,2EAA2E;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD,4CAA4C;;AAE5C,mDAAmD;AACnD,oCAAoC,YAAY,+BAA+B,GAAG;AAClF,oCAAoC,YAAY,SAAS,+BAA+B,kBAAkB,EAAE;AAC5G,oCAAoC,SAAS,kBAAkB,EAAE;;AAEjE,oCAAoC;;AAEpC,gDAAgD;AAChD,uEAAuE;AACvE,sBAAsB,KAAK;AAC3B,iEAAiE;AACjE,sBAAsB;;AAEtB;;AAEA;;AAEA,kDAAkD;AAClD,gGAAgG;AAChG,2EAA2E;AAC3E,0BAA0B,KAAK;AAC/B,iEAAiE;AACjE,gEAAgE;AAChE,wDAAwD;AACxD,+EAA+E;AAC/E,8BAA8B,KAAK;AACnC,+EAA+E;AAC/E,8BAA8B;AAC9B,0BAA0B;;AAE1B;;AAEA;AACA,qHAAqH;AACrH;AACA,uEAAuE;AACvE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,MAAM;;;AAGN,yDAAyD;;AAEzD,yBAAyB;;AAEzB;AACA,gCAAgC;AAChC;;AAEA,kBAAkB;;AAElB;AACA,8GAA8G;AAC9G,kCAAkC;AAClC;AACA,mCAAmC;AACnC;;AAEA,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,yCAAyC;AACzC,wDAAwD;AACxD,8BAA8B;AAC9B,sFAAsF;AACtF,UAAU,OAAO;AACjB,sGAAsG;AACtG,UAAU;;AAEV,gCAAgC;AAChC,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,8BAA8B;AAC9B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,yCAAyC;AACzC,wDAAwD;AACxD,6BAA6B;AAC7B,gCAAgC;AAChC,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,sDAAsD;AACtD,kGAAkG;AAClG,gCAAgC;AAChC,kIAAkI;AAClI,UAAU,OAAO;AACjB,uCAAuC;AACvC,wDAAwD;AACxD,uCAAuC;AACvC,2CAA2C;AAC3C,2IAA2I;AAC3I,UAAU;AACV,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,8BAA8B;AAC9B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,sDAAsD;AACtD,6BAA6B;AAC7B,gCAAgC;AAChC,kIAAkI;AAClI,UAAU,OAAO;AACjB,uCAAuC;AACvC,wDAAwD;AACxD,uCAAuC;AACvC,2CAA2C;AAC3C,2IAA2I;AAC3I,UAAU;AACV,MAAM;;AAEN,0DAA0D;AAC1D,gCAAgC;AAChC,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,kBAAkB;AAClB,sDAAsD;AACtD,0BAA0B;AAC1B,MAAM;;;AAGN,2DAA2D;AAC3D,gCAAgC;AAChC,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,kBAAkB;AAClB,uDAAuD;AACvD,8BAA8B;AAC9B,oBAAoB,cAAc;AAClC,6BAA6B;AAC7B,8BAA8B;AAC9B,4BAA4B;AAC5B,0BAA0B;AAC1B,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,uBAAuB;AACvB,yBAAyB;AACzB,yBAAyB;AACzB,iBAAiB;AACjB,8EAA8E;AAC9E,6BAA6B;AAC7B,qFAAqF;AACrF,oCAAoC;AACpC,mDAAmD;AACnD,MAAM;;;AAGN,4DAA4D;AAC5D,yBAAyB;AACzB,kBAAkB;AAClB,+BAA+B;AAC/B,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,4BAA4B;AAC5B,iBAAiB;AACjB,8CAA8C;AAC9C,gDAAgD;AAChD,+GAA+G;AAC/G,MAAM;;AAEN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,yBAAyB;AACzB,4BAA4B;AAC5B,6BAA6B,uBAAuB,EAAE;AACtD,iBAAiB;AACjB,8CAA8C;AAC9C,6CAA6C;AAC7C,4CAA4C;AAC5C,oCAAoC;AACpC,2DAA2D;AAC3D,UAAU,KAAK;AACf,oDAAoD;AACpD,oEAAoE;AACpE,oEAAoE;AACpE,mHAAmH;AACnH,UAAU;AACV,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,yBAAyB;AACzB,0BAA0B;AAC1B,+BAA+B;AAC/B,yBAAyB;AACzB,4BAA4B;AAC5B,iBAAiB;AACjB,sCAAsC;AACtC,kCAAkC;AAClC,qCAAqC;AACrC,gBAAgB;AAChB,uCAAuC;AACvC,mEAAmE;AACnE,mEAAmE;AACnE,mEAAmE;AACnE,mEAAmE;AACnE,oCAAoC;AACpC,qCAAqC;AACrC,sCAAsC;AACtC,sCAAsC;;AAEtC,oCAAoC;AACpC,wEAAwE;AACxE,UAAU,KAAK;AACf,qEAAqE;AACrE,wFAAwF;AACxF,UAAU;AACV,MAAM;;AAEN,yDAAyD;AACzD,gCAAgC;AAChC,yBAAyB;AACzB,4BAA4B;AAC5B,kBAAkB;AAClB,+CAA+C;AAC/C,wBAAwB,SAAS,EAAE;AACnC,iCAAiC;AACjC,MAAM;;AAEN,0DAA0D;AAC1D,gCAAgC;AAChC,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,2BAA2B,uBAAuB,EAAE;;AAEpD,kBAAkB;AAClB,6BAA6B;AAC7B,0BAA0B;AAC1B,wCAAwC;;AAExC,uBAAuB;AACvB,uCAAuC;;AAEvC,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;;AAE3B,qCAAqC;AACrC,oCAAoC;AACpC,wFAAwF;;AAExF,gDAAgD;;AAEhD,0BAA0B,SAAS,EAAE;AACrC,gDAAgD;AAChD,MAAM;;AAEN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,uBAAuB;AACvB,4BAA4B;AAC5B,iBAAiB;AACjB,mDAAmD;AACnD,+BAA+B;AAC/B,MAAM;;;AAGN,4DAA4D;AAC5D,gCAAgC;AAChC,4BAA4B;AAC5B,sDAAsD;AACtD,kBAAkB;AAClB,0DAA0D;AAC1D,wEAAwE;AACxE,MAAM;;;AAGN,6DAA6D;AAC7D,gCAAgC;AAChC,4BAA4B;AAC5B,kBAAkB;AAClB,uDAAuD;AACvD,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,wBAAwB;AACxB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,uDAAuD;AACvD,2CAA2C;AAC3C,6CAA6C;AAC7C,+CAA+C;AAC/C,iCAAiC;AACjC,MAAM;;;AAGN,yDAAyD;AACzD,gCAAgC;AAChC,0BAA0B;AAC1B,2BAA2B;AAC3B,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B,0DAA0D;AACtF,6BAA6B,yDAAyD;AACtF,kBAAkB;AAClB,yDAAyD;AACzD,yCAAyC;AACzC,gDAAgD;AAChD,2CAA2C;AAC3C,MAAM;;;AAGN,0DAA0D;AAC1D,gCAAgC;AAChC,4BAA4B;AAC5B,0BAA0B;AAC1B,uBAAuB;AACvB,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B,0DAA0D;AACtF,kBAAkB;AAClB,+CAA+C;AAC/C,0BAA0B;AAC1B,mCAAmC;AACnC,uCAAuC;AACvC,+DAA+D;AAC/D,qBAAqB;AACrB,yCAAyC;AACzC,4BAA4B;;AAE5B,UAAU;AACV,kCAAkC;AAClC,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,gCAAgC;AAChC,6BAA6B;AAC7B,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;;AAE3B,6BAA6B;;AAE7B,iBAAiB;AACjB,4DAA4D;;AAE5D,6EAA6E;AAC7E,gCAAgC;AAChC,yCAAyC;AACzC,4CAA4C;AAC5C,sCAAsC;;AAEtC,8CAA8C;AAC9C,+CAA+C;AAC/C,0CAA0C;;AAE1C;AACA,6DAA6D;AAC7D,0FAA0F;AAC1F,gDAAgD;;AAEhD;AACA,0DAA0D;AAC1D,uFAAuF;;AAEvF;AACA,iCAAiC;AACjC,iEAAiE;;AAEjE;AACA,2HAA2H;AAC3H,uCAAuC;;AAEvC;AACA,iFAAiF;;AAEjF;AACA,2DAA2D;;AAE3D,+BAA+B;;AAE/B,qEAAqE;AACrE,+BAA+B;AAC/B,MAAM;;;AAGN,0DAA0D;AAC1D,6BAA6B;AAC7B,2BAA2B;AAC3B,4BAA4B,2DAA2D;AACvF,6BAA6B,0DAA0D;AACvF,uEAAuE;;AAEvE,kBAAkB;AAClB,gCAAgC;AAChC,6BAA6B,SAAS,EAAE,OAAO;AAC/C,uDAAuD;AACvD,qDAAqD;AACrD,+CAA+C;;AAE/C,iCAAiC,oFAAoF,EAAE;AACvH,UAAU;;AAEV,MAAM;;;AAGN;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,+BAA+B;AAC/B,2BAA2B;AAC3B,0CAA0C;AAC1C,0BAA0B;AAC1B,2CAA2C;AAC3C,0CAA0C;AAC1C,6BAA6B;AAC7B,6BAA6B;AAC7B,8BAA8B;AAC9B,2BAA2B,uBAAuB,EAAE;AACpD,kBAAkB;AAClB,8BAA8B;AAC9B,2FAA2F;AAC3F,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,iDAAiD;AACjD,oDAAoD;AACpD,gCAAgC;AAChC,sDAAsD;AACtD,sDAAsD;AACtD,MAAM;;;AAGN,8DAA8D;AAC9D,gCAAgC;AAChC,8BAA8B;AAC9B,6BAA6B;AAC7B,6BAA6B;AAC7B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB,4GAA4G;AAC5G,8DAA8D;AAC9D,MAAM;;;AAGN;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,+BAA+B;AAC/B,2BAA2B;AAC3B,0CAA0C;AAC1C,0BAA0B;AAC1B,2CAA2C;AAC3C,0CAA0C;AAC1C,6BAA6B;AAC7B,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B,uBAAuB,EAAE;AACpD,kBAAkB;AAClB,8BAA8B;AAC9B,2FAA2F;AAC3F,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,0BAA0B;AAC1B,oDAAoD;AACpD,gCAAgC;AAChC,sDAAsD;AACtD,sDAAsD;AACtD,MAAM;;;AAGN,mEAAmE;AACnE,gCAAgC;AAChC,8BAA8B;AAC9B,6BAA6B;AAC7B,6BAA6B;AAC7B,0BAA0B;AAC1B,kBAAkB;AAClB,yGAAyG;AACzG,MAAM;;AAEN;AACA,gEAAgE;AAChE,2EAA2E;AAC3E,2EAA2E;AAC3E,qDAAqD;AACrD,uDAAuD;AACvD,uDAAuD;AACvD,qHAAqH,EAAE;;AAEvH;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;AAC3B,gCAAgC;;AAEhC;AACA,8BAA8B;AAC9B,mCAAmC;AACnC;;AAEA,4BAA4B;AAC5B,6BAA6B;AAC7B,8BAA8B;;AAE9B;AACA,+CAA+C;AAC/C,6BAA6B;AAC7B,6BAA6B;AAC7B,qCAAqC;AACrC,0CAA0C;AAC1C,iCAAiC;AACjC,iCAAiC;AACjC,qFAAqF;AACrF,wFAAwF;AACxF,wCAAwC;AACxC,UAAU;AACV;;AAEA,kBAAkB;AAClB,kCAAkC;AAClC,4CAA4C;AAC5C,sBAAsB;AACtB,4BAA4B;AAC5B,6CAA6C;AAC7C,iDAAiD;AACjD,oDAAoD;AACpD,sCAAsC;AACtC,uBAAuB;AACvB,sBAAsB;AACtB,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gIAAgI;;AAEhI;AACA;AACA,kEAAkE;AAClE;AACA;;AAEA,oCAAoC;AACpC,2CAA2C;AAC3C,iDAAiD;;AAEjD;AACA,kCAAkC;AAClC;AACA,oDAAoD;AACpD;;AAEA,iBAAiB;AACjB,wDAAwD;AACxD,8DAA8D;AAC9D,wBAAwB;AACxB,2BAA2B;AAC3B,MAAM;;AAEN,0DAA0D;AAC1D,gCAAgC;AAChC,2BAA2B;;AAE3B;AACA,+BAA+B;AAC/B,iCAAiC;AACjC;;AAEA,4BAA4B;AAC5B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB;AACA,mEAAmE,SAAS,EAAE;AAC9E;;AAEA;AACA,iHAAiH;AACjH;AACA,2GAA2G;AAC3G,0DAA0D;AAC1D;AACA,MAAM;;AAEN;AACA,oEAAoE;AACpE,gBAAgB;AAChB,yFAAyF;AACzF,yFAAyF;AACzF,yFAAyF;AACzF,yFAAyF;AACzF,gEAAgE;;AAEhE;AACA,qEAAqE;AACrE,gBAAgB;AAChB,yFAAyF;AACzF,yFAAyF;AACzF,yFAAyF;AACzF,yFAAyF;AACzF,gDAAgD;;AAEhD;AACA;AACA,iCAAiC;AACjC,8BAA8B;AAC9B,gCAAgC;AAChC,mCAAmC;AACnC,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;AAC3B,gCAAgC;AAChC,0BAA0B;AAC1B,2BAA2B;AAC3B,6BAA6B;AAC7B,gCAAgC;AAChC,4BAA4B;AAC5B,6BAA6B;AAC7B,+BAA+B;;AAE/B;AACA,2BAA2B;AAC3B;AACA,8BAA8B;AAC9B;;AAEA,8BAA8B;AAC9B,6BAA6B,mFAAmF;;AAEhH,kBAAkB;AAClB,kCAAkC;AAClC,4CAA4C;AAC5C,sBAAsB;AACtB,4BAA4B;AAC5B,6CAA6C;AAC7C,iDAAiD;AACjD,oDAAoD;AACpD,sCAAsC;AACtC,uBAAuB;AACvB,sBAAsB;AACtB,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gIAAgI;AAChI,sCAAsC;AACtC,oGAAoG;;AAEpG,kGAAkG;;AAElG,oCAAoC;AACpC,2CAA2C;AAC3C,iDAAiD;AACjD,gDAAgD;;AAEhD,qCAAqC;AACrC,iDAAiD;AACjD,iDAAiD;AACjD,wBAAwB;;AAExB,wCAAwC;;AAExC;AACA,8FAA8F;AAC9F,yCAAyC,6BAA6B;AACtE,iEAAiE;AACjE;AACA,6FAA6F;AAC7F,oCAAoC;AACpC;;AAEA,MAAM;;AAEN,2DAA2D;AAC3D;AACA;AACA,gCAAgC;AAChC,2BAA2B;AAC3B,yBAAyB;AACzB,4BAA4B;AAC5B,8BAA8B;AAC9B,+BAA+B;;AAE/B;AACA,2BAA2B;AAC3B;AACA,8BAA8B;AAC9B;;AAEA,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB,8CAA8C;;AAE9C;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,oDAAoD;AACpD,qFAAqF;AACrF;;AAEA;AACA,mFAAmF;;AAEnF;AACA,kGAAkG;AAClG;AACA,4DAA4D;AAC5D;;AAEA;AACA,uCAAuC;AACvC;;AAEA,iDAAiD;;AAEjD,gCAAgC;AAChC,kDAAkD;AAClD,8EAA8E;AAC9E,iEAAiE;AACjE,4DAA4D;AAC5D,4DAA4D;AAC5D,gDAAgD;;AAEhD;AACA,oDAAoD;AACpD;AACA,0EAA0E;AAC1E;AACA,2DAA2D;AAC3D,gDAAgD;AAChD;;AAEA;AACA,2GAA2G;AAC3G,iCAAiC;AACjC;AACA;;AAEA,yDAAyD;;AAEzD;AACA,4CAA4C;;AAE5C;AACA,gEAAgE;AAChE,+DAA+D;AAC/D,iEAAiE;AACjE,+DAA+D;AAC/D,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,gEAAgE;AAChE,+DAA+D;AAC/D,iEAAiE;AACjE,kEAAkE;AAClE,kEAAkE;AAClE,kEAAkE;AAClE,kEAAkE;AAClE,kEAAkE;AAClE,gEAAgE;AAChE,kEAAkE;AAClE,kEAAkE;AAClE,iEAAiE;AACjE,gEAAgE;AAChE,gCAAgC;AAChC;;AAEA,oGAAoG;AACpG,+EAA+E;AAC/E,iFAAiF;AACjF,sEAAsE;AACtE,4FAA4F;AAC5F,kFAAkF;AAClF,uEAAuE;AACvE,uEAAuE;AACvE,uEAAuE;AACvE,iFAAiF;AACjF,uEAAuE;AACvE,8CAA8C;AAC9C;;AAEA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA,8BAA8B;AAC9B;AACA,MAAM;;;AAGN;AACA;AACA,8BAA8B;;AAE9B;AACA,kCAAkC;AAClC;;AAEA;AACA,uCAAuC;AACvC;AACA,sCAAsC;AACtC;;AAEA,gCAAgC;;AAEhC;;AAEA;AACA;AACA,uCAAuC;AACvC;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA,uCAAuC;AACvC;;AAEA,iCAAiC;;AAEjC,gCAAgC;;AAEhC,mEAAmE;AACnE,4BAA4B;AAC5B,iCAAiC;AACjC,uCAAuC;AACvC,iCAAiC;AACjC,sCAAsC;AACtC,4BAA4B;AAC5B,UAAU;;AAEV;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA,wCAAwC;AACxC,mCAAmC;AACnC;;AAEA;AACA,sCAAsC;;AAEtC;AACA,gCAAgC;AAChC;;AAEA,kBAAkB;;AAElB;AACA,4FAA4F;AAC5F,yFAAyF;AACzF,yCAAyC;AACzC,uCAAuC;AACvC,iDAAiD;AACjD,4CAA4C;AAC5C,mEAAmE;AACnE,0BAA0B;AAC1B,mGAAmG;AACnG,yCAAyC;AACzC,yDAAyD;AACzD,+EAA+E;AAC/E;AACA,2DAA2D;AAC3D,yKAAyK;AACzK,qGAAqG;AACrG;;AAEA,2CAA2C;AAC3C,iDAAiD;;AAEjD;AACA,8BAA8B;AAC9B;;AAEA;AACA,4CAA4C;AAC5C;;AAEA,4DAA4D;AAC5D,6EAA6E;;AAE7E;AACA,oCAAoC;AACpC;AACA,qCAAqC;;AAErC;AACA,mIAAmI;AACnI;AACA,0CAA0C;AAC1C;;AAEA;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;AACA,wLAAwL;AACxL,wLAAwL;AACxL,wLAAwL;;AAExL,gLAAgL;;AAEhL,oLAAoL;AACpL,oLAAoL;AACpL,wLAAwL;AACxL,oDAAoD;AACpD;AACA,MAAM;;AAEN,yDAAyD;;AAEzD;AACA,gCAAgC;AAChC,iCAAiC;AACjC;;AAEA;AACA,gCAAgC;AAChC,iCAAiC;AACjC;;;AAGA;AACA,kCAAkC;AAClC;;AAEA,gCAAgC;AAChC,oCAAoC;;AAEpC;AACA,yCAAyC;AACzC;;AAEA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA,mCAAmC;;AAEnC;AACA,iCAAiC;AACjC;;AAEA;;AAEA,2BAA2B;AAC3B,kBAAkB;;AAElB;AACA,qCAAqC;AACrC,yCAAyC;AACzC,kDAAkD;AAClD,kBAAkB,OAAO;AACzB,kDAAkD;AAClD,kBAAkB;AAClB,cAAc,OAAO;AACrB,yCAAyC;AACzC,kDAAkD;AAClD,kBAAkB,OAAO;AACzB,kDAAkD;AAClD,kBAAkB;AAClB,cAAc;AACd;;AAEA;AACA,qCAAqC;AACrC,yCAAyC;AACzC,4IAA4I;AAC5I,kBAAkB,OAAO;AACzB,4IAA4I;AAC5I,kBAAkB;AAClB,cAAc,OAAO;AACrB,yCAAyC;AACzC,4IAA4I;AAC5I,kBAAkB,OAAO;AACzB,4IAA4I;AAC5I,kBAAkB;AAClB,cAAc;AACd;;AAEA;AACA,sCAAsC;AACtC,0CAA0C;AAC1C,6CAA6C;AAC7C,sDAAsD;AACtD,sBAAsB,OAAO;AAC7B,sDAAsD;AACtD,sBAAsB;AACtB,kBAAkB,OAAO;AACzB,6CAA6C;AAC7C,sDAAsD;AACtD,sBAAsB,OAAO;AAC7B,sDAAsD;AACtD,sBAAsB;AACtB,kBAAkB;AAClB,cAAc,OAAO;AACrB,0CAA0C;AAC1C,6CAA6C;AAC7C,sDAAsD;AACtD,sBAAsB,OAAO;AAC7B,sDAAsD;AACtD,sBAAsB;AACtB,kBAAkB,OAAO;AACzB,6CAA6C;AAC7C,sDAAsD;AACtD,sBAAsB,OAAO;AAC7B,sDAAsD;AACtD,sBAAsB;AACtB,kBAAkB;AAClB,cAAc;AACd;;AAEA;;AAEA;AACA,gDAAgD;AAChD;AACA;AACA,kDAAkD;AAClD,kDAAkD;AAClD,yDAAyD;AACzD,uGAAuG;AACvG;AACA,oDAAoD;AACpD;AACA;;AAEA;;AAEA;;AAEA;AACA,iHAAiH;AACjH,+EAA+E;AAC/E;AACA,6DAA6D;AAC7D;;AAEA;;AAEA,qDAAqD;;AAErD;AACA,+DAA+D;AAC/D;;AAEA;AACA,qHAAqH;AACrH;;AAEA;AACA,oEAAoE;AACpE,iEAAiE;AACjE;AACA,0EAA0E;AAC1E,4DAA4D;AAC5D;AACA,qDAAqD;AACrD;;AAEA,2CAA2C;AAC3C;AACA,sGAAsG;AACtG;;AAEA;;AAEA;;AAEA;;AAEA;AACA,kFAAkF;AAClF;AACA,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,4BAA4B;AAC5B,6BAA6B;AAC7B,wBAAwB;AACxB,+BAA+B;AAC/B,4BAA4B;AAC5B,4BAA4B;AAC5B,0BAA0B;AAC1B,8BAA8B;AAC9B,kBAAkB;AAClB,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,iDAAiD;AACjD,+BAA+B;AAC/B,iCAAiC;AACjC,mCAAmC;AACnC,MAAM;;;AAGN,+DAA+D;AAC/D;AACA,oCAAoC;AACpC,gCAAgC;AAChC;AACA,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B;AAC5B,8BAA8B;AAC9B,4BAA4B;AAC5B,kBAAkB;AAClB,+CAA+C;AAC/C,0CAA0C;AAC1C,4BAA4B;AAC5B,8CAA8C;AAC9C,qFAAqF;AACrF,6DAA6D;AAC7D,8EAA8E;AAC9E;AACA,0DAA0D;AAC1D,mGAAmG,mCAAmC;AACtI;AACA,0FAA0F,mCAAmC;AAC7H;;AAEA,MAAM;;AAEN,+DAA+D;AAC/D,yBAAyB;AACzB,kBAAkB;AAClB,+BAA+B;AAC/B,MAAM;;;AAGN;AACA;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,wBAAwB;AACxB,yBAAyB;AACzB,0BAA0B;AAC1B,yBAAyB;AACzB,6BAA6B;AAC7B,qBAAqB;AACrB,gCAAgC;AAChC,qGAAqG;AACrG;;AAEA,gBAAgB;;AAEhB,gIAAgI;AAChI,gIAAgI;AAChI,gIAAgI;AAChI,gIAAgI;;AAEhI,yCAAyC;AACzC,uBAAuB;AACvB,kBAAkB;AAClB,kBAAkB;AAClB,MAAM;;;AAGN,0DAA0D;AAC1D,yBAAyB;AACzB,6BAA6B;AAC7B,gCAAgC;AAChC,qBAAqB;AACrB,uEAAuE;AACvE,mBAAmB;AACnB,wBAAwB,SAAS,EAAE;AACnC,0BAA0B;AAC1B,MAAM;;;AAGS,yEAAU,EAAC;;;;;;;;;;;;;;;;AC9gDwB;;AAElD;AACA,YAAY,kDAAM;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,cAAc;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEe,yEAAU,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;AC1SiB;AACT;AACA;AACA;AACa;AACP;AACA;AACA;;AAExC;AACA,uBAAuB,iDAAiB;AACxC,cAAc,iDAAQ;AACtB,cAAc,iDAAQ;AACtB,cAAc,iDAAQ;AACtB,oBAAoB,wDAAc;AAClC,iBAAiB,oDAAW;AAC5B,iBAAiB,oDAAW;AAC5B,iBAAiB,oDAAW;;;AAG5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wHAAwH;AACxH,8IAA8I;AAC9I,sGAAsG;AACtG,4JAA4J;AAC5J,6KAA6K;AAC7K,+IAA+I;;AAE/I;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kGAAkG;AAClG,0HAA0H;AAC1H,yJAAyJ;AACzJ,4KAA4K;AAC5K,2HAA2H;AAC3H,6KAA6K;AAC7K,8IAA8I;AAC9I,gMAAgM;AAChM,+IAA+I;AAC/I,oKAAoK;AACpK,8HAA8H;AAC9H,iJAAiJ;AACjJ,gLAAgL;AAChL,mMAAmM;;AAEnM,qGAAqG;AACrG,uGAAuG;AACvG,uGAAuG;AACvG,yGAAyG;AACzG,uGAAuG;AACvG,yGAAyG;AACzG,+HAA+H;;AAE/H,4HAA4H;AAC5H,+IAA+I;;AAE/I,qJ;AACA,qJ;AACA,qJ;AACA,qJ;AACA,qJ;AACA,uJ;;AAEA;AACA;AACA,kGAAkG;AAClG,qGAAqG;;AAErG,8HAA8H;AAC9H;AACA;AACA;AACA,8H;AACA,gI;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;;AAEjC;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,eAAe,UAAU;AACzB,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,eAAe,UAAU;AACzB,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,yCAAyC;AAC1F,+CAA+C,uDAAuD;AACtG,2CAA2C,yCAAyC;AACpF,oDAAoD,0CAA0C;AAC9F,kDAAkD,4BAA4B;;AAE9E,kDAAkD,sDAAsD;AACxG,kDAAkD,uDAAuD;AACzG,kDAAkD,uDAAuD;AACzG,kDAAkD,wDAAwD;;AAE1G,kDAAkD,uDAAuD;AACzG,kDAAkD,wDAAwD;AAC1G,kDAAkD,wDAAwD;AAC1G,kDAAkD,yDAAyD;;AAE3G;;;AAGA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGe,2EAAY,EAAC;;;;;;;;;;;;;;;;;;;AClbY;AACN;AACM;AAC2C;;AAEnF;AACA,iBAAiB,oDAAW;AAC5B,cAAc,iDAAQ;AACtB,iBAAiB,oDAAW;AAC5B,aAAa,iDAAO;AACpB,sBAAsB,0DAAgB;;AAEtC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA,gB;AACA;;;AAGA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA,iC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gC;AACA,K;AACA;AACA,iC;AACA,K;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gB;AACA;;;AAGA;AACA,gB;AACA;;;AAGA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGe,gFAAiB,EAAC;;;;;;;;;;;;;;;;;;AC3da;;AAE9C;AACA,WAAW,kDAAK;;;AAGhB;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;;AAEA,+BAA+B,OAAO;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sB;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sB;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,iBAAiB;AACjB;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;;AAEb;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB,yBAAyB;AACzB,OAAO,OAAO;AACd;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4D;AACA,4D;AACA,4D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEiC;;;;;;;;;;;;;;;;;;;;;;;ACrjB4B;AACvB;AACE;AACN;AACH;AACE;AACA;AACA;;AAEjC;AACA,WAAW,kDAAK,SAAS,kDAAK;AAC9B,gBAAgB,mDAAU;AAC1B,iBAAiB,oDAAW;AAC5B,cAAc,iDAAQ;AACtB,aAAa,+CAAO;AACpB,iBAAiB,6CAAW;AAC5B,iBAAiB,6CAAW;AAC5B,iBAAiB,6CAAW;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA6C;AAC7C,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;;AAEA;AACA,qBAAqB,UAAU,UAAU;AACzC,aAAa,oBAAoB,UAAU;AAC3C,aAAa,UAAU,WAAW;AAClC,4BAA4B,0BAA0B,WAAW;;AAEjE;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA,uEAAuE;;AAEvE;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,K;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,c;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4FAA4F;;AAE5F;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gGAAgG;AAChG;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,oEAAoE;AACpE;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;;AAE/B;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iC;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA,mCAAmC,eAAe;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;AACA,SAAS,K;AACT,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGe,uEAAQ,EAAC;;;;;;;;;;;;;;;;ACv0BsB;;AAE9C;AACA,WAAW,kDAAK;;;AAGhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+EAA+E;AAC/E;;AAEA;AACA,gFAAgF;AAChF;;AAEA;AACA,gFAAgF;AAChF;;AAEA;;AAEA,uBAAuB,iBAAiB,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,kBAAkB,QAAQ,SAAS,QAAQ;AAC3C,kBAAkB,QAAQ,SAAS,QAAQ;;AAE3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,QAAQ,SAAS,QAAQ;AAC3C,kBAAkB,QAAQ,SAAS,QAAQ;;AAE3C,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;;AAEA;AACA;AACA,uB;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;;AAEA;AACA;AACA,kB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,QAAQ;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC,QAAQ;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uB;AACA,a;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;;AAEA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;;AAEA;;AAEA;AACA;AACA,2B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mCAAmC,QAAQ;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uB;AACA,a;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,QAAQ;AAC3B,uBAAuB,QAAQ;AAC/B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,QAAQ;AACvB,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,2EAAY,EAAC;;;;;;;;;;;;;;;;;;AC3tBW;;AAEvC;AACA,WAAW,4CAAK;;;AAGhB;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGc;;;;;;;;;;;;;;;;;;;;;ACnLd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;;;ACpzCtC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEkB;;;;;;;;;;;;;;;;;ACxNlB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,6B;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;;AAEA,2B;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sD;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,6B;AACA;AACA;;;AAGkB;;;;;;;;;;;;;;;;;;ACjHmB;AACO;;AAE5C;AACA,WAAW,0CAAK;AAChB,eAAe,6CAAS;;;AAGxB;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,0BAA0B,6BAA6B;AACvD;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA,wCAAwC,cAAc,mCAAmC,E;;AAEzF;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA,0BAA0B,6BAA6B;AACvD;AACA,KAAK;AACL,CAAC;;;AAGD;AACA,8BAA8B,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA,oCAAoC;AACpC,CAAC;;;AAGD;AACA;AACA,CAAC;;;AAGD;AACA;AACA,CAAC,E;;;AAGD;AACA;AACA,CAAC,E;;;AAGD;AACA;AACA,iB;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;;;AAGA,kF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGe;;AAEf;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC","file":"vts-core.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/core/index.js\");\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","/*\n * Geodesic routines from GeographicLib translated to JavaScript.  See\n * https://geographiclib.sourceforge.io/html/js/\n *\n * The algorithms are derived in\n *\n *    Charles F. F. Karney,\n *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013),\n *    https://doi.org/10.1007/s00190-012-0578-z\n *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html\n *\n * This file is the concatenation and compression of the JavaScript files in\n * doc/scripts/GeographicLib in the source tree for GeographicLib.\n *\n * Copyright (c) Charles Karney (2011-2015) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n *\n * Version: 1.50\n * File inventory:\n *   Math.js Geodesic.js GeodesicLine.js PolygonArea.js DMS.js\n */\n\n(function(cb) {\n\n/**************** Math.js ****************/\n/*\n * Math.js\n * Transcription of Math.hpp, Constants.hpp, and Accumulator.hpp into\n * JavaScript.\n *\n * Copyright (c) Charles Karney (2011-2019) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\n/**\n * @namespace GeographicLib\n * @description The parent namespace for the following modules:\n * - {@link module:GeographicLib/Geodesic GeographicLib/Geodesic} The main\n *   engine for solving geodesic problems via the\n *   {@link module:GeographicLib/Geodesic.Geodesic Geodesic} class.\n * - {@link module:GeographicLib/GeodesicLine GeographicLib/GeodesicLine}\n *   computes points along a single geodesic line via the\n *   {@link module:GeographicLib/GeodesicLine.GeodesicLine GeodesicLine}\n *   class.\n * - {@link module:GeographicLib/PolygonArea GeographicLib/PolygonArea}\n *   computes the area of a geodesic polygon via the\n *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea}\n *   class.\n * - {@link module:GeographicLib/DMS GeographicLib/DMS} handles the decoding\n *   and encoding of angles in degree, minutes, and seconds, via static\n *   functions in this module.\n * - {@link module:GeographicLib/Constants GeographicLib/Constants} defines\n *   constants specifying the version numbers and the parameters for the WGS84\n *   ellipsoid.\n *\n * The following modules are used internally by the package:\n * - {@link module:GeographicLib/Math GeographicLib/Math} defines various\n *   mathematical functions.\n * - {@link module:GeographicLib/Accumulator GeographicLib/Accumulator}\n *   interally used by\n *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea} (via the\n *   {@link module:GeographicLib/Accumulator.Accumulator Accumulator} class)\n *   for summing the contributions to the area of a polygon.\n */\n\"use strict\";\nvar GeographicLib = {};\nGeographicLib.Constants = {};\nGeographicLib.Math = {};\nGeographicLib.Accumulator = {};\n\n(function(\n  /**\n   * @exports GeographicLib/Constants\n   * @description Define constants defining the version and WGS84 parameters.\n   */\n  c) {\n\n  /**\n   * @constant\n   * @summary WGS84 parameters.\n   * @property {number} a the equatorial radius (meters).\n   * @property {number} f the flattening.\n   */\n  c.WGS84 = { a: 6378137, f: 1/298.257223563 };\n  /**\n   * @constant\n   * @summary an array of version numbers.\n   * @property {number} major the major version number.\n   * @property {number} minor the minor version number.\n   * @property {number} patch the patch number.\n   */\n  c.version = { major: 1, minor: 50, patch: 0 };\n  /**\n   * @constant\n   * @summary version string\n   */\n  c.version_string = \"1.50\";\n})(GeographicLib.Constants);\n\n(function(\n  /**\n   * @exports GeographicLib/Math\n   * @description Some useful mathematical constants and functions (mainly for\n   *   internal use).\n   */\n  m) {\n\n  /**\n   * @summary The number of digits of precision in floating-point numbers.\n   * @constant {number}\n   */\n  m.digits = 53;\n  /**\n   * @summary The machine epsilon.\n   * @constant {number}\n   */\n  m.epsilon = Math.pow(0.5, m.digits - 1);\n  /**\n   * @summary The factor to convert degrees to radians.\n   * @constant {number}\n   */\n  m.degree = Math.PI/180;\n\n  /**\n   * @summary Square a number.\n   * @param {number} x the number.\n   * @returns {number} the square.\n   */\n  m.sq = function(x) { return x * x; };\n\n  /**\n   * @summary The hypotenuse function.\n   * @param {number} x the first side.\n   * @param {number} y the second side.\n   * @returns {number} the hypotenuse.\n   */\n  m.hypot = Math.hypot || function(x, y) {\n    var a, b;\n    x = Math.abs(x);\n    y = Math.abs(y);\n    a = Math.max(x, y); b = Math.min(x, y) / (a ? a : 1);\n    return a * Math.sqrt(1 + b * b);\n  };\n\n  /**\n   * @summary Cube root function.\n   * @param {number} x the argument.\n   * @returns {number} the real cube root.\n   */\n  m.cbrt = Math.cbrt || function(x) {\n    var y = Math.pow(Math.abs(x), 1/3);\n    return x > 0 ? y : (x < 0 ? -y : x);\n  };\n\n  /**\n   * @summary The log1p function.\n   * @param {number} x the argument.\n   * @returns {number} log(1 + x).\n   */\n  m.log1p = Math.log1p || function(x) {\n    var y = 1 + x,\n        z = y - 1;\n    // Here's the explanation for this magic: y = 1 + z, exactly, and z\n    // approx x, thus log(y)/z (which is nearly constant near z = 0) returns\n    // a good approximation to the true log(1 + x)/x.  The multiplication x *\n    // (log(y)/z) introduces little additional error.\n    return z === 0 ? x : x * Math.log(y) / z;\n  };\n\n  /**\n   * @summary Inverse hyperbolic tangent.\n   * @param {number} x the argument.\n   * @returns {number} tanh<sup>&minus;1</sup> x.\n   */\n  m.atanh = Math.atanh || function(x) {\n    var y = Math.abs(x);          // Enforce odd parity\n    y = m.log1p(2 * y/(1 - y))/2;\n    return x > 0 ? y : (x < 0 ? -y : x);\n  };\n\n  /**\n   * @summary Copy the sign.\n   * @param {number} x gives the magitude of the result.\n   * @param {number} y gives the sign of the result.\n   * @returns {number} value with the magnitude of x and with the sign of y.\n   */\n  m.copysign = function(x, y) {\n    return Math.abs(x) * (y < 0 || (y === 0 && 1/y < 0) ? -1 : 1);\n  };\n\n  /**\n   * @summary An error-free sum.\n   * @param {number} u\n   * @param {number} v\n   * @returns {object} sum with sum.s = round(u + v) and sum.t is u + v &minus;\n   *   round(u + v)\n   */\n  m.sum = function(u, v) {\n    var s = u + v,\n        up = s - v,\n        vpp = s - up,\n        t;\n    up -= u;\n    vpp -= v;\n    t = -(up + vpp);\n    // u + v =       s      + t\n    //       = round(u + v) + t\n    return {s: s, t: t};\n  };\n\n  /**\n   * @summary Evaluate a polynomial.\n   * @param {integer} N the order of the polynomial.\n   * @param {array} p the coefficient array (of size N + 1) (leading\n   *   order coefficient first)\n   * @param {number} x the variable.\n   * @returns {number} the value of the polynomial.\n   */\n  m.polyval = function(N, p, s, x) {\n    var y = N < 0 ? 0 : p[s++];\n    while (--N >= 0) y = y * x + p[s++];\n    return y;\n  };\n\n  /**\n   * @summary Coarsen a value close to zero.\n   * @param {number} x\n   * @returns {number} the coarsened value.\n   */\n  m.AngRound = function(x) {\n    // The makes the smallest gap in x = 1/16 - nextafter(1/16, 0) = 1/2^57 for\n    // reals = 0.7 pm on the earth if x is an angle in degrees.  (This is about\n    // 1000 times more resolution than we get with angles around 90 degrees.)\n    // We use this to avoid having to deal with near singular cases when x is\n    // non-zero but tiny (e.g., 1.0e-200).  This converts -0 to +0; however\n    // tiny negative numbers get converted to -0.\n    if (x === 0) return x;\n    var z = 1/16,\n        y = Math.abs(x);\n    // The compiler mustn't \"simplify\" z - (z - y) to y\n    y = y < z ? z - (z - y) : y;\n    return x < 0 ? -y : y;\n  };\n\n  /**\n   * @summary The remainder function.\n   * @param {number} x the numerator of the division\n   * @param {number} y the denominator of the division\n   * @return {number} the remainder in the range [&minus;y/2, y/2].\n   * <p>\n   * The range of x is unrestricted; y must be positive.\n   */\n  m.remainder = function(x, y) {\n    x = x % y;\n    return x < -y/2 ? x + y : (x < y/2 ? x : x - y);\n  };\n\n  /**\n   * @summary Normalize an angle.\n   * @param {number} x the angle in degrees.\n   * @returns {number} the angle reduced to the range (&minus;180&deg;,\n   *   180&deg;].\n   */\n  m.AngNormalize = function(x) {\n    // Place angle in (-180, 180].\n    x = m.remainder(x, 360);\n    return x == -180 ? 180 : x;\n  };\n\n  /**\n   * @summary Normalize a latitude.\n   * @param {number} x the angle in degrees.\n   * @returns {number} x if it is in the range [&minus;90&deg;, 90&deg;],\n   *   otherwise return NaN.\n   */\n  m.LatFix = function(x) {\n    // Replace angle with NaN if outside [-90, 90].\n    return Math.abs(x) > 90 ? Number.NaN : x;\n  };\n\n  /**\n   * @summary The exact difference of two angles reduced to (&minus;180&deg;,\n   *   180&deg;]\n   * @param {number} x the first angle in degrees.\n   * @param {number} y the second angle in degrees.\n   * @return {object} diff the exact difference, y &minus; x.\n   *\n   * This computes z = y &minus; x exactly, reduced to (&minus;180&deg;,\n   * 180&deg;]; and then sets diff.s = d = round(z) and diff.t = e = z &minus;\n   * round(z).  If d = &minus;180, then e &gt; 0; If d = 180, then e &le; 0.\n   */\n  m.AngDiff = function(x, y) {\n    // Compute y - x and reduce to [-180,180] accurately.\n    var r = m.sum(m.AngNormalize(-x), m.AngNormalize(y)),\n        d = m.AngNormalize(r.s),\n        t = r.t;\n    return m.sum(d === 180 && t > 0 ? -180 : d, t);\n  };\n\n  /**\n   * @summary Evaluate the sine and cosine function with the argument in\n   *   degrees\n   * @param {number} x in degrees.\n   * @returns {object} r with r.s = sin(x) and r.c = cos(x).\n   */\n  m.sincosd = function(x) {\n    // In order to minimize round-off errors, this function exactly reduces\n    // the argument to the range [-45, 45] before converting it to radians.\n    var r, q, s, c, sinx, cosx;\n    r = x % 360;\n    q = 0 + Math.round(r / 90); // If r is NaN this returns NaN\n    r -= 90 * q;\n    // now abs(r) <= 45\n    r *= this.degree;\n    // Possibly could call the gnu extension sincos\n    s = Math.sin(r); c = Math.cos(r);\n    switch (q & 3) {\n      case 0:  sinx =  s; cosx =  c; break;\n      case 1:  sinx =  c; cosx = -s; break;\n      case 2:  sinx = -s; cosx = -c; break;\n      default: sinx = -c; cosx =  s; break; // case 3\n    }\n    if (x !== 0) { sinx += 0; cosx += 0; }\n    return {s: sinx, c: cosx};\n  };\n\n  /**\n   * @summary Evaluate the atan2 function with the result in degrees\n   * @param {number} y\n   * @param {number} x\n   * @returns atan2(y, x) in degrees, in the range (&minus;180&deg;\n   *   180&deg;].\n   */\n  m.atan2d = function(y, x) {\n    // In order to minimize round-off errors, this function rearranges the\n    // arguments so that result of atan2 is in the range [-pi/4, pi/4] before\n    // converting it to degrees and mapping the result to the correct\n    // quadrant.\n    var q = 0, t, ang;\n    if (Math.abs(y) > Math.abs(x)) { t = x; x = y; y = t; q = 2; }\n    if (x < 0) { x = -x; ++q; }\n    // here x >= 0 and x >= abs(y), so angle is in [-pi/4, pi/4]\n    ang = Math.atan2(y, x) / this.degree;\n    switch (q) {\n      // Note that atan2d(-0.0, 1.0) will return -0.  However, we expect that\n      // atan2d will not be called with y = -0.  If need be, include\n      //\n      //   case 0: ang = 0 + ang; break;\n      //\n      // and handle mpfr as in AngRound.\n      case 1: ang = (y >= 0 ? 180 : -180) - ang; break;\n      case 2: ang =  90 - ang; break;\n      case 3: ang = -90 + ang; break;\n    }\n    return ang;\n  };\n})(GeographicLib.Math);\n\n(function(\n  /**\n   * @exports GeographicLib/Accumulator\n   * @description Accurate summation via the\n   *   {@link module:GeographicLib/Accumulator.Accumulator Accumulator} class\n   *   (mainly for internal use).\n   */\n  a, m) {\n\n  /**\n   * @class\n   * @summary Accurate summation of many numbers.\n   * @classdesc This allows many numbers to be added together with twice the\n   *   normal precision.  In the documentation of the member functions, sum\n   *   stands for the value currently held in the accumulator.\n   * @param {number | Accumulator} [y = 0]  set sum = y.\n   */\n  a.Accumulator = function(y) {\n    this.Set(y);\n  };\n\n  /**\n   * @summary Set the accumulator to a number.\n   * @param {number | Accumulator} [y = 0] set sum = y.\n   */\n  a.Accumulator.prototype.Set = function(y) {\n    if (!y) y = 0;\n    if (y.constructor === a.Accumulator) {\n      this._s = y._s;\n      this._t = y._t;\n    } else {\n      this._s = y;\n      this._t = 0;\n    }\n  };\n\n  /**\n   * @summary Add a number to the accumulator.\n   * @param {number} [y = 0] set sum += y.\n   */\n  a.Accumulator.prototype.Add = function(y) {\n    // Here's Shewchuk's solution...\n    // Accumulate starting at least significant end\n    var u = m.sum(y, this._t),\n        v = m.sum(u.s, this._s);\n    u = u.t;\n    this._s = v.s;\n    this._t = v.t;\n    // Start is _s, _t decreasing and non-adjacent.  Sum is now (s + t + u)\n    // exactly with s, t, u non-adjacent and in decreasing order (except\n    // for possible zeros).  The following code tries to normalize the\n    // result.  Ideally, we want _s = round(s+t+u) and _u = round(s+t+u -\n    // _s).  The follow does an approximate job (and maintains the\n    // decreasing non-adjacent property).  Here are two \"failures\" using\n    // 3-bit floats:\n    //\n    // Case 1: _s is not equal to round(s+t+u) -- off by 1 ulp\n    // [12, -1] - 8 -> [4, 0, -1] -> [4, -1] = 3 should be [3, 0] = 3\n    //\n    // Case 2: _s+_t is not as close to s+t+u as it shold be\n    // [64, 5] + 4 -> [64, 8, 1] -> [64,  8] = 72 (off by 1)\n    //                    should be [80, -7] = 73 (exact)\n    //\n    // \"Fixing\" these problems is probably not worth the expense.  The\n    // representation inevitably leads to small errors in the accumulated\n    // values.  The additional errors illustrated here amount to 1 ulp of\n    // the less significant word during each addition to the Accumulator\n    // and an additional possible error of 1 ulp in the reported sum.\n    //\n    // Incidentally, the \"ideal\" representation described above is not\n    // canonical, because _s = round(_s + _t) may not be true.  For\n    // example, with 3-bit floats:\n    //\n    // [128, 16] + 1 -> [160, -16] -- 160 = round(145).\n    // But [160, 0] - 16 -> [128, 16] -- 128 = round(144).\n    //\n    if (this._s === 0)          // This implies t == 0,\n      this._s = u;              // so result is u\n    else\n      this._t += u;             // otherwise just accumulate u to t.\n  };\n\n  /**\n   * @summary Return the result of adding a number to sum (but\n   *   don't change sum).\n   * @param {number} [y = 0] the number to be added to the sum.\n   * @return sum + y.\n   */\n  a.Accumulator.prototype.Sum = function(y) {\n    var b;\n    if (!y)\n      return this._s;\n    else {\n      b = new a.Accumulator(this);\n      b.Add(y);\n      return b._s;\n    }\n  };\n\n  /**\n   * @summary Set sum = &minus;sum.\n   */\n  a.Accumulator.prototype.Negate = function() {\n    this._s *= -1;\n    this._t *= -1;\n  };\n\n  /**\n   * @summary Take the remainder\n   * @param {number} y the divisor of the remainder operation.\n   * @return sum in range [&minus;y/2, y/2].\n   */\n  a.Accumulator.prototype.Remainder = function(y) {\n    this._s = m.remainder(this._s, y);\n    this.Add(0);\n  };\n})(GeographicLib.Accumulator, GeographicLib.Math);\n\n/**************** Geodesic.js ****************/\n/*\n * Geodesic.js\n * Transcription of Geodesic.[ch]pp into JavaScript.\n *\n * See the documentation for the C++ class.  The conversion is a literal\n * conversion from C++.\n *\n * The algorithms are derived in\n *\n *    Charles F. F. Karney,\n *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);\n *    https://doi.org/10.1007/s00190-012-0578-z\n *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html\n *\n * Copyright (c) Charles Karney (2011-2017) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\n// Load AFTER Math.js\n\nGeographicLib.Geodesic = {};\nGeographicLib.GeodesicLine = {};\nGeographicLib.PolygonArea = {};\n\n(function(\n  /**\n   * @exports GeographicLib/Geodesic\n   * @description Solve geodesic problems via the\n   *   {@link module:GeographicLib/Geodesic.Geodesic Geodesic} class.\n   */\n  g, l, p, m, c) {\n\n  var GEOGRAPHICLIB_GEODESIC_ORDER = 6,\n      nA1_ = GEOGRAPHICLIB_GEODESIC_ORDER,\n      nA2_ = GEOGRAPHICLIB_GEODESIC_ORDER,\n      nA3_ = GEOGRAPHICLIB_GEODESIC_ORDER,\n      nA3x_ = nA3_,\n      nC3x_, nC4x_,\n      maxit1_ = 20,\n      maxit2_ = maxit1_ + m.digits + 10,\n      tol0_ = m.epsilon,\n      tol1_ = 200 * tol0_,\n      tol2_ = Math.sqrt(tol0_),\n      tolb_ = tol0_ * tol1_,\n      xthresh_ = 1000 * tol2_,\n      CAP_NONE = 0,\n      CAP_ALL  = 0x1F,\n      CAP_MASK = CAP_ALL,\n      OUT_ALL  = 0x7F80,\n      astroid,\n      A1m1f_coeff, C1f_coeff, C1pf_coeff,\n      A2m1f_coeff, C2f_coeff,\n      A3_coeff, C3_coeff, C4_coeff;\n\n  g.tiny_ = Math.sqrt(Number.MIN_VALUE);\n  g.nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  g.nC1p_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  g.nC2_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  g.nC3_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  g.nC4_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  nC3x_ = (g.nC3_ * (g.nC3_ - 1)) / 2;\n  nC4x_ = (g.nC4_ * (g.nC4_ + 1)) / 2;\n  g.CAP_C1   = 1<<0;\n  g.CAP_C1p  = 1<<1;\n  g.CAP_C2   = 1<<2;\n  g.CAP_C3   = 1<<3;\n  g.CAP_C4   = 1<<4;\n\n  g.NONE          = 0;\n  g.ARC           = 1<<6;\n  g.LATITUDE      = 1<<7  | CAP_NONE;\n  g.LONGITUDE     = 1<<8  | g.CAP_C3;\n  g.AZIMUTH       = 1<<9  | CAP_NONE;\n  g.DISTANCE      = 1<<10 | g.CAP_C1;\n  g.STANDARD      = g.LATITUDE | g.LONGITUDE | g.AZIMUTH | g.DISTANCE;\n  g.DISTANCE_IN   = 1<<11 | g.CAP_C1 | g.CAP_C1p;\n  g.REDUCEDLENGTH = 1<<12 | g.CAP_C1 | g.CAP_C2;\n  g.GEODESICSCALE = 1<<13 | g.CAP_C1 | g.CAP_C2;\n  g.AREA          = 1<<14 | g.CAP_C4;\n  g.ALL           = OUT_ALL| CAP_ALL;\n  g.LONG_UNROLL   = 1<<15;\n  g.OUT_MASK      = OUT_ALL| g.LONG_UNROLL;\n\n  g.SinCosSeries = function(sinp, sinx, cosx, c) {\n    // Evaluate\n    // y = sinp ? sum(c[i] * sin( 2*i    * x), i, 1, n) :\n    //            sum(c[i] * cos((2*i+1) * x), i, 0, n-1)\n    // using Clenshaw summation.  N.B. c[0] is unused for sin series\n    // Approx operation count = (n + 5) mult and (2 * n + 2) add\n    var k = c.length,           // Point to one beyond last element\n        n = k - (sinp ? 1 : 0),\n        ar = 2 * (cosx - sinx) * (cosx + sinx), // 2 * cos(2 * x)\n        y0 = n & 1 ? c[--k] : 0, y1 = 0;        // accumulators for sum\n    // Now n is even\n    n = Math.floor(n/2);\n    while (n--) {\n      // Unroll loop x 2, so accumulators return to their original role\n      y1 = ar * y0 - y1 + c[--k];\n      y0 = ar * y1 - y0 + c[--k];\n    }\n    return (sinp ? 2 * sinx * cosx * y0 : // sin(2 * x) * y0\n            cosx * (y0 - y1));            // cos(x) * (y0 - y1)\n  };\n\n  astroid = function(x, y) {\n    // Solve k^4+2*k^3-(x^2+y^2-1)*k^2-2*y^2*k-y^2 = 0 for positive\n    // root k.  This solution is adapted from Geocentric::Reverse.\n    var k,\n        p = m.sq(x),\n        q = m.sq(y),\n        r = (p + q - 1) / 6,\n        S, r2, r3, disc, u, T3, T, ang, v, uv, w;\n    if ( !(q === 0 && r <= 0) ) {\n      // Avoid possible division by zero when r = 0 by multiplying\n      // equations for s and t by r^3 and r, resp.\n      S = p * q / 4;            // S = r^3 * s\n      r2 = m.sq(r);\n      r3 = r * r2;\n      // The discriminant of the quadratic equation for T3.  This is\n      // zero on the evolute curve p^(1/3)+q^(1/3) = 1\n      disc = S * (S + 2 * r3);\n      u = r;\n      if (disc >= 0) {\n        T3 = S + r3;\n        // Pick the sign on the sqrt to maximize abs(T3).  This\n        // minimizes loss of precision due to cancellation.  The\n        // result is unchanged because of the way the T is used\n        // in definition of u.\n        T3 += T3 < 0 ? -Math.sqrt(disc) : Math.sqrt(disc);    // T3 = (r * t)^3\n        // N.B. cbrt always returns the real root.  cbrt(-8) = -2.\n        T = m.cbrt(T3);     // T = r * t\n        // T can be zero; but then r2 / T -> 0.\n        u += T + (T !== 0 ? r2 / T : 0);\n      } else {\n        // T is complex, but the way u is defined the result is real.\n        ang = Math.atan2(Math.sqrt(-disc), -(S + r3));\n        // There are three possible cube roots.  We choose the\n        // root which avoids cancellation.  Note that disc < 0\n        // implies that r < 0.\n        u += 2 * r * Math.cos(ang / 3);\n      }\n      v = Math.sqrt(m.sq(u) + q);       // guaranteed positive\n      // Avoid loss of accuracy when u < 0.\n      uv = u < 0 ? q / (v - u) : u + v; // u+v, guaranteed positive\n      w = (uv - q) / (2 * v);           // positive?\n      // Rearrange expression for k to avoid loss of accuracy due to\n      // subtraction.  Division by 0 not possible because uv > 0, w >= 0.\n      k = uv / (Math.sqrt(uv + m.sq(w)) + w); // guaranteed positive\n    } else {                                  // q == 0 && r <= 0\n      // y = 0 with |x| <= 1.  Handle this case directly.\n      // for y small, positive root is k = abs(y)/sqrt(1-x^2)\n      k = 0;\n    }\n    return k;\n  };\n\n  A1m1f_coeff = [\n    // (1-eps)*A1-1, polynomial in eps2 of order 3\n      +1, 4, 64, 0, 256\n  ];\n\n  // The scale factor A1-1 = mean value of (d/dsigma)I1 - 1\n  g.A1m1f = function(eps) {\n    var p = Math.floor(nA1_/2),\n        t = m.polyval(p, A1m1f_coeff, 0, m.sq(eps)) / A1m1f_coeff[p + 1];\n    return (t + eps) / (1 - eps);\n  };\n\n  C1f_coeff = [\n    // C1[1]/eps^1, polynomial in eps2 of order 2\n      -1, 6, -16, 32,\n    // C1[2]/eps^2, polynomial in eps2 of order 2\n      -9, 64, -128, 2048,\n    // C1[3]/eps^3, polynomial in eps2 of order 1\n      +9, -16, 768,\n    // C1[4]/eps^4, polynomial in eps2 of order 1\n      +3, -5, 512,\n    // C1[5]/eps^5, polynomial in eps2 of order 0\n      -7, 1280,\n    // C1[6]/eps^6, polynomial in eps2 of order 0\n      -7, 2048\n  ];\n\n  // The coefficients C1[l] in the Fourier expansion of B1\n  g.C1f = function(eps, c) {\n    var eps2 = m.sq(eps),\n        d = eps,\n        o = 0,\n        l, p;\n    for (l = 1; l <= g.nC1_; ++l) {     // l is index of C1p[l]\n      p = Math.floor((g.nC1_ - l) / 2); // order of polynomial in eps^2\n      c[l] = d * m.polyval(p, C1f_coeff, o, eps2) / C1f_coeff[o + p + 1];\n      o += p + 2;\n      d *= eps;\n    }\n  };\n\n  C1pf_coeff = [\n    // C1p[1]/eps^1, polynomial in eps2 of order 2\n      +205, -432, 768, 1536,\n    // C1p[2]/eps^2, polynomial in eps2 of order 2\n      +4005, -4736, 3840, 12288,\n    // C1p[3]/eps^3, polynomial in eps2 of order 1\n      -225, 116, 384,\n    // C1p[4]/eps^4, polynomial in eps2 of order 1\n      -7173, 2695, 7680,\n    // C1p[5]/eps^5, polynomial in eps2 of order 0\n      +3467, 7680,\n    // C1p[6]/eps^6, polynomial in eps2 of order 0\n      +38081, 61440\n  ];\n\n  // The coefficients C1p[l] in the Fourier expansion of B1p\n  g.C1pf = function(eps, c) {\n    var eps2 = m.sq(eps),\n        d = eps,\n        o = 0,\n        l, p;\n    for (l = 1; l <= g.nC1p_; ++l) {     // l is index of C1p[l]\n      p = Math.floor((g.nC1p_ - l) / 2); // order of polynomial in eps^2\n      c[l] = d * m.polyval(p, C1pf_coeff, o, eps2) / C1pf_coeff[o + p + 1];\n      o += p + 2;\n      d *= eps;\n    }\n  };\n\n  A2m1f_coeff = [\n    // (eps+1)*A2-1, polynomial in eps2 of order 3\n      -11, -28, -192, 0, 256\n  ];\n\n  // The scale factor A2-1 = mean value of (d/dsigma)I2 - 1\n  g.A2m1f = function(eps) {\n    var p = Math.floor(nA2_/2),\n        t = m.polyval(p, A2m1f_coeff, 0, m.sq(eps)) / A2m1f_coeff[p + 1];\n    return (t - eps) / (1 + eps);\n  };\n\n  C2f_coeff = [\n    // C2[1]/eps^1, polynomial in eps2 of order 2\n      +1, 2, 16, 32,\n    // C2[2]/eps^2, polynomial in eps2 of order 2\n      +35, 64, 384, 2048,\n    // C2[3]/eps^3, polynomial in eps2 of order 1\n      +15, 80, 768,\n    // C2[4]/eps^4, polynomial in eps2 of order 1\n      +7, 35, 512,\n    // C2[5]/eps^5, polynomial in eps2 of order 0\n      +63, 1280,\n    // C2[6]/eps^6, polynomial in eps2 of order 0\n      +77, 2048\n  ];\n\n  // The coefficients C2[l] in the Fourier expansion of B2\n  g.C2f = function(eps, c) {\n    var eps2 = m.sq(eps),\n        d = eps,\n        o = 0,\n        l, p;\n    for (l = 1; l <= g.nC2_; ++l) {     // l is index of C2[l]\n      p = Math.floor((g.nC2_ - l) / 2); // order of polynomial in eps^2\n      c[l] = d * m.polyval(p, C2f_coeff, o, eps2) / C2f_coeff[o + p + 1];\n      o += p + 2;\n      d *= eps;\n    }\n  };\n\n  /**\n   * @class\n   * @property {number} a the equatorial radius (meters).\n   * @property {number} f the flattening.\n   * @summary Initialize a Geodesic object for a specific ellipsoid.\n   * @classdesc Performs geodesic calculations on an ellipsoid of revolution.\n   *   The routines for solving the direct and inverse problems return an\n   *   object with some of the following fields set: lat1, lon1, azi1, lat2,\n   *   lon2, azi2, s12, a12, m12, M12, M21, S12.  See {@tutorial 2-interface},\n   *   \"The results\".\n   * @example\n   * var GeographicLib = require(\"geographiclib\"),\n   *     geod = GeographicLib.Geodesic.WGS84;\n   * var inv = geod.Inverse(1,2,3,4);\n   * console.log(\"lat1 = \" + inv.lat1 + \", lon1 = \" + inv.lon1 +\n   *             \", lat2 = \" + inv.lat2 + \", lon2 = \" + inv.lon2 +\n   *             \",\\nazi1 = \" + inv.azi1 + \", azi2 = \" + inv.azi2 +\n   *             \", s12 = \" + inv.s12);\n   * @param {number} a the equatorial radius of the ellipsoid (meters).\n   * @param {number} f the flattening of the ellipsoid.  Setting f = 0 gives\n   *   a sphere (on which geodesics are great circles).  Negative f gives a\n   *   prolate ellipsoid.\n   * @throws an error if the parameters are illegal.\n   */\n  g.Geodesic = function(a, f) {\n    this.a = a;\n    this.f = f;\n    this._f1 = 1 - this.f;\n    this._e2 = this.f * (2 - this.f);\n    this._ep2 = this._e2 / m.sq(this._f1); // e2 / (1 - e2)\n    this._n = this.f / ( 2 - this.f);\n    this._b = this.a * this._f1;\n    // authalic radius squared\n    this._c2 = (m.sq(this.a) + m.sq(this._b) *\n                (this._e2 === 0 ? 1 :\n                 (this._e2 > 0 ? m.atanh(Math.sqrt(this._e2)) :\n                  Math.atan(Math.sqrt(-this._e2))) /\n                 Math.sqrt(Math.abs(this._e2))))/2;\n    // The sig12 threshold for \"really short\".  Using the auxiliary sphere\n    // solution with dnm computed at (bet1 + bet2) / 2, the relative error in\n    // the azimuth consistency check is sig12^2 * abs(f) * min(1, 1-f/2) / 2.\n    // (Error measured for 1/100 < b/a < 100 and abs(f) >= 1/1000.  For a given\n    // f and sig12, the max error occurs for lines near the pole.  If the old\n    // rule for computing dnm = (dn1 + dn2)/2 is used, then the error increases\n    // by a factor of 2.)  Setting this equal to epsilon gives sig12 = etol2.\n    // Here 0.1 is a safety factor (error decreased by 100) and max(0.001,\n    // abs(f)) stops etol2 getting too large in the nearly spherical case.\n    this._etol2 = 0.1 * tol2_ /\n      Math.sqrt( Math.max(0.001, Math.abs(this.f)) *\n                 Math.min(1.0, 1 - this.f/2) / 2 );\n    if (!(isFinite(this.a) && this.a > 0))\n      throw new Error(\"Equatorial radius is not positive\");\n    if (!(isFinite(this._b) && this._b > 0))\n      throw new Error(\"Polar semi-axis is not positive\");\n    this._A3x = new Array(nA3x_);\n    this._C3x = new Array(nC3x_);\n    this._C4x = new Array(nC4x_);\n    this.A3coeff();\n    this.C3coeff();\n    this.C4coeff();\n  };\n\n  A3_coeff = [\n    // A3, coeff of eps^5, polynomial in n of order 0\n      -3, 128,\n    // A3, coeff of eps^4, polynomial in n of order 1\n      -2, -3, 64,\n    // A3, coeff of eps^3, polynomial in n of order 2\n      -1, -3, -1, 16,\n    // A3, coeff of eps^2, polynomial in n of order 2\n      +3, -1, -2, 8,\n    // A3, coeff of eps^1, polynomial in n of order 1\n      +1, -1, 2,\n    // A3, coeff of eps^0, polynomial in n of order 0\n      +1, 1\n  ];\n\n  // The scale factor A3 = mean value of (d/dsigma)I3\n  g.Geodesic.prototype.A3coeff = function() {\n    var o = 0, k = 0,\n        j, p;\n    for (j = nA3_ - 1; j >= 0; --j) { // coeff of eps^j\n      p = Math.min(nA3_ - j - 1, j);  // order of polynomial in n\n      this._A3x[k++] = m.polyval(p, A3_coeff, o, this._n) /\n        A3_coeff[o + p + 1];\n      o += p + 2;\n    }\n  };\n\n  C3_coeff = [\n    // C3[1], coeff of eps^5, polynomial in n of order 0\n      +3, 128,\n    // C3[1], coeff of eps^4, polynomial in n of order 1\n      +2, 5, 128,\n    // C3[1], coeff of eps^3, polynomial in n of order 2\n      -1, 3, 3, 64,\n    // C3[1], coeff of eps^2, polynomial in n of order 2\n      -1, 0, 1, 8,\n    // C3[1], coeff of eps^1, polynomial in n of order 1\n      -1, 1, 4,\n    // C3[2], coeff of eps^5, polynomial in n of order 0\n      +5, 256,\n    // C3[2], coeff of eps^4, polynomial in n of order 1\n      +1, 3, 128,\n    // C3[2], coeff of eps^3, polynomial in n of order 2\n      -3, -2, 3, 64,\n    // C3[2], coeff of eps^2, polynomial in n of order 2\n      +1, -3, 2, 32,\n    // C3[3], coeff of eps^5, polynomial in n of order 0\n      +7, 512,\n    // C3[3], coeff of eps^4, polynomial in n of order 1\n      -10, 9, 384,\n    // C3[3], coeff of eps^3, polynomial in n of order 2\n      +5, -9, 5, 192,\n    // C3[4], coeff of eps^5, polynomial in n of order 0\n      +7, 512,\n    // C3[4], coeff of eps^4, polynomial in n of order 1\n      -14, 7, 512,\n    // C3[5], coeff of eps^5, polynomial in n of order 0\n      +21, 2560\n  ];\n\n  // The coefficients C3[l] in the Fourier expansion of B3\n  g.Geodesic.prototype.C3coeff = function() {\n    var o = 0, k = 0,\n        l, j, p;\n    for (l = 1; l < g.nC3_; ++l) {        // l is index of C3[l]\n      for (j = g.nC3_ - 1; j >= l; --j) { // coeff of eps^j\n        p = Math.min(g.nC3_ - j - 1, j);  // order of polynomial in n\n        this._C3x[k++] = m.polyval(p, C3_coeff, o, this._n) /\n          C3_coeff[o + p + 1];\n        o += p + 2;\n      }\n    }\n  };\n\n  C4_coeff = [\n    // C4[0], coeff of eps^5, polynomial in n of order 0\n      +97, 15015,\n    // C4[0], coeff of eps^4, polynomial in n of order 1\n      +1088, 156, 45045,\n    // C4[0], coeff of eps^3, polynomial in n of order 2\n      -224, -4784, 1573, 45045,\n    // C4[0], coeff of eps^2, polynomial in n of order 3\n      -10656, 14144, -4576, -858, 45045,\n    // C4[0], coeff of eps^1, polynomial in n of order 4\n      +64, 624, -4576, 6864, -3003, 15015,\n    // C4[0], coeff of eps^0, polynomial in n of order 5\n      +100, 208, 572, 3432, -12012, 30030, 45045,\n    // C4[1], coeff of eps^5, polynomial in n of order 0\n      +1, 9009,\n    // C4[1], coeff of eps^4, polynomial in n of order 1\n      -2944, 468, 135135,\n    // C4[1], coeff of eps^3, polynomial in n of order 2\n      +5792, 1040, -1287, 135135,\n    // C4[1], coeff of eps^2, polynomial in n of order 3\n      +5952, -11648, 9152, -2574, 135135,\n    // C4[1], coeff of eps^1, polynomial in n of order 4\n      -64, -624, 4576, -6864, 3003, 135135,\n    // C4[2], coeff of eps^5, polynomial in n of order 0\n      +8, 10725,\n    // C4[2], coeff of eps^4, polynomial in n of order 1\n      +1856, -936, 225225,\n    // C4[2], coeff of eps^3, polynomial in n of order 2\n      -8448, 4992, -1144, 225225,\n    // C4[2], coeff of eps^2, polynomial in n of order 3\n      -1440, 4160, -4576, 1716, 225225,\n    // C4[3], coeff of eps^5, polynomial in n of order 0\n      -136, 63063,\n    // C4[3], coeff of eps^4, polynomial in n of order 1\n      +1024, -208, 105105,\n    // C4[3], coeff of eps^3, polynomial in n of order 2\n      +3584, -3328, 1144, 315315,\n    // C4[4], coeff of eps^5, polynomial in n of order 0\n      -128, 135135,\n    // C4[4], coeff of eps^4, polynomial in n of order 1\n      -2560, 832, 405405,\n    // C4[5], coeff of eps^5, polynomial in n of order 0\n      +128, 99099\n  ];\n\n  g.Geodesic.prototype.C4coeff = function() {\n    var o = 0, k = 0,\n        l, j, p;\n    for (l = 0; l < g.nC4_; ++l) {        // l is index of C4[l]\n      for (j = g.nC4_ - 1; j >= l; --j) { // coeff of eps^j\n        p = g.nC4_ - j - 1;               // order of polynomial in n\n        this._C4x[k++] = m.polyval(p, C4_coeff, o, this._n) /\n          C4_coeff[o + p + 1];\n        o += p + 2;\n      }\n    }\n  };\n\n  g.Geodesic.prototype.A3f = function(eps) {\n    // Evaluate A3\n    return m.polyval(nA3x_ - 1, this._A3x, 0, eps);\n  };\n\n  g.Geodesic.prototype.C3f = function(eps, c) {\n    // Evaluate C3 coeffs\n    // Elements c[1] thru c[nC3_ - 1] are set\n    var mult = 1,\n        o = 0,\n        l, p;\n    for (l = 1; l < g.nC3_; ++l) { // l is index of C3[l]\n      p = g.nC3_ - l - 1;          // order of polynomial in eps\n      mult *= eps;\n      c[l] = mult * m.polyval(p, this._C3x, o, eps);\n      o += p + 1;\n    }\n  };\n\n  g.Geodesic.prototype.C4f = function(eps, c) {\n    // Evaluate C4 coeffs\n    // Elements c[0] thru c[g.nC4_ - 1] are set\n    var mult = 1,\n        o = 0,\n        l, p;\n    for (l = 0; l < g.nC4_; ++l) { // l is index of C4[l]\n      p = g.nC4_ - l - 1;          // order of polynomial in eps\n      c[l] = mult * m.polyval(p, this._C4x, o, eps);\n      o += p + 1;\n      mult *= eps;\n    }\n  };\n\n  // return s12b, m12b, m0, M12, M21\n  g.Geodesic.prototype.Lengths = function(eps, sig12,\n                                          ssig1, csig1, dn1, ssig2, csig2, dn2,\n                                          cbet1, cbet2, outmask,\n                                          C1a, C2a) {\n    // Return m12b = (reduced length)/_b; also calculate s12b =\n    // distance/_b, and m0 = coefficient of secular term in\n    // expression for reduced length.\n    outmask &= g.OUT_MASK;\n    var vals = {},\n        m0x = 0, J12 = 0, A1 = 0, A2 = 0,\n        B1, B2, l, csig12, t;\n    if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n      A1 = g.A1m1f(eps);\n      g.C1f(eps, C1a);\n      if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n        A2 = g.A2m1f(eps);\n        g.C2f(eps, C2a);\n        m0x = A1 - A2;\n        A2 = 1 + A2;\n      }\n      A1 = 1 + A1;\n    }\n    if (outmask & g.DISTANCE) {\n      B1 = g.SinCosSeries(true, ssig2, csig2, C1a) -\n        g.SinCosSeries(true, ssig1, csig1, C1a);\n      // Missing a factor of _b\n      vals.s12b = A1 * (sig12 + B1);\n      if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n        B2 = g.SinCosSeries(true, ssig2, csig2, C2a) -\n          g.SinCosSeries(true, ssig1, csig1, C2a);\n        J12 = m0x * sig12 + (A1 * B1 - A2 * B2);\n      }\n    } else if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n      // Assume here that nC1_ >= nC2_\n      for (l = 1; l <= g.nC2_; ++l)\n        C2a[l] = A1 * C1a[l] - A2 * C2a[l];\n      J12 = m0x * sig12 + (g.SinCosSeries(true, ssig2, csig2, C2a) -\n                           g.SinCosSeries(true, ssig1, csig1, C2a));\n    }\n    if (outmask & g.REDUCEDLENGTH) {\n      vals.m0 = m0x;\n      // Missing a factor of _b.\n      // Add parens around (csig1 * ssig2) and (ssig1 * csig2) to ensure\n      // accurate cancellation in the case of coincident points.\n      vals.m12b = dn2 * (csig1 * ssig2) - dn1 * (ssig1 * csig2) -\n        csig1 * csig2 * J12;\n    }\n    if (outmask & g.GEODESICSCALE) {\n      csig12 = csig1 * csig2 + ssig1 * ssig2;\n      t = this._ep2 * (cbet1 - cbet2) * (cbet1 + cbet2) / (dn1 + dn2);\n      vals.M12 = csig12 + (t * ssig2 - csig2 * J12) * ssig1 / dn1;\n      vals.M21 = csig12 - (t * ssig1 - csig1 * J12) * ssig2 / dn2;\n    }\n    return vals;\n  };\n\n  // return sig12, salp1, calp1, salp2, calp2, dnm\n  g.Geodesic.prototype.InverseStart = function(sbet1, cbet1, dn1,\n                                               sbet2, cbet2, dn2,\n                                               lam12, slam12, clam12,\n                                               C1a, C2a) {\n    // Return a starting point for Newton's method in salp1 and calp1\n    // (function value is -1).  If Newton's method doesn't need to be\n    // used, return also salp2 and calp2 and function value is sig12.\n    // salp2, calp2 only updated if return val >= 0.\n    var vals = {},\n        // bet12 = bet2 - bet1 in [0, pi); bet12a = bet2 + bet1 in (-pi, 0]\n        sbet12 = sbet2 * cbet1 - cbet2 * sbet1,\n        cbet12 = cbet2 * cbet1 + sbet2 * sbet1,\n        sbet12a, shortline, omg12, sbetm2, somg12, comg12, t, ssig12, csig12,\n        x, y, lamscale, betscale, k2, eps, cbet12a, bet12a, m12b, m0, nvals,\n        k, omg12a, lam12x;\n    vals.sig12 = -1;        // Return value\n    // Volatile declaration needed to fix inverse cases\n    // 88.202499451857 0 -88.202499451857 179.981022032992859592\n    // 89.262080389218 0 -89.262080389218 179.992207982775375662\n    // 89.333123580033 0 -89.333123580032997687 179.99295812360148422\n    // which otherwise fail with g++ 4.4.4 x86 -O3\n    sbet12a = sbet2 * cbet1;\n    sbet12a += cbet2 * sbet1;\n\n    shortline = cbet12 >= 0 && sbet12 < 0.5 && cbet2 * lam12 < 0.5;\n    if (shortline) {\n      sbetm2 = m.sq(sbet1 + sbet2);\n      // sin((bet1+bet2)/2)^2\n      // =  (sbet1 + sbet2)^2 / ((sbet1 + sbet2)^2 + (cbet1 + cbet2)^2)\n      sbetm2 /= sbetm2 + m.sq(cbet1 + cbet2);\n      vals.dnm = Math.sqrt(1 + this._ep2 * sbetm2);\n      omg12 = lam12 / (this._f1 * vals.dnm);\n      somg12 = Math.sin(omg12); comg12 = Math.cos(omg12);\n    } else {\n      somg12 = slam12; comg12 = clam12;\n    }\n\n    vals.salp1 = cbet2 * somg12;\n    vals.calp1 = comg12 >= 0 ?\n      sbet12 + cbet2 * sbet1 * m.sq(somg12) / (1 + comg12) :\n      sbet12a - cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);\n\n    ssig12 = m.hypot(vals.salp1, vals.calp1);\n    csig12 = sbet1 * sbet2 + cbet1 * cbet2 * comg12;\n    if (shortline && ssig12 < this._etol2) {\n      // really short lines\n      vals.salp2 = cbet1 * somg12;\n      vals.calp2 = sbet12 - cbet1 * sbet2 *\n        (comg12 >= 0 ? m.sq(somg12) / (1 + comg12) : 1 - comg12);\n      // norm(vals.salp2, vals.calp2);\n      t = m.hypot(vals.salp2, vals.calp2); vals.salp2 /= t; vals.calp2 /= t;\n      // Set return value\n      vals.sig12 = Math.atan2(ssig12, csig12);\n    } else if (Math.abs(this._n) > 0.1 || // Skip astroid calc if too eccentric\n               csig12 >= 0 ||\n               ssig12 >= 6 * Math.abs(this._n) * Math.PI * m.sq(cbet1)) {\n      // Nothing to do, zeroth order spherical approximation is OK\n    } else {\n      // Scale lam12 and bet2 to x, y coordinate system where antipodal\n      // point is at origin and singular point is at y = 0, x = -1.\n      lam12x = Math.atan2(-slam12, -clam12); // lam12 - pi\n      if (this.f >= 0) {       // In fact f == 0 does not get here\n        // x = dlong, y = dlat\n        k2 = m.sq(sbet1) * this._ep2;\n        eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);\n        lamscale = this.f * cbet1 * this.A3f(eps) * Math.PI;\n        betscale = lamscale * cbet1;\n\n        x = lam12x / lamscale;\n        y = sbet12a / betscale;\n      } else {                  // f < 0\n        // x = dlat, y = dlong\n        cbet12a = cbet2 * cbet1 - sbet2 * sbet1;\n        bet12a = Math.atan2(sbet12a, cbet12a);\n        // In the case of lon12 = 180, this repeats a calculation made\n        // in Inverse.\n        nvals = this.Lengths(this._n, Math.PI + bet12a,\n                             sbet1, -cbet1, dn1, sbet2, cbet2, dn2,\n                             cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);\n        m12b = nvals.m12b; m0 = nvals.m0;\n        x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);\n        betscale = x < -0.01 ? sbet12a / x :\n          -this.f * m.sq(cbet1) * Math.PI;\n        lamscale = betscale / cbet1;\n        y = lam12 / lamscale;\n      }\n\n      if (y > -tol1_ && x > -1 - xthresh_) {\n        // strip near cut\n        if (this.f >= 0) {\n          vals.salp1 = Math.min(1, -x);\n          vals.calp1 = -Math.sqrt(1 - m.sq(vals.salp1));\n        } else {\n          vals.calp1 = Math.max(x > -tol1_ ? 0 : -1, x);\n          vals.salp1 = Math.sqrt(1 - m.sq(vals.calp1));\n        }\n      } else {\n        // Estimate alp1, by solving the astroid problem.\n        //\n        // Could estimate alpha1 = theta + pi/2, directly, i.e.,\n        //   calp1 = y/k; salp1 = -x/(1+k);  for f >= 0\n        //   calp1 = x/(1+k); salp1 = -y/k;  for f < 0 (need to check)\n        //\n        // However, it's better to estimate omg12 from astroid and use\n        // spherical formula to compute alp1.  This reduces the mean number of\n        // Newton iterations for astroid cases from 2.24 (min 0, max 6) to 2.12\n        // (min 0 max 5).  The changes in the number of iterations are as\n        // follows:\n        //\n        // change percent\n        //    1       5\n        //    0      78\n        //   -1      16\n        //   -2       0.6\n        //   -3       0.04\n        //   -4       0.002\n        //\n        // The histogram of iterations is (m = number of iterations estimating\n        // alp1 directly, n = number of iterations estimating via omg12, total\n        // number of trials = 148605):\n        //\n        //  iter    m      n\n        //    0   148    186\n        //    1 13046  13845\n        //    2 93315 102225\n        //    3 36189  32341\n        //    4  5396      7\n        //    5   455      1\n        //    6    56      0\n        //\n        // Because omg12 is near pi, estimate work with omg12a = pi - omg12\n        k = astroid(x, y);\n        omg12a = lamscale * ( this.f >= 0 ? -x * k/(1 + k) : -y * (1 + k)/k );\n        somg12 = Math.sin(omg12a); comg12 = -Math.cos(omg12a);\n        // Update spherical estimate of alp1 using omg12 instead of\n        // lam12\n        vals.salp1 = cbet2 * somg12;\n        vals.calp1 = sbet12a -\n          cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);\n      }\n    }\n    // Sanity check on starting guess.  Backwards check allows NaN through.\n    if (!(vals.salp1 <= 0.0)) {\n      // norm(vals.salp1, vals.calp1);\n      t = m.hypot(vals.salp1, vals.calp1); vals.salp1 /= t; vals.calp1 /= t;\n    } else {\n      vals.salp1 = 1; vals.calp1 = 0;\n    }\n    return vals;\n  };\n\n  // return lam12, salp2, calp2, sig12, ssig1, csig1, ssig2, csig2, eps,\n  // domg12, dlam12,\n  g.Geodesic.prototype.Lambda12 = function(sbet1, cbet1, dn1,\n                                           sbet2, cbet2, dn2,\n                                           salp1, calp1, slam120, clam120,\n                                           diffp, C1a, C2a, C3a) {\n    var vals = {},\n        t, salp0, calp0,\n        somg1, comg1, somg2, comg2, somg12, comg12, B312, eta, k2, nvals;\n    if (sbet1 === 0 && calp1 === 0)\n      // Break degeneracy of equatorial line.  This case has already been\n      // handled.\n      calp1 = -g.tiny_;\n\n    // sin(alp1) * cos(bet1) = sin(alp0)\n    salp0 = salp1 * cbet1;\n    calp0 = m.hypot(calp1, salp1 * sbet1); // calp0 > 0\n\n    // tan(bet1) = tan(sig1) * cos(alp1)\n    // tan(omg1) = sin(alp0) * tan(sig1) = tan(omg1)=tan(alp1)*sin(bet1)\n    vals.ssig1 = sbet1; somg1 = salp0 * sbet1;\n    vals.csig1 = comg1 = calp1 * cbet1;\n    // norm(vals.ssig1, vals.csig1);\n    t = m.hypot(vals.ssig1, vals.csig1); vals.ssig1 /= t; vals.csig1 /= t;\n    // norm(somg1, comg1); -- don't need to normalize!\n\n    // Enforce symmetries in the case abs(bet2) = -bet1.  Need to be careful\n    // about this case, since this can yield singularities in the Newton\n    // iteration.\n    // sin(alp2) * cos(bet2) = sin(alp0)\n    vals.salp2 = cbet2 !== cbet1 ? salp0 / cbet2 : salp1;\n    // calp2 = sqrt(1 - sq(salp2))\n    //       = sqrt(sq(calp0) - sq(sbet2)) / cbet2\n    // and subst for calp0 and rearrange to give (choose positive sqrt\n    // to give alp2 in [0, pi/2]).\n    vals.calp2 = cbet2 !== cbet1 || Math.abs(sbet2) !== -sbet1 ?\n      Math.sqrt(m.sq(calp1 * cbet1) + (cbet1 < -sbet1 ?\n                                       (cbet2 - cbet1) * (cbet1 + cbet2) :\n                                       (sbet1 - sbet2) * (sbet1 + sbet2))) /\n      cbet2 : Math.abs(calp1);\n    // tan(bet2) = tan(sig2) * cos(alp2)\n    // tan(omg2) = sin(alp0) * tan(sig2).\n    vals.ssig2 = sbet2; somg2 = salp0 * sbet2;\n    vals.csig2 = comg2 = vals.calp2 * cbet2;\n    // norm(vals.ssig2, vals.csig2);\n    t = m.hypot(vals.ssig2, vals.csig2); vals.ssig2 /= t; vals.csig2 /= t;\n    // norm(somg2, comg2); -- don't need to normalize!\n\n    // sig12 = sig2 - sig1, limit to [0, pi]\n    vals.sig12 = Math.atan2(Math.max(0, vals.csig1 * vals.ssig2 -\n                                        vals.ssig1 * vals.csig2),\n                                        vals.csig1 * vals.csig2 +\n                                        vals.ssig1 * vals.ssig2);\n\n    // omg12 = omg2 - omg1, limit to [0, pi]\n    somg12 = Math.max(0, comg1 * somg2 - somg1 * comg2);\n    comg12 =             comg1 * comg2 + somg1 * somg2;\n    // eta = omg12 - lam120\n    eta = Math.atan2(somg12 * clam120 - comg12 * slam120,\n                     comg12 * clam120 + somg12 * slam120);\n    k2 = m.sq(calp0) * this._ep2;\n    vals.eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);\n    this.C3f(vals.eps, C3a);\n    B312 = (g.SinCosSeries(true, vals.ssig2, vals.csig2, C3a) -\n            g.SinCosSeries(true, vals.ssig1, vals.csig1, C3a));\n    vals.domg12 =  -this.f * this.A3f(vals.eps) * salp0 * (vals.sig12 + B312);\n    vals.lam12 = eta + vals.domg12;\n    if (diffp) {\n      if (vals.calp2 === 0)\n        vals.dlam12 = -2 * this._f1 * dn1 / sbet1;\n      else {\n        nvals = this.Lengths(vals.eps, vals.sig12,\n                             vals.ssig1, vals.csig1, dn1,\n                             vals.ssig2, vals.csig2, dn2,\n                             cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);\n        vals.dlam12 = nvals.m12b;\n        vals.dlam12 *= this._f1 / (vals.calp2 * cbet2);\n      }\n    }\n    return vals;\n  };\n\n  /**\n   * @summary Solve the inverse geodesic problem.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} lat2 the latitude of the second point in degrees.\n   * @param {number} lon2 the longitude of the second point in degrees.\n   * @param {bitmask} [outmask = STANDARD] which results to include.\n   * @returns {object} the requested results\n   * @description The lat1, lon1, lat2, lon2, and a12 fields of the result are\n   *   always set.  For details on the outmask parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  g.Geodesic.prototype.Inverse = function(lat1, lon1, lat2, lon2, outmask) {\n    var r, vals;\n    if (!outmask) outmask = g.STANDARD;\n    if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;\n    outmask &= g.OUT_MASK;\n    r = this.InverseInt(lat1, lon1, lat2, lon2, outmask);\n    vals = r.vals;\n    if (outmask & g.AZIMUTH) {\n      vals.azi1 = m.atan2d(r.salp1, r.calp1);\n      vals.azi2 = m.atan2d(r.salp2, r.calp2);\n    }\n    return vals;\n  };\n\n  g.Geodesic.prototype.InverseInt = function(lat1, lon1, lat2, lon2, outmask) {\n    var vals = {},\n        lon12, lon12s, lonsign, t, swapp, latsign,\n        sbet1, cbet1, sbet2, cbet2, s12x, m12x,\n        dn1, dn2, lam12, slam12, clam12,\n        sig12, calp1, salp1, calp2, salp2, C1a, C2a, C3a, meridian, nvals,\n        ssig1, csig1, ssig2, csig2, eps, omg12, dnm,\n        numit, salp1a, calp1a, salp1b, calp1b,\n        tripn, tripb, v, dv, dalp1, sdalp1, cdalp1, nsalp1,\n        lengthmask, salp0, calp0, alp12, k2, A4, C4a, B41, B42,\n        somg12, comg12, domg12, dbet1, dbet2, salp12, calp12, sdomg12, cdomg12;\n    // Compute longitude difference (AngDiff does this carefully).  Result is\n    // in [-180, 180] but -180 is only for west-going geodesics.  180 is for\n    // east-going and meridional geodesics.\n    vals.lat1 = lat1 = m.LatFix(lat1); vals.lat2 = lat2 = m.LatFix(lat2);\n    // If really close to the equator, treat as on equator.\n    lat1 = m.AngRound(lat1);\n    lat2 = m.AngRound(lat2);\n    lon12 = m.AngDiff(lon1, lon2); lon12s = lon12.t; lon12 = lon12.s;\n    if (outmask & g.LONG_UNROLL) {\n      vals.lon1 = lon1; vals.lon2 = (lon1 + lon12) + lon12s;\n    } else {\n      vals.lon1 = m.AngNormalize(lon1); vals.lon2 = m.AngNormalize(lon2);\n    }\n    // Make longitude difference positive.\n    lonsign = lon12 >= 0 ? 1 : -1;\n    // If very close to being on the same half-meridian, then make it so.\n    lon12 = lonsign * m.AngRound(lon12);\n    lon12s = m.AngRound((180 - lon12) - lonsign * lon12s);\n    lam12 = lon12 * m.degree;\n    t = m.sincosd(lon12 > 90 ? lon12s : lon12);\n    slam12 = t.s; clam12 = (lon12 > 90 ? -1 : 1) * t.c;\n\n    // Swap points so that point with higher (abs) latitude is point 1\n    // If one latitude is a nan, then it becomes lat1.\n    swapp = Math.abs(lat1) < Math.abs(lat2) ? -1 : 1;\n    if (swapp < 0) {\n      lonsign *= -1;\n      t = lat1;\n      lat1 = lat2;\n      lat2 = t;\n      // swap(lat1, lat2);\n    }\n    // Make lat1 <= 0\n    latsign = lat1 < 0 ? 1 : -1;\n    lat1 *= latsign;\n    lat2 *= latsign;\n    // Now we have\n    //\n    //     0 <= lon12 <= 180\n    //     -90 <= lat1 <= 0\n    //     lat1 <= lat2 <= -lat1\n    //\n    // longsign, swapp, latsign register the transformation to bring the\n    // coordinates to this canonical form.  In all cases, 1 means no change was\n    // made.  We make these transformations so that there are few cases to\n    // check, e.g., on verifying quadrants in atan2.  In addition, this\n    // enforces some symmetries in the results returned.\n\n    t = m.sincosd(lat1); sbet1 = this._f1 * t.s; cbet1 = t.c;\n    // norm(sbet1, cbet1);\n    t = m.hypot(sbet1, cbet1); sbet1 /= t; cbet1 /= t;\n    // Ensure cbet1 = +epsilon at poles\n    cbet1 = Math.max(g.tiny_, cbet1);\n\n    t = m.sincosd(lat2); sbet2 = this._f1 * t.s; cbet2 = t.c;\n    // norm(sbet2, cbet2);\n    t = m.hypot(sbet2, cbet2); sbet2 /= t; cbet2 /= t;\n    // Ensure cbet2 = +epsilon at poles\n    cbet2 = Math.max(g.tiny_, cbet2);\n\n    // If cbet1 < -sbet1, then cbet2 - cbet1 is a sensitive measure of the\n    // |bet1| - |bet2|.  Alternatively (cbet1 >= -sbet1), abs(sbet2) + sbet1 is\n    // a better measure.  This logic is used in assigning calp2 in Lambda12.\n    // Sometimes these quantities vanish and in that case we force bet2 = +/-\n    // bet1 exactly.  An example where is is necessary is the inverse problem\n    // 48.522876735459 0 -48.52287673545898293 179.599720456223079643\n    // which failed with Visual Studio 10 (Release and Debug)\n\n    if (cbet1 < -sbet1) {\n      if (cbet2 === cbet1)\n        sbet2 = sbet2 < 0 ? sbet1 : -sbet1;\n    } else {\n      if (Math.abs(sbet2) === -sbet1)\n        cbet2 = cbet1;\n    }\n\n    dn1 = Math.sqrt(1 + this._ep2 * m.sq(sbet1));\n    dn2 = Math.sqrt(1 + this._ep2 * m.sq(sbet2));\n\n    // index zero elements of these arrays are unused\n    C1a = new Array(g.nC1_ + 1);\n    C2a = new Array(g.nC2_ + 1);\n    C3a = new Array(g.nC3_);\n\n    meridian = lat1 === -90 || slam12 === 0;\n    if (meridian) {\n\n      // Endpoints are on a single full meridian, so the geodesic might\n      // lie on a meridian.\n\n      calp1 = clam12; salp1 = slam12; // Head to the target longitude\n      calp2 = 1; salp2 = 0;           // At the target we're heading north\n\n      // tan(bet) = tan(sig) * cos(alp)\n      ssig1 = sbet1; csig1 = calp1 * cbet1;\n      ssig2 = sbet2; csig2 = calp2 * cbet2;\n\n      // sig12 = sig2 - sig1\n      sig12 = Math.atan2(Math.max(0, csig1 * ssig2 - ssig1 * csig2),\n                                     csig1 * csig2 + ssig1 * ssig2);\n      nvals = this.Lengths(this._n, sig12,\n                           ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2,\n                           outmask | g.DISTANCE | g.REDUCEDLENGTH,\n                           C1a, C2a);\n      s12x = nvals.s12b;\n      m12x = nvals.m12b;\n      // Ignore m0\n      if (outmask & g.GEODESICSCALE) {\n        vals.M12 = nvals.M12;\n        vals.M21 = nvals.M21;\n      }\n      // Add the check for sig12 since zero length geodesics might yield\n      // m12 < 0.  Test case was\n      //\n      //    echo 20.001 0 20.001 0 | GeodSolve -i\n      //\n      // In fact, we will have sig12 > pi/2 for meridional geodesic\n      // which is not a shortest path.\n      if (sig12 < 1 || m12x >= 0) {\n        // Need at least 2, to handle 90 0 90 180\n        if (sig12 < 3 * g.tiny_)\n          sig12 = m12x = s12x = 0;\n        m12x *= this._b;\n        s12x *= this._b;\n        vals.a12 = sig12 / m.degree;\n      } else\n        // m12 < 0, i.e., prolate and too close to anti-podal\n        meridian = false;\n    }\n\n    somg12 = 2;\n    if (!meridian &&\n        sbet1 === 0 &&           // and sbet2 == 0\n        (this.f <= 0 || lon12s >= this.f * 180)) {\n\n      // Geodesic runs along equator\n      calp1 = calp2 = 0; salp1 = salp2 = 1;\n      s12x = this.a * lam12;\n      sig12 = omg12 = lam12 / this._f1;\n      m12x = this._b * Math.sin(sig12);\n      if (outmask & g.GEODESICSCALE)\n        vals.M12 = vals.M21 = Math.cos(sig12);\n      vals.a12 = lon12 / this._f1;\n\n    } else if (!meridian) {\n\n      // Now point1 and point2 belong within a hemisphere bounded by a\n      // meridian and geodesic is neither meridional or equatorial.\n\n      // Figure a starting point for Newton's method\n      nvals = this.InverseStart(sbet1, cbet1, dn1, sbet2, cbet2, dn2,\n                                lam12, slam12, clam12, C1a, C2a);\n      sig12 = nvals.sig12;\n      salp1 = nvals.salp1;\n      calp1 = nvals.calp1;\n\n      if (sig12 >= 0) {\n        salp2 = nvals.salp2;\n        calp2 = nvals.calp2;\n        // Short lines (InverseStart sets salp2, calp2, dnm)\n\n        dnm = nvals.dnm;\n        s12x = sig12 * this._b * dnm;\n        m12x = m.sq(dnm) * this._b * Math.sin(sig12 / dnm);\n        if (outmask & g.GEODESICSCALE)\n          vals.M12 = vals.M21 = Math.cos(sig12 / dnm);\n        vals.a12 = sig12 / m.degree;\n        omg12 = lam12 / (this._f1 * dnm);\n      } else {\n\n        // Newton's method.  This is a straightforward solution of f(alp1) =\n        // lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one\n        // root in the interval (0, pi) and its derivative is positive at the\n        // root.  Thus f(alp) is positive for alp > alp1 and negative for alp <\n        // alp1.  During the course of the iteration, a range (alp1a, alp1b) is\n        // maintained which brackets the root and with each evaluation of\n        // f(alp) the range is shrunk if possible.  Newton's method is\n        // restarted whenever the derivative of f is negative (because the new\n        // value of alp1 is then further from the solution) or if the new\n        // estimate of alp1 lies outside (0,pi); in this case, the new starting\n        // guess is taken to be (alp1a + alp1b) / 2.\n        numit = 0;\n        // Bracketing range\n        salp1a = g.tiny_; calp1a = 1; salp1b = g.tiny_; calp1b = -1;\n        for (tripn = false, tripb = false; numit < maxit2_; ++numit) {\n          // the WGS84 test set: mean = 1.47, sd = 1.25, max = 16\n          // WGS84 and random input: mean = 2.85, sd = 0.60\n          nvals = this.Lambda12(sbet1, cbet1, dn1, sbet2, cbet2, dn2,\n                                salp1, calp1, slam12, clam12, numit < maxit1_,\n                                C1a, C2a, C3a);\n          v = nvals.lam12;\n          salp2 = nvals.salp2;\n          calp2 = nvals.calp2;\n          sig12 = nvals.sig12;\n          ssig1 = nvals.ssig1;\n          csig1 = nvals.csig1;\n          ssig2 = nvals.ssig2;\n          csig2 = nvals.csig2;\n          eps = nvals.eps;\n          domg12 = nvals.domg12;\n          dv = nvals.dlam12;\n\n          // 2 * tol0 is approximately 1 ulp for a number in [0, pi].\n          // Reversed test to allow escape with NaNs\n          if (tripb || !(Math.abs(v) >= (tripn ? 8 : 1) * tol0_))\n            break;\n          // Update bracketing values\n          if (v > 0 && (numit < maxit1_ || calp1/salp1 > calp1b/salp1b)) {\n            salp1b = salp1; calp1b = calp1;\n          } else if (v < 0 &&\n                     (numit < maxit1_ || calp1/salp1 < calp1a/salp1a)) {\n            salp1a = salp1; calp1a = calp1;\n          }\n          if (numit < maxit1_ && dv > 0) {\n            dalp1 = -v/dv;\n            sdalp1 = Math.sin(dalp1); cdalp1 = Math.cos(dalp1);\n            nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;\n            if (nsalp1 > 0 && Math.abs(dalp1) < Math.PI) {\n              calp1 = calp1 * cdalp1 - salp1 * sdalp1;\n              salp1 = nsalp1;\n              // norm(salp1, calp1);\n              t = m.hypot(salp1, calp1); salp1 /= t; calp1 /= t;\n              // In some regimes we don't get quadratic convergence because\n              // slope -> 0.  So use convergence conditions based on epsilon\n              // instead of sqrt(epsilon).\n              tripn = Math.abs(v) <= 16 * tol0_;\n              continue;\n            }\n          }\n          // Either dv was not positive or updated value was outside legal\n          // range.  Use the midpoint of the bracket as the next estimate.\n          // This mechanism is not needed for the WGS84 ellipsoid, but it does\n          // catch problems with more eccentric ellipsoids.  Its efficacy is\n          // such for the WGS84 test set with the starting guess set to alp1 =\n          // 90deg:\n          // the WGS84 test set: mean = 5.21, sd = 3.93, max = 24\n          // WGS84 and random input: mean = 4.74, sd = 0.99\n          salp1 = (salp1a + salp1b)/2;\n          calp1 = (calp1a + calp1b)/2;\n          // norm(salp1, calp1);\n          t = m.hypot(salp1, calp1); salp1 /= t; calp1 /= t;\n          tripn = false;\n          tripb = (Math.abs(salp1a - salp1) + (calp1a - calp1) < tolb_ ||\n                   Math.abs(salp1 - salp1b) + (calp1 - calp1b) < tolb_);\n        }\n        lengthmask = outmask |\n            (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE) ?\n             g.DISTANCE : g.NONE);\n        nvals = this.Lengths(eps, sig12,\n                             ssig1, csig1, dn1, ssig2, csig2, dn2,\n                             cbet1, cbet2,\n                             lengthmask, C1a, C2a);\n        s12x = nvals.s12b;\n        m12x = nvals.m12b;\n        // Ignore m0\n        if (outmask & g.GEODESICSCALE) {\n          vals.M12 = nvals.M12;\n          vals.M21 = nvals.M21;\n        }\n        m12x *= this._b;\n        s12x *= this._b;\n        vals.a12 = sig12 / m.degree;\n        if (outmask & g.AREA) {\n          // omg12 = lam12 - domg12\n          sdomg12 = Math.sin(domg12); cdomg12 = Math.cos(domg12);\n          somg12 = slam12 * cdomg12 - clam12 * sdomg12;\n          comg12 = clam12 * cdomg12 + slam12 * sdomg12;\n        }\n      }\n    }\n\n    if (outmask & g.DISTANCE)\n      vals.s12 = 0 + s12x;      // Convert -0 to 0\n\n    if (outmask & g.REDUCEDLENGTH)\n      vals.m12 = 0 + m12x;      // Convert -0 to 0\n\n    if (outmask & g.AREA) {\n      // From Lambda12: sin(alp1) * cos(bet1) = sin(alp0)\n      salp0 = salp1 * cbet1;\n      calp0 = m.hypot(calp1, salp1 * sbet1); // calp0 > 0\n      if (calp0 !== 0 && salp0 !== 0) {\n        // From Lambda12: tan(bet) = tan(sig) * cos(alp)\n        ssig1 = sbet1; csig1 = calp1 * cbet1;\n        ssig2 = sbet2; csig2 = calp2 * cbet2;\n        k2 = m.sq(calp0) * this._ep2;\n        eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);\n        // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).\n        A4 = m.sq(this.a) * calp0 * salp0 * this._e2;\n        // norm(ssig1, csig1);\n        t = m.hypot(ssig1, csig1); ssig1 /= t; csig1 /= t;\n        // norm(ssig2, csig2);\n        t = m.hypot(ssig2, csig2); ssig2 /= t; csig2 /= t;\n        C4a = new Array(g.nC4_);\n        this.C4f(eps, C4a);\n        B41 = g.SinCosSeries(false, ssig1, csig1, C4a);\n        B42 = g.SinCosSeries(false, ssig2, csig2, C4a);\n        vals.S12 = A4 * (B42 - B41);\n      } else\n        // Avoid problems with indeterminate sig1, sig2 on equator\n        vals.S12 = 0;\n      if (!meridian && somg12 > 1) {\n        somg12 = Math.sin(omg12); comg12 = Math.cos(omg12);\n      }\n      if (!meridian &&\n          comg12 > -0.7071 &&      // Long difference not too big\n          sbet2 - sbet1 < 1.75) { // Lat difference not too big\n        // Use tan(Gamma/2) = tan(omg12/2)\n        // * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))\n        // with tan(x/2) = sin(x)/(1+cos(x))\n        domg12 = 1 + comg12; dbet1 = 1 + cbet1; dbet2 = 1 + cbet2;\n        alp12 = 2 * Math.atan2( somg12 * (sbet1*dbet2 + sbet2*dbet1),\n                                domg12 * (sbet1*sbet2 + dbet1*dbet2) );\n      } else {\n        // alp12 = alp2 - alp1, used in atan2 so no need to normalize\n        salp12 = salp2 * calp1 - calp2 * salp1;\n        calp12 = calp2 * calp1 + salp2 * salp1;\n        // The right thing appears to happen if alp1 = +/-180 and alp2 = 0, viz\n        // salp12 = -0 and alp12 = -180.  However this depends on the sign\n        // being attached to 0 correctly.  The following ensures the correct\n        // behavior.\n        if (salp12 === 0 && calp12 < 0) {\n          salp12 = g.tiny_ * calp1;\n          calp12 = -1;\n        }\n        alp12 = Math.atan2(salp12, calp12);\n      }\n      vals.S12 += this._c2 * alp12;\n      vals.S12 *= swapp * lonsign * latsign;\n      // Convert -0 to 0\n      vals.S12 += 0;\n    }\n\n    // Convert calp, salp to azimuth accounting for lonsign, swapp, latsign.\n    if (swapp < 0) {\n      t = salp1;\n      salp1 = salp2;\n      salp2 = t;\n      // swap(salp1, salp2);\n      t = calp1;\n      calp1 = calp2;\n      calp2 = t;\n      // swap(calp1, calp2);\n      if (outmask & g.GEODESICSCALE) {\n        t = vals.M12;\n        vals.M12 = vals.M21;\n        vals.M21 = t;\n        // swap(vals.M12, vals.M21);\n      }\n    }\n\n    salp1 *= swapp * lonsign; calp1 *= swapp * latsign;\n    salp2 *= swapp * lonsign; calp2 *= swapp * latsign;\n\n    return {vals: vals,\n            salp1: salp1, calp1: calp1,\n            salp2: salp2, calp2: calp2};\n  };\n\n  /**\n   * @summary Solve the general direct geodesic problem.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   * @param {bool} arcmode is the next parameter an arc length?\n   * @param {number} s12_a12 the (arcmode ? arc length : distance) from the\n   *   first point to the second in (arcmode ? degrees : meters).\n   * @param {bitmask} [outmask = STANDARD] which results to include.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, and a12 fields of the result are always\n   *   set; s12 is included if arcmode is false.  For details on the outmask\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.GenDirect = function(lat1, lon1, azi1,\n                                            arcmode, s12_a12, outmask) {\n    var line;\n    if (!outmask) outmask = g.STANDARD;\n    else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;\n    // Automatically supply DISTANCE_IN if necessary\n    if (!arcmode) outmask |= g.DISTANCE_IN;\n    line = new l.GeodesicLine(this, lat1, lon1, azi1, outmask);\n    return line.GenPosition(arcmode, s12_a12, outmask);\n  };\n\n  /**\n   * @summary Solve the direct geodesic problem.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   * @param {number} s12 the distance from the first point to the second in\n   *   meters.\n   * @param {bitmask} [outmask = STANDARD] which results to include.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, s12, and a12 fields of the result are\n   *   always set.  For details on the outmask parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  g.Geodesic.prototype.Direct = function(lat1, lon1, azi1, s12, outmask) {\n    return this.GenDirect(lat1, lon1, azi1, false, s12, outmask);\n  };\n\n  /**\n   * @summary Solve the direct geodesic problem with arc length.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   * @param {number} a12 the arc length from the first point to the second in\n   *   degrees.\n   * @param {bitmask} [outmask = STANDARD] which results to include.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, and a12 fields of the result are\n   *   always set.  For details on the outmask parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  g.Geodesic.prototype.ArcDirect = function(lat1, lon1, azi1, a12, outmask) {\n    return this.GenDirect(lat1, lon1, azi1, true, a12, outmask);\n  };\n\n  /**\n   * @summary Create a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   *   degrees.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description For details on the caps parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  g.Geodesic.prototype.Line = function(lat1, lon1, azi1, caps) {\n    return new l.GeodesicLine(this, lat1, lon1, azi1, caps);\n  };\n\n  /**\n   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} in terms of the direct geodesic problem specified in terms\n   *   of distance.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   *   degrees.\n   * @param {number} s12 the distance between point 1 and point 2 (meters); it\n   *   can be negative.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description This function sets point 3 of the GeodesicLine to correspond\n   *   to point 2 of the direct geodesic problem.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.DirectLine = function(lat1, lon1, azi1, s12, caps) {\n    return this.GenDirectLine(lat1, lon1, azi1, false, s12, caps);\n  };\n\n  /**\n   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} in terms of the direct geodesic problem specified in terms\n   *   of arc length.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   *   degrees.\n   * @param {number} a12 the arc length between point 1 and point 2 (degrees);\n   *   it can be negative.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description This function sets point 3 of the GeodesicLine to correspond\n   *   to point 2 of the direct geodesic problem.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.ArcDirectLine = function(lat1, lon1, azi1, a12, caps) {\n    return this.GenDirectLine(lat1, lon1, azi1, true, a12, caps);\n  };\n\n  /**\n   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} in terms of the direct geodesic problem specified in terms\n   *   of either distance or arc length.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   *   degrees.\n   * @param {bool} arcmode boolean flag determining the meaning of the\n   *   s12_a12.\n   * @param {number} s12_a12 if arcmode is false, this is the distance between\n   *   point 1 and point 2 (meters); otherwise it is the arc length between\n   *   point 1 and point 2 (degrees); it can be negative.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description This function sets point 3 of the GeodesicLine to correspond\n   *   to point 2 of the direct geodesic problem.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.GenDirectLine = function(lat1, lon1, azi1,\n                                                arcmode, s12_a12, caps) {\n    var t;\n    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;\n    // Automatically supply DISTANCE_IN if necessary\n    if (!arcmode) caps |= g.DISTANCE_IN;\n    t = new l.GeodesicLine(this, lat1, lon1, azi1, caps);\n    t.GenSetDistance(arcmode, s12_a12);\n    return t;\n  };\n\n  /**\n   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} in terms of the inverse geodesic problem.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} lat2 the latitude of the second point in degrees.\n   * @param {number} lon2 the longitude of the second point in degrees.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description This function sets point 3 of the GeodesicLine to correspond\n   *   to point 2 of the inverse geodesic problem.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.InverseLine = function(lat1, lon1, lat2, lon2, caps) {\n    var r, t, azi1;\n    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;\n    r = this.InverseInt(lat1, lon1, lat2, lon2, g.ARC);\n    azi1 = m.atan2d(r.salp1, r.calp1);\n    // Ensure that a12 can be converted to a distance\n    if (caps & (g.OUT_MASK & g.DISTANCE_IN)) caps |= g.DISTANCE;\n    t = new l.GeodesicLine(this, lat1, lon1, azi1, caps, r.salp1, r.calp1);\n    t.SetArc(r.vals.a12);\n    return t;\n  };\n\n  /**\n   * @summary Create a {@link module:GeographicLib/PolygonArea.PolygonArea\n   *   PolygonArea} object.\n   * @param {bool} [polyline = false] if true the new PolygonArea object\n   *   describes a polyline instead of a polygon.\n   * @returns {object} the\n   *   {@link module:GeographicLib/PolygonArea.PolygonArea\n   *   PolygonArea} object\n   */\n  g.Geodesic.prototype.Polygon = function(polyline) {\n    return new p.PolygonArea(this, polyline);\n  };\n\n  /**\n   * @summary a {@link module:GeographicLib/Geodesic.Geodesic Geodesic} object\n   *   initialized for the WGS84 ellipsoid.\n   * @constant {object}\n   */\n  g.WGS84 = new g.Geodesic(c.WGS84.a, c.WGS84.f);\n})(GeographicLib.Geodesic, GeographicLib.GeodesicLine,\n   GeographicLib.PolygonArea, GeographicLib.Math, GeographicLib.Constants);\n\n/**************** GeodesicLine.js ****************/\n/*\n * GeodesicLine.js\n * Transcription of GeodesicLine.[ch]pp into JavaScript.\n *\n * See the documentation for the C++ class.  The conversion is a literal\n * conversion from C++.\n *\n * The algorithms are derived in\n *\n *    Charles F. F. Karney,\n *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);\n *    https://doi.org/10.1007/s00190-012-0578-z\n *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html\n *\n * Copyright (c) Charles Karney (2011-2019) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\n// Load AFTER GeographicLib/Math.js, GeographicLib/Geodesic.js\n\n(function(\n  g,\n  /**\n   * @exports GeographicLib/GeodesicLine\n   * @description Solve geodesic problems on a single geodesic line via the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine GeodesicLine}\n   *   class.\n   */\n  l, m) {\n\n  /**\n   * @class\n   * @property {number} a the equatorial radius (meters).\n   * @property {number} f the flattening.\n   * @property {number} lat1 the initial latitude (degrees).\n   * @property {number} lon1 the initial longitude (degrees).\n   * @property {number} azi1 the initial azimuth (degrees).\n   * @property {number} salp1 the sine of the azimuth at the first point.\n   * @property {number} calp1 the cosine the azimuth at the first point.\n   * @property {number} s13 the distance to point 3 (meters).\n   * @property {number} a13 the arc length to point 3 (degrees).\n   * @property {bitmask} caps the capabilities of the object.\n   * @summary Initialize a GeodesicLine object.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   * @classdesc Performs geodesic calculations along a given geodesic line.\n   *   This object is usually instantiated by\n   *   {@link module:GeographicLib/Geodesic.Geodesic#Line Geodesic.Line}.\n   *   The methods\n   *   {@link module:GeographicLib/Geodesic.Geodesic#DirectLine\n   *   Geodesic.DirectLine} and\n   *   {@link module:GeographicLib/Geodesic.Geodesic#InverseLine\n   *   Geodesic.InverseLine} set in addition the position of a reference point\n   *   3.\n   * @param {object} geod a {@link module:GeographicLib/Geodesic.Geodesic\n   *   Geodesic} object.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include; LATITUDE | AZIMUTH are always included.\n   */\n  l.GeodesicLine = function(geod, lat1, lon1, azi1, caps, salp1, calp1) {\n    var t, cbet1, sbet1, eps, s, c;\n    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;\n\n    this.a = geod.a;\n    this.f = geod.f;\n    this._b = geod._b;\n    this._c2 = geod._c2;\n    this._f1 = geod._f1;\n    this.caps = caps | g.LATITUDE | g.AZIMUTH | g.LONG_UNROLL;\n\n    this.lat1 = m.LatFix(lat1);\n    this.lon1 = lon1;\n    if (typeof salp1 === 'undefined' || typeof calp1 === 'undefined') {\n      this.azi1 = m.AngNormalize(azi1);\n      t = m.sincosd(m.AngRound(this.azi1)); this.salp1 = t.s; this.calp1 = t.c;\n    } else {\n      this.azi1 = azi1; this.salp1 = salp1; this.calp1 = calp1;\n    }\n    t = m.sincosd(m.AngRound(this.lat1)); sbet1 = this._f1 * t.s; cbet1 = t.c;\n    // norm(sbet1, cbet1);\n    t = m.hypot(sbet1, cbet1); sbet1 /= t; cbet1 /= t;\n    // Ensure cbet1 = +epsilon at poles\n    cbet1 = Math.max(g.tiny_, cbet1);\n    this._dn1 = Math.sqrt(1 + geod._ep2 * m.sq(sbet1));\n\n    // Evaluate alp0 from sin(alp1) * cos(bet1) = sin(alp0),\n    this._salp0 = this.salp1 * cbet1; // alp0 in [0, pi/2 - |bet1|]\n    // Alt: calp0 = hypot(sbet1, calp1 * cbet1).  The following\n    // is slightly better (consider the case salp1 = 0).\n    this._calp0 = m.hypot(this.calp1, this.salp1 * sbet1);\n    // Evaluate sig with tan(bet1) = tan(sig1) * cos(alp1).\n    // sig = 0 is nearest northward crossing of equator.\n    // With bet1 = 0, alp1 = pi/2, we have sig1 = 0 (equatorial line).\n    // With bet1 =  pi/2, alp1 = -pi, sig1 =  pi/2\n    // With bet1 = -pi/2, alp1 =  0 , sig1 = -pi/2\n    // Evaluate omg1 with tan(omg1) = sin(alp0) * tan(sig1).\n    // With alp0 in (0, pi/2], quadrants for sig and omg coincide.\n    // No atan2(0,0) ambiguity at poles since cbet1 = +epsilon.\n    // With alp0 = 0, omg1 = 0 for alp1 = 0, omg1 = pi for alp1 = pi.\n    this._ssig1 = sbet1; this._somg1 = this._salp0 * sbet1;\n    this._csig1 = this._comg1 =\n      sbet1 !== 0 || this.calp1 !== 0 ? cbet1 * this.calp1 : 1;\n    // norm(this._ssig1, this._csig1); // sig1 in (-pi, pi]\n    t = m.hypot(this._ssig1, this._csig1);\n    this._ssig1 /= t; this._csig1 /= t;\n    // norm(this._somg1, this._comg1); -- don't need to normalize!\n\n    this._k2 = m.sq(this._calp0) * geod._ep2;\n    eps = this._k2 / (2 * (1 + Math.sqrt(1 + this._k2)) + this._k2);\n\n    if (this.caps & g.CAP_C1) {\n      this._A1m1 = g.A1m1f(eps);\n      this._C1a = new Array(g.nC1_ + 1);\n      g.C1f(eps, this._C1a);\n      this._B11 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C1a);\n      s = Math.sin(this._B11); c = Math.cos(this._B11);\n      // tau1 = sig1 + B11\n      this._stau1 = this._ssig1 * c + this._csig1 * s;\n      this._ctau1 = this._csig1 * c - this._ssig1 * s;\n      // Not necessary because C1pa reverts C1a\n      //    _B11 = -SinCosSeries(true, _stau1, _ctau1, _C1pa);\n    }\n\n    if (this.caps & g.CAP_C1p) {\n      this._C1pa = new Array(g.nC1p_ + 1);\n      g.C1pf(eps, this._C1pa);\n    }\n\n    if (this.caps & g.CAP_C2) {\n      this._A2m1 = g.A2m1f(eps);\n      this._C2a = new Array(g.nC2_ + 1);\n      g.C2f(eps, this._C2a);\n      this._B21 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C2a);\n    }\n\n    if (this.caps & g.CAP_C3) {\n      this._C3a = new Array(g.nC3_);\n      geod.C3f(eps, this._C3a);\n      this._A3c = -this.f * this._salp0 * geod.A3f(eps);\n      this._B31 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C3a);\n    }\n\n    if (this.caps & g.CAP_C4) {\n      this._C4a = new Array(g.nC4_); // all the elements of _C4a are used\n      geod.C4f(eps, this._C4a);\n      // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0)\n      this._A4 = m.sq(this.a) * this._calp0 * this._salp0 * geod._e2;\n      this._B41 = g.SinCosSeries(false, this._ssig1, this._csig1, this._C4a);\n    }\n\n    this.a13 = this.s13 = Number.NaN;\n  };\n\n  /**\n   * @summary Find the position on the line (general case).\n   * @param {bool} arcmode is the next parameter an arc length?\n   * @param {number} s12_a12 the (arcmode ? arc length : distance) from the\n   *   first point to the second in (arcmode ? degrees : meters).\n   * @param {bitmask} [outmask = STANDARD] which results to include; this is\n   *   subject to the capabilities of the object.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, and a12 fields of the result are\n   *   always set; s12 is included if arcmode is false.  For details on the\n   *   outmask parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  l.GeodesicLine.prototype.GenPosition = function(arcmode, s12_a12,\n                                                  outmask) {\n    var vals = {},\n        sig12, ssig12, csig12, B12, AB1, ssig2, csig2, tau12, s, c, serr,\n        omg12, lam12, lon12, E, sbet2, cbet2, somg2, comg2, salp2, calp2, dn2,\n        B22, AB2, J12, t, B42, salp12, calp12;\n    if (!outmask) outmask = g.STANDARD;\n    else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;\n    outmask &= this.caps & g.OUT_MASK;\n    vals.lat1 = this.lat1; vals.azi1 = this.azi1;\n    vals.lon1 = outmask & g.LONG_UNROLL ?\n      this.lon1 : m.AngNormalize(this.lon1);\n    if (arcmode)\n      vals.a12 = s12_a12;\n    else\n      vals.s12 = s12_a12;\n    if (!( arcmode || (this.caps & g.DISTANCE_IN & g.OUT_MASK) )) {\n      // Uninitialized or impossible distance calculation requested\n      vals.a12 = Number.NaN;\n      return vals;\n    }\n\n    // Avoid warning about uninitialized B12.\n    B12 = 0; AB1 = 0;\n    if (arcmode) {\n      // Interpret s12_a12 as spherical arc length\n      sig12 = s12_a12 * m.degree;\n      t = m.sincosd(s12_a12); ssig12 = t.s; csig12 = t.c;\n    } else {\n      // Interpret s12_a12 as distance\n      tau12 = s12_a12 / (this._b * (1 + this._A1m1));\n      s = Math.sin(tau12);\n      c = Math.cos(tau12);\n      // tau2 = tau1 + tau12\n      B12 = -g.SinCosSeries(true,\n                            this._stau1 * c + this._ctau1 * s,\n                            this._ctau1 * c - this._stau1 * s,\n                            this._C1pa);\n      sig12 = tau12 - (B12 - this._B11);\n      ssig12 = Math.sin(sig12); csig12 = Math.cos(sig12);\n      if (Math.abs(this.f) > 0.01) {\n        // Reverted distance series is inaccurate for |f| > 1/100, so correct\n        // sig12 with 1 Newton iteration.  The following table shows the\n        // approximate maximum error for a = WGS_a() and various f relative to\n        // GeodesicExact.\n        //     erri = the error in the inverse solution (nm)\n        //     errd = the error in the direct solution (series only) (nm)\n        //     errda = the error in the direct solution\n        //             (series + 1 Newton) (nm)\n        //\n        //       f     erri  errd errda\n        //     -1/5    12e6 1.2e9  69e6\n        //     -1/10  123e3  12e6 765e3\n        //     -1/20   1110 108e3  7155\n        //     -1/50  18.63 200.9 27.12\n        //     -1/100 18.63 23.78 23.37\n        //     -1/150 18.63 21.05 20.26\n        //      1/150 22.35 24.73 25.83\n        //      1/100 22.35 25.03 25.31\n        //      1/50  29.80 231.9 30.44\n        //      1/20   5376 146e3  10e3\n        //      1/10  829e3  22e6 1.5e6\n        //      1/5   157e6 3.8e9 280e6\n        ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;\n        csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;\n        B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);\n        serr = (1 + this._A1m1) * (sig12 + (B12 - this._B11)) -\n          s12_a12 / this._b;\n        sig12 = sig12 - serr / Math.sqrt(1 + this._k2 * m.sq(ssig2));\n        ssig12 = Math.sin(sig12); csig12 = Math.cos(sig12);\n        // Update B12 below\n      }\n    }\n\n    // sig2 = sig1 + sig12\n    ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;\n    csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;\n    dn2 = Math.sqrt(1 + this._k2 * m.sq(ssig2));\n    if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n      if (arcmode || Math.abs(this.f) > 0.01)\n        B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);\n      AB1 = (1 + this._A1m1) * (B12 - this._B11);\n    }\n    // sin(bet2) = cos(alp0) * sin(sig2)\n    sbet2 = this._calp0 * ssig2;\n    // Alt: cbet2 = hypot(csig2, salp0 * ssig2);\n    cbet2 = m.hypot(this._salp0, this._calp0 * csig2);\n    if (cbet2 === 0)\n      // I.e., salp0 = 0, csig2 = 0.  Break the degeneracy in this case\n      cbet2 = csig2 = g.tiny_;\n    // tan(alp0) = cos(sig2)*tan(alp2)\n    salp2 = this._salp0; calp2 = this._calp0 * csig2; // No need to normalize\n\n    if (arcmode && (outmask & g.DISTANCE))\n      vals.s12 = this._b * ((1 + this._A1m1) * sig12 + AB1);\n\n    if (outmask & g.LONGITUDE) {\n      // tan(omg2) = sin(alp0) * tan(sig2)\n      somg2 = this._salp0 * ssig2; comg2 = csig2; // No need to normalize\n      E = m.copysign(1, this._salp0);\n      // omg12 = omg2 - omg1\n      omg12 = outmask & g.LONG_UNROLL ?\n        E * (sig12 -\n             (Math.atan2(ssig2, csig2) -\n              Math.atan2(this._ssig1, this._csig1)) +\n             (Math.atan2(E * somg2, comg2) -\n              Math.atan2(E * this._somg1, this._comg1))) :\n        Math.atan2(somg2 * this._comg1 - comg2 * this._somg1,\n                     comg2 * this._comg1 + somg2 * this._somg1);\n      lam12 = omg12 + this._A3c *\n        ( sig12 + (g.SinCosSeries(true, ssig2, csig2, this._C3a) -\n                   this._B31));\n      lon12 = lam12 / m.degree;\n      vals.lon2 = outmask & g.LONG_UNROLL ? this.lon1 + lon12 :\n        m.AngNormalize(m.AngNormalize(this.lon1) + m.AngNormalize(lon12));\n    }\n\n    if (outmask & g.LATITUDE)\n      vals.lat2 = m.atan2d(sbet2, this._f1 * cbet2);\n\n    if (outmask & g.AZIMUTH)\n      vals.azi2 = m.atan2d(salp2, calp2);\n\n    if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n      B22 = g.SinCosSeries(true, ssig2, csig2, this._C2a);\n      AB2 = (1 + this._A2m1) * (B22 - this._B21);\n      J12 = (this._A1m1 - this._A2m1) * sig12 + (AB1 - AB2);\n      if (outmask & g.REDUCEDLENGTH)\n        // Add parens around (_csig1 * ssig2) and (_ssig1 * csig2) to ensure\n        // accurate cancellation in the case of coincident points.\n        vals.m12 = this._b * ((      dn2 * (this._csig1 * ssig2) -\n                               this._dn1 * (this._ssig1 * csig2)) -\n                              this._csig1 * csig2 * J12);\n      if (outmask & g.GEODESICSCALE) {\n        t = this._k2 * (ssig2 - this._ssig1) * (ssig2 + this._ssig1) /\n          (this._dn1 + dn2);\n        vals.M12 = csig12 +\n          (t * ssig2 - csig2 * J12) * this._ssig1 / this._dn1;\n        vals.M21 = csig12 -\n          (t * this._ssig1 - this._csig1 * J12) * ssig2 / dn2;\n      }\n    }\n\n    if (outmask & g.AREA) {\n      B42 = g.SinCosSeries(false, ssig2, csig2, this._C4a);\n      if (this._calp0 === 0 || this._salp0 === 0) {\n        // alp12 = alp2 - alp1, used in atan2 so no need to normalize\n        salp12 = salp2 * this.calp1 - calp2 * this.salp1;\n        calp12 = calp2 * this.calp1 + salp2 * this.salp1;\n      } else {\n        // tan(alp) = tan(alp0) * sec(sig)\n        // tan(alp2-alp1) = (tan(alp2) -tan(alp1)) / (tan(alp2)*tan(alp1)+1)\n        // = calp0 * salp0 * (csig1-csig2) / (salp0^2 + calp0^2 * csig1*csig2)\n        // If csig12 > 0, write\n        //   csig1 - csig2 = ssig12 * (csig1 * ssig12 / (1 + csig12) + ssig1)\n        // else\n        //   csig1 - csig2 = csig1 * (1 - csig12) + ssig12 * ssig1\n        // No need to normalize\n        salp12 = this._calp0 * this._salp0 *\n          (csig12 <= 0 ? this._csig1 * (1 - csig12) + ssig12 * this._ssig1 :\n           ssig12 * (this._csig1 * ssig12 / (1 + csig12) + this._ssig1));\n        calp12 = m.sq(this._salp0) + m.sq(this._calp0) * this._csig1 * csig2;\n      }\n      vals.S12 = this._c2 * Math.atan2(salp12, calp12) +\n        this._A4 * (B42 - this._B41);\n    }\n\n    if (!arcmode)\n      vals.a12 = sig12 / m.degree;\n    return vals;\n  };\n\n  /**\n   * @summary Find the position on the line given s12.\n   * @param {number} s12 the distance from the first point to the second in\n   *   meters.\n   * @param {bitmask} [outmask = STANDARD] which results to include; this is\n   *   subject to the capabilities of the object.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, s12, and a12 fields of the result are\n   *   always set; s12 is included if arcmode is false.  For details on the\n   *   outmask parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  l.GeodesicLine.prototype.Position = function(s12, outmask) {\n    return this.GenPosition(false, s12, outmask);\n  };\n\n  /**\n   * @summary Find the position on the line given a12.\n   * @param {number} a12 the arc length from the first point to the second in\n   *   degrees.\n   * @param {bitmask} [outmask = STANDARD] which results to include; this is\n   *   subject to the capabilities of the object.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, and a12 fields of the result are\n   *   always set.  For details on the outmask parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  l.GeodesicLine.prototype.ArcPosition = function(a12, outmask) {\n    return this.GenPosition(true, a12, outmask);\n  };\n\n  /**\n   * @summary Specify position of point 3 in terms of either distance or arc\n   *   length.\n   * @param {bool} arcmode boolean flag determining the meaning of the second\n   *   parameter; if arcmode is false, then the GeodesicLine object must have\n   *   been constructed with caps |= DISTANCE_IN.\n   * @param {number} s13_a13 if arcmode is false, this is the distance from\n   *   point 1 to point 3 (meters); otherwise it is the arc length from\n   *   point 1 to point 3 (degrees); it can be negative.\n   */\n  l.GeodesicLine.prototype.GenSetDistance = function(arcmode, s13_a13) {\n    if (arcmode)\n      this.SetArc(s13_a13);\n    else\n      this.SetDistance(s13_a13);\n  };\n\n  /**\n   * @summary Specify position of point 3 in terms distance.\n   * @param {number} s13 the distance from point 1 to point 3 (meters); it\n   *   can be negative.\n   */\n  l.GeodesicLine.prototype.SetDistance = function(s13) {\n    var r;\n    this.s13 = s13;\n    r = this.GenPosition(false, this.s13, g.ARC);\n    this.a13 = 0 + r.a12;       // the 0+ converts undefined into NaN\n  };\n\n  /**\n   * @summary Specify position of point 3 in terms of arc length.\n   * @param {number} a13 the arc length from point 1 to point 3 (degrees);\n   *   it can be negative.\n   */\n  l.GeodesicLine.prototype.SetArc = function(a13) {\n    var r;\n    this.a13 = a13;\n    r = this.GenPosition(true, this.a13, g.DISTANCE);\n    this.s13 = 0 + r.s12;       // the 0+ converts undefined into NaN\n  };\n\n})(GeographicLib.Geodesic, GeographicLib.GeodesicLine, GeographicLib.Math);\n\n/**************** PolygonArea.js ****************/\n/*\n * PolygonArea.js\n * Transcription of PolygonArea.[ch]pp into JavaScript.\n *\n * See the documentation for the C++ class.  The conversion is a literal\n * conversion from C++.\n *\n * The algorithms are derived in\n *\n *    Charles F. F. Karney,\n *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);\n *    https://doi.org/10.1007/s00190-012-0578-z\n *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html\n *\n * Copyright (c) Charles Karney (2011-2019) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\n// Load AFTER GeographicLib/Math.js and GeographicLib/Geodesic.js\n\n(function(\n  /**\n   * @exports GeographicLib/PolygonArea\n   * @description Compute the area of geodesic polygons via the\n   *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea}\n   *   class.\n   */\n  p, g, m, a) {\n\n  var transit, transitdirect, AreaReduceA, AreaReduceB;\n  transit = function(lon1, lon2) {\n    // Return 1 or -1 if crossing prime meridian in east or west direction.\n    // Otherwise return zero.\n    var lon12, cross;\n    // Compute lon12 the same way as Geodesic::Inverse.\n    lon1 = m.AngNormalize(lon1);\n    lon2 = m.AngNormalize(lon2);\n    lon12 = m.AngDiff(lon1, lon2).s;\n    cross = lon1 <= 0 && lon2 > 0 && lon12 > 0 ? 1 :\n      (lon2 <= 0 && lon1 > 0 && lon12 < 0 ? -1 : 0);\n    return cross;\n  };\n\n  // an alternate version of transit to deal with longitudes in the direct\n  // problem.\n  transitdirect = function(lon1, lon2) {\n    // We want to compute exactly\n    //   int(ceil(lon2 / 360)) - int(ceil(lon1 / 360))\n    // Since we only need the parity of the result we can use std::remquo but\n    // this is buggy with g++ 4.8.3 and requires C++11.  So instead we do\n    lon1 = lon1 % 720.0; lon2 = lon2 % 720.0;\n    return ( ((lon2 <= 0 && lon2 > -360) || lon2 > 360 ? 1 : 0) -\n             ((lon1 <= 0 && lon1 > -360) || lon1 > 360 ? 1 : 0) );\n  };\n\n  // Reduce Accumulator area\n  AreaReduceA = function(area, area0, crossings, reverse, sign) {\n    area.Remainder(area0);\n    if (crossings & 1)\n      area.Add( (area.Sum() < 0 ? 1 : -1) * area0/2 );\n    // area is with the clockwise sense.  If !reverse convert to\n    // counter-clockwise convention.\n    if (!reverse)\n      area.Negate();\n    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)\n    if (sign) {\n      if (area.Sum() > area0/2)\n        area.Add( -area0 );\n      else if (area.Sum() <= -area0/2)\n        area.Add( +area0 );\n    } else {\n      if (area.Sum() >= area0)\n        area.Add( -area0 );\n      else if (area.Sum() < 0)\n        area.Add( +area0 );\n    }\n    return 0 + area.Sum();\n  };\n\n  // Reduce double area\n  AreaReduceB = function(area, area0, crossings, reverse, sign) {\n    area = m.remainder(area, area0);\n    if (crossings & 1)\n      area += (area < 0 ? 1 : -1) * area0/2;\n    // area is with the clockwise sense.  If !reverse convert to\n    // counter-clockwise convention.\n    if (!reverse)\n      area *= -1;\n    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)\n    if (sign) {\n      if (area > area0/2)\n        area -= area0;\n      else if (area <= -area0/2)\n        area += area0;\n    } else {\n      if (area >= area0)\n        area -= area0;\n      else if (area < 0)\n        area += area0;\n    }\n    return 0 + area;\n  };\n\n  /**\n   * @class\n   * @property {number} a the equatorial radius (meters).\n   * @property {number} f the flattening.\n   * @property {bool} polyline whether the PolygonArea object describes a\n   *   polyline or a polygon.\n   * @property {number} num the number of vertices so far.\n   * @property {number} lat the current latitude (degrees).\n   * @property {number} lon the current longitude (degrees).\n   * @summary Initialize a PolygonArea object.\n   * @classdesc Computes the area and perimeter of a geodesic polygon.\n   *   This object is usually instantiated by\n   *   {@link module:GeographicLib/Geodesic.Geodesic#Polygon Geodesic.Polygon}.\n   * @param {object} geod a {@link module:GeographicLib/Geodesic.Geodesic\n   *   Geodesic} object.\n   * @param {bool} [polyline = false] if true the new PolygonArea object\n   *   describes a polyline instead of a polygon.\n   */\n  p.PolygonArea = function(geod, polyline) {\n    this._geod = geod;\n    this.a = this._geod.a;\n    this.f = this._geod.f;\n    this._area0 = 4 * Math.PI * geod._c2;\n    this.polyline = !polyline ? false : polyline;\n    this._mask = g.LATITUDE | g.LONGITUDE | g.DISTANCE |\n          (this.polyline ? g.NONE : g.AREA | g.LONG_UNROLL);\n    if (!this.polyline)\n      this._areasum = new a.Accumulator(0);\n    this._perimetersum = new a.Accumulator(0);\n    this.Clear();\n  };\n\n  /**\n   * @summary Clear the PolygonArea object, setting the number of vertices to\n   *   0.\n   */\n  p.PolygonArea.prototype.Clear = function() {\n    this.num = 0;\n    this._crossings = 0;\n    if (!this.polyline)\n      this._areasum.Set(0);\n    this._perimetersum.Set(0);\n    this._lat0 = this._lon0 = this.lat = this.lon = Number.NaN;\n  };\n\n  /**\n   * @summary Add the next vertex to the polygon.\n   * @param {number} lat the latitude of the point (degrees).\n   * @param {number} lon the longitude of the point (degrees).\n   * @description This adds an edge from the current vertex to the new vertex.\n   */\n  p.PolygonArea.prototype.AddPoint = function(lat, lon) {\n    var t;\n    if (this.num === 0) {\n      this._lat0 = this.lat = lat;\n      this._lon0 = this.lon = lon;\n    } else {\n      t = this._geod.Inverse(this.lat, this.lon, lat, lon, this._mask);\n      this._perimetersum.Add(t.s12);\n      if (!this.polyline) {\n        this._areasum.Add(t.S12);\n        this._crossings += transit(this.lon, lon);\n      }\n      this.lat = lat;\n      this.lon = lon;\n    }\n    ++this.num;\n  };\n\n  /**\n   * @summary Add the next edge to the polygon.\n   * @param {number} azi the azimuth at the current the point (degrees).\n   * @param {number} s the length of the edge (meters).\n   * @description This specifies the new vertex in terms of the edge from the\n   *   current vertex.\n   */\n  p.PolygonArea.prototype.AddEdge = function(azi, s) {\n    var t;\n    if (this.num) {\n      t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);\n      this._perimetersum.Add(s);\n      if (!this.polyline) {\n        this._areasum.Add(t.S12);\n        this._crossings += transitdirect(this.lon, t.lon2);\n      }\n      this.lat = t.lat2;\n      this.lon = t.lon2;\n    }\n    ++this.num;\n  };\n\n  /**\n   * @summary Compute the perimeter and area of the polygon.\n   * @param {bool} reverse if true then clockwise (instead of\n   *   counter-clockwise) traversal counts as a positive area.\n   * @param {bool} sign if true then return a signed result for the area if the\n   *   polygon is traversed in the \"wrong\" direction instead of returning the\n   *   area for the rest of the earth.\n   * @returns {object} r where r.number is the number of vertices, r.perimeter\n   *   is the perimeter (meters), and r.area (only returned if polyline is\n   *   false) is the area (meters<sup>2</sup>).\n   * @description Arbitrarily complex polygons are allowed.  In the case of\n   *   self-intersecting polygons the area is accumulated \"algebraically\",\n   *   e.g., the areas of the 2 loops in a figure-8 polygon will partially\n   *   cancel.  If the object is a polygon (and not a polyline), the perimeter\n   *   includes the length of a final edge connecting the current point to the\n   *   initial point.  If the object is a polyline, then area is nan.  More\n   *   points can be added to the polygon after this call.\n   */\n  p.PolygonArea.prototype.Compute = function(reverse, sign) {\n    var vals = {number: this.num}, t, tempsum;\n    if (this.num < 2) {\n      vals.perimeter = 0;\n      if (!this.polyline)\n        vals.area = 0;\n      return vals;\n    }\n    if (this.polyline) {\n      vals.perimeter = this._perimetersum.Sum();\n      return vals;\n    }\n    t = this._geod.Inverse(this.lat, this.lon, this._lat0, this._lon0,\n                           this._mask);\n    vals.perimeter = this._perimetersum.Sum(t.s12);\n    tempsum = new a.Accumulator(this._areasum);\n    tempsum.Add(t.S12);\n    vals.area = AreaReduceA(tempsum, this._area0,\n                            this._crossings + transit(this.lon, this._lon0),\n                            reverse, sign);\n    return vals;\n  };\n\n  /**\n   * @summary Compute the perimeter and area of the polygon with a tentative\n   *   new vertex.\n   * @param {number} lat the latitude of the point (degrees).\n   * @param {number} lon the longitude of the point (degrees).\n   * @param {bool} reverse if true then clockwise (instead of\n   *   counter-clockwise) traversal counts as a positive area.\n   * @param {bool} sign if true then return a signed result for the area if the\n   *   polygon is traversed in the \"wrong\" direction instead of returning the\n   *   area for the rest of the earth.\n   * @returns {object} r where r.number is the number of vertices, r.perimeter\n   *   is the perimeter (meters), and r.area (only returned if polyline is\n   *   false) is the area (meters<sup>2</sup>).\n   * @description A new vertex is *not* added to the polygon.\n   */\n  p.PolygonArea.prototype.TestPoint = function(lat, lon, reverse, sign) {\n    var vals = {number: this.num + 1}, t, tempsum, crossings, i;\n    if (this.num === 0) {\n      vals.perimeter = 0;\n      if (!this.polyline)\n        vals.area = 0;\n      return vals;\n    }\n    vals.perimeter = this._perimetersum.Sum();\n    tempsum = this.polyline ? 0 : this._areasum.Sum();\n    crossings = this._crossings;\n    for (i = 0; i < (this.polyline ? 1 : 2); ++i) {\n      t = this._geod.Inverse(\n       i === 0 ? this.lat : lat, i === 0 ? this.lon : lon,\n       i !== 0 ? this._lat0 : lat, i !== 0 ? this._lon0 : lon,\n       this._mask);\n      vals.perimeter += t.s12;\n      if (!this.polyline) {\n        tempsum += t.S12;\n        crossings += transit(i === 0 ? this.lon : lon,\n                               i !== 0 ? this._lon0 : lon);\n      }\n    }\n\n    if (this.polyline)\n      return vals;\n\n    vals.area = AreaReduceB(tempsum, this._area0, crossings, reverse, sign);\n    return vals;\n  };\n\n  /**\n   * @summary Compute the perimeter and area of the polygon with a tentative\n   *   new edge.\n   * @param {number} azi the azimuth of the edge (degrees).\n   * @param {number} s the length of the edge (meters).\n   * @param {bool} reverse if true then clockwise (instead of\n   *   counter-clockwise) traversal counts as a positive area.\n   * @param {bool} sign if true then return a signed result for the area if the\n   *   polygon is traversed in the \"wrong\" direction instead of returning the\n   *   area for the rest of the earth.\n   * @returns {object} r where r.number is the number of vertices, r.perimeter\n   *   is the perimeter (meters), and r.area (only returned if polyline is\n   *   false) is the area (meters<sup>2</sup>).\n   * @description A new vertex is *not* added to the polygon.\n   */\n  p.PolygonArea.prototype.TestEdge = function(azi, s, reverse, sign) {\n    var vals = {number: this.num ? this.num + 1 : 0}, t, tempsum, crossings;\n    if (this.num === 0)\n      return vals;\n    vals.perimeter = this._perimetersum.Sum() + s;\n    if (this.polyline)\n      return vals;\n\n    tempsum = this._areasum.Sum();\n    crossings = this._crossings;\n    t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);\n    tempsum += t.S12;\n    crossings += transitdirect(this.lon, t.lon2);\n    crossings += transit(t.lon2, this._lon0);\n    t = this._geod.Inverse(t.lat2, t.lon2, this._lat0, this._lon0, this._mask);\n    vals.perimeter += t.s12;\n    tempsum += t.S12;\n\n    vals.area = AreaReduceB(tempsum, this._area0, crossings, reverse, sign);\n    return vals;\n  };\n\n})(GeographicLib.PolygonArea, GeographicLib.Geodesic,\n   GeographicLib.Math, GeographicLib.Accumulator);\n\n/**************** DMS.js ****************/\n/*\n * DMS.js\n * Transcription of DMS.[ch]pp into JavaScript.\n *\n * See the documentation for the C++ class.  The conversion is a literal\n * conversion from C++.\n *\n * Copyright (c) Charles Karney (2011-2019) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\nGeographicLib.DMS = {};\n\n(function(\n  /**\n   * @exports GeographicLib/DMS\n   * @description Decode/Encode angles expressed as degrees, minutes, and\n   *   seconds.  This module defines several constants:\n   *   - hemisphere indicator (returned by\n   *       {@link module:GeographicLib/DMS.Decode Decode}) and a formatting\n   *       indicator (used by\n   *       {@link module:GeographicLib/DMS.Encode Encode})\n   *     - NONE = 0, no designator and format as plain angle;\n   *     - LATITUDE = 1, a N/S designator and format as latitude;\n   *     - LONGITUDE = 2, an E/W designator and format as longitude;\n   *     - AZIMUTH = 3, format as azimuth;\n   *   - the specification of the trailing component in\n   *       {@link module:GeographicLib/DMS.Encode Encode}\n   *     - DEGREE;\n   *     - MINUTE;\n   *     - SECOND.\n   */\n  d) {\n\n  var lookup, zerofill, internalDecode, numMatch,\n      hemispheres_ = \"SNWE\",\n      signs_ = \"-+\",\n      digits_ = \"0123456789\",\n      dmsindicators_ = \"D'\\\":\",\n      // dmsindicatorsu_ = \"\\u00b0\\u2032\\u2033\"; // Unicode variants\n      dmsindicatorsu_ = \"\\u00b0'\\\"\", // Use degree symbol\n      components_ = [\"degrees\", \"minutes\", \"seconds\"];\n  lookup = function(s, c) {\n    return s.indexOf(c.toUpperCase());\n  };\n  zerofill = function(s, n) {\n    return String(\"0000\").substr(0, Math.max(0, Math.min(4, n-s.length))) +\n      s;\n  };\n  d.NONE = 0;\n  d.LATITUDE = 1;\n  d.LONGITUDE = 2;\n  d.AZIMUTH = 3;\n  d.DEGREE = 0;\n  d.MINUTE = 1;\n  d.SECOND = 2;\n\n  /**\n   * @summary Decode a DMS string.\n   * @description The interpretation of the string is given in the\n   *   documentation of the corresponding function, Decode(string&, flag&)\n   *   in the {@link\n   *   https://geographiclib.sourceforge.io/html/classGeographicLib_1_1DMS.html\n   *   C++ DMS class}\n   * @param {string} dms the string.\n   * @returns {object} r where r.val is the decoded value (degrees) and r.ind\n   *   is a hemisphere designator, one of NONE, LATITUDE, LONGITUDE.\n   * @throws an error if the string is illegal.\n   */\n  d.Decode = function(dms) {\n    var dmsa = dms, end,\n        v = 0, i = 0, mi, pi, vals,\n        ind1 = d.NONE, ind2, p, pa, pb;\n    dmsa = dmsa\n      .replace(/\\u2212/g, '-')  // U+2212 minus sign\n      .replace(/\\u00b0/g, 'd')  // U+00b0 degree symbol\n      .replace(/\\u00ba/g, 'd')  // U+00ba alt symbol\n      .replace(/\\u2070/g, 'd')  // U+2070 sup zero\n      .replace(/\\u02da/g, 'd')  // U+02da ring above\n      .replace(/\\u2032/g, '\\'') // U+2032 prime\n      .replace(/\\u00b4/g, '\\'') // U+00b4 acute accent\n      .replace(/\\u2019/g, '\\'') // U+2019 right single quote\n      .replace(/\\u2033/g, '\"')  // U+2033 double prime\n      .replace(/\\u201d/g, '\"')  // U+201d right double quote\n      .replace(/\\u00a0/g, '')   // U+00a0 non-breaking space\n      .replace(/\\u202f/g, '')   // U+202f narrow space\n      .replace(/\\u2007/g, '')   // U+2007 figure space\n      .replace(/''/g, '\"')      // '' -> \"\n      .trim();\n\n    end = dmsa.length;\n    // p is pointer to the next piece that needs decoding\n    for (p = 0; p < end; p = pb, ++i) {\n      pa = p;\n      // Skip over initial hemisphere letter (for i == 0)\n      if (i === 0 && lookup(hemispheres_, dmsa.charAt(pa)) >= 0)\n        ++pa;\n      // Skip over initial sign (checking for it if i == 0)\n      if (i > 0 || (pa < end && lookup(signs_, dmsa.charAt(pa)) >= 0))\n        ++pa;\n      // Find next sign\n      mi = dmsa.substr(pa, end - pa).indexOf('-');\n      pi = dmsa.substr(pa, end - pa).indexOf('+');\n      if (mi < 0) mi = end; else mi += pa;\n      if (pi < 0) pi = end; else pi += pa;\n      pb = Math.min(mi, pi);\n      vals = internalDecode(dmsa.substr(p, pb - p));\n      v += vals.val; ind2 = vals.ind;\n      if (ind1 === d.NONE)\n        ind1 = ind2;\n      else if (!(ind2 === d.NONE || ind1 === ind2))\n        throw new Error(\"Incompatible hemisphere specifies in \" +\n                        dmsa.substr(0, pb));\n    }\n    if (i === 0)\n      throw new Error(\"Empty or incomplete DMS string \" + dmsa);\n    return {val: v, ind: ind1};\n  };\n\n  internalDecode = function(dmsa) {\n    var vals = {}, errormsg = \"\",\n        sign, beg, end, ind1, k,\n        ipieces, fpieces, npiece,\n        icurrent, fcurrent, ncurrent, p,\n        pointseen,\n        digcount, intcount,\n        x;\n    do {                       // Executed once (provides the ability to break)\n      sign = 1;\n      beg = 0; end = dmsa.length;\n      ind1 = d.NONE;\n      k = -1;\n      if (end > beg && (k = lookup(hemispheres_, dmsa.charAt(beg))) >= 0) {\n        ind1 = (k & 2) ? d.LONGITUDE : d.LATITUDE;\n        sign = (k & 1) ? 1 : -1;\n        ++beg;\n      }\n      if (end > beg &&\n          (k = lookup(hemispheres_, dmsa.charAt(end-1))) >= 0) {\n        if (k >= 0) {\n          if (ind1 !== d.NONE) {\n            if (dmsa.charAt(beg - 1).toUpperCase() ===\n                dmsa.charAt(end - 1).toUpperCase())\n              errormsg = \"Repeated hemisphere indicators \" +\n              dmsa.charAt(beg - 1) + \" in \" +\n              dmsa.substr(beg - 1, end - beg + 1);\n            else\n              errormsg = \"Contradictory hemisphere indicators \" +\n              dmsa.charAt(beg - 1) + \" and \" + dmsa.charAt(end - 1) + \" in \" +\n              dmsa.substr(beg - 1, end - beg + 1);\n            break;\n          }\n          ind1 = (k & 2) ? d.LONGITUDE : d.LATITUDE;\n          sign = (k & 1) ? 1 : -1;\n          --end;\n        }\n      }\n      if (end > beg && (k = lookup(signs_, dmsa.charAt(beg))) >= 0) {\n        if (k >= 0) {\n          sign *= k ? 1 : -1;\n          ++beg;\n        }\n      }\n      if (end === beg) {\n        errormsg = \"Empty or incomplete DMS string \" + dmsa;\n        break;\n      }\n      ipieces = [0, 0, 0];\n      fpieces = [0, 0, 0];\n      npiece = 0;\n      icurrent = 0;\n      fcurrent = 0;\n      ncurrent = 0;\n      p = beg;\n      pointseen = false;\n      digcount = 0;\n      intcount = 0;\n      while (p < end) {\n        x = dmsa.charAt(p++);\n        if ((k = lookup(digits_, x)) >= 0) {\n          ++ncurrent;\n          if (digcount > 0) {\n            ++digcount;         // Count of decimal digits\n          } else {\n            icurrent = 10 * icurrent + k;\n            ++intcount;\n          }\n        } else if (x === '.') {\n          if (pointseen) {\n            errormsg = \"Multiple decimal points in \" +\n              dmsa.substr(beg, end - beg);\n            break;\n          }\n          pointseen = true;\n          digcount = 1;\n        } else if ((k = lookup(dmsindicators_, x)) >= 0) {\n          if (k >= 3) {\n            if (p === end) {\n              errormsg = \"Illegal for colon to appear at the end of \" +\n                dmsa.substr(beg, end - beg);\n              break;\n            }\n            k = npiece;\n          }\n          if (k === npiece - 1) {\n            errormsg = \"Repeated \" + components_[k] +\n              \" component in \" + dmsa.substr(beg, end - beg);\n            break;\n          } else if (k < npiece) {\n            errormsg = components_[k] + \" component follows \" +\n              components_[npiece - 1] + \" component in \" +\n              dmsa.substr(beg, end - beg);\n            break;\n          }\n          if (ncurrent === 0) {\n            errormsg = \"Missing numbers in \" + components_[k] +\n              \" component of \" + dmsa.substr(beg, end - beg);\n            break;\n          }\n          if (digcount > 0) {\n            fcurrent = parseFloat(dmsa.substr(p - intcount - digcount - 1,\n                                              intcount + digcount));\n            icurrent = 0;\n          }\n          ipieces[k] = icurrent;\n          fpieces[k] = icurrent + fcurrent;\n          if (p < end) {\n            npiece = k + 1;\n            icurrent = fcurrent = 0;\n            ncurrent = digcount = intcount = 0;\n          }\n        } else if (lookup(signs_, x) >= 0) {\n          errormsg = \"Internal sign in DMS string \" +\n            dmsa.substr(beg, end - beg);\n          break;\n        } else {\n          errormsg = \"Illegal character \" + x + \" in DMS string \" +\n            dmsa.substr(beg, end - beg);\n          break;\n        }\n      }\n      if (errormsg.length)\n        break;\n      if (lookup(dmsindicators_, dmsa.charAt(p - 1)) < 0) {\n        if (npiece >= 3) {\n          errormsg = \"Extra text following seconds in DMS string \" +\n            dmsa.substr(beg, end - beg);\n          break;\n        }\n        if (ncurrent === 0) {\n          errormsg = \"Missing numbers in trailing component of \" +\n            dmsa.substr(beg, end - beg);\n          break;\n        }\n        if (digcount > 0) {\n          fcurrent = parseFloat(dmsa.substr(p - intcount - digcount,\n                                            intcount + digcount));\n          icurrent = 0;\n        }\n        ipieces[npiece] = icurrent;\n        fpieces[npiece] = icurrent + fcurrent;\n      }\n      if (pointseen && digcount === 0) {\n        errormsg = \"Decimal point in non-terminal component of \" +\n          dmsa.substr(beg, end - beg);\n        break;\n      }\n      // Note that we accept 59.999999... even though it rounds to 60.\n      if (ipieces[1] >= 60 || fpieces[1] > 60) {\n        errormsg = \"Minutes \" + fpieces[1] + \" not in range [0,60)\";\n        break;\n      }\n      if (ipieces[2] >= 60 || fpieces[2] > 60) {\n        errormsg = \"Seconds \" + fpieces[2] + \" not in range [0,60)\";\n        break;\n      }\n      vals.ind = ind1;\n      // Assume check on range of result is made by calling routine (which\n      // might be able to offer a better diagnostic).\n      vals.val = sign *\n        ( fpieces[2] ? (60*(60*fpieces[0] + fpieces[1]) + fpieces[2]) / 3600 :\n          ( fpieces[1] ? (60*fpieces[0] + fpieces[1]) / 60 : fpieces[0] ) );\n      return vals;\n    } while (false);\n    vals.val = numMatch(dmsa);\n    if (vals.val === 0)\n      throw new Error(errormsg);\n    else\n      vals.ind = d.NONE;\n    return vals;\n  };\n\n  numMatch = function(s) {\n    var t, sign, p0, p1;\n    if (s.length < 3)\n      return 0;\n    t = s.toUpperCase().replace(/0+$/, \"\");\n    sign = t.charAt(0) === '-' ? -1 : 1;\n    p0 = t.charAt(0) === '-' || t.charAt(0) === '+' ? 1 : 0;\n    p1 = t.length - 1;\n    if (p1 + 1 < p0 + 3)\n      return 0;\n    // Strip off sign and trailing 0s\n    t = t.substr(p0, p1 + 1 - p0); // Length at least 3\n    if (t === \"NAN\" || t === \"1.#QNAN\" || t === \"1.#SNAN\" || t === \"1.#IND\" ||\n        t === \"1.#R\")\n      return Number.NaN;\n    else if (t === \"INF\" || t === \"1.#INF\")\n      return sign * Number.POSITIVE_INFINITY;\n    return 0;\n  };\n\n  /**\n   * @summary Decode two DMS strings interpreting them as a latitude/longitude\n   *   pair.\n   * @param {string} stra the first string.\n   * @param {string} strb the first string.\n   * @param {bool} [longfirst = false] if true assume then longitude is given\n   *   first (in the absence of any hemisphere indicators).\n   * @returns {object} r where r.lat is the decoded latitude and r.lon is the\n   *   decoded longitude (both in degrees).\n   * @throws an error if the strings are illegal.\n   */\n  d.DecodeLatLon = function(stra, strb, longfirst) {\n    var vals = {},\n        valsa = d.Decode(stra),\n        valsb = d.Decode(strb),\n        a = valsa.val, ia = valsa.ind,\n        b = valsb.val, ib = valsb.ind,\n        lat, lon;\n    if (!longfirst) longfirst = false;\n    if (ia === d.NONE && ib === d.NONE) {\n      // Default to lat, long unless longfirst\n      ia = longfirst ? d.LONGITUDE : d.LATITUDE;\n      ib = longfirst ? d.LATITUDE : d.LONGITUDE;\n    } else if (ia === d.NONE)\n      ia = d.LATITUDE + d.LONGITUDE - ib;\n    else if (ib === d.NONE)\n      ib = d.LATITUDE + d.LONGITUDE - ia;\n    if (ia === ib)\n      throw new Error(\"Both \" + stra + \" and \" + strb + \" interpreted as \" +\n                      (ia === d.LATITUDE ? \"latitudes\" : \"longitudes\"));\n    lat = ia === d.LATITUDE ? a : b;\n    lon = ia === d.LATITUDE ? b : a;\n    if (Math.abs(lat) > 90)\n      throw new Error(\"Latitude \" + lat + \" not in [-90,90]\");\n    vals.lat = lat;\n    vals.lon = lon;\n    return vals;\n  };\n\n  /**\n   * @summary Decode a DMS string interpreting it as an arc length.\n   * @param {string} angstr the string (this must not include a hemisphere\n   *   indicator).\n   * @returns {number} the arc length (degrees).\n   * @throws an error if the string is illegal.\n   */\n  d.DecodeAngle = function(angstr) {\n    var vals = d.Decode(angstr),\n        ang = vals.val, ind = vals.ind;\n    if (ind !== d.NONE)\n      throw new Error(\"Arc angle \" + angstr +\n                      \" includes a hemisphere N/E/W/S\");\n    return ang;\n  };\n\n  /**\n   * @summary Decode a DMS string interpreting it as an azimuth.\n   * @param {string} azistr the string (this may include an E/W hemisphere\n   *   indicator).\n   * @returns {number} the azimuth (degrees).\n   * @throws an error if the string is illegal.\n   */\n  d.DecodeAzimuth = function(azistr) {\n    var vals = d.Decode(azistr),\n        azi = vals.val, ind = vals.ind;\n    if (ind === d.LATITUDE)\n      throw new Error(\"Azimuth \" + azistr + \" has a latitude hemisphere N/S\");\n    return azi;\n  };\n\n  /**\n   * @summary Convert angle (in degrees) into a DMS string (using &deg;, ',\n   *  and &quot;).\n   * @param {number} angle input angle (degrees).\n   * @param {number} trailing one of DEGREE, MINUTE, or SECOND to indicate\n   *   the trailing component of the string (this component is given as a\n   *   decimal number if necessary).\n   * @param {number} prec the number of digits after the decimal point for\n   *   the trailing component.\n   * @param {number} [ind = NONE] a formatting indicator, one of NONE,\n   *   LATITUDE, LONGITUDE, AZIMUTH.\n   * @returns {string} the resulting string formatted as follows:\n   *   * NONE, signed result no leading zeros on degrees except in the units\n   *     place, e.g., -8&deg;03'.\n   *   * LATITUDE, trailing N or S hemisphere designator, no sign, pad\n   *     degrees to 2 digits, e.g., 08&deg;03'S.\n   *   * LONGITUDE, trailing E or W hemisphere designator, no sign, pad\n   *     degrees to 3 digits, e.g., 008&deg;03'W.\n   *   * AZIMUTH, convert to the range [0, 360&deg;), no sign, pad degrees to\n   *     3 digits, e.g., 351&deg;57'.\n   */\n  d.Encode = function(angle, trailing, prec, ind) {\n    // Assume check on range of input angle has been made by calling\n    // routine (which might be able to offer a better diagnostic).\n    var scale = 1, i, sign,\n        idegree, fdegree, f, pieces, ip, fp, s;\n    if (!ind) ind = d.NONE;\n    if (!isFinite(angle))\n      return angle < 0 ? String(\"-inf\") :\n      (angle > 0 ? String(\"inf\") : String(\"nan\"));\n\n    // 15 - 2 * trailing = ceiling(log10(2^53/90/60^trailing)).\n    // This suffices to give full real precision for numbers in [-90,90]\n    prec = Math.min(15 - 2 * trailing, prec);\n    for (i = 0; i < trailing; ++i)\n      scale *= 60;\n    for (i = 0; i < prec; ++i)\n      scale *= 10;\n    if (ind === d.AZIMUTH)\n      angle -= Math.floor(angle/360) * 360;\n    sign = angle < 0 ? -1 : 1;\n    angle *= sign;\n\n    // Break off integer part to preserve precision in manipulation of\n    // fractional part.\n    idegree = Math.floor(angle);\n    fdegree = (angle - idegree) * scale + 0.5;\n    f = Math.floor(fdegree);\n    // Implement the \"round ties to even\" rule\n    fdegree = (f === fdegree && (f & 1) === 1) ? f - 1 : f;\n    fdegree /= scale;\n\n    fdegree = Math.floor((angle - idegree) * scale + 0.5) / scale;\n    if (fdegree >= 1) {\n      idegree += 1;\n      fdegree -= 1;\n    }\n    pieces = [fdegree, 0, 0];\n    for (i = 1; i <= trailing; ++i) {\n      ip = Math.floor(pieces[i - 1]);\n      fp = pieces[i - 1] - ip;\n      pieces[i] = fp * 60;\n      pieces[i - 1] = ip;\n    }\n    pieces[0] += idegree;\n    s = \"\";\n    if (ind === d.NONE && sign < 0)\n      s += '-';\n    switch (trailing) {\n    case d.DEGREE:\n      s += zerofill(pieces[0].toFixed(prec),\n                    ind === d.NONE ? 0 :\n                    1 + Math.min(ind, 2) + prec + (prec ? 1 : 0)) +\n        dmsindicatorsu_.charAt(0);\n      break;\n    default:\n      s += zerofill(pieces[0].toFixed(0),\n                    ind === d.NONE ? 0 : 1 + Math.min(ind, 2)) +\n        dmsindicatorsu_.charAt(0);\n      switch (trailing) {\n      case d.MINUTE:\n        s += zerofill(pieces[1].toFixed(prec), 2 + prec + (prec ? 1 : 0)) +\n          dmsindicatorsu_.charAt(1);\n        break;\n      case d.SECOND:\n        s += zerofill(pieces[1].toFixed(0), 2) + dmsindicatorsu_.charAt(1);\n        s += zerofill(pieces[2].toFixed(prec), 2 + prec + (prec ? 1 : 0)) +\n          dmsindicatorsu_.charAt(2);\n        break;\n      default:\n        break;\n      }\n    }\n    if (ind !== d.NONE && ind !== d.AZIMUTH)\n      s += hemispheres_.charAt((ind === d.LATITUDE ? 0 : 2) +\n                               (sign < 0 ? 0 : 1));\n    return s;\n  };\n})(GeographicLib.DMS);\n\ncb(GeographicLib);\n\n})(function(geo) {\n  if (typeof module === 'object' && module.exports) {\n    /******** support loading with node's require ********/\n    module.exports = geo;\n  } else if (typeof define === 'function' && define.amd) {\n    /******** support loading with AMD ********/\n    define('geographiclib', [], function() { return geo; });\n  } else {\n    /******** otherwise just pollute our global namespace ********/\n    window.GeographicLib = geo;\n  }\n});\n","import {toPoint, forward} from 'mgrs';\n\nfunction Point(x, y, z) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y, z);\n  }\n  if (Array.isArray(x)) {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2] || 0.0;\n  } else if(typeof x === 'object') {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z || 0.0;\n  } else if (typeof x === 'string' && typeof y === 'undefined') {\n    var coords = x.split(',');\n    this.x = parseFloat(coords[0], 10);\n    this.y = parseFloat(coords[1], 10);\n    this.z = parseFloat(coords[2], 10) || 0.0;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z || 0.0;\n  }\n  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');\n}\n\nPoint.fromMGRS = function(mgrsStr) {\n  return new Point(toPoint(mgrsStr));\n};\nPoint.prototype.toMGRS = function(accuracy) {\n  return forward([this.x, this.y], accuracy);\n};\nexport default Point;\n","import parseCode from './parseCode';\nimport extend from './extend';\nimport projections from './projections';\nimport {sphere as dc_sphere, eccentricity as dc_eccentricity} from './deriveConstants';\nimport Datum from './constants/Datum';\nimport datum from './datum';\nimport match from './match';\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = parseCode(srsCode);\n  if(typeof json !== 'object'){\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection.projections.get(json.projName);\n  if(!ourProj){\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== 'none') {\n    var datumDef = match(Datum, json.datumCode);\n    if (datumDef) {\n      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1.0;\n  json.axis = json.axis || 'enu';\n  json.ellps = json.ellps || 'wgs84';\n  var sphere_ = dc_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = dc_eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\n  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);\n\n  extend(this, json); // transfer everything over from the projection because we don't know what we'll need\n  extend(this, ourProj); // transfer all the methods from the projection\n\n  // copy the 4 things over we calulated in deriveConstants.sphere\n  this.a = sphere_.a;\n  this.b = sphere_.b;\n  this.rf = sphere_.rf;\n  this.sphere = sphere_.sphere;\n\n  // copy the 3 things we calculated in deriveConstants.eccentricity\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n\n  // add in the datum object\n  this.datum = datumObj;\n\n  // init the projection\n  this.init();\n\n  // legecy callback from back in the day when it went to spatialreference.org\n  callback(null, this);\n\n}\nProjection.projections = projections;\nProjection.projections.start();\nexport default Projection;\n","export default function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  var out = {};\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      t = 'x';\n    }\n    else if (i === 1) {\n      v = yin;\n      t = 'y';\n    }\n    else {\n      v = zin;\n      t = 'z';\n    }\n    switch (crs.axis[i]) {\n    case 'e':\n      out[t] = v;\n      break;\n    case 'w':\n      out[t] = -v;\n      break;\n    case 'n':\n      out[t] = v;\n      break;\n    case 's':\n      out[t] = -v;\n      break;\n    case 'u':\n      if (point[t] !== undefined) {\n        out.z = v;\n      }\n      break;\n    case 'd':\n      if (point[t] !== undefined) {\n        out.z = -v;\n      }\n      break;\n    default:\n      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n      return null;\n    }\n  }\n  return out;\n}\n","import {HALF_PI} from '../constants/values';\nimport sign from './sign';\n\nexport default function(x) {\n  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));\n}\n","\nimport {TWO_PI, SPI} from '../constants/values';\nimport sign from './sign';\n\nexport default function(x) {\n  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n}\n","import adjust_lon from './adjust_lon';\n\nexport default function(zone, lon) {\n  if (zone === undefined) {\n    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;\n\n    if (zone < 0) {\n      return 0;\n    } else if (zone > 60) {\n      return 60;\n    }\n  }\n  return zone;\n}\n","import hypot from './hypot';\nimport log1py from './log1py';\n\nexport default function(x) {\n  var y = Math.abs(x);\n  y = log1py(y * (1 + y / (hypot(1, y) + 1)));\n\n  return x < 0 ? -y : y;\n}\n","export default function(x) {\n  if (Math.abs(x) > 1) {\n    x = (x > 1) ? 1 : -1;\n  }\n  return Math.asin(x);\n}","export default function(pp, arg_r) {\n  var r = 2 * Math.cos(arg_r);\n  var i = pp.length - 1;\n  var hr1 = pp[i];\n  var hr2 = 0;\n  var hr;\n\n  while (--i >= 0) {\n    hr = -hr2 + r * hr1 + pp[i];\n    hr2 = hr1;\n    hr1 = hr;\n  }\n\n  return Math.sin(arg_r) * hr;\n}\n","import sinh from './sinh';\nimport cosh from './cosh';\n\nexport default function(pp, arg_r, arg_i) {\n  var sin_arg_r = Math.sin(arg_r);\n  var cos_arg_r = Math.cos(arg_r);\n  var sinh_arg_i = sinh(arg_i);\n  var cosh_arg_i = cosh(arg_i);\n  var r = 2 * cos_arg_r * cosh_arg_i;\n  var i = -2 * sin_arg_r * sinh_arg_i;\n  var j = pp.length - 1;\n  var hr = pp[j];\n  var hi1 = 0;\n  var hr1 = 0;\n  var hi = 0;\n  var hr2;\n  var hi2;\n\n  while (--j >= 0) {\n    hr2 = hr1;\n    hi2 = hi1;\n    hr1 = hr;\n    hi1 = hi;\n    hr = -hr2 + r * hr1 - i * hi1 + pp[j];\n    hi = -hi2 + i * hr1 + r * hi1;\n  }\n\n  r = sin_arg_r * cosh_arg_i;\n  i = cos_arg_r * sinh_arg_i;\n\n  return [r * hr - i * hi, r * hi + i * hr];\n}\n","export default function(x) {\n  var r = Math.exp(x);\n  r = (r + 1 / r) / 2;\n  return r;\n}","export default function(x) {\n  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));\n}","export default function(x) {\n  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));\n}","export default function(x) {\n  return (0.05859375 * x * x * (1 + 0.75 * x));\n}","export default function(x) {\n  return (x * x * x * (35 / 3072));\n}","export default function(a, e, sinphi) {\n  var temp = e * sinphi;\n  return a / Math.sqrt(1 - temp * temp);\n}","export default function(pp, B) {\n  var cos_2B = 2 * Math.cos(2 * B);\n  var i = pp.length - 1;\n  var h1 = pp[i];\n  var h2 = 0;\n  var h;\n\n  while (--i >= 0) {\n    h = -h2 + cos_2B * h1 + pp[i];\n    h2 = h1;\n    h1 = h;\n  }\n\n  return (B + h * Math.sin(2 * B));\n}\n","export default function(x, y) {\n  x = Math.abs(x);\n  y = Math.abs(y);\n  var a = Math.max(x, y);\n  var b = Math.min(x, y) / (a ? a : 1);\n\n  return a * Math.sqrt(1 + Math.pow(b, 2));\n}\n","export default function(ml, e0, e1, e2, e3) {\n  var phi;\n  var dphi;\n\n  phi = ml / e0;\n  for (var i = 0; i < 15; i++) {\n    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //..reportError(\"IMLFN-CONV:Latitude failed to converge after 15 iterations\");\n  return NaN;\n}","import {HALF_PI} from '../constants/values';\n\nexport default function(eccent, q) {\n  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));\n  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {\n    if (q < 0) {\n      return (-1 * HALF_PI);\n    }\n    else {\n      return HALF_PI;\n    }\n  }\n  //var phi = 0.5* q/(1-eccent*eccent);\n  var phi = Math.asin(0.5 * q);\n  var dphi;\n  var sin_phi;\n  var cos_phi;\n  var con;\n  for (var i = 0; i < 30; i++) {\n    sin_phi = Math.sin(phi);\n    cos_phi = Math.cos(phi);\n    con = eccent * sin_phi;\n    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //console.log(\"IQSFN-CONV:Latitude failed to converge after 30 iterations\");\n  return NaN;\n}\n","export default function(x) {\n  var y = 1 + x;\n  var z = y - 1;\n\n  return z === 0 ? x : x * Math.log(y) / z;\n}\n","export default function(e0, e1, e2, e3, phi) {\n  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));\n}","export default function(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / (Math.sqrt(1 - con * con));\n}","import {HALF_PI} from '../constants/values';\n\nexport default function(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = HALF_PI - 2 * Math.atan(ts);\n  for (var i = 0; i <= 15; i++) {\n    con = eccent * Math.sin(phi);\n    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n  //console.log(\"phi2z has NoConvergence\");\n  return -9999;\n}\n","var C00 = 1;\nvar C02 = 0.25;\nvar C04 = 0.046875;\nvar C06 = 0.01953125;\nvar C08 = 0.01068115234375;\nvar C22 = 0.75;\nvar C44 = 0.46875;\nvar C46 = 0.01302083333333333333;\nvar C48 = 0.00712076822916666666;\nvar C66 = 0.36458333333333333333;\nvar C68 = 0.00569661458333333333;\nvar C88 = 0.3076171875;\n\nexport default function(es) {\n  var en = [];\n  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));\n  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));\n  var t = es * es;\n  en[2] = t * (C44 - es * (C46 + es * C48));\n  t *= es;\n  en[3] = t * (C66 - es * C68);\n  en[4] = t * es * C88;\n  return en;\n}","import pj_mlfn from \"./pj_mlfn\";\nimport {EPSLN} from '../constants/values';\n\nvar MAX_ITER = 20;\n\nexport default function(arg, es, en) {\n  var k = 1 / (1 - es);\n  var phi = arg;\n  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */\n    var s = Math.sin(phi);\n    var t = 1 - es * s * s;\n    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;\n    //phi -= t * (t * Math.sqrt(t)) * k;\n    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;\n    phi -= t;\n    if (Math.abs(t) < EPSLN) {\n      return phi;\n    }\n  }\n  //..reportError(\"cass:pj_inv_mlfn: Convergence error\");\n  return phi;\n}\n","export default function(phi, sphi, cphi, en) {\n  cphi *= sphi;\n  sphi *= sphi;\n  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));\n}","export default function(eccent, sinphi) {\n  var con;\n  if (eccent > 1.0e-7) {\n    con = eccent * sinphi;\n    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));\n  }\n  else {\n    return (2 * sinphi);\n  }\n}","export default function(x) {\n  return x<0 ? -1 : 1;\n}","export default function(x) {\n  var r = Math.exp(x);\n  r = (r - 1 / r) / 2;\n  return r;\n}","export default function(esinp, exp) {\n  return (Math.pow((1 - esinp) / (1 + esinp), exp));\n}","export default function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n}","import {HALF_PI} from '../constants/values';\n\nexport default function(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow(((1 - con) / (1 + con)), com);\n  return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n}\n","var exports = {};\nexport {exports as default};\nexports.wgs84 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"WGS84\",\n  datumName: \"WGS84\"\n};\n\nexports.ch1903 = {\n  towgs84: \"674.374,15.056,405.346\",\n  ellipse: \"bessel\",\n  datumName: \"swiss\"\n};\n\nexports.ggrs87 = {\n  towgs84: \"-199.87,74.79,246.62\",\n  ellipse: \"GRS80\",\n  datumName: \"Greek_Geodetic_Reference_System_1987\"\n};\n\nexports.nad83 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"GRS80\",\n  datumName: \"North_American_Datum_1983\"\n};\n\nexports.nad27 = {\n  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n  ellipse: \"clrk66\",\n  datumName: \"North_American_Datum_1927\"\n};\n\nexports.potsdam = {\n  towgs84: \"606.0,23.0,413.0\",\n  ellipse: \"bessel\",\n  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n};\n\nexports.carthage = {\n  towgs84: \"-263.0,6.0,431.0\",\n  ellipse: \"clark80\",\n  datumName: \"Carthage 1934 Tunisia\"\n};\n\nexports.hermannskogel = {\n  towgs84: \"653.0,-212.0,449.0\",\n  ellipse: \"bessel\",\n  datumName: \"Hermannskogel\"\n};\n\nexports.ire65 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"mod_airy\",\n  datumName: \"Ireland 1965\"\n};\n\nexports.rassadiran = {\n  towgs84: \"-133.63,-157.5,-158.62\",\n  ellipse: \"intl\",\n  datumName: \"Rassadiran\"\n};\n\nexports.nzgd49 = {\n  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n  ellipse: \"intl\",\n  datumName: \"New Zealand Geodetic Datum 1949\"\n};\n\nexports.osgb36 = {\n  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n  ellipse: \"airy\",\n  datumName: \"Airy 1830\"\n};\n\nexports.s_jtsk = {\n  towgs84: \"589,76,480\",\n  ellipse: 'bessel',\n  datumName: 'S-JTSK (Ferro)'\n};\n\nexports.beduaram = {\n  towgs84: '-106,-87,188',\n  ellipse: 'clrk80',\n  datumName: 'Beduaram'\n};\n\nexports.gunung_segara = {\n  towgs84: '-403,684,41',\n  ellipse: 'bessel',\n  datumName: 'Gunung Segara Jakarta'\n};\n\nexports.rnb72 = {\n  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n  ellipse: \"intl\",\n  datumName: \"Reseau National Belge 1972\"\n};\n","var exports = {};\nexport {exports as default};\nexports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: \"MERIT 1983\"\n};\n\nexports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: \"Soviet Geodetic System 85\"\n};\n\nexports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: \"GRS 1980(IUGG, 1980)\"\n};\n\nexports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: \"IAU 1976\"\n};\n\nexports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: \"Airy 1830\"\n};\n\nexports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: \"Appl. Physics. 1965\"\n};\n\nexports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"Naval Weapons Lab., 1965\"\n};\n\nexports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: \"Modified Airy\"\n};\n\nexports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n};\n\nexports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: \"Australian Natl & S. Amer. 1969\"\n};\n\nexports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: \"GRS 67(IUGG 1967)\"\n};\n\nexports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841\"\n};\n\nexports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841 (Namibia)\"\n};\n\nexports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: \"Clarke 1866\"\n};\n\nexports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: \"Clarke 1880 mod.\"\n};\n\nexports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: \"Clarke 1858\"\n};\n\nexports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: \"Comm. des Poids et Mesures 1799\"\n};\n\nexports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: \"Delambre 1810 (Belgium)\"\n};\n\nexports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: \"Engelis 1985\"\n};\n\nexports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: \"Everest 1830\"\n};\n\nexports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: \"Everest 1948\"\n};\n\nexports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: \"Everest 1956\"\n};\n\nexports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: \"Everest 1969\"\n};\n\nexports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: \"Everest (Sabah & Sarawak)\"\n};\n\nexports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: \"Fischer (Mercury Datum) 1960\"\n};\n\nexports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1960\"\n};\n\nexports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1968\"\n};\n\nexports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: \"Helmert 1906\"\n};\n\nexports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: \"Hough\"\n};\n\nexports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: \"International 1909 (Hayford)\"\n};\n\nexports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: \"Kaula 1961\"\n};\n\nexports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: \"Lerch 1979\"\n};\n\nexports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: \"Maupertius 1738\"\n};\n\nexports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: \"New International 1967\"\n};\n\nexports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: \"Plessis 1817 (France)\"\n};\n\nexports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: \"Krassovsky, 1942\"\n};\n\nexports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: \"Southeast Asia\"\n};\n\nexports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: \"Walbeck\"\n};\n\nexports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: \"WGS 60\"\n};\n\nexports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"WGS 66\"\n};\n\nexports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: \"WGS 72\"\n};\n\nexport var WGS84 = exports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: \"WGS 84\"\n};\n\nexports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: \"Normal Sphere (r=6370997)\"\n};\n","var exports = {};\nexport {exports as default};\n\nexports.greenwich = 0.0; //\"0dE\",\nexports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\nexports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\nexports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\nexports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\nexports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\nexports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\nexports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\nexports.ferro = -17.666666666667; //\"17d40'W\",\nexports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\nexports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\nexports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\nexports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\n","export default {\n  ft: {to_meter: 0.3048},\n  'us-ft': {to_meter: 1200 / 3937}\n};\n","export var PJD_3PARAM = 1;\nexport var PJD_7PARAM = 2;\nexport var PJD_WGS84 = 4; // WGS84 or equivalent\nexport var PJD_NODATUM = 5; // WGS84 or equivalent\nexport var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nexport var HALF_PI = Math.PI/2;\n// ellipoid pj_set_ell.c\nexport var SIXTH = 0.1666666666666666667;\n/* 1/6 */\nexport var RA4 = 0.04722222222222222222;\n/* 17/360 */\nexport var RA6 = 0.02215608465608465608;\nexport var EPSLN = (typeof Number.EPSILON === 'undefined') ? 1.0e-10 : Number.EPSILON;\nexport var D2R = 0.01745329251994329577;\nexport var R2D = 57.29577951308232088;\nexport var FORTPI = Math.PI/4;\nexport var TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nexport var SPI = 3.14159265359;\n","import proj from './Proj';\nimport transform from './transform';\nvar wgs84 = proj('WGS84');\n\nfunction transformer(from, to, coords) {\n  var transformedArray;\n  if (Array.isArray(coords)) {\n    transformedArray = transform(from, to, coords);\n    if (coords.length === 3) {\n      return [transformedArray.x, transformedArray.y, transformedArray.z];\n    }\n    else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  }\n  else {\n    return transform(from, to, coords);\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof proj) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return proj(item);\n}\nfunction proj4(fromProj, toProj, coord, retProj) {\n  if(retProj) {\n    return fromProj;\n  }\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === 'undefined') {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  }\n  else {\n    obj = {\n      forward: function (coords) {\n        return transformer(fromProj, toProj, coords);\n      },\n      inverse: function (coords) {\n        return transformer(toProj, fromProj, coords);\n      },\n      info: function () {\n        return {\n          \"a\": toProj.a,\n          \"b\": toProj.b,\n          \"ra\": toProj.R_A,\n          \"proj-name\": toProj.projName\n        };\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\nexport default proj4;","import {PJD_3PARAM, PJD_7PARAM, PJD_WGS84, PJD_NODATUM, SEC_TO_RAD} from './constants/values';\n\nfunction datum(datumCode, datum_params, a, b, es, ep2) {\n  var out = {};\n\n  if (datumCode === undefined || datumCode === 'none') {\n    out.datum_type = PJD_NODATUM;\n  } else {\n    out.datum_type = PJD_WGS84;\n  }\n\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = PJD_3PARAM;\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = PJD_7PARAM;\n        out.datum_params[3] *= SEC_TO_RAD;\n        out.datum_params[4] *= SEC_TO_RAD;\n        out.datum_params[5] *= SEC_TO_RAD;\n        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n  out.a = a; //datum object also uses these values\n  out.b = b;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\n\nexport default datum;\n","'use strict';\nimport {PJD_3PARAM, PJD_7PARAM, HALF_PI} from './constants/values';\nexport function compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexport function geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return null;\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nexport function geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexport function geocentricToWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexport function geocentricFromWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}\n","import {PJD_3PARAM, PJD_7PARAM, PJD_NODATUM} from './constants/values';\n\nimport {geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums} from './datumUtils';\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n  // Do we need to go through geocentric coordinates?\n  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source.es, source.a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n\n}\n","import globals from './global';\nimport parseProj from './projString';\nimport wkt from 'wkt-parser';\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === 'string') {\n      if (def.charAt(0) === '+') {\n        defs[name] = parseProj(arguments[1]);\n      }\n      else {\n        defs[name] = wkt(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === 'string') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if ('EPSG' in name) {\n      defs['EPSG:' + name.EPSG] = name;\n    }\n    else if ('ESRI' in name) {\n      defs['ESRI:' + name.ESRI] = name;\n    }\n    else if ('IAU2000' in name) {\n      defs['IAU2000:' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nglobals(defs);\nexport default defs;\n","import {SIXTH, RA4, RA6, EPSLN} from './constants/values';\nimport {default as Ellipsoid, WGS84} from './constants/Ellipsoid';\nimport match from './match';\n\nexport function eccentricity(a, b, rf, R_A) {\n  var a2 = a * a; // used in geocentric\n  var b2 = b * b; // used in geocentric\n  var es = (a2 - b2) / a2; // e ^ 2\n  var e = 0;\n  if (R_A) {\n    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n    a2 = a * a;\n    es = 0;\n  } else {\n    e = Math.sqrt(es); // eccentricity\n  }\n  var ep2 = (a2 - b2) / b2; // used in geocentric\n  return {\n    es: es,\n    e: e,\n    ep2: ep2\n  };\n}\nexport function sphere(a, b, rf, ellps, sphere) {\n  if (!a) { // do we have an ellipsoid?\n    var ellipse = match(Ellipsoid, ellps);\n    if (!ellipse) {\n      ellipse = WGS84;\n    }\n    a = ellipse.a;\n    b = ellipse.b;\n    rf = ellipse.rf;\n  }\n\n  if (rf && !b) {\n    b = (1.0 - 1.0 / rf) * a;\n  }\n  if (rf === 0 || Math.abs(a - b) < EPSLN) {\n    sphere = true;\n    b = a;\n  }\n  return {\n    a: a,\n    b: b,\n    rf: rf,\n    sphere: sphere\n  };\n}\n","export default function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n}\n","export default function(defs) {\n  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n  defs.WGS84 = defs['EPSG:4326'];\n  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n  defs.GOOGLE = defs['EPSG:3857'];\n  defs['EPSG:900913'] = defs['EPSG:3857'];\n  defs['EPSG:102113'] = defs['EPSG:3857'];\n}\n","import proj4 from './core';\nimport Proj from \"./Proj\";\nimport Point from \"./Point\";\nimport common from \"./common/toPoint\";\nimport defs from \"./defs\";\nimport transform from \"./transform\";\nimport mgrs from \"mgrs\";\nimport version from \"./version\";\nimport includedProjections from \"../projs\";\n\nproj4.defaultDatum = 'WGS84'; //default datum\nproj4.Proj = Proj;\nproj4.WGS84 = new proj4.Proj('WGS84');\nproj4.Point = Point;\nproj4.toPoint = common;\nproj4.defs = defs;\nproj4.transform = transform;\nproj4.mgrs = mgrs;\nproj4.version = version;\nincludedProjections(proj4);\nexport default proj4;\n","var ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nexport default function match(obj, key) {\n  if (obj[key]) {\n    return obj[key];\n  }\n  var keys = Object.keys(obj);\n  var lkey = key.toLowerCase().replace(ignoredChar, '');\n  var i = -1;\n  var testkey, processedKey;\n  while (++i < keys.length) {\n    testkey = keys[i];\n    processedKey = testkey.toLowerCase().replace(ignoredChar, '');\n    if (processedKey === lkey) {\n      return obj[testkey];\n    }\n  }\n}\n","import defs from './defs';\nimport wkt from 'wkt-parser';\nimport projStr from './projString';\nfunction testObj(code){\n  return typeof code === 'string';\n}\nfunction testDef(code){\n  return code in defs;\n}\n var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS']; \nfunction testWKT(code){\n  return codeWords.some(function (word) {\n    return code.indexOf(word) > -1;\n  });\n}\nfunction testProj(code){\n  return code[0] === '+';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return defs[code];\n    }\n    if (testWKT(code)) {\n      return wkt(code);\n    }\n    if (testProj(code)) {\n      return projStr(code);\n    }\n  }else{\n    return code;\n  }\n}\n\nexport default parse;\n","import {D2R} from './constants/values';\nimport PrimeMeridian from './constants/PrimeMeridian';\nimport units from './constants/units';\nimport match from './match';\n\nexport default function(defData) {\n  var self = {};\n  var paramObj = defData.split('+').map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).reduce(function(p, a) {\n    var split = a.split('=');\n    split.push(true);\n    p[split[0].toLowerCase()] = split[1];\n    return p;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: 'projName',\n    datum: 'datumCode',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * D2R;\n    },\n    lat_1: function(v) {\n      self.lat1 = v * D2R;\n    },\n    lat_2: function(v) {\n      self.lat2 = v * D2R;\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * D2R;\n    },\n    lon_0: function(v) {\n      self.long0 = v * D2R;\n    },\n    lon_1: function(v) {\n      self.long1 = v * D2R;\n    },\n    lon_2: function(v) {\n      self.long2 = v * D2R;\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * D2R;\n    },\n    lonc: function(v) {\n      self.longc = v * D2R;\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(\",\").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      var unit = match(units, v);\n      if (unit) {\n        self.to_meter = unit.to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * D2R;\n    },\n    pm: function(v) {\n      var pm = match(PrimeMeridian, v);\n      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;\n    },\n    nadgrids: function(v) {\n      if (v === '@null') {\n        self.datumCode = 'none';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = \"ewnsud\";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === 'function') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n}\n","import merc from \"./projections/merc\";\nimport longlat from \"./projections/longlat\";\nvar projs = [merc, longlat];\nvar names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\nexport {add};\n\nexport function get(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n    return projStore[names[n]];\n  }\n}\n\nexport function start() {\n  projs.forEach(add);\n}\nexport default {\n  start: start,\n  add: add,\n  get: get\n};\n","import msfnz from '../common/msfnz';\nimport qsfnz from '../common/qsfnz';\nimport adjust_lon from '../common/adjust_lon';\nimport asinz from '../common/asinz';\nimport {EPSLN} from '../constants/values';\n\nexport function init() {\n\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e3 = Math.sqrt(this.es);\n\n  this.sin_po = Math.sin(this.lat1);\n  this.cos_po = Math.cos(this.lat1);\n  this.t1 = this.sin_po;\n  this.con = this.sin_po;\n  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat2);\n  this.cos_po = Math.cos(this.lat2);\n  this.t2 = this.sin_po;\n  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat0);\n  this.cos_po = Math.cos(this.lat0);\n  this.t3 = this.sin_po;\n  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);\n  }\n  else {\n    this.ns0 = this.con;\n  }\n  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;\n  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;\n}\n\n/* Albers Conical Equal Area forward equations--mapping lat,long to x,y\n  -------------------------------------------------------------------*/\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  this.sin_phi = Math.sin(lat);\n  this.cos_phi = Math.cos(lat);\n\n  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);\n  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;\n  var theta = this.ns0 * adjust_lon(lon - this.long0);\n  var x = rh1 * Math.sin(theta) + this.x0;\n  var y = this.rh - rh1 * Math.cos(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var rh1, qs, con, theta, lon, lat;\n\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  if (this.ns0 >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n  con = rh1 * this.ns0 / this.a;\n  if (this.sphere) {\n    lat = Math.asin((this.c - con * con) / (2 * this.ns0));\n  }\n  else {\n    qs = (this.c - con * con) / this.ns0;\n    lat = this.phi1z(this.e3, qs);\n  }\n\n  lon = adjust_lon(theta / this.ns0 + this.long0);\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\n/* Function to compute phi1, the latitude for the inverse of the\n   Albers Conical Equal-Area projection.\n-------------------------------------------*/\nexport function phi1z(eccent, qs) {\n  var sinphi, cosphi, con, com, dphi;\n  var phi = asinz(0.5 * qs);\n  if (eccent < EPSLN) {\n    return phi;\n  }\n\n  var eccnts = eccent * eccent;\n  for (var i = 1; i <= 25; i++) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    con = eccent * sinphi;\n    com = 1 - con * con;\n    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi = phi + dphi;\n    if (Math.abs(dphi) <= 1e-7) {\n      return phi;\n    }\n  }\n  return null;\n}\n\nexport var names = [\"Albers_Conic_Equal_Area\", \"Albers\", \"aea\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  phi1z: phi1z\n};\n","import adjust_lon from '../common/adjust_lon';\nimport {HALF_PI, EPSLN} from '../constants/values';\n\nimport mlfn from '../common/mlfn';\nimport e0fn from '../common/e0fn';\nimport e1fn from '../common/e1fn';\nimport e2fn from '../common/e2fn';\nimport e3fn from '../common/e3fn';\nimport gN from '../common/gN';\nimport asinz from '../common/asinz';\nimport imlfn from '../common/imlfn';\n\n\n\nexport function init() {\n  this.sin_p12 = Math.sin(this.lat0);\n  this.cos_p12 = Math.cos(this.lat0);\n}\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinphi = Math.sin(p.y);\n  var cosphi = Math.cos(p.y);\n  var dlon = adjust_lon(lon - this.long0);\n  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;\n  if (this.sphere) {\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North Pole case\n      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);\n      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South Pole case\n      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);\n      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //default case\n      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);\n      c = Math.acos(cos_c);\n      kp = c / Math.sin(c);\n      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);\n      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));\n      return p;\n    }\n  }\n  else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North Pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);\n      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South Pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);\n      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //Default case\n      tanphi = sinphi / cosphi;\n      Nl1 = gN(this.a, this.e, this.sin_p12);\n      Nl = gN(this.a, this.e, sinphi);\n      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));\n      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));\n      if (Az === 0) {\n        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {\n        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else {\n        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));\n      }\n      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);\n      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);\n      GH = G * H;\n      Hs = H * H;\n      s2 = s * s;\n      s3 = s2 * s;\n      s4 = s3 * s;\n      s5 = s4 * s;\n      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);\n      p.x = this.x0 + c * Math.sin(Az);\n      p.y = this.y0 + c * Math.cos(Az);\n      return p;\n    }\n  }\n\n\n}\n\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;\n  if (this.sphere) {\n    rh = Math.sqrt(p.x * p.x + p.y * p.y);\n    if (rh > (2 * HALF_PI * this.a)) {\n      return;\n    }\n    z = rh / this.a;\n\n    sinz = Math.sin(z);\n    cosz = Math.cos(z);\n\n    lon = this.long0;\n    if (Math.abs(rh) <= EPSLN) {\n      lat = this.lat0;\n    }\n    else {\n      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);\n      con = Math.abs(this.lat0) - HALF_PI;\n      if (Math.abs(con) <= EPSLN) {\n        if (this.lat0 >= 0) {\n          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n        }\n        else {\n          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n        }\n      }\n      else {\n        /*con = cosz - this.sin_p12 * Math.sin(lat);\n        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {\n          //no-op, just keep the lon value as is\n        } else {\n          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));\n          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));\n        }*/\n        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));\n      }\n    }\n\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = Mlp - rh;\n      lat = imlfn(M / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = rh - Mlp;\n\n      lat = imlfn(M / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else {\n      //default case\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      Az = Math.atan2(p.x, p.y);\n      N1 = gN(this.a, this.e, this.sin_p12);\n      cosAz = Math.cos(Az);\n      tmp = this.e * this.cos_p12 * cosAz;\n      A = -tmp * tmp / (1 - this.es);\n      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);\n      D = rh / N1;\n      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;\n      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;\n      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);\n      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));\n      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n  }\n\n}\n\nexport var names = [\"Azimuthal_Equidistant\", \"aeqd\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import mlfn from '../common/mlfn';\nimport e0fn from '../common/e0fn';\nimport e1fn from '../common/e1fn';\nimport e2fn from '../common/e2fn';\nimport e3fn from '../common/e3fn';\nimport gN from '../common/gN';\nimport adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport imlfn from '../common/imlfn';\nimport {HALF_PI, EPSLN} from '../constants/values';\n\nexport function init() {\n  if (!this.sphere) {\n    this.e0 = e0fn(this.es);\n    this.e1 = e1fn(this.es);\n    this.e2 = e2fn(this.es);\n    this.e3 = e3fn(this.es);\n    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  }\n}\n\n/* Cassini forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y;\n  var lam = p.x;\n  var phi = p.y;\n  lam = adjust_lon(lam - this.long0);\n\n  if (this.sphere) {\n    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));\n    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);\n  }\n  else {\n    //ellipsoid\n    var sinphi = Math.sin(phi);\n    var cosphi = Math.cos(phi);\n    var nl = gN(this.a, this.e, sinphi);\n    var tl = Math.tan(phi) * Math.tan(phi);\n    var al = lam * Math.cos(phi);\n    var asq = al * al;\n    var cl = this.es * cosphi * cosphi / (1 - this.es);\n    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n\n    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));\n    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);\n\n\n  }\n\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var phi, lam;\n\n  if (this.sphere) {\n    var dd = y + this.lat0;\n    phi = Math.asin(Math.sin(dd) * Math.cos(x));\n    lam = Math.atan2(Math.tan(x), Math.cos(dd));\n  }\n  else {\n    /* ellipsoid */\n    var ml1 = this.ml0 / this.a + y;\n    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);\n    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {\n      p.x = this.long0;\n      p.y = HALF_PI;\n      if (y < 0) {\n        p.y *= -1;\n      }\n      return p;\n    }\n    var nl1 = gN(this.a, this.e, Math.sin(phi1));\n\n    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);\n    var tl1 = Math.pow(Math.tan(phi1), 2);\n    var dl = x * this.a / nl1;\n    var dsq = dl * dl;\n    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);\n    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);\n\n  }\n\n  p.x = adjust_lon(lam + this.long0);\n  p.y = adjust_lat(phi);\n  return p;\n\n}\n\nexport var names = [\"Cassini\", \"Cassini_Soldner\", \"cass\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import adjust_lon from '../common/adjust_lon';\nimport qsfnz from '../common/qsfnz';\nimport msfnz from '../common/msfnz';\nimport iqsfnz from '../common/iqsfnz';\n\n/*\n  reference:\n    \"Cartographic Projection Procedures for the UNIX Environment-\n    A User's Manual\" by Gerald I. Evenden,\n    USGS Open File Report 90-284and Release 4 Interim Reports (2003)\n*/\nexport function init() {\n  //no-op\n  if (!this.sphere) {\n    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n  }\n}\n\n/* Cylindrical Equal Area forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y;\n  /* Forward equations\n      -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  if (this.sphere) {\n    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);\n    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);\n  }\n  else {\n    var qs = qsfnz(this.e, Math.sin(lat));\n    x = this.x0 + this.a * this.k0 * dlon;\n    y = this.y0 + this.a * qs * 0.5 / this.k0;\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));\n    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));\n  }\n  else {\n    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);\n    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"cea\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\n\nexport function init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Equidistant Cylindrical (Plate Carre)\";\n\n  this.rc = Math.cos(this.lat_ts);\n}\n\n// forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  var dlon = adjust_lon(lon - this.long0);\n  var dlat = adjust_lat(lat - this.lat0);\n  p.x = this.x0 + (this.a * dlon * this.rc);\n  p.y = this.y0 + (this.a * dlat);\n  return p;\n}\n\n// inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n\n  var x = p.x;\n  var y = p.y;\n\n  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));\n  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));\n  return p;\n}\n\nexport var names = [\"Equirectangular\", \"Equidistant_Cylindrical\", \"eqc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import e0fn from '../common/e0fn';\nimport e1fn from '../common/e1fn';\nimport e2fn from '../common/e2fn';\nimport e3fn from '../common/e3fn';\nimport msfnz from '../common/msfnz';\nimport mlfn from '../common/mlfn';\nimport adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport imlfn from '../common/imlfn';\nimport {EPSLN} from '../constants/values';\n\nexport function init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.lat2 = this.lat2 || this.lat1;\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n\n  this.sinphi = Math.sin(this.lat1);\n  this.cosphi = Math.cos(this.lat1);\n\n  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);\n  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);\n\n  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {\n    this.ns = this.sinphi;\n  }\n  else {\n    this.sinphi = Math.sin(this.lat2);\n    this.cosphi = Math.cos(this.lat2);\n    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);\n    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);\n    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);\n  }\n  this.g = this.ml1 + this.ms1 / this.ns;\n  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  this.rh = this.a * (this.g - this.ml0);\n}\n\n/* Equidistant Conic forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var rh1;\n\n  /* Forward equations\n      -----------------*/\n  if (this.sphere) {\n    rh1 = this.a * (this.g - lat);\n  }\n  else {\n    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n    rh1 = this.a * (this.g - ml);\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  var x = this.x0 + rh1 * Math.sin(theta);\n  var y = this.y0 + this.rh - rh1 * Math.cos(theta);\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  var con, rh1, lat, lon;\n  if (this.ns >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    lat = adjust_lat(this.g - rh1 / this.a);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    var ml = this.g - rh1 / this.a;\n    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n\n}\n\nexport var names = [\"Equidistant_Conic\", \"eqdc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","// Heavily based on this etmerc projection implementation\n// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js\n\nimport sinh from '../common/sinh';\nimport hypot from '../common/hypot';\nimport asinhy from '../common/asinhy';\nimport gatg from '../common/gatg';\nimport clens from '../common/clens';\nimport clens_cmplx from '../common/clens_cmplx';\nimport adjust_lon from '../common/adjust_lon';\n\nexport function init() {\n  if (this.es === undefined || this.es <= 0) {\n    throw new Error('incorrect elliptical usage');\n  }\n\n  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n  this.cgb = [];\n  this.cbg = [];\n  this.utg = [];\n  this.gtu = [];\n\n  var f = this.es / (1 + Math.sqrt(1 - this.es));\n  var n = f / (2 - f);\n  var np = n;\n\n  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));\n  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));\n\n  np = np * n;\n  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));\n  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));\n\n  np = np * n;\n  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));\n  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));\n\n  np = np * n;\n  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));\n  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));\n\n  np = np * n;\n  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));\n  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));\n\n  np = np * n;\n  this.cgb[5] = np * (601676 / 22275);\n  this.cbg[5] = np * (444337 / 155925);\n\n  np = Math.pow(n, 2);\n  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));\n\n  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));\n  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));\n\n  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));\n  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));\n\n  np = np * n;\n  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));\n  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));\n\n  np = np * n;\n  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));\n  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));\n\n  np = np * n;\n  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));\n  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));\n\n  np = np * n;\n  this.utg[5] = np * (-20648693 / 638668800);\n  this.gtu[5] = np * (212378941 / 319334400);\n\n  var Z = gatg(this.cbg, this.lat0);\n  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));\n}\n\nexport function forward(p) {\n  var Ce = adjust_lon(p.x - this.long0);\n  var Cn = p.y;\n\n  Cn = gatg(this.cbg, Cn);\n  var sin_Cn = Math.sin(Cn);\n  var cos_Cn = Math.cos(Cn);\n  var sin_Ce = Math.sin(Ce);\n  var cos_Ce = Math.cos(Ce);\n\n  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);\n  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));\n  Ce = asinhy(Math.tan(Ce));\n\n  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);\n\n  Cn = Cn + tmp[0];\n  Ce = Ce + tmp[1];\n\n  var x;\n  var y;\n\n  if (Math.abs(Ce) <= 2.623395162778) {\n    x = this.a * (this.Qn * Ce) + this.x0;\n    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;\n  }\n  else {\n    x = Infinity;\n    y = Infinity;\n  }\n\n  p.x = x;\n  p.y = y;\n\n  return p;\n}\n\nexport function inverse(p) {\n  var Ce = (p.x - this.x0) * (1 / this.a);\n  var Cn = (p.y - this.y0) * (1 / this.a);\n\n  Cn = (Cn - this.Zb) / this.Qn;\n  Ce = Ce / this.Qn;\n\n  var lon;\n  var lat;\n\n  if (Math.abs(Ce) <= 2.623395162778) {\n    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);\n\n    Cn = Cn + tmp[0];\n    Ce = Ce + tmp[1];\n    Ce = Math.atan(sinh(Ce));\n\n    var sin_Cn = Math.sin(Cn);\n    var cos_Cn = Math.cos(Cn);\n    var sin_Ce = Math.sin(Ce);\n    var cos_Ce = Math.cos(Ce);\n\n    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));\n    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);\n\n    lon = adjust_lon(Ce + this.long0);\n    lat = gatg(this.cgb, Cn);\n  }\n  else {\n    lon = Infinity;\n    lat = Infinity;\n  }\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nexport var names = [\"Extended_Transverse_Mercator\", \"Extended Transverse Mercator\", \"etmerc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import srat from '../common/srat';\nvar MAX_ITER = 20;\nimport {HALF_PI, FORTPI} from '../constants/values';\n\nexport function init() {\n  var sphi = Math.sin(this.lat0);\n  var cphi = Math.cos(this.lat0);\n  cphi *= cphi;\n  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);\n  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));\n  this.phic0 = Math.asin(sphi / this.C);\n  this.ratexp = 0.5 * this.C * this.e;\n  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));\n}\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;\n  p.x = this.C * lon;\n  return p;\n}\n\nexport function inverse(p) {\n  var DEL_TOL = 1e-14;\n  var lon = p.x / this.C;\n  var lat = p.y;\n  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);\n  for (var i = MAX_ITER; i > 0; --i) {\n    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;\n    if (Math.abs(lat - p.y) < DEL_TOL) {\n      break;\n    }\n    p.y = lat;\n  }\n  /* convergence failed */\n  if (!i) {\n    return null;\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"gauss\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","export function init() {\n  this.isGeocent = true;\n}\n\nfunction identity(pt) {\n  return pt;\n}\nexport {identity as forward};\nexport {identity as inverse};\nexport var names = [\"geocent\"];\nexport default {\n  init: init,\n  forward: identity,\n  inverse: identity,\n  names: names\n};","import adjust_lon from '../common/adjust_lon';\nimport asinz from '../common/asinz';\nimport {EPSLN} from '../constants/values';\n\n/*\n  reference:\n    Wolfram Mathworld \"Gnomonic Projection\"\n    http://mathworld.wolfram.com/GnomonicProjection.html\n    Accessed: 12th November 2009\n  */\nexport function init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n  // Approximation for projecting points to the horizon (infinity)\n  this.infinity_dist = 1000 * this.a;\n  this.rc = 1;\n}\n\n/* Gnomonic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexport function forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g;\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = adjust_lon(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n  }\n  else {\n\n    // Point is in the opposing hemisphere and is unprojectable\n    // We still need to return a reasonable point, so we project\n    // to infinity, on a bearing\n    // equivalent to the northern hemisphere equivalent\n    // This is a reasonable approximation for short shapes and lines that\n    // straddle the horizon.\n\n    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var rh; /* Rho */\n  var sinc, cosc;\n  var c;\n  var lon, lat;\n\n  /* Inverse equations\n      -----------------*/\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n\n  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    c = Math.atan2(rh, this.rc);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n\n    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);\n    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n    lon = adjust_lon(this.long0 + lon);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"gnom\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import adjust_lon from '../common/adjust_lon';\n\nexport function init() {\n  this.a = 6377397.155;\n  this.es = 0.006674372230614;\n  this.e = Math.sqrt(this.es);\n  if (!this.lat0) {\n    this.lat0 = 0.863937979737193;\n  }\n  if (!this.long0) {\n    this.long0 = 0.7417649320975901 - 0.308341501185665;\n  }\n  /* if scale not set default to 0.9999 */\n  if (!this.k0) {\n    this.k0 = 0.9999;\n  }\n  this.s45 = 0.785398163397448; /* 45 */\n  this.s90 = 2 * this.s45;\n  this.fi0 = this.lat0;\n  this.e2 = this.es;\n  this.e = Math.sqrt(this.e2);\n  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));\n  this.uq = 1.04216856380474;\n  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);\n  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);\n  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;\n  this.k1 = this.k0;\n  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));\n  this.s0 = 1.37008346281555;\n  this.n = Math.sin(this.s0);\n  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);\n  this.ad = this.s90 - this.uq;\n}\n\n/* ellipsoid */\n/* calculate xy from lat/lon */\n/* Constants, identical to inverse transform function */\nexport function forward(p) {\n  var gfi, u, deltav, s, d, eps, ro;\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  /* Transformation */\n  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));\n  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);\n  deltav = -delta_lon * this.alfa;\n  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));\n  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));\n  eps = this.n * d;\n  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);\n  p.y = ro * Math.cos(eps) / 1;\n  p.x = ro * Math.sin(eps) / 1;\n\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  return (p);\n}\n\n/* calculate lat/lon from xy */\nexport function inverse(p) {\n  var u, deltav, s, d, eps, ro, fi1;\n  var ok;\n\n  /* Transformation */\n  /* revert y, x*/\n  var tmp = p.x;\n  p.x = p.y;\n  p.y = tmp;\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  ro = Math.sqrt(p.x * p.x + p.y * p.y);\n  eps = Math.atan2(p.y, p.x);\n  d = eps / Math.sin(this.s0);\n  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);\n  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));\n  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));\n  p.x = this.long0 - deltav / this.alfa;\n  fi1 = u;\n  ok = 0;\n  var iter = 0;\n  do {\n    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);\n    if (Math.abs(fi1 - p.y) < 0.0000000001) {\n      ok = 1;\n    }\n    fi1 = p.y;\n    iter += 1;\n  } while (ok === 0 && iter < 15);\n  if (iter >= 15) {\n    return null;\n  }\n\n  return (p);\n}\n\nexport var names = [\"Krovak\", \"krovak\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","\nimport {HALF_PI, EPSLN, FORTPI} from '../constants/values';\n\nimport qsfnz from '../common/qsfnz';\nimport adjust_lon from '../common/adjust_lon';\n\n/*\n  reference\n    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\nexport var S_POLE = 1;\n\nexport var N_POLE = 2;\nexport var EQUIT = 3;\nexport var OBLIQ = 4;\n\n/* Initialize the Lambert Azimuthal Equal Area projection\n  ------------------------------------------------------*/\nexport function init() {\n  var t = Math.abs(this.lat0);\n  if (Math.abs(t - HALF_PI) < EPSLN) {\n    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n  }\n  else if (Math.abs(t) < EPSLN) {\n    this.mode = this.EQUIT;\n  }\n  else {\n    this.mode = this.OBLIQ;\n  }\n  if (this.es > 0) {\n    var sinphi;\n\n    this.qp = qsfnz(this.e, 1);\n    this.mmf = 0.5 / (1 - this.es);\n    this.apa = authset(this.es);\n    switch (this.mode) {\n    case this.N_POLE:\n      this.dd = 1;\n      break;\n    case this.S_POLE:\n      this.dd = 1;\n      break;\n    case this.EQUIT:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      this.dd = 1 / this.rq;\n      this.xmf = 1;\n      this.ymf = 0.5 * this.qp;\n      break;\n    case this.OBLIQ:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      sinphi = Math.sin(this.lat0);\n      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n      this.ymf = (this.xmf = this.rq) / this.dd;\n      this.xmf *= this.dd;\n      break;\n    }\n  }\n  else {\n    if (this.mode === this.OBLIQ) {\n      this.sinph0 = Math.sin(this.lat0);\n      this.cosph0 = Math.cos(this.lat0);\n    }\n  }\n}\n\n/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n  var lam = p.x;\n  var phi = p.y;\n\n  lam = adjust_lon(lam - this.long0);\n  if (this.sphere) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    coslam = Math.cos(lam);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      if (y <= EPSLN) {\n        return null;\n      }\n      y = Math.sqrt(2 / y);\n      x = y * cosphi * Math.sin(lam);\n      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        coslam = -coslam;\n      }\n      if (Math.abs(phi + this.phi0) < EPSLN) {\n        return null;\n      }\n      y = FORTPI - phi * 0.5;\n      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));\n      x = y * Math.sin(lam);\n      y *= coslam;\n    }\n  }\n  else {\n    sinb = 0;\n    cosb = 0;\n    b = 0;\n    coslam = Math.cos(lam);\n    sinlam = Math.sin(lam);\n    sinphi = Math.sin(phi);\n    q = qsfnz(this.e, sinphi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinb = q / this.qp;\n      cosb = Math.sqrt(1 - sinb * sinb);\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n      break;\n    case this.EQUIT:\n      b = 1 + cosb * coslam;\n      break;\n    case this.N_POLE:\n      b = HALF_PI + phi;\n      q = this.qp - q;\n      break;\n    case this.S_POLE:\n      b = phi - HALF_PI;\n      q = this.qp + q;\n      break;\n    }\n    if (Math.abs(b) < EPSLN) {\n      return null;\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n    case this.EQUIT:\n      b = Math.sqrt(2 / b);\n      if (this.mode === this.OBLIQ) {\n        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n      }\n      else {\n        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n      }\n      x = this.xmf * b * cosb * sinlam;\n      break;\n    case this.N_POLE:\n    case this.S_POLE:\n      if (q >= 0) {\n        x = (b = Math.sqrt(q)) * sinlam;\n        y = coslam * ((this.mode === this.S_POLE) ? b : -b);\n      }\n      else {\n        x = y = 0;\n      }\n      break;\n    }\n  }\n\n  p.x = this.a * x + this.x0;\n  p.y = this.a * y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var lam, phi, cCe, sCe, q, rho, ab;\n  if (this.sphere) {\n    var cosz = 0,\n      rh, sinz = 0;\n\n    rh = Math.sqrt(x * x + y * y);\n    phi = rh * 0.5;\n    if (phi > 1) {\n      return null;\n    }\n    phi = 2 * Math.asin(phi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinz = Math.sin(phi);\n      cosz = Math.cos(phi);\n    }\n    switch (this.mode) {\n    case this.EQUIT:\n      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);\n      x *= sinz;\n      y = cosz * rh;\n      break;\n    case this.OBLIQ:\n      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n      x *= sinz * this.cosph0;\n      y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n      break;\n    case this.N_POLE:\n      y = -y;\n      phi = HALF_PI - phi;\n      break;\n    case this.S_POLE:\n      phi -= HALF_PI;\n      break;\n    }\n    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);\n  }\n  else {\n    ab = 0;\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      x /= this.dd;\n      y *= this.dd;\n      rho = Math.sqrt(x * x + y * y);\n      if (rho < EPSLN) {\n        p.x = 0;\n        p.y = this.phi0;\n        return p;\n      }\n      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n      cCe = Math.cos(sCe);\n      x *= (sCe = Math.sin(sCe));\n      if (this.mode === this.OBLIQ) {\n        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n        q = this.qp * ab;\n        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n      }\n      else {\n        ab = y * sCe / rho;\n        q = this.qp * ab;\n        y = rho * cCe;\n      }\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        y = -y;\n      }\n      q = (x * x + y * y);\n      if (!q) {\n        p.x = 0;\n        p.y = this.phi0;\n        return p;\n      }\n      ab = 1 - q / this.qp;\n      if (this.mode === this.S_POLE) {\n        ab = -ab;\n      }\n    }\n    lam = Math.atan2(x, y);\n    phi = authlat(Math.asin(ab), this.apa);\n  }\n\n  p.x = adjust_lon(this.long0 + lam);\n  p.y = phi;\n  return p;\n}\n\n/* determine latitude from authalic latitude */\nvar P00 = 0.33333333333333333333;\n\nvar P01 = 0.17222222222222222222;\nvar P02 = 0.10257936507936507936;\nvar P10 = 0.06388888888888888888;\nvar P11 = 0.06640211640211640211;\nvar P20 = 0.01641501294219154443;\n\nfunction authset(es) {\n  var t;\n  var APA = [];\n  APA[0] = es * P00;\n  t = es * es;\n  APA[0] += t * P01;\n  APA[1] = t * P10;\n  t *= es;\n  APA[0] += t * P02;\n  APA[1] += t * P11;\n  APA[2] = t * P20;\n  return APA;\n}\n\nfunction authlat(beta, APA) {\n  var t = beta + beta;\n  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));\n}\n\nexport var names = [\"Lambert Azimuthal Equal Area\", \"Lambert_Azimuthal_Equal_Area\", \"laea\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  S_POLE: S_POLE,\n  N_POLE: N_POLE,\n  EQUIT: EQUIT,\n  OBLIQ: OBLIQ\n};\n","import msfnz from '../common/msfnz';\nimport tsfnz from '../common/tsfnz';\nimport sign from '../common/sign';\nimport adjust_lon from '../common/adjust_lon';\nimport phi2z from '../common/phi2z';\nimport {HALF_PI, EPSLN} from '../constants/values';\nexport function init() {\n\n  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north\n  //double c_lat;                   /* center latitude                      */\n  //double c_lon;                   /* center longitude                     */\n  //double lat1;                    /* first standard parallel              */\n  //double lat2;                    /* second standard parallel             */\n  //double r_maj;                   /* major axis                           */\n  //double r_min;                   /* minor axis                           */\n  //double false_east;              /* x offset in meters                   */\n  //double false_north;             /* y offset in meters                   */\n\n  if (!this.lat2) {\n    this.lat2 = this.lat1;\n  } //if lat2 is not defined\n  if (!this.k0) {\n    this.k0 = 1;\n  }\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n\n  var temp = this.b / this.a;\n  this.e = Math.sqrt(1 - temp * temp);\n\n  var sin1 = Math.sin(this.lat1);\n  var cos1 = Math.cos(this.lat1);\n  var ms1 = msfnz(this.e, sin1, cos1);\n  var ts1 = tsfnz(this.e, this.lat1, sin1);\n\n  var sin2 = Math.sin(this.lat2);\n  var cos2 = Math.cos(this.lat2);\n  var ms2 = msfnz(this.e, sin2, cos2);\n  var ts2 = tsfnz(this.e, this.lat2, sin2);\n\n  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n  }\n  else {\n    this.ns = sin1;\n  }\n  if (isNaN(this.ns)) {\n    this.ns = sin1;\n  }\n  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n  if (!this.title) {\n    this.title = \"Lambert Conformal Conic\";\n  }\n}\n\n// Lambert Conformal conic forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  // singular cases :\n  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n    lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n  }\n\n  var con = Math.abs(Math.abs(lat) - HALF_PI);\n  var ts, rh1;\n  if (con > EPSLN) {\n    ts = tsfnz(this.e, lat, Math.sin(lat));\n    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n  }\n  else {\n    con = lat * this.ns;\n    if (con <= 0) {\n      return null;\n    }\n    rh1 = 0;\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n\n  return p;\n}\n\n// Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n\n  var rh1, con, ts;\n  var lat, lon;\n  var x = (p.x - this.x0) / this.k0;\n  var y = (this.rh - (p.y - this.y0) / this.k0);\n  if (this.ns > 0) {\n    rh1 = Math.sqrt(x * x + y * y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(x * x + y * y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2((con * x), (con * y));\n  }\n  if ((rh1 !== 0) || (this.ns > 0)) {\n    con = 1 / this.ns;\n    ts = Math.pow((rh1 / (this.a * this.f0)), con);\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  else {\n    lat = -HALF_PI;\n  }\n  lon = adjust_lon(theta / this.ns + this.long0);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Lambert Tangential Conformal Conic Projection\", \"Lambert_Conformal_Conic\", \"Lambert_Conformal_Conic_2SP\", \"lcc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","export function init() {\n  //no-op for longlat\n}\n\nfunction identity(pt) {\n  return pt;\n}\nexport {identity as forward};\nexport {identity as inverse};\nexport var names = [\"longlat\", \"identity\"];\nexport default {\n  init: init,\n  forward: identity,\n  inverse: identity,\n  names: names\n};\n","import msfnz from '../common/msfnz';\n\nimport adjust_lon from '../common/adjust_lon';\nimport tsfnz from '../common/tsfnz';\nimport phi2z from '../common/phi2z';\nimport {FORTPI, R2D, EPSLN, HALF_PI} from '../constants/values';\nexport function init() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!('x0' in this)){\n    this.x0 = 0;\n  }\n  if(!('y0' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n}\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n}\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nexport function inverse(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import adjust_lon from '../common/adjust_lon';\n\n/*\n  reference\n    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\n\n/* Initialize the Miller Cylindrical projection\n  -------------------------------------------*/\nexport function init() {\n  //no-op\n}\n\n/* Miller Cylindrical forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  var x = this.x0 + this.a * dlon;\n  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Miller Cylindrical inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n\n  var lon = adjust_lon(this.long0 + p.x / this.a);\n  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Miller_Cylindrical\", \"mill\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import adjust_lon from '../common/adjust_lon';\nexport function init() {}\nimport {EPSLN} from '../constants/values';\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  for (var i = 0; true; i++) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n  if (lon < (-Math.PI)) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mollweide\", \"moll\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import {SEC_TO_RAD} from '../constants/values';\n\n/*\n  reference\n    Department of Land and Survey Technical Circular 1973/32\n      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n    OSG Technical Report 4.1\n      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n  */\n\n/**\n * iterations: Number of iterations to refine inverse transform.\n *     0 -> km accuracy\n *     1 -> m accuracy -- suitable for most mapping applications\n *     2 -> mm accuracy\n */\nexport var iterations = 1;\n\nexport function init() {\n  this.A = [];\n  this.A[1] = 0.6399175073;\n  this.A[2] = -0.1358797613;\n  this.A[3] = 0.063294409;\n  this.A[4] = -0.02526853;\n  this.A[5] = 0.0117879;\n  this.A[6] = -0.0055161;\n  this.A[7] = 0.0026906;\n  this.A[8] = -0.001333;\n  this.A[9] = 0.00067;\n  this.A[10] = -0.00034;\n\n  this.B_re = [];\n  this.B_im = [];\n  this.B_re[1] = 0.7557853228;\n  this.B_im[1] = 0;\n  this.B_re[2] = 0.249204646;\n  this.B_im[2] = 0.003371507;\n  this.B_re[3] = -0.001541739;\n  this.B_im[3] = 0.041058560;\n  this.B_re[4] = -0.10162907;\n  this.B_im[4] = 0.01727609;\n  this.B_re[5] = -0.26623489;\n  this.B_im[5] = -0.36249218;\n  this.B_re[6] = -0.6870983;\n  this.B_im[6] = -1.1651967;\n\n  this.C_re = [];\n  this.C_im = [];\n  this.C_re[1] = 1.3231270439;\n  this.C_im[1] = 0;\n  this.C_re[2] = -0.577245789;\n  this.C_im[2] = -0.007809598;\n  this.C_re[3] = 0.508307513;\n  this.C_im[3] = -0.112208952;\n  this.C_re[4] = -0.15094762;\n  this.C_im[4] = 0.18200602;\n  this.C_re[5] = 1.01418179;\n  this.C_im[5] = 1.64497696;\n  this.C_re[6] = 1.9660549;\n  this.C_im[6] = 2.5127645;\n\n  this.D = [];\n  this.D[1] = 1.5627014243;\n  this.D[2] = 0.5185406398;\n  this.D[3] = -0.03333098;\n  this.D[4] = -0.1052906;\n  this.D[5] = -0.0368594;\n  this.D[6] = 0.007317;\n  this.D[7] = 0.01220;\n  this.D[8] = 0.00394;\n  this.D[9] = -0.0013;\n}\n\n/**\n    New Zealand Map Grid Forward  - long/lat to x/y\n    long/lat in radians\n  */\nexport function forward(p) {\n  var n;\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lat = lat - this.lat0;\n  var delta_lon = lon - this.long0;\n\n  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;\n  var d_lambda = delta_lon;\n  var d_phi_n = 1; // d_phi^0\n\n  var d_psi = 0;\n  for (n = 1; n <= 10; n++) {\n    d_phi_n = d_phi_n * d_phi;\n    d_psi = d_psi + this.A[n] * d_phi_n;\n  }\n\n  // 2. Calculate theta\n  var th_re = d_psi;\n  var th_im = d_lambda;\n\n  // 3. Calculate z\n  var th_n_re = 1;\n  var th_n_im = 0; // theta^0\n  var th_n_re1;\n  var th_n_im1;\n\n  var z_re = 0;\n  var z_im = 0;\n  for (n = 1; n <= 6; n++) {\n    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n    th_n_re = th_n_re1;\n    th_n_im = th_n_im1;\n    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n  }\n\n  // 4. Calculate easting and northing\n  p.x = (z_im * this.a) + this.x0;\n  p.y = (z_re * this.a) + this.y0;\n\n  return p;\n}\n\n/**\n    New Zealand Map Grid Inverse  -  x/y to long/lat\n  */\nexport function inverse(p) {\n  var n;\n  var x = p.x;\n  var y = p.y;\n\n  var delta_x = x - this.x0;\n  var delta_y = y - this.y0;\n\n  // 1. Calculate z\n  var z_re = delta_y / this.a;\n  var z_im = delta_x / this.a;\n\n  // 2a. Calculate theta - first approximation gives km accuracy\n  var z_n_re = 1;\n  var z_n_im = 0; // z^0\n  var z_n_re1;\n  var z_n_im1;\n\n  var th_re = 0;\n  var th_im = 0;\n  for (n = 1; n <= 6; n++) {\n    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n    z_n_re = z_n_re1;\n    z_n_im = z_n_im1;\n    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n  }\n\n  // 2b. Iterate to refine the accuracy of the calculation\n  //        0 iterations gives km accuracy\n  //        1 iteration gives m accuracy -- good enough for most mapping applications\n  //        2 iterations bives mm accuracy\n  for (var i = 0; i < this.iterations; i++) {\n    var th_n_re = th_re;\n    var th_n_im = th_im;\n    var th_n_re1;\n    var th_n_im1;\n\n    var num_re = z_re;\n    var num_im = z_im;\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    th_n_re = 1;\n    th_n_im = 0;\n    var den_re = this.B_re[1];\n    var den_im = this.B_im[1];\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    // Complex division\n    var den2 = den_re * den_re + den_im * den_im;\n    th_re = (num_re * den_re + num_im * den_im) / den2;\n    th_im = (num_im * den_re - num_re * den_im) / den2;\n  }\n\n  // 3. Calculate d_phi              ...                                    // and d_lambda\n  var d_psi = th_re;\n  var d_lambda = th_im;\n  var d_psi_n = 1; // d_psi^0\n\n  var d_phi = 0;\n  for (n = 1; n <= 9; n++) {\n    d_psi_n = d_psi_n * d_psi;\n    d_phi = d_phi + this.D[n] * d_psi_n;\n  }\n\n  // 4. Calculate latitude and longitude\n  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);\n  var lon = this.long0 + d_lambda;\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nexport var names = [\"New_Zealand_Map_Grid\", \"nzmg\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import tsfnz from '../common/tsfnz';\nimport adjust_lon from '../common/adjust_lon';\nimport phi2z from '../common/phi2z';\nimport {EPSLN, HALF_PI, FORTPI} from '../constants/values';\n\n/* Initialize the Oblique Mercator  projection\n    ------------------------------------------*/\nexport function init() {\n  this.no_off = this.no_off || false;\n  this.no_rot = this.no_rot || false;\n\n  if (isNaN(this.k0)) {\n    this.k0 = 1;\n  }\n  var sinlat = Math.sin(this.lat0);\n  var coslat = Math.cos(this.lat0);\n  var con = this.e * sinlat;\n\n  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));\n  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);\n  var t0 = tsfnz(this.e, this.lat0, sinlat);\n  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));\n  if (dl * dl < 1) {\n    dl = 1;\n  }\n  var fl;\n  var gl;\n  if (!isNaN(this.longc)) {\n    //Central point and azimuth method\n\n    if (this.lat0 >= 0) {\n      fl = dl + Math.sqrt(dl * dl - 1);\n    }\n    else {\n      fl = dl - Math.sqrt(dl * dl - 1);\n    }\n    this.el = fl * Math.pow(t0, this.bl);\n    gl = 0.5 * (fl - 1 / fl);\n    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);\n    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;\n\n  }\n  else {\n    //2 points method\n    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));\n    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));\n    if (this.lat0 >= 0) {\n      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n    }\n    else {\n      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n    }\n    var hl = Math.pow(t1, this.bl);\n    var ll = Math.pow(t2, this.bl);\n    fl = this.el / hl;\n    gl = 0.5 * (fl - 1 / fl);\n    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);\n    var pl = (ll - hl) / (ll + hl);\n    var dlon12 = adjust_lon(this.long1 - this.long2);\n    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;\n    this.long0 = adjust_lon(this.long0);\n    var dlon10 = adjust_lon(this.long1 - this.long0);\n    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);\n    this.alpha = Math.asin(dl * Math.sin(this.gamma0));\n  }\n\n  if (this.no_off) {\n    this.uc = 0;\n  }\n  else {\n    if (this.lat0 >= 0) {\n      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n    }\n    else {\n      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n    }\n  }\n\n}\n\n/* Oblique Mercator forward equations--mapping lat,long to x,y\n    ----------------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var dlon = adjust_lon(lon - this.long0);\n  var us, vs;\n  var con;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    if (lat > 0) {\n      con = -1;\n    }\n    else {\n      con = 1;\n    }\n    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));\n    us = -1 * con * HALF_PI * this.al / this.bl;\n  }\n  else {\n    var t = tsfnz(this.e, lat, Math.sin(lat));\n    var ql = this.el / Math.pow(t, this.bl);\n    var sl = 0.5 * (ql - 1 / ql);\n    var tl = 0.5 * (ql + 1 / ql);\n    var vl = Math.sin(this.bl * (dlon));\n    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;\n    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {\n      vs = Number.POSITIVE_INFINITY;\n    }\n    else {\n      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;\n    }\n    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {\n      us = this.al * this.bl * (dlon);\n    }\n    else {\n      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;\n    }\n  }\n\n  if (this.no_rot) {\n    p.x = this.x0 + us;\n    p.y = this.y0 + vs;\n  }\n  else {\n\n    us -= this.uc;\n    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);\n    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);\n  }\n  return p;\n}\n\nexport function inverse(p) {\n  var us, vs;\n  if (this.no_rot) {\n    vs = p.y - this.y0;\n    us = p.x - this.x0;\n  }\n  else {\n    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);\n    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);\n    us += this.uc;\n  }\n  var qp = Math.exp(-1 * this.bl * vs / this.al);\n  var sp = 0.5 * (qp - 1 / qp);\n  var tp = 0.5 * (qp + 1 / qp);\n  var vp = Math.sin(this.bl * us / this.al);\n  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;\n  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);\n  if (Math.abs(up - 1) < EPSLN) {\n    p.x = this.long0;\n    p.y = HALF_PI;\n  }\n  else if (Math.abs(up + 1) < EPSLN) {\n    p.x = this.long0;\n    p.y = -1 * HALF_PI;\n  }\n  else {\n    p.y = phi2z(this.e, ts);\n    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);\n  }\n  return p;\n}\n\nexport var names = [\"Hotine_Oblique_Mercator\", \"Hotine Oblique Mercator\", \"Hotine_Oblique_Mercator_Azimuth_Natural_Origin\", \"Hotine_Oblique_Mercator_Azimuth_Center\", \"omerc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import adjust_lon from '../common/adjust_lon';\nimport asinz from '../common/asinz';\nimport {EPSLN, HALF_PI} from '../constants/values';\n\nexport function init() {\n  //double temp;      /* temporary variable    */\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n}\n\n/* Orthographic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexport function forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g, x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = adjust_lon(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n    x = this.a * ksp * cosphi * Math.sin(dlon);\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var rh; /* height above ellipsoid      */\n  var z; /* angle          */\n  var sinz, cosz; /* sin of z and cos of z      */\n  var con;\n  var lon, lat;\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  z = asinz(rh / this.a);\n\n  sinz = Math.sin(z);\n  cosz = Math.cos(z);\n\n  lon = this.long0;\n  if (Math.abs(rh) <= EPSLN) {\n    lat = this.lat0;\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);\n  con = Math.abs(this.lat0) - HALF_PI;\n  if (Math.abs(con) <= EPSLN) {\n    if (this.lat0 >= 0) {\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n    }\n    else {\n      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"ortho\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import e0fn from '../common/e0fn';\nimport e1fn from '../common/e1fn';\nimport e2fn from '../common/e2fn';\nimport e3fn from '../common/e3fn';\nimport adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport mlfn from '../common/mlfn';\nimport {EPSLN} from '../constants/values';\n\nimport gN from '../common/gN';\nvar MAX_ITER = 20;\n\nexport function init() {\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas\n}\n\n/* Polyconic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y, el;\n  var dlon = adjust_lon(lon - this.long0);\n  el = dlon * Math.sin(lat);\n  if (this.sphere) {\n    if (Math.abs(lat) <= EPSLN) {\n      x = this.a * dlon;\n      y = -1 * this.a * this.lat0;\n    }\n    else {\n      x = this.a * Math.sin(el) / Math.tan(lat);\n      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));\n    }\n  }\n  else {\n    if (Math.abs(lat) <= EPSLN) {\n      x = this.a * dlon;\n      y = -1 * this.ml0;\n    }\n    else {\n      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);\n      x = nl * Math.sin(el);\n      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));\n    }\n\n  }\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  var lon, lat, x, y, i;\n  var al, bl;\n  var phi, dphi;\n  x = p.x - this.x0;\n  y = p.y - this.y0;\n\n  if (this.sphere) {\n    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {\n      lon = adjust_lon(x / this.a + this.long0);\n      lat = 0;\n    }\n    else {\n      al = this.lat0 + y / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var tanphi;\n      for (i = MAX_ITER; i; --i) {\n        tanphi = Math.tan(phi);\n        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);\n        phi += dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));\n    }\n  }\n  else {\n    if (Math.abs(y + this.ml0) <= EPSLN) {\n      lat = 0;\n      lon = adjust_lon(this.long0 + x / this.a);\n    }\n    else {\n\n      al = (this.ml0 + y) / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var cl, mln, mlnp, ma;\n      var con;\n      for (i = MAX_ITER; i; --i) {\n        con = this.e * Math.sin(phi);\n        cl = Math.sqrt(1 - con * con) * Math.tan(phi);\n        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);\n        ma = mln / this.a;\n        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);\n        phi -= dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n\n      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);\n      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);\n      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Polyconic\", \"poly\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\nimport {EPSLN, TWO_PI, SPI, HALF_PI, FORTPI} from '../constants/values';\n\n/* constants */\nvar FACE_ENUM = {\n    FRONT: 1,\n    RIGHT: 2,\n    BACK: 3,\n    LEFT: 4,\n    TOP: 5,\n    BOTTOM: 6\n};\n\nvar AREA_ENUM = {\n    AREA_0: 1,\n    AREA_1: 2,\n    AREA_2: 3,\n    AREA_3: 4\n};\n\nexport function init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n\n  /* Determine the cube face from the center of projection. */\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\n\n// QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n  var xy = {x: 0, y: 0};\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n  var area = {value: 0};\n\n  // move lon according to projection's lon\n  p.x -= this.long0;\n\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n  if (this.es !== 0) {//if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n  lon = p.x; //lon = lp.lam;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = (lon > 0.0 ? lon - SPI : lon + SPI);\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n  /* Apply the result to the real area. */\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n\n  /* Now compute x, y from mu and nu */\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n}\n\n// QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n  var lp = {lam: 0, phi: 0};\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {value: 0};\n\n  /* de-offset */\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = (mu < 0.0 ? mu + SPI : mu - SPI);\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n  t = (SPI / 12) * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = theta;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);\n    }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n    t += s * s;\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = (lp.phi < 0 ? 1 : 0);\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n  return theta;\n}\n\n/* Helper function: shift the longitude. */\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n  return slon;\n}\n\nexport var names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n","import adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport pj_enfn from '../common/pj_enfn';\nvar MAX_ITER = 20;\nimport pj_mlfn from '../common/pj_mlfn';\nimport pj_inv_mlfn from '../common/pj_inv_mlfn';\nimport {EPSLN, HALF_PI} from '../constants/values';\n\nimport asinz from '../common/asinz';\n\n\nexport function init() {\n  /* Place parameters in static storage for common use\n    -------------------------------------------------*/\n\n\n  if (!this.sphere) {\n    this.en = pj_enfn(this.es);\n  }\n  else {\n    this.n = 1;\n    this.m = 0;\n    this.es = 0;\n    this.C_y = Math.sqrt((this.m + 1) / this.n);\n    this.C_x = this.C_y / (this.m + 1);\n  }\n\n}\n\n/* Sinusoidal forward equations--mapping lat,long to x,y\n  -----------------------------------------------------*/\nexport function forward(p) {\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n    -----------------*/\n  lon = adjust_lon(lon - this.long0);\n\n  if (this.sphere) {\n    if (!this.m) {\n      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n    }\n    else {\n      var k = this.n * Math.sin(lat);\n      for (var i = MAX_ITER; i; --i) {\n        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n        lat -= V;\n        if (Math.abs(V) < EPSLN) {\n          break;\n        }\n      }\n    }\n    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n    y = this.a * this.C_y * lat;\n\n  }\n  else {\n\n    var s = Math.sin(lat);\n    var c = Math.cos(lat);\n    y = this.a * pj_mlfn(lat, s, c, this.en);\n    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var lat, temp, lon, s;\n\n  p.x -= this.x0;\n  lon = p.x / this.a;\n  p.y -= this.y0;\n  lat = p.y / this.a;\n\n  if (this.sphere) {\n    lat /= this.C_y;\n    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n    if (this.m) {\n      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n    }\n    else if (this.n !== 1) {\n      lat = asinz(Math.sin(lat) / this.n);\n    }\n    lon = adjust_lon(lon + this.long0);\n    lat = adjust_lat(lat);\n  }\n  else {\n    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);\n    s = Math.abs(lat);\n    if (s < HALF_PI) {\n      s = Math.sin(lat);\n      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));\n      //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n      lon = adjust_lon(temp);\n    }\n    else if ((s - EPSLN) < HALF_PI) {\n      lon = this.long0;\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Sinusoidal\", \"sinu\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","/*\n  references:\n    Formules et constantes pour le Calcul pour la\n    projection cylindrique conforme à axe oblique et pour la transformation entre\n    des systèmes de référence.\n    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf\n  */\n\nexport function init() {\n  var phy0 = this.lat0;\n  this.lambda0 = this.long0;\n  var sinPhy0 = Math.sin(phy0);\n  var semiMajorAxis = this.a;\n  var invF = this.rf;\n  var flattening = 1 / invF;\n  var e2 = 2 * flattening - Math.pow(flattening, 2);\n  var e = this.e = Math.sqrt(e2);\n  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));\n  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));\n  this.b0 = Math.asin(sinPhy0 / this.alpha);\n  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));\n  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));\n  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));\n  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;\n}\n\nexport function forward(p) {\n  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));\n  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));\n  var S = -this.alpha * (Sa1 + Sa2) + this.K;\n\n  // spheric latitude\n  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);\n\n  // spheric longitude\n  var I = this.alpha * (p.x - this.lambda0);\n\n  // psoeudo equatorial rotation\n  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));\n\n  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));\n\n  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;\n  p.x = this.R * rotI + this.x0;\n  return p;\n}\n\nexport function inverse(p) {\n  var Y = p.x - this.x0;\n  var X = p.y - this.y0;\n\n  var rotI = Y / this.R;\n  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);\n\n  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));\n  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));\n\n  var lambda = this.lambda0 + I / this.alpha;\n\n  var S = 0;\n  var phy = b;\n  var prevPhy = -1000;\n  var iteration = 0;\n  while (Math.abs(phy - prevPhy) > 0.0000001) {\n    if (++iteration > 20) {\n      //...reportError(\"omercFwdInfinity\");\n      return;\n    }\n    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));\n    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));\n    prevPhy = phy;\n    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;\n  }\n\n  p.x = lambda;\n  p.y = phy;\n  return p;\n}\n\nexport var names = [\"somerc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import {EPSLN, HALF_PI} from '../constants/values';\n\nimport sign from '../common/sign';\nimport msfnz from '../common/msfnz';\nimport tsfnz from '../common/tsfnz';\nimport phi2z from '../common/phi2z';\nimport adjust_lon from '../common/adjust_lon';\n\nexport function ssfn_(phit, sinphi, eccen) {\n  sinphi *= eccen;\n  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));\n}\n\nexport function init() {\n  this.coslat0 = Math.cos(this.lat0);\n  this.sinlat0 = Math.sin(this.lat0);\n  if (this.sphere) {\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));\n    }\n  }\n  else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (this.lat0 > 0) {\n        //North pole\n        //trace('stere:north pole');\n        this.con = 1;\n      }\n      else {\n        //South pole\n        //trace('stere:south pole');\n        this.con = -1;\n      }\n    }\n    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));\n    }\n    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);\n    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;\n    this.cosX0 = Math.cos(this.X0);\n    this.sinX0 = Math.sin(this.X0);\n  }\n}\n\n// Stereographic forward equations--mapping lat,long to x,y\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinlat = Math.sin(lat);\n  var coslat = Math.cos(lat);\n  var A, X, sinX, cosX, ts, rh;\n  var dlon = adjust_lon(lon - this.long0);\n\n  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {\n    //case of the origine point\n    //trace('stere:this is the origin point');\n    p.x = NaN;\n    p.y = NaN;\n    return p;\n  }\n  if (this.sphere) {\n    //trace('stere:sphere case');\n    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));\n    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;\n    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;\n    return p;\n  }\n  else {\n    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;\n    cosX = Math.cos(X);\n    sinX = Math.sin(X);\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);\n      rh = 2 * this.a * this.k0 * ts / this.cons;\n      p.x = this.x0 + rh * Math.sin(lon - this.long0);\n      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);\n      //trace(p.toString());\n      return p;\n    }\n    else if (Math.abs(this.sinlat0) < EPSLN) {\n      //Eq\n      //trace('stere:equateur');\n      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));\n      p.y = A * sinX;\n    }\n    else {\n      //other case\n      //trace('stere:normal case');\n      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));\n      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;\n    }\n    p.x = A * cosX * Math.sin(dlon) + this.x0;\n  }\n  //trace(p.toString());\n  return p;\n}\n\n//* Stereographic inverse equations--mapping x,y to lat/long\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat, ts, ce, Chi;\n  var rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  if (this.sphere) {\n    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));\n    lon = this.long0;\n    lat = this.lat0;\n    if (rh <= EPSLN) {\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);\n    if (Math.abs(this.coslat0) < EPSLN) {\n      if (this.lat0 > 0) {\n        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      }\n      else {\n        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n      }\n    }\n    else {\n      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (rh <= EPSLN) {\n        lat = this.lat0;\n        lon = this.long0;\n        p.x = lon;\n        p.y = lat;\n        //trace(p.toString());\n        return p;\n      }\n      p.x *= this.con;\n      p.y *= this.con;\n      ts = rh * this.cons / (2 * this.a * this.k0);\n      lat = this.con * phi2z(this.e, ts);\n      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));\n    }\n    else {\n      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));\n      lon = this.long0;\n      if (rh <= EPSLN) {\n        Chi = this.X0;\n      }\n      else {\n        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);\n        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));\n      }\n      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n\n  //trace(p.toString());\n  return p;\n\n}\n\nexport var names = [\"stere\", \"Stereographic_South_Pole\", \"Polar Stereographic (variant B)\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  ssfn_: ssfn_\n};\n","import gauss from './gauss';\nimport adjust_lon from '../common/adjust_lon';\n\nexport function init() {\n  gauss.init.apply(this);\n  if (!this.rc) {\n    return;\n  }\n  this.sinc0 = Math.sin(this.phic0);\n  this.cosc0 = Math.cos(this.phic0);\n  this.R2 = 2 * this.rc;\n  if (!this.title) {\n    this.title = \"Oblique Stereographic Alternative\";\n  }\n}\n\nexport function forward(p) {\n  var sinc, cosc, cosl, k;\n  p.x = adjust_lon(p.x - this.long0);\n  gauss.forward.apply(this, [p]);\n  sinc = Math.sin(p.y);\n  cosc = Math.cos(p.y);\n  cosl = Math.cos(p.x);\n  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);\n  p.x = k * cosc * Math.sin(p.x);\n  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);\n  p.x = this.a * p.x + this.x0;\n  p.y = this.a * p.y + this.y0;\n  return p;\n}\n\nexport function inverse(p) {\n  var sinc, cosc, lon, lat, rho;\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    var c = 2 * Math.atan2(rho, this.R2);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);\n    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  gauss.inverse.apply(this, [p]);\n  p.x = adjust_lon(p.x + this.long0);\n  return p;\n}\n\nexport var names = [\"Stereographic_North_Pole\", \"Oblique_Stereographic\", \"Polar_Stereographic\", \"sterea\",\"Oblique Stereographic Alternative\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","// Heavily based on this tmerc projection implementation\n// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js\n\nimport pj_enfn from '../common/pj_enfn';\nimport pj_mlfn from '../common/pj_mlfn';\nimport pj_inv_mlfn from '../common/pj_inv_mlfn';\nimport adjust_lon from '../common/adjust_lon';\n\nimport {EPSLN, HALF_PI} from '../constants/values';\nimport sign from '../common/sign';\n\nexport function init() {\n  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n  if (this.es) {\n    this.en = pj_enfn(this.es);\n    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);\n  }\n}\n\n/**\n    Transverse Mercator Forward  - long/lat to x/y\n    long/lat in radians\n  */\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var con;\n  var x, y;\n  var sin_phi = Math.sin(lat);\n  var cos_phi = Math.cos(lat);\n\n  if (!this.es) {\n    var b = cos_phi * Math.sin(delta_lon);\n\n    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {\n      return (93);\n    }\n    else {\n      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;\n      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));\n      b = Math.abs(y);\n\n      if (b >= 1) {\n        if ((b - 1) > EPSLN) {\n          return (93);\n        }\n        else {\n          y = 0;\n        }\n      }\n      else {\n        y = Math.acos(y);\n      }\n\n      if (lat < 0) {\n        y = -y;\n      }\n\n      y = this.a * this.k0 * (y - this.lat0) + this.y0;\n    }\n  }\n  else {\n    var al = cos_phi * delta_lon;\n    var als = Math.pow(al, 2);\n    var c = this.ep2 * Math.pow(cos_phi, 2);\n    var cs = Math.pow(c, 2);\n    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;\n    var t = Math.pow(tq, 2);\n    var ts = Math.pow(t, 2);\n    con = 1 - this.es * Math.pow(sin_phi, 2);\n    al = al / Math.sqrt(con);\n    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);\n\n    x = this.a * (this.k0 * al * (1 +\n      als / 6 * (1 - t + c +\n      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +\n      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +\n      this.x0;\n\n    y = this.a * (this.k0 * (ml - this.ml0 +\n      sin_phi * delta_lon * al / 2 * (1 +\n      als / 12 * (5 - t + 9 * c + 4 * cs +\n      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +\n      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +\n      this.y0;\n  }\n\n  p.x = x;\n  p.y = y;\n\n  return p;\n}\n\n/**\n    Transverse Mercator Inverse  -  x/y to long/lat\n  */\nexport function inverse(p) {\n  var con, phi;\n  var lat, lon;\n  var x = (p.x - this.x0) * (1 / this.a);\n  var y = (p.y - this.y0) * (1 / this.a);\n\n  if (!this.es) {\n    var f = Math.exp(x / this.k0);\n    var g = 0.5 * (f - 1 / f);\n    var temp = this.lat0 + y / this.k0;\n    var h = Math.cos(temp);\n    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));\n    lat = Math.asin(con);\n\n    if (y < 0) {\n      lat = -lat;\n    }\n\n    if ((g === 0) && (h === 0)) {\n      lon = 0;\n    }\n    else {\n      lon = adjust_lon(Math.atan2(g, h) + this.long0);\n    }\n  }\n  else { // ellipsoidal form\n    con = this.ml0 + y / this.k0;\n    phi = pj_inv_mlfn(con, this.es, this.en);\n\n    if (Math.abs(phi) < HALF_PI) {\n      var sin_phi = Math.sin(phi);\n      var cos_phi = Math.cos(phi);\n      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;\n      var c = this.ep2 * Math.pow(cos_phi, 2);\n      var cs = Math.pow(c, 2);\n      var t = Math.pow(tan_phi, 2);\n      var ts = Math.pow(t, 2);\n      con = 1 - this.es * Math.pow(sin_phi, 2);\n      var d = x * Math.sqrt(con) / this.k0;\n      var ds = Math.pow(d, 2);\n      con = con * tan_phi;\n\n      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -\n        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -\n        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -\n        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));\n\n      lon = adjust_lon(this.long0 + (d * (1 -\n        ds / 6 * (1 + 2 * t + c -\n        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -\n        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));\n    }\n    else {\n      lat = HALF_PI * sign(y);\n      lon = 0;\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nexport var names = [\"Transverse_Mercator\", \"Transverse Mercator\", \"tmerc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import adjust_zone from '../common/adjust_zone';\nimport etmerc from './etmerc';\nexport var dependsOn = 'etmerc';\nimport {D2R} from '../constants/values';\n\n\nexport function init() {\n  var zone = adjust_zone(this.zone, this.long0);\n  if (zone === undefined) {\n    throw new Error('unknown utm zone');\n  }\n  this.lat0 = 0;\n  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;\n  this.x0 = 500000;\n  this.y0 = this.utmSouth ? 10000000 : 0;\n  this.k0 = 0.9996;\n\n  etmerc.init.apply(this);\n  this.forward = etmerc.forward;\n  this.inverse = etmerc.inverse;\n}\n\nexport var names = [\"Universal Transverse Mercator System\", \"utm\"];\nexport default {\n  init: init,\n  names: names,\n  dependsOn: dependsOn\n};\n","import adjust_lon from '../common/adjust_lon';\n\nimport {HALF_PI, EPSLN} from '../constants/values';\n\nimport asinz from '../common/asinz';\n\n/* Initialize the Van Der Grinten projection\n  ----------------------------------------*/\nexport function init() {\n  //this.R = 6370997; //Radius of earth\n  this.R = this.a;\n}\n\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  /* Forward equations\n    -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  var x, y;\n\n  if (Math.abs(lat) <= EPSLN) {\n    x = this.x0 + this.R * dlon;\n    y = this.y0;\n  }\n  var theta = asinz(2 * Math.abs(lat / Math.PI));\n  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {\n    x = this.x0;\n    if (lat >= 0) {\n      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);\n    }\n    else {\n      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);\n    }\n    //  return(OK);\n  }\n  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));\n  var asq = al * al;\n  var sinth = Math.sin(theta);\n  var costh = Math.cos(theta);\n\n  var g = costh / (sinth + costh - 1);\n  var gsq = g * g;\n  var m = g * (2 / sinth - 1);\n  var msq = m * m;\n  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);\n  if (dlon < 0) {\n    con = -con;\n  }\n  x = this.x0 + con;\n  //con = Math.abs(con / (Math.PI * this.R));\n  var q = asq + g;\n  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);\n  if (lat >= 0) {\n    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 + con;\n  }\n  else {\n    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 - con;\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Van Der Grinten inverse equations--mapping x,y to lat/long\n  ---------------------------------------------------------*/\nexport function inverse(p) {\n  var lon, lat;\n  var xx, yy, xys, c1, c2, c3;\n  var a1;\n  var m1;\n  var con;\n  var th1;\n  var d;\n\n  /* inverse equations\n    -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  con = Math.PI * this.R;\n  xx = p.x / con;\n  yy = p.y / con;\n  xys = xx * xx + yy * yy;\n  c1 = -Math.abs(yy) * (1 + xys);\n  c2 = c1 - 2 * yy * yy + xx * xx;\n  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;\n  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;\n  a1 = (c1 - c2 * c2 / 3 / c3) / c3;\n  m1 = 2 * Math.sqrt(-a1 / 3);\n  con = ((3 * d) / a1) / m1;\n  if (Math.abs(con) > 1) {\n    if (con >= 0) {\n      con = 1;\n    }\n    else {\n      con = -1;\n    }\n  }\n  th1 = Math.acos(con) / 3;\n  if (p.y >= 0) {\n    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n  else {\n    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n\n  if (Math.abs(xx) < EPSLN) {\n    lon = this.long0;\n  }\n  else {\n    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Van_der_Grinten_I\", \"VanDerGrinten\", \"vandg\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n","import {D2R, R2D, PJD_3PARAM, PJD_7PARAM} from './constants/values';\nimport datum_transform from './datum_transform';\nimport {geodeticToGeocentric, geocentricToGeodetic} from './datumUtils';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n}\n\nexport default function transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point.x *= D2R;\n    point.y *= D2R;\n  }\n  else {\n    if (source.isGeocent) {\n      if (source.to_meter) {\n        point.x *= source.to_meter;\n        point.y *= source.to_meter;\n        point.z *= source.to_meter;\n      }\n      // originally dest.datum.geocentric_to_geodetic_noniter(point);\n      point = geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n    } else {\n      if (source.to_meter) {\n        point.x *= source.to_meter;\n        point.y *= source.to_meter;\n      }\n      point = source.inverse(point); // Convert Cartesian to longlat\n    }\n  }\n// Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n// Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n\n// Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point.x -= dest.from_greenwich;\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point.x *= R2D;\n    point.y *= R2D;\n  } else { // else project\n    if (dest.isGeocent) {\n      point = geodeticToGeocentric(point, dest.es, dest.a);\n      if (dest.to_meter) {\n        point.x /= dest.to_meter;\n        point.y /= dest.to_meter;\n        point.z /= dest.to_meter;\n      }\n    } else {\n      dest.forward(point);\n      if (dest.to_meter) {\n        point.x /= dest.to_meter;\n        point.y /= dest.to_meter;\n      }\n    }\n  }\n\n// DGR, 2010/11/12\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}\n","export {version as default} from '../package.json';\n","import tmerc from './lib/projections/tmerc';\nimport etmerc from './lib/projections/etmerc';\nimport utm from './lib/projections/utm';\nimport sterea from './lib/projections/sterea';\nimport stere from './lib/projections/stere';\nimport somerc from './lib/projections/somerc';\nimport omerc from './lib/projections/omerc';\nimport lcc from './lib/projections/lcc';\nimport krovak from './lib/projections/krovak';\nimport cass from './lib/projections/cass';\nimport laea from './lib/projections/laea';\nimport aea from './lib/projections/aea';\nimport gnom from './lib/projections/gnom';\nimport cea from './lib/projections/cea';\nimport eqc from './lib/projections/eqc';\nimport poly from './lib/projections/poly';\nimport nzmg from './lib/projections/nzmg';\nimport mill from './lib/projections/mill';\nimport sinu from './lib/projections/sinu';\nimport moll from './lib/projections/moll';\nimport eqdc from './lib/projections/eqdc';\nimport vandg from './lib/projections/vandg';\nimport aeqd from './lib/projections/aeqd';\nimport ortho from './lib/projections/ortho';\nimport geocent from './lib/projections/geocent';\nimport qsc from './lib/projections/qsc';\nexport default function(proj4){\n  proj4.Proj.projections.add(tmerc);\n  proj4.Proj.projections.add(etmerc);\n  proj4.Proj.projections.add(utm);\n  proj4.Proj.projections.add(sterea);\n  proj4.Proj.projections.add(stere);\n  proj4.Proj.projections.add(somerc);\n  proj4.Proj.projections.add(omerc);\n  proj4.Proj.projections.add(lcc);\n  proj4.Proj.projections.add(krovak);\n  proj4.Proj.projections.add(cass);\n  proj4.Proj.projections.add(laea);\n  proj4.Proj.projections.add(aea);\n  proj4.Proj.projections.add(gnom);\n  proj4.Proj.projections.add(cea);\n  proj4.Proj.projections.add(eqc);\n  proj4.Proj.projections.add(poly);\n  proj4.Proj.projections.add(nzmg);\n  proj4.Proj.projections.add(mill);\n  proj4.Proj.projections.add(sinu);\n  proj4.Proj.projections.add(moll);\n  proj4.Proj.projections.add(eqdc);\n  proj4.Proj.projections.add(vandg);\n  proj4.Proj.projections.add(aeqd);\n  proj4.Proj.projections.add(ortho);\n  proj4.Proj.projections.add(geocent);\n  proj4.Proj.projections.add(qsc);\n}","\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\nexport default {\n  forward: forward,\n  inverse: inverse,\n  toPoint: toPoint\n};\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nexport function forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nexport function inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nexport function toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n","var D2R = 0.01745329251994329577;\nimport parser from './parser';\nimport {sExpr} from './process';\n\n\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  } else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  } else {\n    if (typeof wkt.PROJECTION === 'object') {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    } else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.AXIS) {\n    var axisOrder = '';\n    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {\n      var axis = wkt.AXIS[i];\n      var descriptor = axis[0].toLowerCase();\n      if (descriptor.indexOf('north') !== -1) {\n        axisOrder += 'n';\n      } else if (descriptor.indexOf('south') !== -1) {\n        axisOrder += 's';\n      } else if (descriptor.indexOf('east') !== -1) {\n        axisOrder += 'e';\n      } else if (descriptor.indexOf('west') !== -1) {\n        axisOrder += 'w';\n      }\n    }\n    if (axisOrder.length === 2) {\n      axisOrder += 'u';\n    }\n    if (axisOrder.length === 3) {\n      wkt.axis = axisOrder;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = wkt.UNIT.convert;\n      }\n    }\n  }\n  var geogcs = wkt.GEOGCS;\n  if (wkt.type === 'GEOGCS') {\n    geogcs = wkt;\n  }\n  if (geogcs) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (geogcs.DATUM) {\n      wkt.datumCode = geogcs.DATUM.name.toLowerCase();\n    } else {\n      wkt.datumCode = geogcs.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = 'rnb72';\n    }\n    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = geogcs.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n    }\n\n    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {\n      wkt.datum_params = geogcs.DATUM.TOWGS84;\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = 'osgb36';\n    }\n    if (~wkt.datumCode.indexOf('osni_1952')) {\n      wkt.datumCode = 'osni52';\n    }\n    if (~wkt.datumCode.indexOf('tm65')\n      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {\n      wkt.datumCode = 'ire65';\n    }\n    if (wkt.datumCode === 'ch1903+') {\n      wkt.datumCode = 'ch1903';\n    }\n    if (~wkt.datumCode.indexOf('israel')) {\n      wkt.datumCode = 'isr93';\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return input * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['false_easting', 'False_Easting'],\n    ['false_northing', 'False_Northing'],\n    ['central_meridian', 'Central_Meridian'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_Of_Center'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longitude_of_center', 'Longitude_of_center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['azimuth', 'Azimuth'],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\nexport default function(wkt) {\n  var lisp = parser(wkt);\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj);\n  return obj;\n}\n","export default parseString;\n\nvar NEUTRAL = 1;\nvar KEYWORD = 2;\nvar NUMBER = 3;\nvar QUOTED = 4;\nvar AFTERQUOTE = 5;\nvar ENDED = -1;\nvar whitespace = /\\s/;\nvar latin = /[A-Za-z]/;\nvar keyword = /[A-Za-z84]/;\nvar endThings = /[,\\]]/;\nvar digets = /[\\d\\.E\\-\\+]/;\n// const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction Parser(text) {\n  if (typeof text !== 'string') {\n    throw new Error('not a string');\n  }\n  this.text = text.trim();\n  this.level = 0;\n  this.place = 0;\n  this.root = null;\n  this.stack = [];\n  this.currentObject = null;\n  this.state = NEUTRAL;\n}\nParser.prototype.readCharicter = function() {\n  var char = this.text[this.place++];\n  if (this.state !== QUOTED) {\n    while (whitespace.test(char)) {\n      if (this.place >= this.text.length) {\n        return;\n      }\n      char = this.text[this.place++];\n    }\n  }\n  switch (this.state) {\n    case NEUTRAL:\n      return this.neutral(char);\n    case KEYWORD:\n      return this.keyword(char)\n    case QUOTED:\n      return this.quoted(char);\n    case AFTERQUOTE:\n      return this.afterquote(char);\n    case NUMBER:\n      return this.number(char);\n    case ENDED:\n      return;\n  }\n};\nParser.prototype.afterquote = function(char) {\n  if (char === '\"') {\n    this.word += '\"';\n    this.state = QUOTED;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = this.word.trim();\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in afterquote yet, index ' + this.place);\n};\nParser.prototype.afterItem = function(char) {\n  if (char === ',') {\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n    }\n    this.word = null;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (char === ']') {\n    this.level--;\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n      this.word = null;\n    }\n    this.state = NEUTRAL;\n    this.currentObject = this.stack.pop();\n    if (!this.currentObject) {\n      this.state = ENDED;\n    }\n\n    return;\n  }\n};\nParser.prototype.number = function(char) {\n  if (digets.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = parseFloat(this.word);\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in number yet, index ' + this.place);\n};\nParser.prototype.quoted = function(char) {\n  if (char === '\"') {\n    this.state = AFTERQUOTE;\n    return;\n  }\n  this.word += char;\n  return;\n};\nParser.prototype.keyword = function(char) {\n  if (keyword.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (char === '[') {\n    var newObjects = [];\n    newObjects.push(this.word);\n    this.level++;\n    if (this.root === null) {\n      this.root = newObjects;\n    } else {\n      this.currentObject.push(newObjects);\n    }\n    this.stack.push(this.currentObject);\n    this.currentObject = newObjects;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in keyword yet, index ' + this.place);\n};\nParser.prototype.neutral = function(char) {\n  if (latin.test(char)) {\n    this.word = char;\n    this.state = KEYWORD;\n    return;\n  }\n  if (char === '\"') {\n    this.word = '';\n    this.state = QUOTED;\n    return;\n  }\n  if (digets.test(char)) {\n    this.word = char;\n    this.state = NUMBER;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in neutral yet, index ' + this.place);\n};\nParser.prototype.output = function() {\n  while (this.place < this.text.length) {\n    this.readCharicter();\n  }\n  if (this.state === ENDED) {\n    return this.root;\n  }\n  throw new Error('unable to parse string \"' +this.text + '\". State is ' + this.state);\n};\n\nfunction parseString(txt) {\n  var parser = new Parser(txt);\n  return parser.output();\n}\n","\n\nfunction mapit(obj, key, value) {\n  if (Array.isArray(key)) {\n    value.unshift(key);\n    key = null;\n  }\n  var thing = key ? {} : obj;\n\n  var out = value.reduce(function(newObj, item) {\n    sExpr(item, newObj);\n    return newObj\n  }, thing);\n  if (key) {\n    obj[key] = out;\n  }\n}\n\nexport function sExpr(v, obj) {\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  var key = v.shift();\n  if (key === 'PARAMETER') {\n    key = v.shift();\n  }\n  if (v.length === 1) {\n    if (Array.isArray(v[0])) {\n      obj[key] = {};\n      sExpr(v[0], obj[key]);\n      return;\n    }\n    obj[key] = v[0];\n    return;\n  }\n  if (!v.length) {\n    obj[key] = true;\n    return;\n  }\n  if (key === 'TOWGS84') {\n    obj[key] = v;\n    return;\n  }\n  if (key === 'AXIS') {\n    if (!(key in obj)) {\n      obj[key] = [];\n    }\n    obj[key].push(v);\n    return;\n  }\n  if (!Array.isArray(key)) {\n    obj[key] = {};\n  }\n\n  var i;\n  switch (key) {\n    case 'UNIT':\n    case 'PRIMEM':\n    case 'VERT_DATUM':\n      obj[key] = {\n        name: v[0].toLowerCase(),\n        convert: v[1]\n      };\n      if (v.length === 3) {\n        sExpr(v[2], obj[key]);\n      }\n      return;\n    case 'SPHEROID':\n    case 'ELLIPSOID':\n      obj[key] = {\n        name: v[0],\n        a: v[1],\n        rf: v[2]\n      };\n      if (v.length === 4) {\n        sExpr(v[3], obj[key]);\n      }\n      return;\n    case 'PROJECTEDCRS':\n    case 'PROJCRS':\n    case 'GEOGCS':\n    case 'GEOCCS':\n    case 'PROJCS':\n    case 'LOCAL_CS':\n    case 'GEODCRS':\n    case 'GEODETICCRS':\n    case 'GEODETICDATUM':\n    case 'EDATUM':\n    case 'ENGINEERINGDATUM':\n    case 'VERT_CS':\n    case 'VERTCRS':\n    case 'VERTICALCRS':\n    case 'COMPD_CS':\n    case 'COMPOUNDCRS':\n    case 'ENGINEERINGCRS':\n    case 'ENGCRS':\n    case 'FITTED_CS':\n    case 'LOCAL_DATUM':\n    case 'DATUM':\n      v[0] = ['name', v[0]];\n      mapit(obj, key, v);\n      return;\n    default:\n      i = -1;\n      while (++i < v.length) {\n        if (!Array.isArray(v[i])) {\n          return sExpr(v, obj[key]);\n        }\n      }\n      return mapit(obj, key, v);\n  }\n}\n","module.exports = function() {\n  return require(\"!!/home/david/dev/vts-browser-js/node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/*!\\n * Copyright (c) 2020 Melown Technologies SE\\n *  *  For terms of use, see accompanying main file.\\n *  *  For 3rd party libraries licenses, see 3rdpartylicenses.txt.\\n * \\n */\\n/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/core/map/geodata-processor/worker-main.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-bidi.js\\\":\\n/*!*******************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-bidi.js ***!\\n  \\\\*******************************************************/\\n/*! exports provided: bidi */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"bidi\\\", function() { return bidi; });\\n/* Copyright 2012 Mozilla Foundation\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// Character types for symbols from 0000 to 00FF.\\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\\nvar baseTypes = [\\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'S', 'B', 'S',\\n  'WS', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\\n  'BN', 'BN', 'BN', 'BN', 'B', 'B', 'B', 'S', 'WS', 'ON', 'ON', 'ET',\\n  'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'ON', 'ES', 'CS', 'ES', 'CS', 'CS',\\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'CS', 'ON',\\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON',\\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'BN', 'BN', 'BN', 'BN', 'BN',\\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'CS', 'ON', 'ET',\\n  'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'L', 'ON', 'ON', 'BN', 'ON',\\n  'ON', 'ET', 'ET', 'EN', 'EN', 'ON', 'L', 'ON', 'ON', 'ON', 'EN', 'L',\\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'\\n];\\n\\n// Character types for symbols from 0600 to 06FF.\\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\\n// Note that 061D does not exist in the Unicode standard (see\\n// http://unicode.org/charts/PDF/U0600.pdf), so we replace it with an\\n// empty string and issue a warning if we encounter this character. The\\n// empty string is required to properly index the items after it.\\nvar arabicTypes = [\\n  'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ON', 'ON', 'AL', 'ET', 'ET', 'AL',\\n  'CS', 'AL', 'ON', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\\n  'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', '', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\\n  'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\\n  'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN',\\n  'AN', 'AN', 'AN', 'ET', 'AN', 'AN', 'AL', 'AL', 'AL', 'NSM', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN',\\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'NSM', 'NSM',\\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'EN', 'EN', 'EN', 'EN',\\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL'\\n];\\n\\nfunction isOdd(i) {\\n  return (i & 1) !== 0;\\n}\\n\\nfunction isEven(i) {\\n  return (i & 1) === 0;\\n}\\n\\nfunction findUnequal(arr, start, value) {\\n  for (var j = start, jj = arr.length; j < jj; ++j) {\\n    if (arr[j] !== value) {\\n      return j;\\n    }\\n  }\\n  return j;\\n}\\n\\nfunction setValues(arr, start, end, value) {\\n  for (var j = start; j < end; ++j) {\\n    arr[j] = value;\\n  }\\n}\\n\\nfunction reverseValues(arr, arr2, start, end) {\\n  for (var i = start, j = end - 1; i < j; ++i, --j) {\\n    var temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n    temp = arr2[i];\\n    arr2[i] = arr2[j];\\n    arr2[j] = temp;\\n  }\\n}\\n\\nfunction createBidiText(str, isLTR, vertical) {\\n  return {\\n    str: str,\\n    indices: indices,\\n    types : types,\\n    dir: (vertical ? 'ttb' : (isLTR ? 'ltr' : 'rtl')),\\n  };\\n}\\n\\n// These are used in bidi(), which is called frequently. We re-use them on\\n// each call to avoid unnecessary allocations.\\nvar chars = [];\\nvar types = [];\\nvar indices = [];\\n\\nfunction bidi(str, startLevel, vertical) {\\n  var isLTR = true;\\n  var strLength = str.length;\\n  if (strLength === 0 || vertical) {\\n    return createBidiText(str, isLTR, vertical);\\n  }\\n\\n  // Get types and fill arrays\\n  chars.length = strLength;\\n  types.length = strLength;\\n  var numBidi = 0;\\n\\n  var i, ii;\\n  for (i = 0; i < strLength; ++i) {\\n    chars[i] = str.charAt(i);\\n    indices[i] = i;\\n\\n    var charCode = str.charCodeAt(i);\\n    var charType = 'L';\\n    if (charCode <= 0x00ff) {\\n      charType = baseTypes[charCode];\\n    } else if (0x0590 <= charCode && charCode <= 0x05f4) {\\n      charType = 'R';\\n    } else if (0x0600 <= charCode && charCode <= 0x06ff) {\\n      charType = arabicTypes[charCode & 0xff];\\n      if (!charType) {\\n        //console.log('Bidi: invalid Unicode character ' + charCode.toString(16));\\n      }\\n    } else if (0x0700 <= charCode && charCode <= 0x08AC) {\\n      charType = 'AL';\\n    }\\n    if (charType === 'R' || charType === 'AL' || charType === 'AN') {\\n      numBidi++;\\n    }\\n    types[i] = charType;\\n  }\\n\\n  // Detect the bidi method\\n  // - If there are no rtl characters then no bidi needed\\n  // - If less than 30% chars are rtl then string is primarily ltr\\n  // - If more than 30% chars are rtl then string is primarily rtl\\n  if (numBidi === 0) {\\n    isLTR = true;\\n    return createBidiText(str, isLTR);\\n  }\\n\\n  if (startLevel === -1) {\\n    if ((numBidi / strLength) < 0.3) {\\n      isLTR = true;\\n      startLevel = 0;\\n    } else {\\n      isLTR = false;\\n      startLevel = 1;\\n    }\\n  }\\n\\n  var levels = [];\\n  for (i = 0; i < strLength; ++i) {\\n    levels[i] = startLevel;\\n  }\\n\\n  /*\\n   X1-X10: skip most of this, since we are NOT doing the embeddings.\\n   */\\n  var e = (isOdd(startLevel) ? 'R' : 'L');\\n  var sor = e;\\n  var eor = sor;\\n\\n  /*\\n   W1. Examine each non-spacing mark (NSM) in the level run, and change the\\n   type of the NSM to the type of the previous character. If the NSM is at the\\n   start of the level run, it will get the type of sor.\\n   */\\n  var lastType = sor;\\n  for (i = 0; i < strLength; ++i) {\\n    if (types[i] === 'NSM') {\\n      types[i] = lastType;\\n    } else {\\n      lastType = types[i];\\n    }\\n  }\\n\\n  /*\\n   W2. Search backwards from each instance of a European number until the\\n   first strong type (R, L, AL, or sor) is found.  If an AL is found, change\\n   the type of the European number to Arabic number.\\n   */\\n  lastType = sor;\\n  var t;\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (t === 'EN') {\\n      types[i] = (lastType === 'AL') ? 'AN' : 'EN';\\n    } else if (t === 'R' || t === 'L' || t === 'AL') {\\n      lastType = t;\\n    }\\n  }\\n\\n  /*\\n   W3. Change all ALs to R.\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (t === 'AL') {\\n      types[i] = 'R';\\n    }\\n  }\\n\\n  /*\\n   W4. A single European separator between two European numbers changes to a\\n   European number. A single common separator between two numbers of the same\\n   type changes to that type:\\n   */\\n  for (i = 1; i < strLength - 1; ++i) {\\n    if (types[i] === 'ES' && types[i - 1] === 'EN' && types[i + 1] === 'EN') {\\n      types[i] = 'EN';\\n    }\\n    if (types[i] === 'CS' &&\\n        (types[i - 1] === 'EN' || types[i - 1] === 'AN') &&\\n        types[i + 1] === types[i - 1]) {\\n      types[i] = types[i - 1];\\n    }\\n  }\\n\\n  /*\\n   W5. A sequence of European terminators adjacent to European numbers changes\\n   to all European numbers:\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    if (types[i] === 'EN') {\\n      // do before\\n      var j;\\n      for (j = i - 1; j >= 0; --j) {\\n        if (types[j] !== 'ET') {\\n          break;\\n        }\\n        types[j] = 'EN';\\n      }\\n      // do after\\n      for (j = i + 1; j < strLength; ++j) {\\n        if (types[j] !== 'ET') {\\n          break;\\n        }\\n        types[j] = 'EN';\\n      }\\n    }\\n  }\\n\\n  /*\\n   W6. Otherwise, separators and terminators change to Other Neutral:\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (t === 'WS' || t === 'ES' || t === 'ET' || t === 'CS') {\\n      types[i] = 'ON';\\n    }\\n  }\\n\\n  /*\\n   W7. Search backwards from each instance of a European number until the\\n   first strong type (R, L, or sor) is found. If an L is found,  then change\\n   the type of the European number to L.\\n   */\\n  lastType = sor;\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (t === 'EN') {\\n      types[i] = ((lastType === 'L') ? 'L' : 'EN');\\n    } else if (t === 'R' || t === 'L') {\\n      lastType = t;\\n    }\\n  }\\n\\n  /*\\n   N1. A sequence of neutrals takes the direction of the surrounding strong\\n   text if the text on both sides has the same direction. European and Arabic\\n   numbers are treated as though they were R. Start-of-level-run (sor) and\\n   end-of-level-run (eor) are used at level run boundaries.\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    if (types[i] === 'ON') {\\n      var end = findUnequal(types, i + 1, 'ON');\\n      var before = sor;\\n      if (i > 0) {\\n        before = types[i - 1];\\n      }\\n\\n      var after = eor;\\n      if (end + 1 < strLength) {\\n        after = types[end + 1];\\n      }\\n      if (before !== 'L') {\\n        before = 'R';\\n      }\\n      if (after !== 'L') {\\n        after = 'R';\\n      }\\n      if (before === after) {\\n        setValues(types, i, end, before);\\n      }\\n      i = end - 1; // reset to end (-1 so next iteration is ok)\\n    }\\n  }\\n\\n  /*\\n   N2. Any remaining neutrals take the embedding direction.\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    if (types[i] === 'ON') {\\n      types[i] = e;\\n    }\\n  }\\n\\n  /*\\n   I1. For all characters with an even (left-to-right) embedding direction,\\n   those of type R go up one level and those of type AN or EN go up two\\n   levels.\\n   I2. For all characters with an odd (right-to-left) embedding direction,\\n   those of type L, EN or AN go up one level.\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (isEven(levels[i])) {\\n      if (t === 'R') {\\n        levels[i] += 1;\\n      } else if (t === 'AN' || t === 'EN') {\\n        levels[i] += 2;\\n      }\\n    } else { // isOdd\\n      if (t === 'L' || t === 'AN' || t === 'EN') {\\n        levels[i] += 1;\\n      }\\n    }\\n  }\\n\\n  /*\\n   L1. On each line, reset the embedding level of the following characters to\\n   the paragraph embedding level:\\n\\n   segment separators,\\n   paragraph separators,\\n   any sequence of whitespace characters preceding a segment separator or\\n   paragraph separator, and any sequence of white space characters at the end\\n   of the line.\\n   */\\n\\n  // don't bother as text is only single line\\n\\n  /*\\n   L2. From the highest level found in the text to the lowest odd level on\\n   each line, reverse any contiguous sequence of characters that are at that\\n   level or higher.\\n   */\\n\\n  // find highest level & lowest odd level\\n  var highestLevel = -1;\\n  var lowestOddLevel = 99;\\n  var level;\\n  for (i = 0, ii = levels.length; i < ii; ++i) {\\n    level = levels[i];\\n    if (highestLevel < level) {\\n      highestLevel = level;\\n    }\\n    if (lowestOddLevel > level && isOdd(level)) {\\n      lowestOddLevel = level;\\n    }\\n  }\\n\\n  // now reverse between those limits\\n  for (level = highestLevel; level >= lowestOddLevel; --level) {\\n    // find segments to reverse\\n    var start = -1;\\n    for (i = 0, ii = levels.length; i < ii; ++i) {\\n      if (levels[i] < level) {\\n        if (start >= 0) {\\n          reverseValues(chars, indices, start, i);\\n          start = -1;\\n        }\\n      } else if (start < 0) {\\n        start = i;\\n      }\\n    }\\n    if (start >= 0) {\\n      reverseValues(chars, indices, start, levels.length);\\n    }\\n  }\\n\\n  /*\\n   L3. Combining marks applied to a right-to-left base character will at this\\n   point precede their base character. If the rendering engine expects them to\\n   follow the base characters in the final display process, then the ordering\\n   of the marks and the base character must be reversed.\\n   */\\n\\n  // don't bother for now\\n\\n  /*\\n   L4. A character that possesses the mirrored property as specified by\\n   Section 4.7, Mirrored, must be depicted by a mirrored glyph if the resolved\\n   directionality of that character is R.\\n   */\\n\\n  // don't mirror as characters are already mirrored in the pdf\\n\\n  // Finally, return string\\n  for (i = 0, ii = chars.length; i < ii; ++i) {\\n    var ch = chars[i];\\n    if (ch === '<' || ch === '>') {\\n      chars[i] = '';\\n    }\\n  }\\n  return createBidiText(chars.join(''), isLTR);\\n}\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-font.js\\\":\\n/*!*******************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-font.js ***!\\n  \\\\*******************************************************/\\n/*! exports provided: Typr */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Typr\\\", function() { return Typr; });\\n/* harmony import */ var _worker_bidi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-bidi.js */ \\\"./src/core/map/geodata-processor/worker-bidi.js\\\");\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar bidi = _worker_bidi_js__WEBPACK_IMPORTED_MODULE_0__[\\\"bidi\\\"];\\n\\n\\nvar Typr = {};\\n\\nTypr.parse = function(buff) {\\n    var bin = Typr._bin;\\n    var data = new Uint8Array(buff);\\n    var offset = 0;\\n    \\n    var sfnt_version = bin.readFixed(data, offset);\\n    offset += 4;\\n    var numTables = bin.readUshort(data, offset);\\n    offset += 2;\\n    var searchRange = bin.readUshort(data, offset);\\n    offset += 2;\\n    var entrySelector = bin.readUshort(data, offset);\\n    offset += 2;\\n    var rangeShift = bin.readUshort(data, offset);\\n    offset += 2;\\n    \\n    var tags = [\\n        \\\"cmap\\\",\\n        \\\"head\\\",\\n        \\\"hhea\\\",\\n        \\\"maxp\\\",\\n        \\\"hmtx\\\",\\n        //\\\"name\\\",\\n        //\\\"OS/2\\\",\\n        //\\\"post\\\",\\n        \\n        //\\\"cvt\\\",\\n        //\\\"fpgm\\\",\\n        //\\\"loca\\\",\\n        //\\\"glyf\\\",\\n        \\\"kern\\\",\\n        \\n        //\\\"prep\\\"\\n        //\\\"gasp\\\"\\n        \\n        \\\"GPOS\\\",\\n        \\\"GSUB\\\"\\n        //\\\"VORG\\\",\\n        ];\\n    \\n    var obj = {_data:data};\\n    //console.log(sfnt_version, numTables, searchRange, entrySelector, rangeShift);\\n    \\n    var tabs = {};\\n    var tablesOffset = 0;\\n    \\n    for(var i=0; i<numTables; i++) {\\n        var tag = bin.readASCII(data, offset, 4);   offset += 4;\\n        var checkSum = bin.readUint(data, offset);  offset += 4;\\n        var toffset = bin.readUint(data, offset);   offset += 4;\\n        var length = bin.readUint(data, offset);    offset += 4;\\n        tabs[tag] = {offset:toffset, length:length};\\n        tablesOffset = toffset + length;\\n        //if(tags.indexOf(tag)==-1) console.log(\\\"unknown tag\\\", tag);\\n    }\\n    \\n    for(var i=0; i< tags.length; i++) {\\n        var t = tags[i];\\n        //console.log(t);\\n        //if(tabs[t]) console.log(t, tabs[t].offset, tabs[t].length);\\n        if(tabs[t]) obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj);\\n    }\\n\\n    obj._tabs = tabs;\\n\\n    Typr._processGlyphs(data, tablesOffset, tabs, obj);\\n\\n    //get tables\\n    var gsub = obj['GSUB'];\\n    if (gsub) {\\n        var llist = gsub.lookupList, flist = gsub.featureList;\\n\\n        obj.gsubIsolTable = [];\\n        obj.gsubInitTable = [];\\n        obj.gsubFinaTable = [];\\n        obj.gsubMediTable = [];\\n\\n        obj.gsubRligLigaTable = [];\\n\\n        for(var fi = 0; fi < flist.length; fi++) {\\n            var tag = flist[fi].tag;\\n\\n            switch (tag) {\\n                case 'isol':\\n                case 'init':\\n                case 'fina':\\n                case 'medi':\\n\\n                    for(var ti = 0; ti < flist[fi].tab.length; ti++) {\\n                        var tab = llist[flist[fi].tab[ti]];\\n                        \\n                        if(tab.ltype == 1) {\\n                            switch (tag) {\\n                                case 'isol': obj.gsubIsolTable.push(tab.tabs); break;\\n                                case 'init': obj.gsubInitTable.push(tab.tabs); break;\\n                                case 'fina': obj.gsubFinaTable.push(tab.tabs); break;\\n                                case 'medi': obj.gsubMediTable.push(tab.tabs); break;\\n                            }\\n                        }\\n                    }\\n\\n                    break;\\n\\n                case 'rlig':\\n                case 'liga':\\n\\n                    for(var ti = 0; ti < flist[fi].tab.length; ti++) {\\n                        var tab = llist[flist[fi].tab[ti]];\\n                        \\n                        if(tab.ltype == 4) {\\n                            obj.gsubRligLigaTable.push(tab.tabs);\\n                        }\\n                    }\\n\\n                    break;\\n            }\\n\\n        }\\n    }\\n   \\n    return obj;\\n}\\n\\nTypr._processGlyphs = function(data, index, tabs, obj) {\\n    var version = data[index]; index += 1;\\n    var textureLX = (data[index] << 8) | (data[index+1]); index += 2;\\n    var textureLY = (data[index] << 8) | (data[index+1]); index += 2;\\n    var size = data[index]; index += 1;\\n    var flags = data[index]; index += 1;\\n\\n    obj.version = version;\\n    obj.textureLX = textureLX;\\n    obj.textureLY = textureLY;\\n    obj.size = size;\\n    obj.cly = size * 1.5;\\n    obj.flags = flags;\\n\\n    var glyphs = new Array(obj.maxp.numGlyphs);\\n    var fx = 1.0 / textureLX, fy = 1.0 / textureLY;\\n    var step = (textureLX > 256) ? 7 : 6;\\n\\n    var filesIndicesIndex = index + obj.maxp.numGlyphs * step;\\n    var filesIndicesCount = (data[filesIndicesIndex] << 8) | data[filesIndicesIndex+1];\\n    var files = new Array(filesIndicesCount);\\n\\n    filesIndicesIndex += 2;\\n\\n    for (var i = 0, li = filesIndicesCount; i < li; i++) {\\n        files[i] = (data[filesIndicesIndex+i*2] << 8) | data[filesIndicesIndex+i*2+1];\\n    }\\n\\n    var fileIndex = 0;\\n\\n    for (i = 0, li = obj.maxp.numGlyphs; i < li; i++) {\\n        if (i == files[fileIndex]) {\\n            fileIndex++;\\n        }\\n\\n        glyphs[i] = Typr._processGlyph(data, index, fx, fy, textureLX, obj, i, fileIndex);\\n        index += step;\\n    }\\n\\n    obj.glyphs = glyphs;\\n}\\n\\nTypr._processGlyph = function(data, index, fx, fy, textureLX, font, glyphIndex, fileIndex) {\\n    var value = (data[index] << 24) | (data[index+1] << 16) | (data[index+2] << 8) | (data[index+3]);\\n\\n    // w 6bit | h 6bit | sx sign 1bit | abs sx 6bit | sy sign 1bit | abs sy 6bit | plane 2bit \\n    var w = (value >> 22) & 63;\\n    var h = (value >> 16) & 63;\\n    var sx = ((value >> 9) & 63) * (((value >> 15) & 1) ? -1 : 1);\\n    var sy = -((value >> 2) & 63) * (((value >> 8) & 1) ? -1 : 1);\\n    var plane = (value & 3) + (fileIndex * 4);\\n\\n    if (textureLX > 256) {\\n        value = (data[index+4] << 16) | (data[index+5] << 8) | (data[index+6]);\\n    } else {\\n        value = (data[index+4] << 8) | (data[index+5]);\\n    }    \\n\\n    var scale = ((font.size/0.75) / font.head.unitsPerEm) * 0.75;\\n    var x, y, step = font.hmtx.aWidth[glyphIndex] * scale;\\n\\n    //store glyph position\\n    switch (textureLX) {\\n        case 2048: // x 11bit | y 11bit\\n            x = ((value >> 11) & 2047), y = (value & 2047); break;\\n                   \\n        case 1024: // x 10bit | y 10bit\\n            x = ((value >> 10) & 1023), y = (value & 1023); break;\\n\\n        case 512:  // x 9bit | y 9bit\\n            x = ((value >> 9) & 511), y = (value & 511); break;\\n\\n        default:   // x 8bit | y 8bit\\n            x = ((value >> 8) & 255), y = (value & 255); break;\\n    }\\n\\n    return {\\n        u1 : (x) * fx,\\n        v1 : (y * fy) + plane,\\n        u2 : (x + w) * fx,\\n        v2 : ((y + h) * fy) + plane,\\n        lx : w,\\n        ly : h,\\n        sx : sx, \\n        sy : sy, \\n        step : (step), \\n        plane: plane\\n    };\\n}\\n\\nTypr._tabOffset = function(data, tab) {\\n    var bin = Typr._bin;\\n    var numTables = bin.readUshort(data, 4);\\n    var offset = 12;\\n    for(var i=0; i<numTables; i++) {\\n        var tag = bin.readASCII(data, offset, 4);   offset += 4;\\n        var checkSum = bin.readUint(data, offset);  offset += 4;\\n        var toffset = bin.readUint(data, offset);   offset += 4;\\n        var length = bin.readUint(data, offset);    offset += 4;\\n        if(tag==tab) return toffset;\\n    }\\n    return 0;\\n}\\n\\n\\n\\n\\nTypr._bin = {\\n    readFixed : function(data, o) {\\n        return ((data[o]<<8) | data[o+1]) +  (((data[o+2]<<8)|data[o+3])/(256*256+4));\\n    },\\n\\n    readF2dot14 : function(data, o) {\\n        var num = Typr._bin.readShort(data, o);\\n        return num / 16384;\\n        \\n        var intg = (num >> 14), frac = ((num & 0x3fff)/(0x3fff+1));\\n        return (intg>0) ? (intg+frac) : (intg-frac);\\n    },\\n\\n    readInt : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var a = Typr._bin.t.uint8;\\n        a[0] = buff[p+3];\\n        a[1] = buff[p+2];\\n        a[2] = buff[p+1];\\n        a[3] = buff[p];\\n        return Typr._bin.t.int32[0];\\n    },\\n    \\n    readInt8 : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var a = Typr._bin.t.uint8;\\n        a[0] = buff[p];\\n        return Typr._bin.t.int8[0];\\n    },\\n\\n    readShort : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var a = Typr._bin.t.uint8;\\n        a[1] = buff[p]; a[0] = buff[p+1];\\n        return Typr._bin.t.int16[0];\\n    },\\n\\n    readUshort : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        return (buff[p]<<8) | buff[p+1];\\n    },\\n\\n    readUshorts : function(buff, p, len) {\\n        var arr = [];\\n        for(var i=0; i<len; i++) arr.push(Typr._bin.readUshort(buff, p+i*2));\\n        return arr;\\n    },\\n\\n    readUint : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var a = Typr._bin.t.uint8;\\n        a[3] = buff[p];  a[2] = buff[p+1];  a[1] = buff[p+2];  a[0] = buff[p+3];\\n        return Typr._bin.t.uint32[0];\\n    },\\n\\n    readUint64 : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        return (Typr._bin.readUint(buff, p)*(0xffffffff+1)) + Typr._bin.readUint(buff, p+4);\\n    },\\n\\n    readASCII : function(buff, p, l) {   // l : length in Characters (not Bytes)\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var s = \\\"\\\";\\n        for(var i = 0; i < l; i++) s += String.fromCharCode(buff[p+i]);\\n        return s;\\n    },\\n\\n    readUnicode : function(buff, p, l) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var s = \\\"\\\";\\n        for(var i = 0; i < l; i++)  \\n        {\\n            var c = (buff[p++]<<8) | buff[p++];\\n            s += String.fromCharCode(c);\\n        }\\n        return s;\\n    },\\n\\n    readBytes : function(buff, p, l) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var arr = [];\\n        for(var i=0; i<l; i++) arr.push(buff[p+i]);\\n        return arr;\\n    },\\n\\n    readASCIIArray : function(buff, p, l) {  // l : length in Characters (not Bytes)\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var s = [];\\n        for(var i = 0; i < l; i++)  \\n            s.push(String.fromCharCode(buff[p+i]));\\n        return s;\\n    }\\n};\\n\\nTypr._bin.t = {\\n    buff: new ArrayBuffer(8),\\n};\\nTypr._bin.t.int8   = new Int8Array  (Typr._bin.t.buff);\\nTypr._bin.t.uint8  = new Uint8Array (Typr._bin.t.buff);\\nTypr._bin.t.int16  = new Int16Array (Typr._bin.t.buff);\\nTypr._bin.t.uint16 = new Uint16Array(Typr._bin.t.buff);\\nTypr._bin.t.int32  = new Int32Array (Typr._bin.t.buff);\\nTypr._bin.t.uint32 = new Uint32Array(Typr._bin.t.buff);\\n\\n\\n\\n\\n\\n// OpenType Layout Common Table Formats\\n\\nTypr._lctf = {};\\n\\nTypr._lctf.parse = function(data, offset, length, font, subt) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    var offset0 = offset;\\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\\n    \\n    var offScriptList  = bin.readUshort(data, offset);  offset += 2;\\n    var offFeatureList = bin.readUshort(data, offset);  offset += 2;\\n    var offLookupList  = bin.readUshort(data, offset);  offset += 2;\\n    \\n    \\n    obj.scriptList  = Typr._lctf.readScriptList (data, offset0 + offScriptList);\\n    obj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);\\n    obj.lookupList  = Typr._lctf.readLookupList (data, offset0 + offLookupList, subt);\\n    \\n    return obj;\\n}\\n\\nTypr._lctf.readLookupList = function(data, offset, subt) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = [];\\n    var count = bin.readUshort(data, offset);  offset+=2;\\n\\n    for(var i=0; i<count; i++) \\n    {\\n        var noff = bin.readUshort(data, offset);  offset+=2;\\n        var lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);\\n        obj.push(lut);\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readLookupTable = function(data, offset, subt) {\\n    //console.log(\\\"Parsing lookup table\\\", offset);\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {tabs:[]};\\n    \\n    obj.ltype = bin.readUshort(data, offset);  offset+=2;\\n    obj.flag  = bin.readUshort(data, offset);  offset+=2;\\n    var cnt   = bin.readUshort(data, offset);  offset+=2;\\n    \\n    for(var i=0; i<cnt; i++) {\\n        var noff = bin.readUshort(data, offset);  offset+=2;\\n        var tab = subt(data, obj.ltype, offset0 + noff);\\n        //console.log(obj.type, tab);\\n        obj.tabs.push(tab);\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.numOfOnes = function(n) {\\n    var num = 0;\\n    for(var i=0; i<32; i++) if(((n>>>i)&1) != 0) num++;\\n    return num;\\n}\\n\\nTypr._lctf.readClassDef = function(data, offset) {\\n    var bin = Typr._bin;\\n    var obj = { start:[], end:[], class:[] };\\n    var format = bin.readUshort(data, offset);  offset+=2;\\n\\n    if(format==1) {\\n        var startGlyph  = bin.readUshort(data, offset);  offset+=2;\\n        var glyphCount  = bin.readUshort(data, offset);  offset+=2;\\n        for(var i=0; i<glyphCount; i++) {\\n            obj.start.push(startGlyph+i);\\n            obj.end  .push(startGlyph+i);\\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\\n        }\\n    }\\n\\n    if(format==2) {\\n        var count = bin.readUshort(data, offset);  offset+=2;\\n        for(var i=0; i<count; i++) {\\n            obj.start.push(bin.readUshort(data, offset));  offset+=2;\\n            obj.end  .push(bin.readUshort(data, offset));  offset+=2;\\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\\n        }\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readValueRecord = function(data, offset, valFmt) {\\n    var bin = Typr._bin;\\n    var arr = [];\\n    arr.push( (valFmt&1) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&1) ? 2 : 0;\\n    arr.push( (valFmt&2) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&2) ? 2 : 0;\\n    arr.push( (valFmt&4) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&4) ? 2 : 0;\\n    arr.push( (valFmt&8) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&8) ? 2 : 0;\\n    return arr;\\n}\\n\\nTypr._lctf.readCoverage = function(data, offset) {\\n    var bin = Typr._bin;\\n    var cvg = {};\\n    cvg.fmt   = bin.readUshort(data, offset);  offset+=2;\\n    var count = bin.readUshort(data, offset);  offset+=2;\\n    //console.log(\\\"parsing coverage\\\", offset-4, format, count);\\n    if(cvg.fmt==1) cvg.tab = bin.readUshorts(data, offset, count); \\n    if(cvg.fmt==2) cvg.tab = bin.readUshorts(data, offset, count*3);\\n\\n    //get min,max\\n\\n    var min = Number.POSITIVE_INFINITY, max = 0;\\n    var tab = cvg.tab;\\n\\n    if(cvg.fmt==1) {\\n\\n        for(var i=0; i<tab.length; i++) {\\n            var v = tab[i];\\n            if (v > max) max = v;\\n            if (v < min) min = v;\\n        }\\n    }\\n\\n    if(cvg.fmt==2) {\\n        for(var i=0; i<tab.length; i+=3) {\\n            var start = tab[i], end = tab[i+1];\\n            if (start > max) max = start;\\n            if (start < min) min = start;\\n            if (end > max) max = end;\\n            if (end < min) min = end;\\n        }\\n    }\\n\\n    cvg.min = min;\\n    cvg.max = max;\\n\\n    return cvg;\\n}\\n\\nTypr._lctf.coverageIndex = function(cvg, val) {\\n    if (val < cvg.min || val > cvg.max) {\\n        return -1;\\n    }\\n\\n    var tab = cvg.tab;\\n    if(cvg.fmt==1) return tab.indexOf(val);\\n    \\n    for(var i=0; i<tab.length; i+=3) {\\n        var start = tab[i], end = tab[i+1], index = tab[i+2];\\n        if(start<=val && val<=end) return index + (val-start);\\n    }\\n    return -1;\\n}\\n\\nTypr._lctf.readFeatureList = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = [];\\n    \\n    var count = bin.readUshort(data, offset);  offset+=2;\\n    \\n    for(var i=0; i<count; i++) {\\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\\n        var noff = bin.readUshort(data, offset);  offset+=2;\\n        obj.push({tag: tag.trim(), tab:Typr._lctf.readFeatureTable(data, offset0 + noff)});\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readFeatureTable = function(data, offset) {\\n    var bin = Typr._bin;\\n    \\n    var featureParams = bin.readUshort(data, offset);  offset+=2;   // = 0\\n    var lookupCount = bin.readUshort(data, offset);  offset+=2;\\n    \\n    var indices = [];\\n    for(var i=0; i<lookupCount; i++) indices.push(bin.readUshort(data, offset+2*i));\\n    return indices;\\n}\\n\\n\\nTypr._lctf.readScriptList = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    var count = bin.readUshort(data, offset);  offset+=2;\\n    \\n    for(var i=0; i<count; i++) {\\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\\n        var noff = bin.readUshort(data, offset);  offset+=2;\\n        obj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readScriptTable = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    var defLangSysOff = bin.readUshort(data, offset);  offset+=2;\\n    obj.default = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);\\n    \\n    var langSysCount = bin.readUshort(data, offset);  offset+=2;\\n    \\n    for(var i=0; i<langSysCount; i++) {\\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\\n        var langSysOff = bin.readUshort(data, offset);  offset+=2;\\n        obj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readLangSysTable = function(data, offset) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    \\n    var lookupOrder = bin.readUshort(data, offset);  offset+=2;\\n    //if(lookupOrder!=0)  throw \\\"lookupOrder not 0\\\";\\n    obj.reqFeature = bin.readUshort(data, offset);  offset+=2;\\n    //if(obj.reqFeature != 0xffff) throw \\\"reqFeatureIndex != 0xffff\\\";\\n    \\n    //console.log(lookupOrder, obj.reqFeature);\\n    \\n    var featureCount = bin.readUshort(data, offset);  offset+=2;\\n    obj.features = bin.readUshorts(data, offset, featureCount);\\n    return obj;\\n}\\n\\n\\nTypr.cmap = {};\\nTypr.cmap.parse = function(data, offset, length) {\\n    data = new Uint8Array(data.buffer, offset, length);\\n    offset = 0;\\n\\n    var offset0 = offset;\\n    var bin = Typr._bin;\\n    var obj = {};\\n    var version   = bin.readUshort(data, offset);  offset += 2;\\n    var numTables = bin.readUshort(data, offset);  offset += 2;\\n    \\n    //console.log(version, numTables);\\n    \\n    var offs = [];\\n    obj.tables = [];\\n    \\n    \\n    for(var i=0; i<numTables; i++) {\\n        var platformID = bin.readUshort(data, offset);  offset += 2;\\n        var encodingID = bin.readUshort(data, offset);  offset += 2;\\n        var noffset = bin.readUint(data, offset);       offset += 4;\\n        \\n        var id = \\\"p\\\"+platformID+\\\"e\\\"+encodingID;\\n        \\n        //console.log(\\\"cmap subtable\\\", platformID, encodingID, noffset);\\n                \\n        var tind = offs.indexOf(noffset);\\n        \\n        if(tind==-1) {\\n            tind = obj.tables.length;\\n            var subt;\\n            offs.push(noffset);\\n            var format = bin.readUshort(data, noffset);\\n            if     (format== 0) subt = Typr.cmap.parse0(data, noffset);\\n            else if(format== 4) subt = Typr.cmap.parse4(data, noffset);\\n            else if(format== 6) subt = Typr.cmap.parse6(data, noffset);\\n            else if(format==12) subt = Typr.cmap.parse12(data,noffset);\\n            else console.log(\\\"unknown format: \\\"+format, platformID, encodingID, noffset);\\n            obj.tables.push(subt);\\n        }\\n        \\n        if(obj[id]!=null) throw \\\"multiple tables for one platform+encoding\\\";\\n        obj[id] = tind;\\n    }\\n    return obj;\\n}\\n\\nTypr.cmap.parse0 = function(data, offset) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    obj.format = bin.readUshort(data, offset);  offset += 2;\\n    var len    = bin.readUshort(data, offset);  offset += 2;\\n    var lang   = bin.readUshort(data, offset);  offset += 2;\\n    obj.map = [];\\n    for(var i=0; i<len-6; i++) obj.map.push(data[offset+i]);\\n    return obj;\\n}\\n\\nTypr.cmap.parse4 = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    obj.format = bin.readUshort(data, offset);  offset+=2;\\n    var length = bin.readUshort(data, offset);  offset+=2;\\n    var language = bin.readUshort(data, offset);  offset+=2;\\n    var segCountX2 = bin.readUshort(data, offset);  offset+=2;\\n    var segCount = segCountX2/2;\\n    obj.searchRange = bin.readUshort(data, offset);  offset+=2;\\n    obj.entrySelector = bin.readUshort(data, offset);  offset+=2;\\n    obj.rangeShift = bin.readUshort(data, offset);  offset+=2;\\n    obj.endCount   = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\\n    offset+=2;\\n    obj.startCount = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\\n    obj.idDelta = [];\\n    for(var i=0; i<segCount; i++) {obj.idDelta.push(bin.readShort(data, offset));  offset+=2;}\\n    obj.idRangeOffset = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\\n    obj.glyphIdArray = [];\\n    while(offset< offset0+length) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\\n    return obj;\\n}\\n\\nTypr.cmap.parse6 = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    obj.format = bin.readUshort(data, offset);  offset+=2;\\n    var length = bin.readUshort(data, offset);  offset+=2;\\n    var language = bin.readUshort(data, offset);  offset+=2;\\n    obj.firstCode = bin.readUshort(data, offset);  offset+=2;\\n    var entryCount = bin.readUshort(data, offset);  offset+=2;\\n    obj.glyphIdArray = [];\\n    for(var i=0; i<entryCount; i++) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\\n    \\n    return obj;\\n}\\n\\nTypr.cmap.parse12 = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    obj.format = bin.readUshort(data, offset);  offset+=2;\\n    offset += 2;\\n    var length = bin.readUint(data, offset);  offset+=4;\\n    var lang   = bin.readUint(data, offset);  offset+=4;\\n    var nGroups= bin.readUint(data, offset);  offset+=4;\\n    obj.groups = [];\\n    \\n    for(var i=0; i<nGroups; i++) {\\n        var off = offset + i * 12;\\n        var startCharCode = bin.readUint(data, off+0);\\n        var endCharCode   = bin.readUint(data, off+4);\\n        var startGlyphID  = bin.readUint(data, off+8);\\n        obj.groups.push([  startCharCode, endCharCode, startGlyphID  ]);\\n    }\\n    return obj;\\n}\\n\\n\\n\\nTypr.GPOS = {};\\nTypr.GPOS.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);  }\\n\\n\\n\\nTypr.GPOS.subt = function(data, ltype, offset) { // lookup type\\n    if(ltype!=2) return null;\\n    \\n    var bin = Typr._bin, offset0 = offset, tab = {};\\n    \\n    tab.format  = bin.readUshort(data, offset);  offset+=2;\\n    var covOff  = bin.readUshort(data, offset);  offset+=2;\\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);\\n    tab.valFmt1 = bin.readUshort(data, offset);  offset+=2;\\n    tab.valFmt2 = bin.readUshort(data, offset);  offset+=2;\\n    var ones1 = Typr._lctf.numOfOnes(tab.valFmt1);\\n    var ones2 = Typr._lctf.numOfOnes(tab.valFmt2);\\n\\n    if(tab.format==1) {\\n        tab.pairsets = [];\\n        var count = bin.readUshort(data, offset);  offset+=2;\\n        \\n        for(var i=0; i<count; i++) {\\n            var psoff = bin.readUshort(data, offset);  offset+=2;\\n            psoff += offset0;\\n            var pvcount = bin.readUshort(data, psoff);  psoff+=2;\\n            var arr = [];\\n\\n            for(var j=0; j<pvcount; j++) {\\n                var gid2 = bin.readUshort(data, psoff);  psoff+=2;\\n                var value1, value2;\\n                if(tab.valFmt1!=0) {  value1 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt1);  psoff+=ones1*2;  }\\n                if(tab.valFmt2!=0) {  value2 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt2);  psoff+=ones2*2;  }\\n                arr.push({gid2:gid2, val1:value1, val2:value2});\\n            }\\n            tab.pairsets.push(arr);\\n        }\\n    }\\n\\n    if(tab.format==2) {\\n        var classDef1 = bin.readUshort(data, offset);  offset+=2;\\n        var classDef2 = bin.readUshort(data, offset);  offset+=2;\\n        var class1Count = bin.readUshort(data, offset);  offset+=2;\\n        var class2Count = bin.readUshort(data, offset);  offset+=2;\\n        \\n        tab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);\\n        tab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);\\n        \\n        tab.matrix = [];\\n        for(var i=0; i<class1Count; i++) {\\n            var row = [];\\n            for(var j=0; j<class2Count; j++) {\\n                var value1 = null, value2 = null;\\n                if(tab.valFmt1!=0) { value1 = Typr._lctf.readValueRecord(data, offset, tab.valFmt1);  offset+=ones1*2; }\\n                if(tab.valFmt2!=0) { value2 = Typr._lctf.readValueRecord(data, offset, tab.valFmt2);  offset+=ones2*2; }\\n                row.push({val1:value1, val2:value2});\\n            }\\n            tab.matrix.push(row);\\n        }\\n    }\\n    return tab;\\n}\\n\\nTypr.GSUB = {};\\nTypr.GSUB.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);  }\\n\\n\\nTypr.GSUB.subt = function(data, ltype, offset) { // lookup type\\n    var bin = Typr._bin, offset0 = offset, tab = {};\\n    \\n    if(ltype!=1 && ltype!=4) return null;\\n    \\n    tab.fmt  = bin.readUshort(data, offset);  offset+=2;\\n    var covOff  = bin.readUshort(data, offset);  offset+=2;\\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);   // not always is coverage here\\n    \\n    if(false) {}\\n    else if(ltype==1) {\\n        if(tab.fmt==1) {\\n            tab.delta = bin.readShort(data, offset);  offset+=2;\\n        }\\n        else if(tab.fmt==2) {\\n            var cnt = bin.readUshort(data, offset);  offset+=2;\\n            tab.newg = bin.readUshorts(data, offset, cnt);  offset+=tab.newg.length*2;\\n        }\\n    }\\n    else if(ltype==4) {\\n        tab.vals = [];\\n        var cnt = bin.readUshort(data, offset);  offset+=2;\\n        for(var i=0; i<cnt; i++) {\\n            var loff = bin.readUshort(data, offset);  offset+=2;\\n            tab.vals.push(Typr.GSUB.readLigatureSet(data, offset0+loff));\\n        }\\n        //console.log(tab.coverage);\\n        //console.log(tab.vals);\\n    } \\n    \\n    return tab;\\n}\\n\\nTypr.GSUB.readChainSubClassSet = function(data, offset) {\\n    var bin = Typr._bin, offset0 = offset, lset = [];\\n    var cnt = bin.readUshort(data, offset);  offset+=2;\\n    for(var i=0; i<cnt; i++) {\\n        var loff = bin.readUshort(data, offset);  offset+=2;\\n        lset.push(Typr.GSUB.readChainSubClassRule(data, offset0+loff));\\n    }\\n    return lset;\\n}\\n\\nTypr.GSUB.readChainSubClassRule= function(data, offset) {\\n    var bin = Typr._bin, offset0 = offset, rule = {};\\n    var pps = [\\\"backtrack\\\", \\\"input\\\", \\\"lookahead\\\"];\\n    for(var pi=0; pi<pps.length; pi++) {\\n        var cnt = bin.readUshort(data, offset);  offset+=2;  if(pi==1) cnt--;\\n        rule[pps[pi]]=bin.readUshorts(data, offset, cnt);  offset+= rule[pps[pi]].length*2;\\n    }\\n    var cnt = bin.readUshort(data, offset);  offset+=2;\\n    rule.subst = bin.readUshorts(data, offset, cnt*2);  offset += rule.subst.length*2;\\n    return rule;\\n}\\n\\nTypr.GSUB.readLigatureSet = function(data, offset) {\\n    var bin = Typr._bin, offset0 = offset, lset = [];\\n    var lcnt = bin.readUshort(data, offset);  offset+=2;\\n    for(var j=0; j<lcnt; j++) {\\n        var loff = bin.readUshort(data, offset);  offset+=2;\\n        lset.push(Typr.GSUB.readLigature(data, offset0+loff));\\n    }\\n    return lset;\\n}\\n\\nTypr.GSUB.readLigature = function(data, offset) {\\n    var bin = Typr._bin, lig = {chain:[]};\\n    lig.nglyph = bin.readUshort(data, offset);  offset+=2;\\n    var ccnt = bin.readUshort(data, offset);  offset+=2;\\n    for(var k=0; k<ccnt-1; k++) {  lig.chain.push(bin.readUshort(data, offset));  offset+=2;  }\\n    return lig;\\n}\\n\\n\\n\\nTypr.head = {};\\nTypr.head.parse = function(data, offset, length) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\\n    obj.fontRevision = bin.readFixed(data, offset);  offset += 4;\\n    var checkSumAdjustment = bin.readUint(data, offset);  offset += 4;\\n    var magicNumber = bin.readUint(data, offset);  offset += 4;\\n    obj.flags = bin.readUshort(data, offset);  offset += 2;\\n    obj.unitsPerEm = bin.readUshort(data, offset);  offset += 2;\\n    obj.created  = bin.readUint64(data, offset);  offset += 8;\\n    obj.modified = bin.readUint64(data, offset);  offset += 8;\\n    obj.xMin = bin.readShort(data, offset);  offset += 2;\\n    obj.yMin = bin.readShort(data, offset);  offset += 2;\\n    obj.xMax = bin.readShort(data, offset);  offset += 2;\\n    obj.yMax = bin.readShort(data, offset);  offset += 2;\\n    obj.macStyle = bin.readUshort(data, offset);  offset += 2;\\n    obj.lowestRecPPEM = bin.readUshort(data, offset);  offset += 2;\\n    obj.fontDirectionHint = bin.readShort(data, offset);  offset += 2;\\n    obj.indexToLocFormat  = bin.readShort(data, offset);  offset += 2;\\n    obj.glyphDataFormat   = bin.readShort(data, offset);  offset += 2;\\n    return obj;\\n}\\n\\n\\nTypr.hhea = {};\\nTypr.hhea.parse = function(data, offset, length) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\\n    obj.ascender  = bin.readShort(data, offset);  offset += 2;\\n    obj.descender = bin.readShort(data, offset);  offset += 2;\\n    obj.lineGap = bin.readShort(data, offset);  offset += 2;\\n    \\n    obj.advanceWidthMax = bin.readUshort(data, offset);  offset += 2;\\n    obj.minLeftSideBearing  = bin.readShort(data, offset);  offset += 2;\\n    obj.minRightSideBearing = bin.readShort(data, offset);  offset += 2;\\n    obj.xMaxExtent = bin.readShort(data, offset);  offset += 2;\\n    \\n    obj.caretSlopeRise = bin.readShort(data, offset);  offset += 2;\\n    obj.caretSlopeRun  = bin.readShort(data, offset);  offset += 2;\\n    obj.caretOffset    = bin.readShort(data, offset);  offset += 2;\\n    \\n    offset += 4*2;\\n    \\n    obj.metricDataFormat = bin.readShort (data, offset);  offset += 2;\\n    obj.numberOfHMetrics = bin.readUshort(data, offset);  offset += 2;\\n    return obj;\\n}\\n\\n\\nTypr.hmtx = {};\\nTypr.hmtx.parse = function(data, offset, length, font) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    \\n    obj.aWidth = [];\\n    obj.lsBearing = [];\\n        \\n    var aw = 0, lsb = 0;\\n    \\n    for(var i=0; i<font.maxp.numGlyphs; i++) {\\n        if(i<font.hhea.numberOfHMetrics) {  aw=bin.readUshort(data, offset);  offset += 2;  lsb=bin.readShort(data, offset);  offset+=2;  }\\n        obj.aWidth.push(aw);\\n        obj.lsBearing.push(lsb);\\n    }\\n    \\n    return obj;\\n}\\n\\n\\nTypr.kern = {};\\nTypr.kern.parse = function(data, offset, length, font) {\\n    var bin = Typr._bin;\\n    \\n    var version = bin.readUshort(data, offset);  offset+=2;\\n    if(version==1) return Typr.kern.parseV1(data, offset-2, length, font);\\n    var nTables = bin.readUshort(data, offset);  offset+=2;\\n    \\n    var map = {glyph1: [], rval:[]};\\n    for(var i=0; i<nTables; i++) {\\n        offset+=2;  // skip version\\n        var length  = bin.readUshort(data, offset);  offset+=2;\\n        var coverage = bin.readUshort(data, offset);  offset+=2;\\n        var format = coverage>>>8;\\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\\n        else throw \\\"unknown kern table format: \\\"+format;\\n    }\\n    return map;\\n}\\n\\nTypr.kern.parseV1 = function(data, offset, length, font) {\\n    var bin = Typr._bin;\\n    \\n    var version = bin.readFixed(data, offset);  offset+=4;\\n    var nTables = bin.readUint(data, offset);  offset+=4;\\n    \\n    var map = {glyph1: [], rval:[]};\\n    for(var i=0; i<nTables; i++) {\\n        var length = bin.readUint(data, offset);   offset+=4;\\n        var coverage = bin.readUshort(data, offset);  offset+=2;\\n        var tupleIndex = bin.readUshort(data, offset);  offset+=2;\\n        var format = coverage>>>8;\\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\\n        else throw \\\"unknown kern table format: \\\"+format;\\n    }\\n    return map;\\n}\\n\\nTypr.kern.readFormat0 = function(data, offset, map) {\\n    var bin = Typr._bin;\\n    var pleft = -1;\\n    var nPairs        = bin.readUshort(data, offset);  offset+=2;\\n    var searchRange   = bin.readUshort(data, offset);  offset+=2;\\n    var entrySelector = bin.readUshort(data, offset);  offset+=2;\\n    var rangeShift    = bin.readUshort(data, offset);  offset+=2;\\n    for(var j=0; j<nPairs; j++) {\\n        var left  = bin.readUshort(data, offset);  offset+=2;\\n        var right = bin.readUshort(data, offset);  offset+=2;\\n        var value = bin.readShort (data, offset);  offset+=2;\\n        if(left!=pleft) { map.glyph1.push(left);  map.rval.push({ glyph2:[], vals:[] }) }\\n        var rval = map.rval[map.rval.length-1];\\n        rval.glyph2.push(right);   rval.vals.push(value);\\n        pleft = left;\\n    }\\n    return offset;\\n}\\n\\n\\n\\nTypr.maxp = {};\\nTypr.maxp.parse = function(data, offset, length) {\\n    //console.log(data.length, offset, length);\\n    \\n    var bin = Typr._bin;\\n    var obj = {};\\n    \\n    // both versions 0.5 and 1.0\\n    var ver = bin.readUint(data, offset); offset += 4;\\n    obj.numGlyphs = bin.readUshort(data, offset);  offset += 2;\\n    \\n    // only 1.0\\n    if(ver == 0x00010000) {\\n        obj.maxPoints             = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxContours           = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxCompositePoints    = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxCompositeContours  = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxZones              = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxTwilightPoints     = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxStorage            = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxFunctionDefs       = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxInstructionDefs    = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxStackElements      = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxSizeOfInstructions = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxComponentElements  = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxComponentDepth     = bin.readUshort(data, offset);  offset += 2;\\n    }\\n    \\n    return obj;\\n}\\n\\n\\nTypr.U = {};\\n\\nTypr.U.codeToGlyph = function(font, code) {\\n    var cmap = font.cmap;\\n    \\n    \\n    var tind = -1;\\n    if(cmap.p0e4!=null) tind = cmap.p0e4;\\n    else if(cmap.p3e1!=null) tind = cmap.p3e1;\\n    else if(cmap.p1e0!=null) tind = cmap.p1e0;\\n    \\n    if(tind==-1) throw \\\"no familiar platform and encoding!\\\";\\n    \\n    var tab = cmap.tables[tind];\\n    \\n    if (tab.format==0) {\\n        if(code>=tab.map.length) return 0;\\n        return tab.map[code];\\n    } else if(tab.format==4) {\\n        var sind = -1;\\n        for(var i=0; i<tab.endCount.length; i++)   if(code<=tab.endCount[i]){  sind=i;  break;  } \\n        if(sind==-1) return 0;\\n        if(tab.startCount[sind]>code) return 0;\\n        \\n        var gli = 0;\\n        if(tab.idRangeOffset[sind]!=0) gli = tab.glyphIdArray[(code-tab.startCount[sind]) + (tab.idRangeOffset[sind]>>1) - (tab.idRangeOffset.length-sind)];\\n        else                           gli = code + tab.idDelta[sind];\\n        return gli & 0xFFFF;\\n    } else if(tab.format==12) {\\n        if(code>tab.groups[tab.groups.length-1][1]) return 0;\\n        for(var i=0; i<tab.groups.length; i++) {\\n            var grp = tab.groups[i];\\n            if(grp[0]<=code && code<=grp[1]) return grp[2] + (code-grp[0]);\\n        }\\n        return 0;\\n    }\\n    else throw \\\"unknown cmap table format \\\"+tab.format;\\n}\\n\\n\\nTypr.U._getGlyphClass = function(g, cd) {\\n    for(var i=0; i<cd.start.length; i++) \\n        if(cd.start[i]<=g && cd.end[i]>=g) return cd.class[i];\\n    return 0;\\n}\\n\\nTypr.U.getPairAdjustment = function(font, g1, g2) {\\n    if(font.GPOS) {\\n        var ltab = null;\\n        for(var i = 0; i < font.GPOS.featureList.length; i++) {\\n            var fl = font.GPOS.featureList[i];\\n            if (fl.tag==\\\"kern\\\")\\n                for(var j=0; j<fl.tab.length; j++) \\n                    if(font.GPOS.lookupList[fl.tab[j]].ltype==2) ltab=font.GPOS.lookupList[fl.tab[j]];\\n        }\\n        if(ltab) {\\n            for(var i = 0; i < ltab.tabs.length; i++) {\\n                var tab = ltab.tabs[i];\\n                var ind = Typr._lctf.coverageIndex(tab.coverage, g1);\\n                if (ind==-1) continue;\\n                var adj = 0;\\n                if (tab.format==1) {\\n                    var right = tab.pairsets[ind];\\n                    for (var j=0; j<right.length; j++) if (right[j].gid2==g2) adj = right[j];\\n                    if (adj==null) continue;\\n                } else if (tab.format==2) {\\n                    var c1 = Typr.U._getGlyphClass(g1, tab.classDef1);\\n                    var c2 = Typr.U._getGlyphClass(g2, tab.classDef2);\\n                    adj = tab.matrix[c1][c2];\\n                }\\n                return adj.val1[2];\\n            }\\n        }\\n    }\\n    if(font.kern) {\\n        var ind1 = font.kern.glyph1.indexOf(g1);\\n        if(ind1!=-1) {\\n            var ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);\\n            if(ind2!=-1) return font.kern.rval[ind1].vals[ind2];\\n        }\\n    }\\n    \\n    return 0;\\n}\\n\\n/*\\nTypr.U.isRTL = function(str) {           \\n    var weakChars       = '\\\\u0000-\\\\u0040\\\\u005B-\\\\u0060\\\\u007B-\\\\u00BF\\\\u00D7\\\\u00F7\\\\u02B9-\\\\u02FF\\\\u2000-\\\\u2BFF\\\\u2010-\\\\u2029\\\\u202C\\\\u202F-\\\\u2BFF',\\n        rtlChars        = '\\\\u0591-\\\\u07FF\\\\u200F\\\\u202B\\\\u202E\\\\uFB1D-\\\\uFDFD\\\\uFE70-\\\\uFEFC',\\n        rtlDirCheck     = new RegExp('^['+weakChars+']*['+rtlChars+']');\\n\\n    return rtlDirCheck.test(str);\\n};*/\\n\\n// var wsep = \\\"\\\\n\\\\t\\\\\\\" ,.:;!?()  ،\\\";\\n//Typr.U.WSepTable = [9, 10, 32, 33, 34, 40, 41, 44, 46, 58, 59, 63, 1548]\\n\\n//var L = \\\"ꡲ્૗\\\";\\n//Typr.U.LTable = [ 2765, 2775, 43122 ]\\n\\n//var R = \\\"آأؤإاةدذرزوٱٲٳٵٶٷڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙۀۃۄۅۆۇۈۉۊۋۍۏےۓەۮۯܐܕܖܗܘܙܞܨܪܬܯݍݙݚݛݫݬݱݳݴݸݹࡀࡆࡇࡉࡔࡧࡩࡪࢪࢫࢬࢮࢱࢲࢹૅેૉ૊૎૏ૐ૑૒૝ૡ૤૯஁ஃ஄அஉ஌எஏ஑னப஫஬\\\";\\nTypr.U.RTable = [\\n    1570, 1571, 1572, 1573, 1575, 1577, 1583, 1584, 1585, 1586,\\n    1608, 1649, 1650, 1651, 1653, 1654, 1655, 1672, 1673, 1674,\\n    1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684,\\n    1685, 1686, 1687, 1688, 1689, 1728, 1731, 1732, 1733, 1734,\\n    1735, 1736, 1737, 1738, 1739, 1741, 1743, 1746, 1747, 1749,\\n    1774, 1775, 1808, 1813, 1814, 1815, 1816, 1817, 1822, 1832,\\n    1834, 1836, 1839, 1869, 1881, 1882, 1883, 1899, 1900, 1905,\\n    1907, 1908, 1912, 1913, 2112, 2118, 2119, 2121, 2132, 2151,\\n    2153, 2154, 2218, 2219, 2220, 2222, 2225, 2226, 2233, 2757,\\n    2759, 2761, 2762, 2766, 2767, 2768, 2769, 2770, 2781, 2785,\\n    2788, 2799, 2945, 2947, 2948, 2949, 2953, 2956, 2958, 2959,\\n    2961, 2985, 2986, 2987, 2988 ];\\n\\n\\nTypr.U.stringToGlyphs = function(fonts, str) {\\n    var gls = [], g, i, li, j, lj, k, ti, c, c2, gsub, font, llist, flist, t, gsubTable;\\n    var gl, gfonts = [], codes = [], scodes = [], scodesType = [], str2 = '';\\n\\n    var bidiResult = bidi(str, -1, false);\\n\\n    var rtable = Typr.U.RTable;\\n\\n   for (i = 0, li = str.length; i < li; i++) {\\n        c = str.charCodeAt(i);\\n        scodes.push(c);\\n        scodesType.push(0);\\n\\n        //types wsep = 1, L = 2, R = 3\\n\\n        if (c == 2765 || c == 2775 || c == 43122) { // L\\n            scodesType[i] = 2;\\n        } else if (c == 1548) { // wsep\\n            scodesType[i] = 1;\\n        } else if (c <= 63) { // wsep\\n            if (c == 9 || c == 10 || c == 32 || c == 33 || c == 34 || c == 40 || c == 41 || c == 44 || c == 46 || c == 58 || c == 59 || c == 63) {\\n                scodesType[i] = 1;\\n            }\\n        } else if (c >= 1570 && c <= 2988) { // R\\n            if (rtable.indexOf(c) != -1) {\\n                scodesType[i] = 3;\\n            }\\n        }\\n    }\\n\\n    //basic shaping\\n    for (i = 0, li = str.length; i < li; i++) {\\n        c = scodes[i];\\n\\n        if (scodesType[i] != 1) { //not wsep\\n            if (i < li - 2) {\\n                c2 = scodes[i+1];\\n\\n                //myanmar \\n                if (c2 == 0x103c) { //medial ra - prebase substitution\\n                    scodes[i] = c2;\\n                    scodes[i+1] = c;\\n                    i++;\\n                    continue;\\n                }\\n            }\\n        }\\n    }\\n\\n    //get glyphs and fonts for codes\\n    for (i = 0, li = str.length; i < li; i++) {\\n        c = scodes[i];\\n\\n        for (j = 0, lj = fonts.length; j < lj; j++) {\\n            font = fonts[j];\\n            g = Typr.U.codeToGlyph(font, c);\\n            if (g) {\\n                break;\\n            }\\n        }\\n\\n        gls.push(g);\\n        gfonts.push(g ? j : 0);\\n    }\\n\\n    codes = scodes;\\n    font = null;\\n    \\n    \\n    for(var ci = 0; ci < gls.length; ci++) {\\n        gl = gls[ci];\\n\\n        if (font != gfonts[ci]) {\\n            font = fonts[gfonts[ci]];\\n            gsub = font['GSUB'];\\n        }\\n\\n        if(!gsub) {\\n            continue;\\n        }\\n\\n        var t1 = scodesType[ci-1], t2 = scodesType[ci], t3 = scodesType[ci+1];\\n\\n        var slft = (ci==0) || (t1 == 1);\\n        var srgt = (ci==gls.length-1) || (t3 == 1);\\n        \\n        if(!slft && (t1 == 3)) slft=true;\\n        if(!srgt && (t2 == 3)) srgt=true;\\n        \\n        if(!srgt && (t3 == 2)) srgt=true;\\n        if(!slft && (t2 == 2)) slft=true;\\n        \\n        gsubTable = null;\\n        if (slft) {\\n            gsubTable = srgt ? font.gsubIsolTable : font.gsubInitTable;        \\n        } else {\\n            gsubTable = srgt ? font.gsubFinaTable : font.gsubMediTable;            \\n        }\\n        \\n        if (gsubTable) {\\n            for(ti = 0; ti < gsubTable.length; ti++) {\\n                var tab = gsubTable[ti];\\n\\n                for(j = 0; j < tab.length; j++) {\\n                    var ttab = tab[j];\\n                    var ind = Typr._lctf.coverageIndex(ttab.coverage,gl);\\n                    if(ind == -1) continue;  \\n\\n                    if(ttab.fmt == 0) {\\n                        gls[ci] = ind+ttab.delta;\\n                    } else {\\n                        if (!ttab.newg) {\\n                            gls[ci] = gl;\\n                            console.log(ci, gl, 'subst-error', ' original:', str);\\n                        } else {\\n                            gls[ci] = ttab.newg[ind];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    font = null;\\n    \\n    for(var ci=0; ci<gls.length; ci++) {\\n        gl = gls[ci];\\n\\n        if (font != gfonts[ci]) {\\n            font = fonts[gfonts[ci]];\\n            gsub = font['GSUB'];\\n        }\\n\\n        if(!gsub) {\\n            continue;\\n        }\\n\\n        gsubTable = font.gsubRligLigaTable;\\n\\n        if (gsubTable) {\\n            var rlim = Math.min(3, gls.length-ci-1);\\n\\n            for(ti = 0; ti < gsubTable.length; ti++) {\\n                var tab = gsubTable[ti];\\n\\n                for(j = 0; j < tab.length; j++) {\\n                    var ttab = tab[j];\\n                    var ind = Typr._lctf.coverageIndex(ttab.coverage, gl);\\n                    if(ind==-1) continue;  \\n\\n                    var vals = ttab.vals[ind];\\n                    \\n                    for(k=0; k<vals.length; k++) {\\n                        var lig = vals[k], rl = lig.chain.length;  if(rl>rlim) continue;\\n                        var good = true;\\n                        for(var l=0; l<rl; l++) if(lig.chain[l]!=gls[ci+(1+l)]) good=false;\\n                        if(!good) continue;\\n                        gls[ci]=lig.nglyph;\\n                        for(var l=0; l<rl; l++) gls[ci+l+1]=-1;\\n                        //console.log(\\\"lig\\\", fl.tag,  gl, lig.chain, lig.nglyph);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    var indices = bidiResult.indices;\\n    var gls2 = gls.slice();\\n    var codes2 = codes.slice();\\n    var gfonts2 = gfonts.slice();\\n\\n    for (i = 0, li = gls.length; i < li; i++) {\\n        c = indices[i];\\n        gls2[i] = gls[c];\\n        codes2[i] = codes[c];\\n        gfonts2[i] = gfonts[c];\\n    }\\n\\n    return [gls2, gfonts2, codes2];\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-globals.js\\\":\\n/*!**********************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-globals.js ***!\\n  \\\\**********************************************************/\\n/*! exports provided: globals, clamp, vec3Normalize, vec3Length, vec3Cross, simpleFmtCall, getHash, stringToUint8Array, unint8ArrayToString, Utf8ArrayToStr */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"globals\\\", function() { return globals; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"clamp\\\", function() { return clamp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"vec3Normalize\\\", function() { return vec3Normalize; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"vec3Length\\\", function() { return vec3Length; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"vec3Cross\\\", function() { return vec3Cross; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"simpleFmtCall\\\", function() { return simpleFmtCall; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getHash\\\", function() { return getHash; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"stringToUint8Array\\\", function() { return stringToUint8Array; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"unint8ArrayToString\\\", function() { return unint8ArrayToString; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Utf8ArrayToStr\\\", function() { return Utf8ArrayToStr; });\\n\\nvar globals = {\\n    stylesheetData : {},\\n    stylesheetLayers : {},\\n    stylesheetBitmaps : {},\\n    stylesheetFonts : {},\\n    stylesheetConstants : {},\\n    stylesheetVariables : {},\\n    insidePack : false,\\n    directPoints : [],\\n    directPoint : null,\\n    fonts : {},\\n    fontsMap : {},\\n    fontsStorage : {},\\n    forceOrigin : false,\\n    forceScale : [1,1,1],\\n    bboxMin : [0,0,0],\\n    bboxMax : [1,1,1],\\n    geocent : false,\\n    tileX : 0,\\n    tileY : 0,\\n    tileLod : 0,\\n    tileIX : 0,\\n    tileIY : 0,\\n    tileSize : 1,\\n    hitState : 0,\\n    pixelFactor : 1,\\n    alwaysEventInfo : true,\\n    metricUnits : true,\\n    language : 'en',\\n    groupOptimize : true,\\n    groupOrigin : [0,0,0],\\n    messageBuffer : new Array(65536),\\n    messageBufferIndex : 0,\\n    messageBufferSize : 65536,\\n    messagePackSize : 0,\\n    signatureCounter : 0,\\n    autoLod : false,\\n    featureType : null,\\n    groupId : null,\\n    disableLog : false,\\n    reduceMode : 'scr-count4',\\n    reduceParams : null,\\n    processLineLabel : false,\\n    useLineLabel2 : true,\\n    lineLabelPass : 0\\n};\\n\\n\\nfunction clamp(value, min, max) {\\n    if (value < min) {\\n        value = min;\\n    }\\n\\n    if (value > max) {\\n        value = max;\\n    }\\n\\n    return value;\\n}\\n\\n\\nfunction vec3Normalize(a, b) {\\n    b || (b = a);\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = Math.sqrt(c * c + d * d + e * e);\\n    if (g) {\\n        if (g == 1) {\\n            b[0] = c;\\n            b[1] = d;\\n            b[2] = e;\\n            return b;\\n        }\\n    } else {\\n        b[0] = 0;\\n        b[1] = 0;\\n        b[2] = 0;\\n        return b;\\n    }\\n    g = 1 / g;\\n    b[0] = c * g;\\n    b[1] = d * g;\\n    b[2] = e * g;\\n    return b;\\n}\\n\\n\\nfunction vec3Length(a) {\\n    var b = a[0],\\n        c = a[1];\\n    a = a[2];\\n    return Math.sqrt(b * b + c * c + a * a);\\n}\\n\\n\\nfunction vec3Cross(a, b, c) {\\n    c || (c = a);\\n    var d = a[0],\\n        e = a[1];\\n    a = a[2];\\n    var g = b[0],\\n        f = b[1];\\n    b = b[2];\\n    c[0] = e * b - a * f;\\n    c[1] = a * g - d * b;\\n    c[2] = d * f - e * g;\\n    return c;\\n}\\n\\n\\nfunction getHash(str) {\\n    if (!str || str.length === 0) {\\n        return 0;    \\n    }\\n\\n    var hash = 0, c;\\n    for (var i = 0, li = str.length; i < li; i++) {\\n        c   = str.charCodeAt(i);\\n        hash  = ((hash << 5) - hash) + c;\\n        hash |= 0; // Convert to 32bit integer\\n    }\\n\\n    return hash;\\n}\\n\\n\\nvar simpleFmtCall = (function obj(str, call) {\\n    if (!str || str == '') {\\n        return '';\\n    }\\n\\n    var i = str.indexOf('{'), li, str2;\\n\\n    if (i == -1) {\\n        return str;\\n    } else {\\n        str2 = i > 0 ? str.substring(0, i) : '';\\n    }\\n\\n    var counter = 0;\\n    var begin = -1;\\n\\n    for (li = str.length; i < li; i++) {\\n        var c = str.charAt(i);\\n\\n        if (c == '{') {\\n            if (counter == 0) {\\n                begin = i;\\n            }\\n\\n            counter++;\\n        } else if (c == '}') {\\n            counter--;\\n\\n            if (counter == 0) {\\n                str2 += call(str.substring(begin+1, i));\\n            }\\n            \\n        } else if (counter == 0) {\\n            str2 += c;\\n        }\\n    }\\n\\n    return str2;\\n});\\n\\n/*\\nfunction copyArrayToBuffer(view, index, array) {\\n    for (var i = 0, li = array.length; i < li; i++) {\\n        view.setFloat32(index, array[i]); index += 4;\\n    }\\n\\n    return index;\\n}\\n\\nfunction copyDynamicArrayToBuffer(view, index, array) {\\n    if (array) {\\n        view.setUint8(index, array.length); index += 1;\\n\\n        for (var i = 0, li = array.length; i < li; i++) {\\n            view.setFloat32(index, array[i]); index += 4;\\n        }\\n    } else {\\n        view.setUint8(index, 0); index += 1;\\n    }\\n\\n    return index;\\n}\\n\\nfunction copyDynamicArrayOfArraysToBuffer(view, index, array) {\\n    if (array) {\\n        view.setUint16(index, array.length); index += 2;\\n\\n        for (var i = 0, li = array.length; i < li; i++) {\\n            var subarray = array[i];\\n\\n            for (var j = 0, lj = array.length; j < lj; j++) {\\n                view.setUint16(index, subarray[j]); index += 2;\\n            }\\n        }\\n    } else {\\n        view.setUint16(index, 0); index += 2;\\n    }\\n\\n    return index;\\n}\\n\\nfunction getSizeOfArrayOfArrays(array) {\\n    var size = 0;\\n\\n    for (var i = 0, li = array.length; i < li; i++) {\\n        size += array[i].length;\\n    }\\n\\n    return size;\\n}\\n*/\\n\\n//var textEncoderUtf8 = null; //(typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\\nvar textEncoderUtf8 = (typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\\n\\nfunction stringToUint8Array(str) {\\n    if (textEncoderUtf8) {\\n        return textEncoderUtf8.encode(str);\\n    } else {\\n\\n        /*\\n        console.log('' + (str.length * 2));\\n\\n        var buffer = new ArrayBuffer(str.length * 2);\\n        var view = new Uint16Array(buffer);\\n        for (var i = 0, li = str.length; i < li; i++) {\\n            view[i] = str.charCodeAt(i);\\n        }\\n        return new Uint8Array(buffer);\\n        */\\n\\n\\n        // 1. Let S be the DOMString value.\\n        var s = String(str);\\n\\n        // 2. Let n be the length of S.\\n        var n = s.length;\\n\\n        // 3. Initialize i to 0.\\n        var i = 0;\\n\\n        // 4. Initialize U to be an empty sequence of Unicode characters.\\n        var u = [];\\n\\n        // 5. While i < n:\\n        while (i < n) {\\n\\n          // 1. Let c be the code unit in S at index i.\\n          var c = s.charCodeAt(i);\\n\\n          // 2. Depending on the value of c:\\n\\n          // c < 0xD800 or c > 0xDFFF\\n          if (c < 0xD800 || c > 0xDFFF) {\\n            // Append to U the Unicode character with code point c.\\n            u.push(c);\\n          }\\n\\n          // 0xDC00 ≤ c ≤ 0xDFFF\\n          else if (0xDC00 <= c && c <= 0xDFFF) {\\n            // Append to U a U+FFFD REPLACEMENT CHARACTER.\\n            u.push(0xFFFD);\\n          }\\n\\n          // 0xD800 ≤ c ≤ 0xDBFF\\n          else if (0xD800 <= c && c <= 0xDBFF) {\\n            // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\\n            // CHARACTER.\\n            if (i === n - 1) {\\n              u.push(0xFFFD);\\n            }\\n            // 2. Otherwise, i < n−1:\\n            else {\\n              // 1. Let d be the code unit in S at index i+1.\\n              var d = s.charCodeAt(i + 1);\\n\\n              // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\\n              if (0xDC00 <= d && d <= 0xDFFF) {\\n                // 1. Let a be c & 0x3FF.\\n                var a = c & 0x3FF;\\n\\n                // 2. Let b be d & 0x3FF.\\n                var b = d & 0x3FF;\\n\\n                // 3. Append to U the Unicode character with code point\\n                // 2^16+2^10*a+b.\\n                u.push(0x10000 + (a << 10) + b);\\n\\n                // 4. Set i to i+1.\\n                i += 1;\\n              }\\n\\n              // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\\n              // U+FFFD REPLACEMENT CHARACTER.\\n              else  {\\n                u.push(0xFFFD);\\n              }\\n            }\\n          }\\n\\n          // 3. Set i to i+1.\\n          i += 1;\\n        }\\n\\n        // 6. Return U.\\n        return new Uint8Array((new Uint32Array(u)).buffer);        \\n    }\\n}\\n\\n/*\\nvar textDecoderUtf8 = TextEncoder ? (new TextDecoder('utf-8')) : null;\\n\\nfunction unint8ArrayToString(array) {\\n    if (textDecoderUtf8) {\\n        return textDecoderUtf8.decode(array);\\n    } else {\\n        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\\n    }\\n}\\n*/\\n\\n\\nvar textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\\n\\nfunction unint8ArrayToString(array, skip) {\\n    if (textDecoderUtf8 && !skip) {\\n        return textDecoderUtf8.decode(array);\\n    } else {\\n        // return String.fromCharCode.apply(null, new Uint8Array(array.buffer)); //works only for small strings\\n\\n        var s = '';\\n        //var code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\\n        var code_points2 = new Uint8Array(array.byteLength);\\n        code_points2.set(array);\\n        var code_points = new Uint32Array(code_points2.buffer);\\n\\n        for (var i = 0, li = code_points.length; i < li; ++i) {\\n          var cp = code_points[i];\\n          if (cp <= 0xFFFF) {\\n            s += String.fromCharCode(cp);\\n          } else {\\n            cp -= 0x10000;\\n            s += String.fromCharCode((cp >> 10) + 0xD800,\\n                                     (cp & 0x3FF) + 0xDC00);\\n          }\\n        }\\n        return s;\\n\\n    }\\n}\\n\\n\\nfunction Utf8ArrayToStr(array, skip) {  //more universal\\n    if (textDecoderUtf8 && !skip) {\\n        return textDecoderUtf8.decode(array);\\n    } else {\\n\\n        var out, i, len, c;\\n        var char2, char3;\\n\\n        array = new Uint8Array(array);\\n\\n        out = \\\"\\\";\\n        len = array.length;\\n        i = 0;\\n\\n        while(i < len) {\\n            c = array[i++];\\n\\n            switch(c >> 4) { \\n              case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\\n                // 0xxxxxxx\\n                out += String.fromCharCode(c);\\n                break;\\n              case 12: case 13:\\n                // 110x xxxx   10xx xxxx\\n                char2 = array[i++];\\n                out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\\n                break;\\n              case 14:\\n                // 1110 xxxx  10xx xxxx  10xx xxxx\\n                char2 = array[i++];\\n                char3 = array[i++];\\n                out += String.fromCharCode(((c & 0x0F) << 12) |\\n                               ((char2 & 0x3F) << 6) |\\n                               ((char3 & 0x3F) << 0));\\n                break;\\n            }\\n        }\\n\\n        return out;\\n    }\\n}\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-linestring.js\\\":\\n/*!*************************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-linestring.js ***!\\n  \\\\*************************************************************/\\n/*! exports provided: processLineStringPass, processLineLabel, processLineStringGeometry */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"processLineStringPass\\\", function() { return processLineStringPass; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"processLineLabel\\\", function() { return processLineLabel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"processLineStringGeometry\\\", function() { return processLineStringGeometry; });\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/geodata-processor/worker-globals.js\\\");\\n/* harmony import */ var _worker_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-style.js */ \\\"./src/core/map/geodata-processor/worker-style.js\\\");\\n/* harmony import */ var _worker_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-text.js */ \\\"./src/core/map/geodata-processor/worker-text.js\\\");\\n/* harmony import */ var _worker_message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-message.js */ \\\"./src/core/map/geodata-processor/worker-message.js\\\");\\n/* harmony import */ var _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./worker-pointarray.js */ \\\"./src/core/map/geodata-processor/worker-pointarray.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"], vec3Normalize = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"vec3Normalize\\\"],\\n    vec3Cross = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"vec3Cross\\\"];\\nvar getLayerPropertyValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\\\"getLayerPropertyValue\\\"],\\n    getLayerExpresionValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\\\"getLayerExpresionValue\\\"], hasLayerProperty = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\\\"hasLayerProperty\\\"];\\nvar addStreetTextOnPath = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"addStreetTextOnPath\\\"], areTextCharactersAvailable = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"areTextCharactersAvailable\\\"],\\n    getCharVerticesCount = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getCharVerticesCount\\\"], getFonts = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getFonts\\\"], getFontsStorage = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getFontsStorage\\\"];\\nvar postGroupMessageFast = _worker_message_js__WEBPACK_IMPORTED_MODULE_3__[\\\"postGroupMessageFast\\\"], getTextGlyphs = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getTextGlyphs\\\"];\\nvar checkDPoints = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\\\"checkDPoints\\\"];\\n\\n\\nvar getLineInfo = function(lineString, lod, style, featureIndex, zIndex, eventInfo) {\\n\\n};\\n\\nvar processLineStringPass = function(lineString, lod, style, featureIndex, zIndex, eventInfo) {\\n\\n    checkDPoints(lineString);\\n\\n    var lines = lineString['lines'];\\n\\n    if (!lines || lines.length == 0) {\\n        return;\\n    }\\n\\n    var line = getLayerPropertyValue(style, 'line', lineString, lod);\\n    var lineLabel = getLayerPropertyValue(style, 'line-label', lineString, lod);\\n\\n    if (!line && !lineLabel) {\\n        return;\\n    }\\n\\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\\n    var clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\\n\\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\\n\\n    if (hasLayerProperty(style,'line-type')) {\\n\\n    } else {\\n        var lineFlat = getLayerPropertyValue(style, 'line-flat', lineString, lod);\\n    }\\n\\n    var lineColor = getLayerPropertyValue(style, 'line-color', lineString, lod);\\n    var lineWidth = 0.5 * getLayerPropertyValue(style, 'line-width', lineString, lod);\\n    var lineWidthUnits = getLayerPropertyValue(style, 'line-width-units', lineString, lod);\\n\\n    var lineStyle = getLayerPropertyValue(style, 'line-style', lineString, lod);\\n    var lineStyleTexture = getLayerPropertyValue(style, 'line-style-texture', lineString, lod);\\n    var lineStyleBackground = getLayerPropertyValue(style, 'line-style-background', lineString, lod);\\n\\n    var lineLabelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\\n\\n    var texturedLine = (lineStyle != 'solid');\\n    var widthByRatio = (lineWidthUnits == 'ratio');\\n\\n    if (lineWidthUnits == 'points') {\\n        lineWidth *= globals.pixelFactor / ((1 / 72) * (96));\\n    }\\n\\n    var index = 0, index2 = 0, index3 = 0;\\n    var skipJoins = false;\\n\\n    if (widthByRatio) {\\n        skipJoins = (!lineFlat && ((lineWidth/* *globals.invPixelFactor*/)*1080) < 2.1);\\n    } else {\\n        skipJoins = (!lineFlat && (lineWidth/* *globals.invPixelFactor*/) < 2.1);        \\n    }\\n\\n    var ii, i, li, p2, v, vv, l, n, nn, p1, p, elementIndex, elemetBase = 1;\\n\\n    if (!skipJoins) {\\n        var circleBuffer = [];\\n        var circleBuffer2 = [];\\n        var circleSides = 8;//Math.max(8, (14 - lod) * 8);\\n    \\n        var angle = 0, step = (2.0*Math.PI) / circleSides;\\n    \\n        for (i = 0; i < circleSides; i++) {\\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\\n            circleBuffer2[i] = angle;\\n            angle += step;\\n        }\\n    \\n        circleBuffer[circleSides] = [0, 1.0];\\n        circleBuffer2[circleSides] = 0;\\n    }\\n\\n    var totalPoints = 0;\\n\\n    for (ii = 0; ii < lines.length; ii++) {\\n        if (Array.isArray(lines[ii])) {\\n            totalPoints += lines[ii].length;\\n        }\\n    }\\n\\n    if (totalPoints <= 1) {\\n        return;\\n    }\\n\\n    if (lineFlat) {\\n        circleSides = 2;\\n    }\\n\\n    //allocate buffers\\n    var lineVertices = ((texturedLine || (widthByRatio)) || !lineFlat ? 4 : 3) * 3 * 2;\\n    var joinVertices = skipJoins ? 0 : (circleSides * ((texturedLine || (widthByRatio)) || !lineFlat? 4 : 3) * 3);\\n    var vertexBuffer = new Float32Array((totalPoints-1) * lineVertices + totalPoints * joinVertices);\\n\\n    if (advancedHit) {\\n       var elementBuffer = new Float32Array((totalPoints-1) * (3 * 2) + totalPoints * (skipJoins ? 0 : circleSides) * 3);\\n    }\\n\\n    if (!(lineFlat && !texturedLine && !widthByRatio)) {\\n        var lineNormals = 3 * 4 * 2;\\n        var joinNormals = skipJoins ? 0 : (circleSides * 3 * 4);\\n        var normalBuffer = new Float32Array((totalPoints-1) * lineNormals + totalPoints * joinNormals);\\n    }\\n\\n    var center = [0,0,0];\\n    var lineLabelStack = [];\\n    var forceOrigin = globals.forceOrigin;\\n    var bboxMin = globals.bboxMin;\\n    var geocent = globals.geocent;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceScale = globals.forceScale;\\n    var vstart = [1,0,0], vend = [-1,0,0];\\n\\n    for (ii = 0; ii < lines.length; ii++) {\\n        if (!Array.isArray(lines[ii]) || !lines[ii].length) {\\n            continue;\\n        }\\n        \\n        var points = lines[ii];\\n\\n        if (lineLabel) {\\n            var lineLabelPoints = new Array(points.length);\\n            var lineLabelPoints2 = new Array(points.length);\\n            \\n            lineLabelStack.push({points: lineLabelPoints, points2 :lineLabelPoints2});\\n        }\\n    \\n        p = points[0];\\n        p1 = [p[0], p[1], p[2]];\\n    \\n        if (forceOrigin) {\\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n        }\\n    \\n        if (forceScale != null) {\\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n        }\\n    \\n        var distance = 0.001;\\n        var distance2 = 0.001;\\n        /*var ln = null;*/\\n        var vertexBase = index;\\n        var normalBase = index2;\\n\\n        //add lines\\n        for (i = 0, li = points.length - 1; i < li; i++) {\\n    \\n            p1 = points[i];\\n            p2 = points[i+1];\\n\\n            if (forceOrigin) {\\n                p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n                p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\\n            }\\n\\n            if (forceScale != null) {\\n                p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n                p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\\n            }\\n    \\n            if (advancedHit) {\\n                elementIndex = elemetBase + i;\\n\\n                elementBuffer[index3] = elementIndex;\\n                elementBuffer[index3+1] = elementIndex;\\n                elementBuffer[index3+2] = elementIndex;\\n    \\n                //add polygon\\n                elementBuffer[index3+3] = elementIndex;\\n                elementBuffer[index3+4] = elementIndex;\\n                elementBuffer[index3+5] = elementIndex;\\n\\n                index3 += 6;\\n            }\\n\\n            if (lineFlat && !texturedLine && !widthByRatio) {\\n\\n                //normalize vector to line width and rotate 90 degrees\\n                if (geocent) {\\n                    //direction vector\\n                    v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n        \\n                    //get line length\\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\\n                    distance2 += l;\\n        \\n                    l = (l != 0) ? (1 / l) : 0;\\n\\n                    vv = [v[0]*l, v[1]*l, v[2]*l];\\n                    n = [0,0,0];\\n                    nn = [0,0,0];\\n                    \\n                    vec3Normalize(bboxMin, nn);\\n                    vec3Cross(nn, vv, n);\\n\\n                    if (i == 0) {\\n                        vstart = vv;\\n                    }\\n\\n                    if (i == (li - 1)) {\\n                        vend = vv;\\n                    }\\n                    \\n                    n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\\n                } else {\\n                    //direction vector\\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\\n        \\n                    //get line length\\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\\n                    distance2 += l;\\n        \\n                    l = (l != 0) ? (lineWidth / l) : 0;\\n\\n                    n = [-v[1]*l, v[0]*l, 0];\\n\\n                    if (i == 0) {\\n                        vstart = [v[0]*l, v[1]*l, 0];\\n                    }\\n\\n                    if (i == (li - 1)) {\\n                        vend = [v[0]*l, v[1]*l, 0];\\n                    }\\n                }\\n                        \\n                //add polygon\\n                vertexBuffer[index] = p1[0] + n[0];\\n                vertexBuffer[index+1] = p1[1] + n[1];\\n                vertexBuffer[index+2] = p1[2] + n[2];\\n    \\n                vertexBuffer[index+3] = p1[0] - n[0];\\n                vertexBuffer[index+4] = p1[1] - n[1];\\n                vertexBuffer[index+5] = p1[2] - n[2];\\n    \\n                vertexBuffer[index+6] = p2[0] + n[0];\\n                vertexBuffer[index+7] = p2[1] + n[1];\\n                vertexBuffer[index+8] = p2[2] + n[2];\\n    \\n                //add polygon\\n                vertexBuffer[index+9] = p1[0] - n[0];\\n                vertexBuffer[index+10] = p1[1] - n[1];\\n                vertexBuffer[index+11] = p1[2] - n[2];\\n    \\n                vertexBuffer[index+12] = p2[0] - n[0];\\n                vertexBuffer[index+13] = p2[1] - n[1];\\n                vertexBuffer[index+14] = p2[2] - n[2];\\n    \\n                vertexBuffer[index+15] = p2[0] + n[0];\\n                vertexBuffer[index+16] = p2[1] + n[1];\\n                vertexBuffer[index+17] = p2[2] + n[2];\\n    \\n                index += 18;\\n\\n            } else {\\n    \\n   \\n                //console.log(\\\"distance(\\\"+i+\\\"): \\\" + distance + \\\" \\\" + distance2);\\n    \\n                if (lineFlat) {\\n                    \\n                    /*\\n                    //normalize vector to line width and rotate 90 degrees\\n                    l = (l != 0) ? (lineWidth / l) : 0;\\n                    n = [-v[1]*l, v[0]*l,0];\\n    \\n                    if (joinParams != null) {\\n                        joinParams[i] = (l != 0) ? Math.atan2(v[0], v[1]) + Math.PI *0.5 : 0;\\n                    }*/\\n    \\n                    //normalize vector to line width and rotate 90 degrees\\n                    if (geocent) {\\n                        //direction vector\\n                        v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n            \\n                        //get line length\\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\\n                        distance2 += l;\\n            \\n                        l = (l != 0) ? (1 / l) : 0;\\n\\n                        vv = [v[0]*l, v[1]*l, v[2]*l];\\n                        n = [0,0,0];\\n                        nn = [0,0,0];\\n\\n                        if (i == 0) {\\n                            vstart = vv;\\n                        }\\n\\n                        if (i == (li - 1)) {\\n                            vend = vv;\\n                        }\\n                        \\n                        vec3Normalize(bboxMin, nn);\\n                        vec3Cross(nn, vv, n);\\n                        \\n                        //n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\\n                        n = [n[0], n[1], n[2]];\\n                    } else {\\n                        //direction vector\\n                        v = [p2[0] - p1[0], p2[1] - p1[1], 0];\\n            \\n                        //get line length\\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\\n                        distance2 += l;\\n            \\n                        l = (l != 0) ? (lineWidth / l) : 0;\\n\\n                        n = [-v[1], v[0], 0];\\n\\n                        if (i == 0) {\\n                            vstart = [v[0]*l, v[1]*l, 0];\\n                        }\\n\\n                        if (i == (li - 1)) {\\n                            vend = [v[0]*l, v[1]*l, 0];\\n                        }\\n                    }\\n\\n                    //add polygon\\n                    vertexBuffer[index] = p1[0];\\n                    vertexBuffer[index+1] = p1[1];\\n                    vertexBuffer[index+2] = p1[2];\\n                    vertexBuffer[index+3] = distance;\\n                    normalBuffer[index2] = n[0];\\n                    normalBuffer[index2+1] = n[1];\\n                    normalBuffer[index2+2] = n[2];\\n                    normalBuffer[index2+3] = lineWidth;\\n    \\n                    vertexBuffer[index+4] = p1[0];\\n                    vertexBuffer[index+5] = p1[1];\\n                    vertexBuffer[index+6] = p1[2];\\n                    vertexBuffer[index+7] = -distance;\\n                    normalBuffer[index2+4] = -n[0];\\n                    normalBuffer[index2+5] = -n[1];\\n                    normalBuffer[index2+6] = -n[2];\\n                    normalBuffer[index2+7] = lineWidth;\\n    \\n                    vertexBuffer[index+8] = p2[0];\\n                    vertexBuffer[index+9] = p2[1];\\n                    vertexBuffer[index+10] = p2[2];\\n                    vertexBuffer[index+11] = distance2;\\n                    normalBuffer[index2+8] = n[0];\\n                    normalBuffer[index2+9] = n[1];\\n                    normalBuffer[index2+10] = n[2];\\n                    normalBuffer[index2+11] = lineWidth;\\n    \\n                    //add polygon\\n                    vertexBuffer[index+12] = p1[0];\\n                    vertexBuffer[index+13] = p1[1];\\n                    vertexBuffer[index+14] = p1[2];\\n                    vertexBuffer[index+15] = -distance;\\n                    normalBuffer[index2+12] = -n[0];\\n                    normalBuffer[index2+13] = -n[1];\\n                    normalBuffer[index2+14] = -n[2];\\n                    normalBuffer[index2+15] = lineWidth;\\n    \\n                    vertexBuffer[index+16] = p2[0];\\n                    vertexBuffer[index+17] = p2[1];\\n                    vertexBuffer[index+18] = p2[2];\\n                    vertexBuffer[index+19] = -distance2;\\n                    normalBuffer[index2+16] = -n[0];\\n                    normalBuffer[index2+17] = -n[1];\\n                    normalBuffer[index2+18] = -n[2];\\n                    normalBuffer[index2+19] = lineWidth;\\n    \\n                    vertexBuffer[index+20] = p2[0];\\n                    vertexBuffer[index+21] = p2[1];\\n                    vertexBuffer[index+22] = p2[2];\\n                    vertexBuffer[index+23] = distance2;\\n                    normalBuffer[index2+20] = n[0];\\n                    normalBuffer[index2+21] = n[1];\\n                    normalBuffer[index2+22] = n[2];\\n                    normalBuffer[index2+23] = lineWidth;\\n    \\n                    index += 24;\\n                    index2 += 24;\\n                    \\n                } else {\\n\\n                    //direction vector\\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\\n        \\n                    //get line length\\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\\n                    distance2 += l;\\n    \\n                    //add polygon\\n                    vertexBuffer[index] = p1[0];\\n                    vertexBuffer[index+1] = p1[1];\\n                    vertexBuffer[index+2] = p1[2];\\n                    vertexBuffer[index+3] = distance;\\n                    normalBuffer[index2] = p2[0];\\n                    normalBuffer[index2+1] = p2[1];\\n                    normalBuffer[index2+2] = p2[2];\\n                    normalBuffer[index2+3] = lineWidth;\\n    \\n                    vertexBuffer[index+4] = p1[0];\\n                    vertexBuffer[index+5] = p1[1];\\n                    vertexBuffer[index+6] = p1[2];\\n                    vertexBuffer[index+7] = -distance;\\n                    normalBuffer[index2+4] = p2[0];\\n                    normalBuffer[index2+5] = p2[1];\\n                    normalBuffer[index2+6] = p2[2];\\n                    normalBuffer[index2+7] = -lineWidth;\\n    \\n                    vertexBuffer[index+8] = p2[0];\\n                    vertexBuffer[index+9] = p2[1];\\n                    vertexBuffer[index+10] = p2[2];\\n                    vertexBuffer[index+11] = -distance2;\\n                    normalBuffer[index2+8] = p1[0];\\n                    normalBuffer[index2+9] = p1[1];\\n                    normalBuffer[index2+10] = p1[2];\\n                    normalBuffer[index2+11] = lineWidth;\\n    \\n                    //add polygon\\n                    vertexBuffer[index+12] = p1[0];\\n                    vertexBuffer[index+13] = p1[1];\\n                    vertexBuffer[index+14] = p1[2];\\n                    vertexBuffer[index+15] = distance;\\n                    normalBuffer[index2+12] = p2[0];\\n                    normalBuffer[index2+13] = p2[1];\\n                    normalBuffer[index2+14] = p2[2];\\n                    normalBuffer[index2+15] = lineWidth;\\n    \\n                    vertexBuffer[index+16] = p2[0];\\n                    vertexBuffer[index+17] = p2[1];\\n                    vertexBuffer[index+18] = p2[2];\\n                    vertexBuffer[index+19] = -distance2;\\n                    normalBuffer[index2+16] = p1[0];\\n                    normalBuffer[index2+17] = p1[1];\\n                    normalBuffer[index2+18] = p1[2];\\n                    normalBuffer[index2+19] = lineWidth;\\n    \\n                    vertexBuffer[index+20] = p2[0];\\n                    vertexBuffer[index+21] = p2[1];\\n                    vertexBuffer[index+22] = p2[2];\\n                    vertexBuffer[index+23] = distance2;\\n                    normalBuffer[index2+20] = p1[0];\\n                    normalBuffer[index2+21] = p1[1];\\n                    normalBuffer[index2+22] = p1[2];\\n                    normalBuffer[index2+23] = -lineWidth;\\n    \\n                    index += 24;\\n                    index2 += 24;\\n                }\\n            }\\n    \\n            distance = distance2;\\n            p1 = p2; //only for dlines\\n        }\\n    \\n        p1 = [p[0], p[1], p[2]];\\n    \\n        //add joins\\n        for (i = 0, li = points.length; i < li; i++) {\\n    \\n            if (forceOrigin) {\\n                p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n            }\\n    \\n            if (forceScale != null) {\\n                p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n            }\\n    \\n            center[0] += p1[0];\\n            center[1] += p1[1];\\n            center[2] += p1[2];\\n            \\n            if (!skipJoins) {\\n                var angleShift = 0;//(joinParams != null) ? joinParams[i] : 0;\\n                /*var dx, dy;*/\\n\\n                if (lineFlat) {\\n\\n                    if (advancedHit) {\\n                        elementIndex = elemetBase + ((i != (li-1)) ? i : (i -1));\\n\\n                        elementBuffer[index3] = elementIndex;\\n                        elementBuffer[index3+1] = elementIndex;\\n                        elementBuffer[index3+2] = elementIndex;\\n            \\n                        //add polygon\\n                        elementBuffer[index3+3] = elementIndex;\\n                        elementBuffer[index3+4] = elementIndex;\\n                        elementBuffer[index3+5] = elementIndex;\\n\\n                        index3 += 6;\\n                    }\\n\\n                    var lineIndex, lineIndex2;\\n\\n                    if (!(texturedLine || widthByRatio)) {\\n\\n                        if (i != (li-1)) {\\n                            lineIndex = vertexBase + i * lineVertices;\\n                        } else {\\n                            lineIndex = vertexBase + (i - 1) * lineVertices;\\n                        }\\n\\n                        if (i > 0) {\\n                            lineIndex2 = vertexBase + (i - 1) * lineVertices;\\n                        } else {\\n                            lineIndex2 = vertexBase + lineIndex;\\n                        }\\n\\n                        if (i == 0) { //start cap\\n                            //add polygon\\n                            vertexBuffer[index] = p1[0];\\n                            vertexBuffer[index+1] = p1[1];\\n                            vertexBuffer[index+2] = p1[2];\\n\\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\\n\\n                            vertexBuffer[index+6] = p1[0] - vstart[0] * lineWidth;\\n                            vertexBuffer[index+7] = p1[1] - vstart[1] * lineWidth;\\n                            vertexBuffer[index+8] = p1[2] - vstart[2] * lineWidth;\\n\\n                            //add polygon\\n                            vertexBuffer[index+9] = p1[0];\\n                            vertexBuffer[index+9+1] = p1[1];\\n                            vertexBuffer[index+9+2] = p1[2];\\n\\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\\n\\n                            vertexBuffer[index+9+6] = p1[0] - vstart[0] * lineWidth;\\n                            vertexBuffer[index+9+7] = p1[1] - vstart[1] * lineWidth;\\n                            vertexBuffer[index+9+8] = p1[2] - vstart[2] * lineWidth;\\n                        } else if (i == (li - 1)) {  //end cap\\n                            //add polygon\\n                            vertexBuffer[index] = p1[0];\\n                            vertexBuffer[index+1] = p1[1];\\n                            vertexBuffer[index+2] = p1[2];\\n\\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex+15];\\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+16];\\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+17];\\n\\n                            vertexBuffer[index+6] = p1[0] + vend[0] * lineWidth;\\n                            vertexBuffer[index+7] = p1[1] + vend[1] * lineWidth;\\n                            vertexBuffer[index+8] = p1[2] + vend[2] * lineWidth;\\n\\n                            //add polygon\\n                            vertexBuffer[index+9] = p1[0];\\n                            vertexBuffer[index+9+1] = p1[1];\\n                            vertexBuffer[index+9+2] = p1[2];\\n\\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+12];\\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+13];\\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+14];\\n\\n                            vertexBuffer[index+9+6] = p1[0] + vend[0] * lineWidth;\\n                            vertexBuffer[index+9+7] = p1[1] + vend[1] * lineWidth;\\n                            vertexBuffer[index+9+8] = p1[2] + vend[2] * lineWidth;\\n                        } else {\\n                            //add polygon\\n                            vertexBuffer[index] = p1[0];\\n                            vertexBuffer[index+1] = p1[1];\\n                            vertexBuffer[index+2] = p1[2];\\n\\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\\n\\n                            vertexBuffer[index+6] = vertexBuffer[lineIndex2 + 15];\\n                            vertexBuffer[index+7] = vertexBuffer[lineIndex2 + 16];\\n                            vertexBuffer[index+8] = vertexBuffer[lineIndex2 + 17];\\n\\n                            //add polygon\\n                            vertexBuffer[index+9] = p1[0];\\n                            vertexBuffer[index+9+1] = p1[1];\\n                            vertexBuffer[index+9+2] = p1[2];\\n\\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\\n\\n                            vertexBuffer[index+9+6] = vertexBuffer[lineIndex2 + 12];\\n                            vertexBuffer[index+9+7] = vertexBuffer[lineIndex2 + 13];\\n                            vertexBuffer[index+9+8] = vertexBuffer[lineIndex2 + 14];\\n                        }\\n\\n                        index += 18;\\n\\n                    } else {\\n\\n                        if (i != (li-1)) {\\n                            distance = vertexBuffer[i * lineVertices + 3];\\n                        } else {\\n                            distance = vertexBuffer[(i - 1) * lineVertices + 11];\\n                        }\\n\\n                        if (i != (li-1)) {\\n                            lineIndex = normalBase + i * lineVertices;\\n                        } else {\\n                            lineIndex = normalBase + (i - 1) * lineVertices + 8;\\n                        }\\n\\n                        if (i > 0) {\\n                            lineIndex2 = normalBase + (i - 1) * lineVertices + 8;\\n                        } else {\\n                            lineIndex2 = normalBase + lineIndex;\\n                        }\\n\\n                        //add polygon\\n                        vertexBuffer[index] = p1[0];\\n                        vertexBuffer[index+1] = p1[1];\\n                        vertexBuffer[index+2] = p1[2];\\n                        vertexBuffer[index+3] = distance;\\n\\n                        vertexBuffer[index+4] = p1[0];\\n                        vertexBuffer[index+5] = p1[1];\\n                        vertexBuffer[index+6] = p1[2];\\n                        vertexBuffer[index+7] = distance;\\n\\n                        vertexBuffer[index+8] = p1[0];\\n                        vertexBuffer[index+9] = p1[1];\\n                        vertexBuffer[index+10] = p1[2];\\n                        vertexBuffer[index+11] = distance;\\n\\n                        //add polygon\\n                        vertexBuffer[index+12] = p1[0];\\n                        vertexBuffer[index+1+12] = p1[1];\\n                        vertexBuffer[index+2+12] = p1[2];\\n                        vertexBuffer[index+3+12] = distance;\\n\\n                        vertexBuffer[index+4+12] = p1[0];\\n                        vertexBuffer[index+5+12] = p1[1];\\n                        vertexBuffer[index+6+12] = p1[2];\\n                        vertexBuffer[index+7+12] = -distance;\\n\\n                        vertexBuffer[index+8+12] = p1[0];\\n                        vertexBuffer[index+9+12] = p1[1];\\n                        vertexBuffer[index+10+12] = p1[2];\\n                        vertexBuffer[index+11+12] = -distance;\\n\\n                        if (i == 0) { //start cap\\n                            //first polygon\\n                            normalBuffer[index2] = 0;\\n                            normalBuffer[index2+1] = 0;\\n                            normalBuffer[index2+2] = 0;\\n                            normalBuffer[index2+3] = -lineWidth;\\n            \\n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\\n                            normalBuffer[index2+7] = lineWidth;\\n            \\n                            normalBuffer[index2+8] = -vstart[0];\\n                            normalBuffer[index2+9] = -vstart[1];\\n                            normalBuffer[index2+10] = -vstart[2];\\n                            normalBuffer[index2+11] = -lineWidth;\\n\\n                            //second polygon\\n                            normalBuffer[index2+12] = 0;\\n                            normalBuffer[index2+1+12] = 0;\\n                            normalBuffer[index2+2+12] = 0;\\n                            normalBuffer[index2+3+12] = -lineWidth;\\n\\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\\n                            normalBuffer[index2+7+12] = lineWidth;\\n            \\n                            normalBuffer[index2+8+12] = -vstart[0];\\n                            normalBuffer[index2+9+12] = -vstart[1];\\n                            normalBuffer[index2+10+12] = -vstart[2];\\n                            normalBuffer[index2+11+12] = -lineWidth;\\n                        } else if (i == (li - 1)) {  //end cap\\n                            //first polygon\\n                            normalBuffer[index2] = 0;\\n                            normalBuffer[index2+1] = 0;\\n                            normalBuffer[index2+2] = 0;\\n                            normalBuffer[index2+3] = -lineWidth;\\n            \\n                            normalBuffer[index2+4] = normalBuffer[lineIndex2];\\n                            normalBuffer[index2+5] = normalBuffer[lineIndex2+1];\\n                            normalBuffer[index2+6] = normalBuffer[lineIndex2+2];\\n                            normalBuffer[index2+7] = lineWidth;\\n            \\n                            normalBuffer[index2+8] = vend[0];\\n                            normalBuffer[index2+9] = vend[1];\\n                            normalBuffer[index2+10] = vend[2];\\n                            normalBuffer[index2+11] = -lineWidth;\\n\\n                            //second polygon\\n                            normalBuffer[index2+12] = 0;\\n                            normalBuffer[index2+1+12] = 0;\\n                            normalBuffer[index2+2+12] = 0;\\n                            normalBuffer[index2+3+12] = -lineWidth;\\n\\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex2];\\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex2+1];\\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex2+2];\\n                            normalBuffer[index2+7+12] = lineWidth;\\n            \\n                            normalBuffer[index2+8+12] = vend[0];\\n                            normalBuffer[index2+9+12] = vend[1];\\n                            normalBuffer[index2+10+12] = vend[2];\\n                            normalBuffer[index2+11+12] = -lineWidth;\\n                        } else {\\n                            normalBuffer[index2] = 0;\\n                            normalBuffer[index2+1] = 0;\\n                            normalBuffer[index2+2] = 0;\\n                            normalBuffer[index2+3] = -lineWidth;\\n            \\n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\\n                            normalBuffer[index2+7] = lineWidth;\\n            \\n                            normalBuffer[index2+8] = normalBuffer[lineIndex2];\\n                            normalBuffer[index2+9] = normalBuffer[lineIndex2+1];\\n                            normalBuffer[index2+10] = normalBuffer[lineIndex2+2];\\n                            normalBuffer[index2+11] = lineWidth;\\n\\n                            //add polygon\\n                            normalBuffer[index2+12] = 0;\\n                            normalBuffer[index2+1+12] = 0;\\n                            normalBuffer[index2+2+12] = 0;\\n                            normalBuffer[index2+3+12] = -lineWidth;\\n\\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\\n                            normalBuffer[index2+7+12] = lineWidth;\\n            \\n                            normalBuffer[index2+8+12] = -normalBuffer[lineIndex2];\\n                            normalBuffer[index2+9+12] = -normalBuffer[lineIndex2+1];\\n                            normalBuffer[index2+10+12] = -normalBuffer[lineIndex2+2];\\n                            normalBuffer[index2+11+12] = lineWidth;\\n                        }\\n\\n                        index += 24;\\n                        index2 += 24;\\n\\n                    }\\n\\n                } else {\\n\\n                    var segmentIndex = (i != (li-1)) ? i : (i - 1);\\n\\n                    for (var j = 0; j < circleSides; j++) {\\n           \\n                        if (advancedHit) {\\n                            elementIndex = elemetBase + segmentIndex;\\n                            elementBuffer[index3] = elementIndex;\\n                            elementBuffer[index3+1] = elementIndex;\\n                            elementBuffer[index3+2] = elementIndex;\\n                            index3 += 3;\\n                        }\\n\\n                        distance = vertexBuffer[segmentIndex * lineVertices + 3];\\n        \\n                        //add polygon\\n                        vertexBuffer[index] = p1[0];\\n                        vertexBuffer[index+1] = p1[1];\\n                        vertexBuffer[index+2] = p1[2];\\n                        vertexBuffer[index+3] = distance;\\n                        normalBuffer[index2] = 0;\\n                        normalBuffer[index2+1] = 0;\\n                        normalBuffer[index2+2] = 0;\\n                        normalBuffer[index2+3] = 0;\\n        \\n                        vertexBuffer[index+4] = p1[0];\\n                        vertexBuffer[index+5] = p1[1];\\n                        vertexBuffer[index+6] = p1[2];\\n                        vertexBuffer[index+7] = distance;\\n                        normalBuffer[index2+4] = circleBuffer[j][0] * lineWidth;\\n                        normalBuffer[index2+5] = circleBuffer[j][1] * lineWidth;\\n                        normalBuffer[index2+6] = circleBuffer2[j] + angleShift;\\n                        normalBuffer[index2+7] = 0;\\n        \\n                        vertexBuffer[index+8] = p1[0];\\n                        vertexBuffer[index+9] = p1[1];\\n                        vertexBuffer[index+10] = p1[2];\\n                        vertexBuffer[index+11] = distance;\\n                        normalBuffer[index2+8] = circleBuffer[j+1][0] * lineWidth;\\n                        normalBuffer[index2+9] = circleBuffer[j+1][1] * lineWidth;\\n                        normalBuffer[index2+10] = circleBuffer2[j+1] + angleShift;\\n                        normalBuffer[index2+11] = 0;\\n        \\n                        index += 12;\\n                        index2 += 12;\\n                    }\\n                }\\n            }\\n    \\n            if (lineLabel) {\\n                p = [p1[0], p1[1], p1[2] + lineLabelSize*0.1];\\n                lineLabelPoints[i] = p;\\n                lineLabelPoints2[li - i - 1] = p;\\n            }\\n    \\n            if ((i + 1) < li) {\\n                p1 = points[i+1];\\n            }\\n        }\\n\\n        elemetBase += points.length;\\n    }\\n\\n    if (totalPoints > 0) {\\n        center[0] /= totalPoints;\\n        center[1] /= totalPoints;\\n        center[2] /= totalPoints;\\n    }\\n\\n    center[0] += globals.groupOrigin[0];\\n    center[1] += globals.groupOrigin[1];\\n    center[2] += globals.groupOrigin[2];\\n\\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent, type;\\n\\n    if (line) {\\n        //console.log('totalPoints:' + totalPoints + ' vbuff-l:' + (vertexBuffer ? vertexBuffer.length : '??'));\\n\\n        var messageData = {\\n            'color':lineColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit, 'totalPoints': totalPoints,\\n            'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'width-units': lineWidthUnits,\\n            'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\\n            'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, \\n            'line-width':lineWidth*2, 'lod':(globals.autoLod ? null : globals.tileLod) };\\n    \\n        if (lineFlat) {\\n            type = texturedLine ? 8 : (widthByRatio ? 7 : 6);\\n        } else {\\n            type = texturedLine ? 10 : 9;\\n        }\\n    \\n        if (texturedLine) {\\n            if (lineStyleTexture != null) {\\n                messageData['texture'] = [globals.stylesheetBitmaps[lineStyleTexture[0]], lineStyleTexture[1], lineStyleTexture[2]];\\n                messageData['background'] = lineStyleBackground;\\n            }\\n        }\\n\\n        var signature = JSON.stringify({\\n            type: 'T'+type,\\n            color : lineColor,\\n            zIndex : zIndex,\\n            zOffset : zbufferOffset,\\n            state : globals.hitState\\n        });\\n\\n        var buffers = (normalBuffer) ? [vertexBuffer, normalBuffer] : [vertexBuffer];\\n\\n        if (advancedHit) {\\n            buffers.push(elementBuffer);\\n        }\\n        \\n        postGroupMessageFast(5, type, messageData, buffers, signature);\\n    }\\n\\n    if (lineLabel) {\\n        for (i = 0, li = lineLabelStack.length; i < li; i++) {\\n            processLineLabel(lineLabelStack[i].points, lineLabelStack[i].points2, lineString, center, lod, style, featureIndex, zIndex, eventInfo);\\n        }\\n    }\\n\\n};\\n\\nvar processLineLabel = function(lineLabelPoints, lineLabelPoints2, lineString, center, lod, style, featureIndex, zIndex, eventInfo) {\\n    var labelType = getLayerPropertyValue(style, 'line-label-type', lineString, lod);\\n    var labelColor = getLayerPropertyValue(style, 'line-label-color', lineString, lod);\\n    var labelColor2 = getLayerPropertyValue(style, 'line-label-color2', lineString, lod);\\n    var labelOutline = getLayerPropertyValue(style, 'line-label-outline', lineString, lod);\\n    var labelSource = getLayerPropertyValue(style, 'line-label-source', lineString, lod);\\n    var labelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\\n    var labelSpacing = getLayerPropertyValue(style, 'line-label-spacing', lineString, lod);\\n    var labelLineHeight = getLayerPropertyValue(style, 'line-label-line-height', lineString, lod);\\n    var labelOffset = getLayerPropertyValue(style, 'line-label-offset', lineString, lod);\\n    var labelReduce =  getLayerPropertyValue(style, 'dynamic-reduce', lineString, lod);\\n    var labelOverlap = getLayerPropertyValue(style, 'line-label-no-overlap', lineString, lod);\\n    var labelOverlapFactor = getLayerPropertyValue(style, 'line-label-no-overlap-factor', lineString, lod);\\n    var labelOverlapMargin = getLayerPropertyValue(style, 'line-label-no-overlap-margin', lineString, lod);\\n\\n    if (Math.abs(labelSize) < 0.0001) {\\n        return;\\n    }\\n\\n    var labelText = getLayerExpresionValue(style, labelSource, lineString, lod, labelSource);\\n    labelText = labelText ? labelText.replace('\\\\r\\\\n', '\\\\n').replace('\\\\r', '\\\\n') : '';\\n    var fontNames = getLayerPropertyValue(style, 'line-label-font', lineString, lod);\\n    var fonts = getFonts(fontNames);\\n    var fontsStorage = getFontsStorage(fontNames);\\n    var glyphsRes = getTextGlyphs(labelText, fonts);\\n\\n    if (labelSource == '$name') {\\n        if (!areTextCharactersAvailable(labelText, fonts, glyphsRes)) {\\n            var labelText2 = getLayerExpresionValue(style, '$name:en', lineString, lod, labelSource);\\n            labelText2 = labelText2 ? labelText2.replace('\\\\r\\\\n', '\\\\n').replace('\\\\r', '\\\\n') : '';\\n            var glyphsRes2 = getTextGlyphs(labelText, fonts);\\n            \\n            if (areTextCharactersAvailable(labelText2, fonts, glyphsRes2)) {\\n                labelText = labelText2;                     \\n                glyphsRes = glyphsRes2;\\n            }\\n        }\\n    }\\n\\n    if (!labelText || labelText == '') {\\n        return;\\n    }\\n\\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\\n    var clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\\n\\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\\n\\n    var bufferSize, vertexBuffer, texcoordsBuffer, singleBuffer, singleBuffer2;\\n\\n    globals.useLineLabel2 = (labelType != 'flat');\\n\\n    if (globals.useLineLabel2) {\\n        bufferSize = 12 * labelText.length;\\n        singleBuffer = new Float32Array(bufferSize);\\n        singleBuffer2 = new Float32Array(bufferSize);\\n    } else {\\n        bufferSize = getCharVerticesCount() * labelText.length * 2;\\n        vertexBuffer = new Float32Array(bufferSize);\\n        texcoordsBuffer = new Float32Array(bufferSize);\\n    }\\n\\n    var planes = {};\\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\\n    var originalLabelSize = labelSize;\\n\\n    globals.lineLabelPass = 0;\\n    globals.lineLabelPoints = [];\\n    var index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\\n    var labelPoints = globals.lineLabelPoints;\\n\\n    globals.lineLabelPoints = [];\\n    index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, globals.useLineLabel2 ? 0 : index, null, glyphsRes, singleBuffer2);\\n    var labelPoints2 = globals.lineLabelPoints;\\n\\n    if (!index) {\\n\\n        //label is bigger than path\\n        if (globals.useLineLabel2) {\\n\\n            while(true) {\\n\\n                //reduce size until is label smaler than path\\n                labelSize *= 0.5;\\n\\n                globals.lineLabelPass = 0;\\n                globals.lineLabelPoints = [];\\n                var index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\\n                var labelPoints = globals.lineLabelPoints;\\n\\n                globals.lineLabelPoints = [];\\n                index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, globals.useLineLabel2 ? 0 : index, null, glyphsRes, singleBuffer2);\\n                var labelPoints2 = globals.lineLabelPoints;\\n\\n                if (index || labelSize < 0.05) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (!index) {\\n            return;\\n        }\\n    }\\n\\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', lineString, lod) || \\n                     getLayerPropertyValue(style, 'visibility-abs', lineString, lod) ||\\n                     getLayerPropertyValue(style, 'visibility', lineString, lod);\\n    var culling = getLayerPropertyValue(style, 'culling', lineString, lod);\\n    var hysteresis = getLayerPropertyValue(style, 'hysteresis', lineString, lod);\\n\\n\\n    var bboxMin = globals.bboxMin, p, i, li, labelsPack = [], labelIndex = 0;\\n    var originalLabelOffset = labelOffset;\\n\\n    if (globals.useLineLabel2) {\\n        for (i = 0, li = labelPoints.length; i < li; i++) {\\n            p = labelPoints[i];\\n            p[0] += bboxMin[0];\\n            p[1] += bboxMin[1];\\n            p[2] += bboxMin[2];\\n            p = labelPoints2[i];\\n            p[0] += bboxMin[0];\\n            p[1] += bboxMin[1];\\n            p[2] += bboxMin[2];\\n        }\\n\\n        labelsPack.push([labelSize, globals.textVector, labelPoints, labelPoints2]);\\n        globals.lineLabelPass = 1;\\n\\n        //bigger labels\\n        while(true) {\\n\\n            labelSize *= 2;\\n\\n            globals.lineLabelPoints = [];\\n            index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\\n            labelPoints = globals.lineLabelPoints;\\n\\n            if (!index) {\\n                break;\\n            }\\n\\n            globals.lineLabelPoints = [];\\n            index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, globals.useLineLabel2 ? 0 : index, null, glyphsRes, singleBuffer2);\\n            labelPoints2 = globals.lineLabelPoints;\\n\\n            for (i = 0, li = labelPoints.length; i < li; i++) {\\n                p = labelPoints[i];\\n                p[0] += bboxMin[0];\\n                p[1] += bboxMin[1];\\n                p[2] += bboxMin[2];\\n                p = labelPoints2[i];\\n                p[0] += bboxMin[0];\\n                p[1] += bboxMin[1];\\n                p[2] += bboxMin[2];\\n            }\\n\\n            labelsPack.push([labelSize, globals.textVector, labelPoints, labelPoints2]);\\n        }\\n\\n        labelSize = originalLabelSize;\\n\\n        //smaller labels\\n        while(true) {\\n\\n            labelSize *= 0.5;\\n\\n            globals.lineLabelPoints = [];\\n            index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\\n            labelPoints = globals.lineLabelPoints;\\n\\n            if (globals.textLength < 2) {\\n                break;\\n            }\\n\\n            globals.lineLabelPoints = [];\\n            index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, null, glyphsRes, singleBuffer2);\\n            labelPoints2 = globals.lineLabelPoints;\\n\\n            for (i = 0, li = labelPoints.length; i < li; i++) {\\n                p = labelPoints[i];\\n                p[0] += bboxMin[0];\\n                p[1] += bboxMin[1];\\n                p[2] += bboxMin[2];\\n                p = labelPoints2[i];\\n                p[0] += bboxMin[0];\\n                p[1] += bboxMin[1];\\n                p[2] += bboxMin[2];\\n            }\\n\\n            labelsPack.unshift([labelSize, globals.textVector, labelPoints, labelPoints2]);\\n            labelIndex++;\\n        }\\n\\n        center = globals.textCenter;\\n        center[0] += bboxMin[0];\\n        center[1] += bboxMin[1];\\n        center[2] += bboxMin[2];\\n    }\\n    \\n\\n    //var fonts = labelData.fonts;\\n    var labelFiles = new Array(fonts.length);\\n\\n    for (i = 0, li= fonts.length; i < li; i++) {\\n        labelFiles[i] = [];\\n    }\\n\\n    for (var key in planes) {\\n        var fontIndex = parseInt(key);\\n        var planes2 = planes[key];\\n\\n        var files = [];\\n\\n        for (var key2 in planes2) {\\n            var plane = parseInt(key2) - (fontIndex*4000);\\n            var file = Math.round((plane - (plane % 4)) / 4);\\n\\n            if (files.indexOf(file) == -1) {\\n                files.push(file);\\n            }\\n        }\\n\\n        labelFiles[fontIndex] = files;\\n    }\\n\\n    var signature = JSON.stringify({\\n        type: 'line-label',\\n        color : labelColor,\\n        color2 : labelColor2,\\n        outline : labelOutline,\\n        fonts : fontNames,\\n        zIndex : zIndex,\\n        zOffset : zbufferOffset\\n    });\\n\\n\\n    if (labelOverlap) {\\n        var factorType = null, factorValue = null;\\n\\n        if (labelOverlapFactor !== null) {\\n            switch(labelOverlapFactor[0]) {\\n                case 'direct':      factorType = 0;      break;\\n                case 'div-by-dist': factorType = 1; break;\\n            }\\n\\n            factorValue = labelOverlapFactor[1];\\n        }\\n\\n        var noOverlap = [labelOverlapMargin, factorType, factorValue];\\n    }\\n\\n    postGroupMessageFast(5, globals.useLineLabel2 ? 12 : 11, {\\n        'color':labelColor, 'color2':labelColor2, 'outline':labelOutline, 'textVector':globals.textVector, 'labelPoints': globals.useLineLabel2 ? labelsPack : [],\\n        'visibility': visibility, 'culling': culling, 'hysteresis' : hysteresis, 'z-index':zIndex,\\n        'center': center, 'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\\n        'reduce':labelReduce, 'noOverlap': (labelOverlap ? noOverlap : null), 'files': labelFiles, 'enter-event':enterEvent,\\n        'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'advancedHit': advancedHit, 'labelIndex': labelIndex, 'labelSize': originalLabelSize,\\n        'fonts': fontsStorage, 'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\\n        'lod':(globals.autoLod ? null : globals.tileLod) }, globals.useLineLabel2 ? [singleBuffer, singleBuffer2] : [vertexBuffer, texcoordsBuffer], signature);\\n};\\n\\n\\nvar processLineStringGeometry = function(lineString) {\\n\\n    checkDPoints(lineString);\\n\\n    var lines = lineString['lines'];\\n\\n    if (lines || lines.length == 0) {\\n        return;\\n    }\\n\\n    //debugger\\n    var totalPoints = 0;\\n    var indicesBuffer = new Uint32Array(lines.length);\\n\\n    for (i = 0; i < lines.length; i++) {\\n        indicesBuffer[i] = totalPoints;\\n\\n        if (Array.isArray(lines[i])) {\\n            totalPoints += lines[i].length;\\n        }\\n    }\\n\\n    var geometryBuffer = new Float64Array(totalPoints * 3);\\n\\n    /*var forceOrigin = globals.forceOrigin;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;*/\\n    var forceScale = globals.forceScale;\\n    var index = 0, p1, p2, pp, p;\\n\\n    for (var i = 0; i < lines.length; i++) {\\n        if (!Array.isArray(lines[i]) || !lines[i].length) {\\n            continue;\\n        }\\n        \\n        var points = lines[i];\\n   \\n        p = points[0];\\n        p1 = [p[0], p[1], p[2]];\\n    \\n        //add lines\\n        for (var j = 0, lj = points.length; j < lj; j++) {\\n\\n            /*if (forceOrigin) {\\n                pp = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n            }*/\\n    \\n            if (forceScale != null) {\\n                pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n            }\\n\\n            geometryBuffer[index] = pp[0];\\n            geometryBuffer[index+1] = pp[1];\\n            geometryBuffer[index+2] = pp[2];\\n            index += 3;\\n\\n            if (j == (lj - 1)) {\\n                break;\\n            }\\n    \\n            p1 = points[j+1];\\n        }\\n    }\\n\\n    globals.signatureCounter++;\\n\\n    postGroupMessageFast(5, 14, {\\n        'id':lineString['id'] }, [geometryBuffer, indicesBuffer], (\\\"\\\"+globals.signatureCounter));\\n};\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-main.js\\\":\\n/*!*******************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-main.js ***!\\n  \\\\*******************************************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/geodata-processor/worker-globals.js\\\");\\n/* harmony import */ var _worker_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-text.js */ \\\"./src/core/map/geodata-processor/worker-text.js\\\");\\n/* harmony import */ var _worker_style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-style.js */ \\\"./src/core/map/geodata-processor/worker-style.js\\\");\\n/* harmony import */ var _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-linestring.js */ \\\"./src/core/map/geodata-processor/worker-linestring.js\\\");\\n/* harmony import */ var _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./worker-pointarray.js */ \\\"./src/core/map/geodata-processor/worker-pointarray.js\\\");\\n/* harmony import */ var _worker_polygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./worker-polygon.js */ \\\"./src/core/map/geodata-processor/worker-polygon.js\\\");\\n/* harmony import */ var _worker_message_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./worker-message.js */ \\\"./src/core/map/geodata-processor/worker-message.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"];\\nvar setFont = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\\\"setFont\\\"];\\nvar unint8ArrayToString = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"unint8ArrayToString\\\"], Utf8ArrayToStr = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"Utf8ArrayToStr\\\"];\\nvar setFontMap = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\\\"setFontMap\\\"], makeFasterFilter = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\\\"makeFasterFilter\\\"];\\nvar getLayer = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getLayer\\\"], getLayerPropertyValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getLayerPropertyValue\\\"],\\n    processStylesheet = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\\\"processStylesheet\\\"], getFilterResult = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getFilterResult\\\"];\\nvar processLineStringPass = _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__[\\\"processLineStringPass\\\"];\\nvar processPointArrayPass = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\\\"processPointArrayPass\\\"];\\nvar processPointArrayVSwitchPass = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\\\"processPointArrayVSwitchPass\\\"];\\nvar processPolygonPass = _worker_polygon_js__WEBPACK_IMPORTED_MODULE_5__[\\\"processPolygonPass\\\"];\\nvar processLineStringGeometry = _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__[\\\"processLineStringGeometry\\\"];\\nvar processPointArrayGeometry = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\\\"processPointArrayGeometry\\\"],\\n    postGroupMessageLite = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\\\"postGroupMessageLite\\\"], optimizeGroupMessages = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\\\"optimizeGroupMessages\\\"];\\nvar postGroupMessageFast = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\\\"postGroupMessageFast\\\"], postPackedMessage = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\\\"postPackedMessage\\\"], postPackedMessages = _worker_message_js__WEBPACK_IMPORTED_MODULE_6__[\\\"postPackedMessages\\\"];\\nvar getLayerPropertyValueInner = _worker_style_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getLayerPropertyValueInner\\\"];\\n\\nvar exportedGeometries = [];\\nvar featureCache = new Array(1024), featureCacheIndex = 0, finalFeatureCache = new Array(1024), finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\\n\\nfunction processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo) {\\n\\n    globals.stylesheetLocals = {};\\n\\n    switch(type) {\\n    case 'line-string':\\n        if (getLayerPropertyValue(layer, 'point', feature, lod) ||\\n            getLayerPropertyValue(layer, 'label', feature, lod)) {\\n            processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n        }\\n\\n        processLineStringPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n        break;\\n\\n    case 'point-array':\\n        processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n        break;\\n            \\n    case 'polygon':\\n        processPolygonPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n        break;     \\n    }\\n\\n}\\n\\nfunction processFeatures(type, features, lod, featureType, group) {\\n    var reduceParams = globals.reduceParams;\\n\\n    //loop layers\\n    for (var key in globals.stylesheetLayers) {\\n        var layer = globals.stylesheetLayers[key];\\n\\n        if (type == 'point-array') {\\n            var importance = layer['importance-source'];\\n            //\\n\\n            if ((typeof importance === 'undefined' || importance === null) && features[0] && features[0]['importance']) {\\n                importance = '$importance';\\n            }\\n\\n            if (!(typeof importance === 'undefined' || importance === null)) {\\n                //importance = '$importance';\\n                switch (globals.reduceMode) {\\n                    case 'scr-count1': \\n                    case 'scr-count2': \\n                        layer['reduce'] = ['top',100,importance];\\n                        layer['dynamic-reduce'] = ['scr-count2', reduceParams[0], reduceParams[1]];\\n                        break;\\n                    case 'scr-count4': \\n                        layer['dynamic-reduce'] = ['scr-count4',importance];\\n                        break;\\n                    case 'scr-count5': \\n                        layer['dynamic-reduce'] = ['scr-count5',importance];\\n                        break;\\n                    case 'scr-count6': \\n                    case 'scr-count7': \\n                    case 'scr-count8': \\n                        var ppi = globals.reduceMode == 'scr-count8' ? reduceParams[6] : reduceParams[5];\\n                        layer['dynamic-reduce'] = [globals.reduceMode,importance, (typeof layer['importance-weight'] !== 'undefined') ? layer['importance-weight'] : 1 ];\\n                        layer['label-no-overlap-margin'] = [reduceParams[0]*ppi, reduceParams[0]*ppi];\\n                        layer['icon-no-overlap-margin'] = [reduceParams[0]*ppi, reduceParams[0]*ppi];\\n                        layer['label-no-overlap-factor'] = [\\\"div-by-dist\\\",importance];\\n                        break;\\n                }\\n            }\\n        }\\n\\n        var filter =  layer['filter'];\\n        var reduce =  layer['reduce'], i, li, j, lj;\\n\\n        if (filter) {\\n            filter = layer['#filter'];\\n            if (!filter) {\\n                layer['#filter'] = makeFasterFilter(layer['filter']);\\n                filter = layer['#filter'];\\n            }\\n        }\\n\\n        featureCacheIndex = 0, finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\\n\\n        for (i = 0, li = features.length; i < li; i++) {\\n            var feature = features[i];\\n            feature.properties = feature['properties'] || {};\\n\\n            if (feature['id']) {\\n                feature.properties['#id'] = feature['id']; \\n            }\\n            \\n            if (!filter || getFilterResult(filter, feature, featureType, group, layer, 'filter', lod, 0, true)) {\\n                if (reduce) {\\n                    featureCache[featureCacheIndex] = feature;\\n                    featureCacheIndex++;\\n                } else {\\n                    processLayerFeature(type, feature, lod, layer, i);\\n                }\\n            }\\n        }\\n\\n        if (reduce) {\\n\\n            var count = reduce[1];\\n            var property = reduce[2];\\n\\n            switch (reduce[0]) {\\n                case 'top':\\n                case 'bottom':\\n\\n                    if (typeof property === 'string' && property.charAt(0) == '@') {\\n                        property = globals.stylesheetConstants[property];\\n\\n                        if (typeof property === 'undefined') {\\n                            break;\\n                        }\\n                    }\\n\\n                    if ((typeof property === 'string' && property.charAt(0) == '$') || (typeof property === 'object')) {\\n                        var complexProperty = (typeof property === 'object');\\n\\n                        if (!complexProperty) {\\n                            property = property.substr(1);\\n                        }\\n\\n                        if (count > featureCacheIndex) {\\n                            count = featureCacheIndex;\\n                        }\\n\\n                        var top = (reduce[0] == 'top'), value;\\n                        var currentIndex = 0;\\n                        var currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\\n\\n                        do {\\n                            var currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\\n                            finalFeatureCacheIndex2 = finalFeatureCacheIndex;\\n\\n                            for (i = 0, li = featureCacheIndex; i < li; i++) {\\n                                feature = featureCache[i];\\n\\n                                if (!currentIndex) {\\n                                    if (!complexProperty) {\\n                                        value = parseFloat(feature.properties[property]);\\n                                    } else {\\n                                        value = getLayerPropertyValueInner(layer, null, feature, lod, property, 0);\\n                                    }\\n                                    feature.tmp = value;\\n                                } else {\\n                                    value = feature.tmp;\\n                                }\\n\\n                                if (!isNaN(value) && ((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {\\n                                    if (currentValue != value) {\\n                                        finalFeatureCacheIndex = finalFeatureCacheIndex2;\\n                                    }\\n\\n                                    finalFeatureCache[finalFeatureCacheIndex] = feature;\\n                                    finalFeatureCacheIndex++;\\n                                    currentValue = value;\\n                                }\\n                            }\\n\\n                            currentValue2 = currentValue;\\n                            currentIndex++;\\n\\n                        } while(currentIndex < count);\\n                    }\\n\\n                    break;\\n\\n                case 'odd':\\n                case 'even':\\n\\n                    for (i = (reduce[0] == 'odd') ? 1 : 0, li = featureCacheIndex; i < li; i+=2) {\\n                        feature = featureCache[i];\\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\\n                        finalFeatureCacheIndex++;\\n                    }\\n\\n                case 'every':\\n\\n                    if (count > featureCacheIndex) {\\n                        count = featureCacheIndex;\\n                    }\\n\\n                    for (i = 0, li = featureCacheIndex; i < li; i += count) {\\n                        feature = featureCache[i];\\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\\n                        finalFeatureCacheIndex++;\\n                    }\\n\\n                    break;\\n            }\\n\\n            //process reduced features\\n            for (i = 0, li = finalFeatureCacheIndex; i < li; i++) {\\n                feature = finalFeatureCache[i];\\n                processLayerFeature(type, finalFeatureCache[i], lod, layer, i);\\n            }\\n\\n        }\\n\\n    }\\n}\\n\\n\\nfunction processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo) {\\n    var multiPass = getLayerPropertyValue(layer, 'next-pass', feature, lod);\\n\\n    var mylayer;\\n\\n    if (multiPass != null) {\\n        for (var i = 0, li = multiPass.length; i < li; i++) {\\n            var zIndex = multiPass[i][0];\\n            mylayer = getLayer(multiPass[i][1], type, featureIndex);\\n            \\n            if (!getLayerPropertyValue(mylayer, 'visible', feature, lod)) {\\n                continue;\\n            }\\n\\n            var selectedLayerId = getLayerPropertyValue(mylayer, 'selected-layer', feature, lod);\\n            var selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\\n\\n            var selectedHoverLayerId = getLayerPropertyValue(mylayer, 'selected-hover-layer', feature, lod);\\n            var selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\\n\\n            var hoverLayerId = getLayerPropertyValue(mylayer, 'hover-layer', feature, lod);\\n            var hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\\n\\n            var flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\\n\\n            var lastHitState = globals.hitState;\\n\\n            if (selectedLayer != null) {\\n                globals.hitState = flags | 2;\\n                processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\\n            }\\n\\n            if (selectedHoverLayer != null) {\\n                globals.hitState = flags | 3;\\n                processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\\n            }\\n\\n            if (hoverLayer != null) {\\n                globals.hitState = flags | 1;\\n                processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\\n            }\\n                \\n            //globals.hitState = flags | 0;\\n            processLayerFeaturePass(type, feature, lod, mylayer, featureIndex, zIndex, eventInfo);\\n\\n            globals.hitState = lastHitState;\\n        }\\n    }\\n}\\n\\n\\nfunction processLayerFeature(type, feature, lod, layer, featureIndex, skipPack) {\\n    if (!getLayerPropertyValue(layer, 'visible', feature, lod)) {\\n        return;\\n    }\\n\\n    if (type == 'point-array') {\\n        if (layer['visibility-switch']) {\\n            postGroupMessageLite(5, 17);\\n            //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-begin'});\\n            var zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\\n            var eventInfo = feature.properties;\\n            processPointArrayVSwitchPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n\\n            var vswitch = layer['visibility-switch'];\\n            for (var i = 0, li = vswitch.length; i <li; i++) {\\n                if (vswitch[i][1]) {\\n                    var slayer = getLayer(vswitch[i][1], type, featureIndex);\\n                    processLayerFeature(type, feature, lod, slayer, featureIndex);\\n                }\\n                postGroupMessageLite(5, 18, vswitch[i][0]);\\n            }\\n\\n            postGroupMessageLite(5, 19);\\n            return;\\n        }\\n    }\\n\\n    if (!skipPack && layer['pack'] == true) {\\n        globals.directPoints = [];\\n\\n        postGroupMessageLite(5, 15);\\n        processLayerFeature(type, feature, lod, layer, featureIndex, true);\\n        postGroupMessageLite(5, 16);\\n\\n        if (globals.directPoints)  //????????????????? FIXME\\n\\n        return;\\n    }\\n\\n    var zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\\n\\n    if (getLayerPropertyValue(layer, 'export-geometry', feature, lod) && (typeof feature['id'] !== 'undefined')) {\\n        if (!exportedGeometries[feature]) {\\n\\n            switch(type) {\\n            case 'line-string':\\n                processLineStringGeometry(feature);\\n                break;\\n\\n            case 'point-array':\\n                processPointArrayGeometry(feature);\\n                break;\\n                    \\n            case 'polygon':\\n                break;     \\n            }\\n\\n            exportedGeometries[feature] = true;\\n        }\\n    }\\n\\n    var eventInfo = feature.properties;\\n\\n    var selectedLayerId = getLayerPropertyValue(layer, 'selected-layer', feature, lod);\\n    var selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\\n\\n    var selectedHoverLayerId = getLayerPropertyValue(layer, 'selected-hover-layer', feature, lod);\\n    var selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\\n\\n    var hoverLayerId = getLayerPropertyValue(layer, 'hover-layer', feature, lod);\\n    var hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\\n\\n    var flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\\n\\n    if (selectedLayer != null) {\\n        globals.hitState = flags | 2;\\n        processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\\n        processLayerFeatureMultipass(type, feature, lod, selectedLayer, featureIndex, eventInfo);\\n    }\\n\\n    if (selectedHoverLayer != null) {\\n        globals.hitState = flags | 3;\\n        processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\\n        processLayerFeatureMultipass(type, feature, lod, selectedHoverLayer, featureIndex, eventInfo);\\n    }\\n\\n    if (hoverLayer != null) {\\n        globals.hitState = flags | 1;\\n        processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\\n        processLayerFeatureMultipass(type, feature, lod, hoverLayer, featureIndex, eventInfo);\\n    }\\n\\n    globals.hitState = flags | 0;\\n    processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo);\\n    processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo);\\n}\\n\\nfunction processGroup(group, lod) {\\n    var i, li;\\n    var groupId = group['id'] || '';\\n    globals.groupId = groupId;\\n\\n    var bbox = group['bbox'];    \\n    if (!bbox) {\\n        return;\\n    }\\n          \\n    var bboxMin = bbox[0];\\n    var bboxMax = bbox[1];\\n    globals.bboxMin = bboxMin;\\n    globals.bboxMax = bboxMax;\\n\\n    var bboxDelta = [bbox[1][0] - bbox[0][0],\\n        bbox[1][1] - bbox[0][1],\\n        bbox[1][2] - bbox[0][2]];\\n    var bboxResolution = group['resolution'] || 4096;\\n    \\n    globals.groupOrigin = [0,0,0];\\n    globals.forceScale = [bboxDelta[0] / bboxResolution,\\n        bboxDelta[1] / bboxResolution,\\n        bboxDelta[2] / bboxResolution];\\n\\n    postGroupMessageFast(9, 0, {'id': group['id'], 'bbox': [bboxMin, bboxMax], 'origin': bboxMin}, [], \\\"\\\");\\n\\n    //process points\\n    var points = group['points'] || [];\\n    globals.featureType = 'point';\\n    processFeatures('point-array', points, lod, 'point', groupId);\\n\\n    //process lines\\n    var lines = group['lines'] || [];\\n    globals.featureType = 'line';\\n    processFeatures('line-string', lines, lod, 'line', groupId);\\n\\n    //process polygons\\n    var polygons = group['polygons'] || [];\\n    globals.featureType = 'polygon';\\n    processFeatures('polygon', polygons, lod, 'polygon', groupId);\\n\\n    postGroupMessageLite(10, 0);\\n\\n    if (globals.groupOptimize) {\\n        optimizeGroupMessages();\\n    }\\n}\\n\\n\\nfunction processNode(node, lod) {\\n    var i, li;\\n\\n    //TODO: get volume\\n\\n    postGroupMessageFast(5, 21, {'volume': node.volume, 'precision': node.precision, 'tileset': node.tileset }, [], \\\"\\\");\\n\\n    var meshes = node['meshes'] || [];\\n\\n    //loop elements\\n    for (i = 0, li = meshes.length; i < li; i++) {\\n\\n        var signature = meshes[i];\\n\\n        postGroupMessageFast(5, 23, { 'path':meshes[i] }, [], signature);\\n    }\\n\\n    var nodes = node['nodes'] || [];\\n\\n    for (i = 0, li = nodes.length; i < li; i++) {\\n        processNode(nodes[i], lod);\\n    }\\n\\n    postGroupMessageFast(5, 22, {}, [], \\\"\\\");\\n}\\n\\nfunction processGeodata(data, lod) {\\n    //console.log(\\\"processGeodata\\\");\\n\\n    //create object from JSON\\n    if ((typeof data) == 'string') {\\n        try {\\n            var geodata = JSON.parse(data);\\n        } catch (e) {\\n            geodata = null;\\n        }\\n    } else {\\n        geodata = data;\\n    }\\n\\n    if (geodata) {\\n\\n        var groups = geodata['groups'] || [];\\n\\n        //process layers\\n        for (var i = 0, li = groups.length; i < li; i++) {\\n            processGroup(groups[i], lod);\\n        }\\n\\n        var nodes = geodata['nodes'] || [];\\n\\n        for (var i = 0, li = nodes.length; i < li; i++) {\\n            postGroupMessageFast(9, 0, {}, [], \\\"\\\");\\n            processNode(nodes[i], lod);\\n            postGroupMessageLite(10, 0);\\n        }\\n    }\\n\\n    //console.log(\\\"processGeodata-ready\\\");\\n}\\n\\nself.onmessage = function (e) {\\n    var message = e.data;\\n    var command = message['command'];\\n    var data = message['data'];\\n    var dataRaw = null;\\n    var geodata2 = false;\\n\\n    //console.log(\\\"workeronmessage: \\\" + command);\\n\\n    switch(command) {\\n\\n    case 'config':\\n        globals.config = data;\\n        break;\\n\\n    case 'setStylesheet':\\n        if (data) {\\n            globals.geocent = data['geocent'];\\n            globals.metricUnits = data['metric'];\\n            globals.reduceMode = data['reduceMode'];\\n            globals.reduceParams = data['reduceParams'];\\n            globals.log = data['log'];\\n            globals.language = data['language'];\\n            processStylesheet(data['data']);\\n        }\\n        //postMessage({'command' : 'ready'});\\n        break;\\n\\n    case 'setFont':\\n        setFont(data);\\n        //postMessage({'command' : 'ready'});\\n        break;\\n\\n    case 'setFontMap':\\n        setFontMap(data);\\n        postMessage({'command' : 'styleDone'});\\n        postMessage({'command' : 'ready'});\\n        break;\\n\\n    case 'processGeodataRaw':\\n        dataRaw = data;\\n\\n        //test geodata2\\n        if (data.length > 2) {\\n            var dataView = new DataView(data);\\n\\n            var magic = '';\\n            magic += String.fromCharCode(dataView.getUint8(0, true));\\n            magic += String.fromCharCode(dataView.getUint8(1, true));\\n\\n            if (magic != 'GE') {\\n                geodata2 = true;\\n            }\\n        }\\n\\n        data = Utf8ArrayToStr(data);\\n\\n    case 'processGeodata':\\n        globals.tileLod = message['lod'] || 0;\\n        globals.tileIX = message['ix'] || 0;\\n        globals.tileIY = message['iy'] || 0;\\n        globals.tileSize = message['tileSize'] || 1;\\n        globals.pixelSize = message['pixelSize'] || 1;\\n        globals.pixelFactor = message['dpr'] || 1;\\n        globals.invPixelFactor = 1.0 / globals.pixelFactor;\\n        globals.pixelsPerMM = (globals.pixelFactor / 96) / 2.54;\\n        globals.invPixelsPerMM = 1.0 / globals.pixelsPerMM;\\n        exportedGeometries = [];\\n\\n        if (geodata2) {\\n            processGeodata2(dataView, globals.tileLod);\\n        } else {\\n            data = JSON.parse(data);            \\n            processGeodata(data, globals.tileLod);\\n        }\\n\\n        postGroupMessageLite(7, 0);\\n            \\n        if (globals.groupOptimize) {  //we need send all processed message\\n            optimizeGroupMessages();\\n        }\\n            \\n        //postMessage({'command' : 'allProcessed'});\\n\\n        if (dataRaw) {\\n            postPackedMessage({'command' : 'ready', 'geodata': dataRaw}, [dataRaw]);\\n        } else {\\n            postPackedMessage({'command' : 'ready'});\\n        }\\n\\n        if (globals.config.mapPackLoaderEvents) {\\n            postPackedMessages();\\n        }\\n\\n        break;\\n\\n    //case 'tick':\\n      //  postPackedMessages();\\n        //break;\\n\\n    }\\n};\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-message.js\\\":\\n/*!**********************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-message.js ***!\\n  \\\\**********************************************************/\\n/*! exports provided: optimizeGroupMessages, postGroupMessageFast, postGroupMessageLite, postPackedMessage, postPackedMessages */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"optimizeGroupMessages\\\", function() { return optimizeGroupMessages; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"postGroupMessageFast\\\", function() { return postGroupMessageFast; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"postGroupMessageLite\\\", function() { return postGroupMessageLite; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"postPackedMessage\\\", function() { return postPackedMessage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"postPackedMessages\\\", function() { return postPackedMessages; });\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/geodata-processor/worker-globals.js\\\");\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"], stringToUint8Array = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"stringToUint8Array\\\"];\\nvar tmpVertexBuffer = new Uint8Array(65536*4*4*4*4);\\nvar tmpVertexBuffer2 = new Uint8Array(65536*4*4*4*4);\\nvar packedEvents = [];\\nvar packedTransferables = [];\\n\\n\\nfunction postPackedMessage(message, transferables) {\\n\\n    if (globals.config.mapPackLoaderEvents) {\\n\\n        packedEvents.push(message);\\n\\n        if (transferables) {\\n            packedTransferables = packedTransferables.concat(transferables);\\n        }\\n\\n    } else {\\n\\n        if (transferables) {\\n            postMessage(message, transferables);\\n        } else {\\n            postMessage(message);\\n        }\\n    }\\n}\\n\\n\\nfunction postGroupMessageFast(command, type, message, buffers, signature) {\\n\\n    var message2 = stringToUint8Array(JSON.stringify(message));\\n    var messageSize = 1+1+4+message2.byteLength, i, li;\\n\\n    for (i = 0, li = buffers.length; i < li; i++) {\\n        messageSize += 4+buffers[i].byteLength;\\n    }\\n\\n    var buff = new Uint8Array(messageSize);\\n    var view = new DataView(buff.buffer), index = 0, index2 = 0;\\n\\n    view.setUint8(index, command); index += 1;\\n    view.setUint8(index, type); index += 1;\\n    view.setUint32(index, message2.byteLength); index += 4;\\n    buff.set(message2, index); index += message2.byteLength;\\n    index2 = index;\\n\\n    for (i = 0, li = buffers.length; i < li; i++) {\\n        view.setUint32(index, buffers[i].length); index += 4;\\n        buff.set( new Uint8Array(buffers[i].buffer), index); index += buffers[i].byteLength;\\n    }\\n\\n    postGroupMessageDirect(command, type, buff.buffer, index2, signature, message['hitable'], message['totalPoints'], (type == 11) ? message : null);\\n}\\n\\n\\nfunction postGroupMessageLite(command, type, number) {\\n    var messageSize = 1+1+4, index = 0;\\n\\n    var buff = new ArrayBuffer(messageSize);\\n    var view = new DataView(buff), index = 0;\\n\\n    view.setUint8(index, command); index += 1;\\n    view.setUint8(index, type); index += 1;\\n    view.setUint32(index, (number ? number : 0)); index += 4;\\n\\n    postGroupMessageDirect(command, type, buff, index, \\\"\\\");\\n}\\n\\n\\nfunction postGroupMessageDirect(command, type, message, buffersIndex, signature, hitable, totalPoints, job2) {\\n\\n    if (globals.messageBufferIndex >= globals.messageBufferSize) { \\n        var oldBuffer = globals.messageBuffer; \\n        globals.messageBufferSize += 65536;\\n        globals.messageBuffer = new Array(globals.messageBufferSize);\\n        \\n        for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\\n            globals.messageBuffer[i] = oldBuffer[i];\\n        }\\n    }\\n    \\n    globals.messageBuffer[globals.messageBufferIndex] = { command: command, type: type, job : message, buffersIndex: buffersIndex, signature: signature, hitable: hitable, totalPoints: totalPoints, job2: job2 };\\n    globals.messageBufferIndex++;\\n    globals.messagePackSize += message.byteLength;\\n}\\n\\n\\nfunction setToTmpBuffer(index, buffer2, offset) {\\n    var buffer = (index == 1) ? tmpVertexBuffer2 : tmpVertexBuffer;\\n\\n    if (buffer.byteLength <= buffer2.byteLength + offset) {\\n        var buffer3 = new Uint8Array(buffer.byteLength * 2);\\n        buffer3.set(buffer, 0);\\n        buffer = buffer3;\\n\\n        if (index == 1) {\\n            tmpVertexBuffer2 = buffer;\\n        } else {\\n            tmpVertexBuffer = buffer;\\n        }\\n    }\\n\\n    buffer.set(buffer2, offset);\\n}\\n\\n\\nfunction optimizeGroupMessages() {\\n\\n    //loop messages\\n    var messages = globals.messageBuffer;\\n    var j, lk, k, message2, job2, bufferSize, buffer, view, index, length, buff, buff2, index, count, totalVertices;\\n\\n\\n    for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\\n        var message = messages[i];\\n        var job = message.job;\\n        var type = message.type;\\n        var signature = message.signature;\\n\\n        //console.log('command: ' + message.command + ' type:' + message.type);\\n        \\n        if (!message.hitable && !message.reduced && \\n            (type >= 6 && type <= 13)) {\\n            \\n            switch(type) {\\n            case 13:\\n            case 6:\\n                count = 0;\\n\\n                //get message vertices length and copy vertices to buffer\\n                length = (new DataView(message.job)).getUint32(message.buffersIndex) * 4;\\n\\n                //tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\\n                setToTmpBuffer(0, new Uint8Array(message.job, message.buffersIndex+4, length), 0);\\n                bufferSize = length;\\n\\n                for (j = i + 1; j < li; j++) {\\n                    message2 = messages[j];\\n\\n                    if (message2.signature == signature) {\\n                        message2.reduced = true;\\n                        count++;\\n\\n                        //get message2 vertices length\\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex) * 4;\\n\\n                        // copy vertices to buffer\\n                        //tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\\n                        setToTmpBuffer(0, new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\\n                        bufferSize += length;\\n                    }\\n                }\\n\\n                if (count > 0) {\\n\\n                    //create new message with merged vertices\\n                    buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\\n                    view = new DataView(buffer.buffer);\\n                    buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\\n\\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\\n\\n                    globals.messagePackSize -= message.job.byteLength;\\n                    globals.messagePackSize += buffer.byteLength;\\n                    message.job = buffer.buffer;\\n                }\\n\\n                break;\\n                    \\n            case 9:\\n            case 11:\\n            case 7:\\n\\n                count = 0;\\n                totalVertices = 0;\\n\\n                //get message vertices length and copy vertices to buffer\\n                length = (new DataView(message.job)).getUint32(message.buffersIndex);\\n                //console.log('count: ' + count + ' totalPoints:' + message.totalPoints + ' length: ' + length);\\n                length *= 4;\\n                totalVertices += length;\\n\\n\\n                //tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\\n                //tmpVertexBuffer2.set(new Uint8Array(message.job, message.buffersIndex+4+length+4, length), 0);\\n                setToTmpBuffer(0, new Uint8Array(message.job, message.buffersIndex+4, length), 0);\\n                setToTmpBuffer(1, new Uint8Array(message.job, message.buffersIndex+4+length+4, length), 0);\\n                bufferSize = length;\\n\\n                for (j = i + 1; j < li; j++) {\\n                    message2 = messages[j];\\n\\n                    if (message2.signature == signature) {\\n                        message2.reduced = true;\\n                        globals.messagePackSize -= message2.job.byteLength;\\n                        count++;\\n\\n                        //get message2 vertices length\\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex);\\n                        //console.log('count:' + count + ' totalPoints:' + message2.totalPoints + ' length:' + length + ' jobl:' + message2.job.byteLength + ' remaning:' + (message2.job.byteLength - (message2.buffersIndex+4)) + ' bufferSize:' + bufferSize + ' totalVertices:' + totalVertices);\\n                        length *= 4;\\n                        totalVertices += length;\\n\\n\\n                        // copy vertices to buffer\\n                        //tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\\n                        setToTmpBuffer(0, new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\\n\\n                        // copy normals to buffer\\n                        //tmpVertexBuffer2.set(new Uint8Array(message2.job, message2.buffersIndex+4+length+4, length), bufferSize);\\n                        setToTmpBuffer(1, new Uint8Array(message2.job, message2.buffersIndex+4+length+4, length), bufferSize);\\n                        bufferSize += length;\\n\\n                        if (type == 11) {\\n                            var files = message.job2['files'];\\n                            var files2 = message2.job2['files'];\\n\\n                            for (k = 0, lk = files2.length; k < lk; k++) {\\n                                if (!files[k]) {\\n                                    files[k] = [];\\n                                }\\n\\n                                for (var m = 0, lm = files2[k].length; m < lm; m++) {\\n                                    if (files[k].indexOf(files2[k][m]) == -1) {\\n                                        files[k].push(files2[k][m]);\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (count > 0) {\\n\\n                    //create new message with merged vertices\\n\\n                    if (type == 11) { //we have to rebuild header\\n                        var buffjob = stringToUint8Array(JSON.stringify(message.job2));\\n\\n                        buffer = new Uint8Array(1+1+4+buffjob.byteLength+2*(4+bufferSize));\\n                        view = new DataView(buffer.buffer), index = 0;\\n\\n                        view.setUint8(index, message.command); index += 1;\\n                        view.setUint8(index, type); index += 1;\\n                        view.setUint32(index, buffjob.byteLength); index += 4;\\n                        buffer.set(buffjob, index); index += buffjob.byteLength;\\n\\n                        message.buffersIndex = index;\\n                    } else {\\n                        buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\\n                        view = new DataView(buffer.buffer);\\n                        buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\\n                    }\\n\\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\\n\\n                    view.setUint32(message.buffersIndex + 4 + bufferSize, bufferSize / 4);\\n                    buffer.set(new Uint8Array(tmpVertexBuffer2.buffer, 0, bufferSize), message.buffersIndex + 4 + bufferSize + 4 );\\n\\n                    globals.messagePackSize -= message.job.byteLength;\\n                    globals.messagePackSize += buffer.byteLength;\\n                    message.job = buffer.buffer;\\n\\n                }\\n\\n                break;\\n            }\\n        \\n        }\\n    }\\n\\n    var buffer = new Uint8Array(globals.messagePackSize), index = 0;\\n\\n    for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\\n        var message = globals.messageBuffer[i];\\n\\n        if (!message.reduced) {\\n            buffer.set(new Uint8Array(message.job), index);\\n            index += globals.messageBuffer[i].job.byteLength;\\n        }\\n    }\\n\\n    //console.log('send:' + buffer.length);\\n\\n    postPackedMessage({'command' : 'addPackedCommands', 'buffer': buffer}, [buffer.buffer]);\\n\\n    globals.messageBufferIndex = 0;\\n    globals.messagePackSize = 0;\\n} \\n\\n\\nfunction postPackedMessages() {\\n    if (packedEvents.length > 0) {\\n        if (packedTransferables.length > 0) {\\n            postMessage({'command': 'packed-events', 'messages':packedEvents}, packedTransferables);\\n        } else {\\n            postMessage({'command': 'packed-events', 'messages':packedEvents});\\n        }\\n\\n        packedEvents = [];\\n        packedTransferables = [];\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-pointarray.js\\\":\\n/*!*************************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-pointarray.js ***!\\n  \\\\*************************************************************/\\n/*! exports provided: processPointArrayPass, processPointArrayGeometry, processPointArrayVSwitchPass, checkDPoints */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"processPointArrayPass\\\", function() { return processPointArrayPass; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"processPointArrayGeometry\\\", function() { return processPointArrayGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"processPointArrayVSwitchPass\\\", function() { return processPointArrayVSwitchPass; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"checkDPoints\\\", function() { return checkDPoints; });\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/geodata-processor/worker-globals.js\\\");\\n/* harmony import */ var _worker_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-style.js */ \\\"./src/core/map/geodata-processor/worker-style.js\\\");\\n/* harmony import */ var _worker_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-text.js */ \\\"./src/core/map/geodata-processor/worker-text.js\\\");\\n/* harmony import */ var _worker_message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-message.js */ \\\"./src/core/map/geodata-processor/worker-message.js\\\");\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"], clamp = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"clamp\\\"];\\nvar getLayerPropertyValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\\\"getLayerPropertyValue\\\"], getLayerExpresionValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\\\"getLayerExpresionValue\\\"];\\nvar addText = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"addText\\\"], getSplitIndex = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getSplitIndex\\\"], getTextGlyphs = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getTextGlyphs\\\"],\\n    getTextLength = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getTextLength\\\"], getFonts = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getFonts\\\"], getFontsStorage = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getFontsStorage\\\"],\\n    areTextCharactersAvailable = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"areTextCharactersAvailable\\\"], getCharVerticesCount = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getCharVerticesCount\\\"], getLineHeight = _worker_text_js__WEBPACK_IMPORTED_MODULE_2__[\\\"getLineHeight\\\"];\\nvar postGroupMessageFast = _worker_message_js__WEBPACK_IMPORTED_MODULE_3__[\\\"postGroupMessageFast\\\"];\\n\\n\\nvar checkDPoints = function(pointArray) {\\n    var pointsGroups = []; \\n    var i, li, g, gl, points, p, pp;\\n\\n    if (pointArray['d-points'] || pointArray['d-lines']) {  //converty d-lines/points to lines/points\\n        pointsGroups = pointArray['d-points'] || pointArray['d-lines'];\\n\\n        if (Array.isArray(pointsGroups) && points.length > 0) {\\n\\n            for (g = 0, gl = pointsGroups; g < gl; g++) {\\n                points = pointsGroups[g];\\n                \\n                if (Array.isArray(points) && points.length > 0) {\\n                    p = points[0];\\n                    \\n                    p[0] = (p[0] >> 1) ^ (-(p[0] & 1));\\n                    p[1] = (p[1] >> 1) ^ (-(p[1] & 1));\\n                    p[2] = (p[2] >> 1) ^ (-(p[2] & 1));\\n\\n                    for (i = 1, li = points.length; i < li; i++) {\\n                        p = points[i-1];\\n                        pp = points[i];\\n\\n                        pp[0] = ((pp[0] >> 1) ^ (-(pp[0] & 1))) + p[0];\\n                        pp[1] = ((pp[1] >> 1) ^ (-(pp[1] & 1))) + p[1];\\n                        pp[2] = ((pp[2] >> 1) ^ (-(pp[2] & 1))) + p[2];\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (pointArray['d-points']) {\\n            pointArray['points'] = pointArray['d-points'];\\n            delete pointArray['d-points'];\\n        } else {\\n            pointArray['lines'] = pointArray['d-lines'];\\n            delete pointArray['d-lines'];\\n        }\\n    }\\n};\\n\\n\\nvar processPointArrayPass = function(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\\n    var pointsGroups = []; \\n    var i, li, g, gl, points, p, pp;\\n\\n    checkDPoints(pointArray);\\n\\n    if (pointArray['lines']) {  //use lines as points\\n        pointsGroups = pointArray['lines'];\\n    } else {\\n        pointsGroups = [pointArray['points']];\\n    }\\n    \\n    if (!pointsGroups || pointsGroups.length == 0) {\\n        return;\\n    }\\n\\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) || \\n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\\n    var culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', pointArray, lod);\\n    var clickEvent = getLayerPropertyValue(style, 'click-event', pointArray, lod);\\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', pointArray, lod);\\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', pointArray, lod);\\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', pointArray, lod);\\n    var advancedHit = getLayerPropertyValue(style, 'advanced-event', pointArray, lod);\\n    var linePoints = getLayerPropertyValue(style, 'line-points', pointArray, lod);\\n\\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', pointArray, lod);\\n\\n    var point = getLayerPropertyValue(style, 'point', pointArray, lod);\\n    var pointFlat = getLayerPropertyValue(style, 'point-flat', pointArray, lod);\\n    var pointColor = getLayerPropertyValue(style, 'point-color', pointArray, lod);\\n    var pointRadius = 0.5 * getLayerPropertyValue(style, 'point-radius', pointArray, lod);\\n\\n    var source, bufferSize, bufferSize2, totalPoints = 0, noOverlap;\\n    //zIndex = (zIndex !== null) ? zIndex : getLayerPropertyValue(style, \\\"z-index\\\", pointArray, lod);\\n\\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\\n        points = pointsGroups[g];\\n        if (Array.isArray(points) && points.length > 0) {\\n            totalPoints += points.length;\\n        }\\n    }\\n\\n    var icon = getLayerPropertyValue(style, 'icon', pointArray, lod);\\n    if (icon) {\\n        source = getLayerPropertyValue(style, 'icon-source', pointArray, lod);\\n        \\n        if (source) {\\n            bufferSize = getCharVerticesCount() * totalPoints;\\n            bufferSize2 = getCharVerticesCount(true) * totalPoints;\\n    \\n            var iconData = {\\n                color : getLayerPropertyValue(style, 'icon-color', pointArray, lod),\\n                scale : getLayerPropertyValue(style, 'icon-scale', pointArray, lod),\\n                offset : getLayerPropertyValue(style, 'icon-offset', pointArray, lod),\\n                stick : getLayerPropertyValue(style, 'icon-stick', pointArray, lod),\\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\\n                origin : getLayerPropertyValue(style, 'icon-origin', pointArray, lod),\\n                source : getLayerPropertyValue(style, 'icon-source', pointArray, lod),\\n                noOverlap : getLayerPropertyValue(style, 'icon-no-overlap', pointArray, lod),\\n                noOverlapMargin : getLayerPropertyValue(style, 'icon-no-overlap-margin', pointArray, lod),\\n                noOverlapFactor : getLayerPropertyValue(style, 'icon-no-overlap-factor', pointArray, lod),\\n                index : 0,\\n                index2 : 0\\n            };\\n\\n            if (totalPoints > 1) {\\n                iconData.vertexBuffer = new Float32Array(bufferSize);\\n                iconData.originBuffer = new Float32Array(bufferSize2);\\n                iconData.texcoordsBuffer = new Float32Array(bufferSize);\\n            } else {\\n                iconData.singleBuffer = new Float32Array(16);\\n            }\\n\\n        } else {\\n            icon = false;\\n        }\\n    }\\n\\n    var label = getLayerPropertyValue(style, 'label', pointArray, lod);\\n    if (label) {\\n        source = getLayerPropertyValue(style, 'label-source', pointArray, lod);\\n\\n        var text = getLayerExpresionValue(style, source, pointArray, lod, source);\\n        text = text ? text.replace('\\\\r\\\\n', '\\\\n').replace('\\\\r', '\\\\n') : '';\\n        var size = getLayerPropertyValue(style, 'label-size', pointArray, lod);\\n        var fontNames = getLayerPropertyValue(style, 'label-font', pointArray, lod);\\n        var fonts = getFonts(fontNames);\\n        var glyphsRes = getTextGlyphs(text, fonts);\\n        \\n        if (source == '$name') {\\n            if (!areTextCharactersAvailable(text, fonts, glyphsRes)) {\\n                var text2 = getLayerExpresionValue(style, '$name:en', pointArray, lod, source);\\n                text2 = text2 ? text2.replace('\\\\r\\\\n', '\\\\n').replace('\\\\r', '\\\\n') : '';\\n                var glyphsRes2 = getTextGlyphs(text2, fonts);\\n                \\n                if (areTextCharactersAvailable(text2, fonts)) {\\n                    text = text2;                     \\n                    glyphsRes = glyphsRes2;\\n                }\\n            }\\n        }\\n        if (text && text != '' && Math.abs(size) > 0.0001) {\\n            noOverlap = getLayerPropertyValue(style, 'label-no-overlap', pointArray, lod);\\n            bufferSize = getCharVerticesCount() * text.length * (noOverlap ? 1 : totalPoints);\\n            bufferSize2 = getCharVerticesCount(true) * text.length * (noOverlap ? 1 : totalPoints);\\n\\n            var useSingleBuffer = (totalPoints == 1);\\n\\n            var factor = 1;\\n            if (getLayerPropertyValue(style, 'label-size-units', pointArray, lod) == 'points') {\\n                factor = globals.pixelFactor / ((1 / 72) * (96));\\n            }\\n\\n            var labelData = {\\n                color : getLayerPropertyValue(style, 'label-color', pointArray, lod),\\n                color2 : getLayerPropertyValue(style, 'label-color2', pointArray, lod),\\n                outline : getLayerPropertyValue(style, 'label-outline', pointArray, lod),\\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\\n                size : size * factor,\\n                spacing: getLayerPropertyValue(style, 'label-spacing', pointArray, lod),\\n                lineHeight: getLayerPropertyValue(style, 'label-line-height', pointArray, lod),\\n                offset : getLayerPropertyValue(style, 'label-offset', pointArray, lod),\\n                stick : getLayerPropertyValue(style, 'label-stick', pointArray, lod),\\n                origin : getLayerPropertyValue(style, 'label-origin', pointArray, lod),\\n                align : getLayerPropertyValue(style, 'label-align', pointArray, lod),\\n                fonts : fonts,\\n                fontsStorage : getFontsStorage(fontNames),\\n                text : text,\\n                hysteresis : getLayerPropertyValue(style, 'hysteresis', pointArray, lod),\\n                width : factor * getLayerPropertyValue(style, 'label-width', pointArray, lod),\\n                noOverlap : noOverlap,\\n                noOverlapMargin : getLayerPropertyValue(style, 'label-no-overlap-margin', pointArray, lod),\\n                noOverlapFactor : getLayerPropertyValue(style, 'label-no-overlap-factor', pointArray, lod),\\n                vertexBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\\n                originBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize2)),\\n                texcoordsBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\\n                singleBuffer : (useSingleBuffer) ? (new Float32Array(text.length * 4 * 2)) : null,\\n                index : 0,\\n                index2 : 0,\\n                glyphsRes : glyphsRes\\n            };\\n\\n            if (labelData.stick) {\\n                labelData.stick = labelData.stick.slice();\\n                labelData.stick[2] *= factor;\\n                //labelData.stick[7] *= factor;\\n            }\\n\\n        } else {\\n            label = false;\\n        }\\n    }\\n\\n    var index = 0;\\n    var index2 = 0;\\n\\n    \\n    var center = [0,0,0];\\n    var forceOrigin = globals.forceOrigin;\\n    var bboxMin = globals.bboxMin;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceScale = globals.forceScale;\\n    var labelBBox, iconBBox, p, p1, p2, pp, pp2;\\n\\n    var generatePoint = (function(pindex) {\\n\\n        if (icon && (!iconData.noOverlap)) {\\n            iconBBox = processIcon(pp, iconData) ;//, pointArray, lod, style, zIndex);\\n        }\\n\\n        if (label && (!labelData.noOverlap)) {\\n            labelBBox = processLabel(pp, labelData); //, pointArray, lod, style, zIndex);\\n        }\\n\\n        if (point) {\\n\\n            for (var j = 0; j < circleSides; j++) {\\n\\n                if (pointFlat) {\\n\\n                    //add polygon\\n                    vertexBuffer[index] = pp[0];\\n                    vertexBuffer[index+1] = pp[1];\\n                    vertexBuffer[index+2] = pp[2];\\n\\n                    vertexBuffer[index+3] = pp[0] + circleBuffer[j][0] * pointRadius;\\n                    vertexBuffer[index+4] = pp[1] + circleBuffer[j][1] * pointRadius;\\n                    vertexBuffer[index+5] = pp[2];\\n\\n                    vertexBuffer[index+6] = pp[0] + circleBuffer[j+1][0] * pointRadius;\\n                    vertexBuffer[index+7] = pp[1] + circleBuffer[j+1][1] * pointRadius;\\n                    vertexBuffer[index+8] = pp[2];\\n\\n                    index += 9;\\n\\n                } else {\\n\\n                    //add polygon\\n                    vertexBuffer[index] = pp[0];\\n                    vertexBuffer[index+1] = pp[1];\\n                    vertexBuffer[index+2] = pp[2];\\n                    vertexBuffer[index+3] = 0;\\n                    normalBuffer[index2] = 0;\\n                    normalBuffer[index2+1] = 0;\\n                    normalBuffer[index2+2] = 0;\\n                    normalBuffer[index2+3] = 0;\\n\\n                    vertexBuffer[index+4] = pp[0];\\n                    vertexBuffer[index+5] = pp[1];\\n                    vertexBuffer[index+6] = pp[2];\\n                    vertexBuffer[index+7] = 0;\\n                    normalBuffer[index2+4] = circleBuffer[j][0] * pointRadius;\\n                    normalBuffer[index2+5] = circleBuffer[j][1] * pointRadius;\\n                    normalBuffer[index2+6] = 0;\\n                    normalBuffer[index2+7] = 0;\\n\\n                    vertexBuffer[index+8] = pp[0];\\n                    vertexBuffer[index+9] = pp[1];\\n                    vertexBuffer[index+10] = pp[2];\\n                    vertexBuffer[index+11] = 0;\\n                    normalBuffer[index2+8] = circleBuffer[j+1][0] * pointRadius;\\n                    normalBuffer[index2+9] = circleBuffer[j+1][1] * pointRadius;\\n                    normalBuffer[index2+10] = 0;\\n                    normalBuffer[index2+11] = 0;\\n\\n                    index += 12;\\n                    index2 += 12;\\n                }\\n            }\\n        }\\n    });\\n\\n\\n    var getLinePoint = (function(length) {\\n\\n        var l1 = 0;\\n        var l2 = 0;\\n\\n        p = points[0];\\n        p1 = [p[0], p[1], p[2]];\\n\\n        if (forceOrigin) {\\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n        }\\n\\n        if (forceScale != null) {\\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n        }\\n\\n        if (length == 0) {\\n            return p1;\\n        }\\n\\n        for (var k = 0, lk = points.length - 1; k < lk; k++) {\\n            p = points[k+1];\\n            p2 = [p[0], p[1], p[2]];\\n\\n            if (forceOrigin) {\\n                p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\\n            }\\n\\n            if (forceScale != null) {\\n                p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\\n            }\\n\\n            var dx = p2[0] - p1[0], dy = p2[1] - p1[1], dz = p2[2] - p1[2]; \\n            var l = Math.sqrt(dx*dx+dy*dy+dz*dz);\\n\\n            l1 = l2;\\n            l2 += l;\\n\\n            if (length >= l1 && length <= l2) {\\n                var d = (length - l1) / l;\\n\\n                return [p1[0] + dx * d,  p1[1] + dy * d, p1[2] + dz * d];\\n            }\\n\\n            p1 = p2;\\n        }\\n\\n    });\\n\\n    var pointsBuffer = new Array(2048), pointsBufferLength = 0;\\n\\n\\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\\n        points = pointsGroups[g];\\n        \\n        if (Array.isArray(points) && points.length > 0) {\\n\\n            var totalLength = 0, lengths = null;\\n\\n            if (linePoints[0] != 'vertices') {\\n                lengths = new Array(points.length);\\n                lengths[0] = 0;\\n            }\\n\\n            //add ponints\\n            for (i = 0, li = points.length; i < li; i++) {\\n                p = points[i];\\n                p1 = [p[0], p[1], p[2]];\\n\\n                if (forceOrigin) {\\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n                }\\n        \\n                if (forceScale != null) {\\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n                }\\n                \\n                if (i + 1 < li) {\\n                    p = points[i+1];\\n                    p2 = [p[0], p[1], p[2]];\\n\\n                    if (forceOrigin) {\\n                        p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\\n                    }\\n            \\n                    if (forceScale != null) {\\n                        p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\\n                    }\\n\\n                    var dx = p2[0] - p1[0], dy = p2[1] - p1[1], dz = p2[2] - p1[2]; \\n                    var l = Math.sqrt(dx*dx+dy*dy+dz*dz);\\n\\n                    if (lengths) {\\n                        lengths[i] = l;\\n                    }\\n\\n                    totalLength += l;\\n                }\\n        \\n                center[0] += p1[0];\\n                center[1] += p1[1];\\n                center[2] += p1[2];\\n\\n                if (linePoints[0] == 'vertices') {\\n                    pointsBuffer[pointsBufferLength] = p1;\\n                    pointsBufferLength++;\\n                }\\n            }\\n\\n            if (linePoints[0] == 'by-length' || linePoints[0] == 'by-ratio') {\\n                var period = linePoints[1];\\n                var offset = linePoints[2] || 0;\\n\\n                if (linePoints[0] == 'by-ratio') {\\n                    period *= totalLength;\\n                    offset *= totalLength;\\n                }\\n\\n                if (period <= 0) {\\n                    pointsBuffer[pointsBufferLength] = getLinePoint(offset);\\n                    if (pointsBuffer[pointsBufferLength]) {\\n                        pointsBufferLength++;\\n                    }\\n                } else {\\n                    for (i = offset; i < totalLength; i += period) {\\n                        pointsBuffer[pointsBufferLength] = getLinePoint(i);\\n                        if (pointsBuffer[pointsBufferLength]) {\\n                            pointsBufferLength++;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            if (linePoints[0] == 'start') {\\n                pointsBuffer[pointsBufferLength] = getLinePoint(0);\\n                pointsBufferLength++;\\n            }\\n\\n            if (linePoints[0] == 'end') {\\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength);\\n                pointsBufferLength++;\\n            }\\n\\n            if (linePoints[0] == 'endpoints') {\\n                pointsBuffer[pointsBufferLength] = getLinePoint(0);\\n                pointsBufferLength++;\\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength);\\n                pointsBufferLength++;\\n            }\\n\\n            if (linePoints[0] == 'middle' || linePoints[0] == 'midpoint') {\\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength * 0.5);\\n                pointsBufferLength++;\\n            }\\n        }\\n    }\\n\\n    var pointsVertices, vertexBuffer, pointsNormals, normalBuffer, bufferPoints = pointsBufferLength;\\n\\n    if (point) {\\n        var circleBuffer = [];\\n        var circleSides = clamp(pointRadius * 8 * 0.5, 8, 32);\\n\\n        var angle = 0, step = (2.0*Math.PI) / circleSides;\\n\\n        for (i = 0; i < circleSides; i++) {\\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\\n            angle += step;\\n        }\\n\\n        circleBuffer[circleSides] = [0, 1.0];\\n\\n        //allocate buffers\\n        if (!pointFlat) {\\n            pointsVertices = circleSides * 3 * 4;\\n            vertexBuffer = new Float32Array(bufferPoints * pointsVertices);\\n            pointsNormals = circleSides * 3 * 4;\\n            normalBuffer = new Float32Array(bufferPoints * pointsNormals);\\n        } else {\\n            pointsVertices = circleSides * 3 * 3;\\n            vertexBuffer = new Float32Array(bufferPoints * pointsVertices);\\n        }\\n    }\\n\\n    if (!pointsBufferLength) {\\n        return;\\n    }\\n\\n    //if (pointsBufferLength > 1) {\\n      //  globals.directPoints = pointsBuffer.slice(1,pointsBufferLength);\\n    //}\\n \\n    globals.directPoints = pointsBuffer.slice(0,pointsBufferLength);\\n\\n    for (i = 0; i < pointsBufferLength; i++) {\\n        pp = pointsBuffer[i];\\n        generatePoint(i);\\n    }\\n\\n    if (totalPoints > 0) {\\n        center[0] /= totalPoints;\\n        center[1] /= totalPoints;\\n        center[2] /= totalPoints;\\n    }\\n\\n    center[0] += bboxMin[0];//groupOrigin[0];\\n    center[1] += bboxMin[1];//groupOrigin[1];\\n    center[2] += bboxMin[2];//groupOrigin[2];\\n\\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\\n    var message, messageSize;\\n\\n    globals.signatureCounter++;\\n    var signature = (\\\"\\\"+globals.signatureCounter);\\n\\n    if (visibility && !Array.isArray(visibility)) {\\n        visibility = [visibility];\\n    }\\n\\n    if (point) {\\n        if (pointFlat) {\\n            postGroupMessageFast(5, 6, {\\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \\n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer], signature);\\n        } else {\\n            postGroupMessageFast(5, 9, {\\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \\n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, normalBuffer], signature);\\n        }\\n    }\\n\\n    var sendIconMessage = (function(){\\n\\n        if (icon) {\\n\\n            globals.signatureCounter++;\\n            signature = (\\\"\\\"+globals.signatureCounter);\\n\\n            if (iconData.noOverlap) {\\n                var margin = iconData.noOverlapMargin;\\n                var factorType = null, factorValue = null;\\n\\n                if (iconData.noOverlapFactor !== null) {\\n                    switch(iconData.noOverlapFactor[0]) {\\n                        case 'direct':      factorType = 0;      break;\\n                        case 'div-by-dist': factorType = 1; break;\\n                    }\\n\\n                    factorValue = iconData.noOverlapFactor[1];\\n                }\\n\\n                var noOverlap = [iconBBox[0]-margin[0], iconBBox[1]-margin[1], iconBBox[2]+margin[0], iconBBox[3]+margin[1], factorType, factorValue];\\n            }\\n\\n            if ((iconData.singleBuffer && iconData.singleBuffer.length > 0) || (iconData.vertexBuffer && iconData.vertexBuffer.length > 0)) {\\n\\n                postGroupMessageFast(5, (iconData.singleBuffer) ? 3 : 4, {\\n                    'icon':globals.stylesheetBitmaps[iconData.source[0]], 'color':iconData.color, 'z-index':zIndex,\\n                    'visibility': visibility, 'culling': culling, 'center': pp2, 'stick': iconData.stick,\\n                    'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\\n                    'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'noOverlap' : (iconData.noOverlap ? noOverlap: null),\\n                    'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\\n                    'index': featureIndex, 'reduce': iconData.reduce, 'lod':(globals.autoLod ? null : globals.tileLod) },\\n                    (iconData.singleBuffer) ? [iconData.singleBuffer] : [iconData.vertexBuffer, iconData.originBuffer, iconData.texcoordsBuffer],\\n                    signature);\\n            }\\n        }\\n\\n    });\\n\\n    var sendLabelMessage = (function(){\\n\\n        if (label) {\\n            globals.signatureCounter++;\\n            signature = (\\\"\\\"+globals.signatureCounter);\\n\\n            if (labelData.noOverlap) {\\n                var margin = labelData.noOverlapMargin;\\n                var factorType = null, factorValue = null;\\n\\n                if (labelData.noOverlapFactor !== null) {\\n                    switch(labelData.noOverlapFactor[0]) {\\n                        case 'direct':      factorType = 0;      break;\\n                        case 'div-by-dist': factorType = 1; break;\\n                    }\\n\\n                    factorValue = labelData.noOverlapFactor[1];\\n                }\\n\\n                var noOverlap = [labelBBox[0]-margin[0], labelBBox[1]-margin[1], labelBBox[2]+margin[0], labelBBox[3]+margin[1], factorType, factorValue];\\n            }\\n\\n            if ((labelData.singleBuffer && labelData.singleBuffer.length > 0) || (labelData.vertexBuffer && labelData.vertexBuffer.length > 0)) {\\n\\n                postGroupMessageFast(5, (labelData.singleBuffer) ? 1 : 2, {\\n                    'size':labelData.size, 'origin':labelData.pos, 'color':labelData.color,\\n                    'color2':labelData.color2, 'outline':labelData.outline, 'z-index':zIndex, 'visibility': visibility,\\n                    'culling': culling, 'center': pp2, 'stick': labelData.stick, 'noOverlap' : (labelData.noOverlap ? noOverlap: null),\\n                    'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'files':labelData.files, 'index': featureIndex,\\n                    'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'fonts': labelData.fontsStorage,\\n                    'hitable':hitable, 'state':globals.hitState, 'advancedHit': advancedHit, 'reduce': labelData.reduce, 'hysteresis': labelData.hysteresis, \\n                    'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, 'lod':(globals.autoLod ? null : globals.tileLod) },\\n                    (labelData.singleBuffer) ? [labelData.singleBuffer] : [labelData.vertexBuffer, labelData.originBuffer, labelData.texcoordsBuffer],\\n                    signature);\\n            }\\n        }\\n\\n    });\\n\\n    if (icon && (!iconData.noOverlap)) {\\n        pp2 = center;\\n        sendIconMessage();\\n    }\\n\\n    if (label && (!labelData.noOverlap)) {\\n        pp2 = center;\\n        sendLabelMessage();\\n    }\\n\\n    for (i = 0, li = globals.insidePack ? 1 : globals.directPoints.length; i < li; i++) {\\n        pp = globals.directPoints[i];\\n        pp2 = [pp[0] + bboxMin[0], pp[1] + bboxMin[1], pp[2] + bboxMin[2]];\\n\\n        if (icon && (iconData.noOverlap)) {\\n            iconBBox = processIcon(pp, iconData, iconBBox) ;//, pointArray, lod, style, zIndex);\\n            sendIconMessage();\\n        }\\n\\n        if (label && (labelData.noOverlap)) {\\n            labelBBox = processLabel(pp, labelData, labelBBox); //, pointArray, lod, style, zIndex);\\n            sendLabelMessage();\\n        }\\n    }\\n\\n};\\n\\n\\nvar processPointArrayVSwitchPass = function(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\\n    var pointsGroups = []; \\n    var i, li;\\n\\n    checkDPoints(pointArray);\\n\\n    if (pointArray['lines']) {  //use lines as points\\n        pointsGroups = pointArray['lines'];\\n    } else {\\n        pointsGroups = [pointArray['points']];\\n    }\\n    \\n    if (!pointsGroups || pointsGroups.length == 0) {\\n        return;\\n    }\\n\\n\\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) || \\n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\\n    var culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\\n    var hysteresis = getLayerPropertyValue(style, 'hysteresis', pointArray, lod);\\n\\n    var points, g, gl, totalPoints = 0;\\n\\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\\n        points = pointsGroups[g];\\n        if (Array.isArray(points) && points.length > 0) {\\n            totalPoints += points.length;\\n        }\\n    }\\n\\n    var center = [0,0,0];\\n    var forceOrigin = globals.forceOrigin;\\n    var bboxMin = globals.bboxMin;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceScale = globals.forceScale;\\n    var p, p1;\\n\\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\\n        points = pointsGroups[g];\\n        \\n        if (Array.isArray(points) && points.length > 0) {\\n       \\n            //add ponints\\n            for (i = 0, li = points.length; i < li; i++) {\\n                p = points[i];\\n                p1 = [p[0], p[1], p[2]];\\n        \\n                if (forceOrigin) {\\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n                }\\n        \\n                if (forceScale != null) {\\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n                }\\n        \\n                center[0] += p1[0];\\n                center[1] += p1[1];\\n                center[2] += p1[2];\\n            }\\n        }\\n    }\\n   \\n    if (totalPoints > 0) {\\n        center[0] /= totalPoints;\\n        center[1] /= totalPoints;\\n        center[2] /= totalPoints;\\n    }\\n\\n    center[0] += bboxMin[0];//groupOrigin[0];\\n    center[1] += bboxMin[1];//groupOrigin[1];\\n    center[2] += bboxMin[2];//groupOrigin[2];\\n\\n    globals.signatureCounter++;\\n    var signature = (\\\"\\\"+globals.signatureCounter);\\n\\n    postGroupMessageFast(5, 20, {\\n        'z-index':zIndex, 'hysteresis' : hysteresis,\\n        'visibility': visibility, 'culling': culling, 'center': center, 'eventInfo': {} /*(globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}*/,\\n         'index': featureIndex, 'lod':(globals.autoLod ? null : globals.tileLod) }, [], signature);\\n};\\n\\n\\nvar getOriginOffset = function(origin, width, height) { //TODO: fix pixel units\\n    switch(origin) {\\n    case 'top-left':        return [0, 0];\\n    case 'top-right':       return [-width, 0];\\n    case 'top-center':      return [-width*0.5, 0];\\n    case 'center-left':     return [0, -height*0.5];\\n    case 'center-right':    return [-width, -height*0.5];\\n    case 'center-center':   return [-width*0.5, -height*0.5];\\n    case 'bottom-left':     return [0, -height];\\n    case 'bottom-right':    return [-width, -height];\\n    case 'bottom-center':   return [-width*0.5, -height];\\n    }\\n};\\n\\n\\nvar processIcon = function(point, iconData, cloneBuffers) {\\n\\n    if (cloneBuffers) {\\n        iconData.index = 0;\\n        iconData.index2 = 0;\\n        iconData.vertexBuffer = iconData.vertexBuffer ?  (new Float32Array(iconData.vertexBuffer.length)) : null;\\n        iconData.originBuffer = iconData.originBuffer ?  (new Float32Array(iconData.originBuffer.length)) : null;\\n        iconData.singleBuffer = iconData.singleBuffer ?  (new Float32Array(iconData.singleBuffer.length)) : null;\\n    }\\n\\n    var icon = iconData.source;\\n    var index = iconData.index;\\n    var index2 = iconData.index2;\\n    var lastIndex = index;\\n\\n    var width = Math.abs(icon[3] * iconData.scale * 0.5);\\n    var height = Math.abs(icon[4] * iconData.scale * 0.5);\\n\\n    //get offset\\n    var originOffset = getOriginOffset(iconData.origin, width, height);\\n    var offsetX = originOffset[0] + iconData.offset[0];\\n    var offsetY = originOffset[1] + iconData.offset[1];\\n\\n    if (iconData.singleBuffer) {\\n        var b = iconData.singleBuffer;\\n\\n        b[0] = offsetX; b[1] = offsetY;\\n        b[2] = icon[1];\\n        b[3] = icon[2];\\n\\n        b[4] = width + offsetX; b[5] = offsetY;\\n        b[6] = icon[1]+icon[3];\\n        b[7] = icon[2];\\n\\n        b[8] = width + offsetX; b[9] = height + offsetY;\\n        b[10] = icon[1]+icon[3];\\n        b[11] = icon[2]+icon[4];\\n\\n        b[12] = offsetX; b[13] = height + offsetY;\\n        b[14] = icon[1];\\n        b[15] = icon[2]+icon[4];\\n\\n        return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\\n    }\\n\\n    var vertexBuffer = iconData.vertexBuffer;\\n    var texcoordsBuffer = iconData.texcoordsBuffer;\\n    var originBuffer = iconData.originBuffer;\\n\\n    //add polygon\\n    vertexBuffer[index] = 0;\\n    vertexBuffer[index+1] = 0;\\n    vertexBuffer[index+2] = 0;\\n    vertexBuffer[index+3] = 0;\\n\\n    vertexBuffer[index+4] = width;\\n    vertexBuffer[index+5] = 0;\\n    vertexBuffer[index+6] = 0;\\n    vertexBuffer[index+7] = 0;\\n\\n    vertexBuffer[index+8] = width;\\n    vertexBuffer[index+9] = -height;\\n    vertexBuffer[index+10] = 0;\\n    vertexBuffer[index+11] = 0;\\n\\n    texcoordsBuffer[index] = icon[1];\\n    texcoordsBuffer[index+1] = icon[2];\\n    texcoordsBuffer[index+2] = 0;\\n    texcoordsBuffer[index+3] = 0;\\n\\n    texcoordsBuffer[index+4] = icon[1]+icon[3];\\n    texcoordsBuffer[index+5] = icon[2];\\n    texcoordsBuffer[index+6] = 0;\\n    texcoordsBuffer[index+7] = 0;\\n\\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\\n    texcoordsBuffer[index+10] = 0;\\n    texcoordsBuffer[index+11] = 0;\\n\\n    index += 12;\\n\\n    //add polygon\\n    vertexBuffer[index] = 0;\\n    vertexBuffer[index+1] = 0;\\n    vertexBuffer[index+2] = 0;\\n    vertexBuffer[index+3] = 0;\\n\\n    vertexBuffer[index+4] = 0;\\n    vertexBuffer[index+5] = -height;\\n    vertexBuffer[index+6] = 0;\\n    vertexBuffer[index+7] = 0;\\n\\n    vertexBuffer[index+8] = width;\\n    vertexBuffer[index+9] = -height;\\n    vertexBuffer[index+10] = 0;\\n    vertexBuffer[index+11] = 0;\\n\\n    texcoordsBuffer[index] = icon[1];\\n    texcoordsBuffer[index+1] = icon[2];\\n    texcoordsBuffer[index+2] = 0;\\n    texcoordsBuffer[index+3] = 0;\\n\\n    texcoordsBuffer[index+4] = icon[1];\\n    texcoordsBuffer[index+5] = icon[2]+icon[4];\\n    texcoordsBuffer[index+6] = 0;\\n    texcoordsBuffer[index+7] = 0;\\n\\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\\n    texcoordsBuffer[index+10] = 0;\\n    texcoordsBuffer[index+11] = 0;\\n    \\n    index += 12;\\n\\n    var p1 = point[0];\\n    var p2 = point[1];\\n    var p3 = point[2];\\n\\n    //set origin buffer and apply offset\\n    for (var i = lastIndex; i < index; i+=4) {\\n        vertexBuffer[i] += offsetX;\\n        vertexBuffer[i+1] -= offsetY;\\n\\n        originBuffer[index2] = p1;\\n        originBuffer[index2 + 1] = p2;\\n        originBuffer[index2 + 2] = p3;\\n        index2 += 3;\\n    }\\n\\n    iconData.index = index;\\n    iconData.index2 = index2;\\n\\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\\n};\\n\\n\\nvar processLabel = function(point, labelData, cloneBuffers) {\\n\\n    if (cloneBuffers) {\\n        labelData.index = 0;\\n        labelData.index2 = 0;\\n        labelData.vertexBuffer = labelData.vertexBuffer ?  (new Float32Array(labelData.vertexBuffer.length)) : null;\\n        labelData.originBuffer = labelData.originBuffer ?  (new Float32Array(labelData.originBuffer.length)) : null;\\n        labelData.singleBuffer = labelData.singleBuffer ?  (new Float32Array(labelData.singleBuffer.length)) : null;\\n    }\\n\\n    var vertexBuffer = labelData.vertexBuffer;\\n    var texcoordsBuffer = labelData.texcoordsBuffer;\\n    var originBuffer = labelData.originBuffer;\\n    var singleBuffer = labelData.singleBuffer;\\n    var index = labelData.index;\\n    var index2 = labelData.index2;\\n    var lastIndex = index;\\n    var text = '' + labelData.text;\\n    var fonts = labelData.fonts;\\n    var planes = {}, i, li;\\n    var glyphsRes = labelData.glyphsRes;\\n\\n    var linesGlyphsRes = [];\\n    var linesGlyphsRes2 = [];\\n\\n    //split text to lines\\n    do {\\n        var res = glyphsRes[2].indexOf(10); //search /n\\n\\n        if (res != -1) {\\n            linesGlyphsRes.push([glyphsRes[0].slice(0,res), glyphsRes[1].slice(0,res), glyphsRes[2].slice(0,res)]);\\n            glyphsRes = [glyphsRes[0].slice(res+1), glyphsRes[1].slice(res+1), glyphsRes[2].slice(res+1)];\\n        } else {\\n            linesGlyphsRes.push(glyphsRes);\\n        }\\n\\n    } while (res != -1);\\n\\n    //split lines by width\\n    for (var i = 0, li = linesGlyphsRes.length; i < li; i++) {\\n\\n        var glyphsRes = linesGlyphsRes[i];\\n\\n        // eslint-disable-next-line\\n        do {\\n            var splitIndex = getSplitIndex(null, labelData.width, labelData.size, labelData.spacing, fonts, glyphsRes);\\n            var codes = glyphsRes[2];\\n\\n            if (codes.length == splitIndex) {\\n                linesGlyphsRes2.push(glyphsRes);\\n                break;\\n            }\\n\\n            linesGlyphsRes2.push([glyphsRes[0].slice(0,splitIndex), glyphsRes[1].slice(0,splitIndex), glyphsRes[2].slice(0,splitIndex)]);\\n\\n            glyphsRes = [glyphsRes[0].slice(splitIndex+1), glyphsRes[1].slice(splitIndex+1), glyphsRes[2].slice(splitIndex+1)];\\n\\n        } while(true);\\n\\n    }\\n\\n    var x = 0, y = 0;\\n    var lineHeight = getLineHeight(labelData.size, labelData.lineHeight, fonts);\\n    var maxWidth = 0;\\n    var lineWidths = [];\\n\\n    //get max width\\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\\n        lineWidths[i] = getTextLength(null, labelData.size, labelData.spacing, fonts, linesGlyphsRes2[i]);\\n        maxWidth = Math.max(lineWidths[i], maxWidth);\\n    }\\n\\n    //generate text\\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\\n        var textWidth = lineWidths[i];\\n\\n        switch(labelData.align) {\\n        case 'left': x = 0; break;\\n        case 'right': x = maxWidth - textWidth; break;\\n        case 'center': x = (maxWidth - textWidth)*0.5; break;\\n        }\\n\\n        index = addText([x,y,0], [1,0,0], null, labelData.size, labelData.spacing, fonts, vertexBuffer, texcoordsBuffer, true, index, planes, linesGlyphsRes2[i], singleBuffer);\\n        y -= lineHeight;\\n    }\\n\\n    //get offset\\n    var originOffset = getOriginOffset(labelData.origin, maxWidth, -y);\\n    var offsetX = originOffset[0] + labelData.offset[0];\\n    var offsetY = originOffset[1] + labelData.offset[1];\\n    \\n    var p1 = point[0];\\n    var p2 = point[1];\\n    var p3 = point[2];\\n\\n    //set origin buffer and apply offset\\n    if (!singleBuffer) {\\n        for (i = lastIndex; i < index; i+=4) {\\n            vertexBuffer[i] += offsetX;\\n            vertexBuffer[i+1] -= offsetY;\\n\\n            originBuffer[index2] = p1;\\n            originBuffer[index2 + 1] = p2;\\n            originBuffer[index2 + 2] = p3;\\n            index2 += 3;\\n        }\\n    } else {\\n        for (i = lastIndex; i < index; i+=8) {\\n            singleBuffer[i] += offsetX;\\n            singleBuffer[i+1] -= offsetY;\\n            singleBuffer[i+2] += offsetX;\\n            singleBuffer[i+3] -= offsetY;\\n        }\\n\\n        labelData.pos = [p1,p2,p3];\\n        singleBuffer = new Float32Array(singleBuffer.buffer, 0, index);\\n    }\\n    \\n    var fonts = labelData.fonts;\\n    labelData.files = new Array(fonts.length);\\n\\n    for (i = 0, li= fonts.length; i < li; i++) {\\n        labelData.files[i] = [];\\n    }\\n\\n    for (var key in planes) {\\n        var fontIndex = parseInt(key);\\n        var planes2 = planes[key];\\n\\n        var files = [];\\n\\n        for (var key2 in planes2) {\\n            var plane = parseInt(key2) - (fontIndex*4000);\\n            var file = Math.round((plane - (plane % 4)) / 4);\\n            \\n            if (files.indexOf(file) == -1) {\\n                files.push(file);\\n            }\\n        }\\n\\n        labelData.files[fontIndex] = files;\\n    }\\n\\n    labelData.index = index;\\n    labelData.index2 = index2;\\n\\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + maxWidth) * 0.5 + 1, (offsetY + Math.abs(y)) *0.5];\\n};\\n\\nvar processPointArrayGeometry = function(pointArray) {\\n    var i, li;\\n\\n    checkDPoints(pointArray);\\n\\n    if (pointArray['lines']) {  //use lines as points\\n        pointsGroups = pointArray['lines'];\\n    } else {\\n        pointsGroups = [pointArray['points']];\\n    }\\n    \\n    if (!pointsGroups || pointsGroups.length == 0) {\\n        return;\\n    }\\n\\n    var totalPoints = 0;\\n    var indicesBuffer = new Uint32Array(pointsGroups.length);\\n\\n    for (i = 0; i < pointsGroups.length; i++) {\\n        indicesBuffer[i] = totalPoints;\\n\\n        if (Array.isArray(pointsGroups[i])) {\\n            totalPoints += pointsGroups[i].length;\\n        }\\n    }\\n\\n    var geometryBuffer = new Float64Array(totalPoints * 3);\\n\\n    /*var forceOrigin = globals.forceOrigin;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;*/\\n    var forceScale = globals.forceScale;\\n    var index = 0, p1, p2, pp, p;\\n\\n    for (var i = 0; i < pointsGroups.length; i++) {\\n        if (!Array.isArray(pointsGroups[i]) || !pointsGroups[i].length) {\\n            continue;\\n        }\\n        \\n        var points = pointsGroups[i];\\n   \\n        p = points[0];\\n        p1 = [p[0], p[1], p[2]];\\n    \\n        //add lines\\n        for (var j = 0, lj = points.length; j < lj; j++) {\\n\\n            /*if (forceOrigin) {\\n                pp = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n            }*/\\n    \\n            if (forceScale != null) {\\n                pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n            }\\n\\n            geometryBuffer[index] = pp[0];\\n            geometryBuffer[index+1] = pp[1];\\n            geometryBuffer[index+2] = pp[2];\\n            index += 3;\\n\\n            if (j == (lj - 1)) {\\n                break;\\n            }\\n    \\n            p1 = points[j+1];\\n        }\\n    }\\n\\n    globals.signatureCounter++;\\n    postGroupMessageFast(5, 5, {\\n        'id':pointArray['id'] }, [geometryBuffer, indicesBuffer], (\\\"\\\"+globals.signatureCounter));\\n};\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-polygon.js\\\":\\n/*!**********************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-polygon.js ***!\\n  \\\\**********************************************************/\\n/*! exports provided: processPolygonPass */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"processPolygonPass\\\", function() { return processPolygonPass; });\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/geodata-processor/worker-globals.js\\\");\\n/* harmony import */ var _worker_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-style.js */ \\\"./src/core/map/geodata-processor/worker-style.js\\\");\\n/* harmony import */ var _worker_message_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker-message.js */ \\\"./src/core/map/geodata-processor/worker-message.js\\\");\\n/* harmony import */ var _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./worker-linestring.js */ \\\"./src/core/map/geodata-processor/worker-linestring.js\\\");\\n/* harmony import */ var _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./worker-pointarray.js */ \\\"./src/core/map/geodata-processor/worker-pointarray.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"], vec3Normalize = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"vec3Normalize\\\"];\\nvar getLayerPropertyValue = _worker_style_js__WEBPACK_IMPORTED_MODULE_1__[\\\"getLayerPropertyValue\\\"];\\nvar postGroupMessageFast = _worker_message_js__WEBPACK_IMPORTED_MODULE_2__[\\\"postGroupMessageFast\\\"];\\nvar processLineStringPass = _worker_linestring_js__WEBPACK_IMPORTED_MODULE_3__[\\\"processLineStringPass\\\"];\\nvar processPointArrayPass = _worker_pointarray_js__WEBPACK_IMPORTED_MODULE_4__[\\\"processPointArrayPass\\\"];\\n\\nvar processPolygonPass = function(polygon, lod, style, featureIndex, zIndex, eventInfo) {\\n    var vertices = polygon['vertices'] || [];\\n    if (vertices.length == 0) {\\n        return;\\n    }\\n    \\n    // borders as points\\n    if (getLayerPropertyValue(style, 'point', polygon, lod) ||\\n        getLayerPropertyValue(style, 'label', polygon, lod)) {\\n        processPolygonLines(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, false);\\n    }\\n    \\n    // borders as lines\\n    if (getLayerPropertyValue(style, 'line', polygon, lod) ||\\n        getLayerPropertyValue(style, 'line-label', polygon, lod)) {\\n        processPolygonLines(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, true);\\n    }\\n    \\n    var spolygon = getLayerPropertyValue(style, 'polygon', polygon, lod);\\n    \\n    if (!spolygon) {\\n        return;\\n    }\\n    \\n    var surface = polygon['surface'] || [];\\n    if (surface.length == 0) {\\n        return;\\n    }\\n    \\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', polygon, lod);\\n    var clickEvent = getLayerPropertyValue(style, 'click-event', polygon, lod);\\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', polygon, lod);\\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', polygon, lod);\\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', polygon, lod);\\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', polygon, lod);\\n\\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', polygon, lod);\\n    \\n    var polygonColor = getLayerPropertyValue(style, 'polygon-color', polygon, lod);\\n    var polygonStyle = getLayerPropertyValue(style, 'polygon-style', polygon, lod);\\n    var polygonStencil = getLayerPropertyValue(style, 'polygon-use-stencil', polygon, lod);\\n    var polygonCulling = getLayerPropertyValue(style, 'polygon-culling', polygon, lod);\\n    var polygonExtrude = getLayerPropertyValue(style, 'polygon-extrude', polygon, lod);\\n    \\n    polygonStyle = (polygonStyle == 'flatshade') ? 1 : 0;\\n    polygonCulling = (polygonCulling == 'back') ? 1 : 0;\\n\\n    var geocent = globals.geocent;\\n    var center = [0,0,0], n = [0,0,0];\\n    var bboxMin = globals.bboxMin;\\n  \\n\\n    // allocate vertex buffer\\n    var trisCount = surface.length / 3;\\n    var vertexCount = trisCount * 3;\\n    var vertexBuffer = new Float32Array(vertexCount * 3);\\n    \\n    var surfaceI = 0;\\n    var index = 0;\\n    var p1 = [0,0,0], p2 = [0,0,0], p3 = [0,0,0], p4 = [0,0,0];\\n    var offs, li, j, lj;\\n\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceOrigin = globals.forceOrigin;\\n    var forceScale = globals.forceScale;    \\n\\n    //debugger\\n    \\n    //console.log(\\\"vertexCount = \\\" + vertexCount);\\n    //add tris\\n    for (var i = 0; i < vertexCount; i++) {\\n        offs = 3 * surface[surfaceI++];\\n        p1 = [vertices[offs], vertices[offs+1], vertices[offs+2]];\\n\\n        if (forceOrigin) {\\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n        }\\n\\n        if (forceScale != null) {\\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n        }\\n \\n        if (polygonExtrude) {\\n            if (geocent) {\\n                vec3Normalize([p1[0] + bboxMin[0], p1[1] + bboxMin[1], p1[2] + bboxMin[2]], n);\\n                p1[0] += n[0] * polygonExtrude;\\n                p1[1] += n[1] * polygonExtrude;\\n                p1[2] += n[2] * polygonExtrude;\\n            } else {\\n                p1[2] += polygonExtrude;\\n            }\\n        }\\n\\n        center[0] += p1[0];\\n        center[1] += p1[1];\\n        center[2] += p1[2];\\n\\n        //add vertex\\n        vertexBuffer[index++] = p1[0];\\n        vertexBuffer[index++] = p1[1];\\n        vertexBuffer[index++] = p1[2];\\n    }\\n    \\n    //console.log( \\\"vertexBuffer: \\\" + vertexBuffer );\\n    \\n    if (vertexCount > 0) {\\n        var k = 1.0 / vertexCount;\\n        center[0] *= k;\\n        center[1] *= k;\\n        center[2] *= k;\\n    }\\n\\n    center[0] += globals.groupOrigin[0];\\n    center[1] += globals.groupOrigin[1];\\n    center[2] += globals.groupOrigin[2];\\n\\n    var borders = polygon['borders'] || [];\\n    if (borders.length > 0) {\\n\\n        var totalFaces = 0;\\n\\n        for (i = 0, li = borders.length; i < li; i++) {\\n            var border = borders[i];\\n            totalFaces += (border.length + 1) * 2;\\n        }\\n\\n        var vertexBuffer2 = vertexBuffer;\\n        vertexBuffer = new Float32Array(vertexBuffer.length + (totalFaces * 3 * 3));\\n        vertexBuffer.set(vertexBuffer2);\\n\\n        for (i = 0, li = borders.length; i < li; i++) {\\n            var border = borders[i], offset;\\n\\n            for (j = 0, lj = border.length; j < lj; j++) {\\n\\n                if (border[j] >= 0) {\\n                    offset = 3 * border[j];\\n                } else {\\n                    offset = 3 * (-border[j]);\\n                }\\n\\n                p1[0] = vertices[offset];\\n                p1[1] = vertices[offset+1];\\n                p1[2] = vertices[offset+2];\\n\\n                p3[0] = vertices[offset];\\n                p3[1] = vertices[offset+1];\\n                p3[2] = vertices[offset+2];\\n\\n                if (j < lj - 1) {\\n                    if (border[j+1] >= 0) {\\n                        offset = 3 * border[j+1];\\n                    } else {\\n                        offset = 3 * (-border[j+1]);\\n                    }\\n                } else {\\n                    if (border[0] >= 0) {\\n                        offset = 3 * border[0];\\n                    } else {\\n                        offset = 3 * (-border[0]);\\n                    }\\n                }\\n\\n                p2[0] = vertices[offset];\\n                p2[1] = vertices[offset+1];\\n                p2[2] = vertices[offset+2];\\n\\n                p4[0] = vertices[offset];\\n                p4[1] = vertices[offset+1];\\n                p4[2] = vertices[offset+2];\\n\\n                if (forceOrigin) {\\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n                    p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\\n                    p3 = [p3[0] - tileX, p3[1] - tileY, p3[2]];\\n                    p4 = [p4[0] - tileX, p4[1] - tileY, p4[2]];\\n                }\\n\\n                if (forceScale != null) {\\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n                    p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\\n                    p3 = [p3[0] * forceScale[0], p3[1] * forceScale[1], p3[2] * forceScale[2]];\\n                    p4 = [p4[0] * forceScale[0], p4[1] * forceScale[1], p4[2] * forceScale[2]];\\n                }\\n\\n                if (polygonExtrude) {\\n                    if (geocent) {\\n                        vec3Normalize([p1[0] + bboxMin[0], p1[1] + bboxMin[1], p1[2] + bboxMin[2]], n);\\n                        p1 = [p1[0] + n[0] * polygonExtrude, p1[1] + n[1] * polygonExtrude, p1[2] + n[2] * polygonExtrude];\\n\\n                        vec3Normalize([p2[0] + bboxMin[0], p2[1] + bboxMin[1], p2[2] + bboxMin[2]], n);\\n                        p2 = [p2[0] + n[0] * polygonExtrude, p2[1] + n[1] * polygonExtrude, p2[2] + n[2] * polygonExtrude];\\n                    } else {\\n                        p1[2] += polygonExtrude;\\n                        p2[2] += polygonExtrude;\\n                    }\\n                }\\n\\n                vertexBuffer[index] = p4[0];\\n                vertexBuffer[index+1] = p4[1];\\n                vertexBuffer[index+2] = p4[2];\\n\\n                vertexBuffer[index+3] = p2[0];\\n                vertexBuffer[index+4] = p2[1];\\n                vertexBuffer[index+5] = p2[2];\\n\\n                vertexBuffer[index+6] = p1[0];\\n                vertexBuffer[index+7] = p1[1];\\n                vertexBuffer[index+8] = p1[2];\\n\\n                vertexBuffer[index+9] = p1[0];\\n                vertexBuffer[index+10] = p1[1];\\n                vertexBuffer[index+11] = p1[2];\\n\\n                vertexBuffer[index+12] = p3[0];\\n                vertexBuffer[index+13] = p3[1];\\n                vertexBuffer[index+14] = p3[2];\\n\\n                vertexBuffer[index+15] = p4[0];\\n                vertexBuffer[index+16] = p4[1];\\n                vertexBuffer[index+17] = p4[2];\\n\\n                index += 18;\\n            }\\n        }\\n    }    \\n\\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\\n    \\n    var signature = JSON.stringify({\\n        style: polygonStyle,\\n        culling: polygonCulling, \\n        stencil: polygonStencil, \\n        color : polygonColor,\\n        zIndex : zIndex,\\n        zOffset : zbufferOffset,\\n        state : globals.hitState\\n    });\\n\\n    //debugger\\n\\n    postGroupMessageFast(5, 13, {\\n        'color':polygonColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit, 'culling': polygonCulling, \\n        'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'style' : polygonStyle, 'stencil': polygonStencil, \\n        'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\\n        'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\\n        'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer], signature);\\n};\\n\\nvar createEmptyFeatureFromPolygon = function(polygon) {\\n    var feature = {};\\n    for(var key in polygon) {\\n        if(key != 'surface' && key != 'vertices' && key != 'borders') {\\n            feature[key] = polygon[key];\\n        }\\n    }\\n    return feature;\\n};\\n\\nvar processPolygonLines = function(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, processLines) {\\n    var borders = polygon['borders'] || [];\\n    if (borders.length == 0) {\\n        return;\\n    }\\n    var polygonExtrude = getLayerPropertyValue(style, 'polygon-extrude', polygon, lod);\\n    var feature = createEmptyFeatureFromPolygon(polygon);\\n    var bordersCount = borders.length;\\n    var allPoints = [], allPoints2 = [];\\n    var p, p2, n = [0,0,0];\\n\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceOrigin = globals.forceOrigin;\\n    var forceScale = globals.forceScale;    \\n    var forceScale2 = [1.0/forceScale[0], 1.0/forceScale[1], 1.0/forceScale[2]];    \\n    var geocent = globals.geocent;\\n    var bboxMin = globals.bboxMin;\\n\\n    for (var j = 0; j < bordersCount; j++) {\\n        var border = borders[j], offset;\\n        var pointsCount = border.length;\\n        var pointsCount2 = 0;\\n        if (pointsCount > 0) {\\n            var points, points3, points4, i;\\n            if (processLines) {\\n                points = new Array(pointsCount + 1);\\n                points3 = new Array(pointsCount + 1);\\n            } else {\\n                points = new Array(pointsCount);\\n                points3 = new Array(pointsCount);\\n            }\\n            for (i = 0; i < pointsCount; i++) {\\n                if (border[i] >= 0) {\\n                    offset = 3 * border[i];\\n                    pointsCount2++; // count vertices with positive index\\n                } else {\\n                    offset = 3 * (-border[i]);\\n                }\\n\\n                if (polygonExtrude) {\\n                    p = [vertices[offset], vertices[offset+1], vertices[offset+2]];\\n                    p2 = p.slice();\\n\\n                    if (forceOrigin) {\\n                        p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\\n                    }\\n\\n                    if (forceScale != null) {\\n                        p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\\n                    }\\n\\n                    if (geocent) {\\n                        vec3Normalize([p2[0] + bboxMin[0], p2[1] + bboxMin[1], p2[2] + bboxMin[2]], n);\\n                        p2 = [p[0] + (n[0] * polygonExtrude) * forceScale2[0], p[1] + (n[1] * polygonExtrude) * forceScale2[1], p[2] + (n[2] * polygonExtrude) * forceScale2[2]];\\n                    } else {\\n                        p2[2] += polygonExtrude;\\n                    }\\n\\n                    points[i] = p;\\n                    points3[i] = p2;\\n\\n                    if (border[i] >= 0) {\\n                        allPoints.push([p,p2]);\\n                    }\\n\\n                } else {\\n                    points[i] = [vertices[offset], vertices[offset+1], vertices[offset+2]];\\n                }\\n\\n                if (processLines && i == 0) {\\n                    points[pointsCount] = points[0];\\n                    points3[pointsCount] = points3[0];\\n                }\\n            }\\n\\n            var points2 = new Array(pointsCount2);\\n            var points4 = new Array(pointsCount2);\\n            var i2 = 0;\\n            //debugger\\n\\n            //create array of points only for vertices with positive value\\n            for (i = 0; i < pointsCount; i++) {\\n                if (border[i] >= 0) {\\n                    points2[i2] = points[i].slice();\\n\\n                    if (polygonExtrude) {\\n                        points4[i2] = points3[i].slice();\\n                    }\\n\\n                    i2++;\\n                }\\n            }\\n\\n            allPoints.push(points);\\n            allPoints2 = allPoints2.concat(points2);\\n\\n            if (polygonExtrude) {\\n                allPoints.push(points3);\\n                allPoints2 = allPoints2.concat(points4);\\n            }\\n\\n        }\\n    }\\n\\n    if(processLines && allPoints.length > 0) {\\n        feature['lines'] = allPoints;\\n        processLineStringPass(feature, lod, style, featureIndex, zIndex, eventInfo);\\n    } else if(allPoints2.length > 0) {\\n        feature['points'] = allPoints2;\\n        processPointArrayPass(feature, lod, style, featureIndex, zIndex, eventInfo);\\n    }\\n\\n};\\n \\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-style.js\\\":\\n/*!********************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-style.js ***!\\n  \\\\********************************************************/\\n/*! exports provided: getFilterResult, processStylesheet, getLayer, getLayerPropertyValue, getLayerExpresionValue, getLayerPropertyValueInner, makeFasterFilter, hasLayerProperty */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getFilterResult\\\", function() { return getFilterResult; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"processStylesheet\\\", function() { return processStylesheet; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getLayer\\\", function() { return getLayer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getLayerPropertyValue\\\", function() { return getLayerPropertyValue; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getLayerExpresionValue\\\", function() { return getLayerExpresionValue; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getLayerPropertyValueInner\\\", function() { return getLayerPropertyValueInner; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"makeFasterFilter\\\", function() { return makeFasterFilter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"hasLayerProperty\\\", function() { return hasLayerProperty; });\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/geodata-processor/worker-globals.js\\\");\\n/* harmony import */ var _worker_text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-text.js */ \\\"./src/core/map/geodata-processor/worker-text.js\\\");\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"];\\nvar clamp = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"clamp\\\"];\\nvar simpleFmtCall = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"simpleFmtCall\\\"];\\nvar getHash = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"getHash\\\"];\\nvar hasLatin = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\\\"hasLatin\\\"], isCJK = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\\\"isCJK\\\"];\\nvar areTextCharactersAvailable = _worker_text_js__WEBPACK_IMPORTED_MODULE_1__[\\\"areTextCharactersAvailable\\\"];\\n\\n\\nvar getLayer = function(layerId, featureType, index) {\\n    var layer = globals.stylesheetData.layers[layerId];\\n    if (layer == null) {\\n        logError('wrong-Layer', layerId, null, null, index, featureType);\\n        return {};\\n    } else {\\n        return layer;\\n    }\\n};\\n\\n\\nvar getLayerExpresionValue = function(layer, value, feature, lod, key, depth) {\\n    var finalValue;\\n    if (!depth) {\\n        depth = 0;\\n    }\\n    if (depth > 100) {\\n        return void(0);\\n    }\\n\\n\\n    switch(typeof value) {\\n    case 'string':\\n\\n        if (value.length > 0) {\\n\\n            switch (value.charAt(0)) {\\n                case '#': \\n                case '$':\\n                case '@':\\n                case '&':\\n                case '%':\\n\\n                    finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, value, depth + 1);\\n\\n                    if (typeof finalValue == 'undefined') {\\n                        logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\\n                    }\\n\\n                    return finalValue;\\n            }\\n\\n\\n            return simpleFmtCall(value, (function(str){  \\n\\n                if (str.length > 0) {\\n\\n                    switch (str.charAt(0)) {\\n                        case '#': \\n                        case '$':\\n                        case '@':\\n                        case '&':\\n                        case '%':\\n\\n                            finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, str, depth + 1);\\n\\n                            if (typeof finalValue == 'undefined') {\\n                                logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\\n                            }\\n        \\n                            return finalValue;\\n                    }\\n\\n                    if (str.indexOf('{') != -1) {\\n\\n                        try {\\n                            str = str.replace(/'/g, '\\\"');\\n                            finalValue = JSON.parse(str);\\n                        } catch(e) {\\n                            logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\\n                            return \\\"\\\";\\n                        }\\n\\n                        if (typeof finalValue == 'undefined') {\\n                            logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\\n                            return \\\"\\\";\\n                        } else {\\n                            return getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth + 1);\\n                        }\\n\\n                    } else {\\n                        return str;\\n                    }\\n\\n                }\\n\\n            }));\\n        }\\n\\n        break;\\n    }\\n    \\n    return value;\\n};\\n\\n\\nvar hasLayerProperty = function(layer, key) {\\n    return (typeof layer[key] !== 'undefined');\\n};\\n\\n\\nvar getLayerPropertyValue = function(layer, key, feature, lod) {\\n    var value = getLayerPropertyValueInner(layer, key, feature, lod);\\n    return validateLayerPropertyValue(layer['$$layer-id'], key, value);\\n};\\n\\n\\nvar getLayerPropertyValueInnerString = function(layer, key, feature, lod, value, depth) {\\n    var finalValue = value;\\n\\n    //is it feature property, variable or constant?\\n    switch(value.charAt(0)) {\\n        case '$': finalValue = feature.properties[value.substr(1)]; break;\\n        case '@': finalValue = globals.stylesheetConstants[value]; break;\\n        case '%': finalValue = globals.stylesheetVariables[value.substr(1)]; break;\\n        case '&': finalValue = globals.stylesheetLocals[value]; break;\\n        case '#': \\n            //debugger;\\n            switch(value) {\\n                case '#id':        return feature.id;\\n                case '#type':      return globals.featureType;\\n                case '#group':     return globals.groupId;\\n                case '#lod':       return globals.tileLod;\\n                case '#ix':        return globals.tileIX;\\n                case '#iy':        return globals.tileIY;\\n                case '#tileSize':  return globals.tileSize;\\n                case '#pixelSize': return globals.pixelSize;\\n                case '#metric':    return globals.metricUnits;\\n                case '#dpr':       return globals.pixelFactor;\\n                case '#language':  return globals.language;\\n            }\\n            break;\\n    }\\n\\n    if (value.charAt(0) == '&') {\\n        if (typeof finalValue === 'undefined') {\\n            finalValue = layer[value];\\n            if (typeof finalValue !== 'undefined') {\\n\\n                if (typeof finalValue === 'string') {\\n                    finalValue = getLayerExpresionValue(layer, finalValue, feature, lod, key, depth+1);\\n                } else {\\n                    if (typeof finalValue !== 'undefined') {\\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth+1);\\n                    }\\n                }\\n\\n                globals.stylesheetLocals[value] = finalValue;\\n            }\\n        }\\n    } else { // @,$,%\\n\\n        if (typeof finalValue === 'string') {\\n            finalValue = getLayerExpresionValue(layer, finalValue, feature, lod, key, depth+1);\\n        } else {\\n            if (typeof finalValue !== 'undefined' && value.charAt(0) == '@') {\\n                finalValue = getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth+1);\\n            }\\n        }\\n\\n    }\\n\\n    return finalValue;\\n};\\n\\nvar getLayerPropertyValueInner = function(layer, key, feature, lod, value, depth) {\\n    var index = 0, i, li, finalValue, root, v1, v2, v3, v4;\\n    var tmpValue;\\n\\n    \\n    if ((typeof value) === 'undefined') {\\n        /*\\n        if (layer[key]) {\\n            value = JSON.parse(JSON.stringify(layer[key])); //make copy\\n        } else {\\n            value = layer[key];\\n        }*/\\n\\n        value = layer[key];\\n\\n        root = true;\\n        depth = 0;\\n    } else {\\n        if (depth > 100) {\\n            return void(0);\\n        }\\n    }\\n\\n    switch(typeof value) {\\n    case 'string':\\n\\n        if (value.length > 0) {\\n            finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, value, depth);\\n\\n            if (typeof finalValue !== 'undefined') {\\n                return finalValue;\\n            } else {\\n                logError('wrong-object', layer['$$layer-id'], key, value, null, 'feature-property');\\n                \\n                if (root) {\\n                    return getDefaultLayerPropertyValue(key);\\n                } else {\\n                    return void(0);\\n                }\\n            }\\n        }\\n\\n        return value;\\n\\n    case 'object':\\n\\n            //is it null?\\n        if (value == null) {\\n            if (root) {\\n                return getDefaultLayerPropertyValue(key);\\n            } else {\\n                return void(0);\\n            }\\n        }\\n\\n        //is it array (rgb, rgba, vec2)?\\n        if (Array.isArray(value)) {\\n\\n            if (key == 'icon-source') {\\n                //index++;\\n                if (globals.stylesheetBitmaps[value[0]] == null) {\\n                    logError('wrong-object', layer['$$layer-id'], key, value, null, 'bitmap');\\n\\n                    if (root) {\\n                        return getDefaultLayerPropertyValue(key);\\n                    } else {\\n                        return void(0);\\n                    }\\n                }\\n            }\\n\\n            if (key != 'filter') {\\n                tmpValue = new Array(value.length);\\n\\n                for (i = index, li = value.length; i < li; i++) {\\n                    tmpValue[i] = getLayerPropertyValueInner(layer, key, feature, lod, value[i], depth + 1);\\n                }\\n\\n                return tmpValue;\\n            }\\n\\n            return value;\\n        }\\n\\n        var functionName, functionValue, functionError, finalValue;\\n\\n        for (functionName in value) {\\n            break;\\n        }\\n\\n        if (!functionName) {\\n            if (root) {\\n                return getDefaultLayerPropertyValue(key);\\n            } else {\\n                return void(0);\\n            }\\n        }\\n\\n        functionValue = value[functionName];\\n\\n        switch (functionName) {\\n            case 'if':\\n\\n                if (!Array.isArray(functionValue) || functionValue.length != 3) {\\n                    functionError = true;\\n                } else {\\n                    if (getFilterResult(functionValue[0], feature, globals.featureType, globals.groupId, layer, key, lod, 0)) {\\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\\n                    } else {\\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\\n                    }\\n\\n                    if (typeof finalValue === 'undefined') {\\n                        functionError = true;\\n                    } else {\\n                        return finalValue;\\n                    }\\n                }\\n\\n                break;\\n\\n            case 'add':\\n            case 'sub':\\n            case 'mul':\\n            case 'div':\\n            case 'mod':\\n            case 'pow':\\n            case 'tofixed':\\n            case 'atan2':\\n            case 'random':\\n\\n                if (!Array.isArray(functionValue) || functionValue.length != 2) {\\n                    functionError = true;\\n                } else {\\n\\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\\n\\n                    if (typeof v1 !== 'number' || typeof v2 !== 'number') {\\n                        functionError = true;\\n                    } else {\\n                        switch (functionName) {\\n                            case 'add':    return v1 + v2;\\n                            case 'sub':    return v1 - v2;\\n                            case 'mul':    return v1 * v2;\\n                            case 'div':    return v1 / v2;\\n                            case 'mod':    return v1 % v2;\\n                            case 'pow':    return Math.pow(v1, v2);\\n                            case 'atan2':  return Math.atan2(v1, v2);\\n                            case 'tofixed': return v1.tofixed(v2);\\n                            case 'random': return v1 + Math.random() * (v2-v1);\\n                        }\\n                    }\\n                }\\n\\n                break;\\n\\n            case 'clamp':\\n\\n                if (!Array.isArray(functionValue) || functionValue.length != 3) {\\n                    functionError = true;\\n                } else {\\n\\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\\n                    v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\\n\\n                    if (typeof v1 !== 'number' || typeof v2 !== 'number' || typeof v3 !== 'number') {\\n                        functionError = true;\\n                    } else {\\n                        return clamp(v1, v2, v3);\\n                    }\\n                }\\n\\n                break;\\n\\n            case 'logScale':\\n            case 'log-scale':\\n\\n                if (!Array.isArray(functionValue) || functionValue.length < 2) {\\n                    functionError = true;\\n                } else {\\n\\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\\n                    v3 = 0, v4 = 100;\\n\\n                    if (functionValue.length > 2) {\\n                        v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);                        \\n\\n                        if (typeof v3 !== 'number') {\\n                            functionError = true;\\n                        }\\n                    }\\n\\n                    if (functionValue.length > 3) {\\n                        v4 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[3], depth + 1);                        \\n\\n                        if (typeof v4 !== 'number') {\\n                            functionError = true;\\n                        }\\n                    }\\n\\n                    if (functionError || typeof v1 !== 'number' || typeof v2 !== 'number') {\\n                        functionError = true;\\n                    } else {\\n                        var imax = v4, imin = v3, smax = v2, s = v1, p, i;\\n\\n                        if (s > smax) s = smax; \\n\\n                        p = (imax - imin) / Math.log(smax + 1);\\n                        i = p * Math.log(s + 1) + imin;\\n\\n                        return i;\\n                    }\\n                }\\n\\n                break;\\n\\n\\n            case 'sgn':\\n            case 'sin':\\n            case 'cos':\\n            case 'tan':\\n            case 'asin':\\n            case 'acos':\\n            case 'atan':\\n            case 'sqrt':\\n            case 'abs':\\n            case 'log':\\n            case 'round':\\n            case 'floor':\\n            case 'ceil':\\n            case 'deg2rad':\\n            case 'rad2deg':\\n\\n                functionValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue, depth + 1);\\n\\n                if (typeof functionValue !== 'number') {\\n                    functionError = true;\\n                } else {\\n                    switch (functionName) {\\n                        case 'sgn':  return functionValue < 0 ? -1 : 1;\\n                        case 'sin':  return Math.sin(functionValue);\\n                        case 'cos':  return Math.cos(functionValue);\\n                        case 'tan':  return Math.tan(functionValue);\\n                        case 'asin': return Math.asin(functionValue);\\n                        case 'acos': return Math.acos(functionValue);\\n                        case 'atan': return Math.atan(functionValue);\\n                        case 'sqrt': return Math.sqrt(functionValue);\\n                        case 'abs':  return Math.abs(functionValue);\\n                        case 'log':  return Math.log(functionValue);\\n                        case 'round': return Math.round(functionValue);\\n                        case 'floor': return Math.floor(functionValue);\\n                        case 'ceil':  return Math.ceil(functionValue);\\n                        case 'deg2rad':  return (functionValue / 180) * Math.PI;\\n                        case 'rad2deg':  return (functionValue / Math.PI) * 180;\\n                    }\\n                }\\n\\n                break;\\n\\n            case 'strlen':\\n            case 'trim':\\n            case 'str2num':\\n            case 'lowercase':\\n            case 'uppercase':\\n            case 'capitalize':\\n            case 'has-fonts':\\n            case 'has-latin':\\n            case 'is-cjk':\\n                functionValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue, depth + 1);\\n\\n                if (typeof functionValue !== 'string') {\\n                    if (typeof functionValue === 'number') {\\n                        return functionValue;\\n                    } else {\\n                        functionError = true;\\n                    }\\n                } else {\\n                    switch (functionName) {\\n                        case 'strlen':     return functionValue.length;\\n                        case 'trim':       return functionValue.trim();\\n                        case 'str2num':    return parseFloat(functionValue);\\n                        case 'lowercase':  return functionValue.toLowerCase();\\n                        case 'uppercase':  return functionValue.toUpperCase();\\n                        case 'capitalize': return functionValue.replace(/(?:^|\\\\s)\\\\S/g, function(a) { return a.toUpperCase(); });\\n                        case 'has-fonts':  return areTextCharactersAvailable(functionValue);\\n                        case 'has-latin':  return hasLatin(functionValue);\\n                        case 'is-cjk':     return isCJK(functionValue); \\n                    }\\n                }\\n\\n                break;\\n\\n            case 'find':\\n            case 'replace':\\n            case 'substr':\\n\\n                if (Array.isArray(functionValue) && functionValue.length >= 2) {\\n\\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\\n\\n                    if (functionName == 'find' && typeof v1 === 'string' && typeof v2 === 'string') {\\n                        return v1.indexOf(v2);\\n                    }\\n\\n                    if (functionName == 'replace' && functionValue.length == 3) {\\n\\n                        v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\\n\\n                        if (typeof v1 === 'string' && typeof v2 === 'string' && typeof v3 === 'string') {\\n                            return v1.replace(v2,v3);\\n                        }\\n                    }\\n\\n                    if (functionName == 'substr') {\\n\\n                        if (functionValue.length == 2) {\\n                            if (typeof v1 === 'string' && typeof v2 === 'number') {\\n                                return v1.substr(v2);\\n                            }\\n                        } else {\\n                            v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\\n\\n                            if (typeof v1 === 'string' && typeof v2 === 'number' && typeof v3 === 'number') {\\n                                return v1.substr(v2,v3);\\n                            }\\n                        }\\n                    }\\n\\n                }\\n\\n                functionError = true;\\n                break;\\n\\n            case 'min':\\n            case 'max':\\n\\n                if (!Array.isArray(functionValue)) {\\n                    functionError = true;\\n                } else {\\n\\n                    finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n\\n                    for (i = index, li = functionValue.length; i < li; i++) {\\n                        tmpValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[i], depth + 1);\\n\\n                        if (typeof tmpValue !== 'number') {\\n                            functionError = true;\\n                            break;\\n                        }\\n\\n                        if (functionName == 'max') {\\n                            finalValue = Math.max(finalValue, tmpValue);\\n                        } else {\\n                            finalValue = Math.min(finalValue, tmpValue);\\n                        }\\n                    }\\n\\n                    return finalValue;\\n                }\\n\\n                break;\\n\\n            case 'map':\\n\\n                if (!Array.isArray(functionValue)) {\\n                    functionError = true;\\n                } else {\\n\\n                    finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n\\n                    var mapItems = functionValue[1];\\n\\n                    if (!Array.isArray(mapItems)) {\\n                        functionError = true;\\n                    } else {\\n\\n                        for (i = index, li = mapItems.length; i < li; i++) {\\n                            var item = mapItems[i];\\n\\n                            if (!Array.isArray(item)) {\\n                                functionError = true;\\n                                break;\\n                            } else {\\n\\n                                var itemValue = getLayerPropertyValueInner(layer, key, feature, lod, item[0], depth + 1);\\n\\n                                if (finalValue == itemValue) {\\n                                    return getLayerPropertyValueInner(layer, key, feature, lod, item[1], depth + 1);\\n                                }\\n                            }\\n                        }\\n                    }\\n\\n                    return getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\\n                }\\n\\n                break;\\n\\n            case 'linear':\\n            case 'linear2':\\n            case 'discrete':\\n            case 'discrete2':\\n            case 'lod-scaled':\\n\\n                //LOD based functions\\n                var stops = null;\\n                var lodScaledArray = null;\\n                var functionValue = lod;\\n\\n                if (value['lod-scaled'] != null) {\\n                    var array = value['lod-scaled'];\\n\\n                    if ((typeof array[1]) == 'number') {\\n                        return array[1] * Math.pow(2*array[2], array[0] - lod);\\n                    }\\n\\n                    stops = array[1];\\n                    lodScaledArray = array;\\n\\n                } if (value['discrete2'] != null || value['linear2'] != null) {\\n                    var array = value['discrete2'] || value['linear2'];\\n                    stops = array[1];\\n                    functionValue = getLayerPropertyValueInner(layer, key, feature, lod, array[0], depth + 1);\\n                } else {\\n                    stops = value['discrete'] || value['linear'];\\n                }\\n\\n                var lastLod = stops[0][0];\\n                var lastValue = stops[0][1];\\n                var valueType = (typeof lastValue);\\n                var newValue = lastValue;\\n\\n                var currentLod, currentValue;\\n\\n                for (var i = 0, li = stops.length; i <= li; i++) {\\n\\n                    if (i == li) {\\n                        newValue = lastValue;\\n                        break;\\n                    }\\n\\n                    if (stops[i][0] > functionValue) {\\n\\n                        if (value['discrete'] != null || value['discrete2'] != null || lodScaledArray != null) { //no interpolation\\n                            newValue = lastValue;\\n                            break;\\n                        } else { //interpolate\\n\\n                            currentLod = stops[i][0];\\n                            currentValue = stops[i][1];\\n\\n                            if (currentLod == lastLod) { //end of array no interpolation needed\\n                                break;\\n                            }\\n\\n                            switch(valueType) {\\n\\n                            case 'boolean':\\n                                lastValue = lastValue ? 1 : 0;\\n                                currentValue = lastValue ? 1 : 0;\\n                                newValue = lastValue + (currentValue - lastValue) * ((functionValue - lastLod) / (currentLod - lastLod));\\n\\n                                newValue = newValue > 0.5 ? true : false;\\n                                break;\\n\\n                            case 'number':\\n                                newValue = lastValue + (currentValue - lastValue) * ((functionValue - lastLod) / (currentLod - lastLod));\\n                                break;\\n\\n                            case 'object':\\n                                newValue = [];\\n\\n                                for (var j = 0, lj= lastValue.length; j < lj; j++) {\\n                                    newValue[j] = lastValue[j] + (currentValue[j] - lastValue[j]) * ((functionValue - lastLod) / (currentLod - lastLod));\\n                                }\\n\\n                                break;\\n                            }\\n\\n                            break;\\n                        }\\n                    }\\n\\n                    lastLod = stops[i][0];\\n                    lastValue = stops[i][1];\\n                }\\n\\n                if (lodScaledArray != null) {\\n                    newValue *= Math.pow(2*lodScaledArray[2], lodScaledArray[0] - functionValue);\\n                }\\n\\n                return newValue;\\n\\n            default: \\n                functionError = true;\\n                break;\\n        }\\n\\n        if (functionError) {\\n            if (root) {\\n                return getDefaultLayerPropertyValue(key);\\n            } else {\\n                return void(0);\\n            }\\n        }\\n\\n\\n    case 'number':\\n    case 'boolean':\\n        return value;\\n    }\\n\\n    if (root) {\\n        return getDefaultLayerPropertyValue(key);\\n    } else {\\n        return void(0);\\n    }\\n};\\n\\n\\nvar inheritLayer = function(layerId, layer, layerData, stylesheetLayersData, depth) {\\n    if (depth > 100) {\\n        logError('custom', 'infinite inherit loop in Layer: ' + layerId);\\n        return;\\n    }\\n\\n    //do we need inherite Layer?\\n    if (layerData['inherit'] != null) {\\n        //get inherited Layer\\n        var LayerToInherit = stylesheetLayersData['layers'][layerData['inherit']];\\n\\n        if (LayerToInherit != null) {\\n\\n            if (LayerToInherit['inherit'] != null) {\\n                inheritLayer(layerData['inherit'], layer, LayerToInherit, stylesheetLayersData, depth++);\\n            }\\n\\n            //copy inherited Layer properties\\n            for (var key in LayerToInherit) {\\n                layer[key] = LayerToInherit[key];\\n            }\\n        } else {\\n            logError('wrong-object', layerId, 'inherit', LayerToInherit, 'Layer');\\n            return getDefaultLayerPropertyValue(key);\\n        }\\n    }\\n};\\n\\n\\nvar copyLayer = function(layerId, layer, layerData, stylesheetLayersData) {\\n    //do we need inherite Layer?\\n    if (layerData['inherit'] != null) {\\n        inheritLayer(layerId, layer, layerData, stylesheetLayersData, 0);\\n    }\\n\\n    //copy Layer properties\\n    //if inherited properties are present then they will be overwriten\\n    for (var key in layerData) {\\n        layer[key] = layerData[key];\\n    }\\n\\n    //store layer id\\n    layer['$$layer-id'] = layerId;\\n};\\n\\n\\nvar logError = function(errorType, layerId, key, value, index, subkey) {\\n    if (globals.disableLog) {\\n        return;\\n    }\\n\\n    if ((typeof value) == 'object') {\\n        value = JSON.stringify(value);\\n    }\\n    \\n    var str = null;\\n\\n    switch(errorType) {\\n    case 'wrong-property-value':\\n        str = 'Error: wrong layer property ' + (subkey ? ('\\\\'' + subkey + '\\\\'') : '') + ': ' + layerId + '.' + key + ' = ' + value;\\n        break;\\n\\n    case 'wrong-property-value[]':\\n        str = 'Error: wrong layer property ' + (subkey ? ('\\\\'' + subkey + '\\\\'') : '') + '['+index+']: ' + layerId + '.' + key + ' = ' + value;\\n        break;\\n\\n    case 'wrong-object':\\n        str = 'Error: reffered '+ subkey + ' does not exist: ' + layerId + '.' + key + ' = ' + value;\\n        break;\\n\\n    case 'wrong-object[]':\\n        str = 'Error: reffered '+ subkey + ' does not exist: ' + layerId + '.' + key + '['+index+'] = ' + value;\\n        break;\\n\\n    case 'wrong-Layer':\\n        str = 'Error: reffered '+ subkey + ' Layer does not exist: ' + subkey + '['+index+'].Layer = ' + layerId;\\n        break;\\n\\n    case 'wrong-bitmap':\\n        str = 'Error: wrong definition of bitmap: ' + layerId;\\n        break;\\n\\n    case 'custom':\\n        str = 'Error: ' + layerId;\\n        break;\\n    }\\n    \\n    if (str && globals.log) {\\n         // eslint-disable-next-line \\n        console.log(str);\\n        //throw str;\\n    }\\n};\\n\\n\\nvar getUnitsNormalizedValue = function(value, screen, fallbackUnits) {\\n    if (typeof value === 'string') {\\n        if (value == '0' || value.length == 0) return 0;\\n\\n        value = value.trim();\\n\\n        if (value.length >= 2) {\\n\\n            var factor = 1, pf = globals.pixelsPerMM, ipf = globals.invPixelsPerMM;\\n\\n            switch(value.substr(-2, 2)) {\\n                case 'km': factor = screen ? pf * 1000 * 1000 : 1000; break;\\n                case 'cm': factor = screen ? pf * 10 : 1/100; break;\\n                case 'mm': factor = screen ? pf : 1/1000; break;\\n                case 'px': factor = screen ? 1 : ipf * 1/1000; break;\\n                case 'pc': factor = screen ? pf * 2.54 * 1/6 : ipf * 1/1000 * 2.54 * 1/6; break;\\n                case 'pt': factor = screen ? pf * 2.54 * 1/72 : ipf * 1/1000 * 2.54 * 1/72; break;\\n                case 'in': factor = screen ? pf * 2.54 : ipf * 1/1000 * 2.54; break;\\n\\n                default:\\n\\n                    if (value.charAt(value.length - 1) == 'm') {\\n                        return (screen ? pf * 1000 : 1) * parseFloat(value.substr(0, value.length - 1));\\n                    } else {\\n                        return parseFloat(value);\\n                    }\\n\\n            }\\n\\n            return factor * parseFloat(value.substr(0, value.length - 2));\\n\\n        } else {\\n\\n            //fallbackUnits\\n\\n            return parseFloat(value);\\n        }\\n\\n    } else if (typeof value === 'number') {\\n        return value;\\n    }\\n}\\n\\n\\nvar validateValue = function(layerId, key, value, type, arrayLength, min, max, hasUnits) {\\n    var i, li;\\n\\n    //check for object\\n    if (value != null && (typeof value) == 'object' && !Array.isArray(value)) {\\n        logError('wrong-property-value', layerId, key, value);\\n        return getDefaultLayerPropertyValue(key);\\n    }\\n\\n    //check value type\\n    if ((typeof value) != type) {\\n        //check for exceptions\\n        if (!(value === null && (key == 'icon-source' || key == 'visibility' || key == 'label-no-overlap-factor'))) {\\n            logError('wrong-property-value', layerId, key, value);\\n            return getDefaultLayerPropertyValue(key);\\n        }\\n    }\\n\\n    //check value\\n    switch(typeof value) {\\n\\n    case 'object':\\n\\n        //accepted cases for null value\\n        if (value === null && (key == 'line-style-texture' || key == 'icon-source' || 'dynamic-reduce' || 'reduce' ||\\n            key == 'hysteresis' || key == 'visibility' || key == 'visibility-abs' || key == 'visibility-rel' || key == 'next-pass')) {\\n            return value;\\n        }\\n\\n        //check reduce\\n        if (key == 'reduce' || key == 'dynamic-reduce' || key == 'label-no-overlap-factor' || key == 'line-points') {\\n            if (Array.isArray(value) && value.length > 0 && (typeof value[0] === 'string')) {\\n\\n                if (key == 'line-points') {\\n\\n                    if (!(value[0] == 'vertices' || value[0] == 'by-length' || value[0] == 'by-ratio' || value[0] == 'endpoints' ||\\n                          value[0] == 'start' || value[0] == 'end' || value[0] == 'middle' || value[0] == 'midpoint')) {\\n                        logError('wrong-property-value', layerId, key, value);\\n                        return getDefaultLayerPropertyValue(key);\\n                    } \\n\\n                } else if (key == 'dynamic-reduce') {\\n                    if (value[0] == 'by-extenal-param') {\\n                        value[0] = globals.reduceMode;\\n                    }\\n\\n                    if (!((value[0] == 'tilt' || value[0] == 'tilt-cos' || value[0] == 'tilt-cos2' || value[0] == 'scr-count' || value[0] == 'scr-count2' ||\\n                           value[0] == 'scr-count3' || value[0] == 'scr-count4' || value[0] == 'scr-count5' || value[0] == 'scr-count6' || value[0] == 'scr-count7' || value[0] == 'scr-count8') &&\\n                        (typeof value[1] === 'number') && ((typeof value[2] === 'number') || value[0] == 'scr-count4' || value[0] == 'scr-count5' || value[0] == 'scr-count6' || value[0] == 'scr-count7' || value[0] == 'scr-count8'))) {\\n                        logError('wrong-property-value', layerId, key, value);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n                } else if (key == 'reduce') {\\n                    if (value[0] != 'odd' && value != 'even') {\\n                        if ((typeof value[1] !== 'number') || ((value[0] != 'top' || value != 'bottom') && (typeof value[2] !== 'string'))) {\\n                            logError('wrong-property-value', layerId, key, value);\\n                            return getDefaultLayerPropertyValue(key);\\n                        }\\n                    }\\n                } else if (key == 'label-no-overlap-factor') {\\n                    if (!(value[0] == 'direct' || value[0] == 'div-by-dist')) {\\n                        logError('wrong-property-value', layerId, key, value);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n                }\\n\\n            } else {\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        //check multipasss\\n        if (key == 'next-pass' || key == 'visibility-switch') {\\n            var vswitch = (key == 'visibility-switch');\\n            if (Array.isArray(value) && value.length > 0) {\\n\\n                for (i = 0; i < li; i++) {\\n                    var valueItem = value[i];\\n\\n                    if (!(typeof valueItem == 'object' &&\\n                            Array.isArray(valueItem) &&\\n                            valueItem.length == 2 &&\\n                            typeof valueItem[0] == 'number' &&\\n                            (typeof valueItem[1] == 'string' || (vswitch && valueItem[1] === null)))) {\\n\\n                        logError('wrong-property-value[]', layerId, key, value, i);\\n                        return getDefaultLayerPropertyValue(key);\\n                    } else {\\n                        //fast constant \\n                        if (typeof valueItem[1] == 'string' && valueItem[1].charAt(0) == '@') {\\n                            if (typeof globals.stylesheetConstants[valueItem[1]] == 'undefined') {\\n                                logError('wrong-property-value[]', layerId, key, value, i);\\n                                return getDefaultLayerPropertyValue(key);\\n                            } else {\\n                                valueItem[1] = globals.stylesheetConstants[valueItem[1]];\\n                            }\\n                        }\\n                    }\\n                }\\n\\n            } else {\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        if (key == 'label-font' || key == 'line-label-font') {\\n\\n            if (!Array.isArray(value) || value.length < 1) {\\n                logError('wrong-property-value[]', layerId, key, value, 0);\\n                return getDefaultLayerPropertyValue(key);\\n            } else {\\n                for (i = 0, li = value.length; i < li; i++) {\\n                    if (typeof value[i] != 'string' || !globals.fonts[value[i]]) {\\n                        logError('wrong-property-value[]', layerId, key, value, 0);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n                }\\n            }\\n\\n            return value;\\n        }\\n\\n        //check array\\n        if (arrayLength != null) {\\n            if (Array.isArray(value) && (value.length == arrayLength || ((key == 'icon-stick' || 'label-stick') && value.length >= 7) )) {\\n\\n                //validate array values\\n                i = 0;\\n\\n                if (key == 'icon-source' || key == 'line-style-texture') {\\n                    if (typeof value[0] != 'string') {\\n                        logError('wrong-property-value[]', layerId, key, value, 0);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n\\n                    if (globals.stylesheetBitmaps[value[0]] == null) {\\n                        logError('wrong-object', layerId, key, value, null, 'bitmap');\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n\\n                    i = 1;\\n                }\\n\\n                for (li = value.length; i < li; i++) {\\n                    if (typeof value[i] != 'number') {\\n                        logError('wrong-property-value[]', layerId, key, value, i);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n                }\\n\\n                if ((key == 'icon-stick' || 'label-stick') && value.length == 7) {\\n                    value[7] = 0;\\n                }\\n\\n                return value;\\n            } else {\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        return value;\\n\\n    case 'string':\\n\\n        if (key == 'line-type' || key == 'point-type') {\\n            switch(value) {\\n            case 'screen':\\n            case 'flat':\\n            case 'screen-flat': return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        if (key == 'line-label-type') {\\n            switch(value) {\\n            case 'flat':\\n            case 'screen-flat': return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        //validate line Layer enum\\n        if (key == 'line-style') {\\n            switch(value) {\\n            case 'solid':\\n            case 'texture': return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        if (key == 'label-size-units') {\\n            switch(value) {\\n            case 'pixels':\\n            case 'points': return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        if (key == 'line-width-units') {\\n            switch(value) {\\n            case 'pixels':\\n            case 'points':\\n            case 'meters':\\n            case 'ratio': return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        //validate origin enum\\n        if (key == 'label-origin' || key == 'icon-origin') {\\n            switch(value) {\\n            case 'top-left':\\n            case 'top-right':\\n            case 'top-center':\\n            case 'center-left':\\n            case 'center-right':\\n            case 'center-center':\\n            case 'bottom-left':\\n            case 'bottom-right':\\n            case 'bottom-center':   return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        //validate align enum\\n        if (key == 'label-align') {\\n            switch(value) {\\n            case 'left':\\n            case 'right':\\n            case 'center':  return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        return value;\\n\\n    case 'number':\\n\\n        if (value > max || value < min) {\\n            logError('wrong-property-value', layerId, key, value);\\n            return getDefaultLayerPropertyValue(key);\\n        }\\n\\n        return value;\\n\\n    case 'boolean':\\n        return value;\\n    }\\n};\\n\\n\\nvar validateLayerPropertyValue = function(layerId, key, value) {\\n\\n    switch(key) {\\n\\n    case 'inherit' :        return validateValue(layerId, key, value, 'string');\\n    case 'reduce':          return validateValue(layerId, key, value, 'object');\\n    case 'dynamic-reduce':  return validateValue(layerId, key, value, 'object');\\n    case 'line-points':     return validateValue(layerId, key, value, 'object');\\n\\n    case 'line':              return validateValue(layerId, key, value, 'boolean');\\n    case 'line-type':         return validateValue(layerId, key, value, 'string');\\n    case 'line-flat':         return validateValue(layerId, key, value, 'boolean');\\n    case 'line-width':        return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'line-width-units':  return validateValue(layerId, key, value, 'string');\\n    case 'line-color':        return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'line-style':        return validateValue(layerId, key, value, 'string');\\n    case 'line-style-texture':    return validateValue(layerId, key, value, 'object', 3, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'line-style-background': return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n\\n    case 'line-label':         return validateValue(layerId, key, value, 'boolean');\\n    case 'line-label-type':    return validateValue(layerId, key, value, 'string');\\n    case 'line-label-source':  return validateValue(layerId, key, value, 'string');\\n    case 'line-label-color':   return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'line-label-color2':  return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'line-label-size':    return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE, true);\\n    case 'line-label-offset':  return validateValue(layerId, key, value, 'number', null, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'line-label-spacing': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'line-label-line-height': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'line-label-no-overlap':  return validateValue(layerId, key, value, 'boolean');\\n    case 'line-label-no-overlap-factor': return validateValue(layerId, key, value, 'object');\\n    case 'line-label-no-overlap-margin': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n\\n    case 'point':        return validateValue(layerId, key, value, 'boolean');\\n    case 'point-type':   return validateValue(layerId, key, value, 'string');\\n    case 'point-flat':   return validateValue(layerId, key, value, 'boolean');\\n    case 'point-radius': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'point-Layer':  return validateValue(layerId, key, value, 'string');\\n\\n    case 'point-color':  return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n\\n    case 'icon':             return validateValue(layerId, key, value, 'boolean');\\n    case 'icon-source':      return validateValue(layerId, key, value, 'object', 5, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'icon-scale':       return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'icon-offset':      return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'icon-origin':      return validateValue(layerId, key, value, 'string');\\n    case 'icon-stick':       return validateValue(layerId, key, value, 'object', 8, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'icon-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'icon-no-overlap':  return validateValue(layerId, key, value, 'boolean');\\n    case 'icon-no-overlap-factor': return validateValue(layerId, key, value, 'object');\\n    case 'icon-no-overlap-margin': return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\\n\\n    case 'label':             return validateValue(layerId, key, value, 'boolean');\\n    case 'label-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'label-color2':      return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'label-source':      return validateValue(layerId, key, value, 'string');\\n    case 'label-size':        return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'label-size-units':  return validateValue(layerId, key, value, 'string');\\n    case 'label-spacing':     return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'label-line-height': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'label-offset':      return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'label-origin':      return validateValue(layerId, key, value, 'string');\\n    case 'label-align':       return validateValue(layerId, key, value, 'string');\\n    case 'label-stick':       return validateValue(layerId, key, value, 'object', 8, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'label-width':       return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'label-no-overlap':  return validateValue(layerId, key, value, 'boolean');\\n    case 'label-no-overlap-factor': return validateValue(layerId, key, value, 'object');\\n    case 'label-no-overlap-margin': return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\\n\\n    case 'polygon':             return validateValue(layerId, key, value, 'boolean');\\n    case 'polygon-style':       return validateValue(layerId, key, value, 'string');\\n    case 'polygon-use-stencil': return validateValue(layerId, key, value, 'boolean');\\n    case 'polygon-culling':     return validateValue(layerId, key, value, 'string');\\n    case 'polygon-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'polygon-extrude':     return validateValue(layerId, key, value, 'number', 0, -Number.MAX_VALUE, Number.MAX_VALUE);\\n\\n    case 'z-index':        return validateValue(layerId, key, value, 'number', null, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'zbuffer-offset': return validateValue(layerId, key, value, 'object', 3, 0, Number.MAX_VALUE);\\n\\n    case 'selected-hover-layer':  return validateValue(layerId, key, value, 'string');\\n    case 'selected-layer':  return validateValue(layerId, key, value, 'string');\\n    case 'hover-event':     return validateValue(layerId, key, value, 'boolean');\\n    case 'hover-layer':     return validateValue(layerId, key, value, 'string');\\n    case 'enter-event':     return validateValue(layerId, key, value, 'boolean');\\n    case 'leave-event':     return validateValue(layerId, key, value, 'boolean');\\n    case 'click-event':     return validateValue(layerId, key, value, 'boolean');\\n    case 'draw-event':      return validateValue(layerId, key, value, 'boolean');\\n    case 'advanced-hit':    return validateValue(layerId, key, value, 'boolean');\\n    case 'export-geometry': return validateValue(layerId, key, value, 'boolean');\\n    case 'pack':            return validateValue(layerId, key, value, 'boolean');\\n\\n    case 'visible':           return validateValue(layerId, key, value, 'boolean');\\n    case 'visibility':        return validateValue(layerId, key, value, 'number', null, 0.00001, Number.MAX_VALUE);\\n    case 'visibility-abs':    return validateValue(layerId, key, value, 'object', 2, 0.00001, Number.MAX_VALUE);\\n    case 'visibility-rel':    return validateValue(layerId, key, value, 'object', 4, 0.00001, Number.MAX_VALUE);\\n    case 'visibility-switch': return validateValue(layerId, key, value, 'object');\\n\\n    case 'hysteresis':  return validateValue(layerId, key, value, 'object');\\n    case 'culling':     return validateValue(layerId, key, value, 'number', 180, 0.0001, 180);\\n    case 'next-pass':   return validateValue(layerId, key, value, 'object');\\n\\n    case 'importance-source':  return validateValue(layerId, key, value, 'string');\\n    case 'importance-weight':  return validateValue(layerId, key, value, 'number', null, 0, Number.MAX_VALUE);\\n\\n    }\\n\\n    return value; //custom property\\n};\\n\\n\\nvar getDefaultLayerPropertyValue = function(key) {\\n    switch(key) {\\n    case 'inherit':          return '';\\n    case 'filter':           return null;\\n    case 'reduce':           return null;\\n    case 'dynamic-reduce':   return null;\\n    case 'line-points':      return ['vertices',0,0];\\n\\n    case 'line':             return false;\\n    case 'line-type':        return 'screen';\\n    case 'line-flat':        return false;\\n    case 'line-width':       return 1;\\n    case 'line-width-units': return 'meters';\\n    case 'line-color':       return [255,255,255,255];\\n    case 'line-style':       return 'solid';\\n    case 'line-style-texture':    return null;\\n    case 'line-style-background': return [0,0,0,0];\\n\\n    case 'line-label':         return false;\\n    case 'line-label-type':    return 'flat'; //'screen-flat';\\n    case 'line-label-font':    return ['#default'];\\n    case 'line-label-color':   return [255,255,255,255];\\n    case 'line-label-color2':  return [0,0,0,255];\\n    case 'line-label-outline': return [0.27,0.75,2.2,2.2];\\n    case 'line-label-source':  return '$name';\\n    case 'line-label-size':    return 1;\\n    case 'line-label-offset':  return 0;\\n    case 'line-label-spacing': return 1;\\n    case 'line-label-line-height': return 1;\\n    case 'line-label-no-overlap':  return true;\\n    case 'line-label-no-overlap-factor': return null;\\n    case 'line-label-no-overlap-margin': return 1.1;\\n\\n    case 'point':        return false;\\n    case 'point-type':   return 'screen';\\n    case 'point-flat':   return false;\\n    case 'point-radius': return 1;\\n    case 'point-Layer':  return 'solid';\\n    case 'point-color':  return [255,255,255,255];\\n\\n    case 'icon':         return false;\\n    case 'icon-source':  return null;\\n    case 'icon-scale':   return 1;\\n    case 'icon-offset':  return [0,0];\\n    case 'icon-origin':  return 'bottom-center';\\n    case 'icon-stick':   return [0,0,0,255,255,255,255,0];\\n    case 'icon-color':   return [255,255,255,255];\\n    case 'icon-no-overlap':  return false;\\n    case 'icon-no-overlap-factor': return null;\\n    case 'icon-no-overlap-margin': return [5,5];\\n\\n    case 'label':             return false;\\n    case 'label-font':        return ['#default'];\\n    case 'label-color':       return [255,255,255,255];\\n    case 'label-color2':      return [0,0,0,255];\\n    case 'label-outline':     return [0.27,0.75,2.2,2.2];\\n    case 'label-source':      return '$name';\\n    case 'label-size':        return 10;\\n    case 'label-size-units':  return 'pixels';\\n    case 'label-spacing':     return 1;\\n    case 'label-line-height': return 1;\\n    case 'label-offset':      return [0,0];\\n    case 'label-origin':      return 'bottom-center';\\n    case 'label-align':       return 'center';\\n    case 'label-stick':       return [0,0,0,255,255,255,255,0];\\n    case 'label-width':       return 200;\\n    case 'label-no-overlap':  return true;\\n    case 'label-no-overlap-factor': return null;\\n    case 'label-no-overlap-margin': return [5,5];\\n       \\n    case 'polygon':             return false;\\n    case 'polygon-style':       return 'solid';\\n    case 'polygon-use-stencil': return true;\\n    case 'polygon-culling':     return 'none';\\n    case 'polygon-color':       return [255,255,255,255];\\n    case 'polygon-extrude':     return 0;\\n\\n    case 'z-index':        return 0;\\n    case 'zbuffer-offset': return [0,0,0];\\n\\n    case 'selected-hover-layer':  return '';\\n    case 'selected-layer':  return '';\\n    case 'hover-event':     return false;\\n    case 'hover-layer':     return '';\\n    case 'enter-event':     return false;\\n    case 'leave-event':     return false;\\n    case 'click-event':     return false;\\n    case 'draw-event':      return false;\\n    case 'advanced-hit':    return false;\\n    case 'export-geometry': return false;\\n    case 'pack':            return false;\\n\\n    case 'visible':           return true;\\n    case 'visibility':        return null;\\n    case 'visibility-abs':    return null;\\n    case 'visibility-rel':    return null;\\n    case 'visibility-switch': return null;\\n\\n    case 'hysteresis':      return null;\\n    case 'culling':         return 180;\\n    case 'next-pass':       return null;\\n\\n    case 'importance-source':  return null; //''\\n    case 'importance-weight':  return 1;\\n    }\\n};\\n\\n\\nfunction getFilterResult(filter, feature, featureType, group, layer, key, lod, depth, fast) {\\n    var result, i, li;\\n\\n    if (!filter || !Array.isArray(filter)) {\\n        return false;\\n    }\\n\\n    if (depth > 100) {\\n        return false;\\n    }\\n\\n    switch(filter[0]) {\\n        case 'all': \\n            for (i = 1, li = filter.length; i < li; i++) {\\n                result = getFilterResult(filter[i], feature, featureType, group, layer, key, lod, depth + 1, fast);\\n\\n                if (!result) {\\n                    return false;\\n                }\\n            }\\n               \\n            return true;                         \\n\\n        case 'any':\\n            for (i = 1, li = filter.length; i < li; i++) {\\n                result = getFilterResult(filter[i], feature, featureType, group, key, lod, depth + 1, fast);\\n\\n                if (result) {\\n                    return true;\\n                }\\n            }\\n               \\n            return false;                         \\n\\n        case 'none':\\n            for (i = 1, li = filter.length; i < li; i++) {\\n                result = getFilterResult(filter[i], feature, featureType, group, key, lod, depth + 1, fast);\\n\\n                if (result) {\\n                    return false;\\n                }\\n            }\\n               \\n            return true;\\n                              \\n        case 'skip': return false; \\n    }\\n\\n    var value, value2;\\n\\n    if (fast && filter[2]) {\\n        value = filter[1];\\n    } else {\\n        globals.disableLog = (filter[0] == 'has' || filter[0] == '!has');\\n        value = getLayerPropertyValueInner(layer, key, feature, lod, filter[1], 0);\\n        globals.disableLog = false;\\n    }\\n\\n    switch(filter[0]) {\\n    case '==':\\n    case '!=':\\n    case '>=':\\n    case '<=':\\n    case '>':\\n    case '<':\\n        value2 = filter[fast ? 3 : 2];\\n\\n        if (typeof value2 == 'undefined') {\\n            return false;\\n        }\\n\\n        if (!(fast && filter[4])) {\\n            value2 = getLayerPropertyValueInner(layer, key, feature, lod, value2, 0);\\n        }\\n\\n        break;\\n    }\\n\\n    switch(filter[0]) {\\n    case '==': return (value == value2);\\n    case '!=': return (value != value2);\\n    case '>=': return (value >= value2);\\n    case '<=': return (value <= value2);\\n    case '>': return (value > value2);\\n    case '<': return (value < value2);\\n        \\n    case 'has': return (typeof value != 'undefined');\\n    case '!has': return (typeof value == 'undefined');\\n        \\n    case 'in':\\n        for (i = fast ? 3 : 2, li = filter.length; i < li; i++) {\\n            if (filter[i] == value) {\\n                return true;\\n            }\\n        } \\n        return false;\\n        \\n    case '!in':\\n        for (i = fast ? 3 : 2, li = filter.length; i < li; i++) {\\n            if (filter[i] == value) {\\n                return false;\\n            }\\n        } \\n        return true;\\n    }            \\n\\n    return false;    \\n}\\n\\n\\nfunction isSimpleValue(value) {\\n    switch(typeof value) {\\n        case 'number':  return true;\\n        case 'string': \\n            \\n            if (value.length > 0) {\\n                switch(value.charAt(0)) {\\n                    case '#': \\n                    case '$':\\n                    case '@':\\n                    case '&':\\n                        break;\\n                    \\n                    default: \\n\\n                        if (value.indexOf('{') == -1) {\\n                            return true;\\n                        }\\n\\n                        break;\\n                }\\n            } else {\\n                return true;\\n            }\\n\\n            break;\\n    }\\n\\n    return false;\\n}\\n\\n\\nfunction makeFasterFilter(filter) {\\n    if (!filter || !Array.isArray(filter)) {\\n        return filter;\\n    }\\n\\n    var i, li, value, simple, result = [filter[0]];\\n\\n    switch(filter[0]) {\\n    case 'all': \\n    case 'any':\\n    case 'none':\\n    case 'skip':\\n        for (i = 1, li = filter.length; i < li; i++) {\\n            result[i] = makeFasterFilter(filter[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    result[1] = filter[1];\\n    result[2] = isSimpleValue(filter[1]);\\n\\n    switch(filter[0]) {\\n    case '==':\\n    case '!=':\\n    case '>=':\\n    case '<=':\\n    case '>':\\n    case '<':\\n        result[3] = filter[2];\\n        result[4] = isSimpleValue(filter[2]);\\n        break;\\n\\n    case 'in':\\n    case '!in':\\n\\n        for (i = 2, li = filter.length; i < li; i++) {\\n            result[i+1] = filter[i];\\n        } \\n\\n    }\\n\\n    return result;\\n}\\n\\nvar processLayer = function(layerId, layerData, stylesheetLayersData) {\\n    var layer = {}, key, value;\\n\\n    //copy Layer and inherit Layer if needed\\n    copyLayer(layerId, layer, layerData, stylesheetLayersData);\\n\\n    //replace constants and validate properties\\n    for (key in layer) {\\n\\n        value = layer[key];\\n\\n        //replace constant with value\\n        if ((typeof value) == 'string') {\\n            if (value.length > 0) {\\n                //is it constant?\\n                switch(value.charAt(0)) {\\n                    case '@':\\n                        if (globals.stylesheetConstants[value] != null) {\\n                            //replace constant with value\\n                            layer[key] = globals.stylesheetConstants[value];\\n                        } else {\\n                            logError('wrong-object', layerId, key, value, null, 'constant');\\n\\n                            //replace constant with deafault value\\n                            layer[key] = getDefaultLayerPropertyValue(key);\\n                        }\\n                        break;\\n\\n                    case '%':  // reserved for variators\\n\\n                        if (globals.stylesheetLocals[value] != null) {\\n                            if (!layer['$$layer-variables']) {\\n                                layer['$$layer-variables'] = {};\\n                            }\\n\\n                            layer['$$layer-variables'][key] = value;\\n\\n                            //replace variable with value\\n                            layer[key] = globals.stylesheetLocals[value];\\n\\n                        } else {\\n                            logError('wrong-object', layerId, key, value, null, 'variable');\\n\\n                            //replace constant with deafault value\\n                            layer[key] = getDefaultLayerPropertyValue(key);\\n                        }\\n                        break;\\n                }\\n            }\\n        }\\n\\n        //copy constats to vswitch\\n        if (key == 'visibility-switch') {\\n            if (Array.isArray(value) && value.length > 0) {\\n                for (var i = 0, li = value.length; i < li; i++) {\\n                    var valueItem = value[i];\\n                    var wrong = false;\\n\\n                    if (!(typeof valueItem == 'object' && Array.isArray(valueItem) && valueItem.length == 2)) {\\n                        wrong = true;\\n                    } else {\\n                        if (typeof valueItem[0] == 'string' && valueItem[0].charAt(0) == '@') {\\n                            if (typeof globals.stylesheetConstants[valueItem[0]] == 'undefined') {\\n                                wrong = true;\\n                            } else {\\n                                valueItem[0] = globals.stylesheetConstants[valueItem[0]];\\n                            }\\n                        }\\n\\n                        if (!(typeof valueItem[0] == 'number' && (typeof valueItem[1] == 'string' || valueItem[1] === null))) {\\n                            wrong = true;\\n                        }\\n                    }\\n\\n                    if (wrong) {\\n                        logError('wrong-property-value[]', layerId, key, value, i);\\n                    }\\n                }\\n\\n            } else {\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n    }\\n\\n    return layer;\\n};\\n\\n\\nvar processStylesheet = function(stylesheetLayersData) {\\n    var key;\\n    globals.stylesheetBitmaps = {};\\n    globals.stylesheetFonts = {};\\n    globals.stylesheetConstants = stylesheetLayersData['constants'] || {};\\n    globals.stylesheetVariables = stylesheetLayersData['variables'] || {};\\n    globals.stylesheetLocals = {};\\n\\n    //get bitmaps\\n    var bitmaps = stylesheetLayersData['bitmaps'] || {};\\n\\n    //build map\\n    for (key in bitmaps) {\\n        var bitmap = bitmaps[key];\\n        //var skip = false;\\n\\n        if ((typeof bitmap) == 'string') {\\n            bitmap = {'url':bitmap, 'hash': getHash(bitmap) };\\n        } else if((typeof bitmap) == 'object'){\\n            if (bitmap['url'] == null) {\\n                bitmap['hash'] = 'null';\\n                logError('wrong-bitmap', key);\\n            } else {\\n                bitmap['hash'] = getHash(bitmap['url']);\\n            }\\n        } else {\\n            logError('wrong-bitmap', key);\\n        }\\n\\n        globals.stylesheetBitmaps[key] = bitmap;\\n    }\\n\\n    //load bitmaps\\n    postMessage({'command':'loadBitmaps', 'bitmaps': globals.stylesheetBitmaps});\\n\\n    //remove urls\\n    bitmaps = globals.stylesheetBitmaps;\\n\\n    for (key in bitmaps) {\\n        bitmap = bitmaps[key];\\n        bitmap['url'] = null;\\n    }\\n\\n    //get fonts\\n    var fonts = stylesheetLayersData['fonts'] || {};\\n\\n    //build map\\n    for (key in fonts) {\\n        var font = fonts[key];\\n\\n        if ((typeof font) == 'string') {\\n            font = {'url':font};\\n        } else if((typeof font) == 'object'){\\n            if (font['url'] == null) {\\n                logError('wrong-font', key);\\n            }\\n        } else {\\n            logError('wrong-font', key);\\n        }\\n\\n        globals.stylesheetFonts[key] = font;\\n    }\\n\\n    //load fonts\\n    postMessage({'command':'loadFonts', 'fonts': globals.stylesheetFonts});\\n\\n\\n    //get layers\\n    globals.stylesheetData = {\\n        layers : {}\\n    };\\n\\n    var layers = stylesheetLayersData['layers'] || {};\\n\\n    globals.stylesheetLayers = globals.stylesheetData.layers;\\n\\n    //process layers\\n    for (key in layers) {\\n        globals.stylesheetData.layers[key] = processLayer(key, layers[key], stylesheetLayersData);\\n    }\\n};\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/geodata-processor/worker-text.js\\\":\\n/*!*******************************************************!*\\\\\\n  !*** ./src/core/map/geodata-processor/worker-text.js ***!\\n  \\\\*******************************************************/\\n/*! exports provided: addStreetTextOnPath, getTextLength, getLineHeight, getFontFactor, getSplitIndex, areTextCharactersAvailable, addText, addTextOnPath, setFont, setFontMap, getCharVerticesCount, getFonts, getFontsStorage, hasLatin, isCJK, getTextGlyphs */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"addStreetTextOnPath\\\", function() { return addStreetTextOnPath; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getTextLength\\\", function() { return getTextLength; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getLineHeight\\\", function() { return getLineHeight; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getFontFactor\\\", function() { return getFontFactor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getSplitIndex\\\", function() { return getSplitIndex; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"areTextCharactersAvailable\\\", function() { return areTextCharactersAvailable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"addText\\\", function() { return addText; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"addTextOnPath\\\", function() { return addTextOnPath; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"setFont\\\", function() { return setFont; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"setFontMap\\\", function() { return setFontMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getCharVerticesCount\\\", function() { return getCharVerticesCount; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getFonts\\\", function() { return getFonts; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getFontsStorage\\\", function() { return getFontsStorage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"hasLatin\\\", function() { return hasLatin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"isCJK\\\", function() { return isCJK; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getTextGlyphs\\\", function() { return getTextGlyphs; });\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/geodata-processor/worker-globals.js\\\");\\n/* harmony import */ var _worker_font_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-font.js */ \\\"./src/core/map/geodata-processor/worker-font.js\\\");\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"],\\n    vec3Normalize = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"vec3Normalize\\\"], vec3Length = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"vec3Length\\\"],\\n    vec3Cross = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"vec3Cross\\\"],\\n    Typr = _worker_font_js__WEBPACK_IMPORTED_MODULE_1__[\\\"Typr\\\"];\\n\\n\\nvar setFont = function(fontData) {\\n    //console.log('setFont ' + fontData['url']);\\n    //debugger;\\n\\n    var font = Typr.parse(fontData['data']);\\n\\n    globals.fontsStorage[fontData['url']] = font;\\n};\\n\\n\\nvar setFontMap = function(fontMap) {\\n    var fonts = fontMap['map'];\\n    for (var key in fonts) {\\n        globals.fonts[key] = globals.fontsStorage[fonts[key]];\\n    }\\n\\n    globals.fontsMap = fonts;\\n};\\n\\n\\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\\n\\nvar mat3toQuad2 = function(m) {  //TODO: use m as one dimensional vector\\n\\n    var tr = m[0][0] + m[1][1] + m[2][2], qx,qy,qz,qw,s;\\n\\n    if (tr > 0) { \\n      s = Math.sqrt(tr+1.0) * 2; // S=4*qw \\n      qw = 0.25 * s;\\n      qx = (m[2][1] - m[1][2]) / s;\\n      qy = (m[0][2] - m[2][0]) / s; \\n      qz = (m[1][0] - m[0][1]) / s; \\n    } else if ((m[0][0] > m[1][1])&(m[0][0] > m[2][2])) { \\n      s = Math.sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2; // S=4*qx \\n      qw = (m[2][1] - m[1][2]) / s;\\n      qx = 0.25 * s;\\n      qy = (m[0][1] + m[1][0]) / s; \\n      qz = (m[0][2] + m[2][0]) / s; \\n    } else if (m[1][1] > m[2][2]) { \\n      s = Math.sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2; // S=4*qy\\n      qw = (m[0][2] - m[2][0]) / s;\\n      qx = (m[0][1] + m[1][0]) / s; \\n      qy = 0.25 * s;\\n      qz = (m[1][2] + m[2][1]) / s; \\n    } else { \\n      s = Math.sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2; // S=4*qz\\n      qw = (m[1][0] - m[0][1]) / s;\\n      qx = (m[0][2] + m[2][0]) / s;\\n      qy = (m[1][2] + m[2][1]) / s;\\n      qz = 0.25 * s;\\n    }\\n\\n    return [qx,qy,qz,qw];\\n}\\n\\n\\nvar addChar = function(pos, dir, verticalShift, char, factor, spacing, index, index2, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, fontIndex, singleBuffer) {\\n    var n, font = fonts[fontIndex];\\n    var up = [0,0,0];\\n\\n    if (globals.geocent && !flat) {\\n        n = [0,0,0];\\n        vec3Normalize(globals.bboxMin, up);\\n        vec3Cross(up, dir, n);\\n    } else {\\n        n = [-dir[1],dir[0],0];\\n    }\\n\\n    vec3Cross(dir, n, up);\\n\\n    var p1 = [pos[0], pos[1], pos[2]];\\n    var p2 = [p1[0], p1[1], p1[2]];\\n\\n    //var chars = font.chars;\\n    \\n    var fc = font.glyphs[char];\\n    char = 0; // hack\\n\\n    if (!fc) {\\n        return [pos, index, index2, 0];\\n    }\\n\\n    var l = 0;\\n    var nx = textVector[0];\\n    var ny = textVector[1];\\n    var nz = textVector[2];\\n\\n    if (char == 9 || char == 32) {  //tab or space\\n        fc = chars[32]; //space\\n\\n        if (fc) {\\n            pos[0] += dir[0] * (fc.step) * factor * spacing;\\n            pos[1] += dir[1] * (fc.step) * factor * spacing;\\n            l = fc.lx * factor;\\n        }\\n    } else {\\n        if (fc.lx == 0) {\\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\\n            l = fc.lx * factor;\\n        } else {\\n            var planeShift = fontIndex * 4000;\\n            var plane = fc.plane + planeShift;\\n\\n            if (planes) {\\n                if (!planes[fontIndex]) {\\n                    planes[fontIndex] = {};\\n                }\\n                \\n                planes[fontIndex][plane] = true;\\n            }\\n\\n            var factorX = fc.lx * factor;\\n            var factorY = fc.ly * factor;\\n\\n            if (singleBuffer) {\\n\\n                if (globals.processLineLabel && globals.useLineLabel2) {\\n\\n                    p1[0] = p1[0] + dir[0] * fc.sx * factor;\\n                    p1[1] = p1[1] + dir[1] * fc.sx * factor;\\n                    p1[2] = p1[2] + dir[2] * fc.sx * factor;\\n                    p1[0] = p1[0] + n[0] * (fc.sy - font.size) * factor;\\n                    p1[1] = p1[1] + n[1] * (fc.sy - font.size) * factor;\\n                    p1[2] = p1[2] + n[2] * (fc.sy - font.size) * factor;\\n\\n                    var n2 = [n[0] * verticalShift, n[1] * verticalShift, n[2] * verticalShift];\\n                    var n3 = [n2[0] + n[0] * factorY, n2[1] + n[1] * factorY, n2[2] + n[2] * factorY];\\n\\n                    singleBuffer[index] = p1[0] - n2[0];\\n                    singleBuffer[index+1] = p1[1] - n2[1];\\n                    singleBuffer[index+2] = p1[2] - n2[2];\\n\\n                    \\n                    var m = [ [dir[0], dir[1], dir[2]], \\n                              [n[0], n[1], n[2]], \\n                              [up[0], up[1], up[2]] ];\\n\\n                    /*\\n                    var m = [ dir[0], dir[1], dir[2], \\n                              n[0], n[1], n[2], \\n                              up[0], up[1], up[2] ];*/\\n\\n                    var q = mat3toQuad2(m);\\n                    singleBuffer[index+3] = q[0];  //x\\n                    singleBuffer[index+4] = q[1];  //y\\n                    singleBuffer[index+5] = q[2];  //z\\n                    singleBuffer[index+6] = q[3];  //w\\n                   \\n                    if (!globals.lineLabelPass) {\\n                        singleBuffer[index+7] = factorX;\\n                        singleBuffer[index+8] = factorY;\\n                    }\\n\\n                    singleBuffer[index+9] = fc.u1;\\n                    singleBuffer[index+10] = fc.v1 + planeShift;\\n\\n                    var dtx = (fc.u2 - fc.u1) * 1024;\\n                    var dty = (fc.v2 - fc.v1);// * 1024;\\n\\n                    singleBuffer[index+11] = dtx + dty;  // u store in decimal part, v stored in fraction part\\n\\n                    var dx = dir[0]*0.5*factorX - n[0]*0.5*factorY - n2[0];\\n                    var dy = dir[1]*0.5*factorX - n[1]*0.5*factorY - n2[1];\\n                    var dz = dir[2]*0.5*factorX - n[2]*0.5*factorY - n2[2];\\n\\n                    //globals.lineLabelPoints.push([p1[0] + dx, p1[1] + dy, p1[2] + dz, Math.sqrt(factorX*factorX + factorY*factorY)*0.5]);\\n                    globals.lineLabelPoints.push([p1[0] + dx, p1[1] + dy, p1[2] + dz, Math.sqrt(factorX*factorX + factorY*factorY)*0.5, \\n                                                  singleBuffer[index], singleBuffer[index+1], singleBuffer[index+2],\\n                                                  singleBuffer[index+3], singleBuffer[index+4], singleBuffer[index+5], singleBuffer[index+6], factorX, factorY]);\\n\\n                    index += 12;\\n\\n                } else {\\n                    singleBuffer[index] = p1[0] + fc.sx * factor;\\n                    singleBuffer[index+1] = p1[1] + (fc.sy - font.size) * factor;\\n                    singleBuffer[index+2] = singleBuffer[index] + factorX;\\n                    singleBuffer[index+3] = singleBuffer[index+1] - factorY;\\n                    singleBuffer[index+4] = fc.u1;\\n                    singleBuffer[index+5] = fc.v1 + planeShift;\\n                    singleBuffer[index+6] = fc.u2;\\n                    singleBuffer[index+7] = fc.v2 + planeShift;\\n\\n                    index += 8;\\n                }\\n\\n            } else {\\n\\n                var n2 = [n[0] * verticalShift, n[1] * verticalShift, n[2] * verticalShift];\\n                var n3 = [n2[0] + n[0] * factorY, n2[1] + n[1] * factorY, n2[2] + n[2] * factorY];\\n                \\n                p1[0] = p1[0] + dir[0] * fc.sx * factor;\\n                p1[1] = p1[1] + dir[1] * fc.sx * factor;\\n                p1[2] = p1[2] + dir[2] * fc.sx * factor;\\n                p1[0] = p1[0] + n[0] * (fc.sy - font.size) * factor;\\n                p1[1] = p1[1] + n[1] * (fc.sy - font.size) * factor;\\n                p1[2] = p1[2] + n[2] * (fc.sy - font.size) * factor;\\n\\n                p2[0] = p1[0] + dir[0] * factorX;\\n                p2[1] = p1[1] + dir[1] * factorX;\\n                p2[2] = p1[2] + dir[2] * factorX;\\n\\n                //first polygon\\n                vertexBuffer[index] = p1[0] - n2[0];\\n                vertexBuffer[index+1] = p1[1] - n2[1];\\n                vertexBuffer[index+2] = p1[2] - n2[2];\\n                vertexBuffer[index+3] = nz;\\n\\n                texcoordsBuffer[index2] = fc.u1;\\n                texcoordsBuffer[index2+1] = fc.v1 +  planeShift;\\n                texcoordsBuffer[index2+2] = nx;\\n                texcoordsBuffer[index2+3] = ny;\\n\\n                vertexBuffer[index+4] = p1[0] - n3[0];\\n                vertexBuffer[index+5] = p1[1] - n3[1];\\n                vertexBuffer[index+6] = p1[2] - n3[2];\\n                vertexBuffer[index+7] = nz;\\n\\n                texcoordsBuffer[index2+4] = fc.u1;\\n                texcoordsBuffer[index2+5] = fc.v2 +  planeShift;\\n                texcoordsBuffer[index2+6] = nx;\\n                texcoordsBuffer[index2+7] = ny;\\n\\n                vertexBuffer[index+8] = p2[0] - n2[0];\\n                vertexBuffer[index+9] = p2[1] - n2[1];\\n                vertexBuffer[index+10] = p2[2] - n2[2];\\n                vertexBuffer[index+11] = nz;\\n\\n                texcoordsBuffer[index2+8] = fc.u2;\\n                texcoordsBuffer[index2+9] = fc.v1 +  planeShift;\\n                texcoordsBuffer[index2+10] = nx;\\n                texcoordsBuffer[index2+11] = ny;\\n\\n\\n                //next polygon\\n                vertexBuffer[index+12] = p1[0] - n3[0];\\n                vertexBuffer[index+13] = p1[1] - n3[1];\\n                vertexBuffer[index+14] = p1[2] - n3[2];\\n                vertexBuffer[index+15] = nz;\\n\\n                texcoordsBuffer[index2+12] = fc.u1;\\n                texcoordsBuffer[index2+13] = fc.v2 +  planeShift;\\n                texcoordsBuffer[index2+14] = nx;\\n                texcoordsBuffer[index2+15] = ny;\\n\\n                vertexBuffer[index+16] = p2[0] - n3[0];\\n                vertexBuffer[index+17] = p2[1] - n3[1];\\n                vertexBuffer[index+18] = p2[2] - n3[2];\\n                vertexBuffer[index+19] = nz;\\n\\n                texcoordsBuffer[index2+16] = fc.u2;\\n                texcoordsBuffer[index2+17] = fc.v2 +  planeShift;\\n                texcoordsBuffer[index2+18] = nx;\\n                texcoordsBuffer[index2+19] = ny;\\n\\n                vertexBuffer[index+20] = p2[0] - n2[0];\\n                vertexBuffer[index+21] = p2[1] - n2[1];\\n                vertexBuffer[index+22] = p2[2] - n2[2];\\n                vertexBuffer[index+23] = nz;\\n\\n                texcoordsBuffer[index2+20] = fc.u2;\\n                texcoordsBuffer[index2+21] = fc.v1 +  planeShift;\\n                texcoordsBuffer[index2+22] = nx;\\n                texcoordsBuffer[index2+23] = ny;\\n\\n                index += 24;\\n                index2 += 24;\\n            }\\n\\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\\n            l = fc.lx * factor;\\n        }\\n    }\\n\\n    return [pos, index, index2, l * spacing];\\n};\\n\\n\\nvar getCharVerticesCount = function(origin) {\\n    return (origin ? 3 : 4) * 3 * 2;\\n};\\n\\n\\nvar addText = function(pos, dir, text, size, spacing, fonts, vertexBuffer, texcoordsBuffer, flat, index, planes, glyphsRes, singleBuffer) {\\n    var textVector = [0,1,0];\\n    var p1 = [pos[0], pos[1], pos[2]];\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    var gfonts = res[1];\\n\\n    for (var i = 0, li = glyphs.length; i < li; i++) {\\n        var glyph = glyphs[i];\\n        var font = fonts[gfonts[i]];\\n\\n        if (font) {\\n            var factor = getFontFactor(size, font);\\n\\n            var shift = addChar(p1, dir, 0, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, gfonts[i], singleBuffer);\\n\\n            //var gid2 = (i<gls.length-1 && gls[i+1]!=-1)  ? gls[i+1] : 0;\\n            //x += Typr.U.getPairAdjustment(font, gid, gid2);\\n\\n            p1 = shift[0];\\n            index = shift[1];\\n        }\\n    }\\n\\n    return index;\\n};\\n\\n\\nvar addTextOnPath = function(points, distance, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer) {\\n    if (textVector == null) {\\n        textVector = [0,1,0];\\n    }\\n\\n    var p1 = points[0];\\n    //var newLineSpace = getLineHeight(size, fonts);\\n    //var s = [p1[0], p1[1], p1[2]];\\n\\n    p1 = [p1[0], p1[1], p1[2]];\\n    var l = distance;\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    var gfonts = res[1];\\n\\n    globals.processLineLabel = true;\\n\\n    for (var i = 0, li = glyphs.length; i < li; i++) {\\n        /*  \\n        var char = text.charCodeAt(i);\\n\\n        if (char == 10) { //new line\\n            s[0] += -dir[1] * newLineSpace;\\n            s[1] += dir[0] * newLineSpace;\\n            p1 = [s[0], s[1], s[2]];\\n            continue;\\n        }\\n\\n        if (char == 9) { //tab\\n            char = 32;\\n        }\\n        */\\n\\n        var glyph = glyphs[i];\\n        var font = fonts[gfonts[i]];\\n\\n        if (font) {\\n            var factor = getFontFactor(size, font);\\n\\n            var ll = 0.01;\\n            var fc = font.glyphs[glyph];\\n            if (fc) {\\n                ll = fc.step * factor * spacing;\\n            }\\n\\n            var posAndDir = getPathPositionAndDirection(points, l);\\n            var posAndDir2 = getPathPositionAndDirection(points, l+ll);\\n\\n            //average dir\\n            var dir = [(posAndDir2[1][0] + posAndDir[1][0])*0.5,\\n                (posAndDir2[1][1] + posAndDir[1][1])*0.5,\\n                (posAndDir2[1][2] + posAndDir[1][2])*0.5];\\n\\n            vec3Normalize(dir);\\n\\n            var shift = addChar(posAndDir[0], dir, -factor*font.size*0.7+verticalOffset, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, null, planes, gfonts[i], singleBuffer);\\n\\n            p1 = shift[0];\\n            index = shift[1];\\n            //index2 = shift[2];\\n            l += ll;\\n        }\\n    }\\n\\n    globals.processLineLabel = false;\\n\\n    return index;\\n};\\n\\n\\nvar addStreetTextOnPath = function(points, text, size, spacing, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer) {\\n    var textLength = getTextLength(text, size, spacing, fonts, glyphsRes);\\n    var pathLength = getPathLength(points);\\n    var shift = (pathLength -  textLength)*0.5;\\n    if (shift < 0) {\\n        shift = 0;\\n    }\\n\\n    if (textLength > pathLength) {\\n        return;\\n    }\\n\\n    var textVector = getPathTextVector(points, shift, text, size, spacing, fonts, glyphsRes);\\n    globals.textVector = textVector;\\n    globals.textCenter = getPathPositionAndDirection(points, pathLength * 0.5)[0];\\n    globals.textLength = textLength;\\n\\n    return addTextOnPath(points, shift, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer);\\n};\\n\\n\\nvar getFontFactor = function(size, font) {\\n    return font ? ((size / font.size) * 1.52) : 1;\\n};\\n\\n\\nvar getLineHeight = function(size, lineHeight, fonts) {\\n    var factor = getFontFactor(size, fonts[0]);\\n    //return font.space * factor;\\n    return fonts[0].cly * factor * lineHeight;\\n};\\n\\n\\nvar getTextLength = function(text, size, spacing, fonts, glyphsRes) {\\n    var l = 0;\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    var gfonts = res[1];\\n\\n    for (var i = 0, li = glyphs.length; i < li; i++) {\\n        var glyph = glyphs[i];\\n        var font = fonts[gfonts[i]];\\n\\n        if (font) {\\n            var factor = getFontFactor(size, font) * spacing;\\n            var fc = font.glyphs[glyph];\\n\\n            if (fc) {\\n                if (i == (li-1)) {\\n                    l += fc.lx * factor;\\n                } else {\\n                    l += fc.step * factor;\\n                }\\n            }\\n        }\\n    }\\n\\n    return l;\\n};\\n\\n\\nvar getSplitIndex = function(text, width, size, spacing, fonts, glyphsRes) {\\n    var l = 0;\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    var gfonts = res[1];\\n    var codes = res[2];\\n\\n    for (var i = 0, li = glyphs.length; i < li; i++) {\\n        var glyph = glyphs[i];\\n        var char = codes[i];//text.charCodeAt(i);\\n\\n        if (l > width && (char == 10 || char == 9 || char == 32)) {\\n            return i;\\n        }\\n\\n        if (char == 10) { //new line\\n            continue;\\n        }\\n\\n        var font = fonts[gfonts[i]];\\n\\n        if (font) {\\n            var factor = getFontFactor(size, font) * spacing;\\n            var fc = font.glyphs[glyph];\\n\\n            if (fc) {\\n                if (i == (li-1)) {\\n                    l += fc.lx * factor;\\n                } else {\\n                    l += fc.step * factor;\\n                }\\n            }\\n        }\\n    }\\n\\n    return li;\\n};\\n\\n\\nvar getPathLength = function(points) {\\n    var l = 0;\\n\\n    for (var i = 0, li = points.length-1; i < li; i++) {\\n        var p1 = points[i];\\n        var p2 = points[i+1];\\n        var dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n\\n        l += vec3Length(dir);\\n    }\\n\\n    return l;\\n};\\n\\n\\nvar getPathPositionAndDirection = function(points, distance) {\\n    var l = 0;\\n    var p1 = [0,0,0];\\n    var dir = [1,0,0];\\n\\n    for (var i = 0, li = points.length-1; i < li; i++) {\\n        p1 = points[i];\\n        var p2 = points[i+1];\\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n\\n        var ll = vec3Length(dir);\\n\\n        if ((l + ll) > distance) {\\n\\n            var factor = (distance - l) / (ll);\\n            var p = [p1[0] + dir[0] * factor,\\n                p1[1] + dir[1] * factor,\\n                p1[2] + dir[2] * factor];\\n\\n            vec3Normalize(dir);\\n\\n            return [p, dir];\\n        }\\n\\n        l += ll;\\n    }\\n\\n    return [p1, dir];\\n};\\n\\n\\nvar getPathTextVector = function(points, shift, text, size, spacing, fonts, glyphsRes) {\\n    var l = 0;\\n    var p1 = [0,0,0];\\n    var dir = [1,0,0];\\n    var textDir = [0,0,0];\\n    var textStart = shift;\\n    var textEnd = shift + getTextLength(text, size, spacing, fonts, glyphsRes);\\n    var bboxMin = globals.bboxMin;\\n    var geocent = globals.geocent;\\n\\n    for (var i = 0, li = points.length-1; i < li; i++) {\\n        p1 = points[i];\\n        var p2 = points[i+1];\\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n\\n        l += vec3Length(dir);\\n\\n        if (l > textStart) {\\n            vec3Normalize(dir);\\n            textDir[0] += dir[0];\\n            textDir[1] += dir[1];\\n            textDir[2] += dir[2];\\n        }\\n\\n        if (l > textEnd) {\\n            vec3Normalize(textDir);\\n\\n            if (geocent) {\\n                var nn = [0,0,0];\\n                vec3Normalize(bboxMin, nn);\\n                vec3Cross(nn, textDir, nn);\\n                return nn;\\n            } else {\\n                return [-textDir[1], textDir[0],0];\\n            }\\n        }\\n    }\\n\\n    return textDir;\\n};\\n\\n\\nvar areTextCharactersAvailable = function(text, fonts, glyphsRes) {\\n    if (!text || text == '') {\\n        return false;\\n    }\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    //var gfonts = res[1];\\n\\n    if (glyphs.indexOf(0) != -1) {\\n        return false;\\n    }\\n\\n    return true;\\n};\\n\\n\\nvar hasLatin = function(str) {\\n    for (var i = 0, li = str.length; i < li; i++) {\\n        var c = str.charCodeAt(i);\\n        if ((c >= 0x41 && c <= 0x5a) || (c >= 0x61 && c <= 0x7a) ||\\n            ((c >= 0xc0 && c <= 0xff) && c!= 0xd7 && c!= 0xf7) || (c >= 0x100 && c <= 0x17f)) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n\\n\\nvar isCJK = function(str) {\\n    for (var i = 0, li = str.length; i < li; i++) {\\n        var c = str.charCodeAt(i);\\n\\n        if (!((c >= 0x4E00 && c <= 0x62FF) || (c >= 0x6300 && c <= 0x77FF) ||\\n              (c >= 0x7800 && c <= 0x8CFF) || (c >= 0x8D00 && c <= 0x9FFF) || \\n              (c >= 0x3400 && c <= 0x4DBF) || (c >= 0x20000 && c <= 0x215FF) || \\n              (c >= 0x21600 && c <= 0x230FF) || (c >= 0x23100 && c <= 0x245FF) || \\n              (c >= 0x24600 && c <= 0x260FF) || (c >= 0x26100 && c <= 0x275FF) || \\n              (c >= 0x27600 && c <= 0x290FF) || (c >= 0x29100 && c <= 0x2A6DF) || \\n              (c >= 0x2A700 && c <= 0x2B73F) || (c >= 0x2B740 && c <= 0x2B81F) || \\n              (c >= 0x2B820 && c <= 0x2CEAF) || (c >= 0x2CEB0 && c <= 0x2EBEF) || \\n              (c >= 0xF900 && c <= 0xFAFF) || (c >= 0x3300 && c <= 0x33FF) || \\n              (c >= 0xFE30 && c <= 0xFE4F) || (c >= 0xF900 && c <= 0xFAFF) || \\n              (c >= 0x2F800 && c <= 0x2FA1F) || \\n              (c >= 0x0 && c <= 0x40) || (c >= 0xa0 && c <= 0xbf)  )) { //neutral\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n\\n\\nvar getFonts = function(fonts) {\\n    var fontsMap = [];\\n    for (var i = 0, li = fonts.length; i < li; i++) {\\n        fontsMap.push(globals.fonts[fonts[i]]);\\n    }\\n\\n    return fontsMap;\\n};\\n\\n\\nvar getFontsStorage = function(fonts) {\\n    var fontsMap = [];\\n    for (var i = 0, li = fonts.length; i < li; i++) {\\n        fontsMap.push(globals.fontsMap[fonts[i]]);\\n    }\\n\\n    return fontsMap;\\n};\\n\\n\\nvar getTextGlyphs = function(text, fonts) {\\n    return Typr.U.stringToGlyphs(fonts, text);\\n};\\n\\n\\n\\n\\n\\n\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=0156369d1fd9fd880aca.worker.js.map\", null);\n};","module.exports = function() {\n  return require(\"!!/home/david/dev/vts-browser-js/node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/*!\\n * Copyright (c) 2020 Melown Technologies SE\\n *  *  For terms of use, see accompanying main file.\\n *  *  For 3rd party libraries licenses, see 3rdpartylicenses.txt.\\n * \\n */\\n/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/core/map/loader/worker-main.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./src/core/map/geodata-import/3dtiles2.js\\\":\\n/*!*************************************************!*\\\\\\n  !*** ./src/core/map/geodata-import/3dtiles2.js ***!\\n  \\\\*************************************************/\\n/*! exports provided: default */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/math */ \\\"./src/core/utils/math.js\\\");\\n/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/matrix */ \\\"./src/core/utils/matrix.js\\\");\\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/utils */ \\\"./src/core/utils/utils.js\\\");\\n/* harmony import */ var _utils_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/url */ \\\"./src/core/utils/url.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar math = _utils_math__WEBPACK_IMPORTED_MODULE_0__[\\\"math\\\"];\\nvar vec3 = _utils_matrix__WEBPACK_IMPORTED_MODULE_1__[\\\"vec3\\\"];\\nvar utils = _utils_utils__WEBPACK_IMPORTED_MODULE_2__[\\\"utils\\\"];\\nvar utilsUrl = _utils_url__WEBPACK_IMPORTED_MODULE_3__[\\\"utilsUrl\\\"];\\n\\nvar MapGeodataImport3DTiles2 = function() {\\n    this.bintree = null;\\n    this.pathTable = null;\\n    this.totalNodes = 0;\\n    this.pathTableSize = 1;\\n    this.nodesIndex = 0;\\n    this.rootSize = 1;\\n};\\n\\nMapGeodataImport3DTiles2.prototype.countNode = function(node, onlyChildren) {\\n    this.totalNodes++;\\n\\n\\n    var content = node['content'];\\n\\n    if (content && content['uri']) {\\n        var path = content['uri'];\\n\\n        var tmp = path.split(\\\".\\\");\\n        if (tmp.length > 1) {\\n            \\n            var ext = tmp[tmp.length - 1];\\n            tmp.pop();\\n            var stmp = tmp.join('.');\\n\\n            if (ext == \\\"json\\\") {\\n                this.pathTableSize += stmp.length + 1 + 4;\\n            } else if (ext == \\\"mesh\\\") {\\n                this.pathTableSize += stmp.length + 1;\\n            }\\n        }\\n    }\\n\\n\\n    var children = node['children'];\\n\\n    if (children) {\\n        for (var i = 0, li = children.length; i < li; i++) {\\n            this.countNode(children[i]);\\n        }\\n    }\\n};\\n\\n/*\\nMapGeodataImport3DTiles2.prototype.processNodeOctant = function(node, originalOctant) {\\n    var content = node['content'];\\n\\n    if (content && content['uri']) {\\n        var path = content['uri'];\\n\\n        var tmp = path.split(\\\".\\\");\\n        if (tmp.length > 1) {\\n\\n            var ext = tmp[tmp.length - 1];\\n            tmp.pop();\\n            var stmp = tmp.join('.');\\n\\n            if (ext == \\\"json\\\") {\\n                \\n                tmp = stmp.split(\\\"-\\\");\\n\\n            } else if (ext == \\\"mesh\\\") {\\n                \\n                var fname = tmp;\\n                \\n                tmp = stmp.split(\\\"/\\\");\\n                tmp = tmp[tmp.length - 1];\\n                tmp = tmp.split(\\\"-\\\");\\n\\n                var ix = parseInt(tmp[tmp.length - 3]);\\n                var iy = parseInt(tmp[tmp.length - 2]);\\n                var iz = parseInt(tmp[tmp.length - 1]);\\n\\n                var octant = (ix % 2) + (iy % 2)*2 + ((iz+1) % 2)*4;\\n                \\n                console.log(\\\"octant: node: \\\" + originalOctant + \\\" mesh:\\\" + octant + \\\"   \\\"  + fname);\\n            }\\n        }\\n    }\\n \\n};\\n*/\\n\\n\\nMapGeodataImport3DTiles2.prototype.processNode = function(node, index, lod, onlyChildren) {\\n\\n    var index2 = index * 9;\\n\\n    //debugger\\n    var content = node['content'];\\n\\n    if (content && content['uri']) {\\n        var path = content['uri'];\\n\\n        var tmp = path.split(\\\".\\\");\\n        if (tmp.length > 1) {\\n            \\n            var ext = tmp[tmp.length - 1];\\n            tmp.pop();\\n            var stmp = tmp.join('.');\\n\\n            if (ext == \\\"json\\\") {\\n                this.bintree[index2] = this.pathTableSize | (1<<31);\\n                this.pathTableSize += 4;\\n            } else if (ext == \\\"mesh\\\") {\\n                this.bintree[index2] = this.pathTableSize;\\n            }\\n\\n            for (var i = 0, li = stmp.length; i < li; i++) {\\n                this.pathTable[this.pathTableSize++] = stmp.charCodeAt(i);\\n            }\\n            \\n            this.pathTable[this.pathTableSize++] = 0;\\n        }\\n    }\\n\\n    var children = node['children'];\\n\\n    if (children) {\\n\\n        for (var i = 0, li = children.length; i < li; i++) {\\n            var child = children[i];\\n            var boundingVolume = child['boundingVolume'];\\n\\n            if (boundingVolume) {\\n                \\n                var extras = child['extras'];\\n                var octant = 0;\\n                \\n                if (extras) {\\n                    octant = extras['ci'];\\n                }\\n                \\n                \\n                var ix = octant & 1;\\n                var iy = (octant & (1<<1)) >> 1;\\n                var iz = (octant & (1<<2)) >> 2;\\n                \\n                /*\\n                switch(octant) {\\n                    case 0: octant = 4; break;\\n                    case 1: octant = 5; break;\\n                    case 2: octant = 6; break;\\n                    case 3: octant = 7; break;\\n                    case 4: octant = 0; break; //\\n                    case 5: octant = 1; break; //\\n                    case 6: octant = 2; break; //\\n                    case 7: octant = 3; break; //\\n                }*/\\n                \\n                //this.processNodeOctant(child, octant);*/\\n\\n                /*\\n                if (lod > 1) {\\n                    iy = 1 - iy;\\n                }*/\\n\\n                //iz = 1 - iz;\\n                \\n                //octant = (ix<<0) + (iy << 1) + (iz << 2);\\n                //octant = (ix<<0) + (iy << 1) + (iz << 2);\\n                \\n                //octant = 0;\\n                \\n                if (boundingVolume['region']) {\\n                    \\n                    this.totalNodes++;\\n                    var childIndex = this.totalNodes;\\n                    \\n                    this.bintree[index2 + 1 + octant] = childIndex;\\n\\n                    this.processNode(child, childIndex, lod + 1);\\n                }\\n            }\\n        }\\n        \\n        /*var testCount = 0;\\n        for (var i = 0, li = 8; i < li; i++) {\\n            if (this.bintree[index2 + 1 + i]) {\\n                testCount++;\\n            }\\n        }\\n\\n        if (testCount != children.length) {\\n            console.log('duplicit octants!!!');\\n        } */       \\n    }\\n};\\n\\n\\nMapGeodataImport3DTiles2.prototype.processJSON = function(json, options) {\\n    if (!json) {\\n        return;\\n    }\\n\\n    this.rootPath = '';\\n\\n    this.countNode(json['root']);\\n    //alloc memory\\n    this.bintree = new Uint32Array(this.totalNodes*9);\\n    this.pathTable = new Uint8Array(this.pathTableSize+1);\\n\\n    this.totalNodes = 0;\\n    this.pathTableSize = 1;\\n\\n    //debugger\\n\\n    if (options.root) {\\n        \\n        var extras = json['extras'];\\n        var points = extras['extents'];\\n\\n        var center = [ (points[0][0]+points[1][0]+points[2][0]+points[3][0]+points[4][0]+points[5][0]+points[6][0]+points[7][0])/8,\\n                       (points[0][1]+points[1][1]+points[2][1]+points[3][1]+points[4][1]+points[5][1]+points[6][1]+points[7][1])/8,\\n                       (points[0][2]+points[1][2]+points[2][2]+points[3][2]+points[4][2]+points[5][2]+points[6][2]+points[7][2])/8 ];\\n\\n       var yv = [(points[1][0] - points[0][0]), (points[1][1] - points[0][1]), (points[1][2] - points[0][2])];\\n       var xv = [(points[1][0] - points[2][0]), (points[1][1] - points[2][1]), (points[1][2] - points[2][2])];\\n       var zv = [(points[4][0] - points[0][0]), (points[4][1] - points[0][1]), (points[4][2] - points[0][2])];\\n\\n       yv[0] = -yv[0];\\n       yv[1] = -yv[1];\\n       yv[2] = -yv[2];\\n\\n       xv[0] = -xv[0];\\n       xv[1] = -xv[1];\\n       xv[2] = -xv[2];\\n       \\n       /*zv[0] = -zv[0];\\n       zv[1] = -zv[1];\\n       zv[2] = -zv[2];*/\\n       \\n\\n       var p = points[1];\\n\\n        this.rootPoints = [\\n\\n            [p[0],\\n             p[1],\\n             p[2]],\\n\\n            [p[0] + xv[0],\\n             p[1] + xv[1],\\n             p[2] + xv[2]],\\n\\n            [p[0] + xv[0] + yv[0],\\n             p[1] + xv[1] + yv[1],\\n             p[2] + xv[2] + yv[2]],\\n\\n            [p[0] + yv[0],\\n             p[1] + yv[1],\\n             p[2] + yv[2]],\\n\\n            [p[0] + zv[0],\\n             p[1] + zv[1],\\n             p[2] + zv[2]],\\n\\n            [p[0] + xv[0] + zv[0],\\n             p[1] + xv[1] + zv[1],\\n             p[2] + xv[2] + zv[2]],\\n\\n            [p[0] + xv[0] + yv[0] + zv[0],\\n             p[1] + xv[1] + yv[1] + zv[1],\\n             p[2] + xv[2] + yv[2] + zv[2]],\\n\\n            [p[0] + yv[0] + zv[0],\\n             p[1] + yv[1] + zv[1],\\n             p[2] + yv[2] + zv[2]]\\n        \\n        ];\\n\\n        //this.rootPoints = points;\\n        this.rootCenter = center;\\n        this.rootRadius = vec3.distance(center, points[0]);\\n        this.rootTexelSize = extras['nominalResolution'] * Math.pow(2,extras['depth']);\\n    } else {\\n        this.rootPoints = [];\\n        this.rootCenter = [];\\n        this.rootRadius = 1;\\n        this.rootTexelSize = 1;\\n    }\\n\\n    this.processNode(json['root'], 0, 0);\\n    this.totalNodes++;\\n};\\n\\n\\nMapGeodataImport3DTiles2.prototype.loadJSON = function(path, options, onLoaded) {\\n    utils.loadJSON(path, this.onLoaded.bind(this, options, onLoaded), null);\\n};\\n\\nMapGeodataImport3DTiles2.prototype.onLoaded = function(options, onLoaded, json) {\\n    this.processJSON(json, options);\\n    \\n    if (onLoaded) {\\n        onLoaded(options, {\\n                   'bintree': this.bintree,\\n                   'pathTable': this.pathTable,\\n                   'totalNodes': this.totalNodes,\\n                   'rootSize': this.rootSize,\\n                   'points': this.rootPoints,\\n                   'center': this.rootCenter,\\n                   'radius': this.rootRadius,\\n                   'texelSize': this.rootTexelSize\\n               });\\n    }\\n}\\n\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (MapGeodataImport3DTiles2);\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/loader/worker-globals.js\\\":\\n/*!***********************************************!*\\\\\\n  !*** ./src/core/map/loader/worker-globals.js ***!\\n  \\\\***********************************************/\\n/*! exports provided: globals */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"globals\\\", function() { return globals; });\\n\\nvar globals = {};\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/loader/worker-main.js\\\":\\n/*!********************************************!*\\\\\\n  !*** ./src/core/map/loader/worker-main.js ***!\\n  \\\\********************************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/loader/worker-globals.js\\\");\\n/* harmony import */ var _worker_mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker-mesh.js */ \\\"./src/core/map/loader/worker-mesh.js\\\");\\n/* harmony import */ var _geodata_import_3dtiles2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geodata-import/3dtiles2 */ \\\"./src/core/map/geodata-import/3dtiles2.js\\\");\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"];\\nvar parseMesh = _worker_mesh_js__WEBPACK_IMPORTED_MODULE_1__[\\\"parseMesh\\\"];\\nvar MapGeodataImport3DTiles2 = _geodata_import_3dtiles2__WEBPACK_IMPORTED_MODULE_2__[\\\"default\\\"];\\n\\nvar packedEvents = [];\\nvar packedTransferables = [];\\n\\nfunction postPackedMessage(message, transferables) {\\n\\n    if (globals.config.mapPackLoaderEvents) {\\n\\n        packedEvents.push(message);\\n\\n        if (transferables) {\\n            packedTransferables = packedTransferables.concat(transferables);\\n        }\\n\\n    } else {\\n\\n        if (transferables) {\\n            postMessage(message, transferables);\\n        } else {\\n            postMessage(message);\\n        }\\n\\n    }\\n}\\n\\nfunction loadBinary(path, onLoaded, onError, withCredentials, xhrParams, responseType, kind, options) {\\n    var xhr = new XMLHttpRequest();\\n\\n    xhr.onreadystatechange = (function (){\\n\\n        switch (xhr.readyState) {\\n        case 0 : // UNINITIALIZED\\n        case 1 : // LOADING\\n        case 2 : // LOADED\\n        case 3 : // INTERACTIVE\\n            break;\\n        case 4 : // COMPLETED\\n    \\n            if (xhr.status >= 400 || xhr.status == 0) {\\n                if (onError) {\\n                    postPackedMessage({'command' : 'on-error', 'path': path, 'status':xhr.status});\\n                }\\n                break;\\n            }\\n    \\n            var abuffer = xhr.response;\\n                    \\n            if (!abuffer) {\\n                if (onError) {\\n                    postPackedMessage({'command' : 'on-error', 'path': path});\\n                }\\n                break;\\n            }\\n    \\n            if (onLoaded) {\\n                if (kind == 'direct-texture') {\\n                    createImageBitmap(abuffer).then((function(bitmap){\\n                        postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': bitmap, 'filesize': abuffer.size}, [bitmap]);                        \\n                    }).bind(this));\\n                } else if (kind == 'direct-mesh') {\\n                    var data = parseMesh({data:new DataView(abuffer), index:0});\\n                    postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': data.mesh}, data.transferables);\\n                } else if (kind == 'direct-3dtiles') {\\n                    //debugger\\n                    var data = parse3DTile(JSON.parse(abuffer), options);\\n                    //postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': data.geodata}, data.transferables);\\n                    postMessage({'command' : 'on-loaded', 'path': path, 'data': data.geodata}, data.transferables);\\n                } else {\\n                    postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': abuffer}, [abuffer]);\\n                }\\n            }\\n    \\n            break;\\n    \\n        default:\\n    \\n            if (onError) {\\n                postPackedMessage({'command' : 'on-error', 'path': path});\\n            }\\n    \\n            break;\\n        }\\n\\n    }).bind(this);\\n    \\n    /*\\n    xhr.onerror  = (function() {\\n        if (onError) {\\n            onError();\\n        }\\n    }).bind(this);*/\\n\\n    xhr.open('GET', path, true);\\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\\n    xhr.withCredentials = withCredentials;\\n\\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\\\"tokenHeader\\\"]*/) {\\n        //xhr.setRequestHeader(xhrParams[\\\"tokenHeader\\\"], xhrParams[\\\"token\\\"]); //old way\\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\\n    }\\n\\n    xhr.send('');\\n};\\n\\nfunction parse3DTile(json, options) {\\n\\n    var geodata = new MapGeodataImport3DTiles2();\\n    geodata.processJSON(json, options);\\n\\n    return { geodata:{\\n                'bintree': geodata.bintree,\\n                'pathTable': geodata.pathTable,\\n                'totalNodes': geodata.totalNodes,\\n                'rootSize': geodata.rootSize,\\n                'points': geodata.rootPoints,\\n                'center': geodata.rootCenter,\\n                'radius': geodata.rootRadius,\\n                'texelSize': geodata.rootTexelSize\\n             },\\n             transferables:[geodata.bintree.buffer, geodata.pathTable.buffer]\\n           };\\n\\n}\\n\\nself.onmessage = function (e) {\\n    var message = e.data;\\n    var command = message['command'];\\n    //var data = message['data'];\\n\\n    //console.log(\\\"workeronmessage: \\\" + command);\\n\\n    switch(command) {\\n\\n        case 'config':\\n            globals.config = message['data'];\\n            break;\\n\\n        case 'tick':\\n\\n            if (packedEvents.length > 0) {\\n                if (packedTransferables.length > 0) {\\n                    postMessage({'command': 'packed-events', 'messages':packedEvents}, packedTransferables);\\n                } else {\\n                    postMessage({'command': 'packed-events', 'messages':packedEvents});\\n                }\\n            }\\n\\n            packedEvents = [];\\n            packedTransferables = [];\\n\\n            break;\\n\\n        case 'load-binary':\\n            loadBinary(message['path'], true, true, message['withCredentials'], message['xhrParams'], message['responseType'], message['kind'], message['options']);\\n            break;\\n\\n    }\\n};\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/map/loader/worker-mesh.js\\\":\\n/*!********************************************!*\\\\\\n  !*** ./src/core/map/loader/worker-mesh.js ***!\\n  \\\\********************************************/\\n/*! exports provided: parseMesh */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"parseMesh\\\", function() { return parseMesh; });\\n/* harmony import */ var _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-globals.js */ \\\"./src/core/map/loader/worker-globals.js\\\");\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = _worker_globals_js__WEBPACK_IMPORTED_MODULE_0__[\\\"globals\\\"];\\n\\nvar flagsInternalTexcoords =  1;\\nvar flagsExternalTexcoords =  2;\\nvar flagsPerVertexUndulation =  4;\\nvar flagsTextureMode =  8;\\n\\n\\nfunction parseMesh(stream) {\\n    /*\\n    struct MapMesh {\\n        struct MapMeshHeader {\\n            char magic[2];                // letters \\\"ME\\\"\\n            ushort version;               // currently 1\\n            double meanUndulation;        // read more about undulation below\\n            ushort numSubmeshes;          // number of submeshes\\n        } header;\\n        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property\\n    };\\n    */\\n\\n    var mesh = {}, i, li, submesh;\\n\\n    //parase header\\n    var streamData = stream.data;\\n    var magic = '';\\n\\n    if (streamData.length < 2) {\\n        return false;\\n    }\\n\\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\\n\\n    if (magic != 'ME') {\\n        return false;\\n    }\\n\\n    mesh.version = streamData.getUint16(stream.index, true); stream.index += 2;\\n\\n    if (mesh.version > 3) {\\n        return false;\\n    }\\n    \\n    stream.uint8Data = new Uint8Array(stream.data.buffer);\\n\\n    mesh.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;\\n    mesh.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;\\n\\n    mesh.submeshes = [];\\n    mesh.gpuSize = 0; \\n    mesh.faces = 0;\\n    mesh.size = 0;\\n\\n    var use16bit = globals.config.map16bitMeshes;\\n\\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\\n        var submesh = parseSubmesh(mesh, stream);\\n        if (submesh.valid) {\\n            mesh.submeshes.push(submesh); \\n            mesh.size += submesh.size;\\n            mesh.faces += submesh.faces;\\n\\n            //aproximate size\\n            mesh.gpuSize += submesh.size;\\n        }\\n    }\\n    \\n    mesh.numSubmeshes = mesh.submeshes.length;\\n\\n    //prevent minification\\n\\n    var submeshes = [];\\n    var transferables = [];\\n\\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\\n        submesh = mesh.submeshes[i];\\n        submeshes.push({\\n\\n            'bboxMax': submesh.bboxMax,\\n            'bboxMin': submesh.bboxMin,\\n            'externalUVs': (submesh.externalUVs) ? submesh.externalUVs.buffer : null,\\n            'faces': submesh.faces,\\n            'flags': submesh.flags,\\n            'gpuSize': submesh.gpuSize,\\n            'indices': (submesh.indices) ? submesh.indices.buffer : null,\\n            'internalUVs': (submesh.internalUVs) ? submesh.internalUVs.buffer : null,\\n            'size': submesh.size,\\n            'surfaceReference': submesh.surfaceReference,\\n            'textureLayer': submesh.textureLayer,\\n            'textureLayer2': submesh.textureLayer2,\\n            //'valid': submesh.valid\\n            'vertices': submesh.vertices.buffer\\n\\n        });\\n\\n        if (submesh.externalUVs) transferables.push(submesh.externalUVs.buffer);\\n        if (submesh.internalUVs) transferables.push(submesh.internalUVs.buffer);\\n        if (submesh.vertices) transferables.push(submesh.vertices.buffer);\\n        if (submesh.indices) transferables.push(submesh.indices.buffer);\\n    }\\n\\n    return { mesh:{\\n               'faces': mesh.faces,\\n               'gpuSize': mesh.gpuSize,\\n               'meanUndulation': mesh.meanUndulation,\\n               'numSubmeshes': mesh.numSubmeshes,\\n               'size': mesh.size,\\n               'submeshes': mesh.submeshes,\\n               'version': mesh.version\\n             },\\n             transferables:transferables\\n           };\\n};\\n\\n\\nfunction parseSubmesh(mesh, stream) {\\n    /*\\n    struct MapSubmesh {\\n        struct MapSubmeshHeader header;\\n        struct VerticesBlock vertices;\\n        struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )\\n        struct FacesBlock faces;\\n    };\\n    */\\n\\n    var submesh = { valid:true };\\n\\n    parseHeader(mesh, submesh, stream);\\n    if (mesh.version >= 3) {\\n        parseVerticesAndFaces2(mesh, submesh, stream);\\n    } else {\\n        parseVerticesAndFaces(mesh, submesh, stream);\\n    }\\n\\n    return submesh;\\n};\\n\\n\\nfunction parseHeader(mesh, submesh, stream) {\\n    /*\\n    struct MapSubmeshHeader {\\n        char flags;                    // bit 0 - contains internal texture coords\\n                                       // bit 1 - contains external texture coords\\n                                       // bit 2 - contains per vertex undulation\\n                                       // bit 3 - texture mode (0 - internal, 1 - external)\\n        \\n        uchar surfaceReference;        // reference to the surface of origin, see bellow\\n        ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id\\n        double boundingBox[2][3];      // read more about bounding box bellow\\n    };\\n    */\\n\\n    //debugger\\n    var streamData = stream.data;\\n\\n    submesh.flags = streamData.getUint8(stream.index, true); stream.index += 1;\\n\\n    if (mesh.version > 1) {\\n        submesh.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;\\n    } else {\\n        submesh.surfaceReference = 0;\\n    }\\n\\n    submesh.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;\\n    submesh.textureLayer2 = submesh.textureLayer; //hack for presentation\\n\\n    var bboxMin = [];\\n    var bboxMax = [];\\n\\n    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\\n    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\\n    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\\n\\n    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\\n    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\\n    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\\n    \\n    submesh.bboxMin = bboxMin;\\n    submesh.bboxMax = bboxMax;\\n};\\n\\n\\nfunction parseVerticesAndFaces(mesh, submesh, stream) {\\n    /*\\n    struct VerticesBlock {\\n        ushort numVertices;              // number of vertices\\n\\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\\n            // vertex coordinates\\n            ushort x;\\n            ushort y;\\n            ushort z;\\n\\n            // if header.flags & ( 1 << 1 ): external texture coordinates\\n            // values in 2^16^ range represents the 0..1 normalized texture space\\n            ushort eu;\\n            ushort ev;\\n\\n            // if header.flags & ( 1 << 2 ): undulation delta\\n            float16 undulationDelta;\\n        } vertices[];\\n    };\\n    */\\n\\n    var data = stream.data;\\n    var index = stream.index;\\n    var uint8Data = stream.uint8Data;\\n\\n    var use16bit = globals.config.map16bitMeshes;\\n\\n    var numVertices = data.getUint16(index, true); index += 2;\\n\\n    if (!numVertices) {\\n        submesh.valid = false;\\n    }\\n\\n    var internalUVs = null;\\n    var externalUVs = null;\\n    var onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\\n    var tmpVertices, tmpExternalUVs, tmpInternalUVs;\\n\\n    var vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\\n\\n    if (submesh.flags & flagsExternalTexcoords) {\\n        if (onlyOneUVs) {\\n            externalUVs = true;\\n        } else {\\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\\n        }\\n    }\\n\\n    var uvfactor = use16bit ? 1.0 : (1.0 / 65535);\\n    var vindex = 0;\\n    var uvindex = 0;\\n    var i, li;\\n\\n    for (i = 0; i < numVertices; i++) {\\n        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\\n        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;\\n        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;\\n        vindex += 3;\\n\\n        if (externalUVs) {\\n            if (!onlyOneUVs) {\\n                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;\\n                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;\\n                uvindex += 2;\\n            }\\n            index += 10;\\n        } else {\\n            index += 6;\\n        }\\n    }\\n\\n\\n    tmpVertices = vertices;\\n    tmpExternalUVs = externalUVs;\\n   \\n    /*\\n    struct TexcoorsBlock {\\n        ushort numTexcoords;              // number of texture coordinates\\n\\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\\n\\n            // internal texture coordinates\\n            // values in 2^16^ range represents the 0..1 normalized texture space\\n            ushort u;\\n            ushort v;\\n        } texcoords[];\\n    };\\n    */\\n\\n    if (submesh.flags & flagsInternalTexcoords) {\\n        var numUVs = data.getUint16(index, true); index += 2;\\n    \\n        internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\\n        //var uvfactor = 1.0 / 65535;\\n    \\n        for (i = 0, li = numUVs * 2; i < li; i+=2) {\\n            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\\n            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;\\n            index += 4;\\n        }\\n    \\n        tmpInternalUVs = internalUVs;\\n    }\\n\\n    /*\\n    struct FacesBlock {\\n        ushort numFaces;              // number of faces\\n\\n        struct Face {                 // array of faces, size of array is defined by numFaces property\\n\\n            ushort v[3]; // array of indices to stored vertices\\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\\n\\n        } faces[];\\n    };\\n    */\\n\\n    var numFaces = data.getUint16(index, true); index += 2;\\n    var indices = null;\\n\\n    internalUVs = null;\\n    externalUVs = null;\\n\\n    var onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\\n    var onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\\n\\n    if (onlyIndices) {\\n        indices = new Uint16Array(numFaces * 3);\\n    } else {\\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\\n\\n        if (submesh.flags & flagsInternalTexcoords) {\\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\\n        }\\n\\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\\n        }\\n    }\\n\\n    var vtmp = tmpVertices;\\n    var eUVs = tmpExternalUVs;\\n    var iUVs = tmpInternalUVs;\\n    var v1, v2, v3, vv1, vv2, vv3, sindex;\\n\\n    if (onlyExternalIndices) {\\n        vertices = tmpVertices;\\n        externalUVs = tmpExternalUVs;\\n    }\\n\\n    if (onlyInternalIndices) {\\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\\n        internalUVs = tmpInternalUVs;\\n    }\\n\\n    for (i = 0; i < numFaces; i++) {\\n        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));\\n        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));\\n        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));\\n\\n        if (onlyIndices) {\\n            vindex = i * 3;\\n\\n            if (internalUVs != null) {\\n                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\\n                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\\n                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\\n\\n                vertices[vv1*3] = vtmp[v1*3];\\n                vertices[vv1*3+1] = vtmp[v1*3+1];\\n                vertices[vv1*3+2] = vtmp[v1*3+2];\\n\\n                vertices[vv2*3] = vtmp[v2*3];\\n                vertices[vv2*3+1] = vtmp[v2*3+1];\\n                vertices[vv2*3+2] = vtmp[v2*3+2];\\n\\n                vertices[vv3*3] = vtmp[v3*3];\\n                vertices[vv3*3+1] = vtmp[v3*3+1];\\n                vertices[vv3*3+2] = vtmp[v3*3+2];\\n\\n                indices[vindex] = vv1;\\n                indices[vindex+1] = vv2;\\n                indices[vindex+2] = vv3;\\n\\n                index += 12;\\n            } else {\\n                indices[vindex] = v1;\\n                indices[vindex+1] = v2;\\n                indices[vindex+2] = v3;\\n\\n                index += 6;\\n            }\\n\\n        } else {\\n            vindex = i * (3 * 3);\\n\\n            sindex = v1 * 3;\\n            vertices[vindex] = vtmp[sindex];\\n            vertices[vindex+1] = vtmp[sindex+1];\\n            vertices[vindex+2] = vtmp[sindex+2];\\n\\n            sindex = v2 * 3;\\n            vertices[vindex+3] = vtmp[sindex];\\n            vertices[vindex+4] = vtmp[sindex+1];\\n            vertices[vindex+5] = vtmp[sindex+2];\\n\\n            sindex = v3 * 3;\\n            vertices[vindex+6] = vtmp[sindex];\\n            vertices[vindex+7] = vtmp[sindex+1];\\n            vertices[vindex+8] = vtmp[sindex+2];\\n\\n            if (externalUVs != null) {\\n                vindex = i * (3 * 2);\\n                externalUVs[vindex] = eUVs[v1*2];\\n                externalUVs[vindex+1] = eUVs[v1*2+1];\\n                externalUVs[vindex+2] = eUVs[v2*2];\\n                externalUVs[vindex+3] = eUVs[v2*2+1];\\n                externalUVs[vindex+4] = eUVs[v3*2];\\n                externalUVs[vindex+5] = eUVs[v3*2+1];\\n            }\\n\\n            if (internalUVs != null) {\\n                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\\n                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\\n                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\\n                index += 12;\\n\\n                vindex = i * (3 * 2);\\n                internalUVs[vindex] = iUVs[v1*2];\\n                internalUVs[vindex+1] = iUVs[v1*2+1];\\n                internalUVs[vindex+2] = iUVs[v2*2];\\n                internalUVs[vindex+3] = iUVs[v2*2+1];\\n                internalUVs[vindex+4] = iUVs[v3*2];\\n                internalUVs[vindex+5] = iUVs[v3*2+1];\\n            } else {\\n                index += 6;\\n            }\\n        }\\n    }\\n\\n    submesh.vertices = vertices;\\n    submesh.internalUVs = internalUVs;\\n    submesh.externalUVs = externalUVs;\\n    submesh.indices = indices;\\n\\n    tmpVertices = null;\\n    tmpInternalUVs = null;\\n    tmpExternalUVs = null;\\n\\n    stream.index = index;\\n\\n    submesh.size = submesh.vertices.byteLength;\\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\\n    submesh.faces = numFaces;\\n};\\n\\n\\nfunction parseWord(data, res) {\\n    var value = data[res[1]];\\n    \\n    if (value & 0x80) {\\n        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);\\n        res[1] += 2;\\n    } else {\\n        res[0] = value;\\n        res[1] ++;\\n    }\\n};\\n\\n\\nfunction parseDelta(data, res) {\\n    var value = data[res[1]];\\n    \\n    if (value & 0x80) {\\n        value = (value & 0x7f) | (data[res[1]+1] << 7);\\n\\n        if (value & 1) {\\n            res[0] = -((value >> 1)+1); \\n            res[1] += 2;\\n        } else {\\n            res[0] = (value >> 1); \\n            res[1] += 2;\\n        }\\n    } else {\\n        if (value & 1) {\\n            res[0] = -((value >> 1)+1); \\n            res[1] ++;\\n        } else {\\n            res[0] = (value >> 1); \\n            res[1] ++;\\n        }\\n    }\\n};\\n\\n\\nfunction parseVerticesAndFaces2(mesh, submesh, stream) {\\n    /*\\n    struct VerticesBlock {\\n        ushort numVertices;              // number of vertices\\n        ushort geomQuantCoef;            // geometry quantization coefficient\\n\\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\\n            // vertex coordinates\\n            delta x;\\n            delta y;\\n            delta z;\\n        } vertices[];\\n    };\\n    */\\n\\n    var data = stream.data;\\n    var index = stream.index;\\n    var uint8Data = stream.uint8Data;\\n\\n    var use16bit = globals.config.map16bitMeshes;\\n    var onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\\n    var tmpVertices, tmpExternalUVs, tmpInternalUVs;\\n\\n    var numVertices = data.getUint16(index, true); index += 2;\\n    var quant = data.getUint16(index, true); index += 2;\\n\\n    if (!numVertices) {\\n        submesh.valid = false;\\n    }\\n\\n    var bmin = submesh.bboxMin;\\n    var bmax = submesh.bboxMax;\\n\\n    var center = [(bmin[0] + bmax[0])*0.5, (bmin[1] + bmax[1])*0.5, (bmin[2] + bmax[2])*0.5];\\n    var scale = Math.abs(Math.max(bmax[0] - bmin[0], bmax[1] - bmin[1], bmax[2] - bmin[2]));\\n\\n    var multiplier = 1.0 / quant;\\n    var externalUVs = null;\\n\\n    var vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\\n    var vindex;\\n    \\n    var x = 0, y = 0,z = 0;\\n    var cx = center[0], cy = center[1], cz = center[2];\\n    var mx = bmin[0];\\n    var my = bmin[1];\\n    var mz = bmin[2];\\n    var sx = 1.0 / (bmax[0] - bmin[0]);\\n    var sy = 1.0 / (bmax[1] - bmin[1]);\\n    var sz = 1.0 / (bmax[2] - bmin[2]);\\n    \\n    var res = [0, index];\\n    var i, li, t;\\n\\n    if (use16bit) {\\n        for (i = 0; i < numVertices; i++) {\\n            parseDelta(uint8Data, res);\\n            x += res[0];\\n            parseDelta(uint8Data, res);\\n            y += res[0];\\n            parseDelta(uint8Data, res);\\n            z += res[0];\\n            \\n            vindex = i * 3;\\n            t = ((x * multiplier * scale + cx) - mx) * sx;\\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\\n            vertices[vindex] = t * 65535;\\n            t = ((y * multiplier * scale + cy) - my) * sy;\\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\\n            vertices[vindex+1] = t * 65535;\\n            t = ((z * multiplier * scale + cz) - mz) * sz;\\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\\n            vertices[vindex+2] = t * 65535;\\n        }\\n    } else {\\n        for (i = 0; i < numVertices; i++) {\\n            parseDelta(uint8Data, res);\\n            x += res[0];\\n            parseDelta(uint8Data, res);\\n            y += res[0];\\n            parseDelta(uint8Data, res);\\n            z += res[0];\\n            \\n            vindex = i * 3;\\n            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;\\n            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;\\n            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;\\n        }\\n    }\\n    \\n    index = res[1];\\n\\n    if (submesh.flags & flagsExternalTexcoords) {\\n        quant = data.getUint16(index, true); index += 2;\\n        res[1] = index;\\n\\n        if (onlyOneUVs) {\\n\\n            for (i = 0; i < numVertices; i++) {\\n                parseDelta(uint8Data, res);\\n                parseDelta(uint8Data, res);\\n            }\\n\\n        } else {\\n            multiplier = (use16bit) ? (65535 / quant) : (1.0 / quant);\\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\\n            x = 0, y = 0;\\n\\n            if (use16bit) {\\n                for (i = 0; i < numVertices; i++) {\\n                    parseDelta(uint8Data, res);\\n                    x += res[0];\\n                    parseDelta(uint8Data, res);\\n                    y += res[0];\\n\\n                    var uvindex = i * 2;\\n                    t = x * multiplier;\\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\\n                    externalUVs[uvindex] = t;\\n                    t = y * multiplier;\\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\\n                    externalUVs[uvindex+1] = 65535 - t;\\n                }\\n            } else {\\n                for (i = 0; i < numVertices; i++) {\\n                    parseDelta(uint8Data, res);\\n                    x += res[0];\\n                    parseDelta(uint8Data, res);\\n                    y += res[0];\\n\\n                    var uvindex = i * 2;\\n                    externalUVs[uvindex] = x * multiplier;\\n                    externalUVs[uvindex+1] = 1 - (y * multiplier);\\n                }\\n            }\\n        }\\n    }\\n\\n    index = res[1];\\n\\n    tmpVertices = vertices;\\n    tmpExternalUVs = externalUVs;\\n    \\n    /*\\n    struct TexcoorsBlock {\\n        ushort numTexcoords;              // number of texture coordinates\\n\\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\\n\\n            // internal texture coordinates\\n            // values in 2^16^ range represents the 0..1 normalized texture space\\n            ushort u;\\n            ushort v;\\n        } texcoords[];\\n    };\\n    */\\n\\n    if (submesh.flags & flagsInternalTexcoords) {\\n        var numUVs = data.getUint16(index, true); index += 2;\\n        var quantU = data.getUint16(index, true); index += 2;\\n        var quantV = data.getUint16(index, true); index += 2;\\n        var multiplierU = (use16bit) ? (65536.0 / quantU) : (1.0 / quantU);\\n        var multiplierV = (use16bit) ? (65536.0 / quantV) : (1.0 / quantV);\\n        x = 0, y = 0;\\n    \\n        var internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\\n        res[1] = index;7\\n\\n        if (use16bit) {\\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\\n                parseDelta(uint8Data, res);\\n                x += res[0];\\n                parseDelta(uint8Data, res);\\n                y += res[0];\\n\\n                t = x * multiplierU;\\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\\n                internalUVs[i] = t;\\n                t = y * multiplierV;\\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\\n                internalUVs[i+1] = 65535 - t;\\n            }\\n        } else {\\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\\n                parseDelta(uint8Data, res);\\n                x += res[0];\\n                parseDelta(uint8Data, res);\\n                y += res[0];\\n\\n                internalUVs[i] = x * multiplierU;\\n                internalUVs[i+1] = 1 - (y * multiplierV);\\n            }\\n        }\\n\\n        index = res[1];\\n    \\n        tmpInternalUVs = internalUVs;\\n    }\\n\\n    /*\\n    struct FacesBlock {\\n        ushort numFaces;              // number of faces\\n\\n        struct Face {                 // array of faces, size of array is defined by numFaces property\\n\\n            ushort v[3]; // array of indices to stored vertices\\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\\n\\n        } faces[];\\n    };\\n    */\\n\\n    var numFaces = data.getUint16(index, true); index += 2;\\n    var indices = null;\\n\\n    internalUVs = null;\\n    externalUVs = null;\\n\\n    var onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\\n    var onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\\n\\n    if (onlyIndices) {\\n        indices = new Uint16Array(numFaces * 3);\\n    } else {\\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\\n\\n        if (submesh.flags & flagsInternalTexcoords) {\\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\\n        }\\n\\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\\n        }\\n    }\\n\\n    var vtmp = tmpVertices;\\n    var eUVs = tmpExternalUVs;\\n    var iUVs = tmpInternalUVs;\\n    var high = 0;\\n    var v1, v2, v3, vv1, vv2, vv3;\\n    res[1] = index;\\n\\n    for (i = 0; i < numFaces; i++) {\\n        parseWord(uint8Data, res);\\n        v1 = high - res[0];\\n        if (!res[0]) { high++; }\\n\\n        parseWord(uint8Data, res);\\n        v2 = high - res[0];\\n        if (!res[0]) { high++; }\\n\\n        parseWord(uint8Data, res);\\n        v3 = high - res[0];\\n        if (!res[0]) { high++; }\\n\\n        if (onlyIndices) {\\n            vindex = i * 3;\\n            indices[vindex] = v1;\\n            indices[vindex+1] = v2;\\n            indices[vindex+2] = v3;\\n        } else {\\n            vindex = i * (3 * 3);\\n            var sindex = v1 * 3;\\n            vertices[vindex] = vtmp[sindex];\\n            vertices[vindex+1] = vtmp[sindex+1];\\n            vertices[vindex+2] = vtmp[sindex+2];\\n\\n            sindex = v2 * 3;\\n            vertices[vindex+3] = vtmp[sindex];\\n            vertices[vindex+4] = vtmp[sindex+1];\\n            vertices[vindex+5] = vtmp[sindex+2];\\n\\n            sindex = v3 * 3;\\n            vertices[vindex+6] = vtmp[sindex];\\n            vertices[vindex+7] = vtmp[sindex+1];\\n            vertices[vindex+8] = vtmp[sindex+2];\\n\\n            if (externalUVs != null) {\\n                vindex = i * (3 * 2);\\n                externalUVs[vindex] = eUVs[v1*2];\\n                externalUVs[vindex+1] = eUVs[v1*2+1];\\n                externalUVs[vindex+2] = eUVs[v2*2];\\n                externalUVs[vindex+3] = eUVs[v2*2+1];\\n                externalUVs[vindex+4] = eUVs[v3*2];\\n                externalUVs[vindex+5] = eUVs[v3*2+1];\\n            }\\n        }\\n    }\\n\\n    if (onlyExternalIndices) {\\n        vertices = tmpVertices;\\n        externalUVs = tmpExternalUVs;\\n    }\\n\\n    if (onlyInternalIndices) {\\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\\n        internalUVs = tmpInternalUVs;\\n    }\\n\\n    high = 0;\\n\\n    if (internalUVs != null) {\\n        for (i = 0; i < numFaces; i++) {\\n            parseWord(uint8Data, res);\\n            v1 = high - res[0];\\n            if (!res[0]) { high++; }\\n    \\n            parseWord(uint8Data, res);\\n            v2 = high - res[0];\\n            if (!res[0]) { high++; }\\n    \\n            parseWord(uint8Data, res);\\n            v3 = high - res[0];\\n            if (!res[0]) { high++; }\\n\\n            if (onlyInternalIndices) {\\n                vindex = i * 3;\\n\\n                vv1 = indices[vindex] * 3;\\n                vv2 = indices[vindex+1] * 3;\\n                vv3 = indices[vindex+2] * 3;\\n\\n                vertices[v1*3] = vtmp[vv1];\\n                vertices[v1*3+1] = vtmp[vv1+1];\\n                vertices[v1*3+2] = vtmp[vv1+2];\\n\\n                vertices[v2*3] = vtmp[vv2];\\n                vertices[v2*3+1] = vtmp[vv2+1];\\n                vertices[v2*3+2] = vtmp[vv2+2];\\n\\n                vertices[v3*3] = vtmp[vv3];\\n                vertices[v3*3+1] = vtmp[vv3+1];\\n                vertices[v3*3+2] = vtmp[vv3+2];\\n\\n                indices[vindex] = v1;\\n                indices[vindex+1] = v2;\\n                indices[vindex+2] = v3;\\n            } else {\\n                vindex = i * (3 * 2);\\n                internalUVs[vindex] = iUVs[v1*2];\\n                internalUVs[vindex+1] = iUVs[v1*2+1];\\n                internalUVs[vindex+2] = iUVs[v2*2];\\n                internalUVs[vindex+3] = iUVs[v2*2+1];\\n                internalUVs[vindex+4] = iUVs[v3*2];\\n                internalUVs[vindex+5] = iUVs[v3*2+1];\\n            }\\n        }\\n    }\\n\\n    index = res[1];\\n\\n    submesh.vertices = vertices;\\n    submesh.internalUVs = internalUVs;\\n    submesh.externalUVs = externalUVs;\\n    submesh.indices = indices;\\n\\n    //tmpVertices = null;\\n    //tmpInternalUVs = null;\\n    //tmpExternalUVs = null;\\n\\n    stream.index = index;\\n\\n    submesh.size = submesh.vertices.byteLength;\\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\\n    submesh.faces = numFaces;\\n};\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/utils/math.js\\\":\\n/*!********************************!*\\\\\\n  !*** ./src/core/utils/math.js ***!\\n  \\\\********************************/\\n/*! exports provided: math */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"math\\\", function() { return math; });\\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \\\"./src/core/utils/matrix.js\\\");\\n\\n\\n\\n//get rid of compiler mess\\nvar mat4 = _matrix__WEBPACK_IMPORTED_MODULE_0__[\\\"mat4\\\"];\\n\\n\\nvar math = {};\\n\\n\\nmath.isEqual = function(value, value2, delta) {\\n    return (Math.abs(value - value2) < delta);\\n};\\n\\n\\nmath.clamp = function(value, min, max) {\\n    if (value < min) value = min;\\n    else if (value > max) value = max;\\n\\n    return value;\\n};\\n\\n\\nmath.radians = function(degrees) {\\n    return degrees * Math.PI / 180;\\n};\\n\\n\\nmath.degrees = function(radians) {\\n    return (radians / Math.PI) * 180;\\n};\\n\\n\\nmath.mix = function(a, b, c) {\\n    return a + (b - a) * c;\\n};\\n\\n\\nmath.frustumMatrix = function(left, right, bottom, top, near, far) {\\n    var w = (right - left);\\n    var h = (top - bottom);\\n    var d = (far - near);\\n\\n    var m = mat4.create([2*near/w, 0, (right+left)/w, 0,\\n        0, 2*near/h, (top+bottom)/h, 0,\\n        0, 0, -(far+near)/d, -2*far*near/d,\\n        0, 0, -1, 0]);\\n\\n    mat4.transpose(m);\\n    return m;\\n};\\n\\n\\nmath.perspectiveMatrix = function(fovy, aspect, near, far) {\\n    var ymax = near * Math.tan(fovy * Math.PI / 180.0);\\n    var xmax = ymax * aspect;\\n    return math.frustumMatrix(-xmax, xmax, -ymax, ymax, near, far);\\n};\\n\\n\\nmath.orthographicMatrix = function(vsize, aspect, near, far) {\\n    //vsize *= 0.020;\\n    var w = vsize* 0.5 * aspect;\\n    var h = vsize * 0.5;\\n    var d = (far - near);\\n\\n    var m = mat4.create([1/w, 0, 0, 0,\\n        0, 1/h, 0, 0,\\n        0, 0, -2/d, -((far+near)/d),\\n        0, 0, 0, 1]);\\n\\n    mat4.transpose(m);\\n    return m;\\n};\\n\\n\\nmath.rotationMatrix = function(axis, angle) {\\n    var ca = Math.cos(angle), sa = Math.sin(angle);\\n\\n    /*    var m;\\n    switch (axis) {\\n    case 0:\\n        m = [\\n            1,  0,  0, 0,\\n            0, ca,-sa, 0,\\n            0, sa, ca, 0,\\n            0,  0,  0, 1 ];\\n        break;\\n    case 1:\\n        m = [\\n            ca, 0,-sa, 0,\\n            0, 1,  0,  0,\\n            sa, 0, ca, 0,\\n            0, 0,  0, 1 ];\\n        break;\\n    default:\\n        m = [\\n            ca,-sa, 0, 0,\\n            sa, ca, 0, 0,\\n            0,  0,  1, 0,\\n            0,  0,  0, 1 ];\\n        break;\\n    }\\n    mat4.transpose(m);\\n    return m; */\\n\\n    switch (axis) {\\n    case 0:\\n        return [\\n            1,   0,   0,  0,\\n            0,  ca,  sa,  0,\\n            0, -sa,  ca,  0,\\n            0,   0,   0,  1 ];\\n    case 1:\\n        return [\\n             ca,  0,  sa,  0,\\n              0,  1,   0,  0,\\n            -sa,  0,  ca,  0,\\n              0,  0,   0,  1 ];\\n    default:\\n        return [\\n             ca, sa,  0,  0,\\n            -sa, ca,  0,  0,\\n              0,  0,  1,  0,\\n              0,  0,  0,  1 ];\\n    }\\n\\n};\\n\\n\\nmath.scaleMatrix = function(sx, sy, sz) {\\n    /*var m = [\\n        sx,  0,  0, 0,\\n        0, sy,  0, 0,\\n        0,  0, sz, 0,\\n        0,  0,  0, 1 ];\\n\\n    mat4.transpose(m);\\n    return m;*/\\n    return [\\n        sx,   0,   0,   0,\\n        0,   sy,   0,   0,\\n        0,    0,  sz,   0,\\n        0,    0,   0,   1 ];\\n};\\n\\n\\nmath.scaleMatrixf = function(s) {\\n    return math.scaleMatrix(s, s, s);\\n};\\n\\n\\nmath.translationMatrix = function(tx, ty, tz) {\\n    /*\\n    var m = [\\n        1, 0, 0, tx,\\n        0, 1, 0, ty,\\n        0, 0, 1, tz,\\n        0, 0, 0, 1 ];\\n\\n    mat4.transpose(m);\\n    */\\n\\n    return [\\n        1,   0,  0,  0,\\n        0,   1,  0,  0,\\n        0,   0,  1,  0,\\n        tx, ty, tz,  1 ];\\n};\\n\\n\\nmath.translationMatrix2f = function(t) {\\n    return math.translationMatrix(t[0], t[1], 0);\\n};\\n\\n\\nmath.translationMatrix3f = function(t) {\\n    return math.translationMatrix(t[0], t[1], t[2]);\\n};\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/utils/matrix.js\\\":\\n/*!**********************************!*\\\\\\n  !*** ./src/core/utils/matrix.js ***!\\n  \\\\**********************************/\\n/*! exports provided: vec2, vec3, vec4, mat3, mat4 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"vec2\\\", function() { return vec2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"vec3\\\", function() { return vec3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"vec4\\\", function() { return vec4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"mat3\\\", function() { return mat3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"mat4\\\", function() { return mat4; });\\n\\n\\nvar vec2 = {};\\n\\n\\nvec2.create = function (a) {\\n    var b = new Array(2);\\n    if (a) {\\n        b[0] = a[0];\\n        b[1] = a[1];\\n    }\\n    return b;\\n};\\n\\n\\nvar vec4 = {};\\n\\n\\nvec4.create = function (a) {\\n    var b = new Array(4);\\n    if (a) {\\n        b[0] = a[0];\\n        b[1] = a[1];\\n        b[2] = a[2];\\n        b[3] = a[3];\\n    }\\n    return b;\\n};\\n\\n\\nvec4.dot = function (a, b) {\\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\\n};\\n\\n\\nvec4.dot2 = function (a, b) {\\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3];\\n};\\n\\n\\nvec4.dot3 = function (a, b, i, x, y, z) {\\n    return a[0] * (b[i]-x) + a[1] * (b[i+1]-y) + a[2] * (b[i+2]-z) + a[3];\\n};\\n\\n\\nvar vec3 = {};\\n\\n\\nvec3.create = function (a) {\\n    var b = new Array(3);\\n    if (a) {\\n        b[0] = a[0];\\n        b[1] = a[1];\\n        b[2] = a[2];\\n    }\\n    return b;\\n};\\n\\n\\nvec3.set = function (a, b) {\\n    b[0] = a[0];\\n    b[1] = a[1];\\n    b[2] = a[2];\\n    return b;\\n};\\n\\n\\nvec3.add = function (a, b, c) {\\n    if (!c || a == c) {\\n        a[0] += b[0];\\n        a[1] += b[1];\\n        a[2] += b[2];\\n        return a;\\n    }\\n    c[0] = a[0] + b[0];\\n    c[1] = a[1] + b[1];\\n    c[2] = a[2] + b[2];\\n    return c;\\n};\\n\\n\\nvec3.subtract = function (a, b, c) {\\n    if (!c || a == c) {\\n        a[0] -= b[0];\\n        a[1] -= b[1];\\n        a[2] -= b[2];\\n        return a;\\n    }\\n    c[0] = a[0] - b[0];\\n    c[1] = a[1] - b[1];\\n    c[2] = a[2] - b[2];\\n    return c;\\n};\\n\\n\\nvec3.negate = function (a, b) {\\n    b || (b = a);\\n    b[0] = -a[0];\\n    b[1] = -a[1];\\n    b[2] = -a[2];\\n    return b;\\n};\\n\\n\\nvec3.scale = function (a, b, c) {\\n    if (!c || a == c) {\\n        a[0] *= b;\\n        a[1] *= b;\\n        a[2] *= b;\\n        return a;\\n    }\\n    c[0] = a[0] * b;\\n    c[1] = a[1] * b;\\n    c[2] = a[2] * b;\\n    return c;\\n};\\n\\n\\nvec3.normalize = function (a, b) {\\n    b || (b = a);\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = Math.sqrt(c * c + d * d + e * e);\\n    if (g) {\\n        if (g == 1) {\\n            b[0] = c;\\n            b[1] = d;\\n            b[2] = e;\\n            return b;\\n        }\\n    } else {\\n        b[0] = 0;\\n        b[1] = 0;\\n        b[2] = 0;\\n        return b;\\n    }\\n    g = 1 / g;\\n    b[0] = c * g;\\n    b[1] = d * g;\\n    b[2] = e * g;\\n    return b;\\n};\\n\\n\\nvec3.normalize2 = function (a, i, b) {\\n    var c = a[i],\\n        d = a[i+1],\\n        e = a[i+2],\\n        g = Math.sqrt(c * c + d * d + e * e);\\n    if (g) {\\n        if (g == 1) {\\n            b[0] = c;\\n            b[1] = d;\\n            b[2] = e;\\n            return b;\\n        }\\n    } else {\\n        b[0] = 0;\\n        b[1] = 0;\\n        b[2] = 0;\\n        return b;\\n    }\\n    g = 1 / g;\\n    b[0] = c * g;\\n    b[1] = d * g;\\n    b[2] = e * g;\\n};\\n\\n\\nvec3.normalize3 = function (a, i, b, j) {\\n    var c = a[i],\\n        d = a[i+1],\\n        e = a[i+2],\\n        g = Math.sqrt(c * c + d * d + e * e);\\n    if (g) {\\n        if (g == 1) {\\n            b[j] = c;\\n            b[j+1] = d;\\n            b[j+2] = e;\\n            return b;\\n        }\\n    } else {\\n        b[j] = 0;\\n        b[j+1] = 0;\\n        b[j+2] = 0;\\n        return b;\\n    }\\n    g = 1 / g;\\n    b[j] = c * g;\\n    b[j+1] = d * g;\\n    b[j+2] = e * g;\\n};\\n\\n\\nvec3.normalize4 = function (a, b) {\\n    b || (b = a);\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = Math.sqrt(c * c + d * d + e * e);\\n    if (g) {\\n        if (g == 1) {\\n            b[0] = c;\\n            b[1] = d;\\n            b[2] = e;\\n            return b;\\n        }\\n    } else {\\n        b[0] = 0;\\n        b[1] = 0;\\n        b[2] = 0;\\n        return b;\\n    }\\n    var dd = g;\\n    g = 1 / g;\\n    b[0] = c * g;\\n    b[1] = d * g;\\n    b[2] = e * g;\\n    return dd;\\n};\\n\\n\\nvec3.cross = function (a, b, c) {\\n    c || (c = a);\\n    var d = a[0],\\n        e = a[1];\\n    a = a[2];\\n    var g = b[0],\\n        f = b[1];\\n    b = b[2];\\n    c[0] = e * b - a * f;\\n    c[1] = a * g - d * b;\\n    c[2] = d * f - e * g;\\n    return c;\\n};\\n\\n\\nvec3.length = function (a) {\\n    var b = a[0],\\n        c = a[1];\\n    a = a[2];\\n    return Math.sqrt(b * b + c * c + a * a);\\n};\\n\\n\\nvec3.dot = function (a, b) {\\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\\n};\\n\\n\\nvec3.dot2 = function (a, b, i) {\\n    return a[0] * b[i] + a[1] * b[i+1] + a[2] * b[i+2];\\n};\\n\\n\\nvec3.dot3 = function (a, i, b, j) {\\n    return a[i] * b[j] + a[i+1] * b[j+1] + a[i+2] * b[j+2];\\n};\\n\\nvec3.distance = function (a, b) {\\n    var dx = b[0] - a[0];\\n    var dy = b[1] - a[1];\\n    var dz = b[2] - a[2];\\n    return Math.sqrt(dx*dx + dy*dy + dz*dz);\\n};\\n\\nvec3.squareDistance = function (a, b) {\\n    var dx = b[0] - a[0];\\n    var dy = b[1] - a[1];\\n    var dz = b[2] - a[2];\\n    return dx*dx + dy*dy + dz*dz;\\n};\\n\\n\\nvec3.direction = function (a, b, c) {\\n    c || (c = a);\\n    var d = a[0] - b[0],\\n        e = a[1] - b[1];\\n    a = a[2] - b[2];\\n    b = Math.sqrt(d * d + e * e + a * a);\\n    if (!b) {\\n        c[0] = 0;\\n        c[1] = 0;\\n        c[2] = 0;\\n        return c;\\n    }\\n    b = 1 / b;\\n    c[0] = d * b;\\n    c[1] = e * b;\\n    c[2] = a * b;\\n    return c;\\n};\\n\\n\\nvec3.lerp = function (a, b, c, d) {\\n    d || (d = a);\\n    d[0] = a[0] + c * (b[0] - a[0]);\\n    d[1] = a[1] + c * (b[1] - a[1]);\\n    d[2] = a[2] + c * (b[2] - a[2]);\\n    return d;\\n};\\n\\n\\nvec3.str = function (a) {\\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ']';\\n};\\n\\n\\nvar mat3 = {};\\n\\n\\nmat3.create = function (a) {\\n    var b = new Array(9);\\n    if (a) {\\n        b[0] = a[0];\\n        b[1] = a[1];\\n        b[2] = a[2];\\n        b[3] = a[3];\\n        b[4] = a[4];\\n        b[5] = a[5];\\n        b[6] = a[6];\\n        b[7] = a[7];\\n        b[8] = a[8];\\n        b[9] = a[9];\\n    }\\n    return b;\\n};\\n\\n\\nmat3.set = function (a, b) {\\n    b[0] = a[0];\\n    b[1] = a[1];\\n    b[2] = a[2];\\n    b[3] = a[3];\\n    b[4] = a[4];\\n    b[5] = a[5];\\n    b[6] = a[6];\\n    b[7] = a[7];\\n    b[8] = a[8];\\n    return b;\\n};\\n\\n\\nmat3.identity = function (a) {\\n    a[0] = 1;\\n    a[1] = 0;\\n    a[2] = 0;\\n    a[3] = 0;\\n    a[4] = 1;\\n    a[5] = 0;\\n    a[6] = 0;\\n    a[7] = 0;\\n    a[8] = 1;\\n    return a;\\n};\\n\\n\\nmat3.transpose = function (a, b) {\\n    if (!b || a == b) {\\n        var c = a[1],\\n            d = a[2],\\n            e = a[5];\\n        a[1] = a[3];\\n        a[2] = a[6];\\n        a[3] = c;\\n        a[5] = a[7];\\n        a[6] = d;\\n        a[7] = e;\\n        return a;\\n    }\\n    b[0] = a[0];\\n    b[1] = a[3];\\n    b[2] = a[6];\\n    b[3] = a[1];\\n    b[4] = a[4];\\n    b[5] = a[7];\\n    b[6] = a[2];\\n    b[7] = a[5];\\n    b[8] = a[8];\\n    return b;\\n};\\n\\n\\nmat3.toMat4 = function (a, b) {\\n    b || (b = mat4.create());\\n    b[0] = a[0];\\n    b[1] = a[1];\\n    b[2] = a[2];\\n    b[3] = 0;\\n    b[4] = a[3];\\n    b[5] = a[4];\\n    b[6] = a[5];\\n    b[7] = 0;\\n    b[8] = a[6];\\n    b[9] = a[7];\\n    b[10] = a[8];\\n    b[11] = 0;\\n    b[12] = 0;\\n    b[13] = 0;\\n    b[14] = 0;\\n    b[15] = 1;\\n    return b;\\n};\\n\\nmat3.multiplyVec3 = function (a, b, c) {\\n    c || (c = b);\\n    var d = b[0],\\n        e = b[1];\\n    b = b[2];\\n    c[0] = a[0] * d + a[3] * e + a[6] * b;\\n    c[1] = a[1] * d + a[4] * e + a[7] * b;\\n    c[2] = a[2] * d + a[5] * e + a[8] * b;\\n    return c;\\n};\\n\\n\\nmat3.str = function (a) {\\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ']';\\n};\\n\\n\\nvar mat4 = {};\\n\\n\\nmat4.create = function (a) {\\n    var b = new Array(16);\\n    if (a) {\\n        b[0] = a[0];\\n        b[1] = a[1];\\n        b[2] = a[2];\\n        b[3] = a[3];\\n        b[4] = a[4];\\n        b[5] = a[5];\\n        b[6] = a[6];\\n        b[7] = a[7];\\n        b[8] = a[8];\\n        b[9] = a[9];\\n        b[10] = a[10];\\n        b[11] = a[11];\\n        b[12] = a[12];\\n        b[13] = a[13];\\n        b[14] = a[14];\\n        b[15] = a[15];\\n    }\\n    return b;\\n};\\n\\n\\nmat4.set = function (a, b) {\\n    b[0] = a[0];\\n    b[1] = a[1];\\n    b[2] = a[2];\\n    b[3] = a[3];\\n    b[4] = a[4];\\n    b[5] = a[5];\\n    b[6] = a[6];\\n    b[7] = a[7];\\n    b[8] = a[8];\\n    b[9] = a[9];\\n    b[10] = a[10];\\n    b[11] = a[11];\\n    b[12] = a[12];\\n    b[13] = a[13];\\n    b[14] = a[14];\\n    b[15] = a[15];\\n    return b;\\n};\\n\\n\\nmat4.identity = function (a) {\\n    a[0] = 1;\\n    a[1] = 0;\\n    a[2] = 0;\\n    a[3] = 0;\\n    a[4] = 0;\\n    a[5] = 1;\\n    a[6] = 0;\\n    a[7] = 0;\\n    a[8] = 0;\\n    a[9] = 0;\\n    a[10] = 1;\\n    a[11] = 0;\\n    a[12] = 0;\\n    a[13] = 0;\\n    a[14] = 0;\\n    a[15] = 1;\\n    return a;\\n};\\n\\n\\nmat4.transpose = function (a, b) {\\n    if (!b || a == b) {\\n        var c = a[1],\\n            d = a[2],\\n            e = a[3],\\n            g = a[6],\\n            f = a[7],\\n            h = a[11];\\n        a[1] = a[4];\\n        a[2] = a[8];\\n        a[3] = a[12];\\n        a[4] = c;\\n        a[6] = a[9];\\n        a[7] = a[13];\\n        a[8] = d;\\n        a[9] = g;\\n        a[11] = a[14];\\n        a[12] = e;\\n        a[13] = f;\\n        a[14] = h;\\n        return a;\\n    }\\n    b[0] = a[0];\\n    b[1] = a[4];\\n    b[2] = a[8];\\n    b[3] = a[12];\\n    b[4] = a[1];\\n    b[5] = a[5];\\n    b[6] = a[9];\\n    b[7] = a[13];\\n    b[8] = a[2];\\n    b[9] = a[6];\\n    b[10] = a[10];\\n    b[11] = a[14];\\n    b[12] = a[3];\\n    b[13] = a[7];\\n    b[14] = a[11];\\n    b[15] = a[15];\\n    return b;\\n};\\n\\n\\nmat4.determinant = function (a) {\\n    var b = a[0],\\n        c = a[1],\\n        d = a[2],\\n        e = a[3],\\n        g = a[4],\\n        f = a[5],\\n        h = a[6],\\n        i = a[7],\\n        j = a[8],\\n        k = a[9],\\n        l = a[10],\\n        o = a[11],\\n        m = a[12],\\n        n = a[13],\\n        p = a[14];\\n    a = a[15];\\n    return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;\\n};\\n\\n\\nmat4.inverse = function (a, b) {\\n    b || (b = a);\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = a[3],\\n        f = a[4],\\n        h = a[5],\\n        i = a[6],\\n        j = a[7],\\n        k = a[8],\\n        l = a[9],\\n        o = a[10],\\n        m = a[11],\\n        n = a[12],\\n        p = a[13],\\n        r = a[14],\\n        s = a[15],\\n        A = c * h - d * f,\\n        B = c * i - e * f,\\n        t = c * j - g * f,\\n        u = d * i - e * h,\\n        v = d * j - g * h,\\n        w = e * j - g * i,\\n        x = k * p - l * n,\\n        y = k * r - o * n,\\n        z = k * s - m * n,\\n        C = l * r - o * p,\\n        D = l * s - m * p,\\n        E = o * s - m * r,\\n        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);\\n    b[0] = (h * E - i * D + j * C) * q;\\n    b[1] = (-d * E + e * D - g * C) * q;\\n    b[2] = (p * w - r * v + s * u) * q;\\n    b[3] = (-l * w + o * v - m * u) * q;\\n    b[4] = (-f * E + i * z - j * y) * q;\\n    b[5] = (c * E - e * z + g * y) * q;\\n    b[6] = (-n * w + r * t - s * B) * q;\\n    b[7] = (k * w - o * t + m * B) * q;\\n    b[8] = (f * D - h * z + j * x) * q;\\n    b[9] = (-c * D + d * z - g * x) * q;\\n    b[10] = (n * v - p * t + s * A) * q;\\n    b[11] = (-k * v + l * t - m * A) * q;\\n    b[12] = (-f * C + h * y - i * x) * q;\\n    b[13] = (c * C - d * y + e * x) * q;\\n    b[14] = (-n * u + p * B - r * A) * q;\\n    b[15] = (k * u - l * B + o * A) * q;\\n    return b;\\n};\\n\\n\\nmat4.toRotationMat = function (a, b) {\\n    b || (b = mat4.create());\\n    b[0] = a[0];\\n    b[1] = a[1];\\n    b[2] = a[2];\\n    b[3] = a[3];\\n    b[4] = a[4];\\n    b[5] = a[5];\\n    b[6] = a[6];\\n    b[7] = a[7];\\n    b[8] = a[8];\\n    b[9] = a[9];\\n    b[10] = a[10];\\n    b[11] = a[11];\\n    b[12] = 0;\\n    b[13] = 0;\\n    b[14] = 0;\\n    b[15] = 1;\\n    return b;\\n};\\n\\n\\nmat4.toMat3 = function (a, b) {\\n    b || (b = mat3.create());\\n    b[0] = a[0];\\n    b[1] = a[1];\\n    b[2] = a[2];\\n    b[3] = a[4];\\n    b[4] = a[5];\\n    b[5] = a[6];\\n    b[6] = a[8];\\n    b[7] = a[9];\\n    b[8] = a[10];\\n    return b;\\n};\\n\\n\\nmat4.toInverseMat3 = function (a, b) {\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = a[4],\\n        f = a[5],\\n        h = a[6],\\n        i = a[8],\\n        j = a[9],\\n        k = a[10],\\n        l = k * f - h * j,\\n        o = -k * g + h * i,\\n        m = j * g - f * i,\\n        n = c * l + d * o + e * m;\\n    if (!n) return null;\\n    n = 1 / n;\\n    b || (b = mat3.create());\\n    b[0] = l * n;\\n    b[1] = (-k * d + e * j) * n;\\n    b[2] = (h * d - e * f) * n;\\n    b[3] = o * n;\\n    b[4] = (k * c - e * i) * n;\\n    b[5] = (-h * c + e * g) * n;\\n    b[6] = m * n;\\n    b[7] = (-j * c + d * i) * n;\\n    b[8] = (f * c - d * g) * n;\\n    return b;\\n};\\n\\n\\nmat4.multiply = function (a, b, c) {\\n    c || (c = a);\\n    var d = a[0],\\n        e = a[1],\\n        g = a[2],\\n        f = a[3],\\n        h = a[4],\\n        i = a[5],\\n        j = a[6],\\n        k = a[7],\\n        l = a[8],\\n        o = a[9],\\n        m = a[10],\\n        n = a[11],\\n        p = a[12],\\n        r = a[13],\\n        s = a[14];\\n    a = a[15];\\n    var A = b[0],\\n        B = b[1],\\n        t = b[2],\\n        u = b[3],\\n        v = b[4],\\n        w = b[5],\\n        x = b[6],\\n        y = b[7],\\n        z = b[8],\\n        C = b[9],\\n        D = b[10],\\n        E = b[11],\\n        q = b[12],\\n        F = b[13],\\n        G = b[14];\\n    b = b[15];\\n    c[0] = A * d + B * h + t * l + u * p;\\n    c[1] = A * e + B * i + t * o + u * r;\\n    c[2] = A * g + B * j + t * m + u * s;\\n    c[3] = A * f + B * k + t * n + u * a;\\n    c[4] = v * d + w * h + x * l + y * p;\\n    c[5] = v * e + w * i + x * o + y * r;\\n    c[6] = v * g + w * j + x * m + y * s;\\n    c[7] = v * f + w * k + x * n + y * a;\\n    c[8] = z * d + C * h + D * l + E * p;\\n    c[9] = z * e + C * i + D * o + E * r;\\n    c[10] = z *\\n        g + C * j + D * m + E * s;\\n    c[11] = z * f + C * k + D * n + E * a;\\n    c[12] = q * d + F * h + G * l + b * p;\\n    c[13] = q * e + F * i + G * o + b * r;\\n    c[14] = q * g + F * j + G * m + b * s;\\n    c[15] = q * f + F * k + G * n + b * a;\\n    return c;\\n};\\n\\n\\nmat4.multiplyVec3 = function (a, b, c) {\\n    c || (c = b);\\n    var d = b[0],\\n        e = b[1];\\n    b = b[2];\\n    c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];\\n    c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];\\n    c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];\\n    return c;\\n};\\n\\n\\nmat4.multiplyVec4 = function (a, b, c) {\\n    c || (c = b);\\n    var d = b[0],\\n        e = b[1],\\n        g = b[2];\\n    b = b[3];\\n    c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;\\n    c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;\\n    c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;\\n    c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;\\n    return c;\\n};\\n\\n\\nmat4.translate = function (a, b, c) {\\n    var d = b[0],\\n        e = b[1];\\n    b = b[2];\\n    if (!c || a == c) {\\n        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];\\n        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];\\n        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];\\n        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];\\n        return a;\\n    }\\n    var g = a[0],\\n        f = a[1],\\n        h = a[2],\\n        i = a[3],\\n        j = a[4],\\n        k = a[5],\\n        l = a[6],\\n        o = a[7],\\n        m = a[8],\\n        n = a[9],\\n        p = a[10],\\n        r = a[11];\\n    c[0] = g;\\n    c[1] = f;\\n    c[2] = h;\\n    c[3] = i;\\n    c[4] = j;\\n    c[5] = k;\\n    c[6] = l;\\n    c[7] = o;\\n    c[8] = m;\\n    c[9] = n;\\n    c[10] = p;\\n    c[11] = r;\\n    c[12] = g * d + j * e + m * b + a[12];\\n    c[13] = f * d + k * e + n * b + a[13];\\n    c[14] = h * d + l * e + p * b + a[14];\\n    c[15] = i * d + o * e + r * b + a[15];\\n    return c;\\n};\\n\\n\\nmat4.scale = function (a, b, c) {\\n    var d = b[0],\\n        e = b[1];\\n    b = b[2];\\n    if (!c || a == c) {\\n        a[0] *= d;\\n        a[1] *= d;\\n        a[2] *= d;\\n        a[3] *= d;\\n        a[4] *= e;\\n        a[5] *= e;\\n        a[6] *= e;\\n        a[7] *= e;\\n        a[8] *= b;\\n        a[9] *= b;\\n        a[10] *= b;\\n        a[11] *= b;\\n        return a;\\n    }\\n    c[0] = a[0] * d;\\n    c[1] = a[1] * d;\\n    c[2] = a[2] * d;\\n    c[3] = a[3] * d;\\n    c[4] = a[4] * e;\\n    c[5] = a[5] * e;\\n    c[6] = a[6] * e;\\n    c[7] = a[7] * e;\\n    c[8] = a[8] * b;\\n    c[9] = a[9] * b;\\n    c[10] = a[10] * b;\\n    c[11] = a[11] * b;\\n    c[12] = a[12];\\n    c[13] = a[13];\\n    c[14] = a[14];\\n    c[15] = a[15];\\n    return c;\\n};\\n\\n\\nmat4.rotate = function (a, b, c, d) {\\n    var e = c[0],\\n        g = c[1];\\n    c = c[2];\\n    var f = Math.sqrt(e * e + g * g + c * c);\\n    if (!f) return null;\\n    if (f != 1) {\\n        f = 1 / f;\\n        e *= f;\\n        g *= f;\\n        c *= f;\\n    }\\n    var h = Math.sin(b),\\n        i = Math.cos(b),\\n        j = 1 - i;\\n    b = a[0];\\n    f = a[1];\\n    var k = a[2],\\n        l = a[3],\\n        o = a[4],\\n        m = a[5],\\n        n = a[6],\\n        p = a[7],\\n        r = a[8],\\n        s = a[9],\\n        A = a[10],\\n        B = a[11],\\n        t = e * e * j + i,\\n        u = g * e * j + c * h,\\n        v = c * e * j - g * h,\\n        w = e * g * j - c * h,\\n        x = g * g * j + i,\\n        y = c * g * j + e * h,\\n        z = e * c * j + g * h;\\n    e = g * c * j - e * h;\\n    g = c * c * j + i;\\n    if (d) {\\n        if (a != d) {\\n            d[12] = a[12];\\n            d[13] = a[13];\\n            d[14] = a[14];\\n            d[15] = a[15];\\n        }\\n    } else d = a;\\n    d[0] = b * t + o * u + r * v;\\n    d[1] = f * t + m * u + s * v;\\n    d[2] = k * t + n * u + A * v;\\n    d[3] = l * t + p * u + B *\\n        v;\\n    d[4] = b * w + o * x + r * y;\\n    d[5] = f * w + m * x + s * y;\\n    d[6] = k * w + n * x + A * y;\\n    d[7] = l * w + p * x + B * y;\\n    d[8] = b * z + o * e + r * g;\\n    d[9] = f * z + m * e + s * g;\\n    d[10] = k * z + n * e + A * g;\\n    d[11] = l * z + p * e + B * g;\\n    return d;\\n};\\n\\n\\nmat4.rotateX = function (a, b, c) {\\n    var d = Math.sin(b);\\n    b = Math.cos(b);\\n    var e = a[4],\\n        g = a[5],\\n        f = a[6],\\n        h = a[7],\\n        i = a[8],\\n        j = a[9],\\n        k = a[10],\\n        l = a[11];\\n    if (c) {\\n        if (a != c) {\\n            c[0] = a[0];\\n            c[1] = a[1];\\n            c[2] = a[2];\\n            c[3] = a[3];\\n            c[12] = a[12];\\n            c[13] = a[13];\\n            c[14] = a[14];\\n            c[15] = a[15];\\n        }\\n    } else c = a;\\n    c[4] = e * b + i * d;\\n    c[5] = g * b + j * d;\\n    c[6] = f * b + k * d;\\n    c[7] = h * b + l * d;\\n    c[8] = e * -d + i * b;\\n    c[9] = g * -d + j * b;\\n    c[10] = f * -d + k * b;\\n    c[11] = h * -d + l * b;\\n    return c;\\n};\\n\\n\\nmat4.rotateY = function (a, b, c) {\\n    var d = Math.sin(b);\\n    b = Math.cos(b);\\n    var e = a[0],\\n        g = a[1],\\n        f = a[2],\\n        h = a[3],\\n        i = a[8],\\n        j = a[9],\\n        k = a[10],\\n        l = a[11];\\n    if (c) {\\n        if (a != c) {\\n            c[4] = a[4];\\n            c[5] = a[5];\\n            c[6] = a[6];\\n            c[7] = a[7];\\n            c[12] = a[12];\\n            c[13] = a[13];\\n            c[14] = a[14];\\n            c[15] = a[15];\\n        }\\n    } else c = a;\\n    c[0] = e * b + i * -d;\\n    c[1] = g * b + j * -d;\\n    c[2] = f * b + k * -d;\\n    c[3] = h * b + l * -d;\\n    c[8] = e * d + i * b;\\n    c[9] = g * d + j * b;\\n    c[10] = f * d + k * b;\\n    c[11] = h * d + l * b;\\n    return c;\\n};\\n\\n\\nmat4.rotateZ = function (a, b, c) {\\n    var d = Math.sin(b);\\n    b = Math.cos(b);\\n    var e = a[0],\\n        g = a[1],\\n        f = a[2],\\n        h = a[3],\\n        i = a[4],\\n        j = a[5],\\n        k = a[6],\\n        l = a[7];\\n    if (c) {\\n        if (a != c) {\\n            c[8] = a[8];\\n            c[9] = a[9];\\n            c[10] = a[10];\\n            c[11] = a[11];\\n            c[12] = a[12];\\n            c[13] = a[13];\\n            c[14] = a[14];\\n            c[15] = a[15];\\n        }\\n    } else c = a;\\n    c[0] = e * b + i * d;\\n    c[1] = g * b + j * d;\\n    c[2] = f * b + k * d;\\n    c[3] = h * b + l * d;\\n    c[4] = e * -d + i * b;\\n    c[5] = g * -d + j * b;\\n    c[6] = f * -d + k * b;\\n    c[7] = h * -d + l * b;\\n    return c;\\n};\\n\\n\\nmat4.frustum = function (a, b, c, d, e, g, f) {\\n    f || (f = mat4.create());\\n    var h = b - a,\\n        i = d - c,\\n        j = g - e;\\n    f[0] = e * 2 / h;\\n    f[1] = 0;\\n    f[2] = 0;\\n    f[3] = 0;\\n    f[4] = 0;\\n    f[5] = e * 2 / i;\\n    f[6] = 0;\\n    f[7] = 0;\\n    f[8] = (b + a) / h;\\n    f[9] = (d + c) / i;\\n    f[10] = -(g + e) / j;\\n    f[11] = -1;\\n    f[12] = 0;\\n    f[13] = 0;\\n    f[14] = -(g * e * 2) / j;\\n    f[15] = 0;\\n    return f;\\n};\\n\\n\\nmat4.perspective = function (a, b, c, d, e) {\\n    a = c * Math.tan(a * Math.PI / 360);\\n    b = a * b;\\n    return mat4.frustum(-b, b, -a, a, c, d, e);\\n};\\n\\n\\nmat4.ortho = function (a, b, c, d, e, g, f) {\\n    f || (f = mat4.create());\\n    var h = b - a,\\n        i = d - c,\\n        j = g - e;\\n    f[0] = 2 / h;\\n    f[1] = 0;\\n    f[2] = 0;\\n    f[3] = 0;\\n    f[4] = 0;\\n    f[5] = 2 / i;\\n    f[6] = 0;\\n    f[7] = 0;\\n    f[8] = 0;\\n    f[9] = 0;\\n    f[10] = -2 / j;\\n    f[11] = 0;\\n    f[12] = -(a + b) / h;\\n    f[13] = -(d + c) / i;\\n    f[14] = -(g + e) / j;\\n    f[15] = 1;\\n    return f;\\n};\\n\\n\\nmat4.lookAt = function (a, b, c, d) {\\n    d || (d = mat4.create());\\n    var e = a[0],\\n        g = a[1];\\n    a = a[2];\\n    var f = c[0],\\n        h = c[1],\\n        i = c[2];\\n    c = b[1];\\n    var j = b[2];\\n    if (e == b[0] && g == c && a == j) return mat4.identity(d);\\n    var k, l, o, m;\\n    c = e - b[0];\\n    j = g - b[1];\\n    b = a - b[2];\\n    m = 1 / Math.sqrt(c * c + j * j + b * b);\\n    c *= m;\\n    j *= m;\\n    b *= m;\\n    k = h * b - i * j;\\n    i = i * c - f * b;\\n    f = f * j - h * c;\\n    m = Math.sqrt(k * k + i * i + f * f);\\n    if (m) {\\n        m = 1 / m;\\n        k *= m;\\n        i *= m;\\n        f *= m;\\n    } else f = i = k = 0;\\n    h = j * f - b * i;\\n    l = b * k - c * f;\\n    o = c * i - j * k;\\n    m = Math.sqrt(h * h + l * l + o * o);\\n    if (m) {\\n        m = 1 / m;\\n        h *= m;\\n        l *= m;\\n        o *= m;\\n    } else o = l = h = 0;\\n    d[0] = k;\\n    d[1] = h;\\n    d[2] = c;\\n    d[3] = 0;\\n    d[4] = i;\\n    d[5] = l;\\n    d[6] = j;\\n    d[7] = 0;\\n    d[8] = f;\\n    d[9] =\\n        o;\\n    d[10] = b;\\n    d[11] = 0;\\n    d[12] = -(k * e + i * g + f * a);\\n    d[13] = -(h * e + l * g + o * a);\\n    d[14] = -(c * e + j * g + b * a);\\n    d[15] = 1;\\n    return d;\\n};\\n\\n\\nmat4.str = function (a) {\\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ']';\\n};\\n\\n\\nvar quat4 = {};\\n\\n\\nquat4.create = function (a) {\\n    var b = new Array(4);\\n    if (a) {\\n        b[0] = a[0];\\n        b[1] = a[1];\\n        b[2] = a[2];\\n        b[3] = a[3];\\n    }\\n    return b;\\n};\\n\\n\\nquat4.set = function (a, b) {\\n    b[0] = a[0];\\n    b[1] = a[1];\\n    b[2] = a[2];\\n    b[3] = a[3];\\n    return b;\\n};\\n\\n\\nquat4.calculateW = function (a, b) {\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2];\\n    if (!b || a == b) {\\n        a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\\n        return a;\\n    }\\n    b[0] = c;\\n    b[1] = d;\\n    b[2] = e;\\n    b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\\n    return b;\\n};\\n\\n\\nquat4.inverse = function (a, b) {\\n    if (!b || a == b) {\\n        a[0] *= 1;\\n        a[1] *= 1;\\n        a[2] *= 1;\\n        return a;\\n    }\\n    b[0] = -a[0];\\n    b[1] = -a[1];\\n    b[2] = -a[2];\\n    b[3] = a[3];\\n    return b;\\n};\\n\\n\\nquat4.length = function (a) {\\n    var b = a[0],\\n        c = a[1],\\n        d = a[2];\\n    a = a[3];\\n    return Math.sqrt(b * b + c * c + d * d + a * a);\\n};\\n\\n\\nquat4.normalize = function (a, b) {\\n    b || (b = a);\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = a[3],\\n        f = Math.sqrt(c * c + d * d + e * e + g * g);\\n    if (f == 0) {\\n        b[0] = 0;\\n        b[1] = 0;\\n        b[2] = 0;\\n        b[3] = 0;\\n        return b;\\n    }\\n    f = 1 / f;\\n    b[0] = c * f;\\n    b[1] = d * f;\\n    b[2] = e * f;\\n    b[3] = g * f;\\n    return b;\\n};\\n\\n\\nquat4.multiply = function (a, b, c) {\\n    c || (c = a);\\n    var d = a[0],\\n        e = a[1],\\n        g = a[2];\\n    a = a[3];\\n    var f = b[0],\\n        h = b[1],\\n        i = b[2];\\n    b = b[3];\\n    c[0] = d * b + a * f + e * i - g * h;\\n    c[1] = e * b + a * h + g * f - d * i;\\n    c[2] = g * b + a * i + d * h - e * f;\\n    c[3] = a * b - d * f - e * h - g * i;\\n    return c;\\n};\\n\\n\\nquat4.multiplyVec3 = function (a, b, c) {\\n    c || (c = b);\\n    var d = b[0],\\n        e = b[1],\\n        g = b[2];\\n    b = a[0];\\n    var f = a[1],\\n        h = a[2];\\n    a = a[3];\\n    var i = a * d + f * g - h * e,\\n        j = a * e + h * d - b * g,\\n        k = a * g + b * e - f * d;\\n    d = -b * d - f * e - h * g;\\n    c[0] = i * a + d * -b + j * -h - k * -f;\\n    c[1] = j * a + d * -f + k * -b - i * -h;\\n    c[2] = k * a + d * -h + i * -f - j * -b;\\n    return c;\\n};\\n\\n\\nquat4.toMat3 = function (a, b) {\\n    b || (b = mat3.create());\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = a[3],\\n        f = c + c,\\n        h = d + d,\\n        i = e + e,\\n        j = c * f,\\n        k = c * h;\\n    c = c * i;\\n    var l = d * h;\\n    d = d * i;\\n    e = e * i;\\n    f = g * f;\\n    h = g * h;\\n    g = g * i;\\n    b[0] = 1 - (l + e);\\n    b[1] = k - g;\\n    b[2] = c + h;\\n    b[3] = k + g;\\n    b[4] = 1 - (j + e);\\n    b[5] = d - f;\\n    b[6] = c - h;\\n    b[7] = d + f;\\n    b[8] = 1 - (j + l);\\n    return b;\\n};\\n\\n\\nquat4.toMat4 = function (a, b) {\\n    b || (b = mat4.create());\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = a[3],\\n        f = c + c,\\n        h = d + d,\\n        i = e + e,\\n        j = c * f,\\n        k = c * h;\\n    c = c * i;\\n    var l = d * h;\\n    d = d * i;\\n    e = e * i;\\n    f = g * f;\\n    h = g * h;\\n    g = g * i;\\n    b[0] = 1 - (l + e);\\n    b[1] = k - g;\\n    b[2] = c + h;\\n    b[3] = 0;\\n    b[4] = k + g;\\n    b[5] = 1 - (j + e);\\n    b[6] = d - f;\\n    b[7] = 0;\\n    b[8] = c - h;\\n    b[9] = d + f;\\n    b[10] = 1 - (j + l);\\n    b[11] = 0;\\n    b[12] = 0;\\n    b[13] = 0;\\n    b[14] = 0;\\n    b[15] = 1;\\n    return b;\\n};\\n\\n\\nquat4.slerp = function (a, b, c, d) {\\n    d || (d = a);\\n    var e = c;\\n    if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;\\n    d[0] = 1 - c * a[0] + e * b[0];\\n    d[1] = 1 - c * a[1] + e * b[1];\\n    d[2] = 1 - c * a[2] + e * b[2];\\n    d[3] = 1 - c * a[3] + e * b[3];\\n    return d;\\n};\\n\\n\\nquat4.str = function (a) {\\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ']';\\n};\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/utils/url.js\\\":\\n/*!*******************************!*\\\\\\n  !*** ./src/core/utils/url.js ***!\\n  \\\\*******************************/\\n/*! exports provided: utilsUrl */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"utilsUrl\\\", function() { return utilsUrl; });\\n\\nvar utilsUrl = {};\\n\\n\\nutilsUrl.isSameOrigin = function(url) {\\n    if (typeof url !== 'string') {\\n        return false;\\n    }\\n    var docHost = document.location.hostname;\\n    var parser = utilsUrl.parse(url);\\n    return parser['hostname'] === docHost;\\n};\\n\\n\\nutilsUrl.parse = function(url) {\\n    if (typeof url !== 'string') {\\n        return null;\\n    }\\n\\n    var parser = document.createElement('a');\\n    parser['href'] = url;\\n    return parser;\\n};\\n\\n\\nutilsUrl.getParamsFromUrl = function(url) {\\n    var parser = utilsUrl.parse(url);\\n    var queryString = {};\\n    var query = parser['search'].substring(1);\\n    var vars = query.split('&');\\n    if (!(vars.length == 1 && vars[0] == '')) {\\n        for (var i=0; i < vars.length; i++) {\\n            var pair = vars[i].split('=');\\n            if (typeof queryString[pair[0]] === 'undefined') {\\n                queryString[pair[0]] = pair[1];\\n            } else if (typeof queryString[pair[0]] === 'string') {\\n                var arr = [ queryString[pair[0]], pair[1] ];\\n                queryString[pair[0]] = arr;\\n            } else {\\n                queryString[pair[0]].push(pair[1]);\\n            }\\n        }\\n    }\\n    return queryString;\\n};\\n\\n\\nutilsUrl.getHost = function(url) {\\n    var location = document.createElement('a');\\n    location.href = url;\\n    return location.hostname; \\n};\\n\\n\\nutilsUrl.getSchema = function(url) {\\n    //if (window.location.href.indexOf(\\\"file://\\\") != -1) {\\n    if (url.indexOf('http://') != -1) {\\n        return 'http:';\\n    } else if (url.indexOf('https://') != -1) {\\n        return 'https:';\\n    } else {\\n        var location = document.createElement('a');\\n        location.href = url;\\n        return location.protocol;\\n    }\\n};\\n\\n\\nutilsUrl.getOrigin = function(url) {\\n    var location = document.createElement('a');\\n    location.href = url;\\n\\n    if (!location.origin) {  //IE11 hack\\n      return location.protocol + \\\"//\\\" + location.hostname + (location.port ? ':' + location.port: '');\\n    }\\n\\n    return location.origin; \\n};\\n\\n\\nutilsUrl.getBase = function(url) {\\n    return url.split('?')[0].split('/').slice(0, -1).join('/')+'/';\\n};\\n\\n\\nutilsUrl.makeAbsolute = function(href) {\\n    var link = document.createElement(\\\"a\\\");\\n    link.href = href;\\n    return link.href;\\n};\\n\\nutilsUrl.getProcessUrl = function(url, originUrl) {\\n    if (!url || !originUrl) {\\n        return url;\\n    }\\n\\n    url = url.trim();\\n    originUrl= originUrl.trim();\\n    var baseUrl = utilsUrl.getBase(originUrl);\\n    var baseUrlSchema = utilsUrl.getSchema(originUrl);\\n    var baseUrlOrigin = utilsUrl.getOrigin(originUrl); \\n   \\n    if (url.indexOf('://') != -1) { //absolute\\n        return url;\\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\\n        return baseUrlSchema + url;\\n    } else if (url.indexOf('/') == 0) {  //absolute without host\\n        return baseUrlOrigin + url;\\n    } else {  //relative\\n        return baseUrl + url; \\n    }\\n};\\n\\n\\n\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/core/utils/utils.js\\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/core/utils/utils.js ***!\\n  \\\\*********************************/\\n/*! exports provided: utils */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"utils\\\", function() { return utils; });\\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \\\"./src/core/utils/math.js\\\");\\n/* harmony import */ var _url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url */ \\\"./src/core/utils/url.js\\\");\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar math = _math__WEBPACK_IMPORTED_MODULE_0__[\\\"math\\\"];\\nvar utilsUrl = _url__WEBPACK_IMPORTED_MODULE_1__[\\\"utilsUrl\\\"];\\n\\n\\nvar utils = {};\\nutils.useCredentials = false;\\nutils.instanceCounter = 0;\\n\\n\\nutils.validateBool = function(value, defaultValue) {\\n    if (typeof value === 'boolean') {\\n        return value;\\n    } else {\\n        return defaultValue;\\n    }\\n};\\n\\n\\nutils.validateNumber = function(value, minValue, maxValue, defaultValue) {\\n    if (typeof value === 'number') {\\n        return math.clamp(value, minValue, maxValue);\\n    } else {\\n        return defaultValue;\\n    }\\n};\\n\\n\\nutils.validateNumberArray = function(array, arraySize, minValues, maxValues, defaultValues) {\\n    if (Array.isArray(array) && array.length == arraySize) {\\n        for (var i = 0; i < arraySize; i++) {\\n            array[i] = math.clamp(array[i], minValues[i], maxValues[i]);\\n        }\\n        return array;\\n    } else {\\n        return defaultValues;\\n    }\\n};\\n\\n\\nutils.validateString = function(value, defaultValue) {\\n    if (typeof value === 'string') {\\n        return value;\\n    } else {\\n        return defaultValue;\\n    }\\n};\\n\\n\\nutils.padNumber = function(n, width) {\\n    var z = '0';\\n\\n    if (n < 0) {\\n        n = (-n) + '';\\n        width--;     //7\\n        return n.length >= width ? ('-' + n) : '-' + (new Array(width - n.length + 1).join(z) + n);\\n    } else {\\n        n = n + '';\\n        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\\n    }\\n};\\n\\n\\nutils.decodeFloat16 = function(binary) {\\n    var exponent = (binary & 0x7C00) >> 10;\\n    var fraction = binary & 0x03FF;\\n    return (binary >> 15 ? -1 : 1) * (\\n        exponent ?\\n        (\\n            exponent === 0x1F ?\\n            fraction ? NaN : Infinity :\\n            Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\\n        ) :\\n        6.103515625e-5 * (fraction / 0x400)\\n    );\\n};\\n\\n\\nutils.simpleFmtObj = (function obj(str, obj) {\\n    if (!str || str == '') {\\n        return '';\\n    }\\n\\n    return str.replace(/\\\\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\\\\}/g, function(s, match) {\\n        return (match in obj ? obj[match] : s);\\n    });\\n});\\n\\n\\nutils.simpleWikiLinks = (function obj(str, plain) {\\n    if (!str || str == '') {\\n        return '';\\n    }\\n\\n    var str2 = utils.simpleFmtObj(str, {'copy':'&copy;', 'Y': (new Date().getFullYear())}); \\n    \\n    return str2.replace(/\\\\[([^\\\\]]*)\\\\]/g, function(s, match) {\\n        match  = match.trim();\\n        var urls = match.split(' ');//, 1);\\n        \\n        if (urls[0].indexOf('//') != -1) {\\n            if (plain) {\\n                if (urls.length > 1) {\\n                    return '' + match.substring(urls[0].length);\\n                } else {\\n                    return '' + urls[0];\\n                }\\n            } else {\\n                if (urls.length > 1) {\\n                    return '<a href=' + urls[0] + ' target=\\\"blank\\\">' + match.substring(urls[0].length)+'</a>';\\n                } else {\\n                    return '<a href=' + urls[0] + ' target=\\\"blank\\\">' + urls[0]+'</a>';\\n                }\\n            }\\n        }\\n        \\n        return match;\\n    });\\n});\\n\\n\\nutils.simpleFmtObjOrCall = (function obj(str, obj, call) {\\n    if (!str || str == '') {\\n        return '';\\n    }\\n\\n    return str.replace(/\\\\{([$a-zA-Z(-9][$a-zA-Z(-9]*)\\\\}/g, function(s, match) {\\n        return (match in obj ? obj[match] : call(match));\\n    });\\n});\\n\\n\\nutils.getABGRFromHexaCode = (function(code) {\\n    var result = /^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(code);\\n\\n    return result ?\\n    [ parseInt(result[4], 16),\\n        parseInt(result[3], 16),\\n        parseInt(result[2], 16),\\n        parseInt(result[1], 16)]\\n    : [0,0,0,255];\\n});\\n\\n\\nutils.stringifyFunction = (function(fn) {\\n    // Stringify the code\\n    return '(' + fn + ').call(self);';\\n});\\n\\n\\nutils.isPowerOfTwo = (function(value) {\\n    return (value & (value - 1)) === 0 && value !== 0;\\n});\\n\\n\\nutils.nearestPowerOfTwo = (function(value) {\\n    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));\\n});   \\n\\n\\nutils.fitToPowerOfTwo = (function(value) {\\n    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\\n});   \\n\\n\\nutils.getHash = function(str) {\\n    if (!str || str.length === 0) {\\n        return 0;    \\n    }\\n\\n    var hash = 0, c;\\n    for (var i = 0, li = str.length; i < li; i++) {\\n        c   = str.charCodeAt(i);\\n        hash  = ((hash << 5) - hash) + c;\\n        hash |= 0; // Convert to 32bit integer\\n    }\\n\\n    return hash;\\n};\\n\\n\\nutils.convertRGB2YCbCr = function(r, g, b) {\\n  return [( .299 * r + .587 * g  +  0.114 * b) + 0,\\n          ( -.169 * r + -.331 * g +  0.500 * b) + 128,\\n          ( .500 * r + -.419 * g +  -0.081 * b) + 128];\\n};\\n\\n\\nutils.convertYCbCr2RGB = function(y, cb, cr) {\\n  return [1 * y +  0 * (cb-128)      +  1.4 * (cr-128),\\n          1 * y +  -.343 * (cb-128)  +  -.711 * (cr-128),\\n          1 * y +  1.765 * (cb-128)  +  0 * (cr-128)];\\n};\\n\\n\\nutils.convertHSL2RGB = function(h, s, l){\\n   var r, g, b, m, c, x;\\n\\n    h /= 60;\\n    if (h < 0) h = 6 - (-h % 6);\\n    h %= 6;\\n\\n    s = Math.max(0, Math.min(1, s / 100));\\n    l = Math.max(0, Math.min(1, l / 100));\\n\\n    c = (1 - Math.abs((2 * l) - 1)) * s;\\n    x = c * (1 - Math.abs((h % 2) - 1));\\n\\n    if (h < 1) {\\n        r = c, g = x, b = 0;\\n    } else if (h < 2) {\\n        r = x, g = c, b = 0;\\n    } else if (h < 3) {\\n        r = 0, g = c, b = x;\\n    } else if (h < 4) {\\n        r = 0, g = x, b = c;\\n    } else if (h < 5) {\\n        r = x, g = 0, b = c;\\n    } else {\\n        r = c, g = 0, b = x;\\n    }\\n\\n    m = l - c / 2\\n    \\n    return [(r + m),\\n            (g + m),\\n            (b + m)];\\n}\\n\\n\\nutils.getHashColor = function(str) {\\n    var h = utils.getHash(str);\\n    var c = utils.convertRGB2YCbCr(h&255,(h>>8)&255,(h>>16)&255);\\n    c[0] = math.clamp(c[0], 50, 200);\\n    return utils.convertRGB2YCbCr(c[0],c[1],c[2]);\\n};\\n\\n\\nutils.getHashColor2 = function(counter) {\\n    var h = Math.floor(counter / 18);\\n    var l = 50;\\n\\n    if (h >= 1) {\\n        if (h % 2) {\\n            l = 50 + ((l * 10) % 30);\\n        } else {\\n            l = 50 - (((l-1) * 10) % 30);\\n        }\\n     }\\n\\n    h = (counter % 18) * 20;\\n\\n    return utils.convertHSL2RGB(h,100,l);\\n};\\n\\n\\nutils.loadText = function(path, onLoaded, onError, withCredentials, xhrParams) {\\n    utils.loadJSON(path, onLoaded, onError, true, withCredentials, xhrParams);\\n};\\n\\n\\nutils.loadXML = function(path, onLoaded, onError, withCredentials, xhrParams) {\\n    var onLoaded2 = (function(data){\\n        var parser = new DOMParser();\\n        data = parser.parseFromString(data, 'text/xml');\\n        if (onLoaded) {\\n            onLoaded(data);\\n        }\\n    });\\n\\n    utils.loadJSON(path, onLoaded2, onError, true, withCredentials, xhrParams);\\n};\\n\\n\\nutils.loadJSON = function(path, onLoaded, onError, skipParse, withCredentials, xhrParams) {\\n    var xhr = new XMLHttpRequest();\\n\\n    //xhr.onload  = (function() {\\n    xhr.onreadystatechange = (function (){\\n\\n        switch (xhr.readyState) {\\n        case 0 : // UNINITIALIZED\\n        case 1 : // LOADING\\n        case 2 : // LOADED\\n        case 3 : // INTERACTIVE\\n            break;\\n        case 4 : // COMPLETED\\n    \\n            if (xhr.status >= 400 || xhr.status == 0) {\\n                if (onError) {\\n                    onError(xhr.status);\\n                }\\n                break;\\n            }\\n    \\n            var data = xhr.response;\\n            var parsedData = data;\\n                \\n            if (!skipParse) {\\n                try {\\n                        //var parsedData = skipParse ? data : eval(\\\"(\\\"+data+\\\")\\\");\\n                    parsedData = JSON.parse(data);\\n                } catch(e) {\\n                    // eslint-disable-next-line\\n                    console.log('JSON Parse Error ('+path+'): ' + (e['message'] ? e['message'] : ''));\\n                        \\n                    if (onError ) {\\n                        onError(xhr.status);\\n                    }\\n                \\n                    return;\\n                }\\n            }\\n                \\n            if (onLoaded) {\\n                onLoaded(parsedData);\\n            }\\n    \\n            break;\\n        }\\n\\n    }).bind(this);\\n\\n    /*\\n    xhr.onerror  = (function() {\\n        if (onError) {\\n            onError();\\n        }\\n    }).bind(this);*/\\n\\n    xhr.open('GET',  path, true);\\n    xhr.withCredentials = withCredentials;\\n    \\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\\\"tokenHeader\\\"]*/) {\\n        //xhr.setRequestHeader(xhrParams[\\\"tokenHeader\\\"], xhrParams[\\\"token\\\"]); //old way\\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\\n    }\\n\\n    if (xhrParams && xhrParams['charset']) {\\n        xhr.overrideMimeType('text/xml; charset=' + xhrParams['charset']);\\n        //xhr.setRequestHeader('Content-type', xhrParams['Content-type']);\\n    }\\n    \\n    xhr.send('');\\n};\\n\\n\\nutils.loadBinary = function(path, onLoaded, onError, withCredentials, xhrParams, responseType) {\\n    var xhr = new XMLHttpRequest();\\n\\n    xhr.onreadystatechange = (function (){\\n\\n        switch (xhr.readyState) {\\n        case 0 : // UNINITIALIZED\\n        case 1 : // LOADING\\n        case 2 : // LOADED\\n        case 3 : // INTERACTIVE\\n            break;\\n        case 4 : // COMPLETED\\n    \\n            if (xhr.status >= 400 || xhr.status == 0) {\\n                if (onError) {\\n                    onError(xhr.status);\\n                }\\n                break;\\n            }\\n    \\n            var abuffer = xhr.response;\\n                    \\n            if (!abuffer) {\\n                if (onError) {\\n                    onError();\\n                }\\n                break;\\n            }\\n                    \\n                    //if (!responseType || responseType == \\\"arraybuffer\\\") {\\n                        //var data = new DataView(abuffer);\\n                    //} else {\\n                      //  var data = abuffer;\\n                    //}\\n    \\n            if (onLoaded) {\\n                onLoaded(abuffer);\\n            }\\n    \\n            break;\\n    \\n        default:\\n    \\n            if (onError) {\\n                onError();\\n            }\\n    \\n            break;\\n        }\\n\\n    }).bind(this);\\n    \\n    /*\\n    xhr.onerror  = (function() {\\n        if (onError) {\\n            onError();\\n        }\\n    }).bind(this);*/\\n\\n    xhr.open('GET', path, true);\\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\\n    xhr.withCredentials = withCredentials;\\n\\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\\\"tokenHeader\\\"]*/) {\\n        //xhr.setRequestHeader(xhrParams[\\\"tokenHeader\\\"], xhrParams[\\\"token\\\"]); //old way\\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\\n    }\\n\\n    xhr.send('');\\n};\\n\\n\\nutils.headRequest = function(url, onLoaded, onError, withCredentials, xhrParams) { \\n    var xhr = new XMLHttpRequest();\\n\\n    xhr.onreadystatechange = (function (){\\n\\n        switch (xhr.readyState) {\\n        case 0 : // UNINITIALIZED\\n        case 1 : // LOADING\\n        case 2 : // LOADED\\n        case 3 : // INTERACTIVE\\n            break;\\n        case 4 : // COMPLETED\\n            if (onLoaded != null) {\\n                onLoaded(xhr.getAllResponseHeaders(), xhr.status);\\n                    //onLoaded(xhr.getResponseHeader(\\\"X-VE-Tile-Info\\\"), xhr.status);\\n            }\\n            break;\\n    \\n        default:\\n    \\n            if (onError != null) {\\n                onError();\\n            }\\n    \\n            break;\\n        }\\n\\n    }).bind(this);\\n\\n    xhr.onerror  = (function() {\\n        if (onError != null) {\\n            onError();\\n        }\\n    }).bind(this);\\n\\n    xhr.open('HEAD', url, true);\\n    //xhr.responseType = responseType ? responseType : \\\"arraybuffer\\\";\\n    xhr.withCredentials = withCredentials;\\n\\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\\\"tokenHeader\\\"]*/) {\\n        //xhr.setRequestHeader(xhrParams[\\\"tokenHeader\\\"], xhrParams[\\\"token\\\"]); //old way\\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\\n    }\\n\\n    xhr.send('');\\n};\\n\\n\\nutils.loadImage = function(url, onload, onerror, withCredentials, direct) {\\n    var image = new Image();\\n    image.onerror = onerror;\\n    image.onload = onload;\\n\\n    if (!direct){\\n        image.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';\\n    }\\n\\n    image.src = url;\\n    return image;\\n};\\n\\n\\nutils.getParamsFromUrl = function(url) {\\n    return utilsUrl.getParamsFromUrl(url);\\n};\\n\\n\\n//var textDecoderUtf8 = null; //(typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\\nvar textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\\n\\nutils.unint8ArrayToString = function(array) {\\n    if (textDecoderUtf8) {\\n        return textDecoderUtf8.decode(array);\\n    } else {\\n//        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\\n\\n        /*\\n        var buff = new Uint16Array(array.buffer, array.byteOffset, array.byteLength);\\n        var getChar = String.fromCharCode;\\n        //var buff2 = new Array(buff.length);\\n        var str = '';\\n\\n        for (var i = 0, li = buff.length; i < li; i++) {\\n            //buff2[i] = getChar(buff[i]);\\n            str += getChar(buff[i]);\\n        }\\n\\n        return str;\\n        //return buff2.join('');\\n        */\\n\\n        var s = '';\\n        //var code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\\n        var code_points2 = new Uint8Array(array.byteLength);\\n        code_points2.set(array);\\n        var code_points = new Uint32Array(code_points2.buffer);\\n\\n        for (var i = 0, li = code_points.length; i < li; ++i) {\\n          var cp = code_points[i];\\n          if (cp <= 0xFFFF) {\\n            s += String.fromCharCode(cp);\\n          } else {\\n            cp -= 0x10000;\\n            s += String.fromCharCode((cp >> 10) + 0xD800,\\n                                     (cp & 0x3FF) + 0xDC00);\\n          }\\n        }\\n        return s;\\n\\n    }\\n}\\n\\n\\n\\n\\n// only implement if no native implementation is available\\n/*\\nif (typeof Array.isArray === 'undefined') {\\n  Array.isArray = (function(obj) {\\n    return Object.prototype.toString.call(obj) === '[object Array]';\\n  });\\n}*/\\n\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=e3ce97cafed981159c55.worker.js.map\", null);\n};","'use strict';\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};","import Proj4 from 'melowntech-proj4';\nimport Map_ from './map/map';\nimport Inspector_ from './inspector/inspector';\nimport Renderer_ from './renderer/renderer';\nimport RendererInterface_ from './renderer/interface';\nimport MapPosition_ from './map/position';\nimport MapInterface_ from './map/interface';\nimport {utils as utils_} from './utils/utils';\nimport {utilsUrl as utilsUrl_} from './utils/url';\nimport {platform as platform_} from './utils/platform';\n\n//get rid of compiler mess\nvar Map = Map_;\nvar Inspector = Inspector_;\nvar Renderer = Renderer_;\nvar RendererInterface = RendererInterface_;\nvar MapPosition = MapPosition_;\nvar MapInterface = MapInterface_;\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\nvar platform = platform_;\n\n\nvar Core = function(element, config, coreInterface) {\n    var lang = navigator.languages ? navigator.languages[0] : (navigator.language || navigator.userLanguage);\n    this.killed = false;\n    this.config = {\n        map : null,\n        mapCache : 1100, //old value 900\n        mapGPUCache : 600, //old value 500, 360\n        mapMetatileCache : 60,\n        mapTexelSizeFit : 1.1,\n        mapMaxHiresLodLevels : 2,\n        mapDownloadThreads : 20,\n        mapMaxProcessingTime : 10, //1000*20,\n        mapMaxGeodataProcessingTime : 10,\n        mapMobileMode : false,\n        mapMobileModeAutodect : true,\n        mapMobileDetailDegradation : 1,\n        mapNavSamplesPerViewExtent : 4,\n        mapIgnoreNavtiles : false,\n        mapVirtualSurfaces : true,\n        mapAllowHires : true,\n        mapAllowLowres : true,\n        mapAllowSmartSwitching : true,\n        mapDisableCulling : false,\n        mapPreciseCulling : true,\n        mapHeightLodBlend : true,\n        mapHeightNodeBlend : true,\n        mapBasicTileSequence : false,\n        mapPreciseBBoxTest : false,\n        mapPreciseDistanceTest : false,\n        mapHeightfiledWhenUnloaded : true,\n        mapForceMetatileV3 : false,\n        mapSmartNodeParsing : true,\n        mapLoadErrorRetryTime : 3000,\n        mapLoadErrorMaxRetryCount : 3,\n        mapLoadMode : 'topdown', // 'topdown', 'downtop', 'fit', 'fitonly'\n        mapGeodataLoadMode : 'fit', // 'fitonly'\n        mapSplitMeshes : true, // used for topdown load mode\n        mapSplitMargin : 0.0025, // used for topdown load mode\n        mapSplitSpace : null, // used octant spliting demo\n        mapSplitLods : false, // used octant spliting demo\n        mapGridMode : 'linear', // 'flat'\n        mapGridSurrogatez : false,\n        mapGridUnderSurface: 0,\n        mapGridTextureLevel: -1,\n        mapGridTextureLayer: null, // 'bing\",\n        mapXhrImageLoad : true,\n        mapStoreLoadStats : false,\n        mapRefreshCycles : 3,\n        mapSoftViewSwitch : true,\n        mapSortHysteresis : true,\n        mapHysteresisWait : 0,\n        mapSeparateLoader : true,\n        mapGeodataBinaryLoad : true,\n        mapPackLoaderEvents : true,\n        mapParseMeshInWorker : true,\n        mapPackGeodataEvents : true,\n        mapCheckTextureSize : false,\n        mapTraverseToMeshNode : true,\n        mapNormalizeOctantTexelSize : true,\n\n        mapFeatureStickMode : [1,1],\n\n        map16bitMeshes : true,\n        //mapOnlyOneUVs : true,\n        mapOnlyOneUVs : false,\n        mapIndexBuffers : true,\n        mapAsyncImageDecode : true,\n\n        mapFeatureGridCells : 31,\n        mapFeaturesPerSquareInch : 0.25, //0.6614,\n        mapFeaturesSortByTop : false,\n\n        mapFeaturesReduceMode : 'scr-count1', //have to be 'scr-count1' because of legacy https://rigel.mlwn.se/store/map-config/high-terrain/\n        mapFeaturesReduceParams : null,\n        mapFeaturesReduceFactor : 1,\n        mapFeaturesReduceFactor2 : 1,\n\n        mapDMapSize : 1024,\n        mapDMapMode : 1,\n\n        mapDegradeHorizon : false,\n        mapDegradeHorizonParams : [1, 1500, 97500, 3500], //[1, 3000, 15000, 7000],\n        mapDefaultFont : '//cdn.melown.com/libs/vtsjs/fonts/noto-basic/1.0.0/noto.fnt',\n        //mapDefaultFont : '../fonts/basic.fnt',\n        mapFog : true,\n        mapNoTextures: false,\n        mapMetricUnits : !(lang == 'en' || lang.indexOf('en-') == 0),\n        mapLanguage : lang,\n        mapForceFrameTime: 0,\n        mapForcePipeline: 0,\n        mapLogGeodataStyles: true,\n        mapBenevolentMargins: false,\n\n        rendererAnisotropic : 0,\n        rendererAntialiasing : true,\n        rendererAllowScreenshots : false,\n        inspector : true,\n        authorization : null,\n        mario : false\n    };\n\n    this.configStorage = {};\n    this.element = element;\n    this.coreInterface = coreInterface;\n    //this.options = options;\n    this.ready = false;\n    this.listeners = [];\n    this.listenerCounter = 0;\n    this.tokenCookieHost = null;\n    this.tokenIFrame = null;\n    this.xhrParams = {};\n    this.inspector = (Inspector != null) ? (new Inspector(this)) : null;\n    this.setConfigParams(config);\n\n    this.map = null;\n    this.mapInterface = null;\n    this.renderer = new Renderer(this, this.element, null, this.onResize.bind(this), this.config);\n    this.rendererInterface = new RendererInterface(this.renderer);\n    this.proj4 = Proj4;\n    this.contextLost = false;\n\n    //platform detection\n    platform.init();\n    this.requestAnimFrame = (\n               window.requestAnimationFrame ||\n               window.webkitRequestAnimationFrame ||\n               window.mozRequestAnimationFrame ||\n               window.oRequestAnimationFrame ||\n               window.msRequestAnimationFrame ||\n               function(callback) {\n                   window.setTimeout(callback, 1000/60);\n               });\n\n    window.performance = window.performance || {};\n    performance.now = (function() {\n        return performance.now       ||\n               performance.mozNow    ||\n               performance.msNow     ||\n               performance.oNow      ||\n               performance.webkitNow ||\n               function() { return new Date().getTime(); };\n    })();\n\n    this.loadMap(this.config.map);\n\n    this.requestAnimFrame.call(window, this.onUpdate.bind(this));\n};\n\n\nCore.prototype.onResize = function() {\n    if (this.map != null) {\n        this.map.markDirty();\n    }\n};\n\n\nCore.prototype.loadMap = function(path) {\n    if (this.map != null) {\n        this.destroyMap();\n    }\n\n    if (path == null) {\n        return;\n    }\n\n    path = utilsUrl.getProcessUrl(path, window.location.href);\n\n    this.tokenCookieLoaded = true;\n    this.mapConfigData = null;\n    this.tokenExpiration = null;\n    this.tokenExpirationCallback = null;\n    this.tokenExpirationLoop = false;\n    this.tokenCanBeSkiped = true;\n    this.mapRunnig = false;\n\n    var onLoaded = (function() {\n        if (!(this.tokenCookieLoaded || this.tokenCanBeSkiped) || !this.mapConfigData || this.mapRunnig) {\n            return;\n        }\n\n        this.mapRunnig = true;\n        var data = this.mapConfigData;\n\n        this.callListener('map-mapconfig-loaded', data);\n\n        this.map = new Map(this, data, path, this.config, this.configStorage);\n        this.mapInterface = new MapInterface(this.map);\n        this.setConfigParams(this.map.browserOptions, true);\n        this.setConfigParams(this.configStorage);\n\n        if (this.config.position) {\n            this.map.setPosition(this.config.position);\n            this.config.position = null;\n        }\n\n        if (this.config.view) {\n            this.map.setView(this.config.view);\n            this.config.view = null;\n        }\n\n    }).bind(this);\n\n    var onMapConfigLoaded = (function(data) {\n        this.mapConfigData = data;\n        onLoaded();\n    }).bind(this);\n\n    var onMapConfigError = (function() {\n    }).bind(this);\n\n    //this.tokenLoaded = true;\n\n    var onAutorizationLoaded = (function(data) {\n        if (!data || (data && data['status'])) {\n            if (this.tokenCanBeSkiped) {\n                onLoadMapconfig(path);\n            }\n            return;\n        }\n\n        this.tokenLoaded = true;\n        this.xhrParams['token'] = data['token'];\n        this.xhrParams['tokenHeader'] = data['header'];\n        this.tokenExpiration = data['expires'] * 1000;\n        this.tokenExpirationCallback = (function(){\n            //this.tokenLoaded = false;\n            //this.tokenCookieLoaded = false;\n            this.tokenExpiration = null;\n            this.tokenExpirationLoop = true;\n            if (typeof this.config.authorization === 'string') {\n                utils.loadJSON(this.config.authorization, onAutorizationLoaded, onAutorizationError, null, utils.useCredentials, this.xhrParams);\n            } else {\n                this.config.authorization(onAutorizationLoaded);\n            }\n        }).bind(this);\n\n        if (!this.tokenExpirationLoop) {\n            onLoadMapconfig(path);\n        }\n\n        if (typeof this.config.authorization === 'string') {\n            onLoadImageCookie(data['cookieInjector'], this.config.authorization);\n        } else {\n            onLoadImageCookie(data['cookieInjector'], path);\n        }\n\n    }).bind(this);\n\n    var onAutorizationError = (function() {\n        // eslint-disable-next-line\n        console.log('auth token not loaded');\n\n        if (this.tokenCanBeSkiped) {\n            onLoadMapconfig(path);\n        }\n    }).bind(this);\n\n    var onImageCookieLoaded = (function() {\n        document.body.removeChild(this.tokenIFrame);\n        this.tokenIFrame = null;\n        this.tokenCookieLoaded = true;\n        onLoaded();\n    }).bind(this);\n\n    /*var onImageCookieError = (function() {\n        // eslint-disable-next-line\n        console.log('auth cookie not loaded');\n    }).bind(this);*/\n\n    //var baseUrl = path.split('?')[0].split('/').slice(0, -1).join('/')+'/';\n\n    var onLoadMapconfig = (function(path) {\n        utils.loadJSON(path, onMapConfigLoaded, onMapConfigError, null, utils.useCredentials, this.xhrParams);\n    }).bind(this);\n\n    var onLoadImageCookie = (function(url, originUrl) {\n        url = utilsUrl.getProcessUrl(url, originUrl);\n        this.tokenCookieHost = utilsUrl.getHost(url);\n        //utils.loadImage(url, onImageCookieLoaded, onImageCookieError);\n        var iframe = document.createElement('iframe');\n        this.tokenIFrame = iframe;\n        iframe.onload = onImageCookieLoaded;\n        iframe.src = url;\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n    }).bind(this);\n\n    //if (false && this.config.authorization) {\n    if (this.config.authorization) {\n        this.tokenCookieLoaded = false;\n\n        if (typeof this.config.authorization === 'string') {\n            utils.loadJSON(this.config.authorization, onAutorizationLoaded, onAutorizationError, null, utils.useCredentials, this.xhrParams);\n        } else {\n            this.config.authorization(onAutorizationLoaded);\n        }\n    } else {\n        onLoadMapconfig(path);\n    }\n};\n\n\nCore.prototype.destroy = function() {\n    if (this.killed) {\n        return;\n    }\n\n    this.destroyMap();\n    if (this.renderer) {\n        this.renderer.kill();\n    }\n    this.element = null;\n    this.killed = true;\n};\n\n\nCore.prototype.destroyMap = function() {\n    if (this.map) {\n        this.map.kill();\n        this.map = null;\n        this.mapInterface = null;\n        this.callListener('map-unloaded', {});\n    }\n};\n\n\nCore.prototype.getMap = function() {\n    return this.map;\n};\n\n\nCore.prototype.getMapInterface = function() {\n    return this.mapInterface;\n};\n\n\nCore.prototype.getRenderer = function() {\n    return this.renderer;\n};\n\n\nCore.prototype.getRendererInterface = function() {\n    return this.rendererInterface;\n};\n\n\nCore.prototype.getProj4 = function() {\n    return this.proj4;\n};\n\n\nCore.prototype.getOption = function(/*key, value*/) {\n};\n\n\nCore.prototype.setOption = function(/*key, value*/) {\n};\n\n\nCore.prototype.on = function(name, listener, wait, once) {\n    if (this.killed) { // || this.renderer == null) {\n        return;\n    }\n\n    if (listener == null) {\n        return;\n    }\n\n    this.listenerCounter++;\n    this.listeners.push({ name : name, listener : listener, id : this.listenerCounter, once: once, wait: wait ? wait : 0 });\n\n    return (function(id){ this.removeListener(id); }).bind(this, this.listenerCounter);\n};\n\n\nCore.prototype.once = function(name, listener, wait) {\n    this.on(name, listener, wait, true);\n};\n\n\n// private\nCore.prototype.callListener = function(name, event, log) {\n    for (var i = 0; i < this.listeners.length; i++) {\n        if (this.listeners[i].name == name) {\n            var listener = this.listeners[i];\n\n            if (listener.wait > 0) {\n                listener.wait--;\n            } else {\n                listener.listener(event);\n                if (listener.once) {\n                    this.listeners.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n\n    if (log) {\n        // eslint-disable-next-line\n        console.log('event ' + name + ': ' + JSON.stringify(event));\n    }\n};\n\n// private\nCore.prototype.removeListener = function(id) {\n    for (var i = 0; i < this.listeners.length; i++) {\n        if (this.listeners[i].id == id) {\n            //this.listeners[i].splice(i, 1);\n            this.listeners.splice(i, 1);\n            return;\n        }\n    }\n};\n\nCore.prototype.markDirty = function() {\n    if (this.map != null) {\n        this.map.markDirty();\n    }\n};\n\nCore.prototype.onUpdate = function() {\n    if (this.killed || this.contextLost) {\n        return;\n    }\n\n    if (this.map != null) {\n        if (!this.map.srsReady && this.map.isReferenceFrameReady()) {\n            this.map.srsReady = true;\n            this.callListener('map-loaded', { 'browserOptions':this.map.browserOptions});\n        }\n\n        this.map.update();\n    }\n\n    //TODO: detect view change\n    //this.callListener(\"view-update\", {\"position\": position, \"orientaion\":orientation,\n    //                                  \"fov\": renderer.camera.getFov()});\n\n    //this.callListener(\"render-update\", { \"dirty\": true, \"message\": \"DOM element does not exist\" });\n\n    this.callListener('tick', {});\n\n    this.requestAnimFrame.call(window, this.onUpdate.bind(this));\n};\n\n\nCore.prototype.setConfigParams = function(params, solveStorage) {\n    if (typeof params === 'object' && params !== null) {\n        for (var key in params) {\n            this.setConfigParam(key, params[key], solveStorage);\n        }\n    }\n};\n\n\nCore.prototype.setConfigParam = function(key, value, solveStorage) {\n    switch(key) {\n    case 'pos':\n    case 'position':\n    case 'view':\n\n        if (this.getMap()) {\n            if (key == 'view') {\n                this.getMap().setView(value);\n            } else {\n                this.getMap().setPosition(new MapPosition(value));\n            }\n            if (this.configStorage[key]) {\n                delete this.configStorage[key];\n            }\n        } else {\n            this.configStorage[key] = value;\n        }\n        break;\n\n    case 'map':\n        this.config.map = utils.validateString(value, null); break;\n    case 'mapVirtualSurfaces':\n        this.config.mapVirtualSurfaces = utils.validateBool(value, true); break;\n    case 'mapForcePipeline':\n        this.config.mapForcePipeline = utils.validateNumber(value, -1, Number.MAXINTEGER, 0); break;\n    case 'mapDMapSize':\n        this.config.mapDMapSize = utils.validateNumber(value, 16, Number.MAXINTEGER, 512); break;\n    case 'mapDMapMode':\n        this.config.mapDMapMode = utils.validateNumber(value, 1, Number.MAXINTEGER, 1); break;\n    case 'map16bitMeshes':\n        this.config.map16bitMeshes = utils.validateBool(value, false); break;\n    case 'inspector':\n        this.config.inspector = utils.validateBool(value, true); break;\n    case 'authorization':\n        this.config.authorization = ((typeof value === 'string') || (typeof value === 'function')) ? value : null;\n         break;\n    default:\n        if (key.indexOf('map') == 0 || key == 'mario') {\n\n            if (!solveStorage || (typeof this.configStorage[key] === 'undefined')) {\n                this.configStorage[key] = value;\n            }\n\n            if (this.getMap() != null) {\n                this.getMap().setConfigParam(key, value);\n            }\n        }\n\n        if (key.indexOf('renderer') == 0) {\n            if (!solveStorage || (typeof this.configStorage[key] === 'undefined')) {\n                this.configStorage[key] = value;\n            }\n\n            this.setRendererConfigParam(key, value);\n        }\n\n        if (key.indexOf('debug') == 0) {\n            this.configStorage[key] = value;\n            if (this.getMap() != null) {\n                this.inspector.setParameter(key, value);\n            }\n        }\n\n        break;\n    }\n\n};\n\n\nCore.prototype.getConfigParam = function(key) {\n    if (key == 'map') {\n        return this.config.map;\n    } else if (key == 'inspector') {\n        return this.config.inspector;\n    } else {\n        if (key.indexOf('map') == 0 && this.getMap() != null) {\n            return this.getMap().getConfigParam(key);\n        }\n\n        if (key.indexOf('renderer') == 0) {\n            return this.getRendererConfigParam(key);\n        }\n    }\n};\n\n\nCore.prototype.setRendererConfigParam = function(key, value) {\n    switch (key) {\n    case 'rendererAnisotropic':        this.config.rendererAnisotropic = utils.validateNumber(value, -1, 2048, 0); if (this.rederer) this.rederer.gpu.setAniso(this.config.rendererAnisotropic); break;\n    case 'rendererAntialiasing':       this.config.rendererAntialiasing = utils.validateBool(value, true); break;\n    case 'rendererAllowScreenshots':   this.config.rendererAllowScreenshots = utils.validateBool(value, false); break;\n    }\n};\n\n\nCore.prototype.getRendererConfigParam = function(key) {\n    switch (key) {\n    case 'rendererAnisotropic':        return this.config.rendererAnisotropic;\n    case 'rendererAntialiasing':       return this.config.rendererAntialiasing;\n    case 'rendererAllowScreenshots':   return this.config.rendererAllowScreenshots;\n    }\n};\n\n/*\nstring getCoreVersion()\n\n    Returns string with VTS version\n*/\n\nfunction getCoreVersion(full) {\n    return (full ? 'Core: ' : '') + '2.23.9';\n}\n\n\n/*\nbool checkSupport()\n\n    Returns true if the environment is capable of running the WebGL browser, false otherwise.\n*/\n\nfunction checkSupport() {\n    platform.init();\n\n    //is webgl supported\n    var canvas = document.createElement('canvas');\n\n    if (canvas == null) {\n        return false;\n    }\n\n    canvas.width = 1024;\n    canvas.height = 768;\n\n    if (canvas.getContext == null) {\n        return false;\n    }\n\n    var gl = null;\n\n    try {\n        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    } catch(e) {\n        return false;\n    }\n\n    if (!gl) {\n        return false;\n    }\n\n    return true;\n}\n\n\nexport {Core,getCoreVersion,checkSupport};\n","import Proj4 from 'melowntech-proj4';\nimport earcut from 'earcut';\nimport {getCoreVersion as getCoreVersion_, checkSupport as checkSupport_} from './core';\nimport {CoreInterface as CoreInterface_} from './interface';\nimport {vec2 as vec2_, vec3 as vec3_, vec4 as vec4_, mat3 as mat3_, mat4 as mat4_} from './utils/matrix';\nimport {utils as utils_} from './utils/utils';\nimport {math as math_} from './utils/math';\nimport {platform as platform_} from './utils/platform';\n\n//get rid of compiler mess\nvar getCoreVersion = getCoreVersion_, checkSupport = checkSupport_;\nvar CoreInterface = CoreInterface_;\nvar vec2 = vec2_, vec3 = vec3_, vec4 = vec4_, mat3 = mat3_, mat4 = mat4_;\nvar utils = utils_;\nvar math = math_;\nvar proj4 = Proj4;\nvar platform = platform_;\n\n\nfunction core(element, config) {\n    element = (typeof element !== 'string') ? element : document.getElementById(element);\n\n    if (checkSupport()) {\n        return new CoreInterface(element, config);\n    } else {\n        return null;\n    }\n}\n\n\nexport {vec2,vec3,vec4,mat3,mat4,math,utils,getCoreVersion,checkSupport,core,proj4,earcut,platform};\n\n","\nvar InspectorGraphs = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorGraphs.prototype.init = function() {\n    var inspector = this.inspector;\n\n    inspector.addStyle( ''\n        + '#vts-graphs-panel {'\n            + 'position:absolute;'\n            + 'left:10px;'\n            + 'top:10px;'\n            + 'z-index: 7;'\n            + 'background-color: #FFFFFF;'\n            + 'padding: 5px;'\n            + 'border-radius: 4px;'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'color:#000000;'\n            + 'text-align: left;'\n            + 'font-size: 12px;'\n            + 'display:none;'\n        + '}'\n\n        + '.vts-graphs-canvas {'\n            + 'border: solid 1px #bbb;'\n            + 'image-rendering : pixelated;'\n        + '}'\n\n        + '.vts-graphs-info {'\n            + 'padding: 5px 2px;'\n            + 'font-size: 10px;'\n        + '}'\n\n        + '.vts-graphs-button {'\n            + 'padding: 2px 5px;'\n            + 'display:inline-block;'\n            + 'margin-right: 4px;'\n            + 'border-radius: 4px;'\n            + 'cursor:pointer;'\n        + '}'\n\n        + '.vts-graphs-button:hover {'\n            + 'box-shadow: 0 0 1px #0066ff;'\n        + '}'\n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-graphs-panel';\n    this.element.innerHTML = ''\n        + '<canvas id=\"vts-graphs-render\" class=\"vts-graphs-canvas\" width=\"900\" height=\"100\" ></canvas>'\n        + '<div id=\"vts-graphs-info\" class=\"vts-graphs-info\" >&FilledSmallSquare; Frame: 1234 &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Render: 1234 &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Mesh: 1234 &nbsp <span style=\"color:#00bb00\">&FilledSmallSquare;</span> GpuMesh: 1234</div>'\n        + '<canvas id=\"vts-graphs-cache\" class=\"vts-graphs-canvas\" width=\"900\" height=\"100\" ></canvas>'\n        + '<div id=\"vts-graphs-info2\" class=\"vts-graphs-info\" >&FilledSmallSquare; Cache: 1234 &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Used: 123 &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style=\"color:#00bb00\">&FilledSmallSquare;</span> Mesh: &nbsp 1234</div>'\n        + '<div id=\"vts-graphs-rec\" class=\"vts-graphs-button\" >Recording On</div>'\n        + '<div id=\"vts-graphs-ref\" class=\"vts-graphs-button\" >Refresh On</div>'\n        + '<div id=\"vts-graphs-res\" class=\"vts-graphs-button\" >Reset</div>'\n        + '<div id=\"vts-graphs-zoom\" class=\"vts-graphs-button\" >Scale: Max value</div>'\n        + '<div id=\"vts-graphs-magnify\" class=\"vts-graphs-button\" >Magnify Off</div>'\n        + '<div id=\"vts-graphs-graph\" class=\"vts-graphs-button\" >Graph: Cache</div>';\n\n    this.core.element.appendChild(this.element);\n    this.canvasRender = document.getElementById('vts-graphs-render');\n    this.canvasCache = document.getElementById('vts-graphs-cache');\n    this.canvasRenderCtx = this.canvasRender.getContext('2d');\n    this.canvasCacheCtx = this.canvasCache.getContext('2d');\n\n    document.getElementById('vts-graphs-rec').onclick = this.recordingPressed.bind(this);\n\n    document.getElementById('vts-graphs-rec').onclick = this.recordingPressed.bind(this);\n    document.getElementById('vts-graphs-ref').onclick = this.refreshPressed.bind(this);\n    document.getElementById('vts-graphs-res').onclick = this.resetPressed.bind(this);\n    document.getElementById('vts-graphs-zoom').onclick = this.zoomPressed.bind(this);\n    document.getElementById('vts-graphs-magnify').onclick = this.magnifyPressed.bind(this);\n    document.getElementById('vts-graphs-graph').onclick = this.graphPressed.bind(this);\n\n    document.getElementById('vts-graphs-render').onmousemove = this.onMouseMove.bind(this);\n    document.getElementById('vts-graphs-render').onmouseout = this.onMouseOut.bind(this);\n    document.getElementById('vts-graphs-cache').onmousemove = this.onMouseMove.bind(this);\n    document.getElementById('vts-graphs-cache').onmouseout = this.onMouseOut.bind(this);\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.zoom = 'max';\n    this.graph = 'Cache';\n    this.refresh = true;\n\n    this.panelVisible = false;\n};\n\n\nInspectorGraphs.prototype.showPanel = function() {\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n    this.recordingPressed(true);\n};\n\n\nInspectorGraphs.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n    this.recordingPressed(true);\n};\n\n\nInspectorGraphs.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorGraphs.prototype.recordingPressed = function(state) {\n    var map = this.core.getMap();\n\n    if (!map) {\n        return;\n    }\n\n    map.stats.recordGraphs = (state == null) ? state : !map.stats.recordGraphs;\n    this.updateGraphsPanel();\n    this.updateGraphs(null, true);\n};\n\n\nInspectorGraphs.prototype.refreshPressed = function() {\n    this.refresh = !this.refresh;\n    this.updateGraphsPanel();\n    this.updateGraphs();\n};\n\n\nInspectorGraphs.prototype.resetPressed = function() {\n    var map = this.core.getMap();\n\n    if (!map) {\n        return;\n    }\n\n    map.stats.resetGraphs();\n    this.updateGraphs(null, true);\n};\n\n\nInspectorGraphs.prototype.zoomPressed = function() {\n    switch (this.zoom) {\n    case 'max':     this.zoom = '120avrg'; break;\n    case '120avrg': this.zoom = '180avrg'; break;\n    case '180avrg': this.zoom = 'max'; break;\n    }\n\n    this.updateGraphsPanel();\n    this.updateGraphs();\n};\n\n\nInspectorGraphs.prototype.graphPressed = function() {\n    switch (this.graph) {\n    case 'Cache':      this.graph = 'Polygons'; break;\n    case 'Polygons':   this.graph = 'Processing'; break;\n    case 'Processing': this.graph = 'LODs'; break;\n    case 'LODs':       this.graph = 'Flux'; break;\n    case 'Flux':       this.graph = 'Cache'; break;\n    }\n\n    this.updateGraphsPanel();\n    this.updateGraphs();\n};\n\n\nInspectorGraphs.prototype.magnifyPressed = function() {\n    this.magnify = !this.magnify;\n\n    if (this.magnify) {\n        this.canvasRender.style.width = '1400px';\n        this.canvasRender.style.height = '200px';\n        this.canvasCache.style.width = '1400px';\n        this.canvasCache.style.height = '200px';\n        document.getElementById('vts-graphs-magnify').innerHTML = 'Magnify On';\n    } else {\n        this.canvasRender.style.width = '900px';\n        this.canvasRender.style.height = '100px';\n        this.canvasCache.style.width = '900px';\n        this.canvasCache.style.height = '100px';\n        document.getElementById('vts-graphs-magnify').innerHTML = 'Magnify Off';\n    }\n\n    this.updateGraphsPanel();\n    this.updateGraphs();\n};\n\n\nInspectorGraphs.prototype.updateGraphsPanel = function() {\n    var map = this.core.getMap();\n\n    if (!map) {\n        return;\n    }\n\n    if (map.stats.recordGraphs) {\n        document.getElementById('vts-graphs-rec').innerHTML = 'Recording On';\n    } else {\n        document.getElementById('vts-graphs-rec').innerHTML = 'Recording Off';\n    }\n\n    if (this.refresh) {\n        document.getElementById('vts-graphs-ref').innerHTML = 'Refresh On';\n    } else {\n        document.getElementById('vts-graphs-ref').innerHTML = 'Refresh Off';\n    }\n\n    switch (this.zoom) {\n    case 'max':\n        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: Max value';\n        break;\n\n    case '120avrg':\n        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: 100% Avrg';\n        break;\n\n    case '180avrg':\n        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: 50% Avrg';\n        break;\n    }\n\n    document.getElementById('vts-graphs-graph').innerHTML = 'Graph: ' + this.graph;\n};\n\n\nInspectorGraphs.prototype.onMouseMove = function(event) {\n    var x = event.clientX - this.canvasRender.getBoundingClientRect().left;\n    this.showCursor = true;\n\n    if (this.magnify) {\n        x = Math.floor(x * 900/1400);\n    }\n\n    this.cursorIndex = x;\n\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    if (!map.stats.recordGraphs) {\n        this.updateGraphs(null);\n    }\n};\n\n\nInspectorGraphs.prototype.onMouseOut = function() {\n    this.showCursor = false;\n    this.updateGraphs(null);\n};\n\n\nInspectorGraphs.prototype.updateGraphs = function(stats, ignoreRefresh) {\n    var map = this.core.getMap();\n\n    if (!map || (!this.refresh && !ignoreRefresh) || !this.panelVisible) {\n        return;\n    }\n\n    stats = stats || map.stats;\n\n    var width = this.canvasRender.width;\n    var height = this.canvasRender.height;\n    var ctx = this.canvasRenderCtx;\n\n    var samples = stats.graphsTimeSamples;\n    var samplesIndex = stats.graphsTimeIndex;\n\n    var factorX = width / samples;\n\n    ctx.clearRect(0, 0, width, height);\n\n    var maxValue = 0;\n    var totalFrame = 0;\n    var totalRender = 0;\n    var totalTexture = 0;\n    var totalMeshes = 0;\n    var totalGpuMeshes = 0;\n    var realCount = 0, i, j, lj;\n    var index, value, values, str, y, factorY, max, min;\n\n    var valuesFrame = stats.graphsFrameTimes;\n    var valuesRender = stats.graphsRenderTimes;\n    var valuesTextures = stats.graphsCreateTextureTimes;\n    var valuesMeshes = stats.graphsCreateMeshTimes;\n    var valuesGpuMeshes = stats.graphsCreateGpuMeshTimes;\n    var valuesGeodata;\n\n    for (i = 0; i < samples; i++) {\n        totalFrame += valuesFrame[i];\n        totalRender += valuesRender[i];\n        totalTexture += valuesTextures[i];\n        totalMeshes += valuesMeshes[i];\n        totalGpuMeshes += valuesGpuMeshes[i];\n\n        var v = valuesFrame[i];\n\n        if (v > maxValue) {\n            maxValue = v;\n        }\n\n        if (v > 0) {\n            realCount++;\n        }\n    }\n\n    if (this.zoom == '120avrg') {\n        maxValue = (totalFrame / realCount) * 1.0;\n    }\n\n    if (this.zoom == '180avrg') {\n        maxValue = (totalFrame / realCount) * 0.5;\n    }\n\n    factorY = height / maxValue;\n\n    for (i = 0; i < samples; i++) {\n        index = samplesIndex + i;\n        index %= samples;\n\n        ctx.fillStyle='#000000';\n        ctx.fillRect(i*factorX, height, 1, -(valuesFrame[index])*factorY);\n        ctx.fillStyle='#ff0000';\n        ctx.fillRect(i*factorX, height, 1, -(valuesRender[index])*factorY);\n\n        ctx.fillStyle='#0000ff';\n        ctx.fillRect(i*factorX, height, 1, -(valuesTextures[index])*factorY);\n\n        y = height -(valuesTextures[index])*factorY;\n\n        ctx.fillStyle='#007700';\n        ctx.fillRect(i*factorX, y, 1, -(valuesMeshes[index])*factorY);\n\n        y -= (valuesMeshes[index])*factorY;\n\n        ctx.fillStyle='#00ff00';\n        ctx.fillRect(i*factorX, y, 1, -(valuesGpuMeshes[index])*factorY);\n\n    }\n\n    if (this.showCursor) {\n        ctx.fillStyle='#aa00aa';\n        index = (this.cursorIndex) % samples;\n        ctx.fillRect(Math.floor(index*factorX)-1, 0, 1, height);\n        ctx.fillRect(Math.floor(index*factorX)+1, 0, 1, height);\n        index = (this.cursorIndex + samplesIndex) % samples;\n\n        str = '&FilledSmallSquare; Frame: ' + valuesFrame[index].toFixed(2) +\n              ' &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Render: ' + valuesRender[index].toFixed(2) +\n              ' &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Textures: ' + valuesTextures[index].toFixed(2) +\n              ' &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Meshes: ' + valuesMeshes[index].toFixed(2) +\n              ' &nbsp <span style=\"color:#00bb00\">&FilledSmallSquare;</span> GpuMeshes: ' + valuesGpuMeshes[index].toFixed(2) + '</div>';\n    } else {\n        str = '&FilledSmallSquare; Frame: ' + Math.round(totalFrame) +\n              ' &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Render: ' + Math.round(totalRender) +\n              ' &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Textures: ' + Math.round(totalTexture) +\n              ' &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Meshes: ' + Math.round(totalMeshes) +\n              ' &nbsp <span style=\"color:#00bb00\">&FilledSmallSquare;</span> GpuMeshes: ' + Math.round(totalGpuMeshes) +'</div>';\n    }\n\n    document.getElementById('vts-graphs-info').innerHTML = str;\n\n    width = this.canvasCache.width;\n    height = this.canvasCache.height;\n    ctx = this.canvasCacheCtx;\n\n    factorX = width / samples;\n\n    ctx.clearRect(0, 0, width, height);\n\n    switch (this.graph) {\n    case 'Cache':\n        {\n            factorY = height / ((map.gpuCache.maxCost+map.resourcesCache.maxCost+map.metatileCache.maxCost));\n\n            var maxMetatiles = 0;\n            var maxResources = 0;\n            var maxTextures = 0;\n            var maxMeshes = 0;\n            var maxGeodata = 0;\n            var maxGpu = 0;\n\n            var valuesMetatiles = stats.graphsCpuMemoryMetatiles;\n            var valuesResources = stats.graphsCpuMemoryUsed;\n            var valuesGpu = stats.graphsGpuMemoryRender;\n            valuesGeodata = stats.graphsGpuMemoryGeodata;\n            valuesTextures = stats.graphsGpuMemoryTextures;\n            valuesMeshes = stats.graphsGpuMemoryMeshes;\n\n            for (i = 0; i < samples; i++) {\n                maxMetatiles = valuesMetatiles[i] > maxMetatiles ? valuesMetatiles[i] : maxMetatiles;\n                maxResources = valuesResources[i] > maxResources ? valuesResources[i] : maxResources;\n                maxTextures = valuesTextures[i] > maxTextures ? valuesTextures[i] : maxTextures;\n                maxMeshes = valuesMeshes[i] > maxMeshes ? valuesMeshes[i] : maxMeshes;\n                maxGeodata = valuesGeodata[i] > maxGeodata ? valuesGeodata[i] : maxGeodata;\n                maxGpu = valuesGpu[i] > maxGpu ? valuesGpu[i] : maxGpu;\n            }\n\n            for (i = 0; i < samples; i++) {\n                index = samplesIndex + i;\n                index %= samples;\n\n                value = valuesMetatiles[index] + valuesMeshes[index] + valuesTextures[index] + valuesGeodata[index] + valuesResources[index];\n                ctx.fillStyle='#000000';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n                value -= valuesResources[index];\n\n                ctx.fillStyle='#0000ff';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n                value -= valuesTextures[index];\n\n                ctx.fillStyle='#009999';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n                value -= valuesGeodata[index];\n\n                ctx.fillStyle='#007700';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n                value -= valuesMeshes[index];\n\n                ctx.fillStyle='#ff0000';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n\n                value = valuesGpu[index];\n                ctx.fillStyle='#ffff00';\n                ctx.fillRect(i*factorX, height -(value)*factorY, 1, 1);\n            }\n\n            if (this.showCursor) {\n                index = (this.cursorIndex + samplesIndex) % samples;\n                str = '<span style=\"color:#555\">&FilledSmallSquare;</span> Total: ' + Math.ceil((valuesMetatiles[index] + valuesResources[index] + valuesTextures[index] + valuesMeshes[index])/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#000000\">&FilledSmallSquare;</span> CPU: ' + Math.ceil(valuesResources[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#000000\">&FilledSmallSquare;</span> GPU: ' + Math.ceil((valuesTextures[index] + valuesMeshes[index])/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Te: ' + Math.ceil(valuesTextures[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Me: ' + Math.ceil(valuesMeshes[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#009999\">&FilledSmallSquare;</span> Ge: ' + Math.ceil(valuesGeodata[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Met: ' + Math.ceil(valuesMetatiles[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#ffff00\">&FilledSmallSquare;</span> Render: ' + Math.ceil(valuesGpu[index]/(1024*1024)) + 'MB' +'</div>';\n            } else {\n                str = '<span style=\"color:#555\">&FilledSmallSquare;</span> Total: ' + Math.round((maxMetatiles + maxResources + maxTextures + maxMeshes)/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#000000\">&FilledSmallSquare;</span> CPU: ' + Math.ceil(maxResources/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#000000\">&FilledSmallSquare;</span> GPU: ' + Math.ceil((maxTextures + maxMeshes)/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Te ' + Math.ceil(maxTextures/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Me: ' + Math.ceil(maxMeshes/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#009999\">&FilledSmallSquare;</span> Ge: ' + Math.ceil(maxGeodata/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Met: ' + Math.ceil(maxMetatiles/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#ffff00\">&FilledSmallSquare;</span> Render: ' + Math.ceil(maxGpu/(1024*1024)) + 'MB' +'</div>';\n            }\n\n        }\n        break;\n\n\n    case 'Polygons':\n    case 'Processing':\n        {\n            max = 0;\n            min = 99999999999;\n            realCount = 0;\n            values = (this.graph == 'Polygons') ? stats.graphsPolygons : stats.graphsBuild;\n            var total = 0;\n\n            for (i = 0; i < samples; i++) {\n                max = values[i] > max ? values[i] : max;\n\n                if (values[i] > 0) {\n                    min = values[i] < min ? values[i] : min;\n                    total += values[i];\n                    realCount++;\n                }\n            }\n\n            factorY = height / max;\n\n            for (i = 0; i < samples; i++) {\n                index = samplesIndex + i;\n                index %= samples;\n\n                ctx.fillStyle='#007700';\n                ctx.fillRect(i*factorX, height, 1, -(values[index])*factorY);\n            }\n\n            if (this.showCursor) {\n                index = (this.cursorIndex + samplesIndex) % samples;\n                str = '<span style=\"color:#007700\">&FilledSmallSquare;</span> ' + this.graph + ' Max: ' + Math.round(values[index]) +'</div>';\n            } else {\n                str = '<span style=\"color:#007700\">&FilledSmallSquare;</span> ' + this.graph + ' Max: ' + max +'</div>';\n                str += ' &nbsp Min: ' + min;\n                str += ' &nbsp Avrg: ' + Math.round(total / realCount) +'</div>';\n            }\n        }\n        break;\n\n\n    case 'LODs':\n        {\n            max = 0;\n            values = stats.graphsLODs;\n\n            for (i = 0; i < samples; i++) {\n                max = values[i][0] > max ? values[i][0] : max;\n            }\n\n            factorY = height / max;\n\n            ctx.fillStyle='#000000';\n            ctx.fillRect(0, 0, width, height);\n\n            var lods;\n\n            for (i = 0; i < samples; i++) {\n                index = samplesIndex + i;\n                index %= samples;\n\n                //ctx.fillStyle=\"#000000\";\n                //ctx.fillRect(i*factorX, height, 1, -(values[index][0])*factorY);\n\n                y = height;\n                \n                lods = values[index][1]; \n\n                for (j = 0, lj = lods.length; j < lj; j++) {\n                    if (lods[j]) {\n                        ctx.fillStyle='hsl('+((j*23)%360)+',100%,50%)';\n                        value = Math.round((lods[j])*factorY);\n                        ctx.fillRect(i*factorX, y, 1, -value);\n                        y -= value;\n                    }\n                }\n\n            }\n\n            if (this.showCursor) {\n                index = (this.cursorIndex + samplesIndex) % samples;\n\n                str = 'LODs:' + values[index][0];\n                lods = values[index][1]; \n\n                for (j = 0, lj = lods.length; j < lj; j++) {\n                    if (lods[j]) {\n                        str += '<span style=\"color:hsl('+((j*23)%360)+',100%,50%)\">&FilledSmallSquare;</span>'+j+':'+lods[j];\n                    }\n                }\n\n            } else {\n                str = 'LODs:' + values[index][0];\n            }\n\n            str += '</div>';\n        }\n        break;\n\n    case 'Flux':\n        {\n            var maxCount = 0;\n            var maxSize = 0;\n\n            var maxTexPlusCount = 0;\n            var maxTexPlusSize = 0;\n            var maxTexMinusCount = 0;\n            var maxTexMinusSize = 0;\n\n            var maxMeshPlusCount = 0;\n            var maxMeshPlusSize = 0;\n            var maxMeshMinusCount = 0;\n            var maxMeshMinusSize = 0;\n\n            var maxGeodataPlusCount = 0;\n            var maxGeodataPlusSize = 0;\n            var maxGeodataMinusCount = 0;\n            var maxGeodataMinusSize = 0;\n\n            valuesTextures = stats.graphsFluxTextures;\n            valuesMeshes = stats.graphsFluxMeshes;\n            valuesGeodata = stats.graphsFluxGeodatas;\n\n            for (i = 0; i < samples; i++) {\n                var tmp = valuesTextures[i][0][0] + valuesMeshes[i][0][0];\n                maxCount = tmp > maxCount ? tmp : maxCount;\n                tmp = valuesTextures[i][1][0] + valuesMeshes[i][1][0];\n                maxCount = tmp > maxCount ? tmp : maxCount;\n\n                tmp = valuesTextures[i][0][1] + valuesMeshes[i][0][1];\n                maxSize = tmp > maxSize ? tmp : maxSize;\n                tmp = valuesTextures[i][1][1] + valuesMeshes[i][1][1];\n                maxSize = tmp > maxSize ? tmp : maxSize;\n\n                maxTexPlusCount = valuesTextures[i][0][0] > maxTexPlusCount ? valuesTextures[i][0][0] : maxTexPlusCount;\n                maxTexPlusSize = valuesTextures[i][0][1] > maxTexPlusSize ? valuesTextures[i][0][1] : maxTexPlusSize;\n                maxTexMinusCount = valuesTextures[i][1][0] > maxTexMinusCount ? valuesTextures[i][1][0] : maxTexMinusCount;\n                maxTexMinusSize = valuesTextures[i][1][1] ? valuesTextures[i][1][1] : maxTexMinusSize;\n\n                maxMeshPlusCount = valuesMeshes[i][0][0] > maxMeshPlusCount ? valuesMeshes[i][0][0] : maxMeshPlusCount;\n                maxMeshPlusSize = valuesMeshes[i][0][1] > maxMeshPlusSize ? valuesMeshes[i][0][1] : maxMeshPlusSize;\n                maxMeshMinusCount = valuesMeshes[i][1][0] > maxMeshMinusCount ? valuesMeshes[i][1][0] : maxMeshMinusCount;\n                maxMeshMinusSize = valuesMeshes[i][1][1] > maxMeshMinusSize ? valuesMeshes[i][1][1] : maxMeshMinusSize;\n\n                maxGeodataPlusCount = valuesGeodata[i][0][0] > maxGeodataPlusCount ? valuesGeodata[i][0][0] : maxGeodataPlusCount;\n                maxGeodataPlusSize = valuesGeodata[i][0][1] > maxGeodataPlusSize ? valuesGeodata[i][0][1] : maxGeodataPlusSize;\n                maxGeodataMinusCount = valuesGeodata[i][1][0] > maxGeodataMinusCount ? valuesGeodata[i][1][0] : maxGeodataMinusCount;\n                maxGeodataMinusSize = valuesGeodata[i][1][1] > maxGeodataMinusSize ? valuesGeodata[i][1][1] : maxGeodataMinusSize;\n            }\n\n            factorY = (height*0.25-2) / maxCount;\n            var factorY2 = (height*0.25-2) / maxSize;\n\n            var base = Math.floor(height*0.25);\n            var base2 = Math.floor(height*0.75);\n\n            for (i = 0; i < samples; i++) {\n                index = samplesIndex + i;\n                index %= samples;\n                \n                var y1Up = base;\n                var y1Down = base+1;\n                var y2Up = base2;\n                var y2Down = base2+1;\n\n                ctx.fillStyle='#0000aa';\n                ctx.fillRect(i*factorX, y1Up, 1, -(valuesTextures[index][0][0])*factorY);\n                ctx.fillRect(i*factorX, y1Down, 1, (valuesTextures[index][1][0])*factorY);\n\n                ctx.fillRect(i*factorX, y2Up, 1, -(valuesTextures[index][0][1])*factorY2);\n                ctx.fillRect(i*factorX, y2Down, 1, (valuesTextures[index][1][1])*factorY2);\n\n                y1Up -= (valuesTextures[index][0][0])*factorY;\n                y1Down += (valuesTextures[index][1][0])*factorY;\n                y2Up -= (valuesTextures[index][0][1])*factorY2;\n                y2Down += (valuesTextures[index][1][1])*factorY2;\n\n                ctx.fillStyle='#007700';\n                ctx.fillRect(i*factorX, y1Up, 1, -(valuesMeshes[index][0][0])*factorY);\n                ctx.fillRect(i*factorX, y1Down, 1, (valuesMeshes[index][1][0])*factorY);\n\n                ctx.fillRect(i*factorX, y2Up, 1, -(valuesMeshes[index][0][1])*factorY2);\n                ctx.fillRect(i*factorX, y2Down, 1, (valuesMeshes[index][1][1])*factorY2);\n\n                y1Up -= (valuesMeshes[index][0][0])*factorY;\n                y1Down += (valuesMeshes[index][1][0])*factorY;\n                y2Up -= (valuesMeshes[index][0][1])*factorY2;\n                y2Down += (valuesMeshes[index][1][1])*factorY2;\n\n                ctx.fillStyle='#009999';\n                ctx.fillRect(i*factorX, y1Up, 1, -(valuesGeodata[index][0][0])*factorY);\n                ctx.fillRect(i*factorX, y1Down, 1, (valuesGeodata[index][1][0])*factorY);\n\n                ctx.fillRect(i*factorX, y2Up, 1, -(valuesGeodata[index][0][1])*factorY2);\n                ctx.fillRect(i*factorX, y2Down, 1, (valuesGeodata[index][1][1])*factorY2);\n\n                ctx.fillStyle='#aaaaaa';\n                ctx.fillRect(0, Math.floor(height*0.5), width, 1);\n                ctx.fillStyle='#dddddd';\n                ctx.fillRect(0, base, width, 1);\n                ctx.fillRect(0, base2, width, 1);\n            }\n\n\n            if (this.showCursor) {\n                index = (this.cursorIndex + samplesIndex) % samples;\n                str = '<span style=\"color:#007700\">&FilledSmallSquare;</span> Textures Count +/-: ' + valuesTextures[index][0][0] + '/' + valuesTextures[index][1][0];\n                str += ' &nbsp Size +/-: ' + (valuesTextures[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesTextures[index][1][1]/1024/1024).toFixed(2);\n                str += ' &nbsp <span style=\"color:#0000aa\">&FilledSmallSquare;</span> Meshes Count +/-: ' + valuesMeshes[index][0][0] + '/' + valuesMeshes[index][1][0];\n                str += ' &nbsp Size +/-: ' + (valuesMeshes[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesMeshes[index][1][1]/1024/1024).toFixed(2);\n                str += ' &nbsp <span style=\"color:#009999\">&FilledSmallSquare;</span> Geodata Count +/-: ' + valuesGeodata[index][0][0] + '/' + valuesGeodata[index][1][0];\n                str += ' &nbsp Size +/-: ' + (valuesGeodata[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesGeodata[index][1][1]/1024/1024).toFixed(2);\n                str += '</div>';\n            } else {\n                str = '<span style=\"color:#007700\">&FilledSmallSquare;</span> Textures Count +/-: ' + maxTexPlusCount + '/' + maxTexMinusCount;\n                str += ' &nbsp Size +/-: ' + (maxTexPlusSize/1024/1024).toFixed(2) + '/' + (maxTexMinusSize/1024/1024).toFixed(2);\n                str += ' &nbsp <span style=\"color:#0000aa\">&FilledSmallSquare;</span> Meshes Count +/-: ' + maxMeshPlusCount + '/' + maxMeshMinusCount;\n                str += ' &nbsp Size +/-: ' + (maxMeshPlusSize/1024/1024).toFixed(2) + '/' + (maxMeshMinusSize/1024/1024).toFixed(2);\n                str += ' &nbsp <span style=\"color:#009999\">&FilledSmallSquare;</span> Geodata Count +/-: ' + maxGeodataPlusCount + '/' + maxGeodataMinusCount;\n                str += ' &nbsp Size +/-: ' + (maxGeodataPlusSize/1024/1024).toFixed(2) + '/' + (maxGeodataMinusSize/1024/1024).toFixed(2);\n                str += '</div>';\n            }\n\n        }\n        break;\n\n    }\n\n    if (this.showCursor) {\n        ctx.fillStyle='#aa00aa';\n        index = (this.cursorIndex) % samples;\n        ctx.fillRect(Math.floor(index*factorX)-1, 0, 1, height);\n        ctx.fillRect(Math.floor(index*factorX)+1, 0, 1, height);\n    }\n\n    document.getElementById('vts-graphs-info2').innerHTML = str;\n};\n\n\nexport default InspectorGraphs;\n\n","\n\nvar InspectorInput = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorInput.prototype.init = function() {\n    //mouse events\n    //document.addEventListener(\"click\", this.onKeyClick.bind(this), false);\n\n    //keyboard events\n    document.addEventListener('keyup', this.onKeyUp.bind(this), false);\n    document.addEventListener('keypress', this.onKeyPress.bind(this), false);\n    document.addEventListener('keydown', this.onKeyDown.bind(this), false);\n};\n\n\n//keyboard events\nInspectorInput.prototype.onKeyDown = function(event) {\n    if (typeof event == 'undefined') {\n        event = window.event;\n    }\n\n    this.altDown = event.altKey;\n    this.ctrlDown = event.ctrlKey;\n    this.shiftDown = event.shiftKey;\n\n    this.onKeyUp(event, true);\n};\n\n\nInspectorInput.prototype.onKeyPress = function(event) {\n    this.onKeyUp(event, true);\n};\n\n\nInspectorInput.prototype.onKeyUp = function(event, press) {\n    if (typeof event == 'undefined') {\n        event = window.event;\n    }\n\n    var map = this.core.getMap();\n    var inspector = this.inspector;\n\n    if (!map) {\n        return;\n    }\n\n    var debug = map.draw.debug;\n\n    this.altDown = event.altKey;\n    this.ctrlDown = event.ctrlKey;\n    this.shiftDown = event.shiftKey;\n\n    var hit = false;\n    var blockHit = true;\n\n    if (event) {\n        var keyCode;\n\n        if (window.event) {         // eg. IE\n            keyCode = window.event.keyCode;\n        } else if (event.which) {   // eg. Firefox\n            keyCode = event.which;\n        } else {\n            keyCode = event.charCode;\n        }\n\n        if (this.shiftDown) {\n            if (this.ctrlDown) {\n                switch(keyCode) {\n                case 68:\n                case 100:\n                    inspector.preventDefault(event); break;  //key D pressed\n                }\n            }\n        }\n\n        if (this.shiftDown && press !== true) {\n\n            switch(keyCode) {\n            case 76:\n            case 108:\n                /*this.showMenu(); this.toolbarItemSelected('link'); done();*/  break;  //key L pressed\n\n            case 71:\n            case 103:\n                /*this.showMenu(); this.toolbarItemSelected('position'); done();*/ break; //key G pressed\n            }\n\n            if (this.ctrlDown) {\n\n                switch(keyCode) {\n                case 68:\n                case 100:\n                    \n                    inspector.enableInspector();\n                    this.diagnosticMode = true; hit = true; break;  //key D pressed\n                }\n            }\n\n            if (this.diagnosticMode) {\n                blockHit = true;\n\n                switch(keyCode) {\n\n                case 67:\n                case 99:\n                        inspector.shakeCamera = !inspector.shakeCamera;\n\n                        //map.config.mapDegradeHorizon = !map.config.mapDegradeHorizon;\n                        //this.measureMode = !this.measureMode;\n                        //this.measurePoints = [];\n                        //var pos = this.core.hitTest(this.mouseX, this.mouseY, \"all\");\n                        //console.log(\"hit pos: \" + pos[0] + \" \" + pos[1] + \" \" + pos[2] + \" \" + pos[3] + \" d \" + pos[4]); //key T pressed\n\n                    break; //key C pressed\n\n                case 49: /*this.core.setControlMode(\"manual\"); done();*/  break;  //key 1 pressed\n                case 50: /*this.core.setControlMode(\"drone\"); done();*/   break;  //key 2 pressed\n                case 51: /*this.core.setControlMode(\"observer\"); done();*/ break; //key 3 pressed\n\n                case 48:  //key 0 pressed\n                        /*this.core.setOption(\"noForwardMovement\" , !this.core.getOption(\"noForwardMovement\"));*/\n                    break;\n\n                    //case 84: //key T pressed\n                    //case 116:\n                        /*var pos = this.core.hitTest(this.mouseX, this.mouseY, \"all\");\n                        console.log(\"hit pos: \" + pos[0] + \" \" + pos[1] + \" \" + pos[2] + \" \" + pos[3] + \" d \" + pos[4]); //key T pressed\n                        this.core.logTile(pos);*/\n                        //break;\n\n                case 72:\n                case 104:\n                    debug.heightmapOnly = !debug.heightmapOnly;\n\n                        /*\n                        var pos = map.getPosition();\n                        pos.setHeight(pos.setHeight() * 0.9);\n                        map.setPosition(pos);*/\n\n                    break;  //key H pressed\n\n                case 81:\n                case 113:\n                    var pos = map.getPosition();\n                    // eslint-disable-next-line\n                    console.log('pos-before: ' + JSON.stringify(pos.pos));\n                    map.convert.convertPositionViewMode(pos, (pos.getViewMode() == 'obj') ? 'subj' : 'obj');\n                    // eslint-disable-next-line\n                    console.log('new mode: ' + pos.getViewMode());\n                    // eslint-disable-next-line\n                    console.log('pos-after: ' + JSON.stringify(pos.pos));\n                    map.setPosition(pos);\n                    /*this.core.saveScreenshot(pos);*/\n\n                    if (this.altDown && pos.getViewMode() != 'obj') {\n                        map.camera.near = 0.1;\n                    } else {\n                        map.camera.near = 2;\n                    }\n\n                    inspector.preventDefault(event);\n\n                    break;  //key Q pressed\n\n                case 80:\n                case 112:\n                    map.renderer.saveScreenshot('file', 'vts-screenshot.png', 'png'); break;  //key P pressed\n\n                case 83:\n                case 115:\n                    inspector.stats.switchPanel(); break; //key S pressed\n\n                case 86:\n                case 118:\n                    inspector.layers.switchPanel(); break; //key V pressed\n\n                case 69:\n                case 101:\n                    inspector.stylesheets.switchPanel(); break; //key E pressed\n\n                case 84:\n                case 116:\n                    inspector.replay.switchPanel(); break; //key T pressed\n\n                case 66:\n                case 98:\n                    debug.drawBBoxes = !debug.drawBBoxes; break; //key B pressed\n\n                case 65:\n                case 97:\n                    debug.drawLabelBoxes = !debug.drawLabelBoxes; break; //key A pressed\n\n                case 75:\n                case 107:\n                   debug.drawAllLabels = !debug.drawAllLabels; break; //key K pressed\n\n                case 73:\n                case 105:\n                    debug.drawHiddenLabels = !debug.drawHiddenLabels; break; //key I pressed\n                    //debug.drawGridCells = !debug.drawGridCells; break; //key I pressed\n\n                case 87:\n                case 119:\n                    \n                    if (debug.drawWireframe == 3) {\n                        debug.drawWireframe = 1;\n                    } else {\n                        var value = debug.drawWireframe + 1;\n                        debug.drawWireframe = value > 2 ? 0 : value;\n                    }\n                    break; //key W pressed\n\n                case 70:\n                case 102:\n                    debug.drawWireframe = debug.drawWireframe != 3 ? 3 : 0;\n                    break; //key F pressed\n\n                case 85:\n                case 117:\n                    map.renderer.setSuperElevationState(!map.renderer.useSuperElevation);\n                    break; //key U pressed\n\n                case 71:\n                case 103:\n                    debug.meshStats = !debug.meshStats; hit = true;\n                    break; //key G pressed\n\n                case 77:\n                case 109:\n                    map.loaderSuspended = !map.loaderSuspended;            \n                    // eslint-disable-next-line\n                    console.log('loader state ' + map.loaderSuspended);\n\n                    break; //key M pressed\n\n                case 74:\n                case 106:\n                    debug.drawEarth = !debug.drawEarth; hit = true; break; //key J pressed\n\n                case 88:\n                case 120:\n                    debug.drawFog = !debug.drawFog; hit = true; break; //key X pressed\n\n                case 89:\n                case 120:\n                    map.config.mapSplitLods = !map.config.mapSplitLods; hit = true; break; //key Y pressed\n\n                case 82:\n                case 114:\n                    inspector.graphs.switchPanel(); break; //key R pressed\n\n                case 79:\n                case 111:\n                    map.camera.camera.setOrtho(!map.camera.camera.getOrtho()); break; //key O pressed\n\n                case 76:\n                case 108:\n                    inspector.drawRadar = !inspector.drawRadar; break; //key L pressed\n\n                case 90:\n                case 122:\n                    debug.maxZoom = !debug.maxZoom; break; //key Z pressed\n\n                case 78:\n                case 110:\n                    debug.drawNBBoxes = !debug.drawNBBoxes; break; //key N pressed\n\n                default:\n                    blockHit = false;\n                    break;\n\n                }\n\n                if (blockHit) {\n                    hit = true;\n                }\n            }\n        }\n\n        if (this.diagnosticMode && debug.drawWireframe && !press) {\n            if (keyCode >= 96 && keyCode <= 105) {\n                if (this.altDown) {\n                    debug.drawTestData = keyCode - 96;\n                    if (this.ctrlDown) {\n                        debug.drawTestData += 10;\n                    }\n                } else {\n                    debug.drawTestMode = keyCode - 96;\n                }\n\n                hit = true;\n            } \n        }\n\n        if (this.diagnosticMode && inspector.drawRadar && !this.shiftDown && !press) {\n            blockHit = true;\n\n            switch(keyCode) {\n            case 43:\n            case 107:\n                if (inspector.radarLod == null) { inspector.radarLod = 8;}\n                inspector.radarLod++; /*console.log(\"radarLOD: \" + this.radarLod);*/ break; //key mun + pressed\n\n            case 45:\n            case 109:\n                if (inspector.radarLod == null) { inspector.radarLod = 8;}\n                inspector.radarLod = Math.max(0,inspector.radarLod-1); /*console.log(\"radarLOD: \" + this.radarLod);*/ break; //key mun - pressed\n\n            case 42:\n            case 106:\n                inspector.radarLod = null; /*console.log(\"radarLOD: auto\");*/ break; //key mun * pressed\n\n            default:\n                blockHit = false;\n                break;\n            }\n\n            if (blockHit) {\n                hit = true;\n            }\n        }\n\n        if (this.diagnosticMode && (debug.drawBBoxes || debug.drawNBBoxes) && !this.shiftDown && !press) {\n            blockHit = true;\n\n            switch(keyCode) {\n            case 76:\n            case 108:\n                debug.drawLods = !debug.drawLods; break; //key L pressed\n\n            case 80:\n            case 112:\n                debug.drawPositions = !debug.drawPositions; break; //key P pressed\n\n            case 85:\n            case 117:\n                debug.drawOctants = !debug.drawOctants; break;  //key U pressed\n\n            case 84:\n            case 116:\n                debug.drawTextureSize = !debug.drawTextureSize; break; //key T pressed\n\n            case 70:\n            case 102:\n                debug.drawFaceCount = !debug.drawFaceCount; break; //key F pressed\n\n            case 71:\n            case 103:\n                debug.drawGeodataOnly = !debug.drawGeodataOnly; break; //key G pressed\n\n            case 68:\n            case 100:\n                debug.drawDistance = !debug.drawDistance; break; //key D pressed\n\n            case 86:\n            case 118:\n                debug.drawSpaceBBox = !debug.drawSpaceBBox; break; //key V pressed\n\n            case 78:\n            case 110:\n                debug.drawNodeInfo = !debug.drawNodeInfo; break; //key N pressed\n\n            case 77:\n            case 109:\n                debug.drawMeshBBox = !debug.drawMeshBBox; break; //key M pressed\n\n            case 73:\n            case 105:\n                debug.drawIndices = !debug.drawIndices; break; //key I pressed\n\n            case 66:\n            case 98:\n                debug.drawBoundLayers = !debug.drawBoundLayers; break; //key B pressed\n\n            case 82:\n            case 114:\n                debug.drawResources = !debug.drawResources; break; //key R pressed\n\n            case 83:\n            case 115:\n                debug.drawSurfaces = !debug.drawSurfaces; break; //key S pressed\n\n            case 90:\n            case 122:\n                debug.drawSurfaces2 = !debug.drawSurfaces2; break; //key Z pressed\n\n            case 67:\n            case 99:\n                debug.drawCredits = !debug.drawCredits; break; //key C pressed\n\n            case 79:\n            case 111:\n                debug.drawOrder = !debug.drawOrder; break; //key O pressed\n\n            case 69:\n            case 101:\n                debug.debugTextSize = (debug.debugTextSize == 2.0) ? 3.0 : 2.0; break; //key E pressed\n\n            case 88:\n            case 120:\n                map.config.mapPreciseBBoxTest = !map.config.mapPreciseBBoxTest; break; //key X pressed\n\n            case 87:\n            case 119:\n                debug.drawPolyWires = !debug.drawPolyWires; break; //key W pressed\n\n            case 90:\n            case 122:\n                map.config.mapPreciseDistanceTest = !map.config.mapPreciseDistanceTest; break; //key Z pressed\n\n            case 75:\n            case 107:\n                debug.drawGPixelSize = !debug.drawGPixelSize; break; //key K pressed\n\n            default:\n                blockHit = false;\n                break;\n            }\n\n            if (blockHit) {\n                hit = true;\n            }\n        }\n\n    }\n\n    if (hit) {\n        map.markDirty();\n        inspector.preventDefault(event);\n    }\n\n    //console.log(\"key\" + keyCode);\n};\n\n\nInspectorInput.prototype.setParameter = function(key, value) {\n    var map = this.core.getMap();\n    var inspector = this.inspector;\n\n    if (!map) {\n        return;\n    }\n\n    var debug = map.draw.debug;\n    var getBool = (function(a){ return (value === true || value == 'true' || value == '1') });\n\n    switch(key) {\n        case 'debugMode': this.diagnosticMode = true; break;\n        case 'debugBBox':\n            debug.drawBBoxes = true;\n        case 'debugNBBox':\n            if (key == 'debugNBBox') debug.drawNBBoxes = true;\n            var has = (function(a){ return (value.indexOf(a)!=-1); });\n            if (has('L')) debug.drawLods = true;\n            if (has('P')) debug.drawPositions = true;\n            if (has('T')) debug.drawTextureSize = true;\n            if (has('F')) debug.drawFaceCount = true;\n            if (has('G')) debug.drawGeodataOnly = true;\n            if (has('D')) debug.drawDistance = true;\n            if (has('N')) debug.drawNodeInfo = true;\n            if (has('V')) debug.drawSpaceBBox = true;\n            if (has('M')) debug.drawMeshBBox = true;\n            if (has('I')) debug.drawIndices = true;\n            if (has('U')) debug.drawOctants = true;\n            if (has('B')) debug.drawBoundLayers = true;\n            if (has('S')) debug.drawSurfaces = true;\n            if (has('Z')) debug.drawSurfaces2 = true;\n            if (has('C')) debug.drawCredits = true;\n            if (has('O')) debug.drawOrder = true;\n            if (has('E')) debug.debugTextSize = 3.0;\n            if (has('K')) debug.drawGPixelSize = true;\n            break;\n        case 'debugLBox': debug.drawLabelBoxes = getBool(value); break;\n        case 'debugNoEarth': debug.drawEarth = !getBool(value); break;\n        case 'debugShader': debug.drawWireframe = parseInt(value); break;\n        case 'debugHeightmap': debug.heightmapOnly = getBool(value); break;\n        case 'debugGridCells': debug.drawGridCells = getBool(value); break;\n        case 'debugRadar':\n            inspector.enableInspector();\n            inspector.drawRadar = true;\n            inspector.radarLod = parseInt(value);\n            if (isNaN(inspector.radarLod)) {\n                inspector.radarLod = null;\n            } \n            break;\n\n    }\n\n    map.markDirty();\n};\n\nexport default InspectorInput;\n\n","\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport {utils as utils_} from '../utils/utils';\nimport InspectorInput_ from './input';\nimport InspectorStats_ from './stats';\nimport InspectorGraphs_ from './graphs';\nimport InspectorLayers_ from './layers';\nimport InspectorReplay_ from './replay';\nimport InspectorStylesheets_ from './stylesheets';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\nvar math = math_;\nvar utils = utils_;\nvar InspectorInput = InspectorInput_;\nvar InspectorStats = InspectorStats_;\nvar InspectorGraphs = InspectorGraphs_;\nvar InspectorLayers = InspectorLayers_;\nvar InspectorReplay = InspectorReplay_;\nvar InspectorStylesheets = InspectorStylesheets_;\n\n\nvar Inspector = function(core) {\n    this.core = core;\n    this.enabled = false;\n    this.input = new InspectorInput(this);\n    this.stats = new InspectorStats(this);\n    this.graphs = new InspectorGraphs(this);\n    this.layers = new InspectorLayers(this);\n    this.replay = new InspectorReplay(this);\n    this.stylesheets = new InspectorStylesheets(this);\n\n    if (this.core.config.inspector) {\n        this.input.init();\n    }\n\n    this.shakeCamera = false; \n    this.drawReplayCamera = false; \n    this.drawRadar = false;\n    this.radarLod = null;\n    this.debugValue = 0;\n    this.measureMode = false;\n    this.measurePoints = [];\n};\n\n\nInspector.prototype.enableInspector = function() {\n    if (!this.enabled) {\n        this.stats.init();\n        this.graphs.init();\n        this.layers.init();\n        this.replay.init();\n        this.stylesheets.init();\n\n        //load image    \n        if (!this.circleImage) {\n            this.circleImage = utils.loadImage(\n                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QAAAAAAAD5Q7t/AAAACW9GRnMAAAAgAAAA4ACD+EAUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVRYw+2VPwqDMBTG3dz1Am56EnH2XLroETxGuwc3Z7cOdhY8QJpfSUBspUvStJAPPggvD973/uQligICAgL+DKViqygUV02hbaXLwJlio7gpyhNu2idzEXwwgfI8H+u6vnZdN/V9P3EuimLcCRlsiyArGcfxjWDLsmzyAGzc4aNFNDZ7/iw7AeQH4LNrh5WZYLgkJTaZCyHuVVVdkiSZ0zSdOWMzlaBFWkRrQ4A4Zk/A4wBie1MFYUMAz0wybCYAmR8FUAlzj6+2r18TgM2VAO8tOB1Cyk7mrofQ+zP0voheVjHtIBjDxjrmvCu7k1Xs/TP6ie84ICDAGR5uCYdPo0MWiAAAAABJRU5ErkJggg==',\n                    //\"http://maps.google.com/mapfiles/kml/shapes/placemarkcircle.png\",\n                    (function(){\n                        this.circleTexture = this.core.getRendererInterface().createTexture({ 'source': this.circleImage });\n                    }).bind(this)\n                );\n        }\n\n        this.core.on('map-update', this.onMapUpdate.bind(this));\n        this.enabled = true;\n    }\n};\n\n\nInspector.prototype.setParameter = function(key, value) {\n    this.input.setParameter(key, value);\n};\n\nInspector.prototype.addStyle = function(string) {\n    var style = document.createElement('style');\n    style.type = 'text/css';\n    style.innerHTML = string;\n    document.getElementsByTagName('head')[0].appendChild(style);\n};\n\n\n//used to block mouse events\nInspector.prototype.doNothing = function(e) {\n    e.stopPropagation();\n    return false;\n};\n\n\nInspector.prototype.preventDefault = function(e) {\n    if (e.preventDefault) {\n        e.preventDefault();\n    } else {\n        e.returnValue = false;\n    }\n};\n\n\nInspector.prototype.onMapUpdate = function() {\n    var map = this.core.getMapInterface();\n    if (!map) {\n        return;\n    }\n\n    if (this.shakeCamera) {\n        map.redraw();\n    } \n\n    /*if (this.measureMode) {\n        var renderer = this.core.getRenderer();\n        var p = map.convertCoordsFromPhysToNav(this.measurePoints[0]);\n        map.convertCoordsFromPhysToCanvas(this.measurePoints[0]);\n    }*/\n\n    var renderer = this.core.getRendererInterface(), i, li, j, lj, lines, slines, p;\n\n    if (this.replay.drawGlobe) {\n        p = map.convertCoordsFromPhysToCameraSpace([0,0,0]);\n        var renderer2 = this.core.getRenderer();\n        renderer2.draw.drawTBall(p, 12742000 * 0.5, renderer2.progStardome, this.replay.globeTexture, 12742000 * 0.5, true);\n    }\n\n    if (this.replay.drawCamera) {\n        lines = this.replay.cameraLines;\n        slines = []; \n        //for (i = 0, li = lines.length; i < li; i++) {\n          //  slines.push(map.convertCoordsFromPhysToCanvas(lines[i]));\n        //}\n        \n        renderer.drawLineString({\n            points : lines,\n            size : 2.0,\n            color : [0,128,255,255],\n            depthTest : false,\n            screenSpace : false,\n            blend : false\n        });            \n\n        lines = this.replay.cameraLines3;\n        for (i = 0, li = lines.length; i < li; i++) {\n            slines = []; \n            for (j = 0, lj = lines[i].length; j < lj; j++) {\n                //slines.push(map.convertCoordsFromPhysToCanvas(lines[i][j]));\n                slines.push(lines[i][j]);\n            }\n\n            renderer.drawLineString({\n                points : slines,\n                size : 2.0,\n                color : [0,255,128,255],\n                depthTest : false,\n                screenSpace : false,\n                blend : false\n            });   \n        }\n\n        lines = this.replay.cameraLines2;\n        for (i = 0, li = lines.length; i < li; i++) {\n            slines = []; \n            for (j = 0, lj = lines[i].length; j < lj; j++) {\n                //slines.push(map.convertCoordsFromPhysToCanvas(lines[i][j]));\n                slines.push(lines[i][j]);\n            }\n\n            renderer.drawLineString({\n                points : slines,\n                size : 2.0,\n                color : [0,255,255,255],\n                depthTest : false,\n                screenSpace : false,\n                blend : false\n            });   \n        }\n\n\n        var cameInfo = map.getCameraInfo();\n        var p1 = map.convertCoordsFromPhysToCameraSpace(this.replay.cameraLines[0]);\n\n        //var map2 = this.core.getMap();\n    \n        //var m2 = map2.camera.getRotationviewMatrix();\n        var mv = mat4.create(this.replay.cameraMatrix);\n        //mat4.inverse(m2, mv);\n    \n        //matrix which tranforms mesh position and scale\n        /*\n        var mv = [\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            p1[0], p1[1], p1[2], 1\n        ];*/\n        mv[12] = p1[0];\n        mv[13] = p1[1];\n        mv[14] = p1[2];\n    \n        //setup material \n        var material = [ \n            255,128,128, 0, //ambient,\n            0,0,0,0, //diffuse\n            0,0,0,0, //specular \n            0,0.5,0,0 //shininess, alpha,0,0\n        ];\n    \n        //multiply cube matrix with camera view matrix\n        mat4.multiply(cameInfo.viewMatrix, mv, mv);\n    \n        var norm = [\n            0,0,0,\n            0,0,0,\n            0,0,0\n        ];\n    \n        //normal transformation matrix\n        mat4.toInverseMat3(mv, norm);\n    \n        renderer.setState(this.replay.frustumState);\n    \n        //draw cube\n        renderer.drawMesh({\n            mesh : this.replay.frustumMesh,\n            texture : null,\n            shader : 'shaded',\n            shaderVariables : {\n                'uMV' : ['mat4', mv],\n                'uNorm' : ['mat3', norm],\n                'uMaterial' : ['mat4', material]\n            }\n        });\n    }\n    \n    if (this.drawRadar && this.circleTexture) {\n        //var renderer = this.core.getRendererInterface();\n        var pos = map.getPosition();\n        var count = 16;\n        var step = pos.getViewExtent() / (count * 4);\n\n        var cbuffer = new Array(count * count);\n\n/*        \n        var coords = pos.getCoords();\n\n        for (var j = 0; j < count; j++) {\n            for (var i = 0; i < count; i++) {\n                var screenCoords = map.convertCoordsFromNavToCanvas([coords[0] + i*step - count*0.5*step,\n                                                                       coords[1] + j*step - count*0.5*step, 0], \"float\", this.radarLod);\n        \n                cbuffer[j * count + i] = screenCoords;\n            }            \n        }\n*/\n\n\n        for (j = 0; j < count; j++) {\n            for (i = 0; i < count; i++) {\n                var dx =  i*step - count*0.5*step;\n                var dy =  j*step - count*0.5*step;\n                var a = Math.atan2(dy, dx);\n                var l = Math.sqrt(dx*dx + dy*dy);\n\n                var pos2 = map.movePositionCoordsTo(pos, math.degrees(a), l);\n                var coords = pos2.getCoords();\n                \n                var screenCoords = map.convertCoordsFromNavToCanvas([coords[0], coords[1], 0], 'float', this.radarLod);\n\n                cbuffer[j * count + i] = screenCoords;\n            }            \n        }\n\n\n        var lbuffer = new Array(count);\n\n        for (j = 0; j < count; j++) {\n            for (i = 0; i < count; i++) {\n                lbuffer[i] =  cbuffer[j * count + i];\n            }\n            \n            renderer.drawLineString({\n                points : lbuffer,\n                size : 2.0,\n                screenSpace : true,\n                color : [0,255,255,255],\n                depthTest : false,\n                blend : false\n            });            \n        }\n\n\n        for (i = 0; i < count; i++) {\n            for (j = 0; j < count; j++) {\n                lbuffer[j] =  cbuffer[j * count + i];\n            }\n            \n            renderer.drawLineString({\n                points : lbuffer,\n                size : 2.0,\n                screenSpace : true,\n                color : [0,255,255,255],\n                depthTest : false,\n                blend : false\n            });            \n        }\n\n        for (i = 0, li = cbuffer.length; i < li; i++) {\n            p = cbuffer[i];\n            renderer.drawImage({\n                rect : [p[0]-10, p[1]-10, 20, 20],\n                texture : this.circleTexture,\n                color : [255,0,255,255],\n                depth : p[2],\n                depthTest : false,\n                blend : true\n            });\n        }\n    }\n};\n\n\nexport default Inspector;\n","\nvar InspectorLayers = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorLayers.prototype.init = function() {\n    var inspector = this.inspector;\n    inspector.addStyle(\n        '#vts-layers-panel {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'display: none;'\n            + 'padding:15px;'\n            + 'font-size: 14px;'\n            + 'position: absolute;'\n            + 'right: 10px;'\n            + 'bottom: 10px;'\n            + 'cursor: default;'\n            + 'background-color: rgba(255,255,255,0.95);'\n            + 'border-radius: 5px;'\n            + 'border: solid 1px #ccc;'\n            + 'text-align: left;'\n            + 'z-index: 7;'\n            + 'padding: 10px;'\n        + '}'\n\n        + '#vts-layers-panel button {'\n            + 'max-width: 23px;'\n            + 'max-height: 21px;'\n        + '}'\n\n        + '#vts-layers-panel-title {'\n            + 'margin-bottom: 3px;'\n        + '}'\n\n        + '#vts-layers-views-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-layers-views-items {'\n            + 'width: 191px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border: 1px solid #ddd;'\n        + '}'\n        \n        + '#vts-layers-surfaces-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'        \n        \n        + '#vts-layers-surfaces-items {'\n            + 'width: 150px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border-top: 1px solid #ddd;'\n            + 'border-bottom: 1px solid #ddd;'\n        + '}'\n         \n        + '#vts-layers-boundlayers-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-layers-boundlayers-items {'\n            + 'width: 275px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border: 1px solid #ddd;'\n            + 'border-right: none;'\n        + '}'\n\n        + '#vts-layers-freelayers-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-layers-freelayers-items {'\n            + 'width: 150px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border: 1px solid #ddd;'\n        + '}'\n\n        + '#vts-layers-fl-properties-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-layers-fl-properties-items {'\n            + 'width: 250px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border: 1px solid #ddd;'\n            + 'border-right: none;'\n        + '}'\n\n        + '#vts-layers-json-panel {'\n            + 'margin-top: 5px;'\n            + 'float: right;'\n        + '}'\n\n        + '#vts-layers-json-text {'\n            + 'width: 200px;'\n            + 'resize: none;'\n            + 'height: 180px;'\n            + 'border: 1px solid #ddd;'\n            + 'white-space: pre;'\n            + 'padding: 0px;'\n        + '}'\n\n        + '#vts-layers-json-text2 {'\n            + 'width: 200px;'\n            + 'height: 21px;'\n            + 'border: 1px solid #ddd;'\n        + '}'\n        \n        + '.vts-layers-panel-title {'\n            + 'margin: 0px;'\n            + 'margin-bottom: 5px;'\n        + '}'\n\n        + '.vts-layers-item {'\n            + 'width: 100%;'\n        + '}'        \n        \n        + '.vts-layers-item input[type=number]{'\n            + 'width: 43px;'\n        + '}'\n        \n        + '.vts-layers-name {'\n            + 'width: 120px;'\n            + 'display: inline-block;'\n            + 'overflow: hidden;'\n            + 'text-overflow: ellipsis;'\n            + 'white-space: nowrap;'       \n        + '}'          \n\n        + '.vts-layers-name2 {'\n            + 'width: 126px;'\n            + 'display: inline-block;'\n            + 'overflow: hidden;'\n            + 'text-overflow: ellipsis;'\n            + 'white-space: nowrap;'       \n        + '}'\n         \n        + '#vts-layers-fl-properties-style {'\n            + 'width: 175px;'\n            + 'height: 21px;'\n        + '}'\n\n        + '.vts-surface-item {'\n            + 'width: 100%;'\n            + 'overflow: hidden;'\n            + 'text-overflow: ellipsis;'\n            + 'white-space: nowrap;'    \n        + '}' \n        \n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-layers-panel';\n    this.element.innerHTML = ''\n        + '<div id=\"vts-layers-views-panel\"><p class=\"vts-layers-panel-title\">Named Views:</p>'\n           + '<div id=\"vts-layers-views-items\"></div></div>'\n        + '<div id=\"vts-layers-surfaces-panel\"><p class=\"vts-layers-panel-title\">Surfaces:</p>'\n           + '<div id=\"vts-layers-surfaces-items\"></div></div>'\n        + '<div id=\"vts-layers-boundlayers-panel\"><p class=\"vts-layers-panel-title\">Surface Bound Layers:</p>'\n           + '<div id=\"vts-layers-boundlayers-items\"></div></div>'\n        + '<div id=\"vts-layers-freelayers-panel\"><p class=\"vts-layers-panel-title\">Free Layers:</p>'\n           + '<div id=\"vts-layers-freelayers-items\"></div></div>'\n        + '<div id=\"vts-layers-fl-properties-panel\"><p class=\"vts-layers-panel-title\">Free Layer Properties:</p>'\n           + '<div id=\"vts-layers-fl-properties-items\"></div></div>'\n        + '<div id=\"vts-layers-json-panel\"><p class=\"vts-layers-panel-title\">Definition:</p>'\n           + '<textarea id=\"vts-layers-json-text\" cols=\"48\"></textarea><br/>'\n           + '<input id=\"vts-layers-json-text2\" type=\"text\"></div>';\n\n    this.core.element.appendChild(this.element);\n    this.viewItems = document.getElementById('vts-layers-views-items');\n    this.surfacesItems = document.getElementById('vts-layers-surfaces-items');\n    this.boundLayersItems = document.getElementById('vts-layers-boundlayers-items');\n    this.freeLayersItems = document.getElementById('vts-layers-freelayers-items');\n    this.freeLayersPropertiesItems = document.getElementById('vts-layers-fl-properties-items');\n    this.jsonText = document.getElementById('vts-layers-json-text');\n    this.jsonText2 = document.getElementById('vts-layers-json-text2');\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.views = [];\n    \n    this.panelVisible = false;\n    this.panelInitialized = false;\n    this.currentView = '';\n    this.currentSurface = '';\n    this.currentFreeLayer = '';\n};\n\n\nInspectorLayers.prototype.initViews = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var views = map.getNamedViews(), freeLayer;\n    var id = '--initial--';\n    var i, li, j, lj, layers, states, index, view, surfaces, skey;\n\n\n    this.views[id] = {\n        surfaces : {},\n        freeLayers : {},\n        options : {},\n        original : JSON.parse(JSON.stringify(map.getView()))\n    };\n\n    for (i = 0, li = views.length; i < li; i++) {\n        view = views[i];\n        this.views[view] = {\n            surfaces : {},\n            freeLayers : {},\n            options : {},\n            original : JSON.parse(JSON.stringify(map.getNamedView(view).getInfo()))\n        };\n    }\n    \n    this.currentView = id;\n    views = this.views;\n    \n    for (var key in views) {\n        view = views[key];\n        surfaces = map.getSurfaces();   \n        \n        for (i = 0, li = surfaces.length; i < li; i++) {\n            id = surfaces[i];\n            surface = map.getSurface(id);\n            layers = map.getBoundLayers();\n            states = []; \n    \n            for (j = 0, lj = layers.length; j < lj; j++) {\n                //layer = map.getBoundLayerById(layers[j]);\n                \n                states.push({\n                    id : layers[j],\n                    alpha : 100,\n                    options : \"{}\",\n                    enabled : false\n                });\n            }\n            \n            view.surfaces[id] = {\n                enabled : false,\n                layers : states \n            };\n        }         \n\n        var freeLayers = map.getFreeLayers();   \n        \n        for (i = 0, li = freeLayers.length; i < li; i++) {\n            id = freeLayers[i];\n            layers = map.getBoundLayers();\n            states = []; \n    \n            for (j = 0, lj = layers.length; j < lj; j++) {\n                //layer = map.getBoundLayerById(layers[j]);\n                \n                states.push({\n                    id : layers[j],\n                    alpha : 100,\n                    options : \"{}\",\n                    enabled : false\n                });\n            }\n            \n            freeLayer = map.getFreeLayer(id);\n            var freeLayerInfo = freeLayer.getInfo(); \n            \n            view.freeLayers[id] = {\n                enabled : false,\n                style : null,\n                originalStyle : freeLayerInfo['style'],\n                depthShift : 0,\n                depthShift2 : 0,\n                depthShift3 : 0,\n                layers : states \n            };\n        }\n        \n        var viewSurfaces = view.original['surfaces'];\n        \n        for (skey in viewSurfaces) {\n            layers = viewSurfaces[skey];\n            \n            if (view.surfaces[skey]) {\n                var surface = view.surfaces[skey]; \n                surface.enabled = true;\n\n                for (i = 0, li = layers.length; i < li; i++) {\n                    if (typeof layers[i] === 'string') {\n                        index = this.findIdInArray(surface.layers, layers[i]);\n                        if (index != -1 && surface.layers[index]) {\n                            surface.layers[index].enabled = true;\n                            surface.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);\n                        }    \n                    } else {\n                        id = layers[i]['id'];\n                        index = this.findIdInArray(surface.layers, id);\n                        if (index != -1 && surface.layers[index]) {\n                            surface.layers[index].enabled = true;\n                            surface.layers[index].alpha = layers[i]['alpha'] ? (parseFloat(layers[i]['alpha'])*100) : 100;\n                            surface.layers[index].options = layers[i]['options'] ? JSON.stringify(layers[i]['options']) : \"{}\";\n                            surface.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);\n                        }    \n                    }\n                }\n            }\n        }\n\n        var viewfreeLayers = view.original['freeLayers'];\n        \n        for (skey in viewfreeLayers) {\n            var freeLayerProperties = viewfreeLayers[skey];\n            \n            if (view.freeLayers[skey]) {\n                freeLayer = view.freeLayers[skey]; \n                freeLayer.enabled = true;\n                var depthShift = freeLayerProperties['depthOffset'] || [0,0,0];\n                freeLayer.depthShift = depthShift[0];\n                freeLayer.depthShift2 = depthShift[1];\n                freeLayer.depthShift3 = depthShift[2];\n                freeLayer.style = freeLayerProperties['style'];\n                //freeLayer.originalStyle = freeLayer.style;\n                \n                layers = freeLayerProperties['boundLayers'] || [];\n                //freeLayer.layers = layers;\n                \n                for (i = 0, li = layers.length; i < li; i++) {\n                    if (typeof layers[i] === 'string') {\n                        index = this.findIdInArray(freeLayer.layers, layers[i]);\n                        if (index != -1 && freeLayer.layers[index]) {\n                            freeLayer.layers[index].enabled = true;\n                            freeLayer.layers.splice(i, 0, freeLayer.layers.splice(index, 1)[0]);\n                        }    \n                    } else {\n                        id = layers[i]['id'];\n                        index = this.findIdInArray(freeLayer.layers, id);\n                        if (index != -1 && surface.layers[index]) {\n                            freeLayer.layers[index].enabled = true;\n                            freeLayer.layers[index].alpha = layers[i]['alpha'] ? (parseFloat(layers[i]['alpha'])*100) : 100;\n                            freeLayer.layers[index].options = layers[i]['options'] ? JSON.stringify(layers[i]['options']) : \"{}\";\n                            freeLayer.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);\n                        }    \n                    }\n                }\n            }\n        }        \n    }\n};\n\n\nInspectorLayers.prototype.findIdInArray = function(array, id) {\n    for (var i = 0, li = array.length; i < li; i++) {\n        if (array[i].id == id) {\n            return i;\n        } \n    }\n    \n    return -1;\n};\n\n\nInspectorLayers.prototype.buildViews = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var views = this.views;\n    var html = '';\n\n    for (var key in views) {\n        html += '<div class=\"vts-views-item\" id=\"vts-views-item-' + key + '\">'\n                 + '<div class=\"vts-layers-name2\">' + key + '</div>'\n                 + '<button id=\"vts-views-cbutton-' + key + '\" type=\"button\" title=\"Clone\">C</button>' \n                 + '<button id=\"vts-views-xbutton-' + key + '\" type=\"button\" title=\"Remove\">X</button>' \n                 + '</div>';\n    }\n\n    this.viewItems.innerHTML = html;\n\n    for (key in views) {\n        htmlId = 'vts-views-cbutton-' + key;\n        document.getElementById(htmlId).onclick = this.switchView.bind(this, key, htmlId, 'clone');\n        htmlId = 'vts-views-xbutton-' + key;\n        document.getElementById(htmlId).onclick = this.switchView.bind(this, key, htmlId, 'remove');\n        var htmlId = 'vts-views-item-' + key;\n        document.getElementById(htmlId).onclick = this.selectView.bind(this, key);\n    }\n};\n\n\nInspectorLayers.prototype.buildSurfaces = function() {\n    var view = this.views[this.currentView];\n    var surfaces = view.surfaces;\n    var html = '', htmlId;\n    var firstKey = null, key;\n    \n    for (key in surfaces) {\n        html += '<div id=\"vts-surface-item-' + key + '\" class=\"vts-surface-item\"><input id=\"vts-surface-checkbox-'\n                 + key + '\" type=\"checkbox\"/><span title=' + key + '>' + key + '</span></div>';\n                 \n        if (firstKey === null) {\n            firstKey = key;\n        }\n    }\n\n    this.surfacesItems.innerHTML = html;\n    this.currentSurface = firstKey;\n\n    for (key in surfaces) {\n        if (surfaces[key].enabled) {\n            htmlId = 'vts-surface-checkbox-' + key;\n            document.getElementById(htmlId).checked = true;\n        }\n    }\n\n    for (key in surfaces) {\n        htmlId = 'vts-surface-checkbox-' + key;\n        document.getElementById(htmlId).onchange = this.switchSurface.bind(this, key, htmlId);\n        htmlId = 'vts-surface-item-' + key;\n        document.getElementById(htmlId).onclick = this.selectSurface.bind(this, key);\n    }\n};\n\n\nInspectorLayers.prototype.buildBoundLayers = function(id) {\n    var view = this.views[this.currentView];\n    var html = '';\n\n    if (view.surfaces[id]) {\n        var layers = view.surfaces[id].layers;\n\n        for (var i = 0, li = layers.length; i < li; i++) {\n            var layer = layers[i];\n\n            html += '<div class=\"vts-layers-item\"><input id=\"vts-boundlayer-checkbox-' + layer.id + '\" type=\"checkbox\" ' + (layer.enabled ? 'checked' : '')   + '/>'\n                     + '<div class=\"vts-layers-name\">' + layer.id + '</div>'\n                     + '<input id=\"vts-boundlayer-spinner-' + layer.id + '\" type=\"number\" title=\"Alpha\" min=\"0\" max=\"100\" step=\"10\" value=\"' + layer.alpha + '\">'\n                     + '<button id=\"vts-boundlayer-obutton-' + layer.id + '\" type=\"button\" title=\"Options\">O</button>' \n                     + '<button id=\"vts-boundlayer-ubutton-' + layer.id + '\" type=\"button\" title=\"Move Above\">&uarr;</button>' \n                     + '<button id=\"vts-boundlayer-dbutton-' + layer.id + '\" type=\"button\" title=\"Move Bellow\">&darr;</button>' \n                     + '</div>';\n        }\n    }\n\n    this.boundLayersItems.innerHTML = html;\n\n    if (view.surfaces[id]) {\n        for (i = 0, li = layers.length; i < li; i++) {\n            var htmlId = 'vts-boundlayer-checkbox-' + layers[i].id;\n            document.getElementById(htmlId).onchange = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'enable');\n            htmlId = 'vts-boundlayer-spinner-' + layers[i].id;\n            document.getElementById(htmlId).onchange = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'alpha');\n            htmlId = 'vts-boundlayer-obutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'options');\n            htmlId = 'vts-boundlayer-ubutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'up');\n            htmlId = 'vts-boundlayer-dbutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'down');\n        }\n    }\n};\n\n\nInspectorLayers.prototype.buildFreeLayers = function() {\n    var view = this.views[this.currentView];\n    var layers = view.freeLayers;\n    var html = '';\n\n    for (var key in layers) {\n        //var layer = layers[key];\n        html += '<div class=\"vts-surface-item\" id=\"vts-freelayer-item-' + key\n                  + '\"><input id=\"vts-freelayer-checkbox-' + key + '\" type=\"checkbox\" '\n                  + (layers[key].enabled ? 'checked' : '') + '/><span title=' + key + '>' + key + '</span></div>';\n    }\n\n    this.freeLayersItems.innerHTML = html;\n\n    for (key in layers) {\n        var htmlId = 'vts-freelayer-checkbox-' + key;\n        document.getElementById(htmlId).onchange = this.switchFreeLayer.bind(this, key, htmlId);\n        htmlId = 'vts-freelayer-item-' + key;\n        document.getElementById(htmlId).onclick = this.selectFreeLayer.bind(this, key);\n    }\n};\n\n\nInspectorLayers.prototype.buildFreeLayerProperties = function(id) {\n    var map = this.core.getMap();\n    var view = this.views[this.currentView];\n    var layers = view.freeLayers[id].layers;\n    var html = '', i, li, htmlId;\n    \n    if (!map || !map.getFreeLayer(id)) {\n        return;\n    }\n\n    var layerInfo = map.getFreeLayer(id).getInfo();\n    var layerType = layerInfo['type']; \n\n    switch(layerType) {\n    case 'mesh':\n    case 'mesh-tiles':\n\n        html += '<div class=\"vts-layers-item\"><div class=\"vts-layers-name\" style=\"width:90px\">' + 'DepthOffset:' + '</div>'\n                     + '<input id=\"vts-fl-properties-depth-shift\" type=\"number\" min=\"-100\" max=\"100\" step=\"1\" value=\"' + view.freeLayers[id].depthShift + '\">'\n                     + '<input id=\"vts-fl-properties-depth-shift2\" type=\"number\" min=\"-100\" max=\"100\" step=\"1\" value=\"' + view.freeLayers[id].depthShift2 + '\">'\n                     + '<input id=\"vts-fl-properties-depth-shift3\" type=\"number\" min=\"-100\" max=\"100\" step=\"1\" value=\"' + view.freeLayers[id].depthShift3 + '\">'\n                     + '</div>';\n    \n        html += '<div class=\"vts-layers-item\"><div class=\"vts-layers-name\">' + 'BoundLayers:' + '</div></div>';\n        \n        for (i = 0, li = layers.length; i < li; i++) {\n            var layer = layers[i];\n        \n            html += '<div class=\"vts-layers-item\"><input id=\"vts-fl-properties-checkbox-' + layer.id + '\" type=\"checkbox\" ' + (layer.enabled ? 'checked' : '')   + '/>'\n                         + '<div class=\"vts-layers-name\">' + layer.id + '</div>'\n                         + '<input id=\"vts-fl-properties-spinner-' + layer.id + '\" type=\"number\" title=\"Alpha\" min=\"0\" max=\"100\" step=\"10\" value=\"' + layer.alpha + '\">'\n                         + '<button id=\"vts-fl-properties-ubutton-' + layer.id + '\" type=\"button\" title=\"Move Above\">&uarr;</button>' \n                         + '<button id=\"vts-fl-properties-dbutton-' + layer.id + '\" type=\"button\" title=\"Move Bellow\">&darr;</button>' \n                         + '</div>';\n        }\n        \n        this.freeLayersPropertiesItems.innerHTML = html;\n    \n        htmlId = 'vts-fl-properties-depth-shift';\n        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift');\n        htmlId = 'vts-fl-properties-depth-shift2';\n        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift2');\n        htmlId = 'vts-fl-properties-depth-shift3';\n        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift3');\n        \n        for (i = 0, li = layers.length; i < li; i++) {\n            htmlId = 'vts-fl-properties-checkbox-' + layers[i].id;\n            document.getElementById(htmlId).onchange = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'enable');\n            htmlId = 'vts-fl-properties-spinner-' + layers[i].id;\n            document.getElementById(htmlId).onchange = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'alpha');\n            htmlId = 'vts-fl-properties-ubutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'up');\n            htmlId = 'vts-fl-properties-dbutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'down');\n        }\n            \n        break;\n\n    case 'geodata':\n    case 'geodata-tiles':\n\n        html += '<div class=\"vts-layers-item\"><div class=\"vts-layers-name\" style=\"width:50px\">' + 'Style:' + '</div>'\n                    + '<select id=\"vts-layers-fl-properties-style\">';\n                    \n        var styles = map.getStylesheets();\n        var index = styles.indexOf(view.freeLayers[id].style || view.freeLayers[id].originalStyle); // || layerInfo[\"style\"]); \n            \n        for (i = 0, li = styles.length; i < li; i++) {\n            html += '<option value=\"' + styles[i] + '\" ' + ((i == index) ? 'selected' : '') + '>' + styles[i] + '</option>';\n        }\n                    \n        html += '</select>' + '</div>';\n\n        this.freeLayersPropertiesItems.innerHTML = html;\n\n        htmlId = 'vts-layers-fl-properties-style';\n        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'style');\n       \n        break;\n    }\n};\n\n\nInspectorLayers.prototype.selectView = function(id) {\n    if (!this.views[id]) {\n        return;\n    }\n\n    var element;\n\n    //deselect previous\n    if (this.currentView) {\n        element = document.getElementById('vts-views-item-' + this.currentView);\n        if (element) {\n            element.style.backgroundColor = 'initial';\n        }\n    }\n\n    //select new one\n    element = document.getElementById('vts-views-item-' + id);\n    element.style.backgroundColor = '#ddd';\n    this.currentView = id;\n    //this.buildBoundLayers(this.currentSurface);\n\n    this.buildSurfaces();\n    this.selectSurface(this.currentSurface);\n    this.buildFreeLayers();\n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.switchView = function(id, htmlId, action) {\n    //var element = document.getElementById(htmlId);\n    var views = this.views;\n    \n    for (var key in this.views) {\n        if (key == id) {\n            switch(action) {\n            case 'clone':\n                    //layers[i].enabled = element.checked;\n                var i = 2;\n                    \n                // eslint-disable-next-line\n                while(true) {\n                    if (!views[id + ' #' + i]) {\n                        views[id + ' #' + i] = JSON.parse(JSON.stringify(views[id]));\n                        break;\n                    } \n                    i++;\n                }\n                \n                this.buildViews();\n                    \n                break;\n            case 'remove':\n                \n                var count = 0;\n                \n                for (key in views) {\n                    count++;\n                }\n                \n                if (count > 1) {\n                    delete views[id];\n                    this.buildViews();\n\n                    if (this.currentView == id) {\n                        for (key in views) {\n                            this.selectView(key);\n                            break;\n                        }\n                    } else {\n                        this.selectView(this.currentView);\n                    }\n                }\n                    \n                break;\n            }\n            \n            break;\n        }\n    }\n};\n\n\nInspectorLayers.prototype.switchSurface = function(id, htmlId) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    view.surfaces[id].enabled = element.checked;\n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.selectSurface = function(id) {\n    var element;\n    //deselect previous\n    if (this.currentSurface) {\n        element = document.getElementById('vts-surface-item-' + this.currentSurface);\n        element.style.backgroundColor = 'initial';\n    }\n\n    //select new one\n    element = document.getElementById('vts-surface-item-' + id);\n    if (element) {\n        element.style.backgroundColor = '#ddd';\n    }\n    this.currentSurface = id;\n    this.buildBoundLayers(this.currentSurface);\n};\n\n\nInspectorLayers.prototype.switchBoundLayer = function(id, htmlId, action) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    var layers = view.surfaces[this.currentSurface].layers;\n    \n    for (var i = 0, li = layers.length; i < li; i++) {\n        if (layers[i].id == id) {\n            switch(action) {\n            case 'enable':\n                layers[i].enabled = element.checked;\n                break;\n            case 'alpha':\n                layers[i].alpha = parseInt(element.value, 10);\n                break;\n            case 'options':\n                //display popup               \n                break;\n            case 'up':\n                layers.splice(Math.max(0,i-1), 0, layers.splice(i, 1)[0]);\n                this.selectSurface(this.currentSurface);\n                break;\n            case 'down':\n                layers.splice(Math.max(0,i+1), 0, layers.splice(i, 1)[0]);\n                this.selectSurface(this.currentSurface);\n                break;\n            }\n            \n            break;\n        }\n    }\n    \n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.switchFreeLayer = function(id, htmlId) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    view.freeLayers[id].enabled = element.checked;\n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.selectFreeLayer = function(id) {\n    var element;\n    //deselect previous\n    if (this.currentFreeLayer) {\n        element = document.getElementById('vts-freelayer-item-' + this.currentFreeLayer);\n        element.style.backgroundColor = 'initial';\n    }\n\n    //select new one\n    element = document.getElementById('vts-freelayer-item-' + id);\n    element.style.backgroundColor = '#ddd';\n    this.currentFreeLayer = id;\n    this.buildFreeLayerProperties(this.currentFreeLayer);\n};\n\n\nInspectorLayers.prototype.switchFreeLayerBoundLayer = function(id, htmlId, action) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    var layers = view.freeLayers[this.currentFreeLayer].layers;\n    \n    for (var i = 0, li = layers.length; i < li; i++) {\n        if (layers[i].id == id) {\n            switch(action) {\n            case 'enable':\n                layers[i].enabled = element.checked;\n                break;\n            case 'alpha':\n                layers[i].alpha = parseInt(element.value, 10);\n                break;\n            case 'up':\n                layers.splice(Math.max(0,i-1), 0, layers.splice(i, 1)[0]);\n                this.selectFreeLayer(this.currentFreeLayer);\n                break;\n            case 'down':\n                layers.splice(Math.max(0,i+1), 0, layers.splice(i, 1)[0]);\n                this.selectFreeLayer(this.currentFreeLayer);\n                break;\n            }\n            \n            break;\n        }\n    }\n    \n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.switchFreeLayerProperty = function(htmlId, action) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    var layer = view.freeLayers[this.currentFreeLayer];\n\n    switch(action) {\n    case 'depthShift':  layer.depthShift = parseInt(element.value, 10); break;\n    case 'depthShift2': layer.depthShift2 = parseInt(element.value, 10); break;\n    case 'depthShift3': layer.depthShift3 = parseInt(element.value, 10); break;\n    case 'style':       layer.style = element.value; break;\n    }\n    \n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.applyMapView = function(jsonOnly) {\n    var view = {\n        'surfaces' : {},\n        'freeLayers' : {},\n        'options' : {}\n    };\n\n    var sourceView = this.views[this.currentView];\n    var surfaces = sourceView.surfaces, i, li, layers;\n\n    view['options'] = JSON.parse(JSON.stringify(sourceView.options));\n    \n    for (var key in surfaces) {\n        if (surfaces[key].enabled) {\n            var surfaceBoundLayers = [];\n            layers = surfaces[key].layers; //bound layers\n            \n            for (i = 0, li = layers.length; i < li; i++) {\n                if (layers[i].enabled) {\n\n                    var options = JSON.parse(JSON.stringify(layers[i].options));\n                    var options2 = JSON.stringify(options);\n\n                    if (layers[i].alpha < 100) {\n                        var item = {'id':layers[i].id, 'alpha':(layers[i].alpha*0.01).toFixed(2)};\n                        if (options2 != '{}') {\n                            item.options = options;\n                        }\n                        surfaceBoundLayers.push(item);\n                    } else {\n                        surfaceBoundLayers.push(layers[i].id);\n                    }\n                }\n            }\n            \n            view['surfaces'][key] = surfaceBoundLayers;\n        }\n    }\n\n    var freeLayers = sourceView.freeLayers;\n    \n    for (key in freeLayers) {\n        if (freeLayers[key].enabled) {\n            var freeLayerBoundLayers = [];\n            layers = freeLayers[key].layers; //bound layers\n            \n            for (i = 0, li = layers.length; i < li; i++) {\n                if (layers[i].enabled) {\n                    \n                    if (layers[i].alpha < 100) {\n                        var item = {'id':layers[i].id, 'alpha':(layers[i].alpha*0.01).toFixed(2)};\n                        if (options2 != '{}') {\n                            item.options = options;\n                        }\n                        freeLayerBoundLayers.push(item);\n                    } else {\n                        freeLayerBoundLayers.push(layers[i].id);\n                    }\n                }\n            }\n            \n            view['freeLayers'][key] = {};\n            \n            if (freeLayerBoundLayers.length > 0) {\n                view['freeLayers'][key]['boundLayers'] = freeLayerBoundLayers;\n            }\n\n            if (freeLayers[key].style && freeLayers[key].style != freeLayers[key].originalStyle) {\n                view['freeLayers'][key]['style'] = freeLayers[key].style;\n            }\n            \n            if (!(freeLayers[key].depthShift == 0 && freeLayers[key].depthShift2 == 0 && freeLayers[key].depthShift3 == 0)) {\n                view['freeLayers'][key]['depthOffset'] = [\n                    parseFloat((freeLayers[key].depthShift).toFixed(2)),\n                    parseFloat((freeLayers[key].depthShift2).toFixed(2)),\n                    parseFloat((freeLayers[key].depthShift3).toFixed(2)) ];\n            } \n            \n        }\n    }\n\n    this.jsonText.value = JSON.stringify(view, null, '  ');\n    this.jsonText2.value = encodeURIComponent(JSON.stringify(view));\n\n    if (!jsonOnly) {\n        var map = this.core.getMap();\n        if (!map) {\n            return;\n        }\n        \n        map.setView(view, null, true);\n    }\n};\n\n\nInspectorLayers.prototype.showPanel = function() {\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n    this.updatePanel();\n};\n\n\nInspectorLayers.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n};\n\n\nInspectorLayers.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorLayers.prototype.updatePanel = function() {\n    if (!this.panelInitialized) {\n        this.panelInitialized = false;\n        this.initViews();\n        this.buildViews();\n        this.selectView(this.currentView);\n        /*\n        this.buildSurfaces();\n        this.selectSurface(this.currentSurface);\n        this.buildFreeLayers();\n        this.applyMapView(true);\n        */\n    }\n};\n\n\nexport default InspectorLayers;\n","\nimport GpuTexture_ from '../renderer/gpu/texture';\nimport {math as math_} from '../utils/math';\nimport {vec3 as vec3_, mat4 as mat4_} from '../utils/matrix';\n\n//get rid of compiler mess\nvar math = math_;\nvar GpuTexture = GpuTexture_;\nvar vec3 = vec3_, mat4 = mat4_;\n\n\nvar InspectorReplay = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorReplay.prototype.init = function() {\n    var inspector = this.inspector;\n    inspector.addStyle(\n        '#vts-replay-panel {'\n            + 'font-family: Arial, \\'Helvetica Neue\\', Helvetica, sans-serif;'\n            + 'display: none;'\n            + 'padding:15px;'\n            + 'width: 618px;'\n            + 'font-size: 14px;'\n            + 'position: absolute;'\n            + 'right: 10px;'\n            + 'top: 10px;'\n            + 'cursor: default;'\n            + 'background-color: rgba(255,255,255,0.95);'\n            + 'border-radius: 5px;'\n            + 'border: solid 1px #ccc;'\n            + 'text-align: left;'\n            + 'z-index: 7;'\n            + 'padding: 10px;'\n        + '}'\n\n        + '#vts-replay-panel-left {'\n            + 'width: 253px;'\n            + 'height: 100%;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-replay-panel-right {'\n            + 'width: 340px;'\n            + 'height: 100%;'\n            + 'float: right;'\n        + '}'\n\n        + '#vts-replay-items {'\n            + 'width: 240px;'\n            + 'overflow-x: hidden;'\n            + 'border: 1px solid #ddd;'\n            + 'padding-right: 5px;'\n        + '}'\n\n        + '.vts-replay-item {'\n            + 'width: 100%;'\n            + 'overflow: hidden;'\n            + 'text-overflow: ellipsis;'\n            + 'white-space: nowrap;'    \n        + '}' \n\n        + '#vts-replay-lod-slider {'\n            + 'width: 240px;'\n        + '}'\n\n        + '#vts-replay-lod-text {'\n            + 'width: 60px;'\n            + 'margin-left: 10px;'\n            + 'margin-right: 10px;'\n        + '}'\n\n        + '#vts-replay-lod-single {'\n            + 'margin-left: 10px;'\n        + '}'\n    \n        + '#vts-replay-time-slider {'\n            + 'width: 330px;'\n        + '}'\n\n        + '#vts-replay-time-text {'\n            + 'width: 60px;'\n            + 'margin-left: 10px;'\n            + 'margin-right: 10px;'\n        + '}'\n\n        + '#vts-replay-time-single {'\n            + 'margin-left: 10px;'\n        + '}'\n\n        + '#vts-replay-panel-gtime canvas{'\n            + 'border: 1px solid #555;'\n        + '}'\n\n        + '#vts-replay-panel-gtime span{'\n            + 'font-size: 10px;'\n        + '}'\n\n        + '#vts-replay-info {'\n            + 'width: 240px;'\n            + 'height: 140px;'\n            + 'overflow-x: hidden;'\n            + 'border: 1px solid #ddd;'\n            + 'padding-right: 5px;'\n            + 'margin-top: 10px;'            \n            + 'font-size: 12px;'\n            + 'word-wrap: break-word;'   \n        + '}'\n       \n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-replay-panel';\n    this.element.innerHTML =\n            '<div id=\"vts-replay-panel-left\">'\n            + '<div id=\"vts-replay-items\"></div>'\n            + '<div id=\"vts-replay-panel-lod\">'  \n                + '<input id=\"vts-replay-lod-slider\" type=\"range\" min=\"0\" max=\"30\" step=\"1\" value=\"30\" /><br/>'\n                + '<span>LOD:</span>'\n                + '<input id=\"vts-replay-lod-text\" type=\"text\" value=\"30\"/>'\n                + '<input id=\"vts-replay-lod-up\" type=\"button\" value=\"<\"/>'\n                + '<input id=\"vts-replay-lod-down\" type=\"button\" value=\">\"/>'\n                + '<input id=\"vts-replay-lod-single\" type=\"checkbox\"/>'\n                + '<span>Single</span>'\n            + '</div>'\n            + '<div id=\"vts-replay-info\"></div>'\n          + '</div>'\n          + '<div id=\"vts-replay-panel-right\">'\n            + '<div id=\"vts-replay-panel-gtime\">'  \n                + '<span id=\"vts-replay-info-meshes\">Meshes Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-meshes\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-textures\">Internal Textures Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-textures\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-textures2\">External Textures Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-textures2\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-geodata\">Geodata Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-geodata\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-metatiles\">Metatiles Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-metatiles\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-intervals\">Interval Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-intervals\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-threads\">Threads Min/Max: 0/0 Avg. 0 </span><br/>'\n                + '<canvas id=\"vts-replay-canvas-threads\" width=340 height=30></canvas><br/>'  \n            + '</div>'\n\n            + '<div id=\"vts-replay-panel-time\">'  \n                + '<input id=\"vts-replay-time-slider\" type=\"range\" min=\"0\" max=\"2000\" value=\"0\" /><br/>'\n                + '<span>File:</span>'\n                + '<input id=\"vts-replay-time-text\" type=\"text\" value=\"0\"/>'\n                + '<input id=\"vts-replay-time-up\" type=\"button\" value=\"<\"/>'\n                + '<input id=\"vts-replay-time-down\" type=\"button\" value=\">\"/>'\n                + '<input id=\"vts-replay-time-single\" type=\"checkbox\"/>'\n                + '<span>Single</span>'\n            + '</div>'\n          + '</div>';\n\n    this.core.element.appendChild(this.element);\n\n    this.items = document.getElementById('vts-replay-items');\n\n    this.lodSlider = document.getElementById('vts-replay-lod-slider');\n    this.lodSlider.onchange = this.onSliderChange.bind(this, 'lod');\n    this.lodSlider.oninput = this.onSliderChange.bind(this, 'lod');\n\n    this.lodText = document.getElementById('vts-replay-lod-text');\n    this.lodText.onchange = this.onTextChange.bind(this, 'lod');\n    \n    document.getElementById('vts-replay-lod-up').onclick = this.onSliderChange.bind(this, 'lod', 'down');\n    document.getElementById('vts-replay-lod-down').onclick = this.onSliderChange.bind(this, 'lod', 'up');\n    document.getElementById('vts-replay-lod-single').onclick = this.onSliderChange.bind(this, 'lod', 'single');\n    \n    this.timeSlider = document.getElementById('vts-replay-time-slider');\n    this.timeSlider.onchange = this.onSliderChange.bind(this, 'time');\n    this.timeSlider.oninput = this.onSliderChange.bind(this, 'time');\n\n    this.timeText = document.getElementById('vts-replay-time-text');\n    this.timeText.onchange = this.onTextChange.bind(this, 'time');\n\n    this.timeInfo = document.getElementById('vts-replay-info');\n\n    document.getElementById('vts-replay-time-up').onclick = this.onSliderChange.bind(this, 'time', 'down');\n    document.getElementById('vts-replay-time-down').onclick = this.onSliderChange.bind(this, 'time', 'up');\n    document.getElementById('vts-replay-time-single').onclick = this.onSliderChange.bind(this, 'time', 'single');\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.infoMeshes = document.getElementById('vts-replay-info-meshes');\n    this.ctxMeshes = document.getElementById('vts-replay-canvas-meshes').getContext('2d');  \n    this.infoTextures = document.getElementById('vts-replay-info-textures');\n    this.ctxTextures = document.getElementById('vts-replay-canvas-textures').getContext('2d');  \n    this.infoTextures2 = document.getElementById('vts-replay-info-textures2');\n    this.ctxTextures2 = document.getElementById('vts-replay-canvas-textures2').getContext('2d');  \n    this.infoGeodata = document.getElementById('vts-replay-info-geodata');\n    this.ctxGeodata = document.getElementById('vts-replay-canvas-geodata').getContext('2d');  \n    this.infoMetatiles = document.getElementById('vts-replay-info-metatiles');\n    this.ctxMetatiles = document.getElementById('vts-replay-canvas-metatiles').getContext('2d');  \n    this.infoIntervals = document.getElementById('vts-replay-info-intervals');\n    this.ctxIntervals = document.getElementById('vts-replay-canvas-intervals').getContext('2d');  \n    this.infoThreads = document.getElementById('vts-replay-info-threads');\n    this.ctxThreads = document.getElementById('vts-replay-canvas-threads').getContext('2d');  \n\n    this.cameraLines = [];\n    this.cameraLines2 = [];\n    this.cameraLines3 = [];\n    this.cameraGenarated = false;\n\n    this.panelVisible = false;\n};\n\n\nInspectorReplay.prototype.showPanel = function() {\n    this.buildReplayCombo();\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n    this.updateFileInfo(replay.loadedIndex);\n    this.updateLoadGraphs();\n};\n\n\nInspectorReplay.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n};\n\n\nInspectorReplay.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorReplay.prototype.onSliderChange = function(type, button) {\n    if (type == 'lod') {\n        switch (button) {\n        case 'up':\n            this.lodSlider.stepUp();\n            this.lodText.value = this.lodSlider.value;    \n            break;\n            \n        case 'down':\n            this.lodSlider.stepDown();\n            this.lodText.value = this.lodSlider.value;    \n            break;\n\n        default:\n            this.lodText.value = this.lodSlider.value;    \n        } \n    } else {\n        switch (button) {\n        case 'up':\n            this.timeSlider.stepUp();\n            this.timeText.value = this.timeSlider.value;    \n            break;\n            \n        case 'down':\n            this.timeSlider.stepDown();\n            this.timeText.value = this.timeSlider.value;    \n            break;\n\n        default:\n            this.timeText.value = this.timeSlider.value;    \n        } \n    }\n\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n\n    if (type == 'lod') {\n        replay.lod = parseFloat(this.lodText.value);\n        replay.singleLod = document.getElementById('vts-replay-lod-single').checked;\n    } else {\n        replay.loadedIndex = parseFloat(this.timeText.value);\n        replay.singleLodedIndex = document.getElementById('vts-replay-time-single').checked;\n        this.updateFileInfo(replay.loadedIndex);\n        this.updateLoadGraphs();\n    }\n\n    map.markDirty();\n};\n\n\nInspectorReplay.prototype.onTextChange = function(type) {\n    if (type == 'lod') {\n        this.lodSlider.value = this.lodText.value;    \n    } else {\n        this.timeSlider.value = this.timeText.value;    \n    }\n\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n\n    if (type == 'lod') {\n        replay.lod = parseFloat(this.lodText.value);\n    } else {\n        replay.loadedIndex = parseFloat(this.timeText.value);\n        this.updateFileInfo(replay.loadedIndex);\n        this.updateLoadGraphs();\n    }\n\n    map.markDirty();\n};\n\n\nInspectorReplay.prototype.generateCameraLines = function(camera) {\n    var renderer = this.core.getRendererInterface();\n    var p1 = camera.position;\n    var p2 = camera.center;\n\n    this.cameraLines = [p1, p2];\n/*        \n    var screenSize = renderer.getCanvasSize();\n    \n    var v1 = map.getScreenRay(0+1,0+1);\n    var v2 = map.getScreenRay(screenSize[0]-1,0+1);\n    var v3 = map.getScreenRay(screenSize[0]-1,screenSize[1]-1);\n    var v4 = map.getScreenRay(0+1,screenSize[1]-1);\n    var v5 = map.getScreenRay(screenSize[0]*0.5,screenSize[1]*0.5);\n    \n    var l = camera.distance;\n    \n    //l = map.getPositionViewExtent(pos);    \n    \n    vec3.scale(v1, l*10);\n    //vec3.scale(v2, l);\n    //vec3.scale(v3, l);\n    //vec3.scale(v4, l);\n    //vec3.scale(v5, l);\n    \n    vec3.add(v1, p1);\n    //vec3.add(v2, p1);\n    //vec3.add(v3, p1);\n    //vec3.add(v4, p1);\n    //vec3.add(v5, p1);\n\n    this.cameraLines3 = [p1, v1]; //, p1, v2, p1, v3, p1, v4, v1, v2, v3, v4];//, v5, p1];\n    */\n/*\n    this.cameraLines2 = [p1];\n    \n    for (var y = 0; y < screenSize[1]*0.5; y += 100) {\n        for (var x = screenSize[0]*0.5; x < screenSize[0]; x += 100) {\n\n            var v1 = map.getScreenRay(x,y);\n            vec3.scale(v1, l);\n            vec3.add(v1, p1);\n            \n            this.cameraLines2.push(v1);\n        }\n    }    \n*/\n    this.cameraLines2 = [[p1], [p1], [p1], [p1]];\n    \n    var segments = 16;\n\n    var map2 = this.core.getMap();\n\n    var m2 = map2.camera.getRotationviewMatrix();\n    var m = mat4.create();\n    mat4.inverse(m2, m);\n    \n    this.cameraMatrix = m;\n    \n    var a = Math.tan(math.radians(map2.camera.getFov()));\n    var b = a * map2.camera.getAspect();\n    var c = Math.sqrt(a*a + b*b);\n    \n    var dfov = Math.atan(c/1);\n    \n    var l = camera.cameraDistance / segments;\n    var l2 = 0.5 * l * Math.tan(dfov);\n    var l3 = l2 * map2.camera.getAspect();\n    var v1, v2, v3, v4;\n\n    for (var i = 0; i < segments; i++) {\n        v1 = [-l3, -l2, -l];\n        v2 = [l3, -l2, -l];\n        v3 = [l3, l2, -l];\n        v4 = [-l3, l2, -l];\n\n        vec3.scale(v1, (i+1));\n        vec3.scale(v2, (i+1));\n        vec3.scale(v3, (i+1));\n        vec3.scale(v4, (i+1));\n        \n        mat4.multiplyVec3(m, v1);\n        mat4.multiplyVec3(m, v2);\n        mat4.multiplyVec3(m, v3);\n        mat4.multiplyVec3(m, v4);\n    \n        vec3.add(v1, p1);\n        vec3.add(v2, p1);\n        vec3.add(v3, p1);\n        vec3.add(v4, p1);\n        \n        this.cameraLines2[0].push(v1);\n        this.cameraLines2[1].push(v2);\n        this.cameraLines2[2].push(v3);\n        this.cameraLines2[3].push(v4);\n    }\n    \n    this.cameraLines3 = [[p1], [p1], [p1], [p1]];\n\n    segments = 256;\n    l = (camera.distance + 12742000 * 1.1) / segments;\n    //l = (camera.distance * 20.1) / segments;\n    l2 = 0.5 * l * Math.tan(dfov);\n    l3 = l2 * map2.camera.getAspect();\n    \n    for (i = 0; i < segments; i++) {\n        v1 = [-l3, -l2, -l];\n        v2 = [l3, -l2, -l];\n        v3 = [l3, l2, -l];\n        v4 = [-l3, l2, -l];\n\n        vec3.scale(v1, (i+1));\n        vec3.scale(v2, (i+1));\n        vec3.scale(v3, (i+1));\n        vec3.scale(v4, (i+1));\n        \n        mat4.multiplyVec3(m, v1);\n        mat4.multiplyVec3(m, v2);\n        mat4.multiplyVec3(m, v3);\n        mat4.multiplyVec3(m, v4);\n    \n        vec3.add(v1, p1);\n        vec3.add(v2, p1);\n        vec3.add(v3, p1);\n        vec3.add(v4, p1);\n        \n        this.cameraLines3[0].push(v1);\n        this.cameraLines3[1].push(v2);\n        this.cameraLines3[2].push(v3);\n        this.cameraLines3[3].push(v4);\n    }\n\n    v1 = [-l3, -l2, -l];\n    v2 = [l3, -l2, -l];\n    v3 = [l3, l2, -l];\n    v4 = [-l3, l2, -l];\n\n    vec3.scale(v1, segments);\n    vec3.scale(v2, segments);\n    vec3.scale(v3, segments);\n    vec3.scale(v4, segments);\n    \n    p1 = [0,0,0];\n    \n    var vertices = [ p1[0], p1[1], p1[2],\n        v1[0], v1[1], v1[2],\n        v2[0], v2[1], v2[2],\n\n        p1[0], p1[1], p1[2],\n        v2[0], v2[1], v2[2],\n        v3[0], v3[1], v3[2],\n\n        p1[0], p1[1], p1[2],\n        v3[0], v3[1], v3[2],\n        v4[0], v4[1], v4[2],\n\n        p1[0], p1[1], p1[2],\n        v4[0], v4[1], v4[2],\n        v1[0], v1[1], v1[2]\n    ];\n                      \n    var uvs = [ 0,0, 0,0, 0,0,\n        0,0, 0,0, 0,0,\n        0,0, 0,0, 0,0,\n        0,0, 0,0, 0,0 ];\n\n    var normals = [ 0,0,1, 0,0,1, 0,0,1,\n        0,0,1, 0,0,1, 0,0,1,\n        0,0,1, 0,0,1, 0,0,1,\n        0,0,1, 0,0,1, 0,0,1 ];\n\n    this.frustumState = renderer.createState({\n        'blend' : true,\n        'zwrite' : false,\n        'ztest' : true,\n        'culling' : false\n    });\n    \n    this.frustumMesh = renderer.createMesh({ 'vertices': vertices, 'uvs': uvs, 'normals': normals });\n    this.cameraGenarated = true;\n};\n\n\nInspectorReplay.prototype.itemButton = function(item, button) {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;    \n    \n    switch (item) {\n    case 'DrawnTiles':\n        replay.storeTiles = true;\n        break;\n\n    case 'DrawnTilesFreeLayers':\n        replay.storeFreeTiles = true;\n        break;\n\n    case 'TracedNodes':\n        replay.storeNodes = true;\n        break;\n\n    case 'TracedNodesFreeLayers':\n        replay.storeFreeNodes = true;\n        break;\n\n    case 'LoadSequence':\n        replay.storeLoaded = (button == 'S');\n\n        if (button == 'S') {\n            replay.loadedIndex = 0;\n            replay.loaded = [];\n        } else {\n            this.updateFileInfo(replay.loadedIndex);\n            this.updateLoadGraphs();\n        }\n        break;\n\n    case 'Camera':\n\n        if (button == 'S') {\n            var camera = replay.camera = {\n                distance : map.camera.distance,\n                position : map.camera.position.slice(),\n                vector : map.camera.vector.slice(),\n                center : map.camera.center.slice(),\n                height : map.camera.height\n            };\n\n            replay.cameraPos = map.getPosition();\n            this.generateCameraLines(camera);\n        } else {\n            if (replay.cameraPos) {\n                map.setPosition(replay.cameraPos);\n            }\n        }\n\n        break;\n            \n    case 'Globe':\n                        \n        break;\n    }\n\n    map.markDirty();\n};\n\n\nInspectorReplay.prototype.switchItem = function(item, htmlId) {\n    var element = document.getElementById(htmlId);\n    //element.checked;\n    //this.applyMapView();\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n\n    switch (item) {\n    case 'DrawnTiles':\n        replay.drawTiles = element.checked;\n        break;\n\n    case 'DrawnTilesFreeLayers':\n        replay.drawFreeTiles = element.checked;\n        break;\n\n    case 'TracedNodes':\n        replay.drawNodes = element.checked;\n        break;\n\n    case 'TracedNodesFreeLayers':\n        replay.drawFreeNodes = element.checked;\n        break;\n\n    case 'LoadSequence':\n        replay.drawLoaded = element.checked;\n        break;\n\n    case 'Camera':\n        \n        if (!this.cameraGenarated) {\n            this.itemButton('Camera');\n        }\n        \n        this.drawCamera = element.checked;\n        break;\n            \n    case 'Globe':\n        var renderer = this.core.getRenderer();\n        \n        if (!this.globeTexture) {\n            var texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAMAAADyTj5VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Mzk4RkVFMzlGNjUxMUU2OTBDM0I0OEM1NjU0RURBMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Mzk4RkVFNDlGNjUxMUU2OTBDM0I0OEM1NjU0RURBMyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQzOThGRUUxOUY2NTExRTY5MEMzQjQ4QzU2NTRFREEzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQzOThGRUUyOUY2NTExRTY5MEMzQjQ4QzU2NTRFREEzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+5rvbhAAAAAZQTFRFwcHBLS0tMDfv/wAAAiZJREFUeNrs2LENAEEIA0HTf9ME5DTgIZn8ta+TnLjymzuW6kMIwIcQgA8hAAqAAmBdAM4O4E/wBPgQAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACoAAoANoBnB2AngAKgAKgACgACoB2AGcHoCeAAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACoAAoANoBnB2AngAKgAKgACgACoB2AGcHoCeAAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACEIAPIQAfwg7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABSAAH0IAPoQAfAgB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQAPxcAQYAZt2IEFFJhxsAAAAASUVORK5CYII=';        \n            this.globeTexture = new GpuTexture(renderer.gpu, texture, this.core, null, true);\n        }\n\n        this.drawGlobe = element.checked;\n        this.drawGlobe = this.drawGlobe;\n        break;\n    }\n\n    map.markDirty();\n};\n\n\nInspectorReplay.prototype.updateLoadGraphs = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n    var loaded = replay.loaded;\n    var index = replay.loadedIndex;\n\n    this.timeSlider.max = loaded.length; \n\n    var ctx;   \n    var lx = 340;\n    var ly = 30;\n\n    this.ctxMeshes.fillStyle = '#000000';\n    this.ctxMeshes.fillRect(0, 0, lx, ly);\n    this.ctxTextures.fillStyle = '#000000';\n    this.ctxTextures.fillRect(0, 0, lx, ly);\n    this.ctxTextures2.fillStyle = '#000000';\n    this.ctxTextures2.fillRect(0, 0, lx, ly);\n    this.ctxGeodata.fillStyle = '#000000';\n    this.ctxGeodata.fillRect(0, 0, lx, ly);\n    this.ctxMetatiles.fillStyle = '#000000';\n    this.ctxMetatiles.fillRect(0, 0, lx, ly);\n    this.ctxIntervals.fillStyle = '#000000';\n    this.ctxIntervals.fillRect(0, 0, lx, ly);\n    this.ctxThreads.fillStyle = '#000000';\n    this.ctxThreads.fillRect(0, 0, lx, ly);\n\n    var i = Math.floor(replay.loadedIndex / lx) * lx, li = (lx-1);\n    var shift = i, file;\n    \n    for (i = 0; i < li; i++) {\n        file = loaded[i + shift];\n        \n        if (file) {\n            switch(file.kind) {\n            case 'mesh':       ctx = this.ctxMeshes; break;\n            case 'texture-in': ctx = this.ctxTextures; break;\n            case 'texture-ex': ctx = this.ctxTextures2; break;\n            case 'geodata':    ctx = this.ctxGeodata; break;\n            case 'metatile':   ctx = this.ctxMetatiles; break;\n            default:\n                continue;\n            }\n\n            var grey = Math.round(Math.min(255, 60+20 * Math.max(1, file.duration / 300)));\n            ctx.fillStyle='rgb('+grey+','+grey+','+grey+')';\n\n            var h = (file.duration / 300) * 30;                 \n            ctx.fillRect(i, ly, 1, -h);\n\n            //interval\n            grey = Math.round(Math.min(255, 60+20 * Math.max(1, file.interval / 300)));\n            this.ctxIntervals.fillStyle='rgb('+grey+','+grey+','+grey+')';\n            h = (file.interval / 300) * 30;                 \n            this.ctxIntervals.fillRect(i, ly, 1, -h);\n\n            //interval\n            this.ctxThreads.fillStyle='rgb(80,80,80)';\n            h = (file.threads / map.config.mapDownloadThreads) * 30;                 \n            this.ctxThreads.fillRect(i, ly, 1, -h);\n        }\n    }\n\n    var minMeshes = Number.MAX_VALUE, maxMeshes = 0, avgMeshes = 0, avgMeshesCount = 0;\n    var minTextures = Number.MAX_VALUE, maxTextures = 0, avgTextures = 0, avgTexturesCount = 0;\n    var minTextures2 = Number.MAX_VALUE, maxTextures2 = 0, avgTextures2 = 0, avgTextures2Count = 0;\n    var minGeodata = Number.MAX_VALUE, maxGeodata = 0, avgGeodata = 0, avgGeodataCount = 0;\n    var minMetatiles = Number.MAX_VALUE, maxMetatiles = 0, avgMetatiles = 0, avgMetatilesCount = 0;\n    var minThreads = Number.MAX_VALUE, maxThreads = 0, avgThreads = 0, avgThreadsCount = 0;\n    var minIntervals = Number.MAX_VALUE, maxIntervals = 0, avgIntervals = 0, avgIntervalsCount = 0;\n    \n    li = loaded.length;\n\n    for (i = 0; i < li; i++) {\n        file = loaded[i];\n        \n        if (file) {\n            \n            switch(file.kind) {\n            case 'mesh':\n                if (file.duration < minMeshes) minMeshes = file.duration; \n                if (file.duration > maxMeshes) maxMeshes = file.duration; \n                avgMeshes += file.duration;\n                avgMeshesCount++;  \n                break;\n                    \n            case 'texture-in':\n                if (file.duration < minTextures) minTextures = file.duration; \n                if (file.duration > maxTextures) maxTextures = file.duration; \n                avgTextures += file.duration;\n                avgTexturesCount++;  \n                break;\n                    \n            case 'texture-ex':\n                if (file.duration < minTextures2) minTextures2 = file.duration; \n                if (file.duration > maxTextures2) maxTextures2 = file.duration; \n                avgTextures2 += file.duration;\n                avgTextures2Count++;  \n                break;\n                    \n            case 'geodata':\n                if (file.duration < minGeodata) minGeodata = file.duration; \n                if (file.duration > maxGeodata) maxGeodata = file.duration; \n                avgGeodata += file.duration;\n                avgGeodataCount++;  \n                break;\n                    \n            case 'metatile':\n                if (file.duration < minMetatiles) minMetatiles = file.duration; \n                if (file.duration > maxMetatiles) maxMetatiles = file.duration; \n                avgMetatiles += file.duration;\n                avgMetatilesCount++;  \n                break;\n\n            default:\n                continue;\n            }\n                \n            if (file.threads < minThreads) minThreads = file.threads; \n            if (file.threads > maxThreads) maxThreads = file.threads; \n            avgThreads += file.threads;\n            avgThreadsCount++;  \n\n            if (file.threads < minIntervals) minIntervals = file.threads; \n            if (file.threads > maxIntervals) maxIntervals = file.threads; \n            avgIntervals += file.threads;\n            avgIntervalsCount++;  \n        }\n    }\n    \n    index -= shift;\n\n    this.ctxMeshes.fillStyle = '#ff0000';\n    this.ctxMeshes.fillRect(index - 1, 0, 1, ly);\n    this.ctxMeshes.fillRect(index + 1, 0, 1, ly);\n    this.ctxTextures.fillStyle = '#ff0000';\n    this.ctxTextures.fillRect(index - 1, 0, 1, ly);\n    this.ctxTextures.fillRect(index + 1, 0, 1, ly);\n    this.ctxTextures2.fillStyle = '#ff0000';\n    this.ctxTextures2.fillRect(index - 1, 0, 1, ly);\n    this.ctxTextures2.fillRect(index + 1, 0, 1, ly);\n    this.ctxGeodata.fillStyle = '#ff0000';\n    this.ctxGeodata.fillRect(index - 1, 0, 1, ly);\n    this.ctxGeodata.fillRect(index + 1, 0, 1, ly);\n    this.ctxMetatiles.fillStyle = '#ff0000';\n    this.ctxMetatiles.fillRect(index - 1, 0, 1, ly);\n    this.ctxMetatiles.fillRect(index + 1, 0, 1, ly);\n    this.ctxIntervals.fillStyle = '#ff0000';\n    this.ctxIntervals.fillRect(index - 1, 0, 1, ly);\n    this.ctxIntervals.fillRect(index + 1, 0, 1, ly);\n    this.ctxThreads.fillStyle = '#ff0000';\n    this.ctxThreads.fillRect(index - 1, 0, 1, ly);\n    this.ctxThreads.fillRect(index + 1, 0, 1, ly);\n\n    if (!avgMeshesCount) { minMeshes = 0, maxMeshes = 0; }\n    if (!avgTexturesCount) { minTextures = 0, maxTextures = 0; }\n    if (!avgTextures2Count) { minTextures2 = 0, maxTextures2 = 0; }\n    if (!avgGeodataCount) { minGeodata = 0, maxGeodata = 0; }\n    if (!avgMetatilesCount) { minMetatiles = 0, maxMetatiles = 0; }\n    if (!avgThreadsCount) { minThreads = 0, maxThreads = 0; }\n    if (!avgIntervalsCount) { minIntervals = 0, maxIntervals = 0; }\n\n    avgMeshes = avgMeshesCount ? (avgMeshes/avgMeshesCount) : 0;\n    avgTextures = avgTexturesCount ? (avgTextures/avgTexturesCount) : 0;\n    avgTextures2 = avgTextures2Count ? (avgTextures2/avgTextures2Count) : 0;\n    avgGeodata = avgGeodataCount ? (avgGeodata/avgGeodataCount) : 0;\n    avgMetatiles = avgMetatilesCount ? (avgMetatiles/avgMetatilesCount) : 0;\n    avgIntervals = avgIntervalsCount ? (avgIntervals/avgIntervalsCount) : 0;\n    avgThreads = avgThreadsCount ? (avgThreads/avgThreadsCount) : 0;\n\n    this.infoMeshes.innerHTML = 'Meshes Min/Max/Avg/Count: ' + minMeshes.toFixed(0) + '/' + maxMeshes.toFixed(0) + '/' + avgMeshes.toFixed(1) + '/' + avgMeshesCount;\n    this.infoTextures.innerHTML = 'Internal Textures Min/Max/Avg/Count: ' + minTextures.toFixed(0) + '/' + maxTextures.toFixed(0) + '/' + avgTextures.toFixed(1) + '/' + avgTexturesCount;\n    this.infoTextures2.innerHTML = 'External Textures Min/Max/Avg/Count: ' + minTextures2.toFixed(0) + '/' + maxTextures2.toFixed(0) + '/' + avgTextures2.toFixed(1) + '/' + avgTextures2Count;\n    this.infoGeodata.innerHTML = 'Geodata Min/Max/Avg/Count: ' + minGeodata.toFixed(0) + '/' + maxGeodata.toFixed(0) + '/' + avgGeodata.toFixed(1) + '/' + avgGeodataCount;\n    this.infoMetatiles.innerHTML = 'Metatiles Min/Max/Avg/Count: ' + minMetatiles.toFixed(0) + '/' + maxMetatiles.toFixed(0) + '/' + avgMetatiles.toFixed(1) + '/' + avgMetatilesCount;\n    this.infoIntervals.innerHTML = 'Intervals Min/Max/Avg: ' + minIntervals.toFixed(0) + '/' + maxIntervals.toFixed(0) + '/' + avgIntervals.toFixed(1);  \n    this.infoThreads.innerHTML = 'Threads Min/Max/Avg: ' + minThreads + '/' + maxThreads + '/' + avgThreads.toFixed(1);  \n};\n\n\nInspectorReplay.prototype.updateFileInfo = function(index) {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n    var file = replay.loaded[index];\n\n    if (file) {\n        this.timeInfo.innerHTML = ''\n            + 'Resource Kind: ' + file.kind + '<br/>'\n            + 'Time: ' + file.time.toFixed(2) + '<br/>'\n            + 'Duration: ' + file.duration.toFixed(2) + '<br/>'\n            + 'Interval: ' + file.interval.toFixed(2) + '<br/>'\n            + 'Priority: ' + file.priority.toFixed(2) + '<br/>'\n            + 'Threads: ' + file.threads + '<br/>'\n            + '' + file.url;\n    } else {\n        this.timeInfo.innerHTML = '';\n    }\n};\n\n\nInspectorReplay.prototype.buildReplayCombo = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var items = [\n        ['Drawn Tiles',1],\n        ['Drawn Tiles - Free Layers',1],\n        ['Traced Nodes',1],\n        ['Traced Nodes - Free Layers',1],\n        ['Load Sequence',2],\n        ['Camera',2],\n        ['Globe',0]\n    ];\n\n    var keys = [\n        'DrawnTiles',\n        'DrawnTilesFreeLayers',\n        'TracedNodes',\n        'TracedNodesFreeLayers',\n        'LoadSequence',\n        'Camera',\n        'Globe'\n    ];\n\n    var html = '', i, li, htmlId;\n\n    for (i = 0, li = items.length; i < li; i++) {\n        html += '<div id=\"vts-replay-item-' + keys[i] + '\" class=\"vts-replay-item\">'\n                 + '<input id=\"vts-replay-checkbox-' + keys[i] + '\" type=\"checkbox\"/>'\n                 + '<span title=' + items[i][0] + '>' + items[i][0] + '&nbsp;&nbsp;</span>';\n                 \n        if (items[i][1] > 0) {\n            html += '<input id=\"vts-replay-sbutton-' + keys[i] + '\" type=\"button\" value=\"S\"/>';\n        }\n        \n        if (items[i][1] > 1) {\n            html += '<input id=\"vts-replay-fbutton-' + keys[i] + '\" type=\"button\" value=\"' + ((keys[i] == 'Camera') ? 'R' : 'F') + '\"/>';\n        }\n        \n        html += '</div>';\n    }\n\n    this.items.innerHTML = html;\n    //this.currentItem = keys[0];\n\n    for (i = 0, li = items.length; i < li; i++) {\n        htmlId = 'vts-replay-checkbox-' + keys[i];\n        document.getElementById(htmlId).onchange = this.switchItem.bind(this, keys[i], htmlId);\n        //var htmlId = \"vts-replay-item-\" + keys[i];\n        //document.getElementById(htmlId).onclick = this.selectReplayItem.bind(this, keys[i]);\n\n        if (items[i][1] > 0) {\n            htmlId = 'vts-replay-sbutton-' + keys[i];\n            document.getElementById(htmlId).onclick = this.itemButton.bind(this, keys[i], 'S');\n        }\n\n        if (items[i][1] > 1) {\n            htmlId = 'vts-replay-fbutton-' + keys[i];\n            document.getElementById(htmlId).onclick = this.itemButton.bind(this, keys[i], ((keys[i] == 'Camera') ? 'R' : 'F'));\n        }\n    }\n};\n\n\nexport default InspectorReplay;\n\n","\n\nimport {getCoreVersion} from '../core';\n\n\nvar InspectorStats = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorStats.prototype.init = function() {\n    var inspector = this.inspector;\n    inspector.addStyle(\n        '#vts-stats-panel {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'display: none;'\n            + 'padding:15px;'\n            + 'width: 305px;'\n            + 'font-size: 14px;'\n            + 'position: absolute;'\n            + 'right: 10px;'\n            + 'top: 10px;'\n            + 'cursor: default;'\n            + 'background-color: rgba(255,255,255,0.95);'\n            + 'border-radius: 5px;'\n            + 'border: solid 1px #ccc;'\n            + 'text-align: left;'\n            + 'z-index: 7;'\n            + 'padding: 10px;'\n        + '}'\n\n        + '#vts-stats-panel-info {'\n            + 'margin-top: 5px;'\n            + 'margin-bottom: 3px;'\n            + 'overflow: hidden;'\n        + '}'\n\n        + '#vts-stats-panel-info table {'\n            + 'color:#000000;'\n            + 'text-align: left;'\n            + 'font-size: 12px;'\n        + '}'\n\n        + '#vts-stats-panel-info table td {'\n            + 'vertical-align: top;'\n        + '}'\n\n        + '#vts-stats-panel-pos {'\n            + 'width: 100%;'\n        + '}'\n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-stats-panel';\n    this.element.innerHTML =\n        '<span id=\"vts-stats-panel-title\">Render statistics &nbsp;&nbsp;&nbsp;v' + getCoreVersion() + '</h3>'+\n        '<p id=\"vts-stats-panel-info\"></p>'+\n        '<input id=\"vts-stats-panel-pos\" type=\"text\">';\n\n    this.core.element.appendChild(this.element);\n    this.infoElement = document.getElementById('vts-stats-panel-info');\n    this.posElement = document.getElementById('vts-stats-panel-pos');\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.panelVisible = false;\n};\n\n\nInspectorStats.prototype.showPanel = function() {\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n};\n\n\nInspectorStats.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n};\n\n\nInspectorStats.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorStats.prototype.updateStatsPanel = function(stats) {\n    if (!this.infoElement || !this.panelVisible) {\n        return;\n    }\n    var inspector = this.inspector;\n    \n    var text2 =\n            'FPS: ' + Math.round(stats.fps) + '<br/>' +\n            'Render time: ' + Math.round(stats.renderTime*1000) + '<br/>' +\n            ' - resources: ' + Math.round(stats.gpuRenderUsed/(1024*1024)) + 'MB<br/>' +\n            ' - topdown: ' + Math.round(stats.gpuNeeded/(1024*1024)) + 'MB<br/>' +\n            //\" - resources: \" + (stats.gpuRenderUsed) + \" --- \" + (stats.gpuRenderUsed / stats.drawnTiles) + \"<br/>\" +\n            'GPU Cache: ' + Math.round(stats.gpuUsed/(1024*1024)) + 'MB<br/>' +\n            ' - textures: ' + Math.round(stats.gpuTextures/(1024*1024)) + 'MB<br/>' +\n            ' - meshes: ' + Math.round(stats.gpuMeshes/(1024*1024)) + 'MB<br/>' +\n            ' - geodata: ' + Math.round(stats.gpuGeodata/(1024*1024)) + 'MB<br/>' +\n            'CPU Cache: ' + Math.round(stats.resourcesUsed/(1024*1024)) + 'MB<br/>' +\n            'Metatile Cache: ' + Math.round(stats.metaUsed/(1024*1024)) + 'MB<br/>' +\n//            \"FOV: \" + Math.round(this.core.getOption(\"fov\")) + \" deg<br/>\" +\n//            \"viewHeight: \" + Math.round(this.core.getOption(\"viewHeight\")) + \" m<br/>\" +\n//            \"distance: \" + Math.round(this.core.renderer.cameraDistance) + \" m<br/>\" +\n            'Draw calls: ' + (stats.drawCalls) + '<br/>' +\n            'Polygons: ' + (stats.drawnFaces) + '<br/><br/>' +\n            'Terrain Height: ' + (stats.heightTerrain.toFixed(2)) + '<br/>' +\n            '- float: ' + (stats.heightDelta.toFixed(2)) + '<br/>' +\n            '- desired lod: ' + (stats.heightLod.toFixed(2)) + '<br/>' +\n            '- used lod: ' + (stats.heightNode.toFixed(2)) + '<br/>' +\n            '- used source: ' + ((stats.heightClass == 2 ? 'navtile' : stats.heightClass == 1 ? 'node': '---') ) + '<br/>' +\n            'Terrain Radar Lod: ' + (inspector.radarLod) + '<br/><br/>' + \n            'Loaded/Errors: ' + (stats.loadedCount) + ' / ' + (stats.loadErrorCount) + '<br/>' +\n            'Load time: ' + ((stats.loadLast - stats.loadFirst)*0.001).toFixed(2) + 's <br/>';\n\n    var renderer = this.core.renderer;\n\n    if (renderer) {\n        text2 += '<br/>Render jobs: ' + renderer.totalJobs + '<br/>' +\n                 'Drawn jobs: ' + renderer.drawnJobs + '<br/>' +\n                 'Jobs total time: ' +  Math.round((renderer.jobsTimer2 - renderer.jobsTimer1)*1000) + '<br/>' +\n                 'Jobs reduce time: ' + Math.round((renderer.jobsTimer4)*1000) + '<br/>';\n    }\n\n    if (stats.debugStr) {\n        text2 += stats.debugStr + '<br/>';        \n    }\n\n    var text3 =  'PixelRatio: ' + (window.devicePixelRatio || 1).toFixed(3) +'<br/>'+\n                 'BFRate: ' + Math.round(1000 / (stats.frameTime+0.00001)) +'<br/><br/>';\n\n    var map = this.core.getMap();\n\n    if (map) {\n        text3 += 'ReduceMode: ' +'<br/>'+ map.config.mapFeaturesReduceMode +'<br/>'+\n                 'ReduceParams: ' +'<br/>'+ JSON.stringify(map.config.mapFeaturesReduceParams) +'<br/><br/>';\n\n        if (map.draw.debug.meshStats) {\n            text3 += 'TexelsPerPoly: ' + (stats.meshesUVArea / Math.max(1,stats.meshesFaces)).toFixed(2) +'<br/><br/>';\n        }\n    }\n\n    text3 += 'Metatiles: ' + (stats.processedMetatiles) +'<br/>'+\n             'Metanodes: ' + (stats.processedNodes) + ' / ' + (stats.usedNodes) + '<br/>'+\n             'GeodataTiles: ' + (stats.drawnGeodataTiles) + '<br/>';\n\n    if (stats.octoNodes) {\n        text3 += 'OctoNodes: ' + (stats.octoNodes) +'<br/>'+\n                 'OctoNodesMem: ' + Math.round(stats.octoNodesMemSize/(1024*1024)) + 'MB<br/>';\n    }\n\n    text3 += '<br/>';\n\n    if (renderer) {\n        text3 += 'Nodes: ' + (renderer.drawnNodes) +'<br/><br/>';\n    }\n\n    text3 += 'Tiles: ' + (stats.drawnTiles) +'<br/>';\n\n    for (var i =0, li = stats.renderedLods.length; i < li; i++) {\n        if (stats.renderedLods[i]) {\n            text3 += 'LOD ' + i + ': ' + (stats.renderedLods[i]) +'<br/>';\n        }\n    }\n\n\n    var text = '<table style=\"width:305px\"><tr><td>' + text2 + '</td><td>' + text3 + '</td></tr></table>';\n\n    this.infoElement.innerHTML = text;\n\n    if (map) {\n        var p = map.getPosition();\n        var s = '';\n        s += p.getViewMode() + ',';\n        var c = p.getCoords();\n        s += c[0] + ',' + c[1] + ',' + p.getHeightMode() + ',' + c[2].toFixed(2) + ',';\n        var o = p.getOrientation();\n        s += o[0].toFixed(2) + ',' + o[1].toFixed(2) + ',' + o[2].toFixed(2) + ',';\n        s += p.getViewExtent().toFixed(2) + ',' + p.getFov().toFixed(2);\n        \n        //var value = JSON.stringify(p.pos);\n\n        if (this.posElement.value != s) {\n            this.posElement.value = s;\n        }\n    }\n};\n\n\nexport default InspectorStats;\n\n","\nvar InspectorStylesheets = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorStylesheets.prototype.init = function() {\n    var inspector = this.inspector;\n    inspector.addStyle(\n        '#vts-stylesheets-panel * {'\n            + 'all: initial;'\n        + '}'\n\n        + '#vts-stylesheets-panel {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'display: none;'\n            + 'padding:15px;'\n            + 'width: 1200px;'\n            + 'height: 350px;'\n            + 'font-size: 14px;'\n            + 'position: absolute;'\n            + 'right: 10px;'\n            + 'bottom: 10px;'\n            + 'cursor: default;'\n            + 'background-color: rgba(255,255,255,0.95);'\n            + 'border-radius: 5px;'\n            + 'border: solid 1px #ccc;'\n            + 'text-align: left;'\n            + 'z-index: 7;'\n            + 'padding: 10px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-header {'\n            + 'width: 100%;'\n            + 'height: 28px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-combo {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'font-size: 13px;'\n            + 'border: 1px solid #a9a9a9;'\n            + 'width: 1070px;'\n            + 'height: 17px;'\n            + 'padding: 2px;'\n            + 'margin-bottom: 5px;'\n            + '-webkit-appearance: menulist;'\n            + '-moz-appearance: menulist;'\n        + '}'\n\n        + '#vts-stylesheets-panel-combo option {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'font-size: 13px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-update-button {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'font-size: 14px;'\n            + 'float: right;'\n            + 'background-color: #dedede;'\n            + 'padding: 3px 2px 2px 2px;'\n            + 'border: 1px solid #a0a0a0;'\n            + 'border-radius: 2px;'\n            + 'margin-right: 5px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-hide-button {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'font-size: 14px;'\n            + 'float: right;'\n            + 'background-color: #dedede;'\n            + 'padding: 3px 2px 2px 2px;'\n            + 'border: 1px solid #a0a0a0;'\n            + 'border-radius: 2px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-text {'\n            + 'font-family: monospace;'\n            + 'border: 1px solid #a9a9a9;'\n            + 'padding: 2px 0px 0px 2px;'\n            + 'width: 100%;'\n            + 'height: 300px;'\n            + 'resize: none;'\n            + 'white-space: pre;'\n        + '}'\n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-stylesheets-panel';\n    this.element.innerHTML =\n            '<div id=\"vts-stylesheets-panel-header\">'\n            + '<select id=\"vts-stylesheets-panel-combo\"></select>'\n            + '<button id=\"vts-stylesheets-panel-hide-button\" type=\"button\" title=\"Hide\">Hide</button>'\n            + '<button id=\"vts-stylesheets-panel-update-button\" type=\"button\" title=\"Update\">Update</button>'\n          + '</div>'\n          + '<textarea id=\"vts-stylesheets-panel-text\" rows=\"4\" cols=\"50\">aa\\naa\\n</textarea>';\n\n    //this.inspectorElement.appendChild(this.element);\n    this.core.element.appendChild(this.element);\n\n    this.optionsElement = document.getElementById('vts-stylesheets-panel-combo');\n    this.optionsElement.onchange = this.onComboSwitched.bind(this);\n\n    this.textElement = document.getElementById('vts-stylesheets-panel-text');\n    \n    document.getElementById('vts-stylesheets-panel-update-button').onclick = this.onUpdate.bind(this);\n    document.getElementById('vts-stylesheets-panel-hide-button').onclick = this.hidePanel.bind(this);\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.textElement.addEventListener('keyup', inspector.doNothing.bind(this), false);\n    this.textElement.addEventListener('keydown', inspector.doNothing.bind(this), false);\n\n    this.panelVisible = false;\n};\n\n\nInspectorStylesheets.prototype.showPanel = function() {\n    this.buildStylesheetsCombo();\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n};\n\n\nInspectorStylesheets.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n};\n\n\nInspectorStylesheets.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorStylesheets.prototype.onComboSwitched = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var stylesheet = map.getStylesheet(this.optionsElement.value);\n    this.textElement.value = this.niceStyleFormat(stylesheet);\n};\n\n\nInspectorStylesheets.prototype.onUpdate = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    map.setStylesheetData(this.optionsElement.value, JSON.parse(this.textElement.value));\n};\n\n\nInspectorStylesheets.prototype.niceStyleFormat = function(data) {\n    if (!data || !data.data) {\n        return '';\n    }\n    \n    data = data.data;\n\n    //return JSON.stringify(data, null, \"  \");\n    \n    var tmp = '';\n    tmp += '{\\n';\n\n    var elements = [];\n\n    if (data['constants']) {\n        elements.push('constants');\n    } \n\n    if (data['bitmaps']) {\n        elements.push('bitmaps');\n    } \n\n    if (data['fonts']) {\n        elements.push('fonts');\n    } \n\n    if (data['layers']) {\n        elements.push('layers');\n    } \n    \n    for (var j = 0, lj = elements.length; j < lj; j++) {\n        var type = elements[j];\n        tmp += '  \"' + type + '\": {\\n';\n\n        var element = data[type];\n\n        var buff = [];\n        for (var key in element) {\n            buff.push(key);\n        }\n\n        for (var i = 0, li = buff.length; i < li; i++) {\n            if (type == 'layers') {\n                \n                var element2 = element[buff[i]];\n                \n                var buff2 = [];\n                for (var key2 in element2) {\n                    buff2.push(key2);\n                }\n\n                tmp += '    \"' + buff[i] + '\": {\\n';\n\n                for (var k = 0, lk = buff2.length; k < lk; k++) {\n                    tmp += '      \"' + buff2[k] + '\": ' + JSON.stringify(element2[buff2[k]]) + (k == (lk - 1) ? '' : ',') + '\\n';\n                }\n                \n                tmp += '    }'  + (i == (li - 1) ? '' : ',\\n');\n            } else {\n                tmp += '    \"' + buff[i] + '\": ' + JSON.stringify(element[buff[i]]) + (i == (li - 1) ? '' : ',') + '\\n';\n            }\n        }\n        \n        tmp += '\\n  }' + (j == (lj - 1) ? '' : ',\\n');\n    }\n    \n    tmp += '\\n}';\n    \n    return tmp;\n};\n\n\nInspectorStylesheets.prototype.buildStylesheetsCombo = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var html = '';\n\n    var styles = map.getStylesheets();\n    \n    for (var i = 0, li = styles.length; i < li; i++) {\n        html += '<option value=\"' + styles[i] + '\">' + styles[i] + '</option>';\n    }    \n    \n    this.optionsElement.innerHTML = html;\n    \n    var stylesheet = map.getStylesheet(styles[0]);\n    this.textElement.value = this.niceStyleFormat(stylesheet);\n};\n\n\nexport default InspectorStylesheets;\n\n","\nimport Proj4 from 'melowntech-proj4';\nimport earcut from 'earcut';\nimport {Core as Core_} from './core';\n//import {CoreInterface as CoreInterface_} from './interface';\n\n//get rid of compiler mess\n//var CoreInterface = CoreInterface_;\nvar Core = Core_;\nvar proj4 = Proj4;\n\n\nvar CoreInterface = function(element, config) {\n    this.core = new Core(element, config, this);\n\n    Object.defineProperty(this, 'map', {\n        get: function() {\n            if (!this.core) { return null; }\n            return this.core.getMapInterface();\n        }\n    });\n\n    Object.defineProperty(this, 'renderer', {\n        get: function() {\n            if (!this.core) { return null; }\n            return this.core.getRendererInterface();\n        }\n    });\n\n    Object.defineProperty(this, 'proj4', {\n        get: function() {\n            if (!this.core) { return null; }\n            return proj4;\n        }\n    });\n\n    Object.defineProperty(this, 'earcut', {\n        get: function() {\n            if (!this.core) { return null; }\n            return earcut;\n        }\n    });\n};\n\n\nCoreInterface.prototype.destroy = function() {\n    this.core.destroy();\n    this.core = null;\n};\n\n\nCoreInterface.prototype.loadMap = function(path) {\n    if (!this.core) { return null; }\n    return this.core.loadMap(path);\n};\n\n\nCoreInterface.prototype.destroyMap = function() {\n    if (!this.core) { return null; }\n    return this.core.destroyMap();\n};\n\n\n/*CoreInterface.prototype.getMap = function() {\n    if (!this.core) { return null; }\n    return this.core.getMapInterface();\n};\n\n\nCoreInterface.prototype.getRenderer = function() {\n    if (!this.core) { return null; }\n    return this.core.getRendererInterface();\n};\n\n\nCoreInterface.prototype.getProj4 = function() {\n    if (!this.core) { return null; }\n    return this.core.getProj4();\n};*/\n\n\nCoreInterface.prototype.on = function(eventName, call) {\n    if (!this.core) { return null; }\n    return this.core.on(eventName, call);\n};\n\nCoreInterface.prototype.once = function(eventName, call, wait) {\n    if (!this.core) { return null; }\n    return this.core.once(eventName, call, wait);\n};\n\nCoreInterface.prototype.callListener = function(name, event) {\n    if (!this.core) { return null; }\n    this.core.callListener(name, event);\n};\n\n\nexport {CoreInterface};\n","\nvar MapBody = function(map, json) {\n    //this.map = map;\n    //this.id = json[\"id\"] || null;\n    this.parse(json);\n};\n\n\nMapBody.prototype.parse = function(json) {\n    this.class = json['class'] || '';\n    this.comment = json['comment'] || '';\n    this.parent = json['parent'] || '';\n    this.atmosphere = json['atmosphere'] || null;\n\n    if (this.atmosphere) {\n        if (!this.atmosphere['colorHorizon']) this.atmosphere['colorHorizon'] = [0,0,0,0];\n        if (!this.atmosphere['colorZenith']) this.atmosphere['colorZenith'] = [0,0,0,0];\n        if (!this.atmosphere['thickness'])  this.atmosphere['thickness'] = 100000;\n        if (!this.atmosphere['visibility'])  this.atmosphere['visibility'] = 100000;\n    }\n};\n\n\nMapBody.prototype.getInfo = function() {\n    return {\n        'class' : this.class,\n        'comment' : this.comment,\n        'parent' : this.parent,\n        'atmosphere' : JSON.parse(JSON.stringify(this.atmosphere)),\n    };\n};\n\n\nexport default MapBody;","\nimport MapCredit_ from './credit';\nimport {utils as utils_} from '../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../utils/url';\n\n//get rid of compiler mess\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\nvar MapCredit = MapCredit_;\n\n\nvar MapBoundLayer = function(map, json, id) {\n    this.map = map;\n    this.id = id;\n    this.currentAlpha = 1.0;\n\n    this.tileSize = [256,256];\n    this.lodRange = [0,100];\n    this.credits = [];\n    this.tileRange = [[0,0],[0,0]];\n    this.jsonUrl = null;\n    this.baseUrl = this.map.url.baseUrl;\n    this.baseUrlSchema = this.map.url.baseUrlSchema;\n    this.baseUrlOrigin = this.map.url.baseUrlOrigin;\n    this.ready = false;\n    this.dataType = VTS_TEXTURETYPE_COLOR;\n    this.shaderFilters = null;\n\n    //hack\n    if (id == 'esri-world-imagery') {\n        json['availability'] = {\n             // \"type\" : \"negative-type\",\n             // \"mime\": \"image/png\"\n             // \"type\" : \"negative-code\",\n             // \"codes\": [301, 302, 404]\n            'type' : 'negative-size',\n            'size': 2521\n        };  \n    }\n    \n    if (typeof json === 'string') {\n        this.jsonUrl = this.map.url.processUrl(json);\n        this.baseUrl = utilsUrl.getBase(this.jsonUrl);\n        this.baseUrlSchema = utilsUrl.getSchema(this.jsonUrl);\n        this.baseUrlOrigin = utilsUrl.getOrigin(this.jsonUrl);\n        \n        var onLoaded = (function(data){\n            this.parseJson(data);            \n            this.ready = true;\n            this.map.refreshView();\n        }).bind(this);\n        \n        var onError = (function(){ }).bind(this);\n\n        utils.loadJSON(this.jsonUrl, onLoaded, onError, null, (utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n        //utils.loadJSON(this.url, onLoaded, onError, null, utils.useCredentials);\n    } else {\n        this.parseJson(json);\n        this.ready = true;\n    }\n    \n};\n\n\nMapBoundLayer.prototype.parseJson = function(json) {\n    this.numberId = json['id'] || null;\n    this.type = json['type'] || 'raster';\n    this.url = this.processUrl(json['url'], '');\n    this.tileSize = json['tileSize'] || [256,256];\n    this.lodRange = json['lodRange'] || [0,0];\n    this.tileRange = json['tileRange'] || [[0,0],[0,0]];\n    this.metaUrl = this.processUrl(json['metaUrl']);\n    this.maskUrl = this.processUrl(json['maskUrl']);\n    this.isTransparent = json['isTransparent'] || false;\n    this.options = json['options'] || {};\n    this.credits = json['credits'] || [];\n    this.creditsUrl = null;\n\n    this.shaderFilter = this.options['shaderFilter'] || null;\n\n    switch(json['dataType']) {\n        default:\n        case 'color':          this.dataType = VTS_TEXTURETYPE_COLOR;  break;\n        case 'height':         this.dataType = VTS_TEXTURETYPE_HEIGHT; break;\n        case 'classification': this.dataType = VTS_TEXTURETYPE_CLASS;  break;\n    }\n\n    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    \n\n    this.availability = json['availability'] ? {} : null;\n\n    if (this.availability) {\n        var p = json['availability'];\n\n        switch(p['type']) {\n            case 'negative-type': this.availability.type = VTS_TEXTURECHECK_TYPE; break;\n            case 'negative-code': this.availability.type = VTS_TEXTURECHECK_CODE; break;\n            case 'negative-size': this.availability.type = VTS_TEXTURECHECK_SIZE; break;\n        }\n\n        this.availability.mime = p['mime'];\n        this.availability.codes = p['codes'];\n        this.availability.size = p['size'];\n        //this.availability.coverageUrl = p[\"coverageUrl\"];\n    }\n\n    if (this.metaUrl && this.maskUrl) {\n        this.availability = {\n            type : VTS_TEXTURECHECK_MEATATILE\n        };\n    }\n\n    switch(typeof this.credits) {\n    case 'string':\n        this.creditsUrl = this.credits;\n        this.credits = [];\n        break;\n\n    case 'object':\n        \n        if (!Array.isArray(this.credits)) {\n            var credits = this.credits;\n            this.credits = [];\n                \n            for (var key in credits){\n                this.map.addCredit(key, new MapCredit(this.map, credits[key]));\n                this.credits.push(key);\n            }\n        }\n\n        /*\n        for (var i = 0, li = this.credits.length; i < li; i++) {\n            var credit = this.map.getCreditById(this.credits[i]);\n                //this.creditsNumbers.push(credit ? credit.id : null); \n        }*/\n        \n        break;\n    }\n};\n\n\nMapBoundLayer.prototype.kill = function() {\n};\n\n\nMapBoundLayer.prototype.setOptions = function() {\n};\n\n\nMapBoundLayer.prototype.getOptions = function() {\n    return this.getInfo();\n};\n\n\nMapBoundLayer.prototype.getInfo = function() {\n    return {\n        'type' : this.type,\n        'url' : this.url,\n        'tileSize' : this.tileSize,\n        'credits' : this.credits,\n        'lodRange' : this.lodRange,\n        'tileRange' : this.tileRange,\n        'mataUrl' : this.metaUrl,\n        'maskUrl' : this.maskUrl,\n        'isTransparent' : this.isTransparent\n    };\n};\n\n\nMapBoundLayer.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n\n    url = url.trim();\n    \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.baseUrlOrigin + url;\n    } else {  //relative\n        return this.baseUrl + url; \n    }\n};\n\n\nMapBoundLayer.prototype.hasTile = function(id) {\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift < 0) {\n        return false;\n    }\n\n    var x = id[1] >> shift;\n    var y = id[2] >> shift;\n\n    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||\n        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n        return false;\n    }\n\n    return true;\n};\n\n\nMapBoundLayer.prototype.hasTileOrInfluence = function(id) {\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift < 0) {\n        return false;\n    }\n\n    var x = id[1] >> shift;\n    var y = id[2] >> shift;\n\n    if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n        return 0;\n    }\n\n    return (id[0] > this.lodRange[1]) ? 1 : 2;\n};\n\n\nMapBoundLayer.prototype.getUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.url, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapBoundLayer.prototype.getMetatileUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapBoundLayer.prototype.getMaskUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.maskUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nexport default MapBoundLayer;\n\n\n","\n\nvar MapCache = function(map, maxCost) {\n    this.map = map;\n    this.maxCost = (maxCost != null) ? maxCost : Number.MAX_VALUE;\n    this.skipCostCheck = false;\n    this.last = null;\n    this.first = null;\n\n    this.totalCost = 0;\n    this.totalItems = 0;\n};\n\n\nMapCache.prototype.updateItem = function(item) {\n    if (item == null) {\n        return;\n    }\n\n    if (this.first == item) {\n        return;\n    }\n\n    //remove item from list\n    if (item.prev != null) {\n        item.prev.next = item.next;\n    }\n\n    if (item.next != null) {\n        item.next.prev = item.prev;\n    }\n\n    if (this.last == item) {\n        this.last = item.prev;\n    }\n\n    var first = this.first;\n\n    //add item as first\n    this.first = item;\n    this.first.next = first;\n    this.first.prev = null;\n\n    first.prev = this.first;\n};\n\n\nMapCache.prototype.getMaxCost = function() {\n    return this.maxCost;\n};\n\n\nMapCache.prototype.setMaxCost = function(cost) {\n    this.maxCost = cost;\n    this.checkCost();\n};\n\n\nMapCache.prototype.clear = function() {\n    var item = this.first;\n\n    while (item != null) {\n        if (item.destructor != null) {\n            item.destructor();\n        }\n        item = item.next;\n    }\n\n    this.last = null;\n    this.first = null;\n\n    this.totalCost = 0;\n    this.totalItems = 0;\n};\n\n\nMapCache.prototype.insert = function(destructor, cost) {\n    this.totalItems++;\n\n    //console.log(\"insert: \" + hash + \" items: \" + this.totalItems);\n\n    var item = { destructor:destructor, cost:cost, prev: null, next:this.first };\n\n    if (this.first != null) {\n        this.first.prev = item;\n    }\n\n    //add item as first in list\n    this.first = item;\n\n    if (this.last == null) {\n        this.last = item;\n    }\n\n    this.totalCost += cost;\n\n    //console.log(\"MapCache.prototype.insert:\" + this.totalCost + \" / \" + this.maxCost);\n\n    this.checkCost();\n\n    return item;\n};\n\n\nMapCache.prototype.remove = function(item) {\n    this.totalItems++;\n    var hit = false;\n\n    if (item == this.first) {\n        this.first = item.next;\n        hit = true;\n\n        if (this.first != null) {\n            this.first.prev = null;\n        }\n    }\n\n    if (item == this.last) {\n        this.last = item.prev;\n        hit = true;\n\n        if (this.last != null) {\n            this.last.next = null;\n        }\n    }\n\n    if (!hit) {\n    //if (item != this.last && item != this.first) {\n\n        if (!item.prev) {\n            //debugger;\n        } else {\n            item.prev.next = item.next;\n        }\n        \n        if (!item.next) {\n            //debugger;\n        } else {\n            item.next.prev = item.prev;\n        }\n        \n    }\n\n    this.totalCost -= item.cost;\n\n    //destroy item\n    item.destructor();\n\n    //console.log(\"MapCache.prototype.remove:\" + this.totalCost + \" / \" + this.maxCost);\n\n    this.checkCost();\n};\n\n\nMapCache.prototype.checkCost = function() {\n    if (this.skipCostCheck) {\n        return;\n    }\n\n    while (this.totalCost > this.maxCost) {\n\n        this.totalItems--;\n\n        //console.log(\"remove: \" + this.last.hash + \" prev: \" + this.last.prev + \" items: \" + this.totalItems);\n\n        var last = this.last;\n\n        if (last != null) {\n            //set new last\n            this.last = this.last.prev;\n\n            if (this.last != null) {\n                this.last.next = null;\n            }\n\n            this.totalCost -= last.cost;\n\n            //destroy item\n            last.destructor();\n\n        } else {\n            break;\n        }\n    }\n};\n\n\nMapCache.prototype.addItem = function(cost, destructor) {\n    return this.insert(destructor, cost);\n};\n\n\nMapCache.prototype.removeItem = function(item) {\n    return this.remove(item);\n};\n\n\nMapCache.prototype.itemUsed = function(item) {\n    return this.updateItem(item);\n};\n\n/*\nMapCache.prototype[\"addItem\"] = MapCache.prototype.addItem;\nMapCache.prototype[\"removeItem\"] = MapCache.prototype.removeItem;\nMapCache.prototype[\"itemUsed\"] = MapCache.prototype.itemUsed;\n*/\n\nexport default MapCache;","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar math = math_;\n\n\nvar MapCamera = function(map) {\n    this.map = map;\n    this.camera = map.renderer.camera;\n    this.distance = 10;\n    this.distance2 = 10;\n    this.position = [0,0,0];\n    this.vector = [0,0,1];\n    this.vector2 = [0,0,1,1];\n    this.center = [0,0,0];\n    this.height = 0;\n    this.terrainHeight = 0;\n    this.lastTerrainHeight = 0;\n    this.near = 2;\n};\n\n\nMapCamera.prototype.update = function() {\n    var map = this.map;\n\n    //check position orientaion ...\n    map.position.check();\n\n    //var height = 227;\n    var height = map.position.getHeight();\n\n    var lod =  map.measure.getOptimalHeightLod(map.position.getCoords(), map.position.getViewExtent(), map.config.mapNavSamplesPerViewExtent);\n    //var surfaceHeight = [226,true,true]; //map.getSurfaceHeight(map.position.getCoords(), lod, true);\n    var surfaceHeight = map.measure.getSurfaceHeight(map.position.getCoords(), lod, true);\n    \n    map.stats.heightTerrain = surfaceHeight[0];\n    map.stats.heightDelta = height;\n\n    //console.log(\"terrain height:\" + surfaceHeight[0] + \"  pos height:\" + map.position.getHeight());\n\n    if (map.position.getHeightMode() == 'float') {\n        height += surfaceHeight[0];\n    }\n\n    if (map.renderer.useSuperElevation) {\n        height = map.renderer.getSuperElevatedHeight(height);\n    }\n\n    var camInfo = map.measure.getPositionCameraInfo(map.position, map.getNavigationSrs().isProjected());\n\n    this.camera.setPosition(camInfo.orbitCoords);\n    this.camera.setRotationMatrix(camInfo.rotMatrix);\n    this.vector = camInfo.vector;\n    this.vector2 = camInfo.vector2;\n    this.position = camInfo.orbitCoords;\n    this.height = camInfo.orbitHeight + height;\n    this.terrainHeight = this.height - surfaceHeight[0];\n\n    //console.log(''+this.height + ' ' + this.terrainHeight + ' ' + surfaceHeight[0]);\n\n    //get camera distance\n    this.distance2 = map.position.getViewDistance();\n    this.distance = Math.max(this.terrainHeight, this.distance2);\n    this.distance = math.clamp(this.distance, 0.1, this.camera.getFar());\n\n    this.distanceFactor = Math.tan(math.radians(map.position.getFov()*0.5)); \n\n    this.perceivedDistance = Math.max(this.terrainHeight, this.distance2 * this.distanceFactor);\n    \n    //this.renderer.cameraDistance = camInfo.distance; //needed for fog\n    map.renderer.cameraDistance = this.distance; //needed for fog\n    map.renderer.viewExtent = map.position.getViewExtent();\n\n    this.camera.setViewHeight(map.position.getViewExtent());\n    //this.camera.setOrtho(true);\n\n    //convert nav coords to physical\n    var coords = map.position.getCoords();\n    var worldPos = map.convert.convertCoords([coords[0], coords[1], height], 'navigation', 'physical');\n    this.center = [worldPos[0], worldPos[1], worldPos[2]];\n    worldPos[0] += camInfo.orbitCoords[0];\n    worldPos[1] += camInfo.orbitCoords[1];\n    worldPos[2] += camInfo.orbitCoords[2];\n    this.camera.setPosition([0,0,0]); //always zeros\n    this.position = worldPos;\n\n    this.vector2 = [-worldPos[0], -worldPos[1], -worldPos[2], 1];\n    vec3.normalize(this.vector2);\n\n    this.mapIsProjected = map.getNavigationSrs().isProjected();\n\n    if (!this.mapIsProjected) { //HACK!!!!!!!!\n        this.geocentDistance = vec3.length(this.position);\n\n        var n = [0,0,0];\n        vec3.normalize(this.position, n);\n        this.geocentNormal = n;\n    } else {\n        this.vector2[3] = 0;\n    }\n    \n    //console.log(\"word-pos: \" + JSON.stringify(worldPos));\n\n    //set near and far of camera by distance of orbit\n    var factor = Math.max(this.height, this.distance) / 600000;\n\n    var near = Math.max(this.near, this.near * (factor * 20));\n    factor = Math.max(1.0, factor);\n    var far = 600000 * (factor * 10);\n\n    //console.log(\"near: \" + near + \"  far: \" + far);\n\n    this.camera.setParams(map.position.getFov()*0.5, near, far * 2.0);\n    \n    return camInfo;\n};\n\n\nMapCamera.prototype.getCameraHeight = function() {\n    //TODO: get camera height\n    //var cameraPos = this.camera.position;\n    //return (this.camera.getPosition()[2] - this.planet.surfaceHeight([this.position[0] + cameraPos[0], this.position[1] + cameraPos[1]])[0]);\n\n    //hack - distance intead of height\n    //return this.cameraDistance;\n    return this.cameraHeight;\n};\n\n\nMapCamera.prototype.getMvpMatrix = function() {\n    return this.camera.getMvpMatrix();\n};\n\n\nMapCamera.prototype.getRotationMatrix = function() {\n    return this.camera.getRotationMatrix();\n};\n\n\nMapCamera.prototype.getRotationviewMatrix = function() {\n    return this.camera.getRotationviewMatrix();\n};\n\n\nMapCamera.prototype.getFar = function() {\n    return this.camera.getFar();\n};\n\n\nMapCamera.prototype.getFov = function() {\n    return this.camera.getFov();\n};\n\n\nMapCamera.prototype.getAspect = function() {\n    return this.camera.getAspect();\n};\n\n\nexport default MapCamera;\n\n\n","\nimport MapBoundLayer_ from './bound-layer';\nimport MapCredit_ from './credit';\nimport MapRefFrame_ from './refframe';\nimport MapView_ from './view';\nimport MapSrs_ from './srs';\nimport MapBody_ from './body';\nimport MapSurface_ from './surface';\nimport MapVirtualSurface_ from './virtual-surface';\nimport MapStylesheet_ from './stylesheet';\n\n//get rid of compiler mess\nvar MapCredit = MapCredit_;\nvar MapBoundLayer = MapBoundLayer_;\nvar MapRefFrame = MapRefFrame_;\nvar MapView = MapView_;\nvar MapSrs = MapSrs_;\nvar MapBody = MapBody_;\nvar MapSurface = MapSurface_;\nvar MapVirtualSurface = MapVirtualSurface_;\nvar MapStylesheet = MapStylesheet_;\n\n\nvar MapConfig = function(map, config) {\n    this.map = map;\n    this.mapConfig = config;\n    this.parseConfig();\n};\n\n\nMapConfig.prototype.parseConfig = function() {\n    if (!(this.parseSrses() && this.parseBodies() && this.parseReferenceFrame() &&\n          this.parseCredits() && this.parseStylesheets() && \n          this.parseSurfaces() && this.parseGlues() && \n          this.parseVirtualSurfaces() && this.parseBoundLayers() &&\n          this.parseFreeLayers() && this.parseViews() &&\n          this.parseParams() && this.parseBrowserOptions() )) {\n        //wrong config file\n    }\n\n    var stats = this.map.stats;\n    stats.loadedCount = 0;\n    stats.loadErrorCount = 0;\n    stats.loadFirst = performance.now();\n    stats.loadLast = this.map.loadFirst;\n};\n\n\nMapConfig.prototype.afterConfigParsed = function() {\n    if (this.mapConfig['position'] != null) {\n        this.map.setPosition(this.mapConfig['position'], false);\n    }\n\n    this.map.setView(this.map.initialView);\n};\n\n\nMapConfig.prototype.parseSrses = function() {\n    var srses = this.mapConfig['srses'];\n    this.map.srses = {};\n\n    if (srses == null) {\n        return false;\n    }\n\n    for (var key in srses) {\n        this.map.addSrs(key, new MapSrs(this.map, key, srses[key]));\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseBodies = function() {\n    var bodies = this.mapConfig['bodies'];\n    this.map.bodies = {};\n\n    if (bodies == null) {\n        return true;//false;\n    }\n\n    for (var key in bodies) {\n        this.map.addBody(key, new MapBody(this.map, bodies[key]));\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseReferenceFrame = function() {\n    var rf = this.mapConfig['referenceFrame'];\n\n    if (rf == null) {\n        return false;\n    }\n\n    this.map.referenceFrame = new MapRefFrame(this.map, rf);\n\n    if (!this.map.referenceFrame.valid) {\n        return false;\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseCredits = function() {\n    var credits = this.mapConfig['credits'];\n    this.map.credits = {};\n\n    if (credits == null) {\n        return false;\n    }\n\n    for (var key in credits) {\n        this.map.addCredit(key, new MapCredit(this.map, credits[key]));\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseSurfaces = function() {\n    var surfaces = this.mapConfig['surfaces'];\n    this.map.surfaces = [];\n\n    if (surfaces == null) {\n        return false;\n    }\n\n    for (var i = 0, li = surfaces.length; i < li; i++) {\n        var surface = new MapSurface(this.map, surfaces[i]);\n        this.map.addSurface(surface.id, surface);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseVirtualSurfaces = function() {\n    var surfaces = this.mapConfig['virtualSurfaces'];\n    this.map.virtualSurfaces = [];\n\n    if (!this.map.config.mapVirtualSurfaces) {\n        return true;\n    }\n\n    if (surfaces == null) {\n        return true;\n    }\n\n    for (var i = 0, li = surfaces.length; i < li; i++) {\n        var surface = new MapVirtualSurface(this.map, surfaces[i]);\n        this.map.virtualSurfaces[surface.strId] = surface;\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseViews = function() {\n    var views = this.mapConfig['namedViews'];\n    this.map.namedViews = [];\n\n    if (views) {\n        for (var key in views) {\n            this.map.addNamedView(key, new MapView(this.map, views[key], true));\n        }\n    }\n\n    var view = this.mapConfig['view'];\n\n    if (typeof view === 'string') {\n        view = this.map.namedViews[view];\n    }\n\n    if (!view) {\n        return true;\n    }\n\n    view = new MapView(this.map, view, true);\n\n    this.map.initialView = view.getInfo();\n    return true;\n};\n\n\nMapConfig.prototype.parseGlues = function() {\n    var glues = this.mapConfig['glue'];\n    this.map.glues = [];\n\n    if (glues == null) {\n        return true;\n    }\n\n    for (var i = 0, li = glues.length; i < li; i++) {\n        var surface = new MapSurface(this.map, glues[i], 'glue');\n        this.map.addGlue(surface.id.join(';'), surface);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseBoundLayers = function() {\n    var layers = this.mapConfig['boundLayers'];\n    this.map.boundLayers = [];\n\n    if (layers == null) {\n        return true;\n    }\n\n    for (var key in layers) {\n        var layer = new MapBoundLayer(this.map, layers[key], key);\n        this.map.addBoundLayer(key, layer);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseFreeLayers = function() {\n    var layers = this.mapConfig['freeLayers'];\n    this.map.freeLayers = [];\n\n    if (layers == null) {\n        return true;\n    }\n\n    for (var key in layers) {\n        var layer = new MapSurface(this.map, layers[key], 'free');\n        this.map.addFreeLayer(key, layer);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseStylesheets = function() {\n    var styles = this.mapConfig['stylesheets'];\n    this.map.stylesheets = [];\n\n    if (styles == null) {\n        return true;\n    }\n\n    for (var key in styles) {\n        var style = new MapStylesheet(this.map, key, styles[key]);\n        this.map.addStylesheet(key, style);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseParams = function() {\n    return true;\n};\n\n\nMapConfig.prototype.parseBrowserOptions = function() {\n    var options = this.mapConfig['browserOptions'];\n    this.map.browserOptions = {};\n    \n    if (options == null) {\n        return true;\n    }\n    \n    this.map.browserOptions = JSON.parse(JSON.stringify(options));\n    return true;\n};\n\n\nMapConfig.prototype.cloneConfig = function() {\n    var json = JSON.parse(JSON.stringify(this.mapConfig));\n    return json;\n};\n\n\nexport default MapConfig;\n","\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport GeographicLib_ from 'geographiclib';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\nvar math = math_;\nvar GeographicLib = GeographicLib_;\n\n\nvar MapConvert = function(map) {\n    this.map = map;\n    this.renderer = map.renderer;\n    this.config = map.config;\n    this.measure = map.measure;\n    this.isProjected = this.map.getNavigationSrs().isProjected();\n};\n\n\nMapConvert.prototype.convertCoords = function(coords, source, destination) {\n    return this.map.referenceFrame.convertCoords(coords, source, destination);\n};\n\n\nMapConvert.prototype.movePositionCoordsTo = function(position, azimuth, distance, azimuthCorrectionFactor) {\n    var coords = position.getCoords();\n    var navigationSrsInfo = this.map.getNavigationSrs().getSrsInfo();\n    azimuthCorrectionFactor = (azimuthCorrectionFactor == null) ? 1 : azimuthCorrectionFactor; \n\n    if (this.isProjected) {\n        var yaw = math.radians(azimuth);\n        var forward = [-Math.sin(yaw), Math.cos(yaw)];\n\n        position.setCoords2([coords[0] + (forward[0]*distance),\n            coords[1] + (forward[1]*distance)]);\n    } else {\n        var geod = this.measure.getGeodesic();\n\n        var r = geod.Direct(coords[1], coords[0], azimuth, distance);\n        position.setCoords2([r.lon2, r.lat2]);\n\n        var orientation = position.getOrientation();\n\n        //console.log(\"corerction: \" + (r.azi1 - r.azi2));\n\n        orientation[0] -= (r.azi1 - r.azi2) * azimuthCorrectionFactor;\n        //orientation[0] -= (r.azi1 - r.azi2); \n\n        //if (!skipOrientation) {\n        position.setOrientation(orientation);\n        //}\n        \n        //console.log(\"azimuthCorrection: \" + azimuthCorrectionFactor);\n        //console.log(\"oldpos: \" + JSON.stringify(this));\n        //console.log(\"newpos: \" + JSON.stringify(pos2));\n    }\n    \n    return position;\n};\n\n\nMapConvert.prototype.convertPositionViewMode = function(position, mode) {\n    if (mode == position.pos[0]) {\n        return position;\n    }\n\n    if (mode == 'obj') {\n        if (position.getHeightMode() == 'float') {\n            var covertToFloat = true;\n            this.convertPositionHeightMode(position, 'fix', true);\n        }\n        \n        var distance = position.getViewDistance(), coords;\n        var orientation = position.getOrientation();\n        \n        //get height delta\n        var pich = math.radians(-orientation[1]);\n        var heightDelta = distance * Math.sin(pich);\n\n        //reduce distance by pich\n        distance *= Math.cos(pich);\n\n        if (this.isProjected) {\n            //get forward vector\n            var yaw = math.radians(orientation[0]);\n            var forward = [-Math.sin(yaw), Math.cos(yaw)];\n    \n            //get center coords \n            coords = position.getCoords();\n            coords[0] = coords[0] + (forward[0] * distance);\n            coords[1] = coords[1] + (forward[1] * distance);\n        } else {\n            this.movePositionCoordsTo(position, -orientation[0], distance);\n            coords = position.getCoords();\n        }\n        \n        coords[2] -= heightDelta;\n        position.setCoords(coords);\n\n        if (covertToFloat) {\n            this.convertPositionHeightMode(position, 'float', true);\n        }\n        \n    } else if (mode == 'subj') {\n        coords = this.getPositionCameraCoords(position, position.getHeightMode());\n        position.setCoords(coords);\n                \n        //TODO: take in accout planet ellipsoid\n    }\n\n    position.pos[0] = mode;\n\n    return position;\n};\n\n\nMapConvert.prototype.convertPositionHeightMode = function(position, mode, noPrecisionCheck) {\n    if (position.pos[3] == mode) {\n        return position;\n    }\n\n    var lod =  this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n    var height = this.measure.getSurfaceHeight(position.getCoords(), lod);\n\n    if (!height[1] && !noPrecisionCheck) {\n        //return null;\n    }\n\n    //set new height\n    if (mode == 'float') {\n        position.pos[3] = mode;\n        position.pos[4] = position.pos[4] - height[0];\n    } else if (mode == 'fix') {\n        position.pos[3] = mode;\n        position.pos[4] = position.pos[4] + height[0];\n    }\n\n    return position;\n};\n\n\nMapConvert.prototype.getPositionCameraCoords = function(position, heightMode) {\n    var orientation = position.getOrientation();\n    var rotMatrix = mat4.create();\n    mat4.multiply(math.rotationMatrix(2, math.radians(-orientation[0])), math.rotationMatrix(0, math.radians(orientation[1])), rotMatrix);\n\n    var coords, terrainHeight = 0, surfaceHeight, lod = -1;\n\n    if (position.getViewMode() == 'obj') {\n        coords = position.getCoords();\n\n        //convert height to fix\n        if (position.getHeightMode() == 'float') {\n            lod = this.measure.getOptimalHeightLod(coords, position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n            surfaceHeight = this.measure.getSurfaceHeight(coords, lod);\n            terrainHeight = surfaceHeight[0];\n        }\n\n        var camInfo = this.measure.getPositionCameraInfo(position, this.isProjected);\n\n        if (this.isProjected) {\n            //var distance = (this.getViewExtent()) / Math.tan(math.radians(this.getFov()*0.5));\n            //var orbitPos = [0, -distance, 0];\n            //math.mat4.multiplyVec3(rotMatrix, orbitPos);\n\n            coords[0] += camInfo.orbitCoords[0];\n            coords[1] += camInfo.orbitCoords[1];\n            coords[2] += camInfo.orbitCoords[2] + terrainHeight;\n        } else {\n            var worldPos = this.convertCoords([coords[0], coords[1], coords[2] + terrainHeight], 'navigation', 'physical');\n            worldPos[0] += camInfo.orbitCoords[0];\n            worldPos[1] += camInfo.orbitCoords[1];\n            worldPos[2] += camInfo.orbitCoords[2];// + terrainHeight;\n\n            coords = this.convertCoords(worldPos, 'physical', 'navigation');\n        }\n\n        if (heightMode == 'fix') {\n            return coords;\n        } else {\n            //get float height for new coords\n            if (lod == -1) {\n                lod =  this.measure.getOptimalHeightLod(coords, position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n            }\n            \n            surfaceHeight = this.measure.getSurfaceHeight(coords, lod);\n            coords[2] -= surfaceHeight[0];\n\n            return coords;\n        }\n\n    } else {\n\n        if (position.getHeightMode() == heightMode) {\n            return position.getCoords();\n        } else {\n            lod =  this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n            surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n            //height += surfaceHeight[0];\n\n            coords = position.getCoords();\n\n            if (heightMode == 'fix') {\n                coords[2] += surfaceHeight[0];\n            } else {\n                coords[2] -= surfaceHeight[0];\n            }\n\n            return coords;\n        }\n    }\n};\n\n\nMapConvert.prototype.getPositionNavCoordsFromPublic = function(position, lod) {\n    var coords = position.getCoords();\n\n    if (position.getHeightMode() == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n        coords[2] += surfaceHeight[0]; \n    }\n\n    return this.convertCoords(coords, 'public', 'navigation');\n};\n\nMapConvert.prototype.getPositionPublicCoords = function(position, lod) {\n    var coords = position.getCoords();\n\n    if (position.getHeightMode() == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n        coords[2] += surfaceHeight[0]; \n    }\n\n    return this.convertCoords(coords, 'navigation', 'public');\n};\n\n\nMapConvert.prototype.getPositionPhysCoords = function(position, lod, includeSE) {\n    var coords = position.getCoords();\n\n    if (position.getHeightMode() == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n        coords[2] += surfaceHeight[0]; \n    }\n\n    if (this.renderer.useSuperElevation && includeSE) {\n        coords[2] = this.renderer.getSuperElevatedHeight(coords[2]);\n    }\n\n    return this.convertCoords(coords, 'navigation', 'physical');\n};\n\n\nMapConvert.prototype.getPositionCameraSpaceCoords = function(position, lod) {\n    var coords = position.getCoords();\n\n    if (position.getHeightMode() == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n        coords[2] += surfaceHeight[0]; \n    }\n\n    if (this.renderer.useSuperElevation) {\n        coords[2] = this.renderer.getSuperElevatedHeight(coords[2]);\n    }\n\n    var worldPos = this.convertCoords(coords, 'navigation', 'physical');\n    var camPos = this.map.camera.position;\n    worldPos[0] -= camPos[0];\n    worldPos[1] -= camPos[1];\n    worldPos[2] -= camPos[2];\n  \n    return worldPos;\n};\n\n\nMapConvert.prototype.getPositionCanvasCoords = function(position, lod, physical, containsSE) {\n    var worldPos;\n    if (physical) {\n        var camPos = this.map.camera.position;\n        var coords = position.getCoords();\n\n        if (this.renderer.useSuperElevation && !containsSE) {\n            coords = this.renderer.transformPointBySE(coords);\n        }\n\n        worldPos = [coords[0] - camPos[0], coords[1] - camPos[1], coords[2] - camPos[2]];\n    } else {\n        worldPos = this.getPositionCameraSpaceCoords(position, lod);\n    }\n    \n    return this.map.renderer.project2(worldPos, this.map.camera.getMvpMatrix());\n};\n\n\nMapConvert.prototype.transformPhysCoordsBySE = function(coords) {\n    if (!this.renderer.useSuperElevation) {\n        return coords;\n    }\n\n    return this.renderer.transformPointBySE(coords);\n};\n\n\nMapConvert.prototype.convertCoordsFromPhysToNav = function(coords, mode, lod, containsSE) {\n    coords = this.convertCoords(coords, 'physical', 'navigation');\n\n    if (this.renderer.useSuperElevation && containsSE) {\n        coords[2] = this.renderer.getUnsuperElevatedHeight(coords[2]);\n    }\n\n    if (mode == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(coords, 10, this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(coords, lod);\n        coords[2] -= surfaceHeight[0]; \n    } \n\n    return coords;\n};\n\n\nMapConvert.prototype.getGeodesicLinePoints = function(coords, coords2, height, density) {\n    var geod, r, length, azimuth, minStep, d;\n    var navigationSrsInfo = this.measure.navigationSrsInfo;\n    var dx = coords2[0] - coords[0];\n    var dy = coords2[1] - coords[1];\n    var dz = coords2[2] - coords[2];\n\n    if (this.isProjected) {\n        length = Math.sqrt(dx*dx + dy*dy + dz*dz);\n        minStep = 1000000; //just big number\n    } else {\n        geod = this.measure.getGeodesic();\n        r = geod.Inverse(coords[1], coords[0], coords2[1], coords2[0]);\n        length = r.s12;\n        azimuth = r.azi1;\n        minStep = 10 * ((navigationSrsInfo['a'] * 2 * Math.PI) / 4007.5); //aprox 100km for earth\n    }\n\n    var points = [coords];\n    var distance = minStep;\n\n    for (;distance < length; distance += minStep) {\n        d = distance / length;\n\n        if (this.isProjected) {\n            points.push([ coords[0] + dx * d, coords[1] + dy * d, coords[2] + dz * d ]);\n        } else {\n            r = geod.Direct(coords[1], coords[0], azimuth, distance);\n            points.push([r.lon2, r.lat2, coords[2] + dz * d]);\n        }\n    }\n\n    points.push(coords2);\n\n    return points;\n};\n\nexport default MapConvert;\n","\nimport {utils as utils_} from '../utils/utils';\n\n//get rid of compiler mess\nvar utils = utils_;\n\nvar MapCredit = function(map, json) {\n    this.map = map;\n    this.id = json['id'] || null;\n    this.notice = json['notice'] || null;\n    this.copyrighted = json['copyrighted'] || true;\n    this.url = json['url'] || null;\n    this.html = utils.simpleWikiLinks(this.notice);\n    this.plain = utils.simpleWikiLinks(this.notice);\n};\n\n\nMapCredit.prototype.getInfo = function() {\n    return {\n        'id' : this.id,\n        'notice' : this.notice,\n        //\"copyrighted\" : this.copyrighted,\n        //\"url\" : this.url\n        'html' : this.html,\n        'plain' : this.plain\n    };\n};\n\n\nexport default MapCredit;\n\n","\nvar MapDivisionNode = function(map, id, srs, extents, heightRange, partitioning) {\n    this.map = map;\n    this.id = id;\n    this.srs = this.map.getMapsSrs(srs);\n    this.extents = extents;\n    this.heightRange =  heightRange;\n    this.partitioning = partitioning;\n    this.isPole = (id[0] == 1 && ((id[1] == 0 && id[2] == 1)||(id[1] == 1 && id[2] == 0)));\n};\n\n\nMapDivisionNode.prototype.getInnerCoords = function (coords) {\n    return this.srs.convertCoordsFrom(coords, this.map.getNavigationSrs());\n};\n\n\nMapDivisionNode.prototype.getOuterCoords = function (coords) {\n    return this.srs.convertCoordsTo(coords, this.map.getNavigationSrs());\n};\n\n\nMapDivisionNode.prototype.getPhysicalCoords = function (coords, skipVerticalAdjust) {\n    return this.srs.convertCoordsTo(coords, this.map.getPhysicalSrs(), skipVerticalAdjust);\n};\n\n\nMapDivisionNode.prototype.getPhysicalCoordsFast = function (coords, skipVerticalAdjust, coords2, index, index2) {\n    return this.srs.convertCoordsToFast(coords, this.map.getPhysicalSrs(), skipVerticalAdjust, coords2, index, index2);\n};\n\n\nMapDivisionNode.prototype.getExtents = function (coords) {\n    return this.srs.convertCoordsFrom(coords, this.map.getNavigationSrs());\n};\n\n\nexport default MapDivisionNode;\n","\nimport MapGeodataView_ from './geodata-view';\nimport {utils as utils_} from '../utils/utils';\n\n//get rid of compiler mess\nvar MapGeodataView = MapGeodataView_;\nvar utils = utils_;\n\n\nvar MapDrawTiles = function(map, draw) {\n    this.map = map;\n    this.config = map.config;\n    this.isProjected = this.map.getNavigationSrs().isProjected();\n    this.stats = map.stats;\n    this.draw = draw;\n    this.debug = draw.debug;\n    this.core = map.core;\n    this.camera = map.camera;\n\n    this.renderer = map.renderer;\n\n    this.getTextSize = this.renderer.draw.getTextSize.bind(this.renderer.draw);\n    this.drawText = this.renderer.draw.drawText.bind(this.renderer.draw);\n};\n\n\nMapDrawTiles.prototype.drawSurfaceTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {\n    if (this.stats.gpuRenderUsed >= this.draw.maxGpuUsed) {\n        return false;\n    }\n\n    tile.renderReady = false;\n    \n    if (tile.surface) {\n        if (node.hasGeometry()) {\n\n            if (this.debug.drawBBoxes && !preventRedener) {\n                if (tile.surface.geodata || !this.debug.drawGeodataOnly) {\n                    this.drawTileInfo(tile, node, cameraPos, tile.surfaceMesh, pixelSize);\n                }\n            }\n\n            if (this.debug.heightmapOnly && !preventRedener) {\n                if (!tile.surface.geodata) {\n                    tile.drawGrid(cameraPos);\n                }\n                return true;\n            }\n           \n            if (!preventRedener) {\n                this.stats.renderedLods[tile.id[0]]++;\n                this.stats.drawnTiles++;\n\n                if (tile.surface.geodata && this.renderer.drawnGeodataTilesUsed) {    //used in scr-count2 !!! legacy mode, do not remove\n\n                    var pp = this.renderer.project2(\n                        [(node.bbox2[12] + node.bbox2[15] + node.bbox2[18] + node.bbox2[21])*0.25 - cameraPos[0],\n                         (node.bbox2[13] + node.bbox2[16] + node.bbox2[19] + node.bbox2[22])*0.25 - cameraPos[1],\n                         (node.bbox2[14] + node.bbox2[17] + node.bbox2[20] + node.bbox2[23])*0.25 - cameraPos[2]],\n                         this.camera.getMvpMatrix());\n\n                    if (!(pp[0] < 0 || pp[1] < 0 || pp[0] > this.renderer.curSize[0] || pp[1] > this.renderer.curSize[1])) {\n                        this.stats.drawnGeodataTilesPerLayer++;\n                        this.stats.drawnGeodataTilesFactor += Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR);\n                    }\n\n                    this.stats.drawnGeodataTiles++;\n                }\n            }\n\n            var count = 0;\n           \n            do {\n\n                if (tile.resetDrawCommands) {\n                    tile.drawCommands = [[], [], []];\n                    tile.updateBounds = true;\n            \n                    if (tile.bounds) {\n                        for (var key in tile.bounds) {\n                            tile.bounds[key].viewCoutner = 0; \n                        }\n                    }\n                    \n                    tile.resetDrawCommands = false;\n                }\n\n                var ret;\n\n                if (!tile.surface.geodata) {\n                    ret = this.drawMeshTile(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu);\n                } else {\n                    ret = this.drawGeodataTile(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu);\n                }\n\n                //if (count > 0) console.log('loop: ' + count);\n\n                count++;\n\n                if (count > 10) {\n                    break; //prevent infinite loop\n                }\n\n            } while(tile.resetDrawCommands);\n\n            return ret;\n        } else {\n            return true;\n        }\n    } else {\n        if (!preventRedener && tile.lastRenderState) {\n            var channel = this.draw.drawChannel;\n            this.draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);\n            this.map.applyCredits(tile);\n            return true;\n        }\n    }\n};\n\n\n\nMapDrawTiles.prototype.drawMeshTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {\n    var path;\n\n    if (!tile.surfaceMesh) {\n        if (tile.resourceSurface.virtual) {\n            return true;\n        }\n        \n        path = tile.resourceSurface.getMeshUrl(tile.id);\n        tile.surfaceMesh = tile.resources.getMesh(path, tile);\n    }\n\n    var draw = this.draw, texture, layer, credits;\n    var channel = draw.drawChannel;\n    var ret = false;\n\n    //we have commnad so we can draw them\n    if (tile.drawCommands[channel].length > 0 && this.draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n        if (!preventRedener) {\n            draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);\n            this.map.applyCredits(tile);\n        }\n\n        tile.lastRenderState = null;\n        return true;\n    } else if (tile.lastRenderState){ //we do not have cammnds or command are not redy yet, so we can draw last state if present and ready\n\n        if (tile.surfaceMesh.isReady(true, priority, doNotCheckGpu) && tile.drawCommands[channel].length > 0) {\n            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n                if (!preventRedener) {\n                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);\n                    this.map.applyCredits(tile);\n                }\n                return true; // commands are generated so we can return from function here\n            } // else ret = false\n        } else {\n            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n                if (!preventRedener) {\n                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);\n                    this.map.applyCredits(tile);\n                }\n                ret = true;\n            }\n        }\n    }\n\n    if (tile.drawCommands[channel].length > 0) {  //command are generated but not ready, we can return from the function\n\n        if (this.config.mapHeightfiledWhenUnloaded && !preventRedener) {\n            tile.drawGrid(cameraPos);\n            return false;\n        } else {\n            return false;\n        }\n    } \n\n    // information about support for extarnal or internal textures are present in the mesh,  \n    // so we have to wait until is mesh ready and then we can generate commands\n    if (tile.surfaceMesh.isReady(preventLoad, priority, doNotCheckGpu) && !preventLoad) {\n        var submeshes = tile.surfaceMesh.submeshes;\n\n        tile.drawCommands = [[], [], []]; //??\n        tile.imageryCredits = {};\n        tile.boundsDebug = {}; //used for inspector\n\n        var specificity = 0;\n        var i, li, j, lj, k, lk, surface;\n\n        surface = tile.resourceSurface;\n\n        if (!surface) {\n            surface = tile.surface;\n        }\n        \n        if (surface.glue) {\n\n            var surfaces = surface.id; \n            for (i = 0, li = surfaces.length; i < li; i++) {\n                var surface2 = this.map.getSurface(surfaces[i]);\n                if (surface2) {\n                    specificity = Math.max(specificity, surface2.specificity);\n                }\n            }\n\n            //set credits\n            for (k = 0, lk = node.credits.length; k < lk; k++) {\n                tile.glueImageryCredits[node.credits[k]] = specificity;  \n            }\n\n        } else {\n\n            specificity = surface.specificity;\n\n            //set credits\n            for (k = 0, lk = node.credits.length; k < lk; k++) {\n                tile.imageryCredits[node.credits[k]] = specificity;  \n            }\n        }\n\n\n        for (i = 0, li = submeshes.length; i < li; i++) {\n\n            var submesh = submeshes[i];\n            \n            //debug bbox\n            if (this.debug.drawBBoxes && this.debug.drawMeshBBox && !preventRedener) {\n                submesh.drawBBox(cameraPos);\n            }\n\n            if (submesh.externalUVs) {\n                if (tile.updateBounds) {\n                    tile.updateBounds = false;\n                    \n                    this.updateTileBounds(tile, submeshes);\n                }\n                \n                surface = tile.resourceSurface;\n                if (tile.resourceSurface.glue /*&& submesh.surfaceReference != 0*/) { //glue have multiple surfaces per tile\n                    surface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);\n                }\n\n                if (surface != null) {\n                    var bounds = tile.bounds[surface.id];\n                    \n                    if (bounds) {\n                        if (submesh.externalUVs) {\n\n                            //draw bound layers\n                            if (bounds.sequence.length > 0) {\n                                if (bounds.transparent) {\n                                    if (submesh.internalUVs) {  //draw surface\n                                        if (tile.surfaceTextures[i] == null) {\n                                            path = tile.resourceSurface.getTextureUrl(tile.id, i);\n                                            tile.surfaceTextures[i] = tile.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, tile, true);\n                                        }\n                                                \n                                        tile.drawCommands[0].push({\n                                            type : VTS_DRAWCOMMAND_SUBMESH,\n                                            mesh : tile.surfaceMesh,\n                                            submesh : i,\n                                            texture : tile.surfaceTextures[i],\n                                            material : VTS_MATERIAL_INTERNAL_NOFOG\n                                        });\n                                    }\n    \n                                    tile.drawCommands[0].push({\n                                        type : VTS_DRAWCOMMAND_STATE,\n                                        state : draw.drawBlendedTileState\n                                    });            \n                                    \n                                    var layers = bounds.sequence;\n                                    for (j = 0, lj = layers.length; j < lj; j++) {\n                                        texture = tile.boundTextures[layers[j]];\n                                        if (texture) {\n\n                                            //debug stuff\n                                            if (!tile.boundsDebug[surface.id]) {\n                                                tile.boundsDebug[surface.id] = [];\n                                            }\n                                            tile.boundsDebug[surface.id].push(layers[j]);\n\n                                            //set credits\n                                            layer = tile.boundLayers[layers[j]];\n                                            credits = layer.credits;\n                                            for (k = 0, lk = credits.length; k < lk; k++) {\n                                                tile.imageryCredits[credits[k]] = layer.specificity;  \n                                            }\n\n                                            tile.drawCommands[0].push({\n                                                type : VTS_DRAWCOMMAND_SUBMESH,\n                                                mesh : tile.surfaceMesh,\n                                                submesh : i,\n                                                texture : texture,\n                                                alpha : bounds.alpha[layers[j]][1],\n                                                material : VTS_MATERIAL_EXTERNAL_NOFOG,\n                                                layer : layer,\n                                                surface : surface\n                                            });\n                                        }\n                                    }\n                                    \n                                    tile.drawCommands[0].push({\n                                        type : VTS_DRAWCOMMAND_SUBMESH,\n                                        mesh : tile.surfaceMesh,\n                                        submesh : i,\n                                        texture : null,\n                                        material : VTS_MATERIAL_FOG\n                                    });                                                \n\n                                    tile.drawCommands[0].push({\n                                        type : VTS_DRAWCOMMAND_STATE,\n                                        state : draw.drawTileState\n                                    });  \n                                } else {\n                                    var layerId = bounds.sequence[bounds.sequence.length-1];\n                                    texture = tile.boundTextures[layerId];\n                                    if (texture) {\n\n                                        //debug stuff\n                                        if (!tile.boundsDebug[surface.id]) {\n                                            tile.boundsDebug[surface.id] = [];\n                                        }\n                                        tile.boundsDebug[surface.id].push(layerId);\n                                        \n                                        //set credits\n                                        layer = tile.boundLayers[layerId];\n                                        credits = layer.credits;\n                                        for (k = 0, lk = credits.length; k < lk; k++) {\n                                            tile.imageryCredits[credits[k]] = layer.specificity;  \n                                        }\n                                        \n                                        tile.drawCommands[0].push({\n                                            type : VTS_DRAWCOMMAND_SUBMESH,\n                                            mesh : tile.surfaceMesh,\n                                            submesh : i,\n                                            texture : texture,\n                                            material : VTS_MATERIAL_EXTERNAL,\n                                            layer : layer,\n                                            surface : surface\n                                        });\n                                    }\n                                }\n                               \n                            } else {\n                                if (submesh.textureLayer) {\n                                    \n                                    layer = this.map.getBoundLayerByNumber(submesh.textureLayer);\n                                    \n                                    if (layer) {\n                                        texture = tile.boundTextures[layer.id];\n                                        \n                                        if (texture) {\n                                            \n                                            //debug stuff\n                                            if (!tile.boundsDebug[surface.id]) {\n                                                tile.boundsDebug[surface.id] = [];\n                                            }\n                                            tile.boundsDebug[surface.id].push(layer.id);\n                                            \n                                            //set credits\n                                            layer = tile.boundLayers[layer.id];\n                                            credits = layer.credits;\n                                            for (k = 0, lk = credits.length; k < lk; k++) {\n                                                tile.imageryCredits[credits[k]] = layer.specificity;  \n                                            }\n                                            \n                                            //draw mesh\n                                            tile.drawCommands[0].push({\n                                                type : VTS_DRAWCOMMAND_SUBMESH,\n                                                mesh : tile.surfaceMesh,\n                                                submesh : i,\n                                                texture : texture,\n                                                material : VTS_MATERIAL_EXTERNAL,\n                                                layer : layer,\n                                                surface : surface\n                                            });\n                                        }\n                                    }\n                                   \n                                } else {\n    \n                                    if (submesh.internalUVs) {  //draw surface\n                                        if (tile.surfaceTextures[i] == null) {\n                                            path = tile.resourceSurface.getTextureUrl(tile.id, i);\n                                            tile.surfaceTextures[i] = tile.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, tile, true);\n                                        }\n\n                                        //draw mesh\n                                        tile.drawCommands[0].push({\n                                            type : VTS_DRAWCOMMAND_SUBMESH,\n                                            mesh : tile.surfaceMesh,\n                                            submesh : i,\n                                            texture : tile.surfaceTextures[i],\n                                            material : VTS_MATERIAL_INTERNAL\n                                        });\n                                    } else {\n                                        tile.drawCommands[0].push({\n                                            type : VTS_DRAWCOMMAND_SUBMESH,\n                                            mesh : tile.surfaceMesh,\n                                            submesh : i,\n                                            texture : null,\n                                            material : VTS_MATERIAL_FLAT\n                                        });\n                                    }\n    \n                                }\n                            }\n    \n                        } else if (submesh.internalUVs) {\n    \n                            if (tile.surfaceTextures[i] == null) {\n                                path = tile.resourceSurface.getTextureUrl(tile.id, i);\n                                tile.surfaceTextures[i] = tile.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, tile, true);\n                            } //else {\n                            tile.drawCommands[0].push({\n                                type : VTS_DRAWCOMMAND_SUBMESH,\n                                mesh : tile.surfaceMesh,\n                                submesh : i,\n                                texture : tile.surfaceTextures[i],\n                                material : VTS_MATERIAL_INTERNAL\n                            });                                                \n                            //}\n                        }\n                    }                            \n                }\n            } else if (submesh.internalUVs) {\n\n                if (tile.surfaceTextures[i] == null) {\n                    path = tile.resourceSurface.getTextureUrl(tile.id, i);\n                    tile.surfaceTextures[i] = tile.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, tile, true);\n                } //else {\n                tile.drawCommands[0].push({\n                    type : VTS_DRAWCOMMAND_SUBMESH,\n                    mesh : tile.surfaceMesh,\n                    submesh : i,\n                    texture : tile.surfaceTextures[i],\n                    material : VTS_MATERIAL_INTERNAL\n                });                                                \n                //}\n            }\n            \n            //depth path\n            tile.drawCommands[1].push({\n                type : VTS_DRAWCOMMAND_SUBMESH,\n                mesh : tile.surfaceMesh,\n                submesh : i,\n                material : VTS_MATERIAL_DEPTH\n            });\n            \n        }\n\n        if (surface.pipeline > VTS_PIPELINE_BASIC) {\n            this.updateTileHmap(tile, node);\n\n            for (j = 0; j < 2; j++) {\n                var commands = tile.drawCommands[j];\n                for (i = 0, li = commands.length; i < li; i++) {\n                    if (commands[i].type == VTS_DRAWCOMMAND_SUBMESH) {\n                        commands[i].pipeline = surface.pipeline;\n                        commands[i].hmap = tile.hmap;\n                    }\n                }\n            }\n        }\n\n        if (tile.resetDrawCommands) {\n            return false;\n        }\n\n        if (draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n\n            if (tile.resetDrawCommands) {\n                return false;\n            }\n\n            if (!preventRedener) {\n                draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);\n                this.map.applyCredits(tile);\n            }\n\n            tile.lastRenderState = null;\n            ret = true;\n        } else if (tile.lastRenderState) {\n\n            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n                if (!preventRedener) {\n                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);\n                    this.map.applyCredits(tile);\n                }\n                ret = true;\n            } //else ret = false\n        } else {\n\n            if (this.config.mapHeightfiledWhenUnloaded && !preventRedener) {\n\n                //node.drawPlane(cameraPos, tile);\n                tile.drawGrid(cameraPos);\n                ret = !(tile.drawCommands[channel].length > 0);\n            }\n        }\n        \n    } else {\n\n        if (!tile.lastRenderState && this.config.mapHeightfiledWhenUnloaded && !preventRedener) {\n            //node.drawPlane(cameraPos, tile);\n\n            tile.drawGrid(cameraPos);\n            ret = !(tile.drawCommands[channel].length > 0);\n        }        \n    }\n    \n    return ret;\n};\n\n\nMapDrawTiles.prototype.drawGeodataTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {\n    if (tile.id[0] <= 1) {\n        return true;\n    }\n\n    if (tile.surfaceGeodata == null) {\n        var path;\n        \n        if (tile.surface.geodataNavtileInfo) {  //remove this code??? no longer used\n            var navtile = this.tree.findNavTile(tile.id);\n            \n            if (navtile && navtile.surface) {\n                var navtileStr = navtile.surface.getNavUrl(navtile.id) + ';'\n                                  + navtile.id[0] + '-' + navtile.id[1] + '-' + navtile.id[2] + ';'      \n                                  + navtile.metanode.minHeight + ';' + navtile.metanode.maxHeight;     \n                path = tile.surface.getGeodataUrl(tile.id, encodeURIComponent(navtileStr));\n            }\n        }\n        \n        if (!path) {\n            path = tile.resourceSurface.getGeodataUrl(tile.id, '');\n        }\n\n        tile.surfaceGeodata = tile.resources.getGeodata(path, {tile:tile, surface:tile.surface});\n    }\n\n    var channel = this.draw.drawChannel;\n    \n    if (tile.geodataCounter != tile.surface.geodataCounter) {\n        tile.drawCommands = [[],[],[]];\n\n        if (tile.surfaceGeodataView != null) {\n            tile.surfaceGeodataView.kill();\n        }\n        \n        tile.surfaceGeodataView = null;\n        tile.geodataCounter = tile.surface.geodataCounter;\n    }\n\n    if (tile.drawCommands[channel].length > 0 && this.draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n        if (!preventRedener) {\n            this.draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);\n            this.map.applyCredits(tile);\n        }\n        tile.lastRenderState = null;\n        return true;\n    }\n\n    if (!tile.surfaceGeodataView) {\n        if (tile.surfaceGeodata.isReady(preventLoad, priority, doNotCheckGpu) && !preventLoad) {\n            tile.surfaceGeodataView = new MapGeodataView(this.map, tile.surfaceGeodata, {tile:tile, surface:tile.surface});\n        }\n    }\n\n    if (tile.surfaceGeodataView) {\n        tile.mapdataCredits = {};\n        \n        var specificity = (tile.surface) ? tile.surface.specificity : 0;\n\n        //set credits\n        for (var k = 0, lk = node.credits.length; k < lk; k++) {\n            tile.mapdataCredits[node.credits[k]] = specificity;  \n        }\n\n        tile.drawCommands[channel][0] = {\n            type : VTS_DRAWCOMMAND_GEODATA,\n            geodataView : tile.surfaceGeodataView \n        };\n\n        return tile.surfaceGeodataView.isReady();\n    }\n\n    return false;\n};\n\n\nMapDrawTiles.prototype.updateTileHmap = function(tile, node) {\n    if (node && node.hasNavtile() && tile.surface) { \n\n        if (!tile.surface || !tile.resourceSurface) { //surface.virtual) {\n            return false; //is it best way how to do it?\n        }\n            \n        if (!tile.resourceSurface.getHMapUrl) { //virtual surface is as resource surface. Is it bug??!!\n            return false; //is it best way how to do it?\n        }\n            \n        var path = tile.resourceSurface.getHMapUrl(tile.id, true);\n        tile.hmap = tile.resources.getTexture(path);\n\n        //var path = tile.surface.getNavUrl(tile.id);\n        //tile.hmap = tile.resources.getTexture(path, null, null, null, tile, true);\n    } else {\n\n        //get parent with nav tile\n        var parent = tile.parent;\n        var extraBound = null; \n\n        while(parent && parent.id[0] > 0) {\n            if (parent.metanode && parent.metanode.hasNavtile()) {\n                extraBound = {\n                    sourceTile : parent,\n                    sourceTexture : null,\n                    hmap : true,\n                    tile : tile \n                };\n\n                break;\n            }\n\n            parent = parent.parent;\n        }\n\n        //does parent with navtile exist\n        if (extraBound) {\n            var path = tile.resourceSurface.getHMapUrl(tile.id, true);\n            tile.hmap = tile.resources.getTexture(path, null, extraBound, {tile: tile, hmap: true}, tile, false);\n\n            if (tile.hmap.neverReady) {\n                tile.hmap = null;\n            }\n        } else {\n            tile.hmap = null;\n        }\n    }\n};\n\n\nMapDrawTiles.prototype.updateTileBounds = function(tile, submeshes) {\n    for (var i = 0, li = submeshes.length; i < li; i++) {\n        var submesh = submeshes[i];\n        \n        if (submesh.externalUVs) {\n            var submeshSurface = tile.resourceSurface;\n\n            //if (tile.resourceSurface.glue) { //glue have multiple surfaces per tile\n              //  submeshSurface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);\n            //}\n\n            if (tile.resourceSurface.glue) { //glue have multiple surfaces per tile\n                submeshSurface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);\n            }\n\n            \n            if (submeshSurface) {\n                var bounds = tile.bounds[submeshSurface.id];\n                \n                if (!bounds) {\n                    bounds = {\n                        sequence : [],\n                        alpha : [],\n                        transparent : false,\n                        viewCoutner : 0\n                    };\n                    \n                    tile.bounds[submeshSurface.id] = bounds;\n                } \n                \n                if (bounds.viewCoutner != tile.viewCoutner) {\n                    this.updateTileSurfaceBounds(tile, submesh, submeshSurface, bounds, bounds.viewCoutner != tile.viewCoutner);\n                    //bounds.viewCoutner = tile.viewCoutner;\n                }  \n            }\n        }\n    }\n\n    for (var key in tile.bounds) {\n        tile.bounds[key].viewCoutner = tile.viewCoutner;\n    }\n};\n\n\nMapDrawTiles.prototype.getParentTile = function(tile, lod) {\n    while(tile && tile.id[0] > lod) {\n        tile = tile.parent;\n    }\n    \n    return tile;\n};\n\n\nMapDrawTiles.prototype.getTileTextureTransform = function(sourceTile, targetTile) {\n    var shift = targetTile.id[0] - sourceTile.id[0];\n    var x = sourceTile.id[1] << shift;\n    var y = sourceTile.id[2] << shift;\n    var s = 1.0 / Math.pow(2.0, shift);\n    return [ s, s, (targetTile.id[1] - x) * s, (targetTile.id[2] - y) * s ];\n};\n\n\nMapDrawTiles.prototype.updateTileSurfaceBounds = function(tile, submesh, surface, bound, fullUpdate) {\n    var path, extraBound, layer, texture;\n\n    if (this.config.mapNoTextures) {\n        return;\n    }\n\n    //search map view\n    if (surface.boundLayerSequence.length > 0) {\n        if (fullUpdate) {\n            bound.sequence = [];\n            var sequenceFullAndOpaque = [];\n            var sequenceMaskPosible = [];\n            var fullAndOpaqueCounter = 0;\n            \n            for (var j = 0, lj = surface.boundLayerSequence.length; j < lj; j++) {\n                layer = surface.boundLayerSequence[j][0];\n                \n                if (layer && layer.ready && layer.hasTileOrInfluence(tile.id) && surface.boundLayerSequence[j][1] > 0) {\n                    extraBound = null; \n                    \n                    if (tile.id[0] > layer.lodRange[1]) {\n                        extraBound = {\n                            sourceTile : this.getParentTile(tile, layer.lodRange[1]),\n                            sourceTexture : null,\n                            layer : layer,\n                            tile : tile \n                        };\n                    }\n\n                    texture = tile.boundTextures[layer.id];\n\n                    if (!texture) { //TODO: make sure that we load only textures which we need  \n                        path = layer.getUrl(tile.id);\n                        texture = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);\n\n                        if (texture.checkType == VTS_TEXTURECHECK_MEATATILE) {\n                            texture.checkMask = true;\n                        }\n\n                        texture.isReady(true); //check for mask but do not load\n                        tile.boundTextures[layer.id] = texture; \n                    } \n\n                    if (texture.neverReady) {\n                        continue; //do not use this layer\n                    }\n\n                    var maskPosible = false;\n                    var skipOther = false;\n\n                    if (texture.isMaskPosible()) {\n                        if (texture.isMaskInfoReady()) {\n                            if (texture.getMaskTexture()) {\n                                bound.transparent = true;\n                                maskPosible = true;\n                            }\n                        } else {\n                            skipOther = true;\n                            maskPosible = true;\n                        }\n                    }\n\n                    sequenceMaskPosible.push(maskPosible);\n                    \n                    //var fullAndOpaque = !((surface.boundLayerSequence[j][1] < 1.0) || texture.extraBound || texture.getMaskTexture() || layer.isTransparent);\n                    var fullAndOpaque = !((surface.boundLayerSequence[j][1] < 1.0) || maskPosible || layer.isTransparent);\n                    if (fullAndOpaque) {\n                        fullAndOpaqueCounter++;\n                    }\n                            \n                    sequenceFullAndOpaque.push(fullAndOpaque);\n                    \n                    bound.sequence.push(layer.id);\n                    bound.alpha[layer.id] = surface.boundLayerSequence[j];\n                    tile.boundLayers[layer.id] = layer;\n                    if (bound.alpha[layer.id][1] < 1.0 || layer.isTransparent) {\n                        bound.transparent = true;\n                    }\n\n                    if (skipOther) {\n                        break; //wait until mask info is loaded\n                    }\n                }\n            }\n\n            //filter out extra bounds if they are not needed\n            //and remove all layer after first FullAndOpaque \n            if (fullAndOpaqueCounter > 0) {\n                var newSequence = [];\n                \n                for (var i = bound.sequence.length - 1; i >= 0; i--) {\n                    var layerId = bound.sequence[i];\n                    \n                    if (sequenceFullAndOpaque[i]) {\n                        newSequence.unshift(layerId);   \n                        break;\n                    } else {\n                        texture = tile.boundTextures[layerId];\n\n                        if (bound.alpha[layerId][1] < 1.0 ||\n                            tile.boundLayers[layerId].isTransparent ||\n                            (sequenceMaskPosible[i] /*texture.getMaskTexture() /*&& !texture.extraBound*/)) {\n                            newSequence.unshift(layerId);    \n                        }\n                    }\n                }\n                \n                bound.sequence = newSequence; \n            }\n            \n        }\n    } else if (surface.textureLayer != null) { //search surface\n        if (fullUpdate) {\n            layer = this.map.getBoundLayerById(surface.textureLayer);\n            if (layer && layer.hasTileOrInfluence(tile.id)) {\n                extraBound = null; \n                \n                if (tile.id[0] > layer.lodRange[1]) {\n                    extraBound = {\n                        sourceTile : this.getParentTile(tile, layer.lodRange[1]),\n                        sourceTexture : null,\n                        layer : layer,\n                        tile : tile \n                    };\n                }\n\n                bound.sequence.push(layer.id);\n                tile.boundLayers[layer.id] = layer;\n                if (!tile.boundTextures[layer.id]) {\n                    path = layer.getUrl(tile.id);\n                    tile.boundTextures[layer.id] = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);\n                }\n            }\n        }\n    } else { //search submeshes\n        if (submesh.textureLayer != 0) {\n            layer = this.map.getBoundLayerByNumber(submesh.textureLayer);\n\n            if (layer && layer.hasTileOrInfluence(tile.id)) {\n                extraBound = null; \n                \n                if (tile.id[0] > layer.lodRange[1]) {\n                    extraBound = {\n                        sourceTile : this.getParentTile(tile, layer.lodRange[1]),\n                        sourceTexture : null,\n                        layer : layer,\n                        tile : tile \n                    };\n                }\n\n                //submeshes[j].textureLayerId = tile.id;\n                tile.boundLayers[layer.id] = layer;\n                if (!tile.boundTextures[layer.id]) {\n                    path = layer.getUrl(tile.id);\n                    tile.boundTextures[layer.id] = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);\n                }\n            }\n        }\n    }\n};\n\n\nMapDrawTiles.prototype.drawTileInfo = function(tile, node, cameraPos, mesh) {\n    var debug = this.debug, pos;\n\n    if (!debug.drawMeshBBox) {\n        node.drawBBox(cameraPos);\n    }\n\n    //get screen pos of node\n    if (node.metatile.useVersion < 4) {\n        var min = node.bbox.min;\n        var max = node.bbox.max;\n    \n        pos =  this.core.getRendererInterface().getCanvasCoords(\n            [(min[0] + (max[0] - min[0])*0.5) - cameraPos[0],\n                (min[1] + (max[1] - min[1])*0.5) - cameraPos[1],\n                (max[2]) - cameraPos[2]],\n             this.camera.getMvpMatrix());\n    \n        pos[2] = pos[2] * 0.9992;\n    } else {\n        var dx = node.bbox2[3] - node.bbox2[0]; \n        var dy = node.bbox2[4] - node.bbox2[1]; \n        var dz = node.bbox2[5] - node.bbox2[2]; \n    \n        var d = Math.sqrt(dx*dx + dy*dy + dz*dz);\n    \n        pos =  this.core.getRendererInterface().getCanvasCoords(\n            [(node.bbox2[12] + node.bbox2[15] + node.bbox2[18] + node.bbox2[21])*0.25 + node.diskNormal[0] * d*0.1 - cameraPos[0],\n                (node.bbox2[13] + node.bbox2[16] + node.bbox2[19] + node.bbox2[22])*0.25 + node.diskNormal[1] * d*0.1 - cameraPos[1],\n                (node.bbox2[14] + node.bbox2[17] + node.bbox2[20] + node.bbox2[23])*0.25 + node.diskNormal[2] * d*0.1 - cameraPos[2]],\n             this.camera.getMvpMatrix());\n        \n        /*\n            var pos =  this.core.getRendererInterface().getCanvasCoords(\n                            [(node.diskPos[0] + node.diskNormal[0] * node.bboxHeight) - cameraPos[0],\n                             (node.diskPos[1] + node.diskNormal[1] * node.bboxHeight) - cameraPos[1],\n                             (node.diskPos[2] + node.diskNormal[2] * node.bboxHeight) - cameraPos[2]],\n                             this.camera.getMvpMatrix());\n        */\n    }\n\n    var factor = debug.debugTextSize, text, i, li,c;\n\n    //draw lods\n    if (debug.drawLods) {\n        text = '' + tile.id[0]; // + ' ta:' + Math.abs(tile.tiltAngle).toFixed(3);\n        //text = '' + tile.id[0] + ' c:' + (50*(Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR) / Math.max(0.00001, this.renderer.drawnGeodataTilesFactor))).toFixed(3) + \n          //     ' l:' + Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR).toFixed(3) + ' g:' + this.renderer.drawnGeodataTilesFactor.toFixed(3);\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-4*factor), 4*factor, text, [1,0,0,1], pos[2]);\n    }\n\n    //draw indices\n    if (debug.drawIndices) {\n        text = '' + tile.id[1] + ' ' + tile.id[2];\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-11*factor), 4*factor, text, [0,1,1,1], pos[2]);\n    }\n\n    //draw positions\n    if (debug.drawPositions) {\n        //text = \"\" + min[0].toFixed(1) + \" \" + min[1].toFixed(1) + \" \" + min[2].toFixed(1);\n        //text = \"\" + Math.floor(node.corners[0]) + \" \" + Math.floor(node.corners[1]) + \" \" + Math.floor(node.corners[2]) + \" \" + Math.floor(node.corners[3]);\n        \n        var b = node.border2;\n        if (b) {\n            text = '' + Math.floor(b[0]) + ' ' + Math.floor(b[1]) + ' ' + Math.floor(b[2]) + ' ' + Math.floor(b[3]) + ' ' + Math.floor(b[4]) + ' ' + Math.floor(b[5]) + ' ' + Math.floor(b[6]) + ' ' + Math.floor(b[7]) + ' ' + Math.floor(b[8]);\n            this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,1,1], pos[2]);\n        }\n\n        b = node.border;\n        if (b) {\n            draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]); Math.floor(b[0]) + ' ' + Math.floor(b[1]) + ' ' + Math.floor(b[2]) + ' ' + Math.floor(b[3]) + ' ' + Math.floor(b[4]) + ' ' + Math.floor(b[5]) + ' ' + Math.floor(b[6]) + ' ' + Math.floor(b[7]) + ' ' + Math.floor(b[8]);\n            this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,1,1], pos[2]);\n        }\n\n        //text = 'llx:' + Math.floor(node.llx) + ' lly:' + Math.floor(node.lly) + ' urx:' + Math.floor(node.urx) + ' ury:' + Math.floor(node.ury);\n        //this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,1,1], pos[2]);\n    }\n\n    //draw resources\n    if (debug.drawResources && mesh) {\n        text = '' + (this.draw.getDrawCommandsGpuSize(tile.drawCommands[0] || tile.lastRenderState.drawCommands[0])/(1024*1024)).toFixed(2) + 'MB';\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n    }\n\n    //draw face count\n    if (debug.drawFaceCount && mesh) {\n        text = '' + mesh.faces + ' - ' + mesh.submeshes.length + ((tile.surface && tile.surface.glue) ? ' - 1' : ' - 0');\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n    }\n\n    //draw geodata pixel size\n    if (debug.drawGPixelSize) {\n        text = '' + ((Math.tan(tile.metanode.diskAngle2A) * tile.metanode.diskDistance * 0.70710678118) / node.displaySize).toFixed(2);\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n    }\n\n    //draw order\n    if (debug.drawOrder) {\n        text = '' + this.drawTileCounter + ' cmds: ' + (tile.drawCommands[0].length);\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n    }\n\n    if (debug.drawSurfaces || debug.drawSurfaces2) {\n        text = JSON.stringify(tile.surface.id);\n\n        if (debug.drawSurfaces2) {\n            //c = utils.getHashColor(text);\n            c = utils.getHashColor2(tile.surface.surfaceCounter);\n            //c = [c[0]/255,c[1]/255,c[2]/255,1];\n            c = [c[0],c[1],c[2],1];\n        } else {\n            c = [1,1,1,1];    \n        }\n\n        if (node.alien) {\n            text = '[A]' + text;\n        }\n\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, c, pos[2]);\n    }\n\n    if (debug.drawBoundLayers) {\n        if (tile.boundsDebug) {\n            var surface = tile.resourceSurface;\n            if (surface.glue) { \n              \n                for (i = 0, li = surface.id.length; i < li; i++) {\n                    if (tile.boundsDebug[surface.id[i]]) {\n                        text = '< ' + surface.id[i] + ' >';\n                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(10+i*7*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n                        text = JSON.stringify(tile.boundsDebug[surface.id[i]]);\n                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*7*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n                    }\n                }\n                \n            } else if (tile.boundsDebug[surface.id]) {\n                text = '< ' + surface.id + ' >';\n                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);\n    \n                text = JSON.stringify(tile.boundsDebug[surface.id]);\n                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [1,1,1,1], pos[2]);\n            }\n        }\n    }\n\n    if (debug.drawCredits) {\n        text = '{ ';\n       \n        for (var key in tile.imageryCredits) {\n            if (tile.imageryCredits[key]) {\n                text += key + ':' + tile.imageryCredits[key] + ', ';\n            }\n        }\n\n        for (key in tile.glueImageryCredits) {\n            if (!tile.imageryCredits[key]) {\n                text += key + ':' + tile.glueImageryCredits[key] + ', ';\n                //text += key + \", \";\n            }\n        }\n\n        text += '}';\n\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);\n    }\n\n    //draw distance\n    if (debug.drawDistance) {\n        text = '' + tile.distance.toFixed(2) + '  ' + tile.texelSize.toFixed(3) + '  ' + node.pixelSize.toFixed(3);\n        text += '--' + tile.texelSize2.toFixed(3); \n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [1,0,1,1], pos[2]);\n    }\n\n    //draw node info\n    if (debug.drawNodeInfo) {\n        var children = ((node.flags & ((15)<<4))>>4);\n        text = 'v' + node.metatile.version + '-' + node.flags.toString(2) + '-' + ((children & 1) ? '1' : '0') + ((children & 2) ? '1' : '0') + ((children & 4) ? '1' : '0') + ((children & 8) ? '1' : '0');\n        text += '-' + node.minHeight + '/' + node.maxHeight+ '-' + Math.floor(node.minZ) + '/' + Math.floor(node.maxZ)+ '-' + Math.floor(node.surrogatez);\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-18*factor), 4*factor, text, [1,0,1,1], pos[2]);\n    }\n    \n    //draw texture size\n    if (debug.drawTextureSize && mesh) {\n        var submeshes = mesh.submeshes;\n        for (i = 0, li = submeshes.length; i < li; i++) {\n\n            if (submeshes[i].internalUVs) {\n                var texture = tile.surfaceTextures[i];\n                if (texture) {\n                    var gpuTexture = texture.getGpuTexture();\n                    if (gpuTexture) {\n                        text = '[' + i + ']: ' + gpuTexture.width + ' x ' + gpuTexture.height;\n                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n                    }\n                }\n            } else {\n                text = '[' + i + ']: 256 x 256';\n                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n            }\n        }\n    }\n\n};\n\n\nexport default MapDrawTiles;\n\n","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport MapGeodata_ from './geodata';\nimport MapGeodataView_ from './geodata-view';\nimport MapDrawTiles_ from './draw-tiles';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar math = math_;\nvar MapDrawTiles = MapDrawTiles_;\nvar MapGeodataView = MapGeodataView_;\nvar MapGeodata = MapGeodata_;\n\nvar MapDraw = function(map) {\n    this.map = map;\n    this.config = map.config;\n    this.isProjected = map.getNavigationSrs().isProjected();\n    this.isGeocent = map.isGeocent;\n\n    this.renderer = map.renderer;\n    this.stats = map.stats;\n    this.camera = map.camera;\n    this.tree = map.tree;\n\n    this.ndcToScreenPixel = this.renderer.curSize[0] * 0.5;\n\n    this.debug = {\n        heightmapOnly : false,\n        blendHeightmap : true,\n        drawBBoxes : false,\n        drawNBBoxes : false,\n        drawSpaceBBox : false,        \n        drawMeshBBox : false,\n        drawLods : false,\n        drawPositions : false,\n        drawTexelSize : false,\n        drawWireframe : 0,\n        drawTestMode : 0,\n        drawTestData : 0,\n        drawFaceCount : false,\n        drawDistance : false,\n        drawMaxLod : false,\n        drawGeodataOnly : false,\n        drawTextureSize : false,\n        drawNodeInfo : false,\n        drawLayers : true,\n        drawBoundLayers : false,\n        drawSurfaces : false,\n        drawCredits : false,\n        drawOrder : false,\n        drawOctants : false,\n        drawLabelBoxes : false,\n        drawAllLabels : false,\n        drawHiddenLabels : false,\n        drawEarth : true, \n        drawGridCells : false,\n        drawTileCounter : 0,\n        drawPolyWires : false,\n        drawFog : this.config.mapFog,\n        drawGPixelSize : false,\n        debugTextSize : 2.0,\n        ignoreTexelSize : false,\n        maxZoom : false\n    };\n\n    this.gridFlat = false;\n    this.gridGlues = false;\n    this.gridSkipped = false;\n\n    this.atmoColor = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];\n    this.atmoColor2 = [72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0];\n    this.atmoHeight = 50000;\n    this.atmoHeightFactor = 1; //this.atmoHeight / 50000;\n    this.atmoDensity = 1; //this.atmoHeight / 50000;\n\n    this.fogDensity = 0;\n    this.zFactor = 0;\n    //this.zFactor2 = 0.000012;\n    this.zFactor2 = 0.003;\n    this.zbufferOffset = null;    \n    this.zShift = 0;\n    this.zLastShift = 0;\n    this.bestMeshTexelSize = 1;\n    this.bestGeodataTexelSize = 1;\n    this.log8 = Math.log(8);\n    this.log2 = Math.log(2);\n\n    this.geodataTilesPerLayer = 0;\n\n    this.drawCounter = 0;\n    this.drawChannel = 0;\n    this.drawChannelNames = ['base', 'hit'];\n\n    this.planetRadius = this.isGeocent ? map.getNavigationSrs().getSrsInfo()['a'] : 100;\n    this.tileBuffer = new Array(500);\n    this.processBuffer = new Array(60000);\n    this.processBuffer2 = new Array(60000);\n    this.drawBuffer = new Array(60000);\n    this.drawBuffer2 = new Array(60000);\n    this.tmpVec3 = new Array(3);\n    this.tmpVec5 = new Array(5);\n    this.bboxBuffer = new Float32Array(8*3);\n    this.planeBuffer = new Float32Array(9*3);\n    //this.drawBufferIndex = 0;\n\n    var gpu = this.renderer.gpu;\n    this.drawTileState = gpu.createState({});\n    this.drawStardomeState = gpu.createState({zwrite:false, ztest:false});\n    this.drawBlendedTileState = gpu.createState({zequal:true, blend:true});\n    this.drawAuraState = gpu.createState({zwrite:false, blend:true});\n    this.drawAtmoState = gpu.createState({zwrite:false, ztest:false, blend:true});\n    this.drawAtmoState2 = gpu.createState({zwrite:false, ztest:true, blend:false});\n\n    this.degradeHorizonFactor = 0;\n    this.degradeHorizonTiltFactor = 0;\n\n    this.replay = {\n        camera : null,\n        drawnTiles : null,\n        drawnFreeTiles : null,\n        nodeBuffer : null,\n        tracedNodes : null,\n        tracedFreeNodes : null,\n        storeTiles : false,\n        storeFreeTiles : false,\n        storeNodes : false,\n        storeFreeNodes : false,\n        storeLoaded : this.config.mapStoreLoadStats,\n        drawGlobe : false,\n        drawTiles : false,\n        drawNodes : false,\n        drawFreeTiles : false,\n        drawFreeNodes : false,\n        drawLoaded : false,\n        lod : 30,\n        singleLod : false,\n        loadedIndex : 0,\n        singleLodedIndex : 0,\n        loaded : [],\n        loadFirst : 0,\n        loadLast : 0\n    };\n\n    this.drawTiles = new MapDrawTiles(map, this);\n};\n\n\nMapDraw.prototype.drawMap = function(skipFreeLayers) {\n    var map = this.map;\n    var renderer = this.renderer;\n    var camera = this.camera;\n    var replay = this.replay;\n    var gpu = renderer.gpu;\n    var debug = this.debug;\n\n    if (this.drawChannel != 1) {\n        gpu.setViewport();\n\n        map.visibleCredits = {\n            imagery : {},\n            glueImagery : {},\n            mapdata : {}\n        };\n    }\n\n    var projected = this.isProjected;\n\n    switch (this.config.mapGridMode) {\n        case 'none':       this.gridSkipped = true; this.gridFlat = false; this.gridGlues = false;  break;\n        case 'flat':       this.gridSkipped = false; this.gridFlat = true; this.gridGlues = false;  break;\n        case 'linear':     this.gridSkipped = false; this.gridFlat = false; this.gridGlues = true;  break;\n        case 'fastlinear': this.gridSkipped = false; this.gridFlat = false; this.gridGlues = false; break;\n    }\n\n    var drawTiles = this.drawTiles;\n    var camInfo = camera.update();\n    var renderer = this.renderer;\n\n    renderer.debugStr = 'AsyncImageDecode: ' + this.config.mapAsyncImageDecode;\n    renderer.dirty = true;\n    renderer.drawFog = this.debug.drawFog;\n    renderer.debug = this.debug; \n    renderer.mapHack = map;\n    renderer.benevolentMargins = this.config.mapBenevolentMargins;\n\n    if (this.config.mapForceFrameTime) {\n        if (this.config.mapForceFrameTime != -1) {\n            renderer.frameTime = this.config.mapForceFrameTime;\n        } else {\n            renderer.frameTime = 0;\n        }\n    } else {\n        renderer.frameTime = this.stats.frameTime;        \n    }\n\n    renderer.hoverFeatureCounter = 0;\n    renderer.hoverFeatureList = map.hoverFeatureList;\n    renderer.hoverFeature = map.hoverFeature;\n\n    renderer.cameraPosition = camera.position;\n    renderer.cameraOrientation = map.position.getOrientation();\n    renderer.cameraTiltFator = Math.cos(math.radians(renderer.cameraOrientation[1]));\n    renderer.cameraVector = camera.vector; \n    renderer.cameraViewExtent = map.position.getViewExtent();\n    renderer.cameraViewExtent2 = Math.pow(2.0, Math.max(1.0, Math.floor(Math.log(map.position.getViewExtent()) / Math.log(2))));\n    renderer.drawLabelBoxes = this.debug.drawLabelBoxes;\n    renderer.drawGridCells = this.debug.drawGridCells;\n    renderer.drawAllLabels = this.debug.drawAllLabels;\n    renderer.drawHiddenLabels = this.debug.drawHiddenLabels;\n    renderer.debug = this.debug;\n    renderer.fmaxDist = Number.NEGATIVE_INFINITY;\n    renderer.fminDist = Number.POSITIVE_INFINITY;\n\n\n    if (projected) {\n        var yaw = math.radians(renderer.cameraOrientation[0]);\n        renderer.labelVector = [-Math.sin(yaw), Math.cos(yaw), 0, 0, 0];\n    } else {\n        var v = camInfo.vector;\n        renderer.labelVector = [v[0], v[1], v[2], 0]; \n    }\n\n    renderer.distanceFactor = 1 / Math.max(1,Math.log(camera.distance) / Math.log(1.04));\n    renderer.tiltFactor = (Math.abs(renderer.cameraOrientation[1]/-90));\n    renderer.localViewExtentFactor = 2 * Math.tan(math.radians(map.position.getFov()*0.5));\n\n    this.degradeHorizonFactor = 200.0 * this.config.mapDegradeHorizonParams[0];\n    this.degradeHorizonTiltFactor = 0.5*(1.0+Math.cos(math.radians(Math.min(180,Math.abs(renderer.cameraOrientation[1]*2*3)))));\n   \n    if (this.drawChannel != 1) {\n        if (debug.drawWireframe == 2) {\n            gpu.clear(true, true, [255,255,255,255]);\n        } else {\n            gpu.clear(true, true, [0,0,0,255]);\n        }\n    } else { //render depth map\n        gpu.clear(true, true, [255,255,255,255]);\n    }\n\n    gpu.setState(this.drawStardomeState);\n\n    /*\n    if (this.drawChannel != 1) {\n        if (debug.drawWireframe == 2) {\n            renderer.draw.drawSkydome(renderer.whiteTexture, renderer.progStardome);\n        } else {\n            renderer.draw.drawSkydome(renderer.blackTexture, renderer.progStardome);\n        }\n    }*/\n\n    gpu.setState(this.drawTileState);\n\n    this.setupDetailDegradation();\n\n    map.loader.setChannel(0); //0 = hires channel\n    this.zFactor = 0;\n\n    this.ndcToScreenPixel = renderer.curSize[0] * 0.5;\n    this.updateFogDensity();\n    this.updateGridFactors();\n    this.maxGpuUsed = Math.max(32*102*1204, map.gpuCache.getMaxCost() - 32*102*1204); \n    //this.cameraCenter = this.position.getCoords();\n    this.stats.renderBuild = 0;\n    this.drawTileCounter = 0;\n    var cameraPos = camera.position;\n    var i, li, j, lj, tile, tiles, tmp, layer, drawnTiles, nodeBuffer;\n\n    if (map.freeLayersHaveGeodata && this.drawChannel == 0) {\n        renderer.draw.clearJobBuffer();\n    }\n\n    if (this.debug.drawEarth) {\n        if (replay.storeNodes || replay.storeFreeNodes) {\n            replay.nodeBuffer = [];\n        }\n        \n        if (replay.drawGlobe || replay.drawTiles || replay.drawFreeTiles||\n            replay.drawNodes || replay.drawFreeNodes || replay.drawLoaded) { //used only in inspector\n    \n            var lod = replay.lod; \n            var single = replay.singleLod; \n    \n            if (replay.drawTiles && replay.drawnTiles) {\n                tiles = replay.drawnTiles;\n                for (i = 0, li = tiles.length; i < li; i++) {\n                    if (!tiles[i][1]) { //skip grids\n                        tile = tiles[i][0];\n                        if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {\n                            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);\n                        }\n                    } else {\n                        tile = tiles[i][0];\n                        if (drawTiles.debug.drawBBoxes) {\n                            drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);\n                        }\n\n                        tile.drawGrid(cameraPos); \n                    }\n                }\n            }\n            \n            if (replay.drawFreeTiles && replay.drawnFreeTiles) {\n                tiles = replay.drawnFreeTiles;\n                for (i = 0, li = tiles.length; i < li; i++) {\n                    if (!tiles[i][1]) { //skip grids\n                        tile = tiles[i][0];\n                        if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {\n                            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);\n                        }\n                    }\n                }\n            }\n    \n            if (replay.drawNodes && replay.tracedNodes) {\n                tiles = replay.tracedNodes;\n                tmp = debug.drawBBoxes;\n                debug.drawBBoxes = true;  \n                for (i = 0, li = tiles.length; i < li; i++) {\n                    tile = tiles[i];\n                    if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {\n                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);\n                    }\n                }\n                debug.drawBBoxes = tmp;\n            }\n    \n            if (replay.drawFreeNodes && replay.tracedFreeNodes) {\n                tiles = replay.tracedFreeNodes;\n                tmp = debug.drawBBoxes;\n                debug.drawBBoxes = true;  \n                for (i = 0, li = tiles.length; i < li; i++) {\n                    tile = tiles[i];\n                    if ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod)) {\n                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);\n                    }\n                }\n                debug.drawBBoxes = tmp;\n            }\n    \n            var index = replay.loadedIndex; \n            var singleIndex = replay.singleLodedIndex; \n    \n            if (replay.drawLoaded && replay.loaded) {\n                var  loaded = replay.loaded;\n                debug.drawBBoxes = true;  \n                for (i = 0, li = loaded.length; i < li; i++) {\n                    var file = loaded[i];\n                    if (file && file.tile && file.tile.id) {\n                        tile = file.tile;\n                        if (((singleIndex && i == index) || (!singleIndex && i <= index)) &&\n                             ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod)) ) {\n                            if (tile.metanode) {\n                                if (tile.metanode.hasGeometry()) {\n                                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);\n                                } else {\n                                    drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);\n                                }\n                            }\n                        }\n                    }\n                }\n                debug.drawBBoxes = tmp;\n            }\n    \n            if ((replay.drawFreeTiles && replay.drawnFreeTiles) ||\n                (replay.drawLoaded && replay.loaded)) {\n                    \n                if (this.freeLayersHaveGeodata && this.drawChannel == 0) {\n                    renderer.drawnGeodataTiles = this.stats.drawnGeodataTilesPerLayer; //drawnGeodataTiles;\n                    renderer.drawnGeodataTilesFactor = this.stats.drawnGeodataTilesFactor;\n                    renderer.draw.drawGpuJobs();\n                }\n            }\n    \n            return;\n        }    \n        \n        for (i = 0, li = this.tileBuffer.length; i < li; i++) {  //todo remove this\n            this.tileBuffer[i] = null;    \n        }\n    \n        if (this.tree.surfaceSequence.length > 0) {\n            this.tree.draw();\n        }\n    \n        if (replay.storeTiles) { //used only in inspectors\n            drawnTiles = [];\n    \n            for (i = 0, li = this.tileBuffer.length; i < li; i++) {\n                tiles = this.tileBuffer[i];\n               \n                if (tiles) {\n                    for (j = 0, lj = tiles.length; j < lj; j++) {\n                        drawnTiles.push(tiles[j]);\n                    }\n                }\n            }\n            \n            replay.cameraPos = cameraPos; \n            replay.drawnTiles = drawnTiles;\n            replay.storeTiles = false; \n        }\n    \n        if (replay.storeNodes) { //used only in inspector\n            nodeBuffer = []; \n    \n            for (i = 0, li = replay.nodeBuffer.length; i < li; i++) {\n                tile = replay.nodeBuffer[i];\n                nodeBuffer.push(tile);\n            }\n    \n            replay.cameraPos = cameraPos; \n            replay.tracedNodes = nodeBuffer;\n            replay.storeNodes = false; \n        }\n    \n        //draw free layers    \n        for (i = 0, li = map.freeLayerSequence.length; i < li; i++) {\n            layer = map.freeLayerSequence[i];\n            if (layer.ready && layer.tree && \n                (!layer.geodata || (layer.stylesheet && layer.stylesheet.isReady())) && this.drawChannel == 0) {\n                \n                if (layer.zFactor) {\n                    this.zbufferOffset = layer.zFactor;\n                }\n\n                if (layer.type == 'geodata') {\n                    this.drawMonoliticGeodata(layer);\n                } else {\n                    layer.tree.draw();\n                }\n\n                this.zbufferOffset = null;\n            }\n        }\n    \n        if (replay.storeFreeTiles) { //used only in inspector\n            drawnTiles = [];\n    \n            for (i = 0, li = this.tileBuffer.length; i < li; i++) {\n                tiles = this.tileBuffer[i];\n               \n                if (tiles) {\n                    for (j = 0, lj = tiles.length; j < lj; j++) {\n                        tile = tiles[j];\n                        if (tile.surface && tile.surface.free) { //do no draw free layers\n                            drawnTiles.push(tile);\n                        }\n                    }\n                }\n            }\n            \n            replay.cameraPos = cameraPos; \n            replay.drawnFreeTiles = drawnTiles;\n            replay.storeFreeTiles = false; \n        }\n    \n        if (replay.storeFreeNodes) { //used only in inspector\n            nodeBuffer = []; \n    \n            for (i = 0, li = replay.nodeBuffer.length; i < li; i++) {\n                tile = replay.nodeBuffer[i];\n                if (tile.surface && tile.surface.free) { //do no draw free layers\n                    nodeBuffer.push(tile);\n                }\n            }\n    \n            replay.cameraPos = cameraPos; \n            replay.tracedFreeNodes = nodeBuffer;\n            replay.storeFreeNodes = false; \n        }\n    }\n\n    var body = map.referenceFrame.body;\n\n    //draw skydome before geodata\n    if (this.drawChannel != 1 && !projected && debug.drawFog &&\n        ((body && body.atmosphere) || map.referenceFrame.id == 'melown2015' || map.referenceFrame.id == 'mars-qsc' || map.referenceFrame.id == 'earth-qsc') &&\n        renderer.progAtmo.isReady() && renderer.progAtmo2.isReady()) {    \n\n        var navigationSrsInfo = map.getNavigationSrs().getSrsInfo();\n        var earthRadius =  navigationSrsInfo['a'];\n        var earthRadius2 =  navigationSrsInfo['b'];\n        var atmoSize = this.atmoHeight;\n        renderer.earthRadius = earthRadius;\n        renderer.earthRadius2 = earthRadius2;\n        renderer.earthERatio = earthRadius / earthRadius2;\n\n        var cameraPosToEarthCenter = [0,0,0,0];\n        vec3.normalize(camera.position, cameraPosToEarthCenter);\n\n        var pos = map.getPosition();\n        //var orientation = pos.getOrientation();\n        //var tiltFactor = (Math.max(5,-orientation[1])/90);\n\n        //var cameraHeight = Math.max(atmoSize * 0.1, camera.geocentDistance - earthRadius);\n        var heightFactor = 1-math.clamp(Math.max(atmoSize * 0.1, camera.geocentDistance - earthRadius) / (atmoSize*(10)), 0, 1);\n\n        var params = [Math.max(2,heightFactor*128),0,0,0], params2, params3;\n        \n        /*\n        if (cameraHeight > earthRadius*2) { //prevent foggy earth from larger distance\n            params[0] = 2-Math.min(1.0, (camera.height - earthRadius*2) / (earthRadius*2));\n        }*/\n\n        //gpu.setState(this.drawAtmoState);\n        //renderer.draw.drawBall([-camera.position[0], -camera.position[1], -camera.position[2]],\n          //                       earthRadius + 3000, earthRadius2 + 3000, renderer.progAtmo2, params,  cameraPosToEarthCenter, null, this.atmoColor3, this.atmoColor2, true);// this.cameraHeight > atmoSize ? 1 : -1);\n        \n        var safetyFactor = 2.0; \n        params = [safetyFactor, safetyFactor * ((earthRadius + atmoSize) / earthRadius), 0.25, safetyFactor* ((earthRadius + atmoSize) / earthRadius)];\n        var factor = (1 / (earthRadius) ) * safetyFactor;  \n        params2 = [camera.position[0] * factor, camera.position[1] * factor, camera.position[2] * factor, 1];\n        \n        var distance = (pos.getViewExtent()*0.5) / Math.tan(math.radians(pos.getFov()*0.5));\n        var a1 = (earthRadius / (distance + earthRadius)); //get angle to horion\n\n        //var n2 = 10.05;\n        var n2 = 5.00;\n\n        var t1 = math.mix(4.4, 1.01, a1);\n        var t2 = math.mix(n2, 1.05, a1); // * 1.0176;\n\n        params3 = [t1, 1 ,t2,0];\n\n        //console.log(\"a1: \" + a1 + \" t2: \" + t2);\n\n        gpu.setState(this.drawAuraState);\n        renderer.draw.drawBall([-camera.position[0], -camera.position[1], -camera.position[2]],\n                                 earthRadius + atmoSize, earthRadius2 + atmoSize, renderer.progAtmo, params,  params2, params3, this.atmoColor, this.atmoColor2);// this.camera.height > atmoSize ? 1 : -1);\n\n        gpu.setState(this.drawTileState);\n    }\n\n    if (debug.drawEarth) {\n        if (!skipFreeLayers) {\n            if (map.freeLayersHaveGeodata && this.drawChannel == 0) {\n                renderer.drawnGeodataTiles = this.stats.drawnGeodataTilesPerLayer; //drawnGeodataTiles;\n                renderer.drawnGeodataTilesFactor = this.stats.drawnGeodataTilesFactor;\n                renderer.draw.drawGpuJobs();\n            }\n        }\n    }\n\n    if (this.config.mapForceFrameTime) {\n        if (this.config.mapForceFrameTime != -1) {\n            renderer.frameTime = 0;\n            this.config.mapForceFrameTime = -1;\n        }\n    }\n};\n\nMapDraw.prototype.drawToTexture = function(texture) {\n    this.renderer.switchToFramebuffer('texture', texture);\n    this.drawChannel = 0;\n    this.map.renderSlots.processRenderSlots();\n    this.renderer.switchToFramebuffer('base');\n};\n\n\nMapDraw.prototype.drawHitmap = function() {\n    this.drawChannel = 1;\n    this.renderer.switchToFramebuffer('depth');\n    this.map.renderSlots.processRenderSlots();\n    this.renderer.switchToFramebuffer('base');\n\n    if (this.renderer.hitmapMode > 2) {\n        this.renderer.copyHitmap();\n    }\n\n    this.drawChannel = 0;\n    this.map.hitMapDirty = false;\n};\n\n\nMapDraw.prototype.drawGeodataHitmap = function() {\n    this.renderer.gpu.setState(this.drawTileState);\n    this.renderer.switchToFramebuffer('geo');\n    this.renderer.draw.drawGpuJobs();\n\n    if (this.renderer.advancedPassNeeded) {\n        this.renderer.switchToFramebuffer('geo2');\n        this.renderer.draw.drawGpuJobs();\n    }\n\n    this.renderer.switchToFramebuffer('base');\n    this.map.geoHitMapDirty = false;\n};\n\nMapDraw.prototype.getDrawCommandsGpuSize = function(commands) {\n    var gpuNeeded = 0;\n    \n    for (var i = 0, li = commands.length; i < li; i++) {\n        var command = commands[i];\n        \n        switch (command.type) {\n        case VTS_DRAWCOMMAND_SUBMESH:\n               \n            var mesh = command.mesh; \n            var texture = this.config.mapNoTextures ? 0 : command.texture; \n\n            if (mesh) {\n                gpuNeeded += mesh.gpuSize;\n            }\n\n            if (texture) {\n                gpuNeeded += texture.getGpuSize();\n            }\n                \n            break;\n\n        case VTS_DRAWCOMMAND_GEODATA:\n                \n            var geodataView = command.geodataView; \n                \n            if (geodataView) {\n                gpuNeeded += geodataView.size;\n            }\n                \n            break;\n        }\n    }\n    \n    return gpuNeeded;\n};\n\n\nMapDraw.prototype.areDrawCommandsReady = function(commands, priority, doNotLoad, doNotCheckGpu) {\n    var ready = true;\n    var checkGpu = doNotCheckGpu ? true : false;\n    \n    for (var i = 0, li = commands.length; i < li; i++) {\n        var command = commands[i];\n        \n        switch (command.type) {\n        case VTS_DRAWCOMMAND_SUBMESH:\n\n            var pipeline = command.pipeline;\n            if (pipeline) {\n                var hmap = command.hmap;\n    \n                if (!(hmap && hmap.isReady(doNotLoad, priority))) {\n                    ready = false;\n                }\n\n                if (this.debug.drawTestMode == 9) {\n                    var texture = command.texture; \n                    var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority, checkGpu)));\n                        \n                    if (!textureReady) {\n                        ready = false;   \n                    }\n                }\n\n                break;\n            }\n                \n            var mesh = command.mesh; \n            var texture = command.texture; \n                \n            var meshReady = (mesh && mesh.isReady(doNotLoad, priority, checkGpu));\n            var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority, checkGpu)));\n                \n            if (!(meshReady && textureReady) ) {\n                ready = false;   \n            }\n               \n            break;\n\n        case VTS_DRAWCOMMAND_GEODATA:\n                \n            var geodataView = command.geodataView; \n                \n            if (!(geodataView && geodataView.isReady(doNotLoad, priority, checkGpu))) {\n                ready = false;   \n            }\n                \n            break;\n        }\n    }\n    \n    return ready;\n};\n\n\nMapDraw.prototype.processDrawCommands = function(cameraPos, commands, priority, doNotLoad, tile) {\n    if (commands.length > 0) {\n        this.drawTileCounter++;\n    }\n\n    for (var i = 0, li = commands.length; i < li; i++) {\n        var command = commands[i];\n        \n        switch (command.type) {\n        case VTS_DRAWCOMMAND_STATE:\n            this.renderer.gpu.setState(command.state);\n            break;\n\n        case VTS_DRAWCOMMAND_SUBMESH:\n\n            var pipeline = command.pipeline;\n            if (pipeline) {\n                var hmap = command.hmap;\n    \n                if (this.debug.drawTestMode == 9) {\n                    var texture = command.texture; \n                    var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority)));\n                        \n                    if (textureReady) {\n                        if (hmap && hmap.isReady(doNotLoad, priority)) {\n                            tile.drawHmapTile(cameraPos, null, null, pipeline, texture);\n                        }\n                    }\n                } else {\n                    if (hmap && hmap.isReady(doNotLoad, priority)) {\n                        tile.drawHmapTile(cameraPos, null, null, pipeline);\n                    }\n                }\n\n                return;\n            }\n\n            var mesh = command.mesh; \n            var texture = command.texture;\n\n            var meshReady = (mesh && mesh.isReady(doNotLoad, priority)), textureReady;\n\n            if (this.config.mapNoTextures) {\n                textureReady = true;\n                texture = null;\n            } else {\n                textureReady = (!texture || (texture && texture.isReady(doNotLoad, priority)));\n            }\n                \n            if (meshReady && textureReady) {\n                    //debug bbox\n                if (this.debug.drawBBoxes && this.debug.drawMeshBBox) {\n                    mesh.submeshes[command.submesh].drawBBox(cameraPos);\n                }\n                    \n                if (!texture) {\n                    var material = command.material;\n                    switch (material) {\n                            //case \"fog\":\n                    case VTS_MATERIAL_EXTERNAL:\n                    case VTS_MATERIAL_INTERNAL:\n                        material = VTS_MATERIAL_FLAT;\n                        break; \n                    }\n                    mesh.drawSubmesh(cameraPos, command.submesh, texture, material, command.alpha, command.layer, command.surface, tile.splitMask);\n                } else {\n                    //tile.renderHappen = true;\n                    mesh.drawSubmesh(cameraPos, command.submesh, texture, command.material, command.alpha, command.layer, command.surface, tile.splitMask);\n                }\n\n            }\n                \n            break;\n                \n        case VTS_DRAWCOMMAND_GEODATA:\n                \n            var geodataView = command.geodataView; \n            //tile.renderHappen = true;\n                \n            if (geodataView && geodataView.isReady(doNotLoad, priority, true)) {\n                geodataView.draw(cameraPos);\n            }\n                \n            break;\n        }\n    }\n};\n\n\nMapDraw.prototype.drawMonoliticGeodata = function(surface) {\n    if (!surface || this.drawChannel != 0) {\n        return;\n    }\n\n    if (!this.camera.camera.bboxVisible(surface.extents, this.camera.position)) {\n        return;\n    }\n\n    var path;\n\n    if (surface.monoGeodata == null) {\n        if (typeof surface.geodataUrl === 'object') {\n            path = surface.geodataUrl;\n        } else {\n            path = surface.getMonoGeodataUrl(surface.id);\n        }\n\n        surface.monoGeodata = new MapGeodata(this.map, path, {tile:null, surface:surface});\n    }\n\n    if (surface.monoGeodataCounter != surface.geodataCounter) {\n        surface.monoGeodataView = null;\n        surface.monoGeodataCounter = surface.geodataCounter;\n    }\n\n    if (surface.monoGeodata.isReady(null, null, null, surface.options.fastParse)) {\n\n        if (!surface.monoGeodataView) {\n            surface.monoGeodataView = new MapGeodataView(this.map, surface.monoGeodata, {tile:null, surface:surface});\n        }\n        \n        if (surface.monoGeodataView.isReady()) {\n            var mapdataCredits = this.map.visibleCredits.mapdata\n\n            for (var i = 0, li = surface.credits.length; i < li; i++) {\n                var key = surface.credits[i]\n                var value = 10; //fixed specificity\n                var value2 = mapdataCredits[key];\n\n                if (value2) {\n                    mapdataCredits[key] = value > value2 ? value : value2;\n                } else {\n                    mapdataCredits[key] = value;\n                }\n            }\n\n            surface.monoGeodataView.draw(this.camera.position);\n        }\n    }\n};\n\n\nMapDraw.prototype.updateFogDensity = function() {\n    // the fog equation is: exp(-density*distance), this gives the fraction\n    // of the original color that is still visible at some distance\n\n    // we define visibility as a distance where only 5% of the original color\n    // is visible; from this it is easy to calculate the correct fog density\n\n    //var density = Math.log(0.05) / this.core.coreConfig.cameraVisibility;\n    var pos = this.map.getPosition();\n    var orientation = pos.getOrientation();\n    \n    var cameraVisibility = this.camera.getFar();\n    \n    var tiltFactor = (Math.max(5,-orientation[1])/90);\n    var density = Math.log(0.05) / ((this.atmoDensity * cameraVisibility * this.atmoHeightFactor * Math.max(1,this.camera.height*0.0001))* tiltFactor);\n    density *= (5.0) / (Math.min(50000, Math.max(this.camera.distance, 1000)) /5000);\n\n    if (!this.debug.drawFog) {\n        density = 0;\n    }\n    \n    //reduce fog when camera is facing down\n    //density *= 1.0 - (-this.orientation[0]/90)\n    \n    this.fogDensity = density;\n    this.renderer.fogDensity = density; \n};\n\n\nMapDraw.prototype.updateGridFactors = function() {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i]; \n        var embed = 8;\n\n        var altitude = Math.max(10, this.camera.distance + 20);\n        //var altitude = Math.max(1.1, this.cameraDistance);\n        var maxDistance = (node.extents.ur[0] - node.extents.ll[0])*2;\n        var gridSelect = Math.log(Math.min(maxDistance,altitude)) / this.log8;\n        var gridMax = Math.log(maxDistance) / this.log8;\n    \n        gridSelect = gridMax - gridSelect;\n    \n        node.gridBlend = (gridSelect - Math.floor(gridSelect));\n        \n        gridSelect = Math.floor(Math.floor(gridSelect))+1;\n        node.gridStep1 = Math.pow(embed, gridSelect);\n        node.gridStep2 = node.gridStep1 * 8; \n    }\n};\n\n\nMapDraw.prototype.setupDetailDegradation = function(degradeMore) {\n    var factor = 0;\n    \n    if (this.map.mobile) {\n        factor = this.config.mapMobileDetailDegradation;\n    }\n\n    if (degradeMore) {\n        factor += degradeMore;        \n    }\n\n    var dpiRatio = 1; //(window.devicePixelRatio || 1);\n\n    this.texelSizeFit = this.config.mapTexelSizeFit * Math.pow(2,factor) * dpiRatio;      \n};\n\n\nexport default MapDraw;\n\n","\n//import Delaunator_ from './geodata-utils';\nimport MapGeodataGeometry_ from './geodata-geometry';\nimport MapGeodataImportGeoJSON_ from './geodata-import/geojson';\nimport MapGeodataImportVTSGeodata_ from './geodata-import/vts-geodata';\nimport MapGeodataImport3DTiles_ from './geodata-import/3dtiles';\n//import GeographicLib_ from 'geographiclib';\nimport {vec3 as vec3_, mat4 as mat4_,} from '../utils/matrix';\n\n//get rid of compiler mess\n//var Delaunator = Delaunator_;\nvar MapGeodataGeometry = MapGeodataGeometry_;\nvar MapGeodataImportGeoJSON = MapGeodataImportGeoJSON_;\nvar MapGeodataImportVTSGeodata = MapGeodataImportVTSGeodata_;\nvar MapGeodataImport3DTiles = MapGeodataImport3DTiles_;\n\n//var GeographicLib = GeographicLib_;\nvar vec3 = vec3_;\nvar mat4 = mat4_;\n\n\nvar MapGeodataBuilder = function(map) {\n    this.map = map;\n    this.groups = [];\n    this.nodes = [];\n    this.currentGroup = null;\n    this.bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n    this.bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n\n    this.navSrs = this.map.getNavigationSrs();\n    //this.navSrs = this.map.getPublicSrs();\n    this.physSrs = this.map.getPhysicalSrs();\n\n    this.heightsToProcess = 0;\n    this.heightsProcessBuffer = null;\n    this.heightsProcessBufferFirst = null;\n    this.heightsProcessBufferLast = null;\n\n    this.heightsLod = 8;\n    this.heightsSource = \"heightmap-by-precision\";\n    this.updateCallback = null;\n    this.processingHeights = false;\n    this.processHeightsCalls = [];\n};\n\n\nMapGeodataBuilder.prototype.addToHeightsBuffer = function(coords) {\n\n    var item = { coords: coords, prev: null, next: this.heightsProcessBufferFirst };\n\n    if (this.heightsProcessBufferFirst != null) {\n        this.heightsProcessBufferFirst.prev = item;\n    }\n\n    //add item as first in list\n    this.heightsProcessBufferFirst = item;\n\n    if (this.heightsProcessBufferLast == null) {\n        this.heightsProcessBufferLast = item;\n    }\n};\n\n\nMapGeodataBuilder.prototype.removeFromHeightsBuffer = function(item) {\n    var hit = false;\n\n    if (item == this.heightsProcessBufferFirst) {\n        this.heightsProcessBufferFirst = item.next;\n        hit = true;\n\n        if (this.heightsProcessBufferFirst != null) {\n            this.heightsProcessBufferFirst.prev = null;\n        }\n    }\n\n    if (item == this.heightsProcessBufferLast) {\n        this.heightsProcessBufferLast = item.prev;\n        hit = true;\n\n        if (this.heightsProcessBufferLast != null) {\n            this.heightsProcessBufferLast.next = null;\n        }\n    }\n\n    if (!hit) {\n        if (!item.prev) {\n            //debugger;\n        } else {\n            item.prev.next = item.next;\n        }\n        \n        if (!item.next) {\n            //debugger;\n        } else {\n            item.next.prev = item.prev;\n        }\n    }\n};\n\n\nMapGeodataBuilder.prototype.addGroup = function(id) {\n    this.groups.push({\n        points: [],\n        lines: [],\n        polygons: [],\n        id: id\n    });\n\n    this.currentGroup = this.groups[this.groups.length - 1];\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addNode = function(parentNode, volume, precision, tileset) {\n    var node = {\n        meshes: [],\n        precision : precision,\n        volume : volume,\n        tileset: tileset ? true : false,\n        nodes : []\n    };\n\n    if(!parentNode) {\n        parentNode = this;\n    }\n\n    parentNode.nodes.push(node);\n\n    return node;\n};\n\n\nMapGeodataBuilder.prototype.addMesh = function(node, path) {\n    if (node) {\n        node.meshes.push(path);\n    }\n};\n\n\nMapGeodataBuilder.prototype.addLoadNode = function(node, path) {\n    if (node) {\n        if (!node.loadNodes) {\n            node.loadNodes = [];\n        }\n        \n        node.loadNodes.push(path);\n    }\n};\n\n\nMapGeodataBuilder.prototype.addPoint = function(point, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\"), coords;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    if (floatHeight) {\n        coords = [point[0], point[1], point[2] || 0, feature, null, null ];\n        this.addToHeightsBuffer(coords);\n\n        feature.points = [ coords ];\n        feature.floatHeights = true;\n        feature.srs = srs ? srs : this.navSrs;\n        feature.heightsToProcess = 1;\n        this.heightsToProcess++;\n    } else {\n        if (directCopy) {\n            feature.points = [ [point[0], point[1], point[2]] ];\n        } else {\n            feature.points = [ this.physSrs.convertCoordsFrom(point, srs ? srs : this.navSrs) ];\n        }\n    }\n\n    this.currentGroup.points.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addPointArray = function(points, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\"), i, li, point, coords;\n    srs = srs ? srs : this.navSrs;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    var featurePoints = new Array(points.length);\n\n    if (floatHeight) {\n        \n        for (i = 0, li = points.length; i < li; i++) {\n            point = points[i];\n            coords = [point[0], point[1], point[2] || 0, feature, null, null ];\n            this.addToHeightsBuffer(coords);\n\n            featurePoints[i] = coords;\n        }\n\n        feature.floatHeights = true;\n        feature.srs = srs;\n        feature.heightsToProcess = li;\n        this.heightsToProcess++;\n    } else {\n        if (directCopy) {\n            for (i = 0, li = points.length; i < li; i++) {\n                point = points[i];\n                featurePoints[i] = [point[0], point[1], point[2]];\n            }\n        } else {\n            for (i = 0, li = points.length; i < li; i++) {\n                featurePoints[i] = this.physSrs.convertCoordsFrom(points[i], srs);\n            }\n        }\n    }\n\n    feature.points = featurePoints;\n    this.currentGroup.points.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addLineString = function(linePoints, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\"), i, li, point, coords;\n    srs = srs ? srs : this.navSrs;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    var featurePoints = new Array(linePoints.length);\n\n    if (floatHeight) {\n        \n        for (i = 0, li = linePoints.length; i < li; i++) {\n            point = linePoints[i];\n            coords = [point[0], point[1], point[2] || 0, feature, null, null ];\n            this.addToHeightsBuffer(coords);\n\n            featurePoints[i] = coords;\n        }\n\n        feature.floatHeights = true;\n        feature.srs = srs;\n        feature.heightsToProcess = li;\n        this.heightsToProcess += li;\n    } else {\n        if (directCopy) {\n            for (i = 0, li = linePoints.length; i < li; i++) {\n                point = linePoints[i];\n                featurePoints[i] = [point[0], point[1], point[2]];\n            }\n        } else {\n            for (i = 0, li = linePoints.length; i < li; i++) {\n                featurePoints[i] = this.physSrs.convertCoordsFrom(linePoints[i], srs);\n            }\n        }\n    }\n\n    feature.lines = [featurePoints];\n    this.currentGroup.lines.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addLineStringArray = function(lines, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\");\n    var subline, points, i, li, j, lj, point, coords;\n    srs = srs ? srs : this.navSrs;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    var featureLines = new Array(lines.length);\n\n    if (floatHeight) {\n        var totalHeights = 0;\n        \n        for (i = 0, li = lines.length; i < li; i++) {\n            subline = lines[i];\n            points = new Array(subline.length);\n\n            for (j = 0, lj = subline.length; j < lj; j++) {\n                point = subline[j];\n                coords = [point[0], point[1], point[2] || 0, feature, null, null];\n                this.addToHeightsBuffer(coords);\n                points[j] = coords;\n            }\n\n            totalHeights += lj;\n            featureLines[i] = points;\n        }\n\n        feature.floatHeights = true;\n        feature.srs = srs;\n        feature.heightsToProcess = totalHeights;\n        this.heightsToProcess += totalHeights;\n    } else {\n\n        for (i = 0, li = lines.length; i < li; i++) {\n            subline = lines[i];\n            points = new Array(subline.length);\n\n            if (directCopy) {\n                for (j = 0, lj = subline.length; j < lj; j++) {\n                    point = subline[j];\n                    points[j] = [point[0], point[1], point[2]];\n                }\n            } else {\n                for (j = 0, lj = subline.length; j < lj; j++) {\n                    points[j] = this.physSrs.convertCoordsFrom(subline[j], srs);\n                }\n            }\n\n            featureLines[i] = points;\n        }\n    }\n\n    feature.lines = featureLines;\n    this.currentGroup.lines.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addPolygon = function(shape, holes, middle, heightMode, properties, id, srs, tesselation) {\n    //older versions are in github history 2.20.x\n    return this.addPolygon3(shape, holes, middle, heightMode, properties, id, srs, tesselation);\n};\n\n\nMapGeodataBuilder.prototype.getPolygonCenter = function(shape, projected, proj) {\n    if (shape && !shape.length) {\n        return [0,0];\n    }\n\n    var sumX = 0, sumY = 0, sumZ = 0; //, convertLong = false;\n\n    if (projected) {\n        for (var i = 0, li = shape.length; i < li; i++) {\n            var coords = shape[i];\n            sumX += coords[0];\n            sumY += coords[1];\n            sumZ += coords[2];\n        }\n\n        return [sumX / li, sumY / li, sumZ / li];\n    } else {\n        for (var i = 0, li = shape.length; i < li; i++) {\n            var coords = shape[i];\n            var coords2 = proj.forward(coords);\n            sumX += coords2[0];\n            sumY += coords2[1];\n            sumZ += coords2[2];\n        }\n\n        var avgX = sumX / li;\n        var avgY = sumY / li;\n        var avgZ = sumZ / li;\n\n        // convert average x, y, z coordinate to latitude and longtitude\n\n        coords = proj.inverse([avgX, avgY, avgZ]);\n\n        return [coords[0], coords[1], 0];\n    }\n};\n\n\nMapGeodataBuilder.prototype.insidePolygon = function(point, vertices, verticesLength) {\n    // ray-casting algorithm based on\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n    \n    var x = point[0], y = point[1];\n\n    verticesLength = (verticesLength || Math.round(vertices.length/3));\n\n    var inside = false;\n    for (var i = 0, j = verticesLength - 1, li = verticesLength; i < li; j = i++) {\n        var xi = vertices[i*3], yi = vertices[i*3+1];\n        var xj = vertices[j*3], yj = vertices[j*3+1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};    \n\n\n//same as addPolygon but works on poles\n/*\nMapGeodataBuilder.prototype.addPolygon2 = function(shape, holes, middle, heightMode, properties, id, srs) {\n    srs = srs ? srs : this.navSrs.srsProj4;\n    holes = holes || [];\n\n    var flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords, coords2, proj, holesIndices, vertices;\n    var projected = true;\n\n    //convert shape and holes to flat space\n    if (srs.indexOf('+proj=longlat') != -1) {\n        projected = false;\n        //proj = this.map.proj4(srs, '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');\n        //proj = this.map.proj4(srs, '+proj=merc +lat_ts=' + center[1] + ' +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');\n        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');\n    }\n\n    var c = document.getElementById(\"dbg-canvas\");\n    var ctx = c.getContext(\"2d\");\n    var sx = 300;\n    var fx = 300 / 7500000;\n\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        shape[i][2] = shape[i][2] || 0; //add third coord\n    }\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        totalPoints += hole.length*3;\n\n        for (j = 0, lj = hole.length; j < lj; j++) {\n            hole[j][2] = hole[j][2] || 0; //add third coord\n        }\n    }\n\n    var center = this.getPolygonCenter(shape, projected, proj), north, east, dir;\n\n    this.addPoint(center.slice(), 'fix', {}, 'aaa');\n\n    var ned = this.map.measure.getNewNED(center);\n\n    dir = ned.direction;\n    north = ned.north;\n    east = ned.east;\n\n    var totalPoints = shape.length*3;\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        shape[i][2] = shape[i][2] || 0; //add third coord\n    }\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        totalPoints += hole.length*3;\n\n        for (j = 0, lj = hole.length; j < lj; j++) {\n            hole[j][2] = hole[j][2] || 0; //add third coord\n        }\n    }\n\n    flatShape = new Array(totalPoints);\n    vertices = new Array(totalPoints);\n    j = 0;\n\n    var borders = new Array(holes.length + 1);\n    var border = new Array(shape.length);\n    borders[0] = border;\n\n    ctx.beginPath();\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        border[i] = i;\n        coords = shape[i];\n        vertices[j] = coords[0]; \n        vertices[j+1] = coords[1]; \n        vertices[j+2] = coords[2];\n\n        if (proj) {\n            coords2 = proj.forward(shape[i]);\n            coords= [ east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],\n                      dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];\n        } else {\n            coords = shape[i];\n        }\n\n        if (i ==0) {\n            ctx.moveTo(coords[0]*fx+sx,coords[1]*fx+sx);\n        } else {\n            ctx.lineTo(coords[0]*fx+sx,coords[1]*fx+sx);\n        }\n\n        flatShape[j] = coords[0]; \n        flatShape[j+1] = coords[1]; \n        flatShape[j+2] = coords[2]; \n        j+=3;\n    }\n\n    flatHoles = new Array(holes.length);\n    holesIndices = new Array(holes.length);\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        holesIndices[i] = Math.round(j/3);\n\n        border = new Array(hole.length);\n        borders[i + 1] = border;\n\n        l = Math.floor(j /3);\n\n        for (k = 0, lk = hole.length; k < lk; k++) {\n            coords = hole[k];\n            vertices[j] = coords[0]; \n            vertices[j+1] = coords[1]; \n            vertices[j+2] = coords[2]; \n\n            if (proj) {\n                coords2 = proj.forward(hole[k]);\n                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],\n                          dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];\n            } else {\n                coords = hole[k];\n            }\n\n            if (k ==0) {\n                ctx.moveTo(coords[0]*fx+sx,coords[1]*fx+sx);\n            } else {\n                ctx.lineTo(coords[0]*fx+sx,coords[1]*fx+sx);\n            }\n\n\n            flatShape[j] = coords[0]; \n            flatShape[j+1] = coords[1]; \n            flatShape[j+2] = coords[2]; \n            j+=3;\n            border[k] = l++;\n        }\n    }\n\n    ctx.strokeStyle = \"#ff0000\";\n    ctx.stroke();\n\n\n    var surface = vts.earcut(flatShape, holesIndices, 3);\n\n    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);\n\n    ctx.beginPath();\n\n    for (i = 0, li = surface.length; i < li; i+=3) {\n        var v1 = surface[i]*3;\n        var v2 = surface[i+1]*3;\n        var v3 = surface[i+2]*3;\n\n        ctx.moveTo(flatShape[v1]*fx+sx,flatShape[v1+1]*fx+sx);\n        ctx.lineTo(flatShape[v2]*fx+sx,flatShape[v2+1]*fx+sx);\n        ctx.lineTo(flatShape[v3]*fx+sx,flatShape[v3+1]*fx+sx);\n        ctx.lineTo(flatShape[v1]*fx+sx,flatShape[v1+1]*fx+sx);\n    }\n\n    ctx.strokeStyle = \"#0000ff\";\n    ctx.stroke();\n\n    return this;\n};\n*/\n\n//same as addPolygon3 but with Delaunator sudivision\n/*\nMapGeodataBuilder.prototype.addPolygon4 = function(shape, holes, middle, heightMode, properties, id, srs) {\n    srs = srs ? srs : this.navSrs.srsProj4;\n    holes = holes || [];\n    holes = [];\n\n    var flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords = [], coords2 = [], proj, holesIndices, vertices;\n    var projected = true, dx, dy, dz, dd, maxDistance = 0, maxDistanceCoords, flatCenter, trueHolesCount = holes.length;\n    var density = 20;\n\n    //convert shape and holes to flat space\n    if (srs.indexOf('+proj=longlat') != -1) {\n        projected = false;\n        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');\n    }\n\n    var totalPoints = shape.length*3;\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        shape[i][2] = shape[i][2] || 0; //add third coord\n    }\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        totalPoints += hole.length*3;\n\n        for (j = 0, lj = hole.length; j < lj; j++) {\n            hole[j][2] = hole[j][2] || 0; //add third coord\n        }\n    }\n\n    var center = this.getPolygonCenter(shape, projected, proj), north, east, dir, geod;\n\n    var ned = this.map.measure.getNewNED(center);\n\n   // dir = ned.direction;\n    north = ned.direction;\n    east = ned.east;\n\n     geod = this.map.measure.getGeodesic(); \n\n    flatShape = new Array(totalPoints);\n    vertices = new Array(totalPoints);\n    j = 0;\n\n    var borders = new Array(holes.length + 1);\n    var border = new Array(shape.length);\n    borders[0] = border;\n\n\n    var gcenter;\n\n    if (proj) {\n        gcenter = proj.forward(center);\n    } else {\n        gcenter = center;\n    }\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        border[i] = i;\n        coords = shape[i];\n        vertices[j] = coords[0]; \n        vertices[j+1] = coords[1]; \n        vertices[j+2] = coords[2];\n\n        if (proj) {\n            coords2 = proj.forward(shape[i]);\n            coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],\n                      north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];\n        } else {\n            coords2 = shape[i];\n            coords = coords2;\n        }\n\n        dx = coords2[0] - gcenter[0];\n        dy = coords2[1] - gcenter[1];\n        dz = coords2[2] - gcenter[2];\n        dd = dx * dx + dy * dy + dz*dz;\n        if (dd > maxDistance) {\n            maxDistance = dd;\n            maxDistanceCoords = shape[i]\n        }\n\n        flatShape[j] = coords[0]; \n        flatShape[j+1] = coords[1]; \n        flatShape[j+2] = coords[2]; \n        j+=3;\n    }\n\n    maxDistance = Math.sqrt(maxDistance);\n\n    var inPoints = new Array(density * density * 3);\n    var inPointsFlat = new Array(density * density * 3);\n    var inPointsIndex = 0;\n    var inPointsFlatIndex = 0;\n\n    if (proj) {\n\n        if (!projected) {\n            //maxDistanceCoords = proj.inverse(maxDistanceCoords); maxDistanceCoords[2] = 0;\n            maxDistance = this.map.measure.getDistance(center, maxDistanceCoords, false)[0];\n        }\n        \n        density = Math.round(density * 0.5);\n\n        var r, ncoords, ecoords, lastJ = j;\n        var geod = this.map.measure.getGeodesic();\n        \n        for (i = -density; i < density; i++) {\n            r = geod.Direct(center[1], center[0], 0, (maxDistance / (density)) * i);\n            ncoords = [r.lon2, r.lat2];\n\n            for (j = -density; j < density; j++) {\n                r = geod.Direct(ncoords[1], ncoords[0], 90, (maxDistance / (density)) * j);\n\n                ecoords = [r.lon2, r.lat2, 0];\n                coords2 = proj.forward(ecoords);\n                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],\n                          north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];\n               \n                if (this.insidePolygon(coords, flatShape, shape.length)) {\n                    //this.addPoint(ecoords.slice(), 'fix', {}, 'bbb', srs);\n                    //holes.push([ecoords]);\n\n                    inPoints[inPointsIndex] = ecoords[0];\n                    inPoints[inPointsIndex+1] = ecoords[1];\n                    inPoints[inPointsIndex+2] = ecoords[2];\n                    inPointsIndex += 3;\n\n                    inPointsFlat[inPointsFlatIndex] = coords[0];\n                    inPointsFlat[inPointsFlatIndex+1] = coords[1];\n                    inPointsFlat[inPointsFlatIndex+2] = coords[2];\n                    inPointsFlatIndex += 3;\n\n                } else {\n                    //this.addPoint(ecoords.slice(), 'fix', {}, 'aaa', srs);\n                }\n            }\n        }\n\n        j = lastJ; \n\n        inPoints = inPoints.slice(0, inPointsIndex);\n        inPointsFlat = inPointsFlat.slice(0, inPointsFlatIndex);\n\n        vertices = vertices.concat(inPoints);\n        flatShape = flatShape.concat(inPointsFlat);\n\n    }\n\n    if (false) {\n        flatHoles = new Array(holes.length);\n        holesIndices = new Array(holes.length);\n\n        for (i = 0, li = holes.length; i < li; i++) {\n            hole = holes[i];\n            holesIndices[i] = Math.round(j/3);\n\n            if (i < trueHolesCount) {\n                border = new Array(hole.length);\n                borders[i + 1] = border;\n            }\n\n            l = Math.floor(j /3);\n\n            for (k = 0, lk = hole.length; k < lk; k++) {\n                coords = hole[k];\n                vertices[j] = coords[0]; \n                vertices[j+1] = coords[1]; \n                vertices[j+2] = coords[2]; \n\n                if (proj) {\n                    coords2 = proj.forward(hole[k]);\n                    coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],\n                              north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];\n                } else {\n                    coords = hole[k];\n                }\n\n                flatShape[j] = coords[0]; \n                flatShape[j+1] = coords[1]; \n                flatShape[j+2] = coords[2]; \n                j+=3;\n\n                if (i < trueHolesCount) {\n                    border[k] = l++;\n                }\n            }\n        }\n    }\n\n    var flatShape2 = new Array((flatShape.length / 3) *2);\n\n    for (i = 0, j =0, li = flatShape.length; i < li; i+=3, j+=2) {\n        flatShape2[j] = flatShape[i];\n        flatShape2[j+1] = flatShape[i+1];\n    }\n\n    var delaunay = new Delaunator(flatShape2);\n\n    var surface2 = delaunay.triangles;\n    var smax = 30;//vertices.length / 3;\n\n    var surface = new Array(surface2.length);\n\n    j = 0;\n\n    for (i = 0, li = surface.length; i < li; i+=3) {\n        var v1 = surface2[i]*2;\n        var v2 = surface2[i+1]*2;\n        var v3 = surface2[i+2]*2;\n\n        var mid = [(flatShape2[v1]+flatShape2[v2]+flatShape2[v3])/3,\n                   (flatShape2[v1+1]+flatShape2[v2+1]+flatShape2[v3+1])/3,0];\n\n        if (this.insidePolygon(mid, flatShape, shape.length)) {\n            surface[j] = surface2[i+2];\n            surface[j+1] = surface2[i+1];\n            surface[j+2] = surface2[i];\n            j+=3;\n        }\n    }\n\n    surface = surface.slice(0,j);\n\n    //var surface = vts.earcut(flatShape, holesIndices, 3);\n    //var surface = vts.earcut(flatShape2, holesIndices, 2);\n\n    var c = document.getElementById(\"dbg-canvas\");\n    var ctx = c.getContext(\"2d\");\n    var sx = 300;\n    var fx = 300 / 7500000; fx*=30;\n\n\n    ctx.beginPath();\n\n    for (i = 0, li = surface2.length; i < li; i+=3) {\n        var v1 = surface2[i]*2;\n        var v2 = surface2[i+1]*2;\n        var v3 = surface2[i+2]*2;\n\n        ctx.moveTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);\n        ctx.lineTo(flatShape2[v2]*fx+sx,flatShape2[v2+1]*fx+sx);\n        ctx.lineTo(flatShape2[v3]*fx+sx,flatShape2[v3+1]*fx+sx);\n        ctx.lineTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);\n    }\n\n    ctx.strokeStyle = \"#0000ff\";\n    ctx.stroke();\n\n\n    ctx.beginPath();\n\n    for (i = 0, li = surface.length; i < li; i+=3) {\n        var v1 = surface[i]*2;\n        var v2 = surface[i+1]*2;\n        var v3 = surface[i+2]*2;\n\n        ctx.moveTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);\n        ctx.lineTo(flatShape2[v2]*fx+sx,flatShape2[v2+1]*fx+sx);\n        ctx.lineTo(flatShape2[v3]*fx+sx,flatShape2[v3+1]*fx+sx);\n        ctx.lineTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);\n    }\n\n    ctx.strokeStyle = \"#ff00ff\";\n    ctx.stroke();\n\n    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);\n\n    return this;\n};*/\n\n//same as addPolygon but works on poles and is subivided\nMapGeodataBuilder.prototype.addPolygon3 = function(shape, holes, middle, heightMode, properties, id, srs, tesselation) {\n    srs = srs ? srs : this.navSrs.srsProj4;\n    holes = holes || [];\n\n    var flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords = [], coords2 = [], proj, holesIndices, vertices;\n    var projected = true, dx, dy, dz, dd, maxDistance = 0, maxDistanceCoords, flatCenter, trueHolesCount = holes.length;\n\n    tesselation = tesselation || {};\n    tesselation.mode = tesselation['mode'] || 'auto';\n\n    if (tesselation.mode == 'by-length') {\n        tesselation.length = tesselation['length'] || 200000;\n    }\n\n    var density = 19;\n\n    //convert shape and holes to flat space\n    if (srs.indexOf('+proj=longlat') != -1) {\n        projected = false;\n        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');\n        //proj = this.map.proj4(srs, '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');\n    }\n\n    var totalPoints = shape.length*3;\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        shape[i][2] = shape[i][2] || 0; //add third coord\n    }\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        totalPoints += hole.length*3;\n\n        for (j = 0, lj = hole.length; j < lj; j++) {\n            hole[j][2] = hole[j][2] || 0; //add third coord\n        }\n    }\n\n    var center = this.getPolygonCenter(shape, projected, proj), north, east, dir, geod;\n\n    var ned = this.map.measure.getNewNED(center);\n\n    dir = ned.direction;\n    north = ned.direction;\n    east = ned.east;\n\n    flatShape = new Array(totalPoints);\n    vertices = new Array(totalPoints);\n    j = 0;\n\n    var borders = new Array(holes.length + 1);\n    var border = new Array(shape.length);\n    borders[0] = border;\n\n    var gcenter;\n\n    if (proj) {\n        gcenter = proj.forward(center);\n    } else {\n        gcenter = center;\n    }\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        border[i] = i;\n        coords = shape[i];\n        vertices[j] = coords[0]; \n        vertices[j+1] = coords[1]; \n        vertices[j+2] = coords[2];\n\n        if (proj) {\n            coords2 = proj.forward(shape[i]);\n            coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],\n                      north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];\n        } else {\n            coords2 = shape[i];\n            coords = coords2;\n        }\n\n        dx = coords2[0] - gcenter[0];\n        dy = coords2[1] - gcenter[1];\n        dz = coords2[2] - gcenter[2];\n        dd = dx * dx + dy * dy + dz*dz;\n        if (dd > maxDistance) {\n            maxDistance = dd;\n            maxDistanceCoords = shape[i]\n        }\n\n        flatShape[j] = coords[0]; \n        flatShape[j+1] = coords[1]; \n        flatShape[j+2] = coords[2]; \n        j+=3;\n    }\n\n    //check curve orientation (have to be clockwise)\n    var angle = 0, x1, y1, x2, y2, index;\n    for (i = 0, li = shape.length * 3; i < li; i+=3) {\n        x1 = flatShape[i]; \n        y1 = flatShape[i+1]; \n\n        if (i < li - 3) {\n            x2 = flatShape[i+3]; \n            y2 = flatShape[i+4]; \n        } else {\n            x2 = flatShape[0]; \n            y2 = flatShape[1]; \n        }\n\n        //angle += (x2 - x1) * (y2 + y1);\n        angle += (x1 * y2);\n        angle -= (x2 * y1);\n    }    \n    \n    if (angle < 0) { //convert to clokwise\n        var vertices2 = vertices.slice();\n        var flatShape2 = flatShape.slice();\n\n        for (i = 0, li = shape.length * 3; i < li; i+=3) {\n            vertices[i] = vertices2[li - i - 3];\n            vertices[i+1] = vertices2[li - i - 2];\n            vertices[i+2] = vertices2[li - i - 1];\n\n            flatShape[i] = flatShape2[li - i - 3];\n            flatShape[i+1] = flatShape2[li - i - 2];\n            flatShape[i+2] = flatShape2[li - i - 1];\n        }\n    }\n\n\n    flatHoles = new Array(holes.length);\n    holesIndices = new Array(holes.length);\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        index = Math.round(j/3);\n        holesIndices[i] = index;\n\n        if (i < trueHolesCount) {\n            border = new Array(hole.length);\n            borders[i + 1] = border;\n        }\n\n        l = index;\n\n        for (k = 0, lk = hole.length; k < lk; k++) {\n            coords = hole[k];\n            vertices[j] = coords[0]; \n            vertices[j+1] = coords[1]; \n            vertices[j+2] = coords[2]; \n\n            if (proj) {\n                coords2 = proj.forward(hole[k]);\n                //cords = [coords2[0], coords2[1], 0];\n                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],\n                          dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];\n            } else {\n                coords = hole[k];\n            }\n\n            flatShape[j] = coords[0]; \n            flatShape[j+1] = coords[1]; \n            flatShape[j+2] = coords[2]; \n            j+=3;\n\n            if (i < trueHolesCount) {\n                border[k] = l;\n                l++;\n            }\n        }\n\n        //check curve orientation (have to be clockwise)\n        angle = 0;\n        index *= 3;\n        for (k = 0, lk = hole.length * 3; k < lk; k+=3) {\n            x1 = flatShape[index + k]; \n            y1 = flatShape[index + k+1]; \n\n            if (k < lk - 3) {\n                x2 = flatShape[index + k+3]; \n                y2 = flatShape[index + k+4]; \n            } else {\n                x2 = flatShape[index + 0]; \n                y2 = flatShape[index + 1]; \n            }\n\n            //angle += (x2 - x1) * (y2 + y1);\n            angle += (x1 * y2);\n            angle -= (x2 * y1);\n        }    \n        \n        if (angle > 0) { //convert to clokwise\n            var vertices2 = vertices.slice();\n            var flatShape2 = flatShape.slice();\n\n            for (k = 0, lk = hole.length * 3; k < lk; k+=3) {\n                vertices[index + k] = vertices2[index + lk - k - 3];\n                vertices[index + k+1] = vertices2[index + lk - k - 2];\n                vertices[index + k+2] = vertices2[index + lk - k - 1];\n\n                flatShape[index + k] = flatShape2[index + lk - k - 3];\n                flatShape[index + k+1] = flatShape2[index + lk - k - 2];\n                flatShape[index + k+2] = flatShape2[index + lk - k - 1];\n            }\n        }\n\n    }\n\n    var surface = vts.earcut(flatShape, holesIndices, 3);\n\n    var maxFaceLength = Number.POSITIVE_INFINITY;\n\n    switch (tesselation.mode) {\n        case 'auto':      maxFaceLength = Math.sqrt(maxDistance) / density; break;\n        case 'by-length': maxFaceLength = tesselation.length; break;\n    }\n\n    var v1, v2, v3, p1, p2, p3, p4, p5, p6;\n\n    //copy bordes\n    var borders2 = new Array(borders.length), border2; \n    for (i = 0, li = borders.length; i < li; i++) {\n        borders2[i] = borders[i].slice();\n    }\n\n    var sbuffer = new Array(65536*3);\n    var sbuffer2 = new Array(65536*3);\n    var sbuffer3 = new Array(65536*3);\n\n    var sbufferIndex = 0, l1, l2, l3, vv1, vv2, vv3;\n    var sbufferIndex2 = 0;//, i1, i2, i3;\n    var sbufferIndex3 = 0;\n\n    var vbuffer = new Array(65536*3);\n\n    //copy vertices\n    for (i = 0, li = vertices.length; i < li; i +=3) { \n        vbuffer[i] = vertices[i];\n        vbuffer[i+1] = vertices[i+1];\n        vbuffer[i+2] = vertices[i+2];\n    }\n\n    var m = Math.round(li / 3);\n\n\n    var lastMaxFaceLength = maxFaceLength;\n\n    for (i = 0, li = surface.length; i < li; i +=3) { \n\n        v1 = surface[i];\n        v2 = surface[i+1];\n        v3 = surface[i+2];\n        sbufferIndex = 3;\n\n        //find face edges in borders\n        var edge1 = null, edge2 = null, edge3 = null;\n        //var edge1, edge2, edge3;\n        for (j = 0, lj = borders.length; j < lj; j++) { \n            border = borders[j];\n            border2 = borders2[j];\n\n            for (k = 0, lk = border.length; k < lk; k++) {\n                var k2 = (k < border.length - 1) ? k + 1 : 0;\n\n                if ((v1 == border[k] && v2 == border[k2]) || (v1 == border[k2] && v2 == border[k])) {\n                    border2[k] = [border[k]];\n                    edge1 = border2[k];\n                }\n\n                if ((v2 == border[k] && v3 == border[k2]) || (v2 == border[k2] && v3 == border[k])) {\n                    border2[k] = [border[k]];\n                    edge2 = border2[k];\n                }\n\n                if ((v3 == border[k] && v1 == border[k2]) || (v1 == border[k2] && v3 == border[k])) {\n                    border2[k] = [border[k]];\n                    edge3 = border2[k];\n                }\n            }\n        }\n\n        sbuffer[0] = [v1, edge1];\n        sbuffer[1] = [v2, edge2];\n        sbuffer[2] = [v3, edge3];\n\n        var depth = 0, r;\n\n        //loop until subdivision is finished\n        do {\n\n            for (j = 0, lj = sbufferIndex; j < lj; j+=3) {\n                //face indices//\n                vv1 = sbuffer[j][0];\n                vv2 = sbuffer[j+1][0];\n                vv3 = sbuffer[j+2][0];\n                //face edges\n                edge1 = sbuffer[j][1];\n                edge2 = sbuffer[j+1][1];\n                edge3 = sbuffer[j+2][1];\n\n                /*console.log('v1: ' + vv1 + ' v2:' + vv2 + ' v3:' + vv3);\n                console.log('e1: ' + (Array.isArray(edge1) ? 'a' : '') + edge1 + ' e2:' + (Array.isArray(edge2) ? 'a' : '') + edge2 + ' e3:' + (Array.isArray(edge3) ? 'a' : '') + edge3);\n                */\n\n                //get face vertices\n                p1 = [vbuffer[vv1*3], vbuffer[vv1*3+1], vbuffer[vv1*3+2]];\n                p2 = [vbuffer[vv2*3], vbuffer[vv2*3+1], vbuffer[vv2*3+2]];\n                p3 = [vbuffer[vv3*3], vbuffer[vv3*3+1], vbuffer[vv3*3+2]];\n\n                //covert coords to geocent\n                if (proj) {\n                    p1 = proj.forward(p1);\n                    p2 = proj.forward(p2);\n                    p3 = proj.forward(p3);\n                }\n\n                //get face edges lengths\n                l1 = vec3.length([p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]]);\n                l2 = vec3.length([p2[0] - p3[0], p2[1] - p3[1], p2[2] - p3[2]]);\n                l3 = vec3.length([p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]]);\n\n                //get max length\n                l = Math.max(l1,l2,l3);\n\n                //console.log('ll:' + l);\n\n                //is length below threshold\n                if (l < maxFaceLength) {  \n                    //add to final buffer\n                    sbuffer3[sbufferIndex3] = vv1;\n                    sbuffer3[sbufferIndex3+1] = vv2;\n                    sbuffer3[sbufferIndex3+2] = vv3;\n                    sbufferIndex3 += 3;\n                } else {\n\n                    //crete new vertices in the midle of edges and convert coords back to long lat\n                    //if (l1 > 200000 && !projected) {\n                     //   r = geod.Inverse(vbuffer[vv1*3+1], vbuffer[vv1*3], vbuffer[vv2*3+1], vbuffer[vv2*3]);\n                     //   r = geod.Direct(vbuffer[vv1*3+1], vbuffer[vv1*3], r.azi1, r.s12 *0.5);\n                    //    p4 = [r.lon2, r.lat2, (vbuffer[vv1*3+2]+vbuffer[vv2*3+2])*0.5];\n                    //} else {\n                        p4 = [(p1[0]+p2[0])*0.5, (p1[1]+p2[1])*0.5, (p1[2]+p2[2])*0.5];\n                    if (proj) {\n                        p4 = proj.inverse(p4); p4[2] = (vbuffer[vv1 * 3 + 2] + vbuffer[vv2 * 3 + 2]) * 0.5;\n                    }\n                    //}\n\n                    //if (l2 > 200000 && !projected) {\n                     //   r = geod.Inverse(vbuffer[vv2*3+1], vbuffer[vv2*3], vbuffer[vv3*3+1], vbuffer[vv3*3]);\n                     //   r = geod.Direct(vbuffer[vv2*3+1], vbuffer[vv2*3], r.azi1, r.s12 *0.5);\n                     //   p5 = [r.lon2, r.lat2, (vbuffer[vv2*3+2]+vbuffer[vv3*3+2])*0.5];\n                    //} else {\n                        p5 = [(p2[0]+p3[0])*0.5, (p2[1]+p3[1])*0.5, (p2[2]+p3[2])*0.5];\n                    if (proj) {\n                        p5 = proj.inverse(p5); p5[2] = (vbuffer[vv2 * 3 + 2] + vbuffer[vv3 * 3 + 2]) * 0.5;\n                    }\n                    //}\n\n                    //if (l3 > 200000 && !projected) {\n                     //   r = geod.Inverse(vbuffer[vv3*3+1], vbuffer[vv3*3], vbuffer[vv1*3+1], vbuffer[vv1*3]);\n                     //   r = geod.Direct(vbuffer[vv3*3+1], vbuffer[vv3*3], r.azi1, r.s12 *0.5);\n                     //   p6 = [r.lon2, r.lat2, (vbuffer[vv3*3+2]+vbuffer[vv1*3+2])*0.5];\n                    //} else {\n                        p6 = [(p3[0]+p1[0])*0.5, (p3[1]+p1[1])*0.5, (p3[2]+p1[2])*0.5];\n                    if (proj) {\n                        p6 = proj.inverse(p6); p6[2] = (vbuffer[vv3 * 3 + 2] + vbuffer[vv1 * 3 + 2]) * 0.5;\n                    }\n                    //}\n\n                    var mm = m * 3;\n\n                    if (l1 == l) {\n                        //console.log('l1');\n\n                        //add new vertices to the buffer\n                        vbuffer[mm] = p4[0];\n                        vbuffer[mm+1] = p4[1];\n                        vbuffer[mm+2] = p4[2];\n\n                        //create new edges\n                        if (edge1) {\n                            edge1[0] = [[edge1[0]], [-m]];\n                            edge1 = edge1[0];\n                        }\n\n                        l = sbufferIndex2;\n\n                        //store new faces with edges\n                        sbuffer2[l] = [vv1, edge1 ? edge1[0] : null];\n                        sbuffer2[l+1] = [m, null];\n                        sbuffer2[l+2] = [vv3, edge3 ? edge3 : null];\n                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);\n                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + \n                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +\n                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/\n\n\n                        sbuffer2[l+3] = [m, edge1 ? edge1[1] : null];\n                        sbuffer2[l+4] = [vv2, edge2 ? edge2 : null];\n                        sbuffer2[l+5] = [vv3, null];\n                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);\n                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + \n                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +\n                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/\n\n                    } else if (l2 == l) {\n                        //console.log('l2');\n\n                        //add new vertices to the buffer\n                        vbuffer[mm] = p5[0];\n                        vbuffer[mm+1] = p5[1];\n                        vbuffer[mm+2] = p5[2];\n\n                        //create new edges\n                        if (edge2) {\n                            edge2[0] = [[edge2[0]], [-m]];\n                            edge2 = edge2[0];\n                        }\n\n                        l = sbufferIndex2;\n\n                        //store new faces with edges\n                        sbuffer2[l] = [vv1, edge1 ? edge1 : null];\n                        sbuffer2[l+1] = [vv2, edge2 ? edge2[0] : null];\n                        sbuffer2[l+2] = [m, null];\n                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);\n                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + \n                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +\n                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/\n\n                        sbuffer2[l+3] = [m, edge2 ? edge2[1] : null];\n                        sbuffer2[l+4] = [vv3, edge3 ? edge3 : null];\n                        sbuffer2[l+5] = [vv1, null];\n                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);\n                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + \n                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +\n                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/\n\n                    } else if (l3 == l) {\n                        //console.log('l3');\n\n                        //add new vertices to the buffer\n                        vbuffer[mm] = p6[0];\n                        vbuffer[mm+1] = p6[1];\n                        vbuffer[mm+2] = p6[2];\n\n                        //create new edges\n                        if (edge3) {\n                            edge3[0] = [[edge3[0]], [-m]];\n                            edge3 = edge3[0];\n                        }\n\n                        l = sbufferIndex2;\n\n                        //store new faces with edges\n                        sbuffer2[l] = [vv1, edge1 ? edge1 : null];\n                        sbuffer2[l+1] = [vv2, null];\n                        sbuffer2[l+2] = [m, edge3 ? edge3[1] : null];\n                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);\n                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + \n                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +\n                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/\n\n                        sbuffer2[l+3] = [m, null]; \n                        sbuffer2[l+4] =  [vv2, edge2 ? edge2 : null]; \n                        sbuffer2[l+5] = [vv3, edge3 ? edge3[0] : null];\n                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);\n                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + \n                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +\n                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/\n\n                    }\n\n                    m += 1;\n                    sbufferIndex2 += 6;\n                }\n            }\n\n            var tmp = sbuffer;\n            sbuffer = sbuffer2;\n            sbuffer2 = tmp;\n            sbufferIndex = sbufferIndex2;\n            sbufferIndex2 = 0;\n\n            //if (sbufferIndex3 > 1000) {\n                //break;\n            //}\n\n            depth++;\n\n            //if (depth == 1) {\n              //  maxFaceLength = Number.POSITIVE_INFINITY;\n            //}\n\n\n        } while(sbufferIndex > 0);\n\n        maxFaceLength = lastMaxFaceLength;\n\n    }\n\n    var ebuffer = new Array(65536*3), ebufferIndex = 0;\n\n    var unrollBorder = (function(borderArray) {\n        for (var o = 0, lo = borderArray.length; o < lo; o++) {\n            if (Array.isArray(borderArray[o])) {\n                unrollBorder(borderArray[o]);\n            } else {\n                ebuffer[ebufferIndex] = borderArray[o];\n                ebufferIndex++;\n            }\n        }\n    });\n\n    var lastEbufferIndex = 0;\n\n    //unroll edges\n    for (i = 0, li = borders2.length; i < li; i++) {\n        unrollBorder(borders2[i]);\n        borders2[i] = ebuffer.slice(lastEbufferIndex, ebufferIndex);\n        lastEbufferIndex = ebufferIndex;\n    }\n\n    surface = new Array(sbufferIndex);\n\n    for (i = 0, li = sbufferIndex3; i < li; i+=3) {\n        surface[i] = sbuffer3[i];\n        surface[i+1] = sbuffer3[i+1];\n        surface[i+2] = sbuffer3[i+2];\n    }\n\n    vertices = new Array(m * 3);\n    j = 0;\n\n    for (i = 0, li = m*3; i < li; i+=3) {\n        vertices[i] = vbuffer[i];\n        vertices[i+1] = vbuffer[i+1];\n        vertices[i+2] = vbuffer[i+2];\n        //this.addPoint([vertices[i], vertices[i+1], vertices[i+2]], 'fix', {name:(''+j)}, 'aaa');\n        j++;\n    }\n\n    this.addPolygonRAW(vertices, surface, borders2, middle, heightMode, properties, id, srs);\n};\n\n\nMapGeodataBuilder.prototype.addPolygonRAW = function(vertices, surface, borders, middle, heightMode, properties, id, srs, directCopy, transform) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\");\n    var i, li, j = 0, coords;\n    srs = srs ? srs : this.navSrs;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    var featureVertices = new Array(Math.round(vertices.length/3));\n\n    if (floatHeight) {\n        for (i = 0, li = vertices.length; i < li; i+=3) {\n            coords = [vertices[i], vertices[i+1], vertices[i+2], feature, null, null];\n            this.addToHeightsBuffer(coords);\n            featureVertices[j++] = coords;\n        }\n\n        feature.floatHeights = true;\n        feature.srs = srs;\n        feature.heightsToProcess = featureVertices.length;\n        this.heightsToProcess += featureVertices.length;\n    } else {\n\n        for (i = 0, li = vertices.length; i < li; i+=3) {\n\n            if (directCopy) {\n                if (transform) {\n                    featureVertices[j++] = [vertices[i]*transform.sx+transform.px, vertices[i+1]*transform.sy+transform.py, vertices[i+2]*transform.sz+transform.pz];\n                } else {\n                    featureVertices[j++] = [vertices[i], vertices[i+1], vertices[i+2]];\n                }\n            } else {\n                featureVertices[j++] = this.physSrs.convertCoordsFrom(coords, srs);\n            }\n        }\n    }\n\n    var featureSurface = surface.slice();\n    var featureBorders = new Array(borders.length);\n\n    for (i = 0, li = borders.length; i < li; i++) {\n        featureBorders[i] = borders[i].slice();\n    }\n\n    feature.vertices = featureVertices;\n    feature.surface = featureSurface;\n    feature.borders = featureBorders;\n    this.currentGroup.polygons.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.importVTSGeodata = function(json, groupIdPrefix, dontCreateGroups) {\n    var importer = new MapGeodataImportVTSGeodata(this, groupIdPrefix, dontCreateGroups);\n    return importer.processJSON(json);\n};\n\n\nMapGeodataBuilder.prototype.importGeoJson = function(json, heightMode, srs, options) {\n    var importer = new MapGeodataImportGeoJSON(this, heightMode, srs, options);\n    return importer.processJSON(json);\n};\n\n\nMapGeodataBuilder.prototype.import3DTiles = function(json, options) {\n    var importer = new MapGeodataImport3DTiles(this, options);\n    return importer.processJSON(json);\n};\n\n\nMapGeodataBuilder.prototype.load3DTiles = function(path, options, onLoaded) {\n    var importer = new MapGeodataImport3DTiles(this, options);\n    importer.loadJSON(path, options, onLoaded);\n};\n\n\nMapGeodataBuilder.prototype.load3DTiles2 = function(path, options, onLoaded) {\n    this.binPath = path;\n    if (onMapLoaded) {\n        onMapLoaded();\n    }\n};\n\n\nMapGeodataBuilder.prototype.processHeights = function(heightsSource, precision, onProcessed) {\n    if (this.heightsToProcess <= 0) {\n        if (onProcessed) {\n            onProcessed(this);\n        }\n\n        return;\n    }\n\n    if (this.processingHeights) {\n        this.processHeightsCalls.push(this.processHeights.bind(this, heightsSource, precision));\n    }\n\n    this.processingHeights = true;\n    this.heightsSource = heightsSource;\n    this.heightsLod = precision;\n\n    var item = this.heightsProcessBufferFirst, lastItem;\n    //var item = this.heightsProcessBuffer, lastItem;\n    var p, res, nodeOnly, heightsLod, nodeOnly, coords, noSource;\n\n    if (item) {\n\n        switch (heightsSource) {\n            case \"node-by-precision\":\n                nodeOnly = true;\n            case \"heightmap-by-precision\":\n\n                coords = item.coords;\n\n                if (coords[3].srs) {\n                    p = this.navSrs.convertCoordsFrom(coords, coords[3].srs);\n                } else {\n                    p = coords;\n                }\n\n                heightsLod = this.map.measure.getOptimalHeightLodBySampleSize(p, precision);\n                break;\n\n            case \"node-by-lod\":\n                nodeOnly = true;\n                precision -= 8;\n            case \"heightmap-by-lod\":\n                heightsLod = precision;\n                break;\n            case \"none\":\n                noSource = true;\n                break;\n        }\n\n        do {\n            coords = item.coords;\n\n            if (!noSource && coords[4] == null) {\n                if (coords[3].srs) {\n                    p = this.navSrs.convertCoordsFrom(coords, coords[3].srs);\n                } else {\n                    p = coords;\n                }\n\n                res = this.map.measure.getSpatialDivisionNode(p);\n\n                coords[4] = res[0];\n                coords[5] = res[1];\n\n                //coords[4] = p;\n            }\n\n\n            if (noSource) {\n                res = [0,true,true];\n            } else {\n                res = this.map.measure.getSurfaceHeight(coords, heightsLod, null, coords[4], coords[5], null, nodeOnly);\n            }\n\n            //res = this.map.measure.getSurfaceHeight(coords[4], heightsLod, null, null, null, null, nodeOnly);\n\n            //console.log(JSON.stringify(res));\n\n            //if (res[1] || res[2]) { //precisin reached or not aviable\n                //res = this.map.measure.getSurfaceHeight(coords[4], heightsLod, null, null, null, null, nodeOnly);\n                //res = this.map.measure.getSurfaceHeight(coords, heightsLod, null, coords[4], coords[5], null, nodeOnly);\n            //}\n\n            if (res[1] || res[2]) { //precision reached or not aviable\n\n                //console.log(JSON.stringify(res));\n\n                coords[2] += res[0]; //convet float height to fixed\n                this.removeFromHeightsBuffer(item, lastItem);\n                coords[3].heightsToProcess--;\n                this.heightsToProcess--;\n\n                if (coords[3].heightsToProcess <= 0) { //this prevents multiple conversions\n                    coords[3].floatHeights = false;\n                }\n\n                p = [coords[0], coords[1], coords[2]];\n\n                //console.log(JSON.stringify(p) + \"  srs  \" + coords[3].srs);\n\n                p = this.physSrs.convertCoordsFrom(p, coords[3].srs);\n\n                coords[0] = p[0];\n                coords[1] = p[1];\n                coords[2] = p[2];\n            }\n\n            lastItem = item;\n            item = item.next;\n\n        } while(item);\n    }\n\n    if (this.heightsToProcess <= 0) {\n        if (this.updateCallback) {\n            this.updateCallback(); //remove callback\n        }\n\n        this.processingHeights = false;\n\n        if (onProcessed) {\n            onProcessed(this);\n        }\n\n        if (this.processHeightsCalls.length > 1) {\n            (this.processHeightsCalls.shift())();\n        }\n\n    } else {\n        if (!this.updateCallback) {\n            this.updateCallback = this.map.core.on(\"map-update\", this.processHeights.bind(this, this.heightsSource, this.heightsLod, onProcessed));\n        }\n    }\n\n};\n\nMapGeodataBuilder.prototype.extractGeometry = function(id) {\n    var feature, i, li, j, lj, points, lines,\n        vertexBuffer, indexBuffer, index, p;\n\n\n    for (var i = 0, li = this.groups.length; i < li; i++) {\n        var group = this.groups[i];\n\n        var groupPoints = group.points;\n        var groupLines = group.lines;\n        var groupPolygons = group.polygons, j, lj;\n\n        //get group bbox\n        for (j = 0, lj = groupPoints.length; j < lj; j++) {\n            if (groupPoints[j].id == id) {\n                feature = groupPoints[j];\n            }\n        }\n\n        for (j = 0, lj = groupLines.length; j < lj; j++) {\n            if (groupLines[j].id == id) {\n                feature = groupLines[j];\n            }\n        }\n\n        for (j = 0, lj = groupPolygons.length; j < lj; j++) {\n            if (groupPolygons[j].id == id) {\n                feature = groupPolygons[j];\n            }\n        }\n    }\n\n    if (feature) {\n        if (feature.points) {\n\n            points = feature.points;\n\n            if (points.length > 0) {\n                vertexBuffer = new Float64Array(points.length * 3);\n\n                for (i = 0, li = points.length; i < li; i++) {\n                    index = i * 3;\n                    p = points[i];\n                    vertexBuffer[index] = p[0];\n                    vertexBuffer[index+1] = p[1];\n                    vertexBuffer[index+2] = p[2];\n                }\n            }\n\n            return new MapGeodataGeometry(this.map, {'type': 'point-geometry', 'id':feature.id, 'geometryBuffer': vertexBuffer });\n\n        } else if (feature.lines) {\n\n            lines = feature.lines;\n\n            if (lines.length > 0) {\n                \n                var totalPoints = 0;\n\n                for (i = 0, li = lines.length; i < li; i++) {\n                    totalPoints += lines[i].length;\n                }\n\n                vertexBuffer = new Float64Array(totalPoints * 3);\n                indexBuffer = new Uint32Array(li);\n                index = 0;\n\n                for (i = 0, li = lines.length; i < li; i++) {\n\n                    var points = lines[i];\n\n                    for (j = 0, lj = points.length; j < lj; j++) {\n                        p = points[j];\n                        vertexBuffer[index] = p[0];\n                        vertexBuffer[index+1] = p[1];\n                        vertexBuffer[index+2] = p[2];\n                        index += 3;\n                    }\n                }\n            }\n\n            return new MapGeodataGeometry(this.map, {'type': 'line-geometry', 'id':feature.id, 'geometryBuffer': vertexBuffer, 'indicesBuffer': indexBuffer });\n        } else if (feature.vertices) {\n\n            /*feature.vertices = featureVertices;\n            feature.surface = featureSurface;\n            feature.borders = featureBorders;*/\n\n            return new MapGeodataGeometry(this.map, {'type': 'polygon-geometry', 'id':feature.id, 'geometryBuffer': feature.vertices, 'surface': feature.surface });\n        }\n\n        return;\n    }\n\n};\n\n\nMapGeodataBuilder.prototype.compileGroup = function(group, resolution) {\n    var bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n    var bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n    var geodataGroup = {};\n    var groupPoints = group.points, points, p, feature, finalFeature;\n    var groupLines = group.lines, lines, line, i, li, j, lj, k, lk;\n    var groupPolygons = group.polygons, borders;\n\n    geodataGroup.id = group.id;\n\n    //get group bbox\n    for (i = 0, li = groupPoints.length; i < li; i++) {\n        points = groupPoints[i].points;\n\n        for (j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n\n            if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }\n            if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }\n            if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }\n\n            if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }\n            if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }\n            if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }\n        }\n    }\n\n    for (i = 0, li = groupLines.length; i < li; i++) {\n        lines = groupLines[i].lines;\n\n        for (j = 0, lj = lines.length; j < lj; j++) {\n            line = lines[j];\n\n            for (k = 0, lk = line.length; k < lk; k++) {\n                p = line[k];\n\n                if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }\n                if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }\n                if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }\n\n                if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }\n                if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }\n                if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }\n            }\n        }\n    }\n\n    for (i = 0, li = groupPolygons.length; i < li; i++) {\n        points = groupPolygons[i].vertices;\n\n        for (j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n\n            if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }\n            if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }\n            if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }\n\n            if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }\n            if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }\n            if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }\n        }\n    }\n\n    if (!resolution) {\n        var maxDelta = Math.max((bboxMax[0] - bboxMin[0]) + 1, (bboxMax[1] - bboxMin[1]) + 1, (bboxMax[2] - bboxMin[2]) + 1);\n\n        //25cm resolution\n        resolution = maxDelta / 0.25;\n        resolution = Math.max(resolution, 1024);\n        resolution = Math.min(resolution, (2<<20));\n    }\n\n    geodataGroup.resolution = resolution;\n\n    //process coords to resolution\n    var bboxScaleFactor = [resolution/((bboxMax[0] - bboxMin[0]) + 1),\n                           resolution/((bboxMax[1] - bboxMin[1]) + 1),\n                           resolution/((bboxMax[2] - bboxMin[2]) + 1)];\n\n    geodataGroup.points = new Array(groupPoints.length);\n\n    for (i = 0, li = groupPoints.length; i < li; i++) {\n        feature = groupPoints[i]; \n        points = feature.points;\n\n        var finalPoints = new Array(points.length);\n\n        for (j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n\n            finalPoints[j] = [ Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]),\n                               Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]),\n                               Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]) ];\n        }\n\n        finalFeature = {\n            points : finalPoints\n        };\n\n        if (feature.id) {\n            finalFeature.id = feature.id;\n        }\n\n        if (feature.properties) {\n            finalFeature.properties = feature.properties;\n        }\n\n        geodataGroup.points[i] = finalFeature;\n    }\n\n    geodataGroup.lines = new Array(groupLines.length);\n\n    for (i = 0, li = groupLines.length; i < li; i++) {\n        feature = groupLines[i]; \n        lines = feature.lines;\n\n        var finalLines = new Array(lines.length);\n\n        for (j = 0, lj = lines.length; j < lj; j++) {\n            line = lines[j];\n\n            finalPoints = new Array(line.length);\n\n            for (k = 0, lk = line.length; k < lk; k++) {\n                p = line[k];\n\n                finalPoints[k] = [ Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]),\n                                   Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]),\n                                   Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]) ];\n            }\n\n            finalLines[j] = finalPoints;\n        }\n\n        finalFeature = {\n            lines : finalLines\n        };\n\n        if (feature.id) {\n            finalFeature.id = feature.id;\n        }\n\n        if (feature.properties) {\n            finalFeature.properties = feature.properties;\n        }\n\n        geodataGroup.lines[i] = finalFeature;\n    }\n\n\n    geodataGroup.polygons = new Array(groupPolygons.length);\n\n    for (i = 0, li = groupPolygons.length; i < li; i++) {\n        feature = groupPolygons[i]; \n        points = feature.vertices;\n\n        var finalVertices = new Array(points.length);\n        k = 0;\n\n        for (j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n            finalVertices[k++] = Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]);\n            finalVertices[k++] = Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]);\n            finalVertices[k++] = Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]);\n        }\n\n        finalFeature = {\n            vertices : finalVertices,\n            surface : feature.surface.slice()\n        };\n\n        borders = feature.borders;\n        var finalBorders = new Array(borders.length);\n\n        for (j = 0, lj = finalBorders.length; j < lj; j++) {\n            finalBorders[j] = borders[j].slice();\n        }\n\n        finalFeature.borders = finalBorders;\n\n        if (feature.id) {\n            finalFeature.id = feature.id;\n        }\n\n        if (feature.properties) {\n            finalFeature.properties = feature.properties;\n        }\n\n        geodataGroup.polygons[i] = finalFeature;\n    }\n\n    geodataGroup.bbox = [ bboxMin, bboxMax ];\n\n    if (bboxMax[0] > this.bboxMax[0]) { this.bboxMax[0] = bboxMax[0]; }\n    if (bboxMax[1] > this.bboxMax[1]) { this.bboxMax[1] = bboxMax[1]; }\n    if (bboxMax[2] > this.bboxMax[2]) { this.bboxMax[2] = bboxMax[2]; }\n\n    if (bboxMin[0] < this.bboxMin[0]) { this.bboxMin[0] = bboxMin[0]; }\n    if (bboxMin[1] < this.bboxMin[1]) { this.bboxMin[1] = bboxMin[1]; }\n    if (bboxMin[2] < this.bboxMin[2]) { this.bboxMin[2] = bboxMin[2]; }\n\n    return geodataGroup;\n};\n\n\nMapGeodataBuilder.prototype.makeGeodata = function(resolution) {\n    this.bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n    this.bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n\n    var geodata = {\n        \"version\" : 1,\n        \"groups\" : [],\n    }\n    \n    if (this.binPath) {\n        geodata[\"binPath\"] = this.binPath;\n    }\n\n    for (var i = 0, li = this.groups.length; i < li; i++) {\n        geodata[\"groups\"].push(this.compileGroup(this.groups[i], resolution));\n    }\n\n    if (this.nodes.length > 0) {\n        geodata.nodes = [];\n        for (i = 0, li = this.nodes.length; i < li; i++) {\n            geodata[\"nodes\"].push(this.nodes[i]);\n        }\n    }\n\n    return geodata;\n};\n\n\nMapGeodataBuilder.prototype.makeFreeLayer = function(style, resolution, geodata) {\n    if (!geodata) {\n        geodata = this.makeGeodata(resolution);\n    }\n\n    if (!style) {\n        style = {\n            \"layers\" : {\n                \"my-lines\" : {\n                    \"filter\" : [\"==\", \"#type\", \"line\"],\n                    \"line\": true,\n                    \"line-width\" : 4,\n                    \"line-color\": [255,0,255,255],\n                    \"zbuffer-offset\" : [-5,0,0]\n                },\n                \"my-points\" : {\n                    \"filter\" : [\"==\", \"#type\", \"point\"],\n                    \"point\": true,\n                    \"point-radius\" : 10,\n                    \"point-color\": [0,0,255,255],\n                    \"zbuffer-offset\" : [-5,0,0]\n                }\n            }\n        }        \n    }\n\n    var freeLayer = {\n            'credits' : [],\n            'displaySize' : 1024,\n            'extents' : {\n                'll' : this.bboxMin,\n                'ur' : this.bboxMax\n            },\n            'geodata' : geodata,\n            'style' : style,\n            'type' : 'geodata'\n        };\n\n    return freeLayer;        \n};\n\nexport default MapGeodataBuilder;\n\n","\nimport {vec3 as vec3_} from '../utils/matrix';\n/*import {math as math_} from '../utils/math';*/\n\n//get rid of compiler mess\nvar vec3 = vec3_;\n/*var math = math_;*/\n\n\nvar MapGeodataGeometry = function(map, data) {\n    this.map = map;\n    this.data = data;\n    this.camera = map.camera;\n    this.renderer = map.renderer;\n\n    switch (data.type) {\n        case 'point-geometry':   \n            this.type = 1;\n            this.vertexBuffer = this.data.geometryBuffer;\n            break;\n        case 'line-geometry':\n            this.type = 2;\n            this.vertexBuffer = this.data.geometryBuffer;\n            this.indicesBuffer = this.data.indicesBuffer;\n            break;\n        case 'polygon-geometry':\n            this.type = 3;\n            this.vertexBuffer = this.data.geometryBuffer;\n            this.surface = this.data.surface;\n            this.borders = this.data.borders;\n            break;\n    }\n};\n\nMapGeodataGeometry.prototype.getType = function() {\n    switch(this.type) {\n        case 1: return 'point';\n        case 2: return 'line';\n        case 3: return 'polygon';\n    }\n};\n\nMapGeodataGeometry.prototype.getElement = function(index) {\n    var v = this.vertexBuffer, i = index * 3;\n    switch(this.type) {\n        case 1: return [v[i], v[i+1], v[i+2]]; //point\n        case 2: return [[v[i], v[i+1], v[i+2]],  [v[i+3], v[i+4], v[i+5]]]; //line\n        case 3: \n            var s = this.surface;\n            var i1 = s[i], i2 = s[i+1], i3 = s[i+2];\n            return [[v[i1][0], v[i1][1], v[i1][2]],  [v[i2][0], v[i2][1], v[i2][2]],  [v[i3][0], v[i3][1], v[i3][2]]]; //polygon\n    }\n};\n\nMapGeodataGeometry.prototype.getElements = function(pathIndex) {\n    switch(this.type) {\n        case 1: //point\n        case 3: return this.surface.length / 3; //polygon\n        case 2:  //line\n            \n            pathIndex = pathIndex || 0;\n            var si = (this.indicesBuffer[pathIndex]) * 3;\n            var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n            return Math.max(0, ((ei - si) / 3) - 1);\n    }\n};\n\nMapGeodataGeometry.prototype.getRelationToCanvasPoint = function(index, screenX, screenY) {\n    var v = this.vertexBuffer, i = index * 3;\n    var c1, cv, p, r = [0,0,0];\n    var a, b, c, d, e, D, sc, tc, u, v, w;\n\n    c1 = this.camera.position;\n    //cv = this.camera.vector;\n\n    cv = this.renderer.getScreenRay(screenX, screenY);\n\n    //console.log(JSON.stringify(c1) + \"  \" + JSON.stringify(cv));\n\n    switch(this.type) {\n        case 1: \n\n            //get point\n            var p = [v[i], v[i+1], v[i+2]];\n\n            var cp = [p[0] - c[0], p[0] - c[0],]\n\n            //distance = vec3.coss(ray.direction, point - ray.origin).magnitude;\n            vec3.cross(cv, cp, r)\n            d = vec3.length(p);\n\n            return {\n                'distance' : d,\n                'point' : p\n            }\n\n        case 2: \n\n            //line points\n            var p1 = [v[i], v[i+1], v[i+2]];\n            var p2 = [v[i+3], v[i+4], v[i+5]]; \n\n            //distance = http://geomalgorithms.com/a07-_distance.html\n\n            u = cv;\n            v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            w = [c1[0] - p1[0], c1[1] - p1[1], c1[2] - p1[2]];\n            a = vec3.dot(u,u);    // always >= 0\n            b = vec3.dot(u,v);\n            c = vec3.dot(v,v);    // always >= 0\n            d = vec3.dot(u,w);\n            e = vec3.dot(v,w);\n            D = a*c - b*b;        // always >= 0\n\n            // compute the line parameters of the two closest points\n            if (D < 0.0000001) {          // the lines are almost parallel\n                sc = 0.0;\n                tc = (b>c ? d/b : e/c);    // use the largest denominator\n            }\n            else {\n                sc = (b*e - c*d) / D;\n                tc = (a*e - b*d) / D;\n            }\n\n            // get the difference of the two closest points\n            var dP = [ w[0] + (u[0] * sc) - (v[0] * tc),\n                       w[1] + (u[1] * sc) - (v[1] * tc),\n                       w[2] + (u[2] * sc) - (v[2] * tc) ];\n\n            return {\n                'closest' : [ p1[0] + (v[0] * tc), p1[1] + (v[1] * tc), p1[2] + (v[2] * tc) ],\n                'line-distance' : vec3.length(dP),\n                'distance' : tc,\n                'line' : [p1, p2]\n            }\n    }\n};\n\nMapGeodataGeometry.prototype.getPathElement = function(index, pathIndex) {\n    if (this.type != 2) {\n        return null;\n    }\n\n    var i = (this.indicesBuffer[pathIndex || 0] + index) * 3, v = this.vertexBuffer;\n    return [[v[i], v[i+1], v[i+2]],  [v[i+3], v[i+4], v[i+5]]];\n};\n\nMapGeodataGeometry.prototype.getPathPoint = function(distance, pathIndex) {\n    pathIndex = pathIndex || 0;\n\n    var si = (this.indicesBuffer[pathIndex]) * 3;\n    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n    var totalLength = 0, delta, length, v = this.vertexBuffer;\n\n    for (var i = si; i < (ei-3); i+=3) {\n        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];\n        length = vec3.length(delta);\n\n        if (totalLength + length > distance) {\n            var factor =  (distance - totalLength) / length;\n            return [v[i] + delta[0] * factor, v[i+1] + delta[1] * factor, v[i+2] + delta[2] * factor];\n        }\n\n        totalLength += length;    \n    }\n\n    return [v[ei-3], v[ei-2], v[ei-1]];\n};\n\nMapGeodataGeometry.prototype.getPathNED = function(distance, withoutSlope, pathIndex) {\n    pathIndex = pathIndex || 0;\n\n    var si = (this.indicesBuffer[pathIndex]) * 3;\n    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n    var totalLength = 0, p, delta, length, v = this.vertexBuffer;\n\n    for (var i = si; i < (ei-5); i+=3) {\n        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];\n        length = vec3.length(delta);\n\n        if (totalLength + length > distance) {\n            var factor = (totalLength + length) / distance;\n            p = [v[i] + d[0] * factor, v[i+1] + d[1] * factor, v[i+2] + d[2] * factor];\n            break;\n        }\n\n        totalLength += length;    \n    }\n\n    if (!p) {\n        p = [v[ei-3], v[ei-2], v[ei-1]];\n    }\n\n    var vv = [0, 0, 0];\n    var nn = [0, 0, 0];\n    var pp = [0, 0, 0];\n\n    vec3.nomalize(delta, vv);\n    vec3.nomalize(p, pp);\n    vec3.cross(pp, vv, nn);    \n\n    if (withoutSlope) {\n        vec3.cross(pp, nn, vv);    \n    }\n\n    var east = nn;\n    var direction = vv;\n    var north = pp;\n\n    return {\n        'east'  : east, \n        'direction' : direction,\n        'north' : north,\n        'position' : p,\n        'matrix' : [\n            east[0], east[1], east[2], 0,\n            north[0], north[1], north[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            0, 0, 0, 1\n        ] \n    };    \n};\n\n\nMapGeodataGeometry.prototype.getPathLengthToElement = function(index, pathIndex) {\n    pathIndex = pathIndex || 0;\n\n    var si = (this.indicesBuffer[pathIndex]) * 3;\n    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n    var totalLength = 0, delta, length, v = this.vertexBuffer, elementIndex = 0;\n\n    for (var i = si; i < (ei-5); i+=3) {\n        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];\n        length = vec3.length(delta);\n\n        if (index == elementIndex) {\n            return {\n                'lengthToElement' : totalLength,\n                'elementLengh' : length\n            }\n        }\n\n        elementIndex++\n        totalLength += length;\n    }\n\n    return totalLength;\n};\n\n\nMapGeodataGeometry.prototype.getPathLength = function(pathIndex) {\n    pathIndex = pathIndex || 0;\n\n    var si = (this.indicesBuffer[pathIndex]) * 3;\n    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n    var totalLength = 0, delta, length, v = this.vertexBuffer;\n\n    for (var i = si; i < (ei-5); i+=3) {\n        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];\n        length = vec3.length(delta);\n\n        totalLength += length;\n    }\n\n    return totalLength;\n};\n\n\nMapGeodataGeometry.prototype.getPathsCount = function() {\n    if (this.type != 2) {\n        return 0;\n    }\n\n    return this.indicesBuffer.length;\n};\n\n\nMapGeodataGeometry.prototype.getSurfaceArea = function() {\n    if (this.type != 3) {\n        return 0;\n    }\n\n    if (!this.surfaceArea) {\n        var v = this.vertexBuffer, s = this.surface;\n        var p1, p2, p3, l1, l2, l3, dx, dy, dz, perimeter, area;\n\n        this.surfaceArea = 0;\n        for (var i = 0, li = s.length; i < li; i+= 3) {\n            p1 = v[s[i]];\n            p2 = v[s[i+1]];\n            p3 = v[s[i+2]];\n\n            dx = p2[0] - p1[0];\n            dy = p2[1] - p1[1];\n            dz = p2[2] - p1[2];\n            l1 = Math.sqrt(dx*dx + dy*dy + dz*dz); \n\n            dx = p2[0] - p3[0];\n            dy = p2[1] - p3[1];\n            dz = p2[2] - p3[2];\n            l2 = Math.sqrt(dx*dx + dy*dy + dz*dz); \n\n            dx = p3[0] - p1[0];\n            dy = p3[1] - p1[1];\n            dz = p3[2] - p1[2];\n            l3 = Math.sqrt(dx*dx + dy*dy + dz*dz); \n\n            //Heron's formula\n            perimeter = (l1 + l2 + l3)/2;\n            area =  Math.sqrt(perimeter*((perimeter-l1)*(perimeter-l2)*(perimeter-l3)));\n\n            this.surfaceArea += area;\n        }\n    }\n\n    return this.surfaceArea;\n};\n\nexport default MapGeodataGeometry;\n\n\n","\nimport {math as math_} from '../../utils/math';\nimport {vec3 as vec3_} from '../../utils/matrix';\nimport {utils as utils_} from '../../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../../utils/url';\n\n\n\n//get rid of compiler mess\nvar math = math_;\nvar vec3 = vec3_;\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\n\nvar MapGeodataImport3DTiles = function(builder, options) {\n    this.builder = builder;\n    this.map = builder.map;\n    //this.heightMode = heightMode || 'float';\n    this.navSrs = this.map.getNavigationSrs();\n    this.physSrs = this.map.getPhysicalSrs();\n    this.srs = this.navSrs;\n    this.rootPath = '';\n    this.filesToLoad = 0;\n    //this.options = options || {};\n};\n\n\nMapGeodataImport3DTiles.prototype.processNode = function(builderNode, node, onlyChildren) {\n    var boundingVolume = node['boundingVolume'], volume;\n\n    if (boundingVolume) {\n\n        if (boundingVolume['region']) {\n            var v = boundingVolume['region'];\n            var min = [math.degrees(v[0]), math.degrees(v[1]), v[4]];\n            var max = [math.degrees(v[2]), math.degrees(v[3]), v[5]];\n\n            var p = [], r;\n\n            p[0] = this.physSrs.convertCoordsFrom([min[0], max[1], max[2]], this.srs);\n            p[1] = this.physSrs.convertCoordsFrom([max[0], max[1], max[2]], this.srs);\n            p[2] = this.physSrs.convertCoordsFrom([max[0], min[1], max[2]], this.srs);\n            p[3] = this.physSrs.convertCoordsFrom([min[0], min[1], max[2]], this.srs);\n\n            p[4] = this.physSrs.convertCoordsFrom([min[0], max[1], min[2]], this.srs);\n            p[5] = this.physSrs.convertCoordsFrom([max[0], max[1], min[2]], this.srs);\n            p[6] = this.physSrs.convertCoordsFrom([max[0], min[1], min[2]], this.srs);\n            p[7] = this.physSrs.convertCoordsFrom([min[0], min[1], min[2]], this.srs);\n\n            //var center = this.physSrs.convertCoordsFrom([(max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5], this.srs);\n\n            var center = [ (p[0][0]+p[1][0]+p[2][0]+p[3][0]+p[4][0]+p[5][0]+p[6][0]+p[7][0])/8,\n                           (p[0][1]+p[1][1]+p[2][1]+p[3][1]+p[4][1]+p[5][1]+p[6][1]+p[7][1])/8,\n                           (p[0][2]+p[1][2]+p[2][2]+p[3][2]+p[4][2]+p[5][2]+p[6][2]+p[7][2])/8 ];\n\n            //var axisX = [p[1][0] - p[0][0], p[1][1] - p[0][1], p[1][2] - p[0][2]];\n            //var axisY = [p[2][0] - p[1][0], p[2][1] - p[1][1], p[2][2] - p[1][2]];\n            //var axisZ = [p[0][0] - p[4][0], p[0][1] - p[4][1], p[0][2] - p[4][2]];\n\n            r = vec3.length([p[0][0] - center[0], p[0][1] - center[1], p[0][2] - center[2]]);\n\n            volume = {\n                points : p,\n                center : center,\n                radius: r,\n                halfAxis : [\n                    [(p[1][0] - p[0][0]) * 0.5, (p[1][1] - p[0][1]) * 0.5, (p[1][2] - p[0][2]) * 0.5 ],\n                    [(p[2][0] - p[1][0]) * 0.5, (p[2][1] - p[1][1]) * 0.5, (p[2][2] - p[1][2]) * 0.5 ],\n                    [(p[4][0] - p[0][0]) * 0.5, (p[4][1] - p[0][1]) * 0.5, (p[4][2] - p[0][2]) * 0.5 ]\n                ]\n            }\n        }\n    }\n\n\n    var precision = node['geometricError'];\n\n    if (!onlyChildren) {\n        builderNode = this.builder.addNode(builderNode, volume, precision, onlyChildren);\n    }\n\n    var content = node['content'];\n\n    if (content && content['uri']) {\n        var path = content['uri'];\n\n        path = utilsUrl.getProcessUrl(path, this.rootPath);\n\n        if (path.indexOf('.json') != -1) {\n            if (this.baseOptions.gradualJSONLoader) {\n                this.builder.addLoadNode(builderNode, path);\n            } else {\n                this.loadJSON(path, { internal: true, node: builderNode } );\n            }\n        }\n\n        else if (path.indexOf('.mesh') != -1) {\n            this.builder.addMesh(builderNode, path);\n        }\n    }\n\n    var children = node['children'];\n\n    if (children) {\n        for (var i = 0, li = children.length; i < li; i++) {\n            this.processNode(builderNode, children[i]);\n        }\n    }\n};\n\nMapGeodataImport3DTiles.prototype.processJSON = function(json) {\n    if (!json) {\n        return;\n    }\n\n    this.rootPath = rootPath || '';\n    this.processNode(null, json['root']);\n};\n\n\nMapGeodataImport3DTiles.prototype.loadJSON = function(path, options, onLoaded) {\n    this.filesToLoad++;\n\n    options = options || {};\n\n    if (!(options.internal)) {\n        this.onFinished = onLoaded;\n        this.baseOptions = options;\n        options = { internal:true, node: null };\n    }\n\n    utils.loadJSON(path, this.onLoaded.bind(this, path, options), this.onError.bind(this, options));\n};\n\n\nMapGeodataImport3DTiles.prototype.onLoaded = function(path, options, json) {\n    this.rootPath = utilsUrl.makeAbsolute(path);\n    this.rootPath = utilsUrl.getBase(this.rootPath);\n\n    this.processNode(options.node, json['root'], options.node ? true : false);\n\n    this.filesToLoad--;\n\n    if (!this.filesToLoad && this.onFinished) {\n        this.onFinished();\n    }\n}\n\nMapGeodataImport3DTiles.prototype.onError = function() {\n    this.filesToLoad--;\n\n    if (!this.filesToLoad && this.onFinished) {\n        this.onFinished();\n    }\n}\n\n\nexport default MapGeodataImport3DTiles;\n\n\n\n\n\n\n\n\n\n","\nimport {math as math_} from '../../utils/math';\nimport {vec3 as vec3_} from '../../utils/matrix';\nimport {utils as utils_} from '../../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../../utils/url';\n\n\n\n//get rid of compiler mess\nvar math = math_;\nvar vec3 = vec3_;\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\n\nvar MapGeodataImport3DTiles2 = function() {\n    this.bintree = null;\n    this.pathTable = null;\n    this.totalNodes = 0;\n    this.pathTableSize = 1;\n    this.nodesIndex = 0;\n    this.rootSize = 1;\n};\n\nMapGeodataImport3DTiles2.prototype.countNode = function(node, onlyChildren) {\n    this.totalNodes++;\n\n\n    var content = node['content'];\n\n    if (content && content['uri']) {\n        var path = content['uri'];\n\n        var tmp = path.split(\".\");\n        if (tmp.length > 1) {\n            \n            var ext = tmp[tmp.length - 1];\n            tmp.pop();\n            var stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n                this.pathTableSize += stmp.length + 1 + 4;\n            } else if (ext == \"mesh\") {\n                this.pathTableSize += stmp.length + 1;\n            }\n        }\n    }\n\n\n    var children = node['children'];\n\n    if (children) {\n        for (var i = 0, li = children.length; i < li; i++) {\n            this.countNode(children[i]);\n        }\n    }\n};\n\n/*\nMapGeodataImport3DTiles2.prototype.processNodeOctant = function(node, originalOctant) {\n    var content = node['content'];\n\n    if (content && content['uri']) {\n        var path = content['uri'];\n\n        var tmp = path.split(\".\");\n        if (tmp.length > 1) {\n\n            var ext = tmp[tmp.length - 1];\n            tmp.pop();\n            var stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n                \n                tmp = stmp.split(\"-\");\n\n            } else if (ext == \"mesh\") {\n                \n                var fname = tmp;\n                \n                tmp = stmp.split(\"/\");\n                tmp = tmp[tmp.length - 1];\n                tmp = tmp.split(\"-\");\n\n                var ix = parseInt(tmp[tmp.length - 3]);\n                var iy = parseInt(tmp[tmp.length - 2]);\n                var iz = parseInt(tmp[tmp.length - 1]);\n\n                var octant = (ix % 2) + (iy % 2)*2 + ((iz+1) % 2)*4;\n                \n                console.log(\"octant: node: \" + originalOctant + \" mesh:\" + octant + \"   \"  + fname);\n            }\n        }\n    }\n \n};\n*/\n\n\nMapGeodataImport3DTiles2.prototype.processNode = function(node, index, lod, onlyChildren) {\n\n    var index2 = index * 9;\n\n    //debugger\n    var content = node['content'];\n\n    if (content && content['uri']) {\n        var path = content['uri'];\n\n        var tmp = path.split(\".\");\n        if (tmp.length > 1) {\n            \n            var ext = tmp[tmp.length - 1];\n            tmp.pop();\n            var stmp = tmp.join('.');\n\n            if (ext == \"json\") {\n                this.bintree[index2] = this.pathTableSize | (1<<31);\n                this.pathTableSize += 4;\n            } else if (ext == \"mesh\") {\n                this.bintree[index2] = this.pathTableSize;\n            }\n\n            for (var i = 0, li = stmp.length; i < li; i++) {\n                this.pathTable[this.pathTableSize++] = stmp.charCodeAt(i);\n            }\n            \n            this.pathTable[this.pathTableSize++] = 0;\n        }\n    }\n\n    var children = node['children'];\n\n    if (children) {\n\n        for (var i = 0, li = children.length; i < li; i++) {\n            var child = children[i];\n            var boundingVolume = child['boundingVolume'];\n\n            if (boundingVolume) {\n                \n                var extras = child['extras'];\n                var octant = 0;\n                \n                if (extras) {\n                    octant = extras['ci'];\n                }\n                \n                \n                var ix = octant & 1;\n                var iy = (octant & (1<<1)) >> 1;\n                var iz = (octant & (1<<2)) >> 2;\n                \n                /*\n                switch(octant) {\n                    case 0: octant = 4; break;\n                    case 1: octant = 5; break;\n                    case 2: octant = 6; break;\n                    case 3: octant = 7; break;\n                    case 4: octant = 0; break; //\n                    case 5: octant = 1; break; //\n                    case 6: octant = 2; break; //\n                    case 7: octant = 3; break; //\n                }*/\n                \n                //this.processNodeOctant(child, octant);*/\n\n                /*\n                if (lod > 1) {\n                    iy = 1 - iy;\n                }*/\n\n                //iz = 1 - iz;\n                \n                //octant = (ix<<0) + (iy << 1) + (iz << 2);\n                //octant = (ix<<0) + (iy << 1) + (iz << 2);\n                \n                //octant = 0;\n                \n                if (boundingVolume['region']) {\n                    \n                    this.totalNodes++;\n                    var childIndex = this.totalNodes;\n                    \n                    this.bintree[index2 + 1 + octant] = childIndex;\n\n                    this.processNode(child, childIndex, lod + 1);\n                }\n            }\n        }\n        \n        /*var testCount = 0;\n        for (var i = 0, li = 8; i < li; i++) {\n            if (this.bintree[index2 + 1 + i]) {\n                testCount++;\n            }\n        }\n\n        if (testCount != children.length) {\n            console.log('duplicit octants!!!');\n        } */       \n    }\n};\n\n\nMapGeodataImport3DTiles2.prototype.processJSON = function(json, options) {\n    if (!json) {\n        return;\n    }\n\n    this.rootPath = '';\n\n    this.countNode(json['root']);\n    //alloc memory\n    this.bintree = new Uint32Array(this.totalNodes*9);\n    this.pathTable = new Uint8Array(this.pathTableSize+1);\n\n    this.totalNodes = 0;\n    this.pathTableSize = 1;\n\n    //debugger\n\n    if (options.root) {\n        \n        var extras = json['extras'];\n        var points = extras['extents'];\n\n        var center = [ (points[0][0]+points[1][0]+points[2][0]+points[3][0]+points[4][0]+points[5][0]+points[6][0]+points[7][0])/8,\n                       (points[0][1]+points[1][1]+points[2][1]+points[3][1]+points[4][1]+points[5][1]+points[6][1]+points[7][1])/8,\n                       (points[0][2]+points[1][2]+points[2][2]+points[3][2]+points[4][2]+points[5][2]+points[6][2]+points[7][2])/8 ];\n\n       var yv = [(points[1][0] - points[0][0]), (points[1][1] - points[0][1]), (points[1][2] - points[0][2])];\n       var xv = [(points[1][0] - points[2][0]), (points[1][1] - points[2][1]), (points[1][2] - points[2][2])];\n       var zv = [(points[4][0] - points[0][0]), (points[4][1] - points[0][1]), (points[4][2] - points[0][2])];\n\n       yv[0] = -yv[0];\n       yv[1] = -yv[1];\n       yv[2] = -yv[2];\n\n       xv[0] = -xv[0];\n       xv[1] = -xv[1];\n       xv[2] = -xv[2];\n       \n       /*zv[0] = -zv[0];\n       zv[1] = -zv[1];\n       zv[2] = -zv[2];*/\n       \n\n       var p = points[1];\n\n        this.rootPoints = [\n\n            [p[0],\n             p[1],\n             p[2]],\n\n            [p[0] + xv[0],\n             p[1] + xv[1],\n             p[2] + xv[2]],\n\n            [p[0] + xv[0] + yv[0],\n             p[1] + xv[1] + yv[1],\n             p[2] + xv[2] + yv[2]],\n\n            [p[0] + yv[0],\n             p[1] + yv[1],\n             p[2] + yv[2]],\n\n            [p[0] + zv[0],\n             p[1] + zv[1],\n             p[2] + zv[2]],\n\n            [p[0] + xv[0] + zv[0],\n             p[1] + xv[1] + zv[1],\n             p[2] + xv[2] + zv[2]],\n\n            [p[0] + xv[0] + yv[0] + zv[0],\n             p[1] + xv[1] + yv[1] + zv[1],\n             p[2] + xv[2] + yv[2] + zv[2]],\n\n            [p[0] + yv[0] + zv[0],\n             p[1] + yv[1] + zv[1],\n             p[2] + yv[2] + zv[2]]\n        \n        ];\n\n        //this.rootPoints = points;\n        this.rootCenter = center;\n        this.rootRadius = vec3.distance(center, points[0]);\n        this.rootTexelSize = extras['nominalResolution'] * Math.pow(2,extras['depth']);\n    } else {\n        this.rootPoints = [];\n        this.rootCenter = [];\n        this.rootRadius = 1;\n        this.rootTexelSize = 1;\n    }\n\n    this.processNode(json['root'], 0, 0);\n    this.totalNodes++;\n};\n\n\nMapGeodataImport3DTiles2.prototype.loadJSON = function(path, options, onLoaded) {\n    utils.loadJSON(path, this.onLoaded.bind(this, options, onLoaded), null);\n};\n\nMapGeodataImport3DTiles2.prototype.onLoaded = function(options, onLoaded, json) {\n    this.processJSON(json, options);\n    \n    if (onLoaded) {\n        onLoaded(options, {\n                   'bintree': this.bintree,\n                   'pathTable': this.pathTable,\n                   'totalNodes': this.totalNodes,\n                   'rootSize': this.rootSize,\n                   'points': this.rootPoints,\n                   'center': this.rootCenter,\n                   'radius': this.rootRadius,\n                   'texelSize': this.rootTexelSize\n               });\n    }\n}\n\nexport default MapGeodataImport3DTiles2;\n\n\n\n\n\n\n\n\n\n","\nvar MapGeodataImportGeoJSON = function(builder, heightMode, srs, options) {\n    this.builder = builder;\n    this.map = builder.map;\n    this.heightMode = heightMode || 'float';\n    this.srs = srs;\n\n    options = options || {};\n\n    this.groupIdPrefix = options['groupIdPrefix'] || '';\n    this.dontCreateGroups = options['dontCreateGroups'];\n    this.tesselation = options['tesselation'];\n};\n\nMapGeodataImportGeoJSON.prototype.processGeometry = function(geometry, feature) {\n    var coords = geometry['coordinates'];\n    if (!coords) {\n        return;\n    }\n\n    switch(geometry['type']) {\n        case 'Point':\n            this.builder.addPoint(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);\n            break;\n\n        case 'MultiPoint':\n            this.builder.addPointArray(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);\n            break;\n\n        case 'LineString':\n            this.builder.addLineString(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);\n            break;\n\n        case 'MultiLineString':\n            this.builder.addLineStringArray(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);\n            break;\n\n        case 'Polygon':\n            if (coords.length > 0) {\n                this.builder.addPolygon(coords[0], (coords.length > 1) ? coords.slice(1) : [], null, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs, this.tesselation);\n            }\n            break;\n\n        case 'MultiPolygon':\n            for (var i = 0, li = coords.length; i < li; i++) {\n                var coords2 = coords[i];\n                if (coords2.length > 0) {\n                    this.builder.addPolygon(coords2[0], (coords2.length > 1) ? coords2.slice(1) : [], null, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs, this.tesselation);\n                }\n            }\n            break;\n\n        case 'GeometryCollection':\n\n            var geometries = geometry['gemetries'];\n\n            if (geometries) {\n                for (var i = 0, li = geometries.length; i < li; i++) {\n                    this.processGeometry(geometries[i], feature);\n                }\n            }\n    }\n};\n\nMapGeodataImportGeoJSON.prototype.processFeature = function(json) {\n    var geometry = json['geometry'];\n\n    if (geometry) {\n        this.processGeometry(geometry, json);\n    }\n};\n\nMapGeodataImportGeoJSON.prototype.processCollection = function(json) {\n    var features = json['features'];\n\n    if (!features) {\n        return;\n    }\n\n    for (var i = 0, li = features.length; i < li; i++) {\n        this.processFeature(features[i]);\n    }\n};\n\nMapGeodataImportGeoJSON.prototype.processJSON = function(json) {\n    if (!json) {\n        return;\n    }\n\n    if (json['type']) {\n\n        switch (json['type']) {\n            case 'FeatureCollection':\n\n                if (!this.dontCreateGroups) {\n                    this.builder.addGroup(this.groupIdPrefix != '' ? this.groupIdPrefix : null);\n                }\n\n                this.processCollection(json);\n                break;\n            case 'Feature':\n\n                if (!this.dontCreateGroups) {\n                    this.builder.addGroup(this.groupIdPrefix != '' ? this.groupIdPrefix : null);\n                }\n\n                this.processFeature(json);\n                break;\n        }\n\n    } else {\n\n        for (var key in json) {\n            var item = json[key];\n\n            if (!this.dontCreateGroups) {\n                this.builder.addGroup(this.groupIdPrefix + key);\n            }\n\n            switch (json['type']) {\n                case 'FeatureCollection':\n                    this.processCollection(item);\n                    break;\n                case 'Feature':\n                    this.processFeature(item);\n                    break;\n            }\n        }\n    }\n\n};\n\nexport default MapGeodataImportGeoJSON;\n\n","\nvar MapGeodataImportVTSGeodata = function(builder, groupIdPrefix, dontCreateGroups) {\n    this.builder = builder;\n    this.map = builder.map;\n    this.groupIdPrefix = groupIdPrefix || '';\n    this.dontCreateGroups = dontCreateGroups;\n    //this.processJSON(json);\n};\n\nMapGeodataImportVTSGeodata.prototype.processJSON = function(json) {\n    if (!json) {\n        return;\n    }\n\n    var groups = json['groups'], i, li, j, lj, k, lk, p;\n    var builder = this.builder, newPoints, points;\n\n    if (!groups) {\n        return;\n    }\n\n    for (i = 0, li = groups.length; i < li; i++) {\n        var group = groups[i];\n\n        var bbox = group['bbox'],\n            resolution = group['resolution'];\n\n        if (!bbox || !resolution) {\n            continue;\n        }\n\n        var bboxMin = bbox[0];\n        var bboxMax = bbox[1];\n\n        if (!bboxMin || !bboxMax) {\n            continue;\n        }\n\n        if (!this.dontCreateGroups) {\n            builder.addGroup(this.groupIdPrefix + (group['id'] || ''));\n        }\n\n        var fx = (bboxMax[0] - bboxMin[0]) / resolution;\n        var fy = (bboxMax[1] - bboxMin[1]) / resolution;\n        var fz = (bboxMax[2] - bboxMin[2]) / resolution;\n\n        //import group points\n        var pointsFeatures = group['points'];\n        if (pointsFeatures) {\n\n            points = pointsFeatures['points']\n\n            for (j = 0, lj = pointsFeatures.length; j < lj; j++) {\n                var point = pointsFeatures[j];\n                var subpoints = point['points'];\n                var newSubpoints = new Array(subpoints.length);\n\n                for (k = 0, lk = subpoints.length; k < lk; k++) {\n                    p = subpoints[k];\n                    newSubpoints[k] = [bboxMin[0] + p[0] * fx, bboxMin[1] + p[1] * fy, bboxMin[2] + p[2] * fz];\n                }\n\n                builder.addPointArray(newSubpoints, 'fix', point['properties'], point['id'], null, true);\n            }\n        }\n\n        //import group lines\n        var linesFeatures = group['lines'];\n        if (linesFeatures) {\n            for (j = 0, lj = linesFeatures.length; j < lj; j++) {\n                var line = linesFeatures[j];\n                var sublines = line['lines'];\n                var newSublines = new Array(sublines.length);\n\n                for (k = 0, lk = sublines.length; k < lk; k++) {\n\n                    points = sublines[k];\n                    newPoints = new Array(points.length);\n\n                    for (var l  = 0, ll = points.length; l < ll; l++) {\n                        p = points[l];\n                        newPoints[l] = [bboxMin[0] + p[0] * fx, bboxMin[1] + p[1] * fy, bboxMin[2] + p[2] * fz];\n                    }\n\n                    newSublines[k] = newPoints;\n                }\n\n                builder.addLineStringArray(newSublines, 'fix', line['properties'], line['id'], null, true);\n            }\n        }\n\n        var polygonsFeatures = group['polygons'];\n        if (polygonsFeatures) {\n            var transform = { sx: fx, sy:fy, sz:fz, px:bboxMin[0], py:bboxMin[1], pz:bboxMin[2] };\n\n            for (j = 0, lj = polygonsFeatures.length; j < lj; j++) {\n                var polygon = polygonsFeatures[j];\n\n                builder.addPolygonRAW(polygon['vertices'], polygon['surface'], polygon['borders'], polygon['middle'], 'fix', polygon['properties'], polygon['id'], null, true, transform);\n            }\n        }\n\n    }\n\n};\n\nexport default MapGeodataImportVTSGeodata;\n\n\n","\nvar MapGeodataProcessor = function(surface, listener) {\n    this.layer = surface;\n    this.map = surface.map;\n    this.renderer = this.map.renderer;\n    this.killed = false;\n    this.listener = listener;\n    this.busy = false;\n    this.ready = true;\n    this.waitingForStylesheet = false;\n    this.stylesheet = null;\n    this.fonts = {};\n    this.processCounter = 0;\n\n\n    // eslint-disable-next-line\n    var worker = require('worker-loader?inline&fallback=false!./worker-main');\n    //var worker = require('worker-loader?!./worker-main');\n\n    //debug worker\n    this.processWorker = new worker;\n    \n    this.processWorker.onerror = function(event){\n        throw new Error(event.message + ' (' + event.filename + ':' + event.lineno + ')');\n    };\n\n    this.processWorker.onmessage = this.onMessage.bind(this);\n\n    this.processWorker.postMessage({'command':'config', 'data': this.map.config});\n};\n\n\nMapGeodataProcessor.prototype.kill = function() {\n    if (this.killed) {\n        return;\n    }\n\n    this.killed = true;\n\n    if (this.processWorker != null) {\n        this.processWorker.terminate();\n    }\n};\n\n\nMapGeodataProcessor.prototype.isReady = function() {\n    if (this.waitingForStylesheet) {\n        this.waitingForStylesheet = !(this.stylesheet.isReady());\n    }\n\n    return ((this.ready && !this.busy) || this.killed) && !this.waitingForStylesheet;\n};\n\n\nMapGeodataProcessor.prototype.onMessage = function(message, direct) {\n    if (this.killed) {\n        return;\n    }\n\n    if (!direct) {\n        message = message.data;\n    }\n    \n    var command = message['command'];\n\n    //console.log('onmessage ' + command);\n\n    //if (typeof message === \"string\" && message == \"ready\") {\n    if (command == 'ready') {\n        this.ready = true;\n        //console.log(\"ready\");\n    } else if (command == 'styleDone') {\n        this.busy = false;\n    } else if (command == 'loadBitmaps') {\n        var bitmaps = message['bitmaps'];\n\n        for (var key in bitmaps) {\n            var bitmap = bitmaps[key];\n            this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false, bitmap['hash'], true);\n        }\n    }\n\n    if (this.listener != null) {\n        if (command == 'packed-events') {\n            var messages = message['messages'];\n\n            for (var i = 0, li = messages.length; i < li; i++) {\n                this.onMessage(messages[i], true);\n            }\n\n            return;\n        } else {\n            this.listener(command, message);\n        }\n    }\n};\n\n\nMapGeodataProcessor.prototype.setListener = function(listener) {\n    this.listener = listener;\n};\n\n\nMapGeodataProcessor.prototype.sendCommand = function(command, data, tile, dpr) {\n    if (this.killed) {\n        return;\n    }\n\n    this.ready = false;\n    \n    var message = {'command': command, 'data':data};\n\n    //console.log('sendCommand ' + command);\n    \n    if (tile && tile.id) { \n        message['lod'] = tile.id[0];\n        message['ix'] = tile.id[1];\n        message['iy'] = tile.id[2];\n\n        if (tile.metanode) {\n            message['tileSize'] = Math.tan(tile.metanode.diskAngle2A) * tile.metanode.diskDistance;\n            message['pixelSize'] =  (message['tileSize'] * 0.70710678118) / tile.metanode.displaySize;\n        }\n    }\n\n    if (dpr) {\n        message['dpr'] = dpr;\n    }\n\n    this.processWorker.postMessage(message);\n};\n\nMapGeodataProcessor.prototype.setStylesheet = function(stylesheet, fontsOnly) {\n    this.stylesheet = stylesheet;\n\n    if (!stylesheet.isReady()) {\n        this.waitingForStylesheet = true;\n        return;\n    }\n\n    this.busy = true;\n\n    var ppi = 96 * (window.devicePixelRatio || 1);\n    var config = this.map.config;\n    var params = config.mapFeaturesReduceParams;\n    var isDef = (function(val){ return (typeof val !== 'undefined') });\n    var rmode = config.mapFeaturesReduceMode;\n\n\n    switch (rmode) {\n        case 'scr-count1':\n        case 'scr-count2':\n            if (!params) {\n                params = [1,50,0];\n            } else {\n                params[0] = isDef(params[0]) ? params[0] : 1;\n                params[1] = isDef(params[1]) ? params[1] : 50;\n                params[2] = isDef(params[2]) ? params[2] : 0;\n            }\n            config.mapFeaturesSortByTop = (rmode == 'scr-count2') ? true : false;\n            break;\n\n        case 'scr-count4':\n            if (!params) {\n                params = [0.18,0,0];\n            } else {\n                params[0] = isDef(params[0]) ? params[0] : 0.18;\n                params[1] = isDef(params[1]) ? params[1] : 0;\n                params[2] = isDef(params[2]) ? params[2] : 1;\n            }\n            config.mapFeaturesSortByTop = true;\n            break;\n\n        case 'scr-count5':\n            if (!params) {\n                params = [2,1,0];\n            } else {\n                params[0] = isDef(params[0]) ? params[0] : 2;\n                params[1] = isDef(params[1]) ? params[1] : 1;\n                params[2] = isDef(params[2]) ? params[2] : 1;\n            }\n            config.mapFeaturesSortByTop = true;\n            break;\n\n        case 'scr-count6':\n        case 'scr-count7':\n            if (!params) {\n                params = [0.2,0,((rmode == 'scr-count6') ? 1 : 2), 1, 1];\n            } else {\n                params[0] = (isDef(params[0]) ? params[0] : 0.2);\n                params[1] = isDef(params[1]) ? params[1] : 0;\n                params[2] = isDef(params[2]) ? params[2] : ((rmode == 'scr-count6') ? 1 : 2);\n                params[3] = isDef(params[3]) ? params[3] : 1;\n                params[4] = isDef(params[4]) ? params[4] : 1;\n                params[5] = ppi;\n                config.mapFeaturesSortByTop = true;\n            }\n            break;\n\n        case 'scr-count8':\n            if (!params) {\n                params = [0.2, 0.6, 11, 1, 1000, 5];\n            } else {\n                params[0] = (isDef(params[0]) ? params[0] : 0.2);\n                params[1] = isDef(params[1]) ? params[1] : 0.6;\n                params[2] = isDef(params[2]) ? params[2] : 11;\n                params[3] = isDef(params[3]) ? params[3] : 1;\n                params[4] = isDef(params[4]) ? params[4] : 1000;\n                params[5] = isDef(params[5]) ? params[5] : 5;\n                params[6] = ppi;\n                config.mapFeaturesSortByTop = true;\n            }\n            break;\n\n    }\n    \n    config.mapFeaturesReduceParams = params;\n    config.mapFeaturesReduceFactor = params[2];\n    config.mapFeaturesReduceFactor2 = params[3];\n    config.mapFeaturesReduceFactor3 = params[4];\n\n    //this.setFont('#default', this.renderer.font);\n    this.sendCommand('setStylesheet', { 'data' : stylesheet.data,\n                                        'geocent' : (!this.map.getNavigationSrs().isProjected()),\n                                        'metric': config.mapMetricUnits,\n                                        'language': config.mapLanguage,\n                                        'reduceMode': rmode,\n                                        'reduceParams': config.mapFeaturesReduceParams,\n                                        'log': config.mapLogGeodataStyles } );\n\n    var fonts = stylesheet.fonts;\n    var fontMap = {}; //'#default' : '#default' };\n\n    for (var key in fonts) {\n        var fontUrl = fonts[key];\n        var font = this.renderer.fonts[fontUrl];\n        fontMap[key] = fontUrl;\n\n        if (font) {\n            this.setFont(fontUrl, font);\n        }\n    }\n\n    this.processCounter++;\n    this.sendCommand('setFontMap', { 'map' : fontMap });\n};\n\n\nMapGeodataProcessor.prototype.setFont = function(url, font) {\n    if (!this.fonts[url]) {\n        this.fonts[url] = font;\n        this.sendCommand('setFont', {'url' : url, 'data': font.data}, [font.data]);\n    }\n};\n\n\nexport default MapGeodataProcessor;\n","\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport {utils as utils_} from '../utils/utils';\nimport GpuGroup_ from '../renderer/gpu/group';\nimport MapGeodataProcessor_ from './geodata-processor/processor';\n\n//get rid of compiler mess\nvar mat4 = mat4_, math = math_, utils = utils_;\nvar GpuGroup = GpuGroup_;\nvar MapGeodataProcessor = MapGeodataProcessor_;\n\nvar MapGeodataView = function(map, geodata, extraInfo) {\n    this.map = map;\n    this.stats = map.stats;\n    this.geodata = geodata;\n    this.gpu = this.map.renderer.gpu;\n    this.renderer = this.map.renderer;\n    this.gpuGroups = [];\n    this.currentGpuGroup = null;\n    this.tile = extraInfo.tile;\n    this.surface = extraInfo.surface;\n\n    if (!this.surface.geodataProcessor) {\n        var processor = new MapGeodataProcessor(this, this.onGeodataProcessorMessage.bind(this));\n        processor.setStylesheet(this.surface.stylesheet);\n        this.surface.geodataProcessor = processor;\n        this.map.geodataProcessors.push(processor);\n    } else {\n        if (this.surface.styleChanged) {\n            this.surface.geodataProcessor.setStylesheet(this.surface.stylesheet);\n            this.surface.styleChanged = false;\n        }\n    }\n\n    this.geodataProcessor = this.surface.geodataProcessor;\n    this.processing = false;\n    this.statsCounter = 0;\n    this.size = 0;\n    this.killed = false;\n    this.killedByCache = false;\n    this.ready = false;\n    this.isReady();\n};\n\n\nMapGeodataView.prototype.kill = function() {\n    this.killed = true;\n    this.geodata = null;\n    this.killGeodataView(false);\n};\n\n\nMapGeodataView.prototype.killGeodataView = function(killedByCache) {\n    this.killedByCache = killedByCache;\n\n    for (var i = 0, li = this.gpuGroups.length; i < li; i++) {\n        this.gpuGroups[i].kill();\n    }\n\n    this.gpuGroups = [];\n\n    if (killedByCache !== true && this.gpuCacheItem != null) {\n        this.map.gpuCache.remove(this.gpuCacheItem);\n    }\n\n    this.stats.gpuGeodata -= this.size;\n    this.stats.graphsFluxGeodata[1][0]++;\n    this.stats.graphsFluxGeodata[1][1] += this.size;\n    \n    this.ready = false;\n    this.size = 0;\n    this.gpuCacheItem = null;\n};\n\n\nMapGeodataView.prototype.processPackedCommands = function(buffer, index) {\n\n    var maxIndex = buffer.byteLength;\n    var maxTime = this.map.config.mapMaxGeodataProcessingTime;\n    var t = performance.now(), length, str, data;\n    var view = new DataView(buffer.buffer);\n\n    do {\n\n        var command = buffer[index]; index += 1;\n\n        switch(command) {\n            case VTS_WORKERCOMMAND_GROUP_BEGIN:\n                index += 1;\n                length = view.getUint32(index); index += 4;\n                str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;\n                data = JSON.parse(str);\n\n                this.currentGpuGroup = new GpuGroup(data['id'], data['bbox'], data['origin'], this.gpu, this.renderer);\n                this.gpuGroups.push(this.currentGpuGroup);\n\n                //console.log('VTS_WORKERCOMMAND_GROUP_BEGIN ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n                break;\n\n            case VTS_WORKERCOMMAND_GROUP_END:\n                this.size += this.currentGpuGroup.size; index += 1 + 4;\n                //console.log('VTS_WORKERCOMMAND_GROUP_END ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n                break;\n\n            case VTS_WORKERCOMMAND_ADD_RENDER_JOB:\n                index = this.currentGpuGroup.addRenderJob2(buffer, index, this.tile);\n                break;\n\n            case VTS_WORKERCOMMAND_ALL_PROCESSED:\n                this.map.markDirty();\n                this.gpuCacheItem = this.map.gpuCache.insert(this.killGeodataView.bind(this, true), this.size);\n\n                this.stats.gpuGeodata += this.size;\n                this.stats.graphsFluxGeodata[0][0]++;\n                this.stats.graphsFluxGeodata[0][1] += this.size;\n                this.ready = true;\n                this.processing = false;\n\n                //console.log('VTS_WORKERCOMMAND_ALL_PROCESSED ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n\n                index += 1 + 4;\n                break;\n        }\n\n        if ((performance.now() - t) > maxTime) {\n            if (index < maxIndex) {\n                return index;\n            }\n        }\n\n    } while(index < maxIndex);\n\n\n    this.stats.renderBuild += performance.now() - t; \n\n    return -1;\n};\n\n\nMapGeodataView.prototype.onGeodataProcessorMessage = function(command, message, task) {\n    if (this.killed || this.killedByCache){\n        return;\n    }\n\n    switch (command) {\n\n    case 'addPackedCommands':\n\n        //console.log('pack size:' + message['buffer'].byteLength);\n\n        if (task) {\n            var index = this.processPackedCommands(message['buffer'], message.index);\n\n            if (index < 0) {\n                this.map.markDirty();\n                //console.log('addPackedCommandsB ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n            } else {\n                //console.log('addPackedCommandsC ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n                message.index = index;\n                return -123;\n            }\n\n        } else {\n            message.index = 0;\n            this.map.markDirty();\n            this.map.addProcessingTask2(this.onGeodataProcessorMessage.bind(this, command, message, true));\n\n            //console.log('addPackedCommandsA ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n        }\n\n        break;\n\n    case 'ready':\n\n        if (this.geodataProcessor.processCounter > 0) {\n            this.geodataProcessor.processCounter--;\n\n            if (this.geodataProcessor.processCounter > 0) {\n                this.map.markDirty();\n                //console.log('ready2 ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n\n                break;\n            }\n        }\n\n        if (message['geodata']) {\n            this.geodata.geodata = message['geodata'];\n        }\n\n        this.geodataProcessor.busy = false;\n        this.map.markDirty();\n        //console.log('ready ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n\n            //this.ready = true;\n        break;\n    }\n};\n\n\nMapGeodataView.prototype.directParseNode = function(node, lod) {\n\n    this.currentGpuGroup.addRenderJob2(null, null, this.tile, { type: VTS_WORKER_TYPE_NODE_BEGIN, data: {'volume': node.volume, 'precision': node.precision, 'tileset': node.tileset }});\n\n    var meshes = node['meshes'] || [];\n    var i, li;\n\n    //loop elements\n    for (i = 0, li = meshes.length; i < li; i++) {\n        this.currentGpuGroup.addRenderJob2(null, null, this.tile, { type: VTS_WORKER_TYPE_MESH, data: { 'path':meshes[i] } });\n    }\n\n    var nodes = node['nodes'] || [];\n\n    for (i = 0, li = nodes.length; i < li; i++) {\n        this.directParseNode(nodes[i], lod+1);\n    }\n\n    var loadNodes = node['loadNodes'] || [];\n\n    for (i = 0, li = loadNodes.length; i < li; i++) {\n        this.currentGpuGroup.addRenderJob2(null, null, this.tile, { type: VTS_WORKER_TYPE_LOAD_NODE, data: { 'path':loadNodes[i] } });\n    }\n\n    this.currentGpuGroup.addRenderJob2(null, null, this.tile, { type: VTS_WORKER_TYPE_NODE_END, data: {} });\n\n};\n\n\nMapGeodataView.prototype.directParse = function(data) {\n    if (!data) {\n        return;\n    }\n\n    var nodes = data['nodes'] || [];\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        \n        //VTS_WORKERCOMMAND_GROUP_BEGIN\n        this.currentGpuGroup = new GpuGroup(null /*data['id']*/, null /*data['bbox']*/, null /*data['origin']*/, this.gpu, this.renderer);\n        this.gpuGroups.push(this.currentGpuGroup);\n    \n        this.directParseNode(nodes[i], 0);\n    \n        //VTS_WORKERCOMMAND_GROUP_END:\n        this.size += this.currentGpuGroup.size;\n    }\n};\n\n\nMapGeodataView.prototype.directBinParse = function(path) {\n    this.currentGpuGroup = new GpuGroup(null /*data['id']*/, null /*data['bbox']*/, null /*data['origin']*/, this.gpu, this.renderer);\n    this.gpuGroups.push(this.currentGpuGroup);\n    this.currentGpuGroup.binPath = path;\n};\n\n\nMapGeodataView.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {\n    if (this.killed) {\n        return false;\n    }\n\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n    \n    if (!this.ready && !this.processing && !doNotLoad && this.surface.stylesheet.isReady()) {\n        if (this.geodata.isReady(doNotLoad, priority, doNotCheckGpu, this.surface.options.fastParse) && this.geodataProcessor.isReady()) {\n\n            if (this.surface.options.fastParse) {\n\n                if (typeof this.geodata.geodata === 'object') { //use geodata directly\n                    if (this.geodata.geodata['binPath']) {\n                        this.directBinParse(this.geodata.geodata['binPath']);\n                    } else {\n                        this.directParse(this.geodata.geodata);\n                    }\n                } else {\n                    this.directParse(JSON.parse(this.geodata.geodata));\n                }\n                \n                this.map.markDirty();\n                this.ready = true;\n            } else {\n                var geodata = this.geodata.geodata;\n\n                this.processing = true;\n                this.killedByCache = false;\n                this.geodataProcessor.setListener(this.onGeodataProcessorMessage.bind(this));\n\n                if (this.map.config.mapGeodataBinaryLoad && (typeof geodata !== 'string')) {\n                    this.geodataProcessor.sendCommand('processGeodataRaw', geodata, this.tile, (window.devicePixelRatio || 1), [geodata]);\n                } else {\n                    this.geodataProcessor.sendCommand('processGeodata', geodata, this.tile, (window.devicePixelRatio || 1));\n                }\n\n                this.geodataProcessor.busy = true;\n                //console.log('processGeodata ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n            }\n        }\n    }\n\n    if (!doNotLoad && this.gpuCacheItem) {\n        this.map.gpuCache.updateItem(this.gpuCacheItem);\n    }\n\n    return this.ready;\n};\n\n\nMapGeodataView.prototype.getWorldMatrix = function(bbox, geoPos, matrix) {\n    var m = matrix;\n\n    if (m != null) {\n        m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;\n        m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;\n        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;\n        m[12] = bbox.min[0] - geoPos[0]; m[13] = bbox.min[1] - geoPos[1]; m[14] = bbox.min[2] - geoPos[2]; m[15] = 1;\n    } else {\n        m = mat4.create();\n\n        mat4.multiply( math.translationMatrix(bbox.min[0] - geoPos[0], bbox.min[1] - geoPos[1], bbox.min[2] - geoPos[2]),\n                       math.scaleMatrix(1, 1, 1), m);\n    }\n\n    return m;\n};\n\n\nMapGeodataView.prototype.draw = function(cameraPos) {\n    if (this.ready) {\n\n        var renderer = this.renderer;\n        var tiltAngle = this.tile ? Math.abs(this.tile.tiltAngle) : renderer.cameraTiltFator;\n        var useSuperElevation = renderer.useSuperElevation;\n\n        for (var i = 0, li = this.gpuGroups.length; i < li; i++) {\n            var group = this.gpuGroups[i]; \n\n            if (group.rootNode || group.binPath) {\n                group.draw(mv, mvp, null, tiltAngle, (this.tile ? this.tile.texelSize : 1));\n                continue;\n            }\n\n            if (!(group.jobs.length || group.rootNode)) {\n                continue; //TODO: remove empty groups\n            }\n\n            var mvp = group.mvp;\n            var mv = group.mv;\n            var mtmp = mvp; //use it as tmp matrix\n\n            if (useSuperElevation) {\n                //mat4.set(renderer.camera.getModelviewFMatrix(), mv);\n                mat4.multiply(renderer.camera.getModelviewFMatrix(), this.getWorldMatrix(group.bbox, cameraPos, mtmp), mv);\n            } else {\n                mat4.multiply(renderer.camera.getModelviewFMatrix(), this.getWorldMatrix(group.bbox, cameraPos, mtmp), mv);\n            }     \n        \n            var proj = renderer.camera.getProjectionFMatrix();\n            mat4.multiply(proj, mv, mvp);\n            \n            group.draw(mv, mvp, null, tiltAngle, (this.tile ? this.tile.texelSize : 1));\n\n            this.stats.drawnFaces += group.polygons;\n            this.stats.drawCalls += group.jobs.length;\n        }\n        \n        if (this.statsCoutner != this.stats.counter) {\n            this.statsCoutner = this.stats.counter;\n            this.stats.gpuRenderUsed += this.size;\n        }\n    }\n    return this.ready;\n};\n\n//MapGeodataView.prototype.getSize = function() {\n    //return this.size;\n//};\n\nexport default MapGeodataView;\n","\nimport BBox_ from '../renderer/bbox';\nimport {utils as utils_} from '../utils/utils';\nimport MapGeodataBuilder_ from './geodata-builder';\n\n//get rid of compiler mess\nvar BBox = BBox_;\nvar utils = utils_;\nvar MapGeodataBuilder = MapGeodataBuilder_;\n\n\nvar MapGeodata = function(map, url, extraInfo) {\n    this.map = map;\n    this.stats = map.stats;\n    this.mapLoaderUrl  = url;\n    this.extraInfo = extraInfo;\n\n    this.bbox = new BBox();\n    this.size = 0;\n    this.fileSize = 0;\n    this.geodata = null;\n    this.type = 'geodata';\n\n    this.cacheItem = null;\n\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n\n    this.map.markDirty();\n};\n\n\nMapGeodata.prototype.kill = function() {\n    this.bbox = null;\n    this.killGeodata();\n};\n\n\nMapGeodata.prototype.killGeodata = function(killedByCache) {\n    if (this.geodata) {\n        this.geodata = null;\n    }\n    \n    if (killedByCache !== true && this.cacheItem != null) {\n        this.map.resourcesCache.remove(this.cacheItem);\n    }\n\n    //if (this.gpuSubmeshes.length == 0) {\n    this.loadState = 0;\n    //}\n\n    this.size = 0;\n    this.fileSize = 0;\n    this.cacheItem = null;\n};\n\n\nMapGeodata.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu, fastParse) {\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n\n    if (this.loadState == 2) { //loaded\n        this.map.resourcesCache.updateItem(this.cacheItem);\n        return true;\n    } else {\n        if (this.loadState == 0) { \n            if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                  //  this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            } else {\n                //not loaded\n                //add to loading queue or top position in queue\n\n                /*if (typeof this.mapLoaderUrl !== 'object' || this..mapLoaderUrl.indexOf('tileset.json')) { \n\n                    var geodata = new MapGeodataBuilder(this.map);\n                    geodata.load3DTiles(this..mapLoaderUrl, {}, (function(){ \n\n                        //TODO:\n                    }));\n\n                }\n                else*/ if (typeof this.mapLoaderUrl === 'object') { //use geodata directly\n                    this.geodata = fastParse ? this.mapLoaderUrl : JSON.stringify(this.mapLoaderUrl);\n                    this.loadState = 2;\n                    this.size = this.geodata.length ? this.geodata.length : 0;\n                    this.cacheItem = this.map.resourcesCache.insert(this.killGeodata.bind(this, true), this.size);\n                    this.map.resourcesCache.updateItem(this.cacheItem);\n                    return true;\n                } else {\n                    this.scheduleLoad(priority);\n                }\n            }\n        } else if (this.loadState == 3) { //loadError\n            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n\n                this.scheduleLoad(priority);                    \n            }\n        }  //else load in progress\n    }\n\n    return false;\n};\n\n\nMapGeodata.prototype.scheduleLoad = function(priority) {\n    //if (this.mapLoaderUrl == null) {\n        //this.mapLoaderUrl = this.map.url.makeUrl(this.tile.surface.meshUrl, {lod:this.tile.id[0], ix:this.tile.id[1], iy:this.tile.id[2] });\n    //}\n\n    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.extraInfo.tile, 'geodata');\n};\n\n\nMapGeodata.prototype.onLoad = function(url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    this.loadState = 1;\n    \n    if (this.map.config.mapGeodataBinaryLoad) {\n        this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'geodata');\n    } else {\n        utils.loadJSON(url, this.onLoaded.bind(this), this.onLoadError.bind(this), true, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n    }\n\n    return;\n};\n\n\nMapGeodata.prototype.onLoadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    this.loadState = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n\n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n\n    this.mapLoaderCallError();\n};\n\n\nMapGeodata.prototype.onLoaded = function(data) {\n    if (this.map.killed){\n        return;\n    }\n\n    var size = data.length || data.byteLength;\n    if (!size) {\n        size = 0;\n    }\n\n    this.size = size;\n    this.fileSize = size;\n\n    this.geodata = data;\n\n    this.cacheItem = this.map.resourcesCache.insert(this.killGeodata.bind(this, true), size);\n\n    this.map.markDirty();\n    this.loadState = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.mapLoaderCallLoaded();\n};\n\n// Returns RAM usage in bytes.\n//MapGeodata.prototype.getSize = function () {\n  //  return this.size;\n//};\n\n//MapGeodata.prototype.getFileSize = function () {\n  //  return this.fileSize;\n//};\n\nexport default MapGeodata;\n\n\n","\nimport MapTrajectory_ from './trajectory';\nimport MapBoundLayer_ from './bound-layer';\nimport MapSurface_ from './surface';\nimport MapPosition_ from './position';\nimport MapGeodataBuilder_ from './geodata-builder';\n\n//get rid of compiler mess\nvar MapTrajectory = MapTrajectory_;\nvar MapBoundLayer = MapBoundLayer_;\nvar MapSurface = MapSurface_;\nvar MapPosition = MapPosition_;\nvar MapGeodataBuilder = MapGeodataBuilder_;\n\n\nvar MapInterface = function(map) {\n    this.map = map;\n    this.config = map.config;\n};\n\n\nMapInterface.prototype.setPosition = function(position) {\n    this.map.setPosition(position);\n    return this;    \n};\n\n\nMapInterface.prototype.getPosition = function() {\n    return this.map.getPosition();\n};\n\n\nMapInterface.prototype.setView = function(view, forceRefresh, posToFixed) {\n    this.map.setView(view, forceRefresh, posToFixed);\n    return this;    \n};\n\n\nMapInterface.prototype.getView = function() {\n    return this.map.getView();\n};\n\n\nMapInterface.prototype.getCredits = function() {\n    return this.map.getCredits();\n};\n\n\nMapInterface.prototype.getCurrentCredits = function() {\n    return this.map.getVisibleCredits();\n};\n\n\nMapInterface.prototype.getCreditInfo = function(creditId) {\n    var credit = this.map.getCreditById(creditId);\n    return credit ? credit.getInfo() : {};\n};\n\n\nMapInterface.prototype.getViews = function() {\n    return this.map.getNamedViews();\n};\n\n\nMapInterface.prototype.getViewInfo = function(viewId) {\n    var view = this.map.getNamedView(viewId);\n    return view ? view.getInfo() : {};\n};\n\n\nMapInterface.prototype.getBoundLayers = function() {\n    return this.map.getBoundLayers();\n};\n\n\nMapInterface.prototype.getBoundLayerInfo = function(layerId) {\n    return this.map.getBoundLayerInfo(layerId);\n};\n\n\nMapInterface.prototype.getFreeLayers = function() {\n    return this.map.getFreeLayers();\n};\n\n\nMapInterface.prototype.getFreeLayerInfo = function(layerId) {\n    var layer = this.map.getFreeLayer(layerId);\n    return layer ? layer.getInfo() : {};\n};\n\n\nMapInterface.prototype.getSurfaces = function() {\n    return this.map.getSurfaces();\n};\n\n\nMapInterface.prototype.getSurfaceInfo = function(surfaceId) {\n    var surface = this.map.getFreeLayer(surfaceId);\n    return surface ? surface.getInfo() : {};\n};\n\n\nMapInterface.prototype.getSrses = function() {\n    return this.map.getSrses();\n};\n\n\nMapInterface.prototype.getSrsInfo = function(srsId) {\n    var srs = this.map.getSrs(srsId);\n    return srs ? srs.getInfo() : {};\n};\n\n\nMapInterface.prototype.getReferenceFrame = function() {\n    return this.map.referenceFrame.getInfo();\n};\n\n\nMapInterface.prototype.addFreeLayer = function(id, options) {\n    var layer = new MapSurface(this.map, options, 'free');\n    this.map.addFreeLayer(id, layer);\n};\n\n\nMapInterface.prototype.removeFreeLayer = function(id) {\n    this.map.removeFreeLayer(id); \n};\n\n\n/* MapInterface.prototype.setFreeLayerOptions = function(id, options) {\n    this.map.setFreeLayerOptions(id, options); \n};\n\n\nMapInterface.prototype.getFreeLayerOptions = function(id) {\n    return this.map.getFreeLayerOptions(id); \n}; */\n\n\nMapInterface.prototype.addBoundLayer = function(id, options) {\n    var layer = new MapBoundLayer(this.map, options, id);\n    this.map.addBoundLayer(id, layer); \n};\n\n\nMapInterface.prototype.removeBoundLayer = function(id) {\n    this.map.removeBoundLayer(id); \n};\n\n\n/* MapInterface.prototype.setBoundLayerOptions = function(id, options) {\n    this.map.setBoundLayerOptions(id, options); \n};\n\n\nMapInterface.prototype.getBoundLayerOptions = function(id) {\n    return this.map.setBoundLayerOptions(id); \n};*/\n\nMapInterface.prototype.convertPositionViewMode = function(position, mode) {\n    return this.map.convert.convertPositionViewMode((new MapPosition(position)), mode);\n};\n\n\nMapInterface.prototype.convertPositionHeightMode = function(position, mode, noPrecisionCheck) {\n    return this.map.convert.convertPositionHeightMode((new MapPosition(position)), mode, noPrecisionCheck);\n};\n\n\nMapInterface.prototype.convertCoords = function(sourceSrs, destinationSrs, coords) {\n    var srs = this.map.getSrs(sourceSrs);\n    var srs2 = this.map.getSrs(destinationSrs);\n    if (!srs || !srs2) {\n        return null;\n    }\n\n    return srs2.convertCoordsFrom(coords, srs);\n};\n\n\nMapInterface.prototype.convertCoordsFromNavToPublic = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionPublicCoords((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPublicToNav = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionNavCoordsFromPublic((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPhysToPublic = function(pos, containsSE) {\n    if (containsSE && this.map.renderer.useSuperElevation) {\n        var p = this.map.renderer.transformPointBySE(pos);\n        return this.map.convert.convertCoords(p, 'physical', 'public');\n    } else {\n        return this.map.convert.convertCoords(pos, 'physical', 'public');\n    }\n};\n\n\nMapInterface.prototype.convertCoordsFromNavToPhys = function(pos, mode, lod, includeSE) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionPhysCoords((new MapPosition(p)), lod, includeSE);\n};\n\n\nMapInterface.prototype.convertCoordsFromPhysToNav = function(pos, mode, lod, containsSE) {\n    return this.map.convert.convertCoordsFromPhysToNav(pos, mode, lod, containsSE);\n};\n\n\nMapInterface.prototype.convertCoordsFromNavToCanvas = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionCanvasCoords((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPhysToCanvas = function(pos, containsSE) {\n    var p = ['obj', pos[0], pos[1], 'fix', pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionCanvasCoords((new MapPosition(p)), null, true, containsSE);\n};\n\n\nMapInterface.prototype.convertCoordsFromNavToCameraSpace = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionCameraSpaceCoords((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPhysToCameraSpace = function(pos) {\n    var p = this.map.camera.position;\n    return [pos[0] - p[0], pos[1] - p[1], pos[2] - p[2]];\n};\n\n\nMapInterface.prototype.transformPhysCoordsBySE = function(pos) {\n    return this.map.convert.transformPhysCoordsBySE(pos);\n};\n\n\nMapInterface.prototype.getPositionCanvasCoords = function(position, lod) {\n    return this.map.convert.getPositionCanvasCoords(new MapPosition(position), lod);\n};\n\n\nMapInterface.prototype.getPositionCameraCoords = function(position, mode) {\n    return this.map.convert.getPositionCameraCoords(new MapPosition(position), mode);\n};\n\n\nMapInterface.prototype.movePositionCoordsTo = function(position, azimuth, distance, skipOrientation) {\n    return this.map.convert.movePositionCoordsTo(new MapPosition(position), azimuth, distance, skipOrientation);\n};\n\n\nMapInterface.prototype.getGeodesicLinePoints = function(coords, coords2, height, density) {\n    return this.map.convert.getGeodesicLinePoints(coords, coords2, height, density);\n};\n\n\nMapInterface.prototype.getSurfaceHeight = function(coords, precision) {\n    return this.map.measure.getSurfaceHeight(coords, this.map.measure.getOptimalHeightLodBySampleSize(coords, precision));\n};\n\n\nMapInterface.prototype.getSurfaceAreaGeometry = function(coords, radius, mode, limit, callback, loadTextures) {\n    var res = this.map.measure.getSurfaceAreaGeometry(coords, radius, mode, limit, true, loadTextures);\n    //console.log('getSurfaceAreaGeometry');\n\n    if (!res[0]) {\n        return this.map.core.once('map-update', this.getSurfaceAreaGeometry.bind(this, coords, radius, mode, limit, callback, loadTextures), 1);\n    } else {\n        var buffer = res[1], ret = [], map = this.map;        \n\n        if (map.tree) {\n            map.storedTilesRes = [];\n            map.tree.storeGeometry(buffer, buffer.length);\n            ret = map.storedTilesRes;\n            map.storedTilesRes = [];\n        }\n\n        callback(ret);\n        return (function(){});\n    }\n};\n\n\nMapInterface.prototype.getDistance = function(coords, coords2, includingHeights, usePublic) {\n    return this.map.measure.getDistance(coords, coords2, includingHeights, usePublic);\n};\n\n\nMapInterface.prototype.getAzimuthCorrection = function(coords, coords2) {\n    return this.map.measure.getAzimuthCorrection(coords, coords2);\n};\n\n\nMapInterface.prototype.getNED = function(coords, onlyMatrix) {\n    return this.map.measure.getNewNED(coords, (onlyMatrix === false) ? false : true);\n};\n\n\nMapInterface.prototype.getCameraInfo = function() {\n    var camera = this.map.camera;\n    return {\n        'projectionMatrix' : camera.camera.projection.slice(),\n        'viewMatrix' : camera.camera.modelview.slice(),\n        'viewProjectionMatrix' : camera.camera.mvp.slice(),\n        'rotationMatrix' : camera.camera.rotationview.slice(),\n        'position' : this.map.camera.position.slice(),\n        'vector' : this.map.camera.vector.slice(),\n        'distance' : this.map.camera.distance,\n        'height' : this.map.camera.height\n    };\n};\n\n\nMapInterface.prototype.isPointInsideCameraFrustum = function(point) {\n    return this.map.camera.camera.pointVisible(point, this.map.camera.position);\n};\n\n\nMapInterface.prototype.isBBoxInsideCameraFrustum = function(bbox) {\n    return this.map.camera.camera.bboxVisible({min:bbox[0], max:bbox[1]}, this.map.camera.position);\n};\n\n\nMapInterface.prototype.generateTrajectory = function(p1, p2, options) {\n    p1 = new MapPosition(p1);\n    p2 = new MapPosition(p2);\n    return (new MapTrajectory(this.map, p1, p2, options)).generate();\n};\n\n\nMapInterface.prototype.generatePIHTrajectory = function(position, azimuth, distance, options) {\n    var p = new MapPosition(position);\n    options['distance'] = distance;\n    options['azimuth'] = azimuth;\n    options['distanceAzimuth'] = true;\n    return (new MapTrajectory(this.map, p, p, options)).generate();\n};\n\n\nMapInterface.prototype.setConfigParams = function(params) {\n    this.map.setConfigParams(params);\n    return this;\n};\n\n\nMapInterface.prototype.setConfigParam = function(key, value) {\n    this.map.setConfigParam(key, value);\n    return this;\n};\n\n\nMapInterface.prototype.getConfigParam = function(key) {\n    return this.map.getConfigParam(key);\n};\n\n\nMapInterface.prototype.redraw = function() {\n    this.map.markDirty();\n    return this;\n};\n\n\nMapInterface.prototype.addRenderSlot = function(id, callback, enabled) {\n    this.map.renderSlots.addRenderSlot(id, callback, enabled);\n    return this;    \n};\n\n\nMapInterface.prototype.moveRenderSlotBefore = function(whichId, whereId) {\n    this.map.renderSlots.moveRenderSlotBefore(whichId, whereId);\n    return this;    \n};\n\n\nMapInterface.prototype.moveRenderSlotAfter = function(whichId, whereId) {\n    this.map.renderSlots.moveRenderSlotAfter(whichId, whereId);\n    return this;    \n};\n\n\nMapInterface.prototype.removeRenderSlot = function(id) {\n    this.map.renderSlots.removeRenderSlot(id);\n    return this;    \n};\n\n\nMapInterface.prototype.setRenderSlotEnabled = function(id, state) {\n    this.map.renderSlots.setRenderSlotEnabled(id, state);\n    return this;    \n};\n\n\nMapInterface.prototype.getRenderSlotEnabled = function(id) {\n    return this.map.renderSlots.getRenderSlotEnabled(id);\n};\n\n\nMapInterface.prototype.setLoaderSuspended = function(state) {\n    this.map.loaderSuspended = state;\n    return this;\n};\n\n\nMapInterface.prototype.getLoaderSuspended = function() {\n    return this.map.loaderSuspended;\n};\n\n\nMapInterface.prototype.getGpuCache = function() {\n    return this.map.gpuCache;\n};\n\n\nMapInterface.prototype.getHitCoords = function(screenX, screenY, mode, lod) {\n    return this.map.getHitCoords(screenX, screenY, mode, lod);\n};\n\n\nMapInterface.prototype.getScreenRay = function(screenX, screenY) {\n    return this.map.getScreenRay(screenX, screenY);\n};\n\n\nMapInterface.prototype.renderToImage = function() {\n    return this.map.renderToImage();\n};\n\n\nMapInterface.prototype.getCurrentGeometry = function() {\n    return this.map.getCurrentGeometry();\n};\n\n\nMapInterface.prototype.getStats = function(switches) {\n    if (switches) {\n        return {\n            'maxZoom' : this.map.draw.debug.maxZoom\n        };\n    }\n\n    var busyWorkers = 0;\n    for (var i = 0, li = this.map.geodataProcessors; i < li; i++) {\n        if (this.map.geodataProcessors[i].busy) {\n            busyWorkers++;\n        }        \n    }\n\n    return {\n        'bestMeshTexelSize' : this.map.bestMeshTexelSize,\n        'bestGeodataTexelSize' : this.map.bestGeodataTexelSize, \n        'downloading' : this.map.loader.downloading.length,\n        'lastDownload' : this.map.loader.lastDownloadTime, \n        'surfaces' : this.map.tree.surfaceSequence.length,\n        'freeLayers' : this.map.freeLayerSequence.length,\n        'texelSizeFit' : this.map.texelSizeFit,\n        'loadMode' : this.map.config.mapLoadMode,\n        'processingTasks' : this.map.processingTasks.length,\n        'busyWorkers' : busyWorkers,\n        'dirty' : this.map.dirty,\n        'drawnTiles' : this.map.stats.drawnTiles,\n        'drawnGeodataTiles' : this.map.stats.drawnGeodataTiles,\n        'renderTime' : this.map.stats.rendererTime,\n        'frameTime' : this.map.stats.frameTime\n    };\n};\n\n\nMapInterface.prototype.click = function(screenX, screenY, state) {\n    this.map.click(screenX, screenY, state);\n};\n\n\nMapInterface.prototype.hover = function(screenX, screenY, persistent, state) {\n    this.map.hover(screenX, screenY, persistent, state);\n};\n\nMapInterface.prototype.createGeodata = function() {\n    return new MapGeodataBuilder(this.map);\n};\n\nMapInterface.prototype.getGeodataGeometry = function(id) {\n    return this.map.renderer.geometries[id];\n};\n\nMapInterface.prototype.setGeodataSelection = function(selection) {\n    this.map.renderer.geodataSelection = selection;\n    this.map.markDirty();\n    return this;\n};\n\nMapInterface.prototype.getGeodataSelection = function() {\n    return this.map.renderer.geodataSelection;\n};\n\n\nexport default MapInterface;\n","\nimport {utils as utils_} from '../../utils/utils';\n\n//get rid of compiler mess\nvar utils = utils_;\n\n\nvar MapLoader = function(map, maxThreads) {\n    this.map = map;\n    this.core = map.core;\n    this.killed = false;\n    this.config = map.config;\n\n    this.maxThreads = maxThreads || 1;\n    this.usedThreads = 0;\n    this.maxPending = this.maxThreads * 2;\n    this.fadeout = 19 / 20;\n\n    this.pending = [[],[]];\n    this.channel = 0;\n\n    this.downloading = [];\n    this.downloadingTime = [];\n    this.workerTask = {};\n\n    this.lastDownloadTime = 0;\n    this.downloaded = 0;\n    this.processWorker = null;\n    this.updateThreadCount();\n\n    if (this.config.mapSeparateLoader) {\n        // eslint-disable-next-line\n        var worker = require('worker-loader?inline&fallback=false!./worker-main');\n\n        this.processWorker = new worker;\n        \n        this.processWorker.onerror = function(event){\n            throw new Error(event.message + ' (' + event.filename + ':' + event.lineno + ')');\n        };\n\n        this.processWorker.onmessage = this.onWorkerMessage.bind(this);\n\n        this.processWorker.postMessage({'command':'config', 'data': this.config});\n    }\n\n};\n\n\nMapLoader.prototype.updateThreadCount = function() {\n    this.maxThreads = this.config.mapDownloadThreads;\n    this.maxPending = Math.max(20, this.maxThreads * 2);\n    this.fadeout = (this.maxPending-1) / this.maxPending;\n};\n\n\nMapLoader.prototype.setChannel = function(channel) {\n    this.channel = channel;\n};\n\n\nMapLoader.prototype.onWorkerMessage = function(message, direct) {\n    if (this.killed) {\n        return;\n    }\n\n    if (!direct) {\n        message = message.data;\n    }\n    \n    var command = message['command'];\n\n    if (command == 'packed-events') {\n        var messages = message['messages'];\n\n        for (var i = 0, li = messages.length; i < li; i++) {\n            this.onWorkerMessage(messages[i], true);\n        }\n\n        return;\n    }\n\n    var path = message['path'];\n\n    var task = this.workerTask[path];\n    if (task) {\n\n        switch(command) {\n\n            case 'on-loaded':\n\n                if (task.onLoaded) {\n\n                    switch(task.kind) {\n                        case 'direct-texture':\n                            task.onLoaded(message['data'], true, message['filesize']);\n                            break;\n\n                        case 'direct-mesh':\n                            task.onLoaded(message['data'], false, true, message['filesize']);\n                            break;\n\n                        case 'texture':\n                            task.onLoaded(new Blob([message['data']]));\n                            break;\n\n                        default:\n                            task.onLoaded(message['data']);\n                    }\n\n                }\n\n                break;\n\n            case 'on-error':\n                if (task.onError) {\n                    task.onError();\n                }\n\n                break;\n        }\n\n        /*\n        if (command == 'on-loaded') {\n\n            if (task.onLoaded) {\n                if (task.kind == 'texture') {\n                    task.onLoaded(new Blob([message['data']]));\n                } else {\n                    task.onLoaded(message['data']);\n                }\n            }\n\n        } else if (command == 'on-error') {\n\n            if (task.onError) {\n                task.onError();\n            }\n        }*/\n\n        delete this.workerTask[path];\n    }\n\n};\n\n\nMapLoader.prototype.processLoadBinary = function(path, onLoaded, onError, responseType, kind, options) {\n    var withCredentials = (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false);\n\n    if (this.processWorker) {\n\n        switch(kind) {\n            case 'texture':\n                if (this.config.mapAsyncImageDecode) {\n                    responseType = 'blob';\n                    kind = 'direct-texture';\n                }\n                break;\n\n            case 'mesh':\n                if (this.config.mapParseMeshInWorker) {\n                    kind = 'direct-mesh';\n                }\n                break;\n        }\n\n        switch(kind) {\n            case 'texture':\n            case 'direct-texture':\n            case 'mesh':\n            case 'direct-mesh':\n            case 'metadata':\n            case 'geodata':\n            case 'direct-3dtiles':\n\n                //console.log(\"kind: \" + kind + \" \" + \"path: \" + path);\n\n                this.workerTask[path] = { onLoaded: onLoaded, onError: onError, kind: kind };\n                this.processWorker.postMessage({'command':'load-binary', 'path': path, 'withCredentials':withCredentials, 'xhrParams':this.map.core.xhrParams, 'responseType':responseType, 'kind': kind, 'options': options});\n                break;\n\n            default:\n                utils.loadBinary(path, onLoaded, onError, withCredentials, this.map.core.xhrParams, responseType);\n        }\n\n    } else {\n        if (kind == 'texture' && this.config.mapAsyncImageDecode) {\n            responseType = 'blob';\n        }\n\n        utils.loadBinary(path, onLoaded, onError, withCredentials, this.map.core.xhrParams, responseType);\n    }\n};\n\n\nMapLoader.prototype.load = function(path, downloadFunction, priority, id, kind) {\n    var index = this.downloading.indexOf(path);\n\n    if (index != -1) {\n        return;\n    }\n\n    // update the pending list\n    var pending = this.pending[this.channel];\n\n   // put the request to the beginning of the pending list\n    index = this.map.searchArrayIndexById(pending, path);\n    if (index != -1) {\n        pending[index].priority = priority; \n    } else {\n        pending.unshift({id:path, call: downloadFunction, priority : (priority || 0), tile:id, kind:kind });\n    }\n\n    //sort pending list by priority\n    do {\n        var sorted = true;\n        \n        for (var i = 0, li = pending.length - 1; i < li; i++) {\n            if (pending[i].priority > pending[i+1].priority) {\n                var t = pending[i];\n                pending[i] = pending[i+1];\n                pending[i+1] = t;\n    \n                sorted = false;\n            } \n        }\n        \n    } while(!sorted);\n\n    // keep the pending list at reasonable length\n    if (pending.length > this.maxPending) {\n        pending.pop();\n    }\n};\n\n\nMapLoader.prototype.remove = function(path) {\n    var index = this.map.searchArrayIndexById(this.pending[this.channel], path);\n    if (index != -1) {\n        this.pending[this.channel].splice(index, 1);\n    }\n};\n\n\nMapLoader.prototype.onLoaded = function(item) {\n    var index = this.downloading.indexOf(item.id);\n    var timer = performance.now();\n    var stats = this.map.stats;\n    var recordStats = this.map.draw.replay.storeLoaded;\n\n    if (recordStats) {\n        this.map.draw.replay.loaded.push({\n            url : item.id,\n            kind : item.kind,\n            tile: item.tile,\n            priority : item.priority,\n            time : timer,\n            duration : timer - this.downloadingTime[index],\n            interval : timer - this.lastDownloadTime,\n            threads : this.downloading.length\n        });\n\n        //var a = (timer - this.downloadingTime[index]);\n        //if (Number.isNaN(a)) {\n            //a = a; \n        //}\n\n    }\n\n    this.downloading.splice(index, 1);\n    this.downloadingTime.splice(index, 1);\n    //this.lastDownloadTime = Date.now();\n    this.lastDownloadTime = timer;\n    this.usedThreads--;\n    this.map.markDirty();\n    this.update(true);\n    stats.loadedCount++;\n    stats.loadLast = timer;\n};\n\n\nMapLoader.prototype.onLoadError = function(item) {\n    var index = this.downloading.indexOf(item.id);\n    var timer = performance.now();\n    var stats = this.map.stats;\n    var recordStats = this.map.draw.replay.storeLoaded;\n\n    if (recordStats) {\n        this.map.draw.replay.loaded.push({\n            url : item.id,\n            kind : item.kind,\n            tile: item.tile,\n            priority : item.priority,\n            time : timer,\n            duration : timer - this.downloadingTime[index],\n            interval : timer - this.lastDownloadTime,\n            threads : this.downloading.length\n        });\n    }\n\n    this.downloading.splice(index, 1);\n    this.downloadingTime.splice(index, 1);\n    //this.lastDownloadTime = Date.now();\n    this.lastDownloadTime = timer;\n    this.usedThreads--;\n    this.map.markDirty();\n    this.update(true);\n    stats.loadErrorCount++;\n    stats.loadLast = timer;\n};\n\n\nMapLoader.prototype.updateChannel = function(channel) {\n    var pending = this.pending[channel];\n    this.updateThreadCount();\n\n    //reduce priority for pending stuff\n    for (var i = 0, li = pending.length; i < li; i++) {\n        pending[i].priority *= this.fadeout;\n    }\n\n    var timer = performance.now();\n\n    while (pending.length > 0 && this.usedThreads < this.maxThreads) {\n        var item = pending.shift();\n\n        if (this.downloading.indexOf(item.id) == -1 && item.call != null) {\n            this.downloading.push(item.id);\n            this.downloadingTime.push(timer);\n            this.usedThreads++;\n            this.downloaded++;\n\n            item.call(item.id, this.onLoaded.bind(this, item), this.onLoadError.bind(this, item));\n        }\n    }\n};\n\n\nMapLoader.prototype.update = function(skipTick) {\n    if (this.map.loaderSuspended || this.core.contextLost) {\n        return;\n    }\n\n    if (!skipTick && this.processWorker && this.config.mapPackLoaderEvents && this.downloading.length) {\n        this.processWorker.postMessage({'command':'tick'});\n    }\n\n    for (var i = this.pending.length - 1; i >= 0; i--) {\n        if (this.pending[i].length > 0) {\n            this.updateChannel(i);\n            break;\n        }\n    }\n};\n\n\nexport default MapLoader;\n\n","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport {utils as utils_} from '../utils/utils';\nimport {platform as platform_} from '../utils/platform';\nimport MapView_ from './view';\nimport MapSurfaceTree_ from './surface-tree';\nimport MapResourceTree_ from './resource-tree';\nimport MapSrs_ from './srs';\nimport MapCache_ from './cache';\nimport MapCamera_ from './camera';\nimport MapConfig_ from './config';\nimport MapConvert_ from './convert';\nimport MapMeasure_ from './measure';\nimport MapDraw_ from './draw';\nimport MapLoader_ from './loader/loader';\nimport MapPosition_ from './position';\nimport MapRenderSlots_ from './render-slots';\nimport MapStats_ from './stats';\nimport MapSurfaceSequence_ from './surface-sequence';\nimport MapUrl_ from './url';\nimport GpuTexture_ from '../renderer/gpu/texture';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar utils = utils_;\nvar platform = platform_;\nvar MapView = MapView_;\nvar MapSurfaceTree = MapSurfaceTree_;\nvar MapResourceTree = MapResourceTree_;\nvar MapSrs = MapSrs_;\nvar MapCache = MapCache_;\nvar MapCamera = MapCamera_;\nvar MapConfig = MapConfig_;\nvar MapConvert = MapConvert_;\nvar MapMeasure = MapMeasure_;\nvar MapDraw = MapDraw_;\nvar MapLoader = MapLoader_;\nvar MapPosition = MapPosition_;\nvar MapRenderSlots = MapRenderSlots_;\nvar MapStats = MapStats_;\nvar MapSurfaceSequence = MapSurfaceSequence_;\nvar MapUrl = MapUrl_;\nvar GpuTexture = GpuTexture_;\n\n\nvar Map = function(core, mapConfig, path, config, configStorage) {\n    this.config = config || {};\n    this.setConfigParams(config);\n    this.setLoaderParams(mapConfig, configStorage);\n    this.core = core;\n    this.proj4 = this.core.getProj4();\n    this.coreConfig = core.coreConfig;\n    this.killed = false;\n    this.config = config || {};\n    this.loaderSuspended = false;\n\n    this.url = new MapUrl(this, path);\n\n    this.position = new MapPosition(['obj', 0, 0, 'fix', 0,  0, 0, 0,  0, 0]);\n    this.lastPosition = this.position.clone();\n\n    this.srses = {};\n    this.bodies = {};\n    this.referenceFrame = {};\n    this.credits = {};\n    this.creditsByNumber = {};\n    this.surfaces = {};\n    this.virtualSurfaces = {};\n    this.glues = {};\n    this.freeLayers = {};\n    this.boundLayers = {};\n    this.stylesheets = {};\n    this.processingTasks = [];\n    this.processingTasks2 = [];\n    this.geodataProcessors = [];\n\n    this.surfaceSequence = new MapSurfaceSequence(this);\n\n    this.initialView = null;\n    this.currentView = new MapView(this, {});\n    this.currentViewString = '';\n    this.namedViews = {};\n    this.viewCounter = 0;\n    this.srsReady = false;\n    this.surfaceCounter = 0;\n\n    this.freeLayerSequence = [];\n    this.freeLayersHaveGeodata = false;\n\n    this.visibleCredits = {\n        imagery : {},\n        glueImagery : {},\n        mapdata : {}\n    };\n    \n    this.mobile = false;\n    this.metanodeBuffer = new Uint8Array(1024);\n   \n    this.gpuCache = new MapCache(this, this.config.mapGPUCache*1024*1024);\n    this.resourcesCache = new MapCache(this, this.config.mapCache*1024*1024);\n    this.metatileCache = new MapCache(this, this.config.mapMetatileCache*1024*1024);\n\n    this.setupMobileMode(this.config.mapMobileMode);\n    this.setupCache();\n\n    this.loader = new MapLoader(this, this.config.mapDownloadThreads);\n\n    this.renderer = this.core.renderer;\n    this.camera = new MapCamera(this);\n\n    this.stats = new MapStats(this);\n    this.resourcesTree = new MapResourceTree(this);\n   \n    this.mapConfig = new MapConfig(this, mapConfig);\n    this.convert = new MapConvert(this);\n    this.measure = new MapMeasure(this);\n    this.convert.measure = this.measure;\n\n    this.isGeocent = !this.getNavigationSrs().isProjected();\n\n    this.tree = new MapSurfaceTree(this, false);\n    this.mapConfig.afterConfigParsed();\n\n    this.updateCoutner = 0;\n\n    this.dirty = true;\n    this.dirtyCountdown = 0;\n    this.hitMapDirty = true;\n    this.geoHitMapDirty = true;\n\n    this.clickEvent = null;\n    this.hoverEvent = null;\n    this.hoverFeature = null;\n    this.hoverFeatureId = null;\n    this.lastHoverFeature = null;\n    this.lastHoverFeatureId = null;\n    this.hoverFeatureCounter = 0;\n    this.hoverFeatureList = [];\n    \n    this.draw = new MapDraw(this);\n    this.draw.setupDetailDegradation();\n\n    var body = this.referenceFrame.body, c;\n\n    if (body && body.atmosphere) {\n        c = body.atmosphere.colorHorizon;\n        this.draw.atmoColor = [c[0]/255.0, c[1]/255.0, c[2]/255.0, c[3]/255.0];\n        c = body.atmosphere.colorZenith;\n        this.draw.atmoColor2 = [c[0]/255.0, c[1]/255.0, c[2]/255.0, c[3]/255.0];\n        this.draw.atmoHeight = 50000 * (body.atmosphere.thickness / 100000);\n        this.draw.atmoDensity = (body.atmosphere.visibility / 100000) * (100000 / body.atmosphere.thickness);\n    } else {\n        switch(this.referenceFrame.id) {\n            case 'melown2015':\n            case 'earth-qsc':\n                this.draw.atmoColor = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];\n                this.draw.atmoColor2 = [72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0];\n                //this.draw.atmoColor3 = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];\n                this.draw.atmoHeight = 50000;\n                break;\n\n            case 'mars-qsc':\n                this.draw.atmoColor = [255.0/255.0, 187.0/255.0, 157.0/255.0, 1.0];\n                this.draw.atmoColor2 = [255.0/255.0, 155.0/255.0, 113.0/255.0, 1.0];\n                //this.draw.atmoColor3 = [255.0/255.0, 187.0/255.0, 157.0/255.0, 0.5];\n                this.draw.atmoHeight = 25000;\n                this.draw.atmoDensity = 1.0 / 0.25;\n                break;\n        }\n    }\n\n    this.draw.atmoHeightFactor = this.draw.atmoHeight / 50000;\n\n    this.renderSlots = new MapRenderSlots(this);\n    this.renderSlots.addRenderSlot('map', this.drawMap.bind(this), true);\n};\n\n\nMap.prototype.kill = function() {\n    this.killed = true;\n    \n    if (this.tree) {\n        this.tree.kill();\n    }\n\n    for (var key in this.freeLayers) {\n        var layer = this.freeLayers[key];\n        if (layer && layer.tree) {\n            layer.tree.kill();\n        }\n    }\n\n    this.gpuCache.clear();\n    this.resourcesCache.clear();\n    this.metatileCache.clear();\n\n    if (this.renderer != null) {\n        this.renderer.kill();\n        this.renderer = null;\n    }\n};\n\n\nMap.prototype.setupMobileMode = function() {\n    this.mobile = this.config.mapMobileMode;\n\n    if (!this.mobile && this.config.mapMobileModeAutodect) {\n        this.mobile = platform.isMobile();        \n    }\n\n    this.setupCache();\n};\n\n\nMap.prototype.setupCache = function() {\n    if (!this.resourcesCache) {\n        return;\n    }\n\n    var factor = 1 / (this.mobile ? Math.pow(2, Math.max(0,this.config.mapMobileDetailDegradation-1)) : 1);\n    var factor2 = 1 / (this.mobile ? Math.pow(2, this.config.mapMobileDetailDegradation) : 1);\n    factor = (factor + factor2) * 0.5;\n    this.resourcesCache.setMaxCost(this.config.mapCache*1024*1024*factor);\n    this.gpuCache.setMaxCost(this.config.mapGPUCache*1024*1024*factor);\n    this.metatileCache.setMaxCost(this.config.mapMetatileCache*1024*1024*(factor < 0.8 ? 0.5 : 1));\n};\n\n\nMap.prototype.getCoreInterface = function() {\n    return this.core.interface;\n};\n\n\nMap.prototype.getRendererInterface = function() {\n    return this.core.interface.getRendererInterface();\n};\n\n\nMap.prototype.setOption = function(/*key, value*/) {\n};\n\n\nMap.prototype.getOption = function(/*key*/) {\n};\n\n\nMap.prototype.addSrs = function(id, srs) {\n    this.srses[id] = srs;\n};\n\n\nMap.prototype.getSrs = function(srsId) {\n    return this.srses[srsId];\n};\n\n\nMap.prototype.getSrses = function() {\n    return this.getMapKeys(this.srses);\n};\n\n\nMap.prototype.addBody = function(id, body) {\n    this.bodies[id] = body;\n};\n\n\nMap.prototype.getBody = function(id) {\n    return this.bodies[id];\n};\n\n\nMap.prototype.getBodies = function() {\n    return this.getMapKeys(this.bodies);\n};\n\n\nMap.prototype.setReferenceFrame = function(referenceFrame) {\n    this.referenceFrame = referenceFrame;\n};\n\n\nMap.prototype.addCredit = function(id, credit) {\n    this.credits[id] = credit;\n    this.creditsByNumber[credit.id] = credit;\n    credit.key = id;\n};\n\n\nMap.prototype.getCreditByNumber = function(id) {\n    return this.creditsByNumber[id];\n};\n\n\nMap.prototype.getCreditById = function(id) {\n    return this.credits[id];\n};\n\n\nMap.prototype.getCredits = function() {\n    return this.getMapKeys(this.credits);\n};\n\n\nMap.prototype.getVisibleCredits = function() {\n    var imagery = this.visibleCredits.imagery;\n    var glueImagery = this.visibleCredits.glueImagery;\n    var imageryArray = []; \n    var imagerySpecificity = [];\n    var i, li, t, sorted;\n\n    for (var key in glueImagery) {\n        if (!imagery[key]) {\n            imagery[key] = glueImagery[key];\n        }\n    }\n    \n    this.visibleCredits.glueImagery = {};\n    \n    for (key in imagery) {\n        imageryArray.push(key);\n        imagerySpecificity.push(imagery[key]); \n    }\n\n    //sort imagery\n    do {\n        sorted = true;\n        \n        for (i = 0, li = imagerySpecificity.length - 1; i < li; i++) {\n            if (imagerySpecificity[i] < imagerySpecificity[i+1]) {\n                t = imagerySpecificity[i];\n                imagerySpecificity[i] = imagerySpecificity[i+1];\n                imagerySpecificity[i+1] = t;\n                t = imageryArray[i];\n                imageryArray[i] = imageryArray[i+1];\n                imageryArray[i+1] = t;\n                sorted = false;\n            } \n        }\n        \n    } while(!sorted);\n\n    var mapdata = this.visibleCredits.mapdata;\n    var mapdataArray = []; \n    var mapdataSpecificity = []; \n\n    for (key in mapdata) {\n        mapdataArray.push(key);\n        mapdataSpecificity.push(mapdata[key]); \n    }\n    \n    //sort imagery\n    do {\n        sorted = true;\n        \n        for (i = 0, li = mapdataSpecificity.length - 1; i < li; i++) {\n            if (mapdataSpecificity[i] < mapdataSpecificity[i+1]) {\n                t = mapdataSpecificity[i];\n                mapdataSpecificity[i] = mapdataSpecificity[i+1];\n                mapdataSpecificity[i+1] = t;\n                t = mapdataArray[i];\n                mapdataArray[i] = mapdataArray[i+1];\n                mapdataArray[i+1] = t;\n                sorted = false;\n            } \n        }\n        \n    } while(!sorted);\n\n    return {\n        '3D' : [], \n        'imagery' : imageryArray, \n        'mapdata' : mapdataArray \n    };\n};\n\n\nMap.prototype.addSurface = function(id, surface) {\n    this.surfaces.push(surface);\n    surface.index = this.surfaces.length - 1; \n};\n\n\nMap.prototype.getSurface = function(id) {\n    return this.searchArrayById(this.surfaces, id);\n};\n\n\nMap.prototype.getSurfaces = function() {\n    var keys = [];\n    for (var i = 0, li = this.surfaces.length; i < li; i++) {\n        keys.push(this.surfaces[i].id);\n    }\n    return keys;\n};\n\n\nMap.prototype.addGlue = function(id, glue) {\n    this.glues[id] = glue;\n};\n\n\nMap.prototype.getGlue = function(id) {\n    return this.glues[id];\n};\n\n\nMap.prototype.addBoundLayer = function(id, layer) {\n    this.boundLayers[id] = layer;\n};\n\n\nMap.prototype.setBoundLayerOptions = function(id, options) {\n    if (this.boundLayers[id]) {\n        this.boundLayers[id].setOptions(options);\n    }\n};\n\n\nMap.prototype.getBoundLayerOptions = function(id) {\n    if (this.boundLayers[id]) {\n        return this.boundLayers[id].getOptions();\n    }\n    \n    return null;\n};\n\n\nMap.prototype.removeBoundLayer = function(id) {\n    if (this.boundLayers[id]) {\n        this.boundLayers[id].kill();\n        this.boundLayers[id] = null;\n    }\n};\n\n\nMap.prototype.getBoundLayerByNumber = function(number) {\n    var layers = this.boundLayers;\n    for (var key in layers) {\n        if (layers[key].numberId == number) {\n            return layers[key];\n        }\n    }\n\n    return null;\n};\n\n\nMap.prototype.getBoundLayerById = function(id) {\n    return this.boundLayers[id];\n};\n\n\nMap.prototype.getBoundLayers = function() {\n    return this.getMapKeys(this.boundLayers);\n};\n\n\nMap.prototype.addFreeLayer = function(id, layer) {\n    this.freeLayers[id] = layer;\n    this.setView(this.getView());\n    this.markDirty();\n};\n\n\nMap.prototype.removeFreeLayer = function(id) {\n    if (this.freeLayers[id]) {\n        this.freeLayers[id].kill();\n        this.freeLayers[id] = null;\n        this.setView(this.getView());\n        this.markDirty();\n    }\n};\n\n\nMap.prototype.setFreeLayerOptions = function(id, options) {\n    if (this.freeLayers[id]) {\n        this.freeLayers[id].setOptions(options);\n    }\n};\n\n\nMap.prototype.getFreeLayerOptions = function(id) {\n    if (this.freeLayers[id]) {\n        return this.freeLayers[id].getOptions();\n    }\n    \n    return null;\n};\n\n\nMap.prototype.getFreeLayer = function(id) {\n    return this.freeLayers[id];\n    //return this.searchArrayById(this.freeLayers, id);\n};\n\n\nMap.prototype.getFreeLayers = function() {\n    var keys = [];\n    for (var key in this.freeLayers) {\n        keys.push(key);\n    }\n    return keys;    \n};\n\n\nMap.prototype.getMapsSrs = function(srs) {\n    if (srs == null) {\n        return null;\n    }\n\n    //is it proj4 string?\n    if (srs.indexOf('+proj') != -1) {\n        return new MapSrs(this, {'srsDef':srs});\n    }\n\n    //search existing srs\n    return this.srses[srs];\n};\n\n\nMap.prototype.addNamedView = function(id, view) {\n    this.namedViews[id] = view;\n};\n\n\nMap.prototype.getNamedView = function(id) {\n    return this.namedViews[id];\n};\n\n\nMap.prototype.getNamedViews = function() {\n    return this.getMapKeys(this.namedViews);\n};\n\n\nMap.prototype.setView = function(view, forceRefresh, posToFixed) {\n    if (view == null) {\n        return;\n    }\n\n    if (posToFixed && this.convert) {\n        var p = this.getPosition();\n        p = this.convert.convertPositionHeightMode(p, 'fix', true);\n        this.setPosition(p);\n    }\n    \n    if (typeof view === 'string') {\n        view = view.trim();\n        \n        if (view.charAt(0) == '{') {\n            try {\n                view = JSON.parse(view);\n            } catch(e){\n                return;            \n            }\n        } else {\n            view = this.getNamedView(view);\n\n            if (!view) {\n                return;\n            }\n            \n            //view = JSON.parse(JSON.stringify(view));\n            view = view.getInfo();\n        }\n    }\n\n    //construct view string without options\n    var string = {};\n\n    if (view.surfaces) {\n        string.surfaces = view.surfaces;\n    }\n\n    if (view.freeLayers) {\n        string.freeLayers = view.freeLayers;\n    }\n\n    string = JSON.stringify(string);\n\n    var renderer = this.renderer;\n\n    //process options\n    if (view.options) {\n        var se = view.options.superelevation;\n\n        if (se && se[0] && se[1] && se[0].length >=2 && se[1].length >=2) {\n            renderer.setSuperElevationState(true);\n            renderer.setSuperElevation(se[0][0], se[1][0], se[0][1], se[1][1]);\n        } else {\n            renderer.setSuperElevationState(false);\n        }\n    } else {\n        renderer.setSuperElevationState(false);        \n    }\n\n    if (string != this.currentViewString || forceRefresh) {\n        this.currentView.parse(view);\n        this.currentViewString = string;\n        this.viewCounter++;  //this also cause rest of geodata\n        renderer.draw.clearJobHBuffer(); //hotfix - reset hysteresis buffer\n    }\n\n    this.surfaceSequence.generateSurfaceSequence();\n    this.surfaceSequence.generateBoundLayerSequence();\n\n    this.refreshFreelayesInView();\n\n    this.markDirty();\n};\n\n\nMap.prototype.addStylesheet = function(id, style) {\n    this.stylesheets[id] = style;\n};\n\n\nMap.prototype.getStylesheet = function(id) {\n    return this.stylesheets[id];\n    //return this.searchArrayById(this.stylesheets, id);\n};\n\n\nMap.prototype.getStylesheets = function() {\n    var keys = [];\n\n    for (var key in this.stylesheets) {\n        keys.push(key);\n    }\n    return keys;\n};\n\n\nMap.prototype.getStylesheetData = function(id) {\n    var stylesheet = this.getStylesheet(id);\n\n    if (stylesheet) {\n        return {'url':stylesheet.url, 'data': stylesheet.data};\n    }\n    \n    return {'url':null, 'data':{}};\n};\n\n\nMap.prototype.setStylesheetData = function(id, data) {\n    var stylesheet = this.getStylesheet(id);\n    \n    //if (stylesheet) {\n      //  stylesheet.data = data;\n    //}\n\n    this.renderer.draw.clearJobHBuffer();\n\n    if (stylesheet) {\n        if (data) {\n            stylesheet.setData(data);\n        }\n\n        for (var key in this.freeLayers) {\n            var freeLayer = this.getFreeLayer(key);\n            if (freeLayer && freeLayer.geodata && freeLayer.stylesheet == stylesheet) {\n                \n                if (freeLayer.geodataProcessor) {\n                    freeLayer.geodataProcessor.setStylesheet(freeLayer.stylesheet);\n                }\n\n                freeLayer.geodataCounter++;\n            }\n        }\n    }\n\n    this.markDirty();\n        \n    //TODO: reset geodatview in free layers\n};\n\n\nMap.prototype.getView = function() {\n    return this.currentView.getInfo();\n};\n\n\nMap.prototype.refreshFreelayesInView = function() {\n    var freeLayers = this.currentView.freeLayers;\n    this.freeLayerSequence = [];\n\n    for (var key in freeLayers) {\n        var freeLayer = this.getFreeLayer(key);\n        \n        if (freeLayer) {\n            \n            freeLayer.zFactor = freeLayers[key]['depthOffset'];\n            freeLayer.maxLod = freeLayers[key]['maxLod'];\n            \n            this.freeLayerSequence.push(freeLayer);\n            \n            if (freeLayers[key]['style']) {\n                freeLayer.setStyle(freeLayers[key]['style']);\n            } else {\n                freeLayer.setStyle(freeLayer.originalStyle);\n            }\n            \n            //TODO: generate bound layer seqence for      \n        }\n    }\n};\n\nMap.prototype.refreshView = function() {\n    this.viewCounter++;\n    this.surfaceSequence.generateSurfaceSequence();\n    this.surfaceSequence.generateBoundLayerSequence();\n    this.refreshFreelayesInView();\n    this.markDirty();\n};\n\n\nMap.prototype.searchArrayIndexById = function(array, id) {\n    for (var i = 0, li = array.length; i < li; i++) {\n        if (array[i].id == id) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\n\nMap.prototype.searchArrayById = function(array, id) {\n    for (var i = 0, li = array.length; i < li; i++) {\n        if (array[i].id == id) {\n            return array[i];\n        }\n    }\n\n    return null;\n};\n\n\nMap.prototype.searchMapByInnerId = function(map, id) {\n    for (var key in map) {\n        if (map[key].id == id) {\n            return map[key];\n        }\n    }\n\n    return null;\n};\n\n\nMap.prototype.getMapKeys = function(map) {\n    var keys = [];\n    for (var key in map) {\n        keys.push(key);\n    }\n\n    return keys;\n};\n\n\nMap.prototype.getMapIds = function(map) {\n    var keys = [];\n    for (var key in map) {\n        keys.push(key.id);\n    }\n\n    return keys;\n};\n\n\nMap.prototype.setPosition = function(pos) {\n    this.position = new MapPosition(pos);\n    this.markDirty();\n};\n\n\nMap.prototype.isReferenceFrameReady = function() {\n    return this.referenceFrame.model.physicalSrs.isReady() &&\n           this.referenceFrame.model.publicSrs.isReady() &&\n           this.referenceFrame.model.navigationSrs.isReady();\n};\n\n\nMap.prototype.getPhysicalSrs = function() {\n    return this.referenceFrame.model.physicalSrs;\n};\n\n\nMap.prototype.getPublicSrs = function() {\n    return this.referenceFrame.model.publicSrs;\n};\n\n\nMap.prototype.getNavigationSrs = function() {\n    return this.referenceFrame.model.navigationSrs;\n};\n\n\nMap.prototype.getPosition = function() {\n    return this.position.clone();\n};\n\n\nMap.prototype.setLoaderParams = function(mapConfig, configStorage) {\n    var sources = [];\n\n    if (mapConfig && mapConfig['browserOptions']) {\n        sources.push(mapConfig['browserOptions']);\n    }\n\n    if (configStorage) {\n        sources.push(configStorage);\n    }\n\n    for (var i = 0, li = sources.length; i < li; i++) {\n        var source = sources[i];\n        for (var key in source) {\n            switch(key) {\n                case 'mapSeparateLoader':\n                case 'mapGeodataBinaryLoad':\n                case 'mapPackLoaderEvents':\n                case 'mapParseMeshInWorker':\n                case 'mapPackGeodataEvents':\n                    this.setConfigParam(key, source[key]);\n                    break;\n            }\n        }\n    }\n};\n\n\nMap.prototype.setConfigParams = function(params) {\n    if (typeof params === 'object' && params !== null) {\n        for (var key in params) {\n            this.setConfigParam(key, params[key]);\n        }\n    }\n};\n\n\nMap.prototype.setConfigParam = function(key, value) {\n    switch (key) {\n    case 'map':                           this.config.map = utils.validateString(value, null); break;\n    case 'mapCache':                      this.config.mapCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 900); this.setupCache(); break;\n    case 'mapGPUCache':                   this.config.mapGPUCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 360); this.setupCache(); break;\n    case 'mapMetatileCache':              this.config.mapMetatileCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 60); this.setupCache(); break;\n    case 'mapTexelSizeFit':               this.config.mapTexelSizeFit = utils.validateNumber(value, 0.0001, Number.MAXINTEGER, 1.1); break;\n    case 'mapDownloadThreads':            this.config.mapDownloadThreads = utils.validateNumber(value, 1, Number.MAXINTEGER, 6); break;\n    case 'mapMaxProcessingTime':          this.config.mapMaxProcessingTime = utils.validateNumber(value, 1, Number.MAXINTEGER, 1000/20); break;\n    case 'mapMaxGeodataProcessingTime':   this.config.mapMaxGeodataProcessingTime = utils.validateNumber(value, 1, Number.MAXINTEGER, 10); break;\n    case 'mapMobileMode':                 this.config.mapMobileMode = utils.validateBool(value, false); this.setupMobileMode(); break;\n    case 'mapMobileModeAutodect':         this.config.mapMobileModeAutodect = utils.validateBool(value, false); break;\n    case 'mapMobileDetailDegradation':    this.config.mapMobileDetailDegradation = utils.validateNumber(value, 1, Number.MAXINTEGER, 2); break;\n    case 'mapNavSamplesPerViewExtent':    this.config.mapNavSamplesPerViewExtent = utils.validateNumber(value, 0.00000000001, Number.MAXINTEGER, 4); break;\n    case 'mapFog':                        this.config.mapFog = utils.validateBool(value, false); if(this.draw){ this.draw.debug.drawFog = this.config.mapFog; this.dirty = true; } break;\n    case 'mapFlatshade':                  this.config.mapFlatshade = utils.validateBool(value, false); if(this.draw){ this.draw.debug.drawWireframe = this.config.mapFlatshade ? 3 : 0; this.dirty = true; } break;\n    case 'mapIgnoreNavtiles':             this.config.mapIgnoreNavtiles = utils.validateBool(value, false); break;\n    case 'mapAllowHires':                 this.config.mapAllowHires = utils.validateBool(value, true); break;\n    case 'mapAllowLowres':                this.config.mapAllowLowres = utils.validateBool(value, true); break;\n    case 'mapAllowSmartSwitching':        this.config.mapAllowSmartSwitching = utils.validateBool(value, true); break;\n    case 'mapDisableCulling':             this.config.mapDisableCulling = utils.validateBool(value, false); break;\n    case 'mapPreciseCulling':             this.config.mapPreciseCulling = utils.validateBool(value, false); break;\n    case 'mapHeightLodBlend':             this.config.mapHeightLodBlend = utils.validateBool(value, true); break;\n    case 'mapHeightNodeBlend':            this.config.mapHeightNodeBlend = utils.validateBool(value, true); break;\n    case 'mapBasicTileSequence':          this.config.mapBasicTileSequence = utils.validateBool(value, true); break;\n    case 'mapSmartNodeParsing':           this.config.mapSmartNodeParsing = utils.validateBool(value, true); break;\n    case 'mapStoreLoadStats':             this.config.mapStoreLoadStats = utils.validateBool(value, true);  if (this.draw && this.draw.replay) this.draw.replay.storeLoaded = this.config.mapStoreLoadStats; break;\n    case 'mapXhrImageLoad':               this.config.mapXhrImageLoad = utils.validateBool(value, false); break;\n    case 'mapLoadMode':                   this.config.mapLoadMode = utils.validateString(value, 'topdown'); break;\n    case 'mapGeodataLoadMode':            this.config.mapGeodataLoadMode = utils.validateString(value, 'fit'); break;\n    case 'mapGridMode':                   this.config.mapGridMode = utils.validateString(value, 'linear'); break;\n    case 'mapGridSurrogatez':             this.config.mapGridSurrogatez = utils.validateBool(value, false); break;\n    case 'mapGridUnderSurface':           this.config.mapGridUnderSurface = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;\n    case 'mapGridTextureLevel':           this.config.mapGridTextureLevel = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, -1); break;\n    case 'mapGridTextureLayer':           this.config.mapGridTextureLayer = utils.validateString(value, ''); break;\n    case 'mapPreciseBBoxTest':            this.config.mapPreciseBBoxTest = utils.validateBool(value, true); break;\n    case 'mapPreciseDistanceTest':        this.config.mapPreciseDistanceTest = utils.validateBool(value, false); break;\n    case 'mapHeightfiledWhenUnloaded':    this.config.mapHeightfiledWhenUnloaded = utils.validateBool(value, false); break;\n    case 'mapForceMetatileV3':            this.config.mapForceMetatileV3 = utils.validateBool(value, false); break;\n    case 'mapVirtualSurfaces':            this.config.mapVirtualSurfaces = utils.validateBool(value, true); break;\n    case 'mapDegradeHorizon':             this.config.mapDegradeHorizon = utils.validateBool(value, true); break;\n    case 'mapDegradeHorizonParams':       this.config.mapDegradeHorizonParams = utils.validateNumberArray(value, 4, [0,1,1,1], [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], [1, 3000, 15000, 7000]); break;\n    case 'mapRefreshCycles':              this.config.mapRefreshCycles = utils.validateNumber(value, 0, Number.MAXINTEGER, 3); break;\n    case 'mapDefaultFont':                this.config.mapDefaultFont = utils.validateString(value, ''); break;\n    case 'mapMetricUnits':                this.config.mapMetricUnits = utils.validateBool(value, true); break;\n    case 'mapLanguage':                   this.config.mapLanguage = utils.validateString(value, 'en'); break;\n    case 'mapNoTextures':                 this.config.mapNoTextures = this.config.mapDisableCulling = utils.validateBool(value, false); break;\n    case 'mapForceFrameTime':             this.config.mapForceFrameTime = utils.validateNumber(value, -1, Number.MAXINTEGER, 0); break;\n    case 'mapForcePipeline':              this.config.mapForcePipeline = utils.validateNumber(value, 0, Number.MAXINTEGER, 0); break;\n    case 'mapFeatureGridCells':           this.config.mapFeatureGridCells = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;\n    case 'mapFeaturesPerSquareInch':      this.config.mapFeaturesPerSquareInch = utils.validateNumber(value, 0.000001, Number.MAXINTEGER, 0); break;\n    case 'mapFeaturesSortByTop':          this.config.mapFeaturesSortByTop = utils.validateBool(value, false); break;\n    case 'mapFeaturesReduceParams':       this.config.mapFeaturesReduceParams = value; break;\n    case 'mapLogGeodataStyles':           this.config.mapLogGeodataStyles = utils.validateBool(value, true); break;\n    case 'map16bitMeshes':                this.config.map16bitMeshes = utils.validateBool(value, false); break;\n    case 'mapOnlyOneUVs':                 this.config.mapOnlyOneUVs = utils.validateBool(value, false); break;\n    case 'mapIndexBuffers':               this.config.mapIndexBuffers = utils.validateBool(value, false); break;\n    case 'mapSoftViewSwitch':             this.config.mapSoftViewSwitch = utils.validateBool(value, true); break;\n    case 'mapAsyncImageDecode':           this.config.mapAsyncImageDecode = (utils.validateBool(value, false) && (typeof createImageBitmap !== 'undefined')) ? true : false; break;\n    case 'mapFeatureStickMode':           this.config.mapFeatureStickMode = utils.validateNumberArray(value, 2, [0,1], [Number.MAX_VALUE, Number.MAX_VALUE], [0, 1]); break;\n    case 'mapSeparateLoader':             this.config.mapSeparateLoader = utils.validateBool(value, true); break;\n    case 'mapGeodataBinaryLoad':          this.config.mapGeodataBinaryLoad = utils.validateBool(value, true); break;\n    case 'mapPackLoaderEvents':           this.config.mapPackLoaderEvents = utils.validateBool(value, true); break;\n    case 'mapParseMeshInWorker':          this.config.mapParseMeshInWorker = utils.validateBool(value, true); break;\n    case 'mapPackGeodataEvents':          this.config.mapPackGeodataEvents = utils.validateBool(value, true); break;\n    case 'mapSortHysteresis':             this.config.mapSortHysteresis = utils.validateBool(value, false); break;\n    case 'mapHysteresisWait':             this.config.mapHysteresisWait = utils.validateNumber(value, 0, Number.MAXINTEGER, 0); break;\n    case 'mapBenevolentMargins':          this.config.mapBenevolentMargins = utils.validateBool(value, false); break;\n    case 'mapCheckTextureSize':           this.config.mapCheckTextureSize = utils.validateBool(value, false); break;\n    case 'mapTraverseToMeshNode':         this.config.mapTraverseToMeshNode = utils.validateBool(value, true); break;\n    case 'mapNormalizeOctantTexelSize':   this.config.mapNormalizeOctantTexelSize = utils.validateBool(value, true); break;\n    case 'mapDMapSize':                   this.config.mapDMapSize = utils.validateNumber(value, 16, Number.MAXINTEGER, 512); break; \n    case 'mapDMapMode':                   this.config.mapDMapMode = utils.validateNumber(value, 1, Number.MAXINTEGER, 1); break;\n    case 'mapSplitSpace':                 this.config.mapSplitSpace = value; break;\n    case 'mario':                         this.config.mario = utils.validateBool(value, true); break;\n    case 'mapFeaturesReduceMode':         \n        value = utils.validateString(value, 'scr-count4');\n        if (value == 'auto') value = 'scr-count2';\n        if (value == 'legacy') value = 'scr-count2';\n        if (value == 'gridcells') value = 'scr-count4';\n        if (value == 'singlepass') value = 'scr-count5';\n        if (value == 'margin') value = 'scr-count6';\n        //if (value == 'margin') value = 'scr-count7';\n        this.config.mapFeaturesReduceMode = value;\n        break;\n\n    }\n};\n\n\nMap.prototype.getConfigParam = function(key) {\n    switch (key) {\n    case 'map':                           return this.config.map;\n    case 'mapCache':                      return this.config.mapCache;\n    case 'mapGPUCache':                   return this.config.mapGPUCache;\n    case 'mapMetatileCache':              return this.config.mapMetatileCache;\n    case 'mapTexelSizeFit':               return this.config.mapTexelSizeFit;\n    case 'mapDownloadThreads':            return this.config.mapDownloadThreads;\n    case 'mapMaxProcessingTime':          return this.config.mapMaxProcessingTime;\n    case 'mapMaxGeodataProcessingTime':   return this.config.mapMaxGeodataProcessingTime;\n    case 'mapMobileMode':                 return this.config.mapMobileMode;\n    case 'mapMobileModeAutodect':         return this.config.mapMobileModeAutodect;\n    case 'mapMobileDetailDegradation':    return this.config.mapMobileDetailDegradation;\n    case 'mapNavSamplesPerViewExtent':    return this.config.mapNavSamplesPerViewExtent;\n    case 'mapFog':                        return this.config.mapFog;\n    case 'mapFlatshade':                  return this.config.mapFlatshade;\n    case 'mapIgnoreNavtiles':             return this.config.mapIgnoreNavtiles;\n    case 'mapAllowHires':                 return this.config.mapAllowHires;\n    case 'mapAllowLowres':                return this.config.mapAllowLowres;\n    case 'mapAllowSmartSwitching':        return this.config.mapAllowSmartSwitching;\n    case 'mapDisableCulling':             return this.config.mapDisableCulling;\n    case 'mapPreciseCulling':             return this.config.mapPreciseCulling;\n    case 'mapHeightLodBlend':             return this.config.mapHeightLodBlend;\n    case 'mapHeightNodeBlend':            return this.config.mapHeightNodeBlend;\n    case 'mapBasicTileSequence':          return this.config.mapBasicTileSequence;\n    case 'mapSmartNodeParsing':           return this.config.mapSmartNodeParsing;\n    case 'mapStoreLoadStats':             return this.config.mapStoreLoadStats;\n    case 'mapXhrImageLoad':               return this.config.mapXhrImageLoad;\n    case 'mapLoadMode':                   return this.config.mapLoadMode;\n    case 'mapGeodataLoadMode':            return this.config.mapGeodataLoadMode;\n    case 'mapGridMode':                   return this.config.mapGridMode;\n    case 'mapGridSurrogatez':             return this.config.mapGridSurrogatez;\n    case 'mapGridUnderSurface':           return this.config.mapGridUnderSurface;\n    case 'mapGridTextureLevel':           return this.config.mapGridTextureLevel;\n    case 'mapGridTextureLayer':           return this.config.mapGridTextureLayer;\n    case 'mapPreciseBBoxTest':            return this.config.mapPreciseBBoxTest;\n    case 'mapPreciseDistanceTest':        return this.config.mapPreciseDistanceTest;\n    case 'mapHeightfiledWhenUnloaded':    return this.config.mapHeightfiledWhenUnloaded;\n    case 'mapForceMetatileV3':            return this.config.mapForceMetatileV3;\n    case 'mapVirtualSurfaces':            return this.config.mapVirtualSurfaces;\n    case 'mapDegradeHorizon':             return this.config.mapDegradeHorizon;\n    case 'mapDegradeHorizonParams':       return this.config.mapDegradeHorizonParams;\n    case 'mapRefreshCycles':              return this.config.mapRefreshCycles;\n    case 'mapDefaultFont':                return this.config.mapDefaultFont;\n    case 'mapMetricUnits':                return this.config.mapMetricUnits;\n    case 'mapLanguage':                   return this.config.mapLanguage;\n    case 'mapNoTextures':                 return this.config.mapNoTextures;\n    case 'mapForceFrameTime':             return this.config.mapForceFrameTime;\n    case 'mapForcePipeline':              return this.config.mapForcePipeline;\n    case 'mapFeatureGridCells':           return this.config.mapFeatureGridCells;\n    case 'mapFeaturesPerSquareInch':      return this.config.mapFeaturesPerSquareInch;\n    case 'mapFeaturesSortByTop':          return this.config.mapFeaturesSortByTop;\n    case 'mapFeaturesReduceMode':         return this.config.mapFeaturesReduceMode;\n    case 'mapFeaturesReduceParams':       return this.config.mapFeaturesReduceParams;\n    case 'mapLogGeodataStyles':           return this.config.mapLogGeodataStyles;\n    case 'map16bitMeshes':                return this.config.map16bitMeshes;\n    case 'mapOnlyOneUVs':                 return this.config.mapOnlyOneUVs;\n    case 'mapIndexBuffers':               return this.config.mapIndexBuffers;\n    case 'mapSoftViewSwitch':             return this.config.mapSoftViewSwitch;\n    case 'mapAsyncImageDecode':           return this.config.mapAsyncImageDecode;\n    case 'mapFeatureStickMode':           return this.config.mapFeatureStickMode;\n    case 'mapSeparateLoader':             return this.config.mapSeparateLoader;\n    case 'mapGeodataBinaryLoad':          return this.config.mapGeodataBinaryLoad;\n    case 'mapPackLoaderEvents':           return this.config.mapPackLoaderEvents;\n    case 'mapParseMeshInWorker':          return this.config.mapParseMeshInWorker;\n    case 'mapPackGeodataEvents':          return this.config.mapPackGeodataEvents;\n    case 'mapSortHysteresis':             return this.config.mapSortHysteresis;\n    case 'mapHysteresisWait':             return this.config.mapHysteresisWait;\n    case 'mapBenevolentMargins':          return this.config.mapBenevolentMargins;\n    case 'mapDMapSize':                   return this.config.mapDMapSize; \n    case 'mapDMapMode':                   return this.config.mapDMapMode;\n    case 'mario':                         return this.config.mario;\n    }\n};\n\n\nMap.prototype.click = function(screenX, screenY, state) {\n    this.clickEvent = [screenX, screenY, state];\n};\n\n\nMap.prototype.hover = function(screenX, screenY, persistent, state) {\n    this.hoverEvent = [screenX, screenY, persistent, state];\n};\n\n\nMap.prototype.markDirty = function() {\n    this.dirty = true;\n    this.hitMapDirty = true;\n    this.geoHitMapDirty = true;\n};\n\n\nMap.prototype.getScreenRay = function(screenX, screenY) {\n    return this.renderer.getScreenRay(screenX, screenY);\n};\n\n\nMap.prototype.renderToImage = function(texture) {\n    //var renderer = this.renderer;\n    var canvas = this.renderer.gpu.canvas;\n    var w = canvas.width;\n    var h = canvas.height;\n    var w2 = utils.fitToPowerOfTwo(w);\n    var h2 = utils.fitToPowerOfTwo(h);\n\n    var data = new Uint8Array( w2 * h2 * 4 );\n\n    var texture = new GpuTexture(this.renderer.gpu);\n    texture.createFromData(w2, h2, data);\n    texture.createFramebuffer(w2, h2);\n\n    this.draw.drawToTexture(texture);\n\n    data = texture.readFramebufferPixels(0, 0, w, h);\n\n    texture.kill();\n\n    //flip vertically\n    var data2 = new Uint8Array( w * h * 4 );\n    for (var y = 0; y < h; y++) {\n        var index = y * w * 4;\n        var index2 = (h - y - 1) * w * 4; \n\n        for (var x = 0; x < w; x++) {\n            data2[index2] = data[index];\n            data2[index2+1] = data[index+1];\n            data2[index2+2] = data[index+2];\n            data2[index2+3] = data[index+3];\n            index += 4;\n            index2 += 4;\n        }\n    }\n\n    return { 'width': w, 'height': h, 'data': data2};\n};\n\n\nMap.prototype.getScreenDepth = function(screenX, screenY, useFallback) {\n\n    if (useFallback) {\n\n        var cameraPos = this.camera.position;\n        var ray = this.renderer.getScreenRay(screenX, screenY), a, d;\n\n        if (this.getNavigationSrs().isProjected()) { //plane fallback\n            var planePos = [0,0,Math.min(-1000,this.referenceFrame.getGlobalHeightRange()[0])];\n            var planeNormal = [0,0,1];\n\n            d = vec3.dot(planeNormal, ray); //minification is wrong there\n            a = [planePos[0] - cameraPos[0], planePos[1] - cameraPos[1], planePos[2] - cameraPos[2]];\n            t = vec3.dot(a, planeNormal) / d;\n\n            if (t >= 0) {\n                return [true, t];\n            } else {\n                return [false, 1];\n            }\n\n        } else { //elipsoid fallback\n            var navigationSrsInfo = this.getNavigationSrs().getSrsInfo();\n            var planetRadius = navigationSrsInfo['b'] + this.referenceFrame.getGlobalHeightRange()[0];\n        \n            var offset = [cameraPos[0], cameraPos[1], cameraPos[2]];\n            a = vec3.dot(ray, ray); //minification is wrong there\n            var b = 2 * vec3.dot(ray, offset);\n            var c = vec3.dot(offset, offset) - planetRadius * planetRadius;\n            d = b * b - 4 * a * c;\n            \n            if (d > 0) {\n                d = Math.sqrt(d);\n                var t1 = (-b - d) / (2*a);\n                var t2 = (-b + d) / (2*a);\n                var t = (t1 < t2) ? t1 : t2;\n\n                return [true, t];\n            } else {\n                return [false, 1];\n            }\n        }\n\n    } else {\n\n        if (this.hitMapDirty) {\n            var tmp1 = this.draw.ndcToScreenPixel;\n\n            this.draw.drawHitmap();\n\n            this.draw.ndcToScreenPixel = tmp1;\n\n            var width = this.renderer.curSize[0], height = this.renderer.curSize[1];\n\n            var m = new Float32Array(16);\n            m[0] = 2.0/width; m[1] = 0; m[2] = 0; m[3] = 0;\n            m[4] = 0; m[5] = -2.0/height; m[6] = 0; m[7] = 0;\n            m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;\n            m[12] = -width*0.5*m[0]; m[13] = -height*0.5*m[5]; m[14] = 0; m[15] = 1;\n\n            this.renderer.imageProjectionMatrix = m;\n            this.renderer.camera.update();\n        }\n\n        var res = this.renderer.getDepth(screenX, screenY);\n    }\n\n    return res;\n};\n\n\nMap.prototype.getHitCoords = function(screenX, screenY, mode, lod) {\n    if (this.hitMapDirty) {\n        this.draw.drawHitmap();\n    }\n\n    var cameraSpaceCoords = this.renderer.hitTest(screenX, screenY);\n    \n    var fallbackUsed = false; \n    var cameraPos = this.camera.position;\n    var worldPos;\n\n    var ray = cameraSpaceCoords[4], a, d;\n\n    if (this.getNavigationSrs().isProjected()) { //plane fallback\n        var planePos = [0,0,Math.min(-1000,this.referenceFrame.getGlobalHeightRange()[0])];\n        var planeNormal = [0,0,1];\n\n        d = vec3.dot(planeNormal, ray); //minification is wrong there\n        //if (d > 1e-6) {\n        a = [planePos[0] - cameraPos[0], planePos[1] - cameraPos[1], planePos[2] - cameraPos[2]];\n        t = vec3.dot(a, planeNormal) / d;\n            \n            //var t = (vec3.dot(cameraPos, planeNormal) + (-500)) / d;            \n        if (t >= 0) {\n            if (!cameraSpaceCoords[3] || t < cameraSpaceCoords[5]) {\n                worldPos = [ (ray[0] * t) + cameraPos[0],\n                    (ray[1] * t) + cameraPos[1],\n                    (ray[2] * t) + cameraPos[2] ];\n    \n                fallbackUsed = true;\n            }\n        }\n        //}\n\n    } else /*if (false)*/ { //elipsoid fallback\n        var navigationSrsInfo = this.getNavigationSrs().getSrsInfo();\n        var planetRadius = navigationSrsInfo['b'] + this.referenceFrame.getGlobalHeightRange()[0];\n    \n        var offset = [cameraPos[0], cameraPos[1], cameraPos[2]];\n        a = vec3.dot(ray, ray); //minification is wrong there\n        var b = 2 * vec3.dot(ray, offset);\n        var c = vec3.dot(offset, offset) - planetRadius * planetRadius;\n        d = b * b - 4 * a * c;\n        \n        if (d > 0) {\n            d = Math.sqrt(d);\n            var t1 = (-b - d) / (2*a);\n            var t2 = (-b + d) / (2*a);\n            var t = (t1 < t2) ? t1 : t2;\n\n            //console.log(\"hit: \" + t + \",   \" + cameraSpaceCoords[5]);\n            \n            if (!cameraSpaceCoords[3] || t < cameraSpaceCoords[5]) {\n                worldPos = [ (ray[0] * t) + cameraPos[0],\n                    (ray[1] * t) + cameraPos[1],\n                    (ray[2] * t) + cameraPos[2] ];\n\n                fallbackUsed = true;\n            }\n        }   \n    }\n    \n    if (!cameraSpaceCoords[3] && !fallbackUsed) {\n        return null;\n    }\n    \n    if (!fallbackUsed) {\n        worldPos = [ cameraSpaceCoords[0] + cameraPos[0],\n            cameraSpaceCoords[1] + cameraPos[1],\n            cameraSpaceCoords[2] + cameraPos[2] ];\n    }\n\n    var navCoords = this.convert.convertCoords(worldPos, 'physical', 'navigation');\n\n    if (this.renderer.useSuperElevation) {\n        navCoords[2] = this.renderer.getUnsuperElevatedHeight(navCoords[2]);\n    }\n\n    if (mode == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(navCoords, 100, this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(navCoords, lod);\n        navCoords[2] -= surfaceHeight[0]; \n    }\n\n    return navCoords;\n};\n\n\nMap.prototype.hitTestGeoLayers = function(screenX, screenY, mode) {\n    if (this.geoHitMapDirty) {\n        if (this.freeLayersHaveGeodata) {\n            this.draw.drawGeodataHitmap();\n        }\n    }\n\n    if (!this.freeLayersHaveGeodata) {\n        this.lastHoverFeature = null;\n        this.lastHoverFeatureId = null;\n        this.hoverFeature = null;\n        this.hoverFeatureId = null;\n\n        return [null, false, []];\n    }\n\n    var res = this.renderer.hitTestGeoLayers(screenX, screenY);\n    var relatedEvents, elementIndex;\n\n    if (res[0]) { //do we hit something?\n        //console.log(JSON.stringify([id, JSON.stringify(this.hoverFeatureList[id])]));\n       \n        var id = (res[1]) + (res[2]<<8);\n\t\t\n        var feature = this.hoverFeatureList[id];\n\n        if (!feature) {\n            return [null, false, [], elementIndex];\n        }\n\n        if (feature[6]) { //advanced hit feature?\n            res = this.renderer.hitTestGeoLayers(screenX, screenY, true);\n        \n            if (res[0]) { //do we hit something?\n                elementIndex = (res[1]) + (res[2]<<8);\n            }\n        }\n\n        if (mode == 'hover') {\n            this.lastHoverFeature = this.hoverFeature;\n            this.lastHoverFeatureId = this.hoverFeatureId;\n            \n            if (feature && feature[3]) {\n                this.hoverFeature = feature;\n                this.hoverFeatureId = (feature != null) ? feature[0]['#id'] : null;\n            } else {\n                this.hoverFeature = null;\n                this.hoverFeatureId = null;\n            }\n\n            relatedEvents = [];\n\n            if (this.hoverFeatureId != this.lastHoverFeatureId) {\n                if (this.lastHoverFeatureId != null) {\n                    relatedEvents.push(['leave', this.lastHoverFeature, this.lastHoverFeatureId]);\n                }\n\n                if (this.hoverFeatureId != null) {\n                    relatedEvents.push(['enter', this.hoverFeature, this.hoverFeatureId]);\n                }\n\n                this.dirty = true;\n            }\n\n            if (this.hoverFeature != null && this.hoverFeature[3]) {\n                return [this.hoverFeature, true, relatedEvents, elementIndex];\n            } else {\n                return [null, false, relatedEvents, elementIndex];\n            }\n        }\n\n        if (mode == 'click') {\n            if (feature != null && feature[2]) {\n                return [feature, true, [], elementIndex];\n            } else {\n                return [null, false, [], elementIndex];\n            }\n        }\n    } else {\n        relatedEvents = [];\n\n        if (mode == 'hover') {\n            this.lastHoverFeature = this.hoverFeature;\n            this.lastHoverFeatureId = this.hoverFeatureId;\n            this.hoverFeature = null;\n            this.hoverFeatureId = null;\n\n            if (this.lastHoverFeatureId != null) {\n                if (this.lastHoverFeatureId != null) {\n                    relatedEvents.push(['leave', this.lastHoverFeature, this.lastHoverFeatureId]);\n                }\n\n                this.dirty = true;\n            }\n        }\n\n        return [null, false, relatedEvents, elementIndex];\n    }\n};\n\nMap.prototype.getCurrentGeometry = function() {\n    if (this.draw.tree.surfaceSequence.length > 0) {\n        this.draw.tree.draw(true);\n        var res = this.storedTilesRes;\n        this.storedTilesRes = [];\n        return res;\n    }\n\n    return res;\n};\n\nMap.prototype.applyCredits = function(tile) {\n    var value, value2;\n    for (var key in tile.imageryCredits) {\n        value = tile.imageryCredits[key];\n        value2 = this.visibleCredits.imagery[key];\n\n        if (value2) {\n            this.visibleCredits.imagery[key] = value > value2 ? value : value2;\n        } else {\n            this.visibleCredits.imagery[key] = value;\n        }\n    }\n    for (key in tile.glueImageryCredits) {\n        value = tile.glueImageryCredits[key];\n        value2 = this.visibleCredits.imagery[key];\n\n        if (value2) {\n            this.visibleCredits.glueImagery[key] = value > value2 ? value : value2;\n        } else {\n            this.visibleCredits.glueImagery[key] = value;\n        }\n    }\n    for (key in tile.mapdataCredits) {\n        value = tile.mapdataCredits[key];\n        value2 = this.visibleCredits.mapdata[key];\n\n        if (value2) {\n            this.visibleCredits.mapdata[key] = value > value2 ? value : value2;\n        } else {\n            this.visibleCredits.mapdata[key] = value;\n        }\n    }\n    \n    /*if (this.drawBBoxes) {\n        console.log(JSON.stringify(tile.id) + \" \" + JSON.stringify(this.visibleCredits));\n    }*/\n};\n\n\nMap.prototype.drawMap = function() {\n    this.draw.drawMap(null);\n};\n\n\nMap.prototype.processProcessingTasks = function() {\n    while (this.processingTasks.length > 0) {\n        if (this.stats.renderBuild > this.config.mapMaxProcessingTime) {\n            this.markDirty();\n            return;\n        }\n\n        this.processingTasks[0]();\n        this.processingTasks.shift();\n    }\n\n    while (this.processingTasks2.length > 0) {\n        if (this.processingTasks2[0]() != -123) {\n            this.processingTasks2.shift();\n        } else {\n            break;\n        }\n    }\n\n};\n\n\nMap.prototype.addProcessingTask = function(task) {\n    this.processingTasks.push(task);\n};\n\nMap.prototype.addProcessingTask2 = function(task) {\n    this.processingTasks2.push(task);\n};\n\n/*\nMap.prototype.updateGeodataProcessors = function(task) {\n    var processors = this.map.geodataProcessors;\n    for (var i = 0, li = processors.length; i < li; i++) {\n        var processor = processors[i];\n\n        if (!processor.ready && processor.processing) {\n            processor.\n        }\n    }\n};*/\n\n\nMap.prototype.update = function() {\n    if (this.killed) {\n        return;\n    }\n\n    if (this.core.tokenExpiration) {\n        if (Date.now() > (this.core.tokenExpiration - (1000*60))) {\n            this.core.tokenExpirationCallback();\n        }\n    }\n\n    if (!this.srsReady) {\n        this.loader.update();\n        return;\n    }\n\n    if (this.div && this.div.style.visibility == 'hidden'){\n        //loop heartbeat\n        //window.requestAnimFrame(this.update.bind(this));\n        return;\n    }\n\n    if (!this.position.isSame(this.lastPosition)) {\n        this.core.callListener('map-position-changed', {'position':this.position.toArray(), 'last-position':this.lastPosition.toArray()});\n    }\n\n    if (this.camera.lastTerrainHeight != this.camera.terrainHeight) {\n        this.core.callListener('map-position-fixed-height-changed', {'height':this.camera.terrainHeight, 'last-height':this.camera.lastTerrainHeight});\n    }\n\n    this.lastPosition = this.position.clone();\n    this.camera.lastTerrainHeight = this.camera.terrainHeight;\n    this.drawFog = this.config.mapFog;\n\n    var rect = this.renderer.div.getBoundingClientRect();\n    var renderer = this.renderer, p;\n    var camPos = renderer.cameraPosition;\n\n    if (renderer.curSize[0] != rect.width || renderer.curSize[1] != rect.height) {\n        renderer.onResize();\n        this.dirty = true;\n    }\n\n    var dirty = (this.dirty || this.dirtyCountdown > 0), result;\n    this.stats.begin(dirty);\n\n    this.loader.update();\n\n    //this.updateGeodataProcessors();\n\n    this.processProcessingTasks();\n\n    if (dirty) {\n        if (this.dirty) {\n            this.dirtyCountdown = this.config.mapRefreshCycles;\n        } else {\n            this.dirtyCountdown--;\n        }\n\n        this.dirty = false;\n        this.bestMeshTexelSize = 0;//Number.MAX_VALUE;\n        this.bestGeodataTexelSize = 0;//Number.MAX_VALUE;\n        \n        this.renderSlots.processRenderSlots();\n\n        this.loader.update();\n        \n        this.core.callListener('map-update', {});\n\n        //this.renderer.gpu.setState(this.drawTileState);\n        //this.renderer.gpu.gl.disable(this.renderer.gpu.gl.BLEND);\n        //this.renderer.drawImage(300, 0, 256, 256, this.renderer.hitmapTexture, null, null, null, null, false);\n        //this.renderer.drawImage(558, 0, 256, 256, this.renderer.hitmapTexture, null, null, null, null, false);\n\n        //console.log(\"\" + this.stats.gpuRenderUsed);\n    }\n\n    //hover and click events\n    if (this.clickEvent != null || this.hoverEvent != null) {\n        //this.updateGeoHitmap = this.dirty;\n\n        if (this.hoverEvent != null) {\n            result = this.hitTestGeoLayers(this.hoverEvent[0], this.hoverEvent[1], 'hover');\n\n            var relatedEvents = result[2];\n\n            if (relatedEvents != null) {\n                for(var i = 0, li = relatedEvents.length; i < li; i++) {\n                    var event = relatedEvents[i];\n\n                    switch(event[0]) {\n                    case 'enter':\n                        p = event[1][1];\n                        this.core.callListener('geo-feature-enter', {'feature': event[1][0], 'canvas-coords':renderer.project2(event[1][1], renderer.camera.mvp, camPos),\n                            'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3] });\n                        break;\n\n                    case 'leave':\n                        p = event[1][1];\n                        this.core.callListener('geo-feature-leave', {'feature':event[1][0], 'canvas-coords':renderer.project2(event[1][1], renderer.camera.mvp, camPos),\n                            'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3] });\n                        break;\n                    }\n                }\n            }\n\n            if (result[1] && result[0] != null) {\n                p = result[0][1];\n                this.core.callListener('geo-feature-hover', {'feature': result[0][0], 'canvas-coords':renderer.project2(result[0][1], renderer.camera.mvp, camPos),\n                    'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3]});\n            }\n\n            //is it persistent event?\n            if (this.hoverEvent[2] !== true) {\n                this.hoverEvent = null;\n            }\n        }\n\n        if (this.clickEvent != null) {\n            result = this.hitTestGeoLayers(this.clickEvent[0], this.clickEvent[1], 'click');\n\n            if (result[1] && result[0] != null) {\n                p = result[0][1];\n                this.core.callListener('geo-feature-click', {'feature': result[0][0], 'canvas-coords':renderer.project2(result[0][1], renderer.camera.mvp, camPos),\n                    'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.clickEvent[2], 'element': result[3] });\n            }\n\n            this.clickEvent = null;\n        }\n\n    }\n\n\n    this.stats.end(dirty);\n};\n\nexport default Map;\n","\nimport {vec3 as vec3_, mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport GeographicLib_ from 'geographiclib';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat4 = mat4_;\nvar math = math_;\nvar GeographicLib = GeographicLib_;\n\n\nvar MapMeasure = function(map) {\n    this.map = map;\n    this.config = map.config;\n    this.convert = map.convert;\n    this.getPhysicalSrs = this.map.getPhysicalSrs();\n    this.navigationSrs = this.map.getNavigationSrs();\n    this.publicSrs = this.map.getPublicSrs();\n    this.navigationSrsInfo = this.navigationSrs.getSrsInfo();\n    this.isProjected = this.navigationSrs.isProjected();\n\n    var res = this.getSpatialDivisionNodeDepths();\n\n    this.minDivisionNodeDepth = res[0];\n    this.maxDivisionNodeDepth = res[1];\n};\n\nMapMeasure.prototype.getSurfaceAreaGeometry = function(coords, radius, mode, limit, loadMeshes, loadTextures) {\n    var tree = this.map.tree;\n\n    if (tree.surfaceSequence.length == 0) {\n        reurn [true, []];\n    }\n\n    var center = this.convert.convertCoords(coords, 'navigation', 'physical');\n    var coneVec = [0,0,0];\n\n    vec3.normalize(center, coneVec);\n\n    var distance = vec3.length(center);\n    var coneAngle = Math.atan(Math.tan(radius / distance));\n\n    tree.params = {\n        coneVec : coneVec,\n        coneAngle : coneAngle,\n        mode : mode,\n        limit : limit,\n        loaded : true,\n        areaTiles : [],\n        loadMeshes: (loadMeshes === true),\n        loadTextures: (loadTextures === true)\n    };\n\n    //priority = 0, noReadInly = false\n    tree.traceAreaTiles(tree.surfaceTree, 0, false);\n\n    return [tree.params.loaded, tree.params.areaTiles];\n};\n\nMapMeasure.prototype.getSurfaceHeight = function(coords, lod, storeStats, node, nodeCoords, coordsArray, useNodeOnly) {\n    var tree = this.map.tree;\n\n    if (tree.surfaceSequence.length == 0) {\n        return [0, true, true, null, null, null];\n    }\n\n    if (!node) {\n        var result = this.getSpatialDivisionNode(coords);\n        node = result[0];\n        nodeCoords = result[1];\n    }\n    \n    if (!this.config.mapHeightLodBlend) {\n        lod = Math.floor(lod);\n    }\n\n    if (useNodeOnly || this.config.mapIgnoreNavtiles) {\n        return this.getSurfaceHeightNodeOnly(null, lod + 8, storeStats, lod, null, node, nodeCoords, coordsArray);        \n    }\n\n    if (node != null && lod !== null) {\n        var root = tree.findSurfaceTile(node.id);\n\n        var extents = {\n            ll : node.extents.ll.slice(),\n            ur : node.extents.ur.slice()\n        };\n        var params = {\n            coords : nodeCoords,\n            desiredLod : Math.ceil(lod),\n            extents : extents,\n            metanode : null,\n            heightMap : null,\n            heightMapExtents : null,\n            traceHeight : true,\n            waitingForNode : false,\n            finalNode : false,\n            bestHeightMap : 999\n        };\n\n        tree.traceHeight(root, params, false);\n\n        var metanode = params.metanode, i, li, height;\n\n        if (params.heightMap) {\n            if (storeStats) {\n                var stats = this.map.stats;\n                stats.heightClass = 2;\n                stats.heightLod = lod;\n                stats.heightNode = metanode.id[0];                        \n            }\n            \n            var res = metanode.id[0] >= Math.ceil(lod);\n            var arrayRes, height1, height2;\n           \n            if (this.config.mapHeightLodBlend && metanode.id[0] > 0 &&\n                params.parent && params.parent.heightMap && lod <= metanode.id[0]) {\n                height1 = this.getHeightmapValue(nodeCoords, params.parent.metanode, params.parent);  \n                height2 = this.getHeightmapValue(nodeCoords, metanode, params);  \n                var factor = lod - Math.floor(lod);\n                height = height1 + (height2 - height1) * factor;\n\n                if (coordsArray) {\n                    arrayRes = new Array(coordsArray.length);\n                    \n                    for (i = 0, li = coordsArray.length; i < li; i++) {\n                        var nodeCoords2 = coordsArray[i];//node.getInnerCoords(coordsArray[i]);\n                        height1 = this.getHeightmapValue(nodeCoords2, params.parent.metanode, params.parent);  \n                        height2 = this.getHeightmapValue(nodeCoords2, metanode, params);  \n\n                        arrayRes[i] = [height1 + (height2 - height1) * factor, res, true];\n                    }\n                }\n                \n                //console.log(\"lod: \" + lod + \" h1: \" + height1 + \" h2: \" + height2 + \" h: \" + height);  \n            } else {\n                height = this.getHeightmapValue(nodeCoords, metanode, params);  \n\n                if (coordsArray) {\n                    arrayRes = new Array(coordsArray.length);\n                    \n                    for (i = 0, li = coordsArray.length; i < li; i++) {\n                        height2 = this.getHeightmapValue(coordsArray[i], metanode, params);  \n\n                        arrayRes[i] = [height2, res, true];\n                    }\n                }\n            }\n\n            return [height, res, true, null, null, arrayRes];\n\n        } else if (metanode /*&& metanode.id[0] == lod && !metanode.hasNavtile()*/){\n            res = this.getSurfaceHeightNodeOnly(coords, lod + 8, storeStats, lod, null, node, nodeCoords, coordsArray);\n\n            //console.log(\"lod2: \" + lod + \" h: \" + height[0]);  \n            //return [res[0], res[1], true, null, null, res[5]];\n\n            return [res[0], res[1], res[2], null, null, res[5]];\n        }\n\n        /*\n        if (metanode != null) {\n            var height = metanode.minHeight + (metanode.maxHeight - metanode.minHeight) * 0.5;\n            return [height, metanode.id[0] >= lod, true];\n        }*/\n    }\n\n    return [0, false, false, null, null, null];\n};\n\n\nMapMeasure.prototype.getSurfaceHeightNodeOnly = function(coords, lod, storeStats, statsLod, deltaSample, node, nodeCoords, coordsArray) {\n    var arrayRes, height, stats = this.map.stats; \n\n    var tree = this.map.tree;\n\n    if (tree.surfaceSequence.length == 0) {\n        return [0, true, true, null, null, null];\n    }\n    \n    if (!deltaSample) {\n        if (!node) {\n            var result = this.getSpatialDivisionNode(coords);\n            node = result[0];\n            nodeCoords = result[1];\n        }\n        \n        if (coordsArray) {\n            arrayRes = new Array(coordsArray.length);\n            \n            for (var i = 0, li = coordsArray.length; i < li; i++) {\n                arrayRes[i] = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, deltaSample, node, coordsArray[i]);\n            }\n        }\n        \n    } else {\n        node = deltaSample[0];\n        nodeCoords = deltaSample[1];\n    }\n\n    if (!this.config.mapHeightLodBlend) {\n        lod = Math.floor(lod);\n    }\n\n    if (!deltaSample && this.config.mapHeightNodeBlend) {\n        var res1 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0], nodeCoords[1], nodeCoords[2]]]);\n        \n        if (res1[2]) {\n            var sx = res1[3].ur[0] - res1[3].ll[0];\n            var sy = res1[3].ur[1] - res1[3].ll[1];\n            \n            var fx = (nodeCoords[0] - res1[3].ll[0]) / sx;\n            var fy = (nodeCoords[1] - res1[3].ll[1]) / sy;\n            \n            /*\n            var c2 = node.getOuterCoords([nodeCoords[0] + sx, nodeCoords[1], nodeCoords[2]]);\n            var c3 = node.getOuterCoords([nodeCoords[0], nodeCoords[1] + sy, nodeCoords[2]]);\n            var c4 = node.getOuterCoords([nodeCoords[0] + sx, nodeCoords[1] + sy, nodeCoords[2]]);\n    \n            var res2 = this.getSurfaceHeightNodeOnly(c2, lod, storeStats, statsLod, true);\n            var res3 = this.getSurfaceHeightNodeOnly(c3, lod, storeStats, statsLod, true);\n            var res4 = this.getSurfaceHeightNodeOnly(c4, lod, storeStats, statsLod, true);\n            */\n            \n            var res2 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0] + sx, nodeCoords[1], nodeCoords[2]]]);\n            var res3 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0], nodeCoords[1] + sy, nodeCoords[2]]]);\n            var res4 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0] + sx, nodeCoords[1] + sy, nodeCoords[2]]]);\n\n            var w0 = (res1[0] + (res2[0] - res1[0])*fx);\n            var w1 = (res3[0] + (res4[0] - res3[0])*fx);\n            height = (w0 + (w1 - w0)*fy);\n            \n            //console.log(\"h: \" + height + \"fx: \" + fx + \"fy: \" + fy + \"s1234: \" + res1[0] + \" \"  + res2[0] + \" \"  + res3[0] + \" \"  + res4[0]);            \n            /*\n            if (res1[4] && res2[4] && res3[4] && res4[4]){\n                console.log(\"h: \" + height + \"fx: \" + fx + \"fy: \" + fy + \"s1234: \" + JSON.stringify(res1[4].id) + \" \"  + JSON.stringify(res2[4].id) + \" \"  + JSON.stringify(res3[4].id) + \" \"  + JSON.stringify(res4[4].id));            \n            }*/\n\n            return [height, res1[1], res1[2], res1[3], null, arrayRes];                \n        } else {\n            return [res1[0], res1[1], res1[2], res1[3], null, arrayRes];                \n        }\n        //convert new coords to nav coords\n        //blend values\n    }\n\n    if (node != null && lod !== null) {\n        var root = tree.findSurfaceTile(node.id);\n\n        var extents = {\n            ll : node.extents.ll.slice(),\n            ur : node.extents.ur.slice()\n        };\n        var params = {\n            coords : nodeCoords,\n            desiredLod : Math.ceil(lod),\n            extents : extents,\n            metanode : null,\n            heightMap : null,\n            heightMapExtents : null,\n            traceHeight : true,\n            waitingForNode : false,\n            finalNode : false,\n            bestHeightMap : 999\n        };\n\n        tree.traceHeight(root, params, true);\n\n        var metanode = params.metanode, center, center2;\n\n        if (metanode != null) { // && metanode.id[0] == lod){\n\n            if (metanode.bbox.maxSize < 8000) { // use bbox only when bbox is reasonable small\n                center = metanode.bbox.center();\n                center = this.convert.convertCoords(center, 'physical', 'navigation');\n            } else {\n                center = [0,0,nodeCoords[2]];\n            }\n\n            //console.log(\"lod2: \" + lod + \" nodelod: \" + metanode.id[0] + \" h: \" + center[2]/1.55);  \n\n            if (storeStats) {\n                stats.heightClass = 1;\n                stats.heightLod = statsLod;\n                stats.heightNode = metanode.id[0];                        \n            }\n\n            if (this.config.mapHeightLodBlend && metanode.id[0] > 0 &&\n                params.parent && params.parent.metanode) {\n\n                if (params.parent.metanode.bbox.maxSize < 8000) { // use bbox only when bbox is reasonable small\n                    center2 = this.convert.convertCoords(params.parent.metanode.bbox.center(), 'physical', 'navigation');\n                } else {\n                    center2 = [0,0,nodeCoords[2]];\n                }\n\n                var factor = lod - Math.floor(lod);\n                height = center[2] + (center2[2] - center[2]) * factor;\n               \n                //extetnts = params.extents;\n                //return [height, true, true, params.extents, metanode, arrayRes];\n\n                return [height, (metanode.id[0] >= Math.floor(lod) || params.finalNode), \n                        (!params.waitingForNode || metanode.id[0] >= Math.floor(lod) || params.finalNode),\n                        params.extents, metanode, arrayRes];\n                                      \n\n                //console.log(\"lod: \" + lod + \" h1: \" + center[2] + \" h2: \" + center2[2] + \" h: \" + height);  \n            } else {\n                return [center[2], (metanode.id[0] >= Math.floor(lod) || params.finalNode), \n                        (!params.waitingForNode || metanode.id[0] >= Math.floor(lod) || params.finalNode),\n                        params.extents, metanode, arrayRes];\n\n                //return [center[2], true, true, params.extents, metanode, arrayRes];\n            }\n        }\n\n        /*\n        if (metanode != null) {\n            var height = metanode.minHeight + (metanode.maxHeight - metanode.minHeight) * 0.5;\n            return [height, metanode.id[0] >= lod, true];\n        }*/\n    }\n\n    //coords\n    //console.log(\"lod3: \" + lod + \" h: 0\");  \n\n    if (storeStats) {\n        stats.heightClass = 0;\n        stats.heightLod = statsLod;\n        stats.heightNode = 0;                        \n    }\n\n\n    return [0, false, false, null, null, arrayRes];\n};\n\n\nMapMeasure.prototype.getHeightmapValue = function(coords, node, params) {\n    var heightMap = params.heightMap;\n    var data = heightMap.getImageData();\n    var dataExtents = heightMap.getImageExtents();\n    var mapExtents = params.heightMapExtents;\n\n    //relative tile coords\n    var x = coords[0] - mapExtents.ll[0];\n    //var y = nodeCoords[1] - mapExtents.ll[1];\n    var y = mapExtents.ur[1] - coords[1];\n\n    var maxX = (dataExtents[0]-1);\n    var maxY = (dataExtents[1]-1);\n    \n    //data coords\n    x = (maxX) * (x / (mapExtents.ur[0] - mapExtents.ll[0]));\n    y = (maxY) * (y / (mapExtents.ur[1] - mapExtents.ll[1]));\n\n    if (x < 0) { x = 0; }\n    if (y < 0) { y = 0; }\n    if (x > maxX) { x = maxX; }\n    if (y > maxY) { y = maxY; }\n\n    var ix = Math.floor(x);\n    var iy = Math.floor(y);\n    var fx = x - ix;\n    var fy = y - iy;\n\n    var index = iy * dataExtents[0];\n    var index2 = (iy == maxY) ? index : index + dataExtents[0];\n    var ix2 = (ix == maxX) ? ix : ix + 1; \n    var h00 = data[(index + ix)*4];\n    var h01 = data[(index + ix2)*4];\n    var h10 = data[(index2 + ix)*4];\n    var h11 = data[(index2 + ix2)*4];\n    var w0 = (h00 + (h01 - h00)*fx);\n    var w1 = (h10 + (h11 - h10)*fx);\n    var height = (w0 + (w1 - w0)*fy);\n\n    height = node.minHeight + (node.maxHeight - node.minHeight) * (height/255);\n    \n    return height;\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNode = function(coords) {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n\n    var bestNode = null;\n    var bestLod = -1;\n    var bestCoords = [0,0];\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i];\n        var nodeCoords = node.getInnerCoords(coords);\n        var extents = node.extents;\n\n        if (nodeCoords[0] >= extents.ll[0] && nodeCoords[0] <= extents.ur[0] &&\n            nodeCoords[1] >= extents.ll[1] && nodeCoords[1] <= extents.ur[1]) {\n\n            if (node.id[0] > bestLod) {\n                bestNode = node;\n                bestLod = node.id[0];\n                bestCoords = nodeCoords;\n            }\n        }\n    }\n\n    return [bestNode, bestCoords];\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNodeAndExtents = function(id) {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n\n    var bestNode = null;\n    //var bestLod = -1;\n    var bestNodeCoords = [0,0], shift;\n    //var bestExtents = {ll:[0,0], ur:[1,1]};\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i];\n        \n        //has division node this tile node \n        //var shift = node.id[0] - this.lodRange[0];\n        shift = id[0] - node.id[0];\n\n        if (shift >= 0) {\n            var x = id[1] >> shift;\n            var y = id[2] >> shift;\n            \n            if (node.id[1] == x && node.id[2] == y) {\n                bestNode = node;\n                //bestLod = node.id[0];\n                //bestExtents = node.extents;\n                bestNodeCoords = [node.id[1] << shift, node.id[2] << shift];                \n            }\n        }\n    }\n    \n    if (!bestNode) {\n        return null;\n    }\n    \n    shift = id[0] - bestNode.id[0];\n    \n    var factor = 1.0 / Math.pow(2, shift);\n    var ur = bestNode.extents.ur;\n    var ll = bestNode.extents.ll;\n    \n    //extents ll ur but tiles are ul lr!!!! \n    \n    var dx = (ur[0] - ll[0]) * factor; \n    var dy = (ll[1] - ur[1]) * factor;\n    \n    var nx = id[1] - bestNodeCoords[0];\n    var ny = id[2] - bestNodeCoords[1];\n\n    return [bestNode, [[ll[0] + dx * nx, ur[1] + dy * ny], [ll[0] + dx * (nx+1), ur[1] + dy * (ny+1)] ]];\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNodeFromId = function(id) {\n    var shift = id[0] - this.maxDivisionNodeDepth;\n    var nx = id[1] >> shift;\n    var ny = id[2] >> shift;\n    \n    return this.map.referenceFrame.nodesMap['' + this.maxDivisionNodeDepth + '.'  + nx + '.' + ny];\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNodeAndExtents2 = function(id, res, divisionNode) {\n    if (!divisionNode) {\n        return [null, 0,0,0,0];\n    }\n    \n    var shift = id[0] - divisionNode.id[0];\n    var factor = 1.0 / Math.pow(2, shift);\n    var ur = divisionNode.extents.ur;\n    var ll = divisionNode.extents.ll;\n    \n    //extents ll ur but tiles are ul lr!!!! \n    \n    var dx = (ur[0] - ll[0]) * factor; \n    var dy = (ll[1] - ur[1]) * factor;\n    \n    var nx = id[1] - (divisionNode.id[1] << shift);\n    var ny = id[2] - (divisionNode.id[2] << shift);\n    \n    res[0] = divisionNode;\n    res[1] = ll[0] + dx * nx;\n    res[2] = ur[1] + dy * ny;\n    res[3] = ll[0] + dx * (nx+1);\n    res[4] = ur[1] + dy * (ny+1);\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNodeDepths = function() {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n    var maxLod = -1;\n    var minLod = Number.MAX_VALUE;\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i];\n\n        if (node.id[0] < minLod) {\n            minLod = node.id[0];\n        } \n        \n        if (node.id[0] > maxLod) {\n            maxLod = node.id[0];\n        } \n    }\n\n    return [minLod, maxLod];\n};\n\n\nMapMeasure.prototype.getOptimalHeightLodBySampleSize = function(coords, desiredSamplesSize) {\n    var result = this.getSpatialDivisionNode(coords);\n    var node = result[0];\n\n    if (node != null) {\n        var nodeLod = node.id[0];\n        var nodeExtent = node.extents.ur[1] - node.extents.ll[1];\n\n        var lod = Math.log(nodeExtent / desiredSamplesSize) / Math.log(2);\n        //lod = Math.round(lod) - 8 + nodeLod;\n        lod = lod - 8 + nodeLod;\n\n        return Math.max(0, lod);\n    }\n\n    return null;\n};\n\n\nMapMeasure.prototype.getOptimalHeightLod = function(coords, viewExtent, desiredSamplesPerViewExtent) {\n    var result = this.getSpatialDivisionNode(coords);\n    var node = result[0];\n\n    if (node != null) {\n        var nodeLod = node.id[0];\n        var nodeExtent = node.extents.ur[1] - node.extents.ll[1];\n\n        var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / Math.log(2);\n        //lod = Math.round(lod) - 8 + nodeLod;\n        lod = lod - 8 + nodeLod;\n\n        return Math.max(0, lod);\n    }\n\n    return null;\n};\n\n\nMapMeasure.prototype.getDistance = function(coords, coords2, includingHeight, usePublic) {\n    var sourceSrs = usePublic ? this.publicSrs : this.navigationSrs;\n    var p1 = this.getPhysicalSrs.convertCoordsFrom(coords,  sourceSrs);\n    var p2 = this.getPhysicalSrs.convertCoordsFrom(coords2, sourceSrs);\n    var d = 0;\n\n    var dx = p2[0] - p1[0];\n    var dy = p2[1] - p1[1];\n    var dz = p2[2] - p1[2];\n\n    var dd = Math.sqrt(dx*dx + dy*dy + dz*dz);\n    var navigationSrsInfo = this.navigationSrsInfo;\n\n    if (!this.isProjected) {\n        var geod = this.getGeodesic(); //new GeographicLib[\"Geodesic\"][\"Geodesic\"](navigationSrsInfo[\"a\"],\n                                       //                   (navigationSrsInfo[\"a\"] / navigationSrsInfo[\"b\"]) - 1.0);\n\n        var r = geod.Inverse(coords[1], coords[0], coords2[1], coords2[0]);\n\n        if (r.s12 > (navigationSrsInfo['a'] * 2 * Math.PI) / 4007.5) { //aprox 10km for earth\n            if (includingHeight) {\n                return [Math.sqrt(r.s12*r.s12 + dz*dz), -r.azi1, dd];\n            } else {\n                return [r.s12, -r.azi1, dd];\n            }\n        } else {\n            if (includingHeight) {\n                return [Math.sqrt(dx*dx + dy*dy + dz*dz), -r.azi1, dd];\n            } else {\n                return [r.s12, -r.azi1, dd];\n            }\n        }\n\n    } else {\n        return [Math.sqrt(dx*dx + dy*dy), math.degrees(Math.atan2(dx, dy)), dd];\n    }\n};\n\n\nMapMeasure.prototype.getGeodesic = function() {\n    var navigationSrsInfo = this.navigationSrsInfo;\n\n    var geodesic = new GeographicLib.Geodesic.Geodesic(navigationSrsInfo['a'],\n                                                      (navigationSrsInfo['a'] / navigationSrsInfo['b']) - 1.0);\n\n    return geodesic;\n};\n\n\nMapMeasure.prototype.getAzimuthCorrection = function(coords, coords2) {\n    if (!this.getNavigationSrs().isProjected()) {\n        var geodesic = this.getGeodesic();\n        var r = geodesic.Inverse(coords[0], coords[1], coords2[0], coords2[1]);\n        var ret = (r.azi1 - r.azi2);\n        if (isNaN(ret)) {\n            ret = 0;\n        } \n        return ret; \n    }\n    return 0;\n};\n\n\nMapMeasure.prototype.getNED = function(coords) {\n    var centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');\n    var upCoords, rightCoords;\n\n    if (this.isProjected) {\n        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');\n        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');\n    } else {\n        var cy = (coords[1] + 90) - 0.0001;\n        var cx = (coords[0] + 180) + 0.0001;\n\n        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated\n            var geodesic = this.getGeodesic();\n        \n            //up coords\n            var r = geodesic.Direct(coords[1], coords[0], 0, -100);\n            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');\n    \n            //right coords\n            r = geodesic.Direct(coords[1], coords[0], 90, 100);\n            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');\n        } else {\n            // substraction instead of addition is probably case of complicated view matrix calculation\n            upCoords = this.convert.convertCoords([coords[0], coords[1] - 0.0001, 0], 'navigation', 'physical');\n            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');\n        }\n    }\n\n    var up = [upCoords[0] - centerCoords[0],\n        upCoords[1] - centerCoords[1],\n        upCoords[2] - centerCoords[2]]; \n\n    var right = [rightCoords[0] - centerCoords[0],\n        rightCoords[1] - centerCoords[1],\n        rightCoords[2] - centerCoords[2]]; \n\n    var dir = [0,0,0];\n    vec3.normalize(up);\n    vec3.normalize(right);\n    vec3.cross(up, right, dir);\n    vec3.normalize(dir);\n\n    return {\n        east  : right, \n        direction : up,\n        north : dir        \n    };\n};\n\nMapMeasure.prototype.getNewNED = function(coords, returnMatrix) {\n    var centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');\n    var upCoords, rightCoords;\n\n    if (this.isProjected) {\n        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');\n        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');\n    } else {\n        //get NED for latlon coordinates\n        //http://www.mathworks.com/help/aeroblks/directioncosinematrixeceftoned.html\n        /*        \n        var coords = this.position.getCoords();\n        var lon = math.radians(coords[0]);\n        var lat = math.radians(coords[1]);\n\n        //NED vectors for sphere\n        var east = [-Math.sin(lat)*Math.cos(lon), -Math.sin(lat)*Math.sin(lon), Math.cos(lat)];\n        var direction = [-Math.sin(lon), Math.cos(lon), 0];\n        var north = [-Math.cos(lat)*Math.cos(lon), -Math.cos(lat)*Math.sin(lon), -Math.sin(lat)];\n\n        north = vec3.negate(north);\n        east  = vec3.negate(east);\n        \n        //get elipsoid factor\n        var navigationSrsInfo = this.getNavigationSrs().getSrsInfo();\n        var factor = navigationSrsInfo[\"b\"] / navigationSrsInfo[\"a\"];\n\n        //flaten vectors\n        north[2] *= factor;\n        east[2] *= factor;\n        direction[2] *= factor;\n\n        //normalize vectors\n        north = vec3.normalize(north);\n        east  = vec3.normalize(east);\n        direction = vec3.normalize(direction);\n        */\n\n        var cy = (coords[1] + 90) + 0.0001;\n        var cx = (coords[0] + 180) + 0.0001;\n\n        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated\n            var geodesic = this.getGeodesic();\n        \n            //up coords\n            var r = geodesic.Direct(coords[1], coords[0], 0, -100);\n            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');\n    \n            //right coords\n            r = geodesic.Direct(coords[1], coords[0], 90, -100);\n            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');\n        } else {\n            // substraction instead of addition is probably case of complicated view matrix calculation\n            upCoords = this.convert.convertCoords([coords[0], coords[1] + 0.0001, 0], 'navigation', 'physical');\n            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');\n        }\n    }\n\n    var up = [upCoords[0] - centerCoords[0],\n        upCoords[1] - centerCoords[1],\n        upCoords[2] - centerCoords[2]]; \n\n    var right = [rightCoords[0] - centerCoords[0],\n        rightCoords[1] - centerCoords[1],\n        rightCoords[2] - centerCoords[2]]; \n\n    var dir = [0,0,0];\n    vec3.normalize(up);\n    vec3.normalize(right);\n    vec3.cross(up, right, dir);\n    vec3.normalize(dir);\n\n    if (returnMatrix) {\n        var east = right;\n        var direction = up;\n        var north = dir;\n\n        return [\n            east[0], east[1], east[2], 0,\n            north[0], north[1], north[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            0, 0, 0, 1\n        ];        \n    }\n\n    return {\n        east  : right, \n        direction : up,\n        north : dir        \n    };\n};\n\n//TODO: use getNewNED \nMapMeasure.prototype.getPositionCameraInfo = function(position, projected, clampTilt) {\n    //var position = [0,0,0];\n    var orientation = position.getOrientation();\n    var distance = position.getViewDistance();\n    \n    if (clampTilt) { //used for street labels\n        orientation[1] = math.clamp(orientation[1], -89.0, 90.0);\n    }\n\n    var roty = math.clamp(orientation[1], -89.5, 89.5);\n\n    var tmpMatrix = mat4.create();\n    mat4.multiply(math.rotationMatrix(2, math.radians(-orientation[0])), math.rotationMatrix(0, math.radians(roty)), tmpMatrix);\n    var orbitPos, ned, north, east, direction, spaceMatrix, rotationMatrix;\n    var east2, north2, direction2, dir, up, right;\n\n    if (position.getViewMode() == 'obj') {\n        orbitPos = [0, -distance, 0];\n        mat4.multiplyVec3(tmpMatrix, orbitPos);\n    } else {\n        orbitPos = [0, 0, 0];\n    }\n\n    //this.cameraVector = [0, 0, 1];\n    //mat4.multiplyVec3(this.updateCameraMatrix, this.cameraVector);\n\n    var ret = {\n        orbitCoords : null,\n        distance : distance,\n        rotMatrix : null,\n        vector : null,\n        orbitHeight : orbitPos[2]  \n    };\n\n    var coords = position.getCoords();\n\n    if (projected) {\n        \n        tmpMatrix = mat4.create();\n        mat4.multiply(math.rotationMatrix(0, math.radians(-roty - 90.0)), math.rotationMatrix(2, math.radians(orientation[0])), tmpMatrix);\n\n        ned = this.getNED(coords);\n        north = ned.north;\n        east  = ned.east;\n        direction = ned.direction;\n\n        spaceMatrix = [\n            east[0], east[1], east[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            north[0], north[1], north[2], 0,\n            0, 0, 0, 1\n        ];\n        \n        east2  = [1,0,0];\n        direction2 = [0,1,0];\n        north2 = [0,0,1];\n\n        dir = [1,0,0];\n        up = [0,0,-1];\n        right = [0,0,0];\n        vec3.cross(dir, up, right);\n\n        //rotate vectors according to eulers\n        mat4.multiplyVec3(tmpMatrix, north2);\n        mat4.multiplyVec3(tmpMatrix, east2);\n        mat4.multiplyVec3(tmpMatrix, direction2);\n\n        mat4.multiplyVec3(tmpMatrix, dir);\n        mat4.multiplyVec3(tmpMatrix, up);\n        mat4.multiplyVec3(tmpMatrix, right);\n\n        var t = 0;\n        t = dir[0]; dir[0] = dir[1]; dir[1] = t;\n        t = up[0]; up[0] = up[1]; up[1] = t;\n        t = right[0]; right[0] = right[1]; right[1] = t;\n        \n        dir[2] = -dir[2];\n        up[2] = -up[2];\n        right[2] = -right[2];\n\n        /*\n        mat4.multiplyVec3(spaceMatrix, north2);\n        mat4.multiplyVec3(spaceMatrix, east2);\n        mat4.multiplyVec3(spaceMatrix, direction2);\n        */\n\n        //get rotation matrix\n        rotationMatrix = [\n            east2[0], east2[1], east2[2], 0,\n            direction2[0], direction2[1], direction2[2], 0,\n            north2[0], north2[1], north2[2], 0,\n            0, 0, 0, 1\n        ];\n\n       // mat4.multiplyVec3(spaceMatrix, orbitPos);\n/*\n        //get rotation matrix\n        var rotationMatrix = [\n            east[0], east[1], east[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            north[0], north[1], north[2], 0,\n            0, 0, 0, 1\n        ];\n*/\n        ret.vector = vec3.normalize([-orbitPos[0], -orbitPos[1], -orbitPos[2]]); \n        ret.vector2 = ret.vector; //vector2 is probably hack for tree.js bboxVisible \n        \n        ret.orbitCoords = orbitPos;\n        ret.rotMatrix = rotationMatrix; \n\n    } else { //geographics\n\n      \n        ned = this.getNED(coords);\n        north = ned.north;\n        east  = ned.east;\n        direction = ned.direction;\n        \n\n        spaceMatrix = [\n            east[0], east[1], east[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            north[0], north[1], north[2], 0,\n            0, 0, 0, 1\n        ];\n        \n        //spaceMatrix = mat4.inverse(spaceMatrix);\n        \n        var localRotMatrix = mat4.create();\n        mat4.multiply(math.rotationMatrix(0, math.radians(-roty - 90.0)), math.rotationMatrix(2, math.radians(orientation[0])), localRotMatrix);\n\n        east2  = [1,0,0];\n        direction2 = [0,1,0];\n        north2 = [0,0,1];\n\n        coords = position.getCoords();\n        var latlonMatrix = mat4.create();\n        mat4.multiply(math.rotationMatrix(0, math.radians((coords[1] - 90.0))), math.rotationMatrix(2, math.radians((-coords[0]-90))), latlonMatrix);\n//      mat4.multiply(math.rotationMatrix(2, math.radians((coords[0]-90))), math.rotationMatrix(0, math.radians((coords[1] - 90.0))), latlonMatrix);\n\n\n        //mat4.multiply(math.rotationMatrix(0, math.radians(0)), math.rotationMatrix(2, math.radians(-(coords[0]+90))), latlonMatrix);\n        //mat4.multiply(math.rotationMatrix(0, math.radians(0)), math.rotationMatrix(2, math.radians(0)), latlonMatrix);\n\n        //rotate vectors according to latlon\n        mat4.multiplyVec3(latlonMatrix, north2);\n        mat4.multiplyVec3(latlonMatrix, east2);\n        mat4.multiplyVec3(latlonMatrix, direction2);\n\n\n        spaceMatrix = [\n            east2[0], east2[1], east2[2], 0,\n            direction2[0], direction2[1], direction2[2], 0,\n            north2[0], north2[1], north2[2], 0,\n            0, 0, 0, 1\n        ];\n\n        right = [1,0,0];\n        dir = [0,1,0];\n        up = [0,0,1];\n        //vec3.cross(dir, up, right);\n\n        //rotate vectors according to eulers\n        //mat4.multiplyVec3(this.updateCameraMatrix, north2);\n        //mat4.multiplyVec3(this.updateCameraMatrix, east2);\n        //mat4.multiplyVec3(this.updateCameraMatrix, direction2);\n\n        mat4.multiplyVec3(spaceMatrix, dir);\n        mat4.multiplyVec3(spaceMatrix, up);\n        mat4.multiplyVec3(spaceMatrix, right);\n\n        mat4.multiplyVec3(localRotMatrix, right);\n        mat4.multiplyVec3(localRotMatrix, dir);\n        mat4.multiplyVec3(localRotMatrix, up);\n        \n        //mat4.multiplyVec3(spaceMatrix, north2);\n        //mat4.multiplyVec3(spaceMatrix, east2);\n        //mat4.multiplyVec3(spaceMatrix, direction2);\n\n\n        //get rotation matrix\n/*        \n        var rotationMatrix = [\n            east2[0], east2[1], east2[2], 0,\n            direction2[0], direction2[1], direction2[2], 0,\n            north2[0], north2[1], north2[2], 0,\n            0, 0, 0, 1\n        ];\n*/        \n\n        rotationMatrix = [\n            right[0], right[1], right[2], 0,\n            dir[0], dir[1], dir[2], 0,\n            up[0], up[1], up[2], 0,\n            0, 0, 0, 1\n        ];\n\n        //get orbit pos\n        spaceMatrix = mat4.inverse(spaceMatrix);\n        mat4.multiplyVec3(spaceMatrix, orbitPos);\n\n        //ret.vector2 = [-spaceMatrix[8], -spaceMatrix[9], -spaceMatrix[10]]; //vector2 is probably hack for tree.js bboxVisible \n        ret.vector = [-rotationMatrix[2], -rotationMatrix[6], -rotationMatrix[10]];\n\n        //var ray = this.map.renderer.getScreenRay(800,400);\n\n        //get camera direction\n        //mat4.inverse(rotationMatrix, spaceMatrix);\n        //ret.vector = [-spaceMatrix[8], -spaceMatrix[9], -spaceMatrix[10]]; \n        \n        //console.log(\"cam vec: \" + JSON.stringify(this.cameraVector));\n         \n        //this.position.setHeight(0); !!!!!!!!!!!!!!!\n    }\n\n    ret.orbitCoords = orbitPos;\n    ret.rotMatrix = rotationMatrix;\n    return ret; \n};\n\n\nexport default MapMeasure;\n\n","\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {utils as utils_} from '../utils/utils';\nimport MapSubmesh_ from './submesh';\nimport BBox_ from '../renderer/bbox';\nimport GpuProgram_ from '../renderer/gpu/program';\nimport GpuShaders_ from '../renderer/gpu/shaders';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\nvar BBox = BBox_;\nvar MapSubmesh = MapSubmesh_;\nvar utils = utils_;\nvar GpuProgram = GpuProgram_;\nvar GpuShaders = GpuShaders_;\n\nvar MapMesh = function(map, url, tile) {\n    this.generateLines = true;\n    this.map = map;\n    this.stats = map.stats;\n    this.mapLoaderUrl  = url;\n    this.tile = tile; // used only for stats\n    this.use16bit = map.config.map16bitMeshes;\n\n    this.bbox = new BBox();\n    this.size = 0;\n    this.gpuSize = 0;\n    this.fileSize = 0;\n    this.faces = 0;\n\n    this.cacheItem = null;  //store killSubmeshes\n    this.gpuCacheItem = null; //store killGpuSubmeshes\n\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n\n    this.mBuffer = new Float32Array(16);\n    this.mBuffer2 = new Float32Array(16);\n    this.vBuffer = new Float32Array(4);\n\n    this.submeshes = [];\n    this.gpuSubmeshes = [];\n    this.submeshesKilled = false;\n};\n\n\nMapMesh.prototype.kill = function() {\n    this.bbox = null;\n    this.killSubmeshes();\n    this.killGpuSubmeshes();\n};\n\n\nMapMesh.prototype.killSubmeshes = function(killedByCache) {\n    for (var i = 0, li = this.submeshes.length; i < li; i++) {\n        this.submeshes[i].kill();\n    }\n    //this.submeshes = [];\n    this.submeshesKilled = true;\n\n    if (killedByCache !== true && this.cacheItem) {\n        this.map.resourcesCache.remove(this.cacheItem);\n        //this.tile.validate();\n    }\n\n    if (this.gpuSubmeshes.length == 0) {\n        this.loadState = 0;\n    }\n\n    this.cacheItem = null;\n};\n\n\nMapMesh.prototype.killGpuSubmeshes = function(killedByCache) {\n    var size = 0;\n    for (var i = 0, li = this.gpuSubmeshes.length; i < li; i++) {\n        this.gpuSubmeshes[i].kill();\n        size += this.gpuSubmeshes[i].getSize();\n    }\n\n    if (li > 0) {\n        this.stats.gpuMeshes -= size;\n        this.stats.graphsFluxMesh[1][0]++;\n        this.stats.graphsFluxMesh[1][1] += size;\n    }\n\n    this.gpuSubmeshes = [];\n\n    if (killedByCache !== true && this.gpuCacheItem) {\n        this.map.gpuCache.remove(this.gpuCacheItem);\n        //this.tile.validate();\n    }\n\n    //console.log(\"kill: \" + this.stats.counter + \"   \" + this.mapLoaderUrl);\n\n//    if (this.submeshes.length == 0) {\n    if (this.submeshesKilled) {\n        this.loadState = 0;\n    }\n\n    this.gpuCacheItem = null;\n};\n\n\nMapMesh.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n\n    //if (doNotUseGpu) {\n      //  doNotUseGpu = doNotUseGpu;\n    //}\n\n    //if (this.mapLoaderUrl == \"https://cdn.vts.com/mario/proxy/melown2015/surface/vts/cz10/12-1107-688.bin?0\") {\n      //  this.mapLoaderUrl = this.mapLoaderUrl;\n    //}\n\n    if (this.loadState == 2) { //loaded\n        if (this.cacheItem) {\n            this.map.resourcesCache.updateItem(this.cacheItem);\n        }\n\n        if (doNotCheckGpu) {\n            return true;\n        }\n\n        if (this.gpuSubmeshes.length == 0) {\n            if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {\n                return false;\n            }\n\n            /*if (this.stats.renderBuild > this.map.config.mapMaxProcessingTime) {\n                this.map.markDirty();\n                return false;\n            }*/\n\n            if (doNotUseGpu) {\n                return false;\n            }\n\n            var t = performance.now();\n            this.buildGpuSubmeshes();\n            this.stats.renderBuild += performance.now() - t;\n        }\n\n        if (!doNotLoad && this.gpuCacheItem) {\n            this.map.gpuCache.updateItem(this.gpuCacheItem);\n        }\n        return true;\n    } else {\n        if (this.loadState == 0) {\n            if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                  //  this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            } else {\n                //not loaded\n                //add to loading queue or top position in queue\n                this.scheduleLoad(priority);\n            }\n        } else if (this.loadState == 3) { //loadError\n            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n\n                this.scheduleLoad(priority);\n            }\n        } //else load in progress\n    }\n\n    return false;\n};\n\n\nMapMesh.prototype.scheduleLoad = function(priority) {\n    if (!this.mapLoaderUrl) {\n        this.mapLoaderUrl = this.map.url.makeUrl(this.tile.resourceSurface.meshUrl, {lod:this.tile.id[0], ix:this.tile.id[1], iy:this.tile.id[2] });\n    }\n\n    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.tile, 'mesh');\n};\n\n\nMapMesh.prototype.onLoad = function(url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'mesh');\n    this.loadState = 1;\n};\n\n\nMapMesh.prototype.onLoadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    this.loadState = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n\n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) {\n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }\n\n    this.mapLoaderCallError();\n};\n\n\nMapMesh.prototype.onLoaded = function(data, task, direct) {\n    if (this.map.killed){\n        return;\n    }\n\n    if (!task) {\n        //this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {\n        this.map.markDirty();\n        this.map.addProcessingTask(this.onLoaded.bind(this, data, true, direct));\n        return;\n    }\n\n    var t = performance.now();\n\n    if (direct) {\n        this.parseWorkerData(data);\n    } else {\n        this.fileSize = data.byteLength;\n        var stream = {data: new DataView(data), buffer:data, index:0};\n        this.parseMapMesh(stream);\n    }\n\n    this.map.stats.renderBuild += performance.now() - t;\n\n    this.submeshesKilled = false;\n\n    this.cacheItem = this.map.resourcesCache.insert(this.killSubmeshes.bind(this, true), this.size);\n\n    this.map.markDirty();\n    this.loadState = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.mapLoaderCallLoaded();\n};\n\n\n// Returns RAM usage in bytes.\n//MapMesh.prototype.getSize = function () {\n  //  return this.size;\n//};\n\n//MapMesh.prototype.fileSize = function () {\n    //return this.fileSize;\n//};\n\n\nMapMesh.prototype.parseWorkerData = function (data) {\n    this.faces = data['faces'];\n    this.gpuSize = data['gpuSize'];\n    this.meanUndulation = data['meanUndulation'];\n    this.numSubmeshes = data['numSubmeshes'];\n    this.size = data['size'];\n    this.version = data['version'];\n    this.submeshes = [];\n\n    var submeshes = data['submeshes'];\n\n    for (var i = 0, li = submeshes.length; i < li; i++) {\n        var submesh = new MapSubmesh(this);\n        var submeshData = submeshes[i];\n\n        submesh.bbox.min = submeshData['bboxMin'];\n        submesh.bbox.max = submeshData['bboxMax'];\n        submesh.externalUVs = submeshData['externalUVs'];\n        submesh.faces = submeshData['faces'];\n        submesh.flags = submeshData['flags'];\n        submesh.gpuSize = submeshData['gpuSize'];\n        submesh.indices = submeshData['indices'];\n        submesh.internalUVs = submeshData['internalUVs'];\n        submesh.size = submeshData['size'];\n        submesh.surfaceReference = submeshData['surfaceReference'];\n        submesh.textureLayer = submeshData['textureLayer'];\n        submesh.textureLayer2 = submeshData['textureLayer2'];\n        submesh.vertices = submeshData['vertices'];\n\n        this.submeshes.push(submesh);\n    }\n\n    this.bbox.updateMaxSize();\n};\n\nMapMesh.prototype.parseMapMesh = function (stream) {\n/*\n    struct MapMesh {\n        struct MapMeshHeader {\n            char magic[2];                // letters \"ME\"\n            ushort version;               // currently 1\n            double meanUndulation;        // read more about undulation below\n            ushort numSubmeshes;          // number of submeshes\n        } header;\n        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property\n    };\n*/\n    this.killSubmeshes(); //just in case\n\n    //parase header\n    var streamData = stream.data;\n    var magic = '';\n\n    if (streamData.length < 2) {\n        return false;\n    }\n\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n\n    if (magic != 'ME') {\n        return false;\n    }\n\n    this.version = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    if (this.version > 3) {\n        return false;\n    }\n\n    //if (this.version >= 3) {\n    stream.uint8Data = new Uint8Array(stream.buffer);\n    //}\n\n    this.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;\n    this.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    this.submeshes = [];\n    this.gpuSize = 0;\n    this.faces = 0;\n\n    for (var i = 0, li = this.numSubmeshes; i < li; i++) {\n        var submesh = new MapSubmesh(this, stream);\n        if (submesh.valid) {\n            this.submeshes.push(submesh);\n            this.size += submesh.getSize();\n            this.faces += submesh.faces;\n\n            //aproximate size\n            this.gpuSize += submesh.getSize();\n        }\n    }\n\n    this.numSubmeshes = this.submeshes.length;\n};\n\n\nMapMesh.prototype.addSubmesh = function(submesh) {\n    this.submeshes.push(submesh);\n    this.size += submesh.size;\n    this.faces += submesh.faces;\n};\n\n\nMapMesh.prototype.buildGpuSubmeshes = function() {\n    var size = 0;\n    this.gpuSubmeshes = new Array(this.submeshes.length);\n\n    for (var i = 0, li = this.submeshes.length; i < li; i++) {\n        this.gpuSubmeshes[i] = this.submeshes[i].buildGpuMesh();\n        size += this.gpuSubmeshes[i].getSize();\n    }\n\n    this.stats.gpuMeshes += size;\n    this.stats.graphsFluxMesh[0][0]++;\n    this.stats.graphsFluxMesh[0][1] += size;\n\n    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuSubmeshes.bind(this, true), size);\n    this.gpuSize = size;\n\n    //console.log(\"build: \" + this.stats.counter + \"   \" + this.mapLoaderUrl);\n};\n\n\nMapMesh.prototype.generateTileShader = function (progs, v, useSuperElevation, splitMask) {\n    var str = '';\n    if (splitMask) {\n        if (!this.map.config.mapSplitMargin) {\n            if (splitMask.length == 4){ str += '#define clip4_nomargin\\n' } else { str += '#define clip8\\n' };\n        } else {\n            if (splitMask.length == 4){ str += '#define clip4\\n' } else { str += '#define clip8\\n' };\n            str += '#define TMIN ' + (0.5-this.map.config.mapSplitMargin) + '\\n' + '#define TMAX ' + (0.5+this.map.config.mapSplitMargin) + '\\n';\n        }\n    }\n    if (useSuperElevation) str += '#define applySE\\n';\n    var prog = (new GpuProgram(this.map.renderer.gpu, progs[0].vertex.replace('#define variants\\n', str), progs[0].fragment.replace('#define variants\\n', str)));\n    progs[v] = prog;\n    return prog;\n};\n\n\nMapMesh.prototype.drawSubmesh = function (cameraPos, index, texture, type, alpha, layer, surface, splitMask, splitSpace) {\n    if (this.gpuSubmeshes[index] == null && this.submeshes[index] != null && !this.submeshes[index].killed) {\n        this.gpuSubmeshes[index] = this.submeshes[index].buildGpuMesh();\n    }\n\n    var submesh = this.submeshes[index];\n    var gpuSubmesh = this.gpuSubmeshes[index];\n\n    if (!gpuSubmesh) {\n        return;\n    }\n\n    var renderer = this.map.renderer;\n    var draw = this.map.draw;\n    var program = null;\n    var gpuMask = null;\n\n    var texcoordsAttr = null;\n    var texcoords2Attr = null;\n    var drawWireframe = draw.debug.drawWireframe;\n    var useSuperElevation = renderer.useSuperElevation;\n    //var attributes = (drawWireframe != 0) ?  ['aPosition', 'aBarycentric'] : ['aPosition'];\n    var attributes = ['aPosition'];\n    var v = (useSuperElevation) ? VTS_TILE_SHADER_SE : 0;\n\n    if (splitMask) {\n        v |= VTS_TILE_SHADER_CLIP4;\n\n        if (type != VTS_MATERIAL_EXTERNAL && type != VTS_MATERIAL_INTERNAL_NOFOG) {\n            texcoords2Attr = 'aTexCoord2';\n            attributes.push('aTexCoord2');\n        }\n    }\n\n    if (texture && draw.debug.meshStats) {\n        if (!submesh.uvAreaComputed) {\n            submesh.computeUVArea(texture.getGpuTexture());\n        }\n\n        this.stats.meshesUVArea += submesh.uvArea;\n        this.stats.meshesFaces += submesh.faces;\n    }\n\n    if (type == VTS_MATERIAL_DEPTH) {\n        program = renderer.progDepthTile[v];\n\n        if (!program) {\n            program = this.generateTileShader(renderer.progDepthTile, v, useSuperElevation, splitMask);\n        }\n\n    } else if (type == VTS_MATERIAL_FLAT) {\n        program = renderer.progFlatShadeTile[v];\n\n        if (!program) {\n            program = this.generateTileShader(renderer.progFlatShadeTile, v, useSuperElevation, splitMask);\n        }\n\n    } else {\n        if (drawWireframe > 0 && type == VTS_MATERIAL_FOG) {\n            return;\n        }\n\n        if (drawWireframe == 1 || drawWireframe == 3) {\n            program = renderer.progFlatShadeTile[v];\n\n            if (!program) {\n                program = this.generateTileShader(renderer.progFlatShadeTile, v, useSuperElevation, splitMask);\n            }\n\n        } else {\n            switch(type) {\n            case VTS_MATERIAL_INTERNAL:\n            case VTS_MATERIAL_INTERNAL_NOFOG:\n\n                texcoordsAttr = 'aTexCoord';\n                attributes.push('aTexCoord');\n\n                program = renderer.progTile[v];\n\n                if (!program) {\n                    program = this.generateTileShader(renderer.progTile, v, useSuperElevation, splitMask);\n                }\n\n                break;\n\n            case VTS_MATERIAL_EXTERNAL:\n            case VTS_MATERIAL_EXTERNAL_NOFOG:\n\n                var prog = renderer.progTile2;\n\n                if (texture) {\n                    gpuMask = texture.getGpuMaskTexture();\n                    if (gpuMask) {\n                        prog = renderer.progTile3;\n                    }\n                }\n\n                program = prog[v];\n\n                if (!program) {\n                    program = this.generateTileShader(prog, v, useSuperElevation, splitMask);\n                }\n\n\n                if (layer && (layer.shaderFilters || layer.shaderFilter)) {\n                    var filter, id, flatShade;\n\n                    if (surface && layer.shaderFilters) {\n                        filter = layer.shaderFilters[surface.id];\n\n                        if (filter) {\n                            if (filter.varFlatShade) {\n                                flatShade = true;\n                            }\n\n                            filter = filter.filter;\n                        }\n                    }\n\n                    if (!filter) {\n                        filter = layer.shaderFilter;\n                    }\n\n                    if (filter) {\n                        var id = (gpuMask) ? 'progTile3' : 'progTile2';\n                        var renderer = this.map.renderer;\n\n                        if (useSuperElevation) {\n                            id += 'se';\n                        }\n\n                        if (flatShade) {\n                            id += 'fs';\n                        }\n\n                        if (splitMask) {\n                            id += 'c4';\n                        }\n\n                        id += filter;\n\n                        program = renderer.progMap[id];\n\n                        if (!program) {\n                            var gpu = renderer.gpu, pixelShader, variations = '';\n\n                            if (splitMask) {\n                                if (!this.map.config.mapSplitMargin) {\n                                    variations += '#define clip4_nomargin\\n';\n                                } else {\n                                    variations += '#define clip4\\n';\n                                    variations += '#define TMIN ' + (0.5-this.map.config.mapSplitMargin) + '\\n' + '#define TMAX ' + (0.5+this.map.config.mapSplitMargin) + '\\n';\n                                }\n                            }\n\n                            var vertexShader = '#define externalTex\\n' + variations + ((useSuperElevation) ? '#define applySE\\n' : '') + GpuShaders.tileVertexShader;\n\n                            if (gpuMask) {\n                                pixelShader = '#define externalTex\\n#define mask\\n' + variations + GpuShaders.tileFragmentShader;\n                            } else {\n                                pixelShader = '#define externalTex\\n' + variations + GpuShaders.tileFragmentShader;\n                            }\n\n                            if (flatShade) {\n                                pixelShader =  '#extension GL_OES_standard_derivatives : enable\\n#define flatShadeVar\\n' + pixelShader;\n                                vertexShader = '#define flatShadeVar\\n' + vertexShader;\n\n                                //if (this.map.mobile) {\n                                    //pixelShader = '#define flatShadeVarFallback\\n' + pixelShader;\n                                    pixelShader = pixelShader.replace('mediump', 'highp');\n                                //}\n                            }\n\n                            program = new GpuProgram(gpu, vertexShader, pixelShader.replace('__FILTER__', filter));\n                            renderer.progMap[id] = program;\n                        }\n                    }\n                }\n\n                texcoords2Attr = 'aTexCoord2';\n                attributes.push('aTexCoord2');\n                break;\n\n            case VTS_MATERIAL_FOG:\n                program = renderer.progFogTile[v];\n\n                if (!program) {\n                    program = this.generateTileShader(renderer.progFogTile, v, useSuperElevation, splitMask);\n                }\n\n                break;\n            }\n        }\n    }\n\n    if (!program || !program.isReady()) {\n        return;\n    }\n\n    renderer.gpu.useProgram(program, attributes, gpuMask);\n\n    if (texture) {\n        var gpuTexture = texture.getGpuTexture();\n\n        if (gpuTexture) {\n            if (texture.statsCoutner != this.stats.counter) {\n                texture.statsCoutner = this.stats.counter;\n                this.stats.gpuRenderUsed += gpuTexture.getSize();\n            }\n\n            renderer.gpu.bindTexture(gpuTexture);\n\n            if (gpuMask) {\n                renderer.gpu.bindTexture(gpuMask, 1);\n            }\n\n        } else {\n            return;\n        }\n    } else if (type != VTS_MATERIAL_FOG && type != VTS_MATERIAL_DEPTH && type != VTS_MATERIAL_FLAT) {\n        return;\n    }\n\n    var mv = this.mBuffer, m = this.mBuffer2, v = this.vBuffer;\n\n    if (useSuperElevation) {\n\n        var m = this.mBuffer;\n        var se = renderer.superElevation;\n\n        m[0] = submesh.bbox.min[0];\n        m[1] = submesh.bbox.min[1];\n        m[2] = submesh.bbox.min[2];\n\n        m[3] = submesh.bbox.side(0);\n        m[4] = submesh.bbox.side(1);\n        m[5] = submesh.bbox.side(2);\n\n        //m[6] = 0;\n        //m[7] = 0;\n        //m[8] = 0;\n\n        m[9] = se[0]; // h1\n        m[10] = se[1]; // f1\n        m[11] = se[2]; // h2\n        m[12] = se[6]; // inv dh\n        m[13] = se[5]; // df\n\n        m[14] = renderer.earthRadius;\n        m[15] = renderer.earthERatio;\n\n        program.setMat4('uParamsSE', m);\n\n        //mv = renderer.camera.getModelviewFMatrix();\n        mat4.multiply(renderer.camera.getModelviewFMatrix(), submesh.getWorldMatrixSE(cameraPos, m), mv);\n\n    } else {\n        mat4.multiply(renderer.camera.getModelviewFMatrix(), submesh.getWorldMatrix(cameraPos, m), mv);\n    }\n\n\n    var proj = renderer.camera.getProjectionFMatrix();\n\n    program.setMat4('uMV', mv);\n\n    if (draw.zbufferOffset) {\n        program.setMat4('uProj', proj, renderer.getZoffsetFactor(draw.zbufferOffset));\n    } else {\n        program.setMat4('uProj', proj);\n    }\n\n    if (splitMask /*&& type != VTS_MATERIAL_FLAT*/) {\n        program.setFloatArray('uClip', splitMask);\n\n        //var fx = this.getLinePointParametricDist(points[0], points[1], point);\n        //var fy = this.getLinePointParametricDist(points[1], points[2], point);\n        //var fz = this.getLinePointParametricDist(points[4], points[0], point);\n\n        var p = this.map.camera.position;\n        var s = splitSpace;\n        //var c = [s[0][0] - p[0], s[0][1] - p[1], s[0][2] - p[2]];\n        //var px = [s[1][0] - p[0], s[1][1] - p[1], s[1][2] - p[2]];\n        //var py = [s[2][0] - p[0], s[2][1] - p[1], s[2][2] - p[2]];\n        //var pz = [s[4][0] - p[0], s[4][1] - p[1], s[4][2] - p[2]];\n\n        if (splitSpace) {\n            m[0] = s[0][0] - p[0]; m[1] = s[0][1] - p[1]; m[2] = s[0][2] - p[2];\n            m[4] = s[1][0] - s[0][0]; m[5] = s[1][1] - s[0][1]; m[6] = s[1][2] - s[0][2];\n            m[8] = s[2][0] - s[1][0]; m[9] = s[2][1] - s[1][1]; m[10] = s[2][2] - s[1][2];\n            //m[12] = s[0][0] - s[4][0]; m[13] = s[0][1] - s[4][1]; m[14] = s[0][2] - s[4][2];\n            m[12] = s[4][0] - s[0][0]; m[13] = s[4][1] - s[0][1]; m[14] = s[4][2] - s[0][2];\n\n            var bmin = submesh.bbox.min, bmax = submesh.bbox.max;\n\n            m[3] = bmin[0] - p[0];\n            m[7] = bmin[1] - p[1];\n            m[11] = bmin[2] - p[2];\n\n            program.setMat4('uParamsC8', m);\n        }\n    }\n\n    if (drawWireframe == 0) {\n        var cv = this.map.camera.vector2, c = draw.atmoColor, t, bmin = submesh.bbox.min, bmax = submesh.bbox.max;\n\n        switch(type) {\n        case VTS_MATERIAL_INTERNAL:\n        case VTS_MATERIAL_FOG:\n        case VTS_MATERIAL_INTERNAL_NOFOG:\n\n            m[0] = draw.zFactor, m[1] = (type == VTS_MATERIAL_INTERNAL_NOFOG) ? 0 : draw.fogDensity;\n            m[2] = bmax[0] - bmin[0], m[3] = bmax[1] - bmin[1],\n            m[4] = cv[0], m[5] = cv[1], m[6] = cv[2], m[7] = cv[3],\n            m[12] = bmax[2] - bmin[2], m[13] = bmin[0], m[14] = bmin[1], m[15] = bmin[2];\n\n            program.setMat4('uParams', m);\n\n            v[0] = c[0], v[1] = c[1], v[2] = c[2];\n            program.setVec4('uParams2', v);\n\n            break;\n\n        case VTS_MATERIAL_EXTERNAL:\n        case VTS_MATERIAL_EXTERNAL_NOFOG:\n\n            t = texture.getTransform();\n\n            m[0] = draw.zFactor, m[1] = (type == VTS_MATERIAL_EXTERNAL) ? draw.fogDensity : 0;\n            m[2] = bmax[0] - bmin[0], m[3] = bmax[1] - bmin[1],\n            m[4] = cv[0], m[5] = cv[1], m[6] = cv[2], m[7] = cv[3],\n            m[8] = t[0], m[9] = t[1], m[10] = t[2], m[11] = t[3],\n            m[12] = bmax[2] - bmin[2], m[13] = bmin[0], m[14] = bmin[1], m[15] = bmin[2];\n\n            program.setMat4('uParams', m);\n\n            v[0] = c[0], v[1] = c[1], v[2] = c[2]; v[3] = (type == VTS_MATERIAL_EXTERNAL) ? 1 : alpha;\n            program.setVec4('uParams2', v);\n\n            break;\n        }\n    }\n\n    if (submesh.statsCoutner != this.stats.counter) {\n        submesh.statsCoutner = this.stats.counter;\n        this.stats.gpuRenderUsed += gpuSubmesh.getSize();\n    }\n\n    gpuSubmesh.draw(program, 'aPosition', texcoordsAttr, texcoords2Attr, drawWireframe != 0 ? 'aBarycentric' : null, (drawWireframe == 2));\n\n\n    if (drawWireframe == 1 || drawWireframe == 2) { //very slow debug only\n        program = renderer.progWireFrameBasic[v];\n\n        if (!program) {\n            program = this.generateTileShader(renderer.progWireFrameBasic, v, useSuperElevation, splitMask);\n        }\n\n        renderer.gpu.useProgram(program, attributes, gpuMask);\n\n        if (useSuperElevation) {\n            program.setMat4('uParamsSE', m);\n        }\n\n        program.setMat4('uMV', mv);\n        program.setVec4('uColor', [0,0,0,1]);\n\n        program.setMat4('uProj', proj, renderer.getZoffsetFactor([-0.001,0,0]));\n\n        if (splitMask) {\n            program.setFloatArray('uClip', splitMask);\n        }\n\n        var gl = gpuSubmesh.gl;\n\n        if (gpuSubmesh.indexBuffer) {\n            for (var i = 0, li = gpuSubmesh.indexBuffer.numItems*2; i < li; i+=3) {\n                gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i);\n            }\n        }  else {\n            for (var i = 0, li = gpuSubmesh.vertexBuffer.numItems*2; i < li; i+=3) {\n                gl.drawArrays(gl.LINE_LOOP, i, 3);\n            }\n        }\n    }\n\n    this.stats.drawnFaces += this.faces;\n    this.stats.drawCalls ++;\n};\n\n\nexport default MapMesh;\n","\nimport {vec3 as vec3_, mat4 as mat4_} from '../utils/matrix';\nimport {utils as utils_} from '../utils/utils';\nimport {math as math_} from '../utils/math';\nimport BBox_ from '../renderer/bbox';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat4 = mat4_;\nvar BBox = BBox_;\nvar math = math_;\nvar utils = utils_;\n\n\nvar MapMetanode = function(metatile, id, stream, divisionNode) {\n    this.metatile = metatile;\n    this.map = metatile.map;\n    this.id = id;\n    this.credits = [];\n    this.alien = false;\n    this.ready = false;\n    this.heightReady = false;\n    this.divisionNode = divisionNode;\n\n    this.diskPos = new Array(3);\n    this.diskDistance = 1; \n    this.diskNormal = new Array(3); \n    this.diskAngle = 1;\n    this.diskAngle2 = 1;\n    this.diskAngle2A = 1;\n    //this.bboxHeight = 1;\n    this.bbox2 = new Array(24);\n\n    //this.flagsGeometryPresent =  1;\n    //this.flagsNavtilePresent =  3;\n    //this.flagsInternalTexturePresent =  7;\n    //this.flagsCoarsenessControl =  15;\n    //this.flagsChildShift =  3;\n\n    if (stream) {\n        this.parseMetanode(stream);\n    }\n};\n\n\nMapMetanode.prototype.kill = function() {\n};\n\n\nMapMetanode.prototype.hasChild = function(index) {\n    return ((this.flags & (1<<(index+4))) != 0);\n};\n\n\nMapMetanode.prototype.hasChildById = function(id) {\n    var ix = id[1] - (this.id[1]<<1); \n    var iy = id[2] - (this.id[2]<<1);\n    \n    //ul,ur,ll,lr\n    return this.hasChild((iy<<1) + ix); \n};\n\n\nMapMetanode.prototype.hasChildren = function() {\n    return ((this.flags & ((15)<<4)) != 0);\n};\n\n\nMapMetanode.prototype.parseExtentBits = function(extentBytes, extentBits, index) {\n    var value = 0;\n\n    for (var i = 0, li = extentBits; i < li; i++) {\n        var byteIndex = index >> 3;\n        var bitIndex = index & 0x7;\n\n        if (extentBytes[byteIndex] & (1 << (7-bitIndex))) {\n            value = value | (1 << (li - i - 1));\n        }\n\n        index ++;\n    }\n\n    value /= (1 << li) - 1;\n//    value *= maxExtent;\n\n    return value;\n};\n\n\nMapMetanode.prototype.hasGeometry = function() {\n    return ((this.flags & 1) != 0);\n};\n\n\nMapMetanode.prototype.hasNavtile = function() {\n    return ((this.flags & (1 << 1)) != 0);\n};\n\n\nMapMetanode.prototype.usedTexelSize = function() {\n    return ((this.flags & (1 << 2)) != 0);\n};\n\n\nMapMetanode.prototype.usedDisplaySize = function() {\n    return ((this.flags & (1 << 3)) != 0);\n};\n\nMapMetanode.prototype.parseMetanode = function(stream) {\n\n/*\nstruct Metanode {\n    char flags;                   // #0 - geometry present, #1 - navtile present #2 - applyTexelSize,\n                                  // #3 - applyPixelSize, #4,5,6,7 - ul,ur,ll,lr child exists\n    char geomExtents[];           // a packed array of 6 bit sequences, each lod+2 long, in the following order:\n                                  // minx,maxx,miny,maxy,minz,maxz, undefined if no geometry present\n    uchar internalTextureCount;   // number of internal textures in geometry\n    hfloat texelSize;             // internal texel size in physical srs units, undef unless applyTexelSize is set\n    ushort displaySize;           // desired display size, undef unless applyDisplay size is set\n    short minHeight, maxHeight;   // navigation tile value range, undef if no navtile present\n}\n*/\n\n    var streamData = stream.data;\n    //var lastIndex = stream.index;\n    var version = this.metatile.version;\n\n    this.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    if (version < 5) {\n        var extentsSize = (((this.id[0] + 2) * 6 + 7) >> 3);\n        var extentsBytes = this.map.metanodeBuffer;//new Uint8Array(extentsSize);\n    \n        for (var i = 0, li = extentsSize; i < li; i++) {\n            extentsBytes[i] = streamData.getUint8(stream.index, true); stream.index += 1;\n        }\n    \n        var extentBits = this.id[0] + 2;\n    \n        var minExtents = [0,0,0];\n        var maxExtents = [0,0,0];\n    \n        var index = 0;\n        var spaceExtentSize = this.map.spaceExtentSize;\n        var spaceExtentOffset = this.map.spaceExtentOffset;\n    \n        for (i = 0; i < 3; i++) {\n            minExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index) * spaceExtentSize[i] + spaceExtentOffset[i];\n            //minExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index, 1.0);\n            index += extentBits;\n            maxExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index) * spaceExtentSize[i] + spaceExtentOffset[i];\n            //maxExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index, 1.0);\n            index += extentBits;\n        }\n    \n        //check zero bbox\n        var extentsBytesSum = 0;\n        for (i = 0, li = extentsBytes.length; i < li; i++) {\n            extentsBytesSum += extentsBytes[i];\n        }\n        \n        //extent bytes are empty and therefore bbox is empty also\n        if (extentsBytesSum == 0 ) {\n            //console.log(\"empty-node: id: \" + JSON.stringify(this.id));\n            //console.log(\"empty-node: surafce: \" + this.metatile.surface.id);\n    \n            minExtents[0] = Number.POSITIVE_INFINITY;\n            minExtents[1] = Number.POSITIVE_INFINITY;\n            minExtents[2] = Number.POSITIVE_INFINITY;\n            maxExtents[0] = Number.NEGATIVE_INFINITY;\n            maxExtents[1] = Number.NEGATIVE_INFINITY;\n            maxExtents[2] = Number.NEGATIVE_INFINITY;\n        }\n    \n        this.bbox = new BBox(minExtents[0], minExtents[1], minExtents[2], maxExtents[0], maxExtents[1], maxExtents[2]);\n    }    \n\n    //this.surrogatezHeight = 0;\n\n    if (version >= 4) {\n        this.minZ = streamData.getFloat32(stream.index, true); stream.index += 4;\n        this.maxZ = streamData.getFloat32(stream.index, true); stream.index += 4;\n        this.surrogatez = streamData.getFloat32(stream.index, true); stream.index += 4;\n\n        //if (!(this.minZ > this.maxZ || this.surrogatez == Number.NEGATIVE_INFINITY)) {\n          //  this.surrogatezHeight = this.surrogatez; //have to converted to nav srs height\n        //}\n    }\n\n\n\n    this.internalTextureCount = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    this.pixelSize = utils.decodeFloat16( streamData.getUint16(stream.index, true) ); stream.index += 2;\n    this.displaySize = streamData.getUint16(stream.index, true); stream.index += 2;\n    this.displaySize = this.metatile.surface.displaySize; //1024;\n    if ((this.flags & (1 << 2)) == 0) {\n        this.pixelSize = Number.POSITIVE_INFINITY;\n    }\n\n    if ((this.flags & (1 << 3)) == 0) {\n        this.displaySize = 256;\n    }\n\n    this.minHeight = streamData.getInt16(stream.index, true); stream.index += 2;\n    this.maxHeight = streamData.getInt16(stream.index, true); stream.index += 2;\n\n    if (version < 4) {\n        this.minZ = this.minHeight;\n        this.maxZ = this.maxHeight;\n        this.surrogatez =this.minHeight;\n    }\n\n    this.minZ2 = this.minZ;\n    this.maxZ2 = this.maxZ;\n\n    \n    if (this.metatile.version >= 3) {\n        if (this.metatile.flags & (1<<7)) {\n            this.sourceReference = streamData.getUint16(stream.index, true); stream.index += 2;\n        } else if (this.metatile.flags & (1<<6)) {\n            this.sourceReference = streamData.getUint8(stream.index, true); stream.index += 1;\n        }\n    }\n\n    this.heightReady = this.hasNavtile();\n    \n    this.alien = false;\n\n    //var nodeSize2 = stream.index - lastIndex;\n\n    //if (!this.map.config.mapSmartNodeParsing) {\n    this.generateCullingHelpers();\n    //}    \n};\n\n\nMapMetanode.prototype.clone = function() {\n    var node = new  MapMetanode(this.metatile, this.id);\n    node.flags = this.flags;\n    node.minHeight = this.minHeight;\n    node.maxHeight = this.maxHeight;\n    node.minZ = this.minZ;\n    node.maxZ = this.maxZ;\n    node.minZ2 = this.minZ2;\n    node.maxZ2 = this.maxZ2;\n    node.llx = this.llx;\n    node.lly = this.lly;\n    node.urx = this.urx;\n    node.ury = this.ury;\n    node.surrogatez = this.surrogatez;\n    node.internalTextureCount = this.internalTextureCount;\n    node.pixelSize = this.pixelSize;\n    node.displaySize = this.displaySize;\n    node.ready = this.ready;\n    node.stream = this.stream;\n    node.heightReady = this.heightReady;\n    \n    //copy credits\n    node.credits = new Array(this.credits.length);\n    \n    for (var i = 0, li = this.credits.length; i < li; i++) {\n        node.credits[i] = this.credits[i];\n    }\n\n    if (this.bbox) {\n        node.bbox = this.bbox.clone();\n    }\n\n\n//    if (this.map.config.mapGeocentCulling) {\n    node.diskPos = this.diskPos;\n    node.diskNormal = this.diskNormal; \n    node.diskAngle = this.diskAngle;\n    node.diskAngle2 = this.diskAngle2;\n    node.diskAngle2A = this.diskAngle2A;\n    node.diskDistance = this.diskDistance; \n    node.bbox2 = this.bbox2;  \n\n    node.divisionNode = this.divisionNode;\n\n //   }\n\n    if (this.plane) {\n        node.plane = this.plane.slice();\n    }\n\n    return node;\n};\n\n\nMapMetanode.prototype.generateCullingHelpers = function(virtual) {\n    this.ready = true;\n    \n    var map = this.map;\n    var draw = map.draw;\n    var geocent = map.isGeocent;\n    var version = this.metatile.useVersion;\n\n    if (this.id[0] < map.measure.minDivisionNodeDepth || (!geocent && version < 4)) {\n        return;\n    }\n\n    if (map.config.mapPreciseCulling || version >= 4) { //use division node srs\n        if (virtual) {\n            return; //result is same for each tile id\n        }\n\n        var divisionNode;\n        var llx, lly, urx, ury;\n        var pos = draw.tmpVec3;\n        \n        if (this.id[0] > map.measure.maxDivisionNodeDepth) {\n            var pos2 = draw.tmpVec5;\n            \n            divisionNode = map.measure.getSpatialDivisionNodeFromId(this.id);\n\n            if (!divisionNode) {\n                return;\n            }\n\n            map.measure.getSpatialDivisionNodeAndExtents2(this.id, pos2, divisionNode);\n            //var node = pos2[0]; \n            llx = pos2[1];\n            lly = pos2[2];\n            urx = pos2[3];\n            ury = pos2[4];\n\n            this.divisionNode = divisionNode;\n\n            /*if (this.id[0] == 2 && this.id[1] == 0 && this.id[2] == 2) {\n                var res = this.map.measure.getSpatialDivisionNodeAndExtents(this.id);\n                res = res;\n            }*/\n            \n        } else {\n            var res = map.measure.getSpatialDivisionNodeAndExtents(this.id);\n            divisionNode = res ? res[0] : null; \n\n            if (!divisionNode) {\n                return;\n            }\n                        \n            llx = res[1][0][0];\n            lly = res[1][0][1];\n            urx = res[1][1][0];\n            ury = res[1][1][1];\n            this.divisionNode = divisionNode;\n        }\n\n        this.llx = llx;\n        this.lly = lly;\n        this.urx = urx;\n        this.ury = ury;\n        \n        var h = this.minZ;\n        //var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5, h];\n        //var normal = [0,0,0];\n        \n        pos[0] = (urx + llx)* 0.5; \n        pos[1] = (ury + lly)* 0.5; \n        pos[2] = h; \n        \n        divisionNode.getPhysicalCoordsFast(pos, true, this.diskPos, 0, 0);\n        \n        if (geocent) {\n            this.diskDistance = vec3.length(this.diskPos); \n            vec3.normalize(this.diskPos, this.diskNormal);\n        } else {\n            this.diskNormal[0] = 0;\n            this.diskNormal[1] = 0;\n            this.diskNormal[2] = 1;\n        }\n        //this.diskNormal = normal;   \n        var normal = this.diskNormal;\n        \n        \n        //if (divisionNode.id[0] == 1 && divisionNode.id[1] ==  1 && divisionNode.id[2] == 0) {   //???? debug?????\n          //  var res = this.map.getSpatialDivisionNodeAndExtents(this.id);\n          //  node = node;\n        //}\n        \n        pos[0] = urx; \n        pos[1] = ury; \n        pos[2] = h; \n\n        /*if (this.id[0] == 17 && this.id[1] == 53306 && this.id[2] == 30754) {\n            normal = normal;\n        }*/\n        \n        var bbox = this.bbox2;\n\n        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 0);\n\n        pos[1] = lly; \n        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 3);\n        \n        pos[0] = llx; \n        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 6);\n        \n        pos[1] = ury; \n        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 9);\n\n        var height;\n\n        if (!geocent) {\n            height = this.maxZ - h;\n            \n            bbox[12] = bbox[0];\n            bbox[13] = bbox[1];\n            bbox[14] = bbox[2] + height;\n            \n            bbox[15] = bbox[3];\n            bbox[16] = bbox[4];\n            bbox[17] = bbox[5] + height;\n        \n            bbox[18] = bbox[6];\n            bbox[19] = bbox[7];\n            bbox[20] = bbox[8] + height;\n        \n            bbox[21] = bbox[9];\n            bbox[22] = bbox[10];\n            bbox[23] = bbox[11] + height;\n            return;        \n        }\n\n        var normalize;\n        var dot = vec3.dot;\n        var d1, d2, d3, d4, maxDelta;\n\n        if (map.config.mapPreciseBBoxTest || version >= 4) { \n        //if (true) { \n            height = this.maxZ - h;\n\n            if (this.id[0] <= 3) { //get aabbox for low lods\n                normalize = vec3.normalize2; \n\n                normalize(bbox, 0, pos);\n                d1 = dot(normal, pos);\n                \n                normalize(bbox, 3, pos);\n                d2 = dot(normal, pos);\n        \n                normalize(bbox, 6, pos);\n                d3 = dot(normal, pos);\n        \n                normalize(bbox, 9, pos);\n                d4 = dot(normal, pos);\n\n                maxDelta = Math.min(d1, d2, d3, d4);\n\n                pos[0] = (urx + llx)* 0.5; \n                pos[1] = ury; \n                pos[2] = h; \n                \n                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 12);\n\n                pos[1] = lly; \n                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 15);\n\n                pos[0] = urx; \n                pos[1] = (ury + lly)* 0.5; \n                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 18);\n\n                pos[0] = llx; \n                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 21);\n\n                var mpos = this.diskPos;\n                var maxX = Math.max(bbox[0], bbox[3], bbox[6], bbox[9], bbox[12], bbox[15], bbox[18], bbox[21], mpos[0]);\n                var minX = Math.min(bbox[0], bbox[3], bbox[6], bbox[9], bbox[12], bbox[15], bbox[18], bbox[21], mpos[0]);\n                \n                var maxY = Math.max(bbox[1], bbox[4], bbox[7], bbox[10], bbox[13], bbox[16], bbox[19], bbox[22], mpos[1]);\n                var minY = Math.min(bbox[1], bbox[4], bbox[7], bbox[10], bbox[13], bbox[16], bbox[19], bbox[22], mpos[1]);\n                \n                var maxZ = Math.max(bbox[2], bbox[5], bbox[8], bbox[11], bbox[14], bbox[17], bbox[20], bbox[23], mpos[2]);\n                var minZ = Math.min(bbox[2], bbox[5], bbox[8], bbox[11], bbox[14], bbox[17], bbox[20], bbox[23], mpos[2]);\n                \n                if (this.id[0] <= 1) {\n                    pos[0] = urx + (llx-urx )* 0.25; \n                    pos[1] = (ury + lly)* 0.5; \n                    \n                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 12);\n    \n                    pos[0] = urx + (llx-urx )* 0.75; \n                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 15);\n    \n                    pos[0] = (urx + llx)* 0.5; \n                    pos[1] = ury + (lly-ury )* 0.25; \n                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 18);\n    \n                    pos[1] = ury + (lly-ury )* 0.75; \n                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 21);\n\n                    maxX =  Math.max(maxX, bbox[12], bbox[15], bbox[18], bbox[21]);\n                    minX =  Math.min(minX, bbox[12], bbox[15], bbox[18], bbox[21]);\n                    \n                    maxY =  Math.max(maxY, bbox[13], bbox[16], bbox[19], bbox[22]);\n                    minY =  Math.min(minY, bbox[13], bbox[16], bbox[19], bbox[22]);\n                    \n                    maxZ =  Math.max(maxZ, bbox[14], bbox[17], bbox[20], bbox[23]);\n                    minZ =  Math.min(minZ, bbox[14], bbox[17], bbox[20], bbox[23]);\n\n                    maxDelta = -1;//full circle;\n                }\n\n                bbox[0] = minX; bbox[1] = minY; bbox[2] = minZ;\n                bbox[3] = maxX; bbox[4] = minY; bbox[5] = minZ;\n                bbox[6] = maxX; bbox[7] = maxY; bbox[8] = minZ;\n                bbox[9] = minX; bbox[10] = maxY; bbox[11] = minZ;\n\n                bbox[12] = minX; bbox[13] = minY; bbox[14] = maxZ;\n                bbox[15] = maxX; bbox[16] = minY; bbox[17] = maxZ;\n                bbox[18] = maxX; bbox[19] = maxY; bbox[20] = maxZ;\n                bbox[21] = minX; bbox[22] = maxY; bbox[23] = maxZ;\n            } else {\n\n                normalize = vec3.normalize3; \n                dot = vec3.dot2;\n\n                normalize(bbox, 0, bbox, 12);\n                d1 = dot(normal, bbox, 12);\n                \n                normalize(bbox, 3, bbox, 15);\n                d2 = dot(normal, bbox, 15);\n        \n                normalize(bbox, 6, bbox, 18);\n                d3 = dot(normal, bbox, 18);\n        \n                normalize(bbox, 9, bbox, 21);\n                d4 = dot(normal, bbox, 21);\n    \n                maxDelta = Math.min(d1, d2, d3, d4);\n\n                if (this.id[0] <= 8) { //extend bbox because of lon curvature\n                    pos = this.diskPos;\n\n                    var expand = 0.12 / (9-4) * (5-(this.id[0]-4));\n\n                    bbox[0] += (bbox[0] - pos[0]) * expand;\n                    bbox[1] += (bbox[1] - pos[1]) * expand;\n                    bbox[2] += (bbox[2] - pos[2]) * expand;\n\n                    bbox[3] += (bbox[3] - pos[0]) * expand;\n                    bbox[4] += (bbox[4] - pos[1]) * expand;\n                    bbox[5] += (bbox[5] - pos[2]) * expand;\n\n                    bbox[6] += (bbox[6] - pos[0]) * expand;\n                    bbox[7] += (bbox[7] - pos[1]) * expand;\n                    bbox[8] += (bbox[8] - pos[2]) * expand;\n\n                    bbox[9] += (bbox[9] - pos[0]) * expand;\n                    bbox[10] += (bbox[10] - pos[1]) * expand;\n                    bbox[11] += (bbox[11] - pos[2]) * expand;\n                }\n\n                //extend bbox height by tile curvature \n                height += draw.planetRadius - (draw.planetRadius * maxDelta);  \n                \n                bbox[12] = bbox[0] + bbox[12] * height;\n                bbox[13] = bbox[1] + bbox[13] * height;\n                bbox[14] = bbox[2] + bbox[14] * height;\n                \n                bbox[15] = bbox[3] + bbox[15] * height;\n                bbox[16] = bbox[4] + bbox[16] * height;\n                bbox[17] = bbox[5] + bbox[17] * height;\n            \n                bbox[18] = bbox[6] + bbox[18] * height;\n                bbox[19] = bbox[7] + bbox[19] * height;\n                bbox[20] = bbox[8] + bbox[20] * height;\n            \n                bbox[21] = bbox[9] + bbox[21] * height;\n                bbox[22] = bbox[10] + bbox[22] * height;\n                bbox[23] = bbox[11] + bbox[23] * height;\n            }\n        \n        } else {\n            normalize = vec3.normalize2; \n\n            normalize(bbox, 0, pos);\n            d1 = dot(normal, pos);\n            \n            normalize(bbox, 3, pos);\n            d2 = dot(normal, pos);\n    \n            normalize(bbox, 6, pos);\n            d3 = dot(normal, pos);\n    \n            normalize(bbox, 9, pos);\n            d4 = dot(normal, pos);\n\n            maxDelta = Math.min(d1, d2, d3, d4);\n        }\n\n        //get cos angle based at 90deg\n        this.diskAngle = Math.cos(Math.max(0,(Math.PI * 0.5) - Math.acos(maxDelta)));\n        this.diskAngle2 = maxDelta;\n        this.diskAngle2A = Math.acos(maxDelta); //optimalization\n\n        //shift center closer to earth\n        //var factor = this.bbox.maxSize * 0.2; \n        //this.diskPos = [this.diskPos[0] - normal[0] * factor, this.diskPos[1]  - normal[1] * factor, this.diskPos[2] - normal[2] * factor];   \n    } \n};\n\n\nMapMetanode.prototype.getWorldMatrix = function(geoPos, matrix) {\n    // Note: the current camera geographic position (geoPos) is not necessary\n    // here, in theory, but for numerical stability (OpenGL ES is float only)\n    // we get rid of the large UTM numbers in the following subtractions. The\n    // camera effectively stays in the position [0,0] and the tiles travel\n    // around it. (The Z coordinate is fine and is not handled in this way.)\n\n    var m = matrix;\n\n    if (m != null) {\n        m[0] = this.bbox.side(0); m[1] = 0; m[2] = 0; m[3] = 0;\n        m[4] = 0; m[5] = this.bbox.side(1); m[6] = 0; m[7] = 0;\n        m[8] = 0; m[9] = 0; m[10] = this.bbox.side(2); m[11] = 0;\n        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;\n    } else {\n        m = mat4.create();\n\n        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),\n                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);\n    }\n\n    return m;\n};\n\n\nMapMetanode.prototype.drawBBox = function(cameraPos) {\n    if (this.metatile.useVersion >= 4) {\n        return this.drawBBox2(cameraPos);\n    }\n\n    var renderer = this.map.renderer;\n\n    renderer.gpu.useProgram(renderer.progBBox, ['aPosition']);\n\n    var mvp = mat4.create();\n    var mv = mat4.create();\n\n    mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);\n\n    var proj = renderer.camera.getProjectionMatrix();\n    mat4.multiply(proj, mv, mvp);\n\n    renderer.progBBox.setMat4('uMVP', mvp);\n\n    //draw bbox\n    renderer.bboxMesh.draw(renderer.progBBox, 'aPosition');\n};\n\n\nMapMetanode.prototype.drawBBox2 = function() {\n    //var spoints = []; \n    //for (var i = 0, li = this.bbox2.length; i < li; i++) {\n        //var pos = this.bbox2[i];\n        //pos = [\"obj\", pos[0], pos[1], \"fix\", pos[2], 0, 0, 0, 10, 90 ];\n        \n    var bbox = this.bbox2;\n    var buffer = this.map.draw.bboxBuffer;\n    var camPos = this.map.camera.position;\n    var renderer = this.map.renderer;\n    var prog = renderer.progBBox2;\n\n    for (var i = 0, li = 8*3; i < li; i+=3) {\n        //var pos = [\"obj\", bbox[i], bbox[i+1], \"fix\", bbox[i+2], 0, 0, 0, 10, 90 ];\n        //var coords = this.map.convert.getPositionCameraCoords((new MapPosition(pos)), null, true);\n\n        buffer[i] = bbox[i] - camPos[0];\n        buffer[i+1] = bbox[i+1] - camPos[1];\n        buffer[i+2] = bbox[i+2] - camPos[2];\n    }\n    \n\n    renderer.gpu.useProgram(prog, ['aPosition']);\n\n    prog.setFloatArray('uPoints', buffer);\n\n    //var mvp = mat4.create();\n    //var mv = mat4.create();\n\n    //mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);\n\n    //var proj = renderer.camera.getProjectionMatrix();\n    //mat4.multiply(proj, mv, mvp);\n\n    var mvp = renderer.camera.getMvpMatrix();\n\n    prog.setMat4('uMVP', mvp);\n\n    //draw bbox\n    renderer.bboxMesh2.draw(prog, 'aPosition');\n};\n\nMapMetanode.prototype.drawPlane = function(cameraPos, tile) {\n    var renderer = this.map.renderer;\n    var buffer = this.map.draw.planeBuffer;\n    var points = this.plane;\n    \n    if (!points) {\n        return;\n    }\n\n    renderer.gpu.useProgram(renderer.progPlane, ['aPosition', 'aTexCoord']);\n\n    var mvp = mat4.create();\n    var mv = renderer.camera.getModelviewMatrix();\n    var proj = renderer.camera.getProjectionMatrix();\n    mat4.multiply(proj, mv, mvp);\n    \n    var sx = cameraPos[0];\n    var sy = cameraPos[1];\n    var sz = cameraPos[2];\n\n    for (var i = 0; i < 9; i++) {\n        var index = i*3;\n        buffer[index] = points[index] - sx; \n        buffer[index+1] = points[index+1] - sy; \n        buffer[index+2] = points[index+2] - sz; \n    }\n    \n    var prog = renderer.progPlane; \n\n    prog.setMat4('uMV', mv);\n    prog.setMat4('uProj', proj);\n    prog.setFloatArray('uPoints', buffer);\n\n    //var minTile = 32;\n    var embed = 8;\n    var altitude = Math.max(10, tile.distance + 20);\n    var gridSelect = (Math.log(altitude) / Math.log(embed));\n    var step1 = 4;//(Math.pow(embed, Math.floor(gridSelect)));\n    var step2 = 8;//(Math.pow(embed, Math.ceil(gridSelect)));\n    var blend = (gridSelect - Math.floor(gridSelect));\n    //var blend = 0;\n\n    //prog.setVec4(\"uParams\", [0,0,1/15,0]);\n    //prog.setVec4(\"uParams\", [(minTile / step1),0,1/15,(minTile / step2)]);\n    prog.setVec4('uParams', [step1, 0, 1/15, step2]);\n\n    //prog.setVec4(\"uParams2\", [(minTile / step1), (minTile / step2), blend, 0]);\n    prog.setVec4('uParams2', [0, 0, blend, 0]);\n\n    renderer.gpu.bindTexture(renderer.heightmapTexture);\n    \n    //draw bbox\n    renderer.planeMesh.draw(renderer.progPlane, 'aPosition', 'aTexCoord');\n};\n\n\nMapMetanode.prototype.getGridHeight = function(coords, data, dataWidth) {\n    var x = coords[0] - this.llx;\n    //var y = this.ury - coords[1];\n    var y = coords[1]  - this.lly;\n    var maxX = (dataWidth-1);\n    var maxY = (dataWidth-1);\n    \n    //data coords\n    x = (maxX) * (x / (this.urx - this.llx));\n    y = (maxY) * (y / (this.ury - this.lly));\n\n    if (x < 0) { x = 0; }\n    if (y < 0) { y = 0; }\n    if (x > maxX) { x = maxX; }\n    if (y > maxY) { y = maxY; }\n\n    var ix = Math.floor(x);\n    var iy = Math.floor(y);\n    var fx = x - ix;\n    var fy = y - iy;\n\n    var index = iy * dataWidth;\n    var index2 = (iy == maxY) ? index : index + dataWidth;\n    var ix2 = (ix == maxX) ? ix : ix + 1; \n    var h00 = data[index + ix];\n    var h01 = data[index + ix2];\n    var h10 = data[index2 + ix];\n    var h11 = data[index2 + ix2];\n    var w0 = (h00 + (h01 - h00)*fx);\n    var w1 = (h10 + (h11 - h10)*fx);\n    var height = (w0 + (w1 - w0)*fy);\n\n    return height;\n};\n\nexport default MapMetanode;\n\n","\nimport {utils as utils_} from '../utils/utils';\nimport MapMetanode_ from './metanode';\n\n//get rid of compiler mess\nvar utils = utils_;\nvar MapMetanode = MapMetanode_;\n\n\nvar MapMetatile = function(metaresources, surface, tile) {\n    this.metaresources= metaresources; //this is metastorage tile\n    this.map = metaresources.map;\n    this.surface = surface;\n    this.id = metaresources.id;\n    this.tile = tile; // used only for stats\n    this.nodes = [];\n    this.drawCounter = 0;\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.size = 0;\n    this.cacheItem = null;\n};\n\n\nMapMetatile.prototype.kill = function(killedByCache) {\n    if (killedByCache !== true && this.cacheItem != null) {\n        this.map.metatileCache.remove(this.cacheItem);\n    }\n\n    if (this.metaresources) {\n        this.metaresources.removeMetatile(this);\n        //this.metaresources.validate();\n        //this.metaresources = null;\n    }\n\n    this.loadState = 0;\n    this.surface = 0;\n    this.cacheItem = null;\n\n    this.nodes = [];\n};\n\n\nMapMetatile.prototype.clone = function(surface) {\n    var metatile = new MapMetatile(this.metaresources, surface);\n    metatile.nodes = this.nodes;\n    metatile.loadState = this.loadState;\n    metatile.nodes = this.nodes;\n    metatile.size = this.size;\n\n    metatile.lod = this.lod;\n    metatile.metatileIdx = this.metatileIdx;\n    metatile.metatileIdy = this.metatileIdy;\n    metatile.offsetx = this.offsetx;\n    metatile.offsety = this.offsety;\n    metatile.sizex = this.sizex;\n    metatile.sizey = this.sizey;\n    metatile.version = this.version;\n    metatile.credits = this.credits;\n\n    if (this.version < 2) {\n        metatile.nodeSize = this.nodeSize;\n    } else {\n        metatile.flags = this.flags;\n        metatile.creditCount = this.creditCount;\n        metatile.flagPlanes = this.flagPlanes;\n    }\n\n    metatile.cacheItem= this.map.metatileCache.insert(metatile.kill.bind(metatile, true), metatile.size);\n    return metatile;\n};\n\n\nMapMetatile.prototype.isReady = function (/*doNotLoad,*/ priority) {\n    //if (this.id[0] == 18 &&\n    //    this.id[1] == 130400 &&\n    //    this.id[2] == 129088) {\n    //    debugger;\n    //}\n\n    if (this.loadState == 2) { //loaded\n        return true;\n    } else {\n\n        if (this.loadState == 0) { \n            //if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                  //  this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            //} else {\n                //not loaded\n                //add to loading queue or top position in queue\n            if (this.loadState == 3) { //loadError\n                if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                        performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n\n                    this.scheduleLoad(priority);                    \n                }\n            } else {\n                this.scheduleLoad(priority);\n            }\n            //}\n        } //else load in progress\n        \n        return false;\n    }\n};\n\n\nMapMetatile.prototype.used = function() {\n    if (this.cacheItem != null) {\n        this.map.metatileCache.updateItem(this.cacheItem);\n    }\n};\n\n\nMapMetatile.prototype.getNode = function(id) {\n    var x = id[1] - this.id[1] - this.offsetx;\n    var y = id[2] - this.id[2] - this.offsety;\n    \n    if (x < 0 || y < 0 || x >= this.sizex || y >= this.sizey) {\n        return null;\n    }\n    \n    var node = this.nodes[this.sizex * y + x];\n\n    if (!node) {\n        var index = this.sizex * y + x;\n        var stream = {data:this.data, index:this.metanodesIndex + (index * this.metanodeSize)};\n        node = (new MapMetanode(this, [this.lod, this.metatileIdx + this.offsetx + x, this.metatileIdy + this.offsety + y], stream, this.divisionNode)); \n        this.nodes[index] = node;\n        this.applyMetanodeCredits(x, y);\n        this.applyMetatanodeBitplanes(x, y); \n    }\n\n/*    \n    if (!node.ready) {\n        node.generateCullingHelpers();\n        node.ready = true;\n    }\n*/\n    \n    return node;\n};\n\n\nMapMetatile.prototype.scheduleLoad = function() {\n    if (this.mapLoaderUrl == null) {\n        this.mapLoaderUrl = this.surface.getMetaUrl(this.id);\n    }\n\n    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), null, this.tile, 'metatile');\n};\n\n\nMapMetatile.prototype.onLoad = function(url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'metadata');\n    //utils.loadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n    this.loadState = 1;\n};\n\n\nMapMetatile.prototype.onLoadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    this.loadState = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n\n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n\n    this.mapLoaderCallError();\n};\n\n\nMapMetatile.prototype.onLoaded = function(data, task) {\n    if (this.map.killed){\n        return;\n    }\n\n    if (!task) {\n    //if (this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {\n        this.map.markDirty();\n        this.map.addProcessingTask(this.onLoaded.bind(this, data, true));\n        return;\n    }\n\n    data = new DataView(data);\n\n    this.size += data.byteLength * 4;\n    \n    this.data = data;\n\n    var t = performance.now();\n    this.parseMetatatile({data:data, index: 0});\n    this.map.stats.renderBuild += performance.now() - t; \n\n    this.cacheItem= this.map.metatileCache.insert(this.kill.bind(this, true), this.size);\n\n    this.map.markDirty();\n    this.loadState = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.mapLoaderCallLoaded();\n};\n\n\nMapMetatile.prototype.parseMetatatile = function(stream) {\n\n/*\n    struct Header {\n\n        char magic[2];                         // letters \"MT\"\n        ushort version;                        // version\n        uchar lod;                             // common lod\n        uint metatileIdx, metatileIdy;         // id of upper left tile corner (reflected in tile name)\n        ushort offsetx, offsety;               // offset of valid data block\n        ushort sizex, sizey;                   // dimensions of metanode grid\n        uchar nodeSize;                        // size of a metanode in bytes\n        uchar creditCount;                     // total number of credit blocks (= number of attributions used by nodes)\n        ushort creditSize;                     // size of credit block in bytes\n    };\n*/\n\n    var streamData = stream.data;\n    var magic = '';\n\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n\n    if (magic != 'MT') {\n        return;\n    }\n\n    this.version = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    if (this.version > 5) {\n        return;\n    }\n\n    this.lod = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    this.metatileIdx = streamData.getUint32(stream.index, true); stream.index += 4;\n    this.metatileIdy = streamData.getUint32(stream.index, true); stream.index += 4;\n\n    this.offsetx = streamData.getUint16(stream.index, true); stream.index += 2;\n    this.offsety = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    this.sizex = streamData.getUint16(stream.index, true); stream.index += 2;\n    this.sizey = streamData.getUint16(stream.index, true); stream.index += 2;\n    \n    this.flagPlanes = new Array(8);\n\n    if (this.version < 2) {\n        this.nodeSize = streamData.getUint8(stream.index, true); stream.index += 1;\n    } else {\n        this.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n        this.creditCount = streamData.getUint8(stream.index, true); stream.index += 1;\n        this.parseFlagPlanes(stream);\n    }\n\n    this.parseMetatatileCredits(stream);\n    this.parseMetatatileNodes(stream);\n    \n    this.useVersion = (this.map.config.mapForceMetatileV3 && this.version < 5) ? 3 : this.version; \n};\n\n\nMapMetatile.prototype.parseFlagPlanes = function(stream) {\n    var streamData = stream.data;\n\n    //rounded to bytes\n    var bitplaneSize = ((this.sizex * this.sizey + 7) >> 3);\n\n    for (var i = 0; i < 6; i++) {\n        if ((this.flags & (1 << i)) != 0) {\n\n            var bitplane = new Uint8Array(bitplaneSize);\n    \n            for (var j = 0; j < bitplaneSize; j++) {\n                bitplane[j] = streamData.getUint8(stream.index, true); stream.index += 1;\n            }\n    \n            this.flagPlanes[i] = bitplane; \n        }\n    }\n};\n\n\nMapMetatile.prototype.parseMetatatileCredits = function(stream) {\n\n/*\n    struct CreditBlock {\n       ushort creditId;       // numerical creditId\n       char creditMask[];     // bitfield of size header.sizex * header.sizey, row major, row padded\n    };\n*/\n\n    var streamData = stream.data;\n    \n    if (this.version < 2) {\n        this.creditCount = streamData.getUint8(stream.index, true); stream.index += 1;\n        this.creditSize = streamData.getUint16(stream.index, true); stream.index += 2;\n    }\n    \n    if (this.creditCount == 0) {\n        this.credits = [];\n        return;\n    }\n\n    //rounded to bytes\n    var bitfieldSize = ((this.sizex * this.sizey + 7) >> 3);\n\n    this.credits = new Array(this.creditCount);\n\n    for (var i = 0, li = this.credits.length; i < li; i++) {\n        var creditId = streamData.getUint16(stream.index, true); stream.index += 2;\n        var bitfield = new Uint8Array(bitfieldSize);\n\n        for (var j = 0; j < bitfieldSize; j++) {\n            bitfield[j] = streamData.getUint8(stream.index, true); stream.index += 1;\n        }\n    \n        var credit = this.map.getCreditByNumber(creditId);\n        var stringId = credit ? credit.key : null;\n\n        this.credits[i] = { creditId : stringId, creditMask: bitfield};\n    }\n};\n\n\nMapMetatile.prototype.applyMetatatileBitplanes = function() {\n    for (var i = 0; i < 1; i++) {\n        if (this.flagPlanes[i]) {\n            \n            var bitplane = this.flagPlanes[i]; \n    \n            for (var y = 0; y < this.sizey; y++) {\n                for (var x = 0; x < this.sizex; x++) {\n                    var byteIndex = this.sizex * y + x;\n                    var bitIndex = byteIndex & 7;\n                    var bitMask = 1 << bitIndex;\n                    byteIndex >>= 3;\n                    \n                    if (bitplane[byteIndex] & bitMask) {\n                        switch(i) {\n                        case 0:\n                            this.nodes[y*this.sizex+x].alien = true;\n                            break;       \n                        }\n                    }\n                }\n            }\n        }\n    }\n};\n\n\nMapMetatile.prototype.applyMetatanodeBitplanes = function(x, y) {\n    for (var i = 0; i < 1; i++) {\n        if (this.flagPlanes[i]) {\n            var bitplane = this.flagPlanes[i]; \n            var byteIndex = this.sizex * y + x;\n            var bitIndex = byteIndex & 7;\n            var bitMask = 1 << bitIndex;\n            byteIndex >>= 3;\n            \n            if (bitplane[byteIndex] & bitMask) {\n                switch(i) {\n                case 0:\n                    this.nodes[y*this.sizex+x].alien = true;\n                    break;       \n                }\n            }\n        }\n    }\n};\n\n\nMapMetatile.prototype.applyMetatatileCredits = function() {\n    for (var y = 0; y < this.sizey; y++) {\n        for (var x = 0; x < this.sizex; x++) {\n            var byteIndex = this.sizex * y + x;\n            var bitIndex = byteIndex & 7;\n            var bitMask = 1 << bitIndex;\n            byteIndex >>= 3;\n\n            for (var i = 0, li = this.credits.length; i < li; i++) {\n                if (this.credits[i].creditMask[byteIndex] & bitMask) {\n                    var id = this.credits[i].creditId;\n                    if (id) {\n                        this.nodes[y*this.sizex+x].credits.push(id);\n                    }\n                }\n            }\n        }\n    }\n};\n\n\nMapMetatile.prototype.applyMetanodeCredits = function(x, y) {\n    var byteIndex = this.sizex * y + x;\n    var bitIndex = byteIndex & 7;\n    var bitMask = 1 << bitIndex;\n    byteIndex >>= 3;\n\n    for (var i = 0, li = this.credits.length; i < li; i++) {\n        if (this.credits[i].creditMask[byteIndex] & bitMask) {\n            var id = this.credits[i].creditId;\n            if (id) {\n                this.nodes[y*this.sizex+x].credits.push(id);\n            }\n        }\n    }\n};\n\n\nMapMetatile.prototype.parseMetatatileNodes = function(stream) {\n    this.metanodesIndex = stream.index;\n    this.metanodeSize = 1 + 1 + 2 + 2 + 2 + 2;\n    \n    if (this.version >= 5) {\n        this.metanodeSize += 3 * 4;\n    } else {\n        this.metanodeSize += Math.floor((6 * (this.id[0] + 2) + 7) / 8);\n\n        if (this.version == 4) {\n            this.metanodeSize += 3 * 4;\n        }\n    }\n\n    if (this.version >= 3) {\n        if (this.flags & (1<<7)) {\n            this.metanodeSize += 2;\n        } else if (this.flags & (1<<6)) {\n            this.metanodeSize += 1;\n        }\n    }\n\n    if (this.lod >= this.map.measure.minDivisionNodeDepth) {\n        this.divisionNode = this.map.measure.getSpatialDivisionNodeAndExtents([this.lod, this.metatileIdx + this.offsetx, this.metatileIdy + this.offsety]);\n        if (this.divisionNode) {\n            this.divisionNode = this.divisionNode[0];\n        }\n    } else {\n        this.divisionNode = null;\n    }\n    \n    this.nodes = new Array(this.sizex*this.sizey);\n    \n    /*\n    var index = 0;\n\n    for (var y = 0; y < this.sizey; y++) {\n        for (var x = 0; x < this.sizex; x++) {\n            this.nodes[index] = (new MapMetanode(this, [this.lod, this.metatileIdx + this.offsetx + x, this.metatileIdy + this.offsety + y], stream, divisionNode));\n            index++;\n        }\n    }\n    \n    this.applyMetatatileCredits();\n    this.applyMetatatileBitplanes();\n    */\n};\n\n\nexport default MapMetatile;\n","\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar math = math_;\n\nvar MapPosition = function(pos) {\n    if (pos instanceof MapPosition) {\n        this.pos = pos.pos.slice();\n    } else {\n        if (!(pos != null && (pos instanceof Array))) {\n            this.pos = [];\n        } else {\n            this.pos = pos.slice();\n        }\n\n        this.validate();\n    }\n};\n\n\nMapPosition.prototype.clone = function() {\n    return new MapPosition(this.pos);\n};\n\n\nMapPosition.prototype.getCoords = function() {\n    return [this.pos[1], this.pos[2], this.pos[4]];\n};\n\n\nMapPosition.prototype.getCoords2 = function() {\n    return [this.pos[1], this.pos[2]];\n};\n\n\nMapPosition.prototype.setCoords = function(coords) {\n    this.pos[1] = coords[0];\n    this.pos[2] = coords[1];\n    this.pos[4] = coords[2];\n    return this;\n};\n\n\nMapPosition.prototype.setCoords2 = function(coords) {\n    this.pos[1] = coords[0];\n    this.pos[2] = coords[1];\n    return this;\n};\n\n\nMapPosition.prototype.getHeight = function() {\n    return this.pos[4];\n};\n\n\nMapPosition.prototype.setHeight = function(height) {\n    this.pos[4] = height;\n    return this;\n};\n\n\nMapPosition.prototype.getOrientation = function() {\n    return [this.pos[5], this.pos[6], this.pos[7]];\n};\n\n\nMapPosition.prototype.setOrientation = function(orientation) {\n    this.pos[5] = orientation[0];\n    this.pos[6] = orientation[1];\n    this.pos[7] = orientation[2];\n    return this;\n};\n\n\nMapPosition.prototype.getFov = function() {\n    return this.pos[9];\n};\n\n\nMapPosition.prototype.setFov = function(fov) {\n    this.pos[9] = fov;\n    return this;\n};\n\n\nMapPosition.prototype.getViewExtent = function() {\n    return this.pos[8];\n};\n\n\nMapPosition.prototype.setViewExtent = function(extent) {\n    this.pos[8] = extent;\n    return this;\n};\n\n\nMapPosition.prototype.getViewDistance = function() {\n    return (this.getViewExtent()*0.5) / Math.tan(math.radians(this.getFov()*0.5));\n};\n\n\nMapPosition.prototype.getViewMode = function() {\n    return this.pos[0];\n};\n\n\nMapPosition.prototype.getHeightMode = function() {\n    return this.pos[3];\n};\n\n\nMapPosition.prototype.check = function() {\n    //check pich\n    if (this.getViewMode() == 'obj') {\n        this.pos[6] = math.clamp(this.pos[6], -90.0, 90.0);\n    } else {\n        this.pos[6] = math.clamp(this.pos[6], -90.0, 90.0);\n    }\n\n    this.pos[5] = this.pos[5] % 360;\n    this.pos[7] = this.pos[7] % 360;\n};\n\n\nMapPosition.prototype.isSame = function(pos) {\n    pos = pos.pos;\n    return (this.pos[0] == pos[0] &&\n             math.isEqual(this.pos[1], pos[1], 0.0000001) &&\n             math.isEqual(this.pos[2], pos[2], 0.0000001) &&\n             this.pos[3] == pos[3] &&\n             math.isEqual(this.pos[4], pos[4], 0.001) &&\n             math.isEqual(this.pos[5], pos[5], 0.001) &&\n             math.isEqual(this.pos[6], pos[6], 0.001) &&\n             math.isEqual(this.pos[7], pos[7], 0.001) &&\n             math.isEqual(this.pos[8], pos[8], 0.001) &&\n             math.isEqual(this.pos[9], pos[9], 0.001));\n};\n\n\nMapPosition.prototype.validate = function() {\n    var pos = this.pos;\n    if (pos[0] == 'fixed') { //old format\n        pos[0] = 'obj';\n        pos[9] = pos[8];\n        pos[8] = pos[7];\n        pos[7] = pos[6];\n        pos[6] = pos[5];\n        pos[5] = pos[4];\n        pos[4] = pos[3];\n        pos[3] = 'fix';\n    }\n\n    pos[0] = (pos[0] == 'obj' || pos[0] == 'subj') ? pos[0] : 'obj';\n    pos[1] = (pos[1] != null) ? pos[1] : 0;\n    pos[2] = (pos[2] != null) ? pos[2] : 0;\n    pos[3] = (pos[3] == 'fix' || pos[3] == 'fixed' || pos[3] == 'float') ? pos[3] : 'float';\n    pos[4] = (pos[4] != null) ? pos[4] : 0;\n    pos[5] = (pos[5] != null) ? pos[5] : 0;\n    pos[6] = (pos[6] != null) ? pos[6] : -90;\n    pos[7] = (pos[7] != null) ? pos[7] : 0;\n    pos[8] = (pos[8] != null) ? pos[8] : 900;\n    pos[9] = (pos[9] != null) ? pos[9] : 45;\n\n    pos[3] = (pos[3] == 'fixed') ? 'fix' : pos[3];\n};\n\n\nMapPosition.prototype.toString = function() {\n    var p = this.pos;\n    return p[0] + ', ' + p[1].toFixed(0) + ', ' + p[2].toFixed(0) + ', ' + p[3] + ', ' + p[4].toFixed(0)\n           + ', ' + p[5].toFixed(0) + ', ' + p[6].toFixed(0) + ', ' + p[7].toFixed(0) + ', ' \n           + ', ' + p[8].toFixed(0) + ', ' + p[9].toFixed(0); \n};\n\n\nMapPosition.prototype.toArray = function() {\n    return this.pos.slice();\n};\n\n\nexport default MapPosition;\n","\nimport MapDivisionNode_ from './division-node';\n\n//get rid of compiler mess\nvar MapDivisionNode = MapDivisionNode_;\n\n\nvar MapRefFrame = function(map, json) {\n    this.map = map;\n    this.proj4 = map.proj4;\n    this.valid = false;\n    this.id = json['id'] || null;\n    this.description = json['description'] || '';\n    this.nodesMap = [];\n\n    var model = json['model'];\n\n    if (model == null) {\n        return;\n    }\n\n    this.model = {\n        physicalSrs : map.getMapsSrs(model['physicalSrs']),\n        navigationSrs : map.getMapsSrs(model['navigationSrs']),\n        publicSrs : map.getMapsSrs(model['publicSrs'])\n    };\n\n    this.body = json['body'] ? map.getBody(json['body']) : null;\n\n    this.params = {};\n\n    if (json['parameters'] != null) {\n        var params = json['parameters'];\n        this.params.metaBinaryOrder = params['metaBinaryOrder'] || 1;\n        this.params.navDelta = params['navDelta'] || 8;\n    }\n\n    var division = json['division'];\n\n    if (division == null) {\n        return;\n    }\n\n    this.division = {\n        rootLod : division['rootLod'] || 0,\n        arity : division['arity'] || null,\n        heightRange : division['heightRange'] || [0,1]\n    };\n\n    var extents = this.parseSpaceExtents(division['extents']);\n    this.division.extents = extents;\n\n    map.spaceExtentSize = [extents.ur[0] - extents.ll[0], extents.ur[1] - extents.ll[1], extents.ur[2] - extents.ll[2]];\n    map.spaceExtentOffset = extents.ll;\n\n    var divisionNodes = division['nodes'];\n    this.division.nodes = [];\n\n    if (divisionNodes == null) {\n        return;\n    }\n\n    this.hasPoles = (divisionNodes.length == 4); \n\n    for (var i = 0, li = divisionNodes.length; i < li; i++) {\n        var node = this.parseNode(divisionNodes[i]);\n        this.nodesMap['' + node.id[0] + '.'  + node.id[1] + '.' + node.id[2]] = node;\n        this.division.nodes.push(node);\n    }\n\n    this.valid = true;\n};\n\n\nMapRefFrame.prototype.getInfo = function() {\n    return {\n        'id' : this.id,\n        'physicalSrs' : this.model.physicalSrs.id,\n        'navigationSrs' : this.model.navigationSrs.id,\n        'publicSrs' : this.model.publicSrs.id\n    };\n};\n\n\nMapRefFrame.prototype.getGlobalHeightRange = function() {\n    return this.division.heightRange;     \n};\n\n\nMapRefFrame.prototype.parseNode = function(nodeData) {\n    var node = {\n        srs : nodeData['srs'],\n        partitioning : nodeData['partitioning']\n    };\n\n    node.extents = this.parseExtents(nodeData['extents']);\n\n    var nodeId = nodeData['id'];\n\n    if (nodeId == null) {\n        return;\n    }\n\n    node.id = {\n        lod : nodeId['lod'] || 0,\n        position : nodeId['position'] || [0,0]\n    };\n\n    return new MapDivisionNode(this.map, [node.id.lod, node.id.position[0], node.id.position[1]],\n                                           node.srs, node.extents, this.heightRange, node.partitioning);\n};\n\n\nMapRefFrame.prototype.parseExtents = function(extentsData) {\n    if (extentsData == null) {\n        return { ll : [0,0], ur : [1,1] };\n    }\n\n    return {\n        ll : extentsData['ll'] || [0,0],\n        ur : extentsData['ur'] || [1,1]\n    };\n};\n\n\nMapRefFrame.prototype.parseSpaceExtents = function(extentsData) {\n    if (extentsData == null) {\n        return { ll : [0,0,0], ur : [1,1,1] };\n    }\n\n    return {\n        ll : extentsData['ll'] || [0,0,0],\n        ur : extentsData['ur'] || [1,1,1]\n    };\n};\n\n\nMapRefFrame.prototype.getSpatialDivisionNodes = function() {\n    return this.division.nodes;\n};\n\n\nMapRefFrame.prototype.convertCoords = function(coords, source, destination) {\n    var sourceSrs, destinationSrs;\n\n    switch(source) {\n    case 'public':     sourceSrs = this.model.publicSrs;     break;\n    case 'physical':   sourceSrs = this.model.physicalSrs;   break;\n    case 'navigation': sourceSrs = this.model.navigationSrs; break;\n    }\n\n    switch(destination) {\n    case 'public':     destinationSrs = this.model.publicSrs;     break;\n    case 'physical':   destinationSrs = this.model.physicalSrs;   break;\n    case 'navigation': destinationSrs = this.model.navigationSrs; break;\n    }\n\n    return sourceSrs.convertCoordsTo(coords, destinationSrs);\n};\n\n\nexport default MapRefFrame;\n\n\n","\n\nvar MapRenderSlots = function(map) {\n    this.map = map;\n    this.draw = map.draw;\n    this.renderer = map.renderer;\n    this.config = map.config;\n    this.renderSlots = [];\n};\n\n\nMapRenderSlots.prototype.createRenderSlot = function(id, callback, enabled) {\n    return { id:id,\n        callback:callback,\n        enabled : enabled\n    };\n};\n\n\nMapRenderSlots.prototype.addRenderSlot = function(id, callback, enabled) {\n    this.renderSlots.push(this.createRenderSlot(id, callback, enabled));\n};\n\n\nMapRenderSlots.prototype.getRenderSlotIndex = function(id) {\n    return this.map.searchArrayIndexById(this.renderSlots, id); \n};\n\n\nMapRenderSlots.prototype.checkRenderSlotId = function(id) {\n    if (id == 'after-map-render') {\n        return 'map'; \n    } else {\n        return id;\n    }\n};\n\n\nMapRenderSlots.prototype.moveRenderSlotBefore = function(whichId, whereId) {\n    var from = this.getRenderSlotIndex(this.checkRenderSlotId(whichId));\n    var to = this.getRenderSlotIndex(whereId);\n    if (from != -1 && to != -1 && to != from-1) { \n        this.renderSlots.splice(to, 0, this.renderSlots.splice(from, 1)[0]);\n    }\n};\n\n\nMapRenderSlots.prototype.moveRenderSlotAfter = function(whichId, whereId) {\n    var from = this.getRenderSlotIndex(this.checkRenderSlotId(whichId));\n    var to = this.getRenderSlotIndex(whereId);\n    if (from != -1 && to != -1 && to != from+1) {\n        to++; \n        this.renderSlots.splice(to, 0, this.renderSlots.splice(from, 1)[0]);\n    }\n};\n\n\nMapRenderSlots.prototype.removeRenderSlot = function(id) {\n    var index = this.getRenderSlotIndex(id);\n    if (index != -1) {\n        this.renderSlots.splice(index, 1);\n    }\n};\n\n\nMapRenderSlots.prototype.setRenderSlotEnabled = function(id, state) {\n    var index = this.getRenderSlotIndex(id);\n    if (index != -1) {\n        this.renderSlots[index].enabled = state;\n    }\n};\n\n\nMapRenderSlots.prototype.getRenderSlotEnabled = function(id) {\n    var index = this.getRenderSlotIndex(id);\n    if (index != -1) {\n        return this.renderSlots[index].enabled;\n    }\n    \n    return false;\n};\n\n\nMapRenderSlots.prototype.processRenderSlots = function() {\n    if (this.draw.drawChannel != 1) {\n        this.renderer.gpu.setViewport(); //just in case\n    }\n\n    for (var i = 0, li = this.renderSlots.length; i < li; i++) {\n        var slot = this.renderSlots[i];\n\n        if (slot.enabled && slot.callback) {\n            this.renderer.gpu.setState(this.draw.drawTileState);\n            slot.callback(this.draw.drawChannelNames[this.draw.drawChannel]);\n        }\n    }\n};\n\n\nexport default MapRenderSlots;\n\n","\nimport MapTexture_ from './texture';\nimport MapSubtexture_ from './subtexture';\nimport MapMetatile_ from './metatile';\nimport MapMesh_ from './mesh';\nimport MapGeodata_ from './geodata';\n\n//get rid of compiler mess\nvar MapTexture = MapTexture_;\nvar MapSubtexture = MapSubtexture_;\nvar MapMetatile = MapMetatile_;\nvar MapMesh = MapMesh_;\nvar MapGeodata = MapGeodata_;\n\n\nvar MapResourceNode = function(map, parent, id) {\n    this.map = map;\n    this.id = id;\n    this.parent = parent;\n\n    this.metatiles = {};\n    this.meshes = {};\n    this.textures = {};\n    this.subtextures = {};\n    this.geodata = {};\n    this.credits = {};\n\n    this.children = [null, null, null, null];\n};\n\n\nMapResourceNode.prototype.kill = function() {\n    //kill children\n    for (var i = 0; i < 4; i++) {\n        if (this.children[i] != null) {\n            this.children[i].kill();\n        }\n    }\n\n    this.children = [null, null, null, null];\n\n    var parent = this.parent;\n    this.parent = null;\n\n    if (parent != null) {\n        parent.removeChild(this);\n    }\n    \n    //kill resources?\n};\n\n\nMapResourceNode.prototype.addChild = function(index) {\n    if (this.children[index]) {\n        return;\n    }\n    \n    var id = this.id;\n    var childId = [id[0] + 1, id[1] << 1, id[2] << 1];\n\n    switch (index) {\n    case 1: childId[1]++; break;\n    case 2: childId[2]++; break;\n    case 3: childId[1]++; childId[2]++; break;\n    }\n\n    this.children[index] = new MapResourceNode(this.map, this, childId);\n};\n\n\nMapResourceNode.prototype.removeChildByIndex = function(index) {\n    if (this.children[index] != null) {\n        this.children[index].kill();\n        this.children[index] = null;\n    }\n};\n\n\nMapResourceNode.prototype.removeChild = function(tile) {\n    for (var i = 0; i < 4; i++) {\n        if (this.children[i] == tile) {\n            this.children[i].kill();\n            this.children[i] = null;\n        }\n    }\n};\n\n\n// Meshes ---------------------------------\n\nMapResourceNode.prototype.getMesh = function(path, tile) {\n    var mesh = this.meshes[path];\n    \n    if (!mesh) {\n        mesh = new MapMesh(this.map, path, tile);\n        this.meshes[path] = mesh;\n    }\n    \n    return mesh;\n};\n\n\n// Geodata ---------------------------------\n\nMapResourceNode.prototype.getGeodata = function(path, extraInfo) {\n    var geodata = this.geodata[path];\n    \n    if (!geodata) {\n        geodata = new MapGeodata(this.map, path, extraInfo);\n        this.geodata[path] = geodata;\n    }\n    \n    return geodata;\n};\n\n\n// Textures ---------------------------------\n\nMapResourceNode.prototype.getTexture = function(path, type, extraBound, extraInfo, tile, internal) {\n    var texture;\n    if (extraInfo && (extraInfo.layer || extraInfo.hmap)) {\n        var id = path + (extraInfo.hmap ? '' : extraInfo.layer.id);\n        texture = this.textures[id];\n        \n        if (!texture) {\n            texture = new MapTexture(this.map, path, type, extraBound, extraInfo, tile, internal);\n            this.textures[id] = texture;\n        }\n    } else {\n        texture = this.textures[path];\n        \n        if (!texture) {\n            texture = new MapTexture(this.map, path, type, extraBound, extraInfo, tile, internal);\n            this.textures[path] = texture;\n        }\n    }\n    \n    return texture;\n};\n\n\n// SubTextures ---------------------------------\n\nMapResourceNode.prototype.getSubtexture = function(texture, path, type, extraBound, extraInfo, tile, internal) {\n    texture = this.subtextures[path];\n    \n    if (!texture) {\n        texture = new MapSubtexture(this.map, path, type, extraBound, extraInfo, tile, internal);\n        this.subtextures[path] = texture;\n    }\n    \n    return texture;\n};\n\n\n// Metatiles ---------------------------------\n\nMapResourceNode.prototype.addMetatile = function(path, metatile) {\n    this.metatiles[path] = metatile;\n};\n\n\nMapResourceNode.prototype.removeMetatile = function(metatile) {\n    for (var key in this.metatiles) {\n        if (this.metatiles[key] == metatile) {\n            delete this.metatiles[key];\n        }\n    }\n};\n\n\nMapResourceNode.prototype.getMetatile = function(surface, allowCreation, tile) {\n    var metatiles = this.metatiles, metatile; \n    for (var key in metatiles) {\n        if (metatiles[key].surface == surface) {\n            return metatiles[key];\n        } \n    }\n    \n    var path = surface.getMetaUrl(this.id);\n\n    if (metatiles[path]) {\n        metatile = metatiles[path].clone(surface);\n        this.addMetatile(path, metatile);\n        return metatile;\n    }\n\n    if (allowCreation) {\n        metatile = new MapMetatile(this, surface, tile);\n        this.addMetatile(path, metatile);\n        return metatile; \n    } else {\n        return null;\n    }\n};\n\n\nexport default MapResourceNode;\n\n\n","\nimport MapResourceNode_ from './resource-node';\n\n//get rid of compiler mess\nvar MapResourceNode = MapResourceNode_;\n\n\nvar MapResourceTree = function(map) {\n    this.map = map;\n    this.tree = new MapResourceNode(map, null, [0,0,0]); \n};\n\n\nMapResourceTree.prototype.kill = function() {\n    this.tree.kill();\n};\n\n\nMapResourceTree.prototype.findNode = function(id, createNonexisted) {\n    var node = this.tree; //TODO: fix is it same way as findNavTile\n\n    //console.log(\"--------------findNode: \" + JSON.stringify(id));\n\n//    for (var lod = 1; lod <= id[0]; lod++) {\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        if (!node.children[index]) {\n            if (createNonexisted) {\n                node.addChild(index);\n                //console.log(\"addNode: \" + JSON.stringify(node.children[index].id));\n            } else {\n                return null;\n            }\n        } \n\n        node = node.children[index];\n    }\n    \n    return node;\n};\n\n\nMapResourceTree.prototype.findAgregatedNode = function(id, agregation, createNonexisted) {\n    //var rootLod = 0;  //TODO: fix is it same way as findNavTile\n    var node = this.tree;\n    var ix = ((id[1] >> agregation) << agregation);\n    var iy = ((id[2] >> agregation) << agregation);\n\n\n//    for (var lod = id[0]; lod > rootLod; lod--) {\n//        var i = lod - rootLod;\n//        var index = 0;\n//        var mask = 1 << (i-1);\n\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((ix & mask) != 0) {\n            index += 1;\n        }\n\n        if ((iy & mask) != 0) {\n            index += 2;\n        }\n\n        if (!node.children[index]) {\n            if (createNonexisted) {\n                node.addChild(index);\n            } else {\n                return null;\n            }\n        } \n\n        node = node.children[index];\n    }\n\n    return node;\n};\n\n\nexport default MapResourceTree;\n\n\n","\nimport MapTexture_ from './texture';\nimport {math as math_} from '../utils/math';\nimport GeographicLib_ from 'geographiclib';\n\n//get rid of compiler mess\nvar MapTexture = MapTexture_;\nvar math = math_;\nvar GeographicLib = GeographicLib_;\n\n\nvar MapSrs = function(map, id, json) {\n    this.map = map;\n    this.id = id;\n    this.proj4 = map.proj4;\n    this.comment = json['comment'] || null;\n    this.srsDef = json['srsDef'] || null;\n    this.srsModifiers = json['srsModifiers'] || [];\n    this.type = json['type'] || 'projected';\n    this.vdatum = json['vdatum'] || 'orthometric';\n    //this.srsDefEllps = json[\"srsDefEllps\"] || \"\";\n    this.srsDef = json['srsDefEllps'] || this.srsDef;\n    this.periodicity = this.parsePeriodicity(json['periodicity']);\n    this.srsInfo = this.proj4(this.srsDef).info();\n    this.geoidGrid = null;\n    this.geoidGridMap = null;\n    this.srsProj4 = this.proj4(this.srsDef, null, null, true); \n    this.latlonProj4 = null; \n    this.proj4Cache = {};\n\n    if (json['geoidGrid']) {\n        var geoidGridData = json['geoidGrid'];\n\n        this.geoidGrid = {\n            definition : geoidGridData['definition'] || null,\n            srsDefEllps : geoidGridData['srsDefEllps'] || null,\n            valueRange : geoidGridData['valueRange'] || [0,1]\n        };\n\n        if (geoidGridData['extents']) {\n            this.geoidGrid.extents = {\n                ll : geoidGridData['extents']['ll'],\n                ur : geoidGridData['extents']['ur']\n            };\n        } else {\n            this.geoidGrid.extents = {\n                ll : [0,0],\n                ur : [1,1]\n            };\n        }\n\n        if (this.geoidGrid.definition) {\n            var url = this.map.url.makeUrl(this.geoidGrid.definition, {}, null);\n            this.geoidGridMap = new MapTexture(this.map, url, true);\n        }\n        \n        if (this.geoidGrid.srsDefEllps) {\n            this.geoidGrid.srsProj4 = this.proj4(this.geoidGrid.srsDefEllps, null, null, true);        \n        }\n    }\n\n    if (this.type == 'geographic') {\n        this.spheroid = json['spheroid'] || null;\n\n        if (this.spheroid == null) {\n            //TODO: return error\n        }\n    }\n};\n\n\nMapSrs.prototype.parsePeriodicity = function(periodicityData) {\n    if (periodicityData == null) {\n        return null;\n    }\n\n    var periodicity = {\n        'type' : periodicityData['type'] || '',\n        'period' : periodicityData['period'] || 0\n    };\n\n    return periodicity;\n};\n\n\nMapSrs.prototype.getInfo = function() {\n    return {\n        'comment' : this.comment,\n        'srsDef' : this.srsDef,\n        'srsModifiers' : this.srsModifiers,\n        'type' : this.type,\n        'vdatum' : this.vdatum,\n        'srsDefEllps' : this.srsDef,\n        'a' : this.srsInfo['a'],\n        'b' : this.srsInfo['b']\n    };\n};\n\n\nMapSrs.prototype.getSrsInfo = function() {\n    return this.srsInfo;\n};\n\n\nMapSrs.prototype.isReady = function() {\n    return this.isGeoidGridReady();\n};\n\n\nMapSrs.prototype.isGeoidGridReady = function() {\n    return (this.geoidGrid == null ||\n           (this.geoidGridMap != null && this.geoidGridMap.isReady()));\n};\n\n\nMapSrs.prototype.isProjected = function() {\n    return (this.type == 'projected');\n};\n\n\nMapSrs.prototype.getOriginalHeight = function(coords) {\n    var height = coords[2] || 0;\n    height /= this.getVerticalAdjustmentFactor(coords);\n    height += this.getGeoidGridDelta(coords);\n    return height;\n};\n\n\nMapSrs.prototype.getFinalHeight = function(coords) {\n    var height = coords[2] || 0;\n    height -= this.getGeoidGridDelta(coords);\n    height *= this.getVerticalAdjustmentFactor(coords);\n    return height;\n};\n\n\nMapSrs.prototype.getGeoidGridDelta = function(coords) {\n    if (this.geoidGridMap != null && this.isGeoidGridReady()) {\n        //get cooords in geoidGrid space\n        var mapCoords = this.proj4(this.srsProj4, this.geoidGrid.srsProj4, [coords[0], coords[1]]);\n\n        //get image coords\n        var px = mapCoords[0] - this.geoidGrid.extents.ll[0];\n        var py = this.geoidGrid.extents.ur[1] - mapCoords[1];\n\n        var imageExtens = this.geoidGridMap.getImageExtents();\n\n        px *= imageExtens[0] / (this.geoidGrid.extents.ur[0] - this.geoidGrid.extents.ll[0]);\n        py *= imageExtens[1] / (this.geoidGrid.extents.ur[1] - this.geoidGrid.extents.ll[1]);\n\n        px = math.clamp(px, 0, imageExtens[0] - 2);\n        py = math.clamp(py, 0, imageExtens[1] - 2);\n\n        //get bilineary interpolated value from image\n        var ix = Math.floor(px);\n        var iy = Math.floor(py);\n        var fx = px - ix;\n        var fy = py - iy;\n\n        var data = this.geoidGridMap.getImageData();\n        var index = iy * imageExtens[0];\n        var index2 = index + imageExtens[0];\n        var h00 = data[(index + ix)*4];\n        var h01 = data[(index + ix + 1)*4];\n        var h10 = data[(index2 + ix)*4];\n        var h11 = data[(index2 + ix + 1)*4];\n        var w0 = (h00 + (h01 - h00)*fx);\n        var w1 = (h10 + (h11 - h10)*fx);\n        var delta = (w0 + (w1 - w0)*fy);\n\n        //strech deta into value range\n        delta = this.geoidGrid.valueRange[0] + (delta * ((this.geoidGrid.valueRange[1] - this.geoidGrid.valueRange[0]) / 255));\n\n        return delta;\n    }\n\n    return 0;\n};\n\n\nMapSrs.prototype.getVerticalAdjustmentFactor = function(coords) {\n    if (this.srsModifiers.indexOf('adjustVertical') != -1) {\n        var info = this.getSrsInfo();\n\n        //convert coords to latlon\n        var latlonProj = '+proj=longlat ' +\n                          ' +alpha=0' +\n                          ' +gamma=0 +a=' + info['a'] +\n                          ' +b=' + info['b'] +\n                          ' +x0=0 +y0=0';\n\n        if (!this.latlonProj4) {\n            this.latlonProj4 = this.proj4(latlonProj, null, null, true); \n        }\n\n        var coords2 = this.proj4(this.srsProj4, this.latlonProj4, [coords[0], coords[1]]);\n\n        //move coors 1000m\n        var geod = new GeographicLib.Geodesic.Geodesic(info['a'],\n                                                       (info['a'] / info['b']) - 1.0);\n\n\n        var r = geod.Direct(coords2[1], coords2[0], 90, 1000);\n        coords2 = [r.lon2, r.lat2];\n\n        //convet coords from latlon back to projected\n        coords2 = this.proj4(this.latlonProj4, this.srsProj4, coords2);\n\n        //get distance between coords\n        var dx = coords2[0] - coords[0];\n        var dy = coords2[1] - coords[1];\n\n        var distance = Math.sqrt(dx * dx + dy* dy);\n\n        //get factor\n        var factor = distance / 1000;\n\n        return factor;\n    }\n\n    return 1.0;\n};\n\n\nMapSrs.prototype.convertCoordsTo = function(coords, srs, skipVerticalAdjust) {\n    this.isReady();\n    if (typeof srs !== 'string') {\n        if (srs.id == this.id) {\n            return coords.slice();\n        }\n\n        srs.isReady();\n    }\n\n    coords = coords.slice();\n\n    var stringSrs = (typeof srs === 'string');\n\n    //if (!skipVerticalAdjust && stringSrs) {\n    coords[2] = this.getOriginalHeight(coords);\n    //}\n\n    var srsDef = (stringSrs) ? srs : srs.srsProj4;\n\n    /*\n    if (srsDef.isGeocent && this.srsProj4.projName == \"merc\") {\n        var coords3 = coords.slice();\n        this.convertMercToWGS(coords3);\n        this.convertWGSToGeocent(coords3, srsDef);\n        return coords3;\n    }*/\n\n\n    var srsDef2 = (stringSrs) ? srs : srs.srsDef;\n    //var coords2 = this.proj4(this.srsProj4, srsDef, coords);\n\n    var proj = this.proj4Cache[srsDef2];\n    \n    if (!proj) {\n        proj = this.proj4(this.srsProj4, srsDef);\n        this.proj4Cache[srsDef2] = proj;\n    }\n\n    var coords2 = proj.forward(coords);\n\n    if (!skipVerticalAdjust && !stringSrs) {\n        coords2[2] = srs.getFinalHeight(coords2);\n    }\n\n    return coords2;\n};\n\n\nMapSrs.prototype.convertCoordsToFast = function(coords, srs, skipVerticalAdjust, coords2, index, index2) {\n\n    //if (!skipVerticalAdjust && stringSrs) {\n        //coords[2] = this.getOriginalHeight(coords);\n    //}\n\n    var srsDef = srs.srsProj4;\n    \n    /*\n    if (srsDef.isGeocent && this.srsProj4.projName == \"merc\") {\n        this.convertMercToWGS(coords, coords2, index, index2);\n        this.convertWGSToGeocent(coords2, srsDef, coords2, index2, index2);\n        return;\n    }*/\n\n    var srsDef2 = srs.srsDef;\n\n    var proj = this.proj4Cache[srsDef2];\n    \n    if (!proj) {\n        proj = this.proj4(this.srsProj4, srsDef);\n        this.proj4Cache[srsDef2] = proj;\n    }\n\n    var coords3 = proj.forward(coords);\n    \n    coords2[index2] = coords3[0];\n    coords2[index2+1] = coords3[1];\n    coords2[index2+2] = coords3[2];\n    \n\n    //if (!skipVerticalAdjust && stringSrs) {\n        //coords2[2] = srs.getFinalHeight(coords2);\n    //}\n    \n    if (srs.geoidGrid) {\n        coords2[index2+2] -= srs.getGeoidGridDelta(coords);\n    }\n};\n\n\nMapSrs.prototype.convertCoordsFrom = function(coords, srs) {\n    this.isReady();\n    if (typeof srs !== 'string') {\n        if (srs.id == this.id) {\n            return coords.slice();\n        }\n\n        srs.isReady();\n    }\n\n    coords = coords.slice();\n\n    if (typeof srs !== 'string') {\n        coords[2] = srs.getOriginalHeight(coords);\n    }\n\n    var srsDef = (typeof srs === 'string') ? srs : srs.srsProj4;\n    var srsDef2 = (typeof srs === 'string') ? srs : srs.srsDef;\n\n    //var coords2 = this.proj4(srsDef, this.srsProj4, coords);\n\n    var proj = this.proj4Cache[srsDef2];\n    \n    if (!proj) {\n        proj = this.proj4(this.srsProj4, srsDef);\n        this.proj4Cache[srsDef2] = proj;\n    }\n\n    var coords2 = proj.inverse(coords);\n\n    coords2[2] = this.getFinalHeight(coords2);\n\n    return coords2;\n};\n\n\nMapSrs.prototype.phi2z = function(eccent, ts) {\n    var HALFPI = Math.PI*0.5;\n    var eccnth = 0.5 * eccent;\n    var con, dphi;\n    var phi = HALFPI - 2 * Math.atan(ts);\n    for (var i = 0; i <= 15; i++) {\n        con = eccent * Math.sin(phi);\n        dphi = HALFPI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n        phi += dphi;\n        if (Math.abs(dphi) <= 0.0000000001) {\n            return phi;\n        }\n    }\n  //console.log(\"phi2z has NoConvergence\");\n    return -9999;\n};\n\n\nMapSrs.prototype.convertMercToWGS = function(coords, coords2, index, index2) {\n    var TWOPI = Math.PI * 2;\n    var HALFPI = Math.PI*0.5;\n    var proj = this.srsProj4;\n    var x = coords[index] - proj.x0;\n    var y = coords[index+1] - proj.y0;\n\n    if (proj.sphere) {\n        coords2[index2+1] = HALFPI - 2 * Math.atan(Math.exp(-y / (proj.a * proj.k0)));\n    } else {\n        var ts = Math.exp(-y / (proj.a * proj.k0));\n        var yy = this.phi2z(proj.e, ts);\n        coords2[index2+1] = yy;\n        if (yy === -9999) {\n            return;\n        }\n    }\n    \n    //coords[0] = adjustlon(proj.long0 + x / (proj.a * proj.k0));\n    x = proj.long0 + x / (proj.a * proj.k0);\n    var SPI = 3.14159265359;\n    coords2[index2] = (Math.abs(x) <= SPI) ? x : (x - ((x < 0) ? -1 : 1) * TWOPI);\n    coords2[index2+2] = coords[index+2];\n};\n\n\nMapSrs.prototype.convertWGSToGeocent = function(coords, srs, coords2, index, index2) {\n    var datum = srs.datum;\n\n    var HALFPI = Math.PI*0.5;\n    var Longitude = coords[index];\n    var Latitude = coords[index+1];\n    var Height = coords[index+2]; //Z value not always supplied\n\n    var Rn; /*  Earth radius at location  */\n    var SinLat; /*  Math.sin(Latitude)  */\n    var Sin2Lat; /*  Square of Math.sin(Latitude)  */\n    var CosLat; /*  Math.cos(Latitude)  */\n\n    /*\n     ** Don't blow up if Latitude is just a little out of the value\n     ** range as it may just be a rounding issue.  Also removed longitude\n     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n     */\n    if (Latitude < -HALFPI && Latitude > -1.001 * HALFPI) {\n        Latitude = -HALFPI;\n    }\n    else if (Latitude > HALFPI && Latitude < 1.001 * HALFPI) {\n        Latitude = HALFPI;\n    }\n    else if ((Latitude < -HALFPI) || (Latitude > HALFPI)) {\n      /* Latitude out of range */\n      //..reportError('geocent:lat out of range:' + Latitude);\n        return null;\n    }\n\n    if (Longitude > Math.PI) {\n        Longitude -= (2 * Math.PI);\n    }\n\n    SinLat = Math.sin(Latitude);\n    CosLat = Math.cos(Latitude);\n    Sin2Lat = SinLat * SinLat;\n    Rn = datum.a / (Math.sqrt(1.0e0 - datum.es * Sin2Lat));\n    coords2[index2] = (Rn + Height) * CosLat * Math.cos(Longitude);\n    coords2[index2+1] = (Rn + Height) * CosLat * Math.sin(Longitude);\n    coords2[index2+2] = ((Rn * (1 - datum.es)) + Height) * SinLat;\n};\n\n\nexport default MapSrs;\n\n","\nvar MapStats = function(map) {\n    this.map = map;\n    this.core = map.core;\n    this.inspector = map.core.inspector;\n    this.drawnTiles = 0;\n    this.drawnGeodataTiles = 0;\n    this.drawnGeodataTilesFactor = 0;\n    this.drawnGeodataTilesPerLayer = 0;\n    this.drawnFaces = 0;\n    this.drawCalls = 0;    \n    this.usedNodes = 0;    \n    this.processedNodes = 0;    \n    this.processedMetatiles = 0;    \n    this.counter = 0;\n    this.statsCycle = 0;\n    this.fps = 0;\n    this.frameTime = 0;\n    this.renderTime = 0;\n    this.renderTimeTmp = 0;\n    this.renderTimeBegin = 0;\n    this.renderBuild = 0;\n    this.lastRenderTime = 0;\n    this.lastFrameTime = 0;\n    this.renderedLods = new Array(32);\n    this.debugIds = {};\n\n    this.recordGraphs = false;\n    this.graphsTimeIndex = 0;\n    this.graphsLastTimeIndex = 0;\n    this.graphsTimeSamples = 900;\n    this.graphsRenderTimes = new Array(this.graphsTimeSamples);\n    this.graphsCreateMeshTimes = new Array(this.graphsTimeSamples);\n    this.graphsCreateGpuMeshTimes = new Array(this.graphsTimeSamples);\n    this.graphsCreateTextureTimes = new Array(this.graphsTimeSamples);\n    this.graphsFrameTimes = new Array(this.graphsTimeSamples);\n    this.graphsCpuMemoryMetatiles = new Array(this.graphsTimeSamples);\n    this.graphsCpuMemoryUsed = new Array(this.graphsTimeSamples);\n    this.graphsGpuMemoryTextures = new Array(this.graphsTimeSamples);\n    this.graphsGpuMemoryMeshes = new Array(this.graphsTimeSamples);\n    this.graphsGpuMemoryGeodata = new Array(this.graphsTimeSamples);\n    this.graphsGpuMemoryRender = new Array(this.graphsTimeSamples);\n    this.graphsPolygons = new Array(this.graphsTimeSamples);\n    this.graphsLODs = new Array(this.graphsTimeSamples);\n    this.graphsBuild = new Array(this.graphsTimeSamples);\n    this.graphsFluxTextures = new Array(this.graphsTimeSamples);\n    this.graphsFluxMeshes = new Array(this.graphsTimeSamples);\n    this.graphsFluxGeodatas = new Array(this.graphsTimeSamples);\n    this.graphsFluxTexture = [[0,0],[0,0]];\n    this.graphsFluxMesh = [[0,0],[0,0]];\n    this.graphsFluxGeodata = [[0,0],[0,0]];\n    this.graphsCreateTextureTime = 0;\n    this.graphsCreateGpuMeshTime = 0;\n    this.graphsCreateMeshTime = 0;\n    this.resetGraphs();\n\n    this.meshesFaces = 0;\n    this.meshesUVArea = 0;\n    this.gpuMeshes = 0;\n    this.gpuTextures = 0;\n    this.gpuGeodata = 0;\n    this.gpuUsed = 0;\n    this.resourcesUsed = 0;\n    this.metaUsed = 0;\n    this.gpuRenderUsed = 0;\n    this.loadedCount = 0;\n    this.loadErrorCount = 0;\n    this.loadFirst = 0;\n    this.loadLast = 0;\n    this.gpuNeeded = 0;\n    this.gpuNeeded2 = 0;\n    this.octoNodes = 0;\n    this.octoNodesMemSize = 0;\n\n    this.heightClass = 0;\n    this.heightLod = 0;\n    this.heightNode = 0;\n    this.heightTerrain = 0;\n    this.heightDelta = 0;\n    this.debugStr = null;\n};\n\n//Object.defineProperty(MapStats.prototype, 'gpuNeeded', {\n    //get: function() { return this.gpuNeeded2; /*console.log(\"\"+this.gpuNeeded);*/ },\n    //set: function(value) { \n        //this.gpuNeeded2 = value; console.log(\"\"+this.gpuNeeded);\n    //}\n//});\n\n\nMapStats.prototype.resetGraphs = function() {\n    this.graphsTimeIndex = 0;\n\n    for (var i = 0; i < this.graphsTimeSamples; i++) {\n        this.graphsRenderTimes[i] = 0;\n        this.graphsCreateMeshTimes[i] = 0;\n        this.graphsCreateGpuMeshTimes[i] = 0;\n        this.graphsCreateTextureTimes[i] = 0;\n        this.graphsFrameTimes[i] = 0;\n        this.graphsCpuMemoryUsed[i] = 0;\n        this.graphsCpuMemoryMetatiles[i] = 0;\n        this.graphsGpuMemoryTextures[i] = 0;\n        this.graphsGpuMemoryMeshes[i] = 0;\n        this.graphsGpuMemoryGeodata[i] = 0;\n        this.graphsGpuMemoryRender[i] = 0;\n        this.graphsPolygons[i] = 0;\n        this.graphsLODs[i] = [0,[]];\n        this.graphsBuild[i] = 0;\n        this.graphsFluxTextures[i] = [[0,0],[0,0]];\n        this.graphsFluxMeshes[i] = [[0,0],[0,0]];\n        this.graphsFluxGeodatas[i] = [[0,0],[0,0]];\n    }\n};\n\n\nMapStats.prototype.begin = function(dirty) {\n    if (dirty) {\n        this.drawnTiles = 0;\n        this.drawnGeodataTiles = 0;\n        this.drawnGeodataTilesFactor = 0;\n        this.drawnGeodataTilesPerLayer = 0;\n        this.drawCalls = 0;        \n        this.drawnFaces = 0;\n        this.gpuRenderUsed = 0;\n        this.gpuNeeded = 0;\n        this.usedNodes = 0;    \n        this.processedNodes = 0;    \n        this.processedMetatiles = 0;    \n        this.meshesFaces = 0;\n        this.meshesUVArea = 0;\n\n        for (var i = 0, li = this.renderedLods.length; i < li; i++) {\n            this.renderedLods[i] = 0;\n        } \n    }\n\n    this.debugIds = {};\n\n    this.counter++;\n    this.statsCycle++;\n\n    this.renderTimeBegin = performance.now();\n\n    if (dirty) {\n        if (this.lastFrameTime) {\n            this.frameTime = this.renderTimeBegin - this.lastFrameTime;\n        }\n\n        this.lastFrameTime = this.renderTimeBegin;\n    }\n};\n\n\nMapStats.prototype.end = function(dirty) {\n    var timer = performance.now();\n\n    var renderTime = timer - this.renderTimeBegin;\n    //var frameTime = timer - this.frameTime;\n    //this.frameTime = timer;\n    if (dirty) { \n        this.renderTimeTmp += renderTime;\n        this.lastRenderTime = renderTime;\n    } else {\n        this.renderTimeTmp += this.lastRenderTime;\n    }\n\n    if (this.recordGraphs) {\n        var i = this.graphsTimeIndex;\n\n        this.graphsRenderTimes[i] = renderTime;\n        this.graphsCreateMeshTimes[i] = 0;\n        this.graphsCreateGpuMeshTimes[i] = 0;\n        this.graphsCreateTextureTimes[i] = 0;\n        this.graphsFrameTimes[i] = this.frameTime;\n        this.graphsCpuMemoryUsed[i] = this.map.resourcesCache.totalCost;\n        this.graphsCpuMemoryMetatiles[i] = this.map.metatileCache.totalCost;\n        this.graphsGpuMemoryTextures[i] = this.gpuTextures;\n        this.graphsGpuMemoryMeshes[i] = this.gpuMeshes;\n        this.graphsGpuMemoryGeodata[i] = this.gpuGeodata;\n        this.graphsGpuMemoryRender[i] = this.gpuRenderUsed;\n        this.graphsPolygons[i] = this.drawnFaces;\n        this.graphsFluxTextures[i] = [[this.graphsFluxTexture[0][0], this.graphsFluxTexture[0][1]], [this.graphsFluxTexture[1][0], this.graphsFluxTexture[1][1]] ];\n        this.graphsFluxMeshes[i] = [[this.graphsFluxMesh[0][0], this.graphsFluxMesh[0][1]], [this.graphsFluxMesh[1][0], this.graphsFluxMesh[1][1]] ];\n        this.graphsFluxGeodatas[i] = [[this.graphsFluxGeodata[0][0], this.graphsFluxGeodata[0][1]], [this.graphsFluxGeodata[1][0], this.graphsFluxGeodata[1][1]] ];\n        this.graphsLODs[i] = [this.drawnTiles, this.renderedLods.slice()];\n        this.graphsBuild[i] = this.renderBuild;\n\n        this.graphsTimeIndex = (this.graphsTimeIndex + 1) % this.graphsTimeSamples;\n        \n        if (this.inspector && this.inspector.graphs) {\n            this.inspector.graphs.updateGraphs(this);\n        }\n    }\n\n\n    if ((this.statsCycle % 50) == 0) {\n        this.renderTime = this.renderTimeTmp / 100;\n        this.fps = 1000 / this.renderTime;\n        this.renderTimeTmp = 0;\n\n        if (this.inspector && this.inspector.stats) {\n            this.gpuUsed = this.map.gpuCache.totalCost;\n            this.resourcesUsed = this.map.resourcesCache.totalCost;\n            this.metaUsed = this.map.metatileCache.totalCost;\n\n            this.inspector.stats.updateStatsPanel(this);\n        }\n    }\n    \n    //do not reset flux data in begin function, because we to collect data from events which     \n    this.graphsFluxTexture = [[0,0],[0,0]];\n    this.graphsFluxMesh = [[0,0],[0,0]];\n    this.graphsFluxGeodata = [[0,0],[0,0]];\n    this.debugStr = this.map.renderer.debugStr;\n};\n\n\nexport default MapStats;\n\n","\nimport {utils as utils_} from '../utils/utils';\n\n//get rid of compiler mess\nvar utils = utils_;\n\n\nvar MapStylesheet = function(map, id, url, freeLayer) {\n    this.generateLines = true;\n    this.map = map;\n    this.renderer = this.map.renderer;\n    this.stats = map.stats;\n    this.id  = id;\n    this.url  = null;\n    this.data = null;\n    this.loadState = 0;\n    this.size = 0;\n    this.fileSize = 0;\n    this.freeLayer = freeLayer;\n    this.fonts = {};\n    this.fontsReady = false;\n    \n    if (typeof url === 'object') {\n        this.data = url;\n        this.setFonts(this.data);\n        this.loadState = 2;\n        this.map.markDirty();\n    } else {\n        if (this.freeLayer) {\n            this.url = this.freeLayer.processUrl(url, '');\n        } else {\n            this.url = this.map.url.processUrl(url);\n        }\n\n        //load style directly\n        utils.loadJSON(this.url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, (utils.useCredentials ? (this.url.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n        this.loadState = 1;\n    }\n};\n\n\nMapStylesheet.prototype.kill = function() {\n};\n\n\nMapStylesheet.prototype.setData = function(data) {\n    this.data = data;\n    this.setFonts(data);\n    this.loadState = 2;\n    this.checkFonts();\n};\n\nMapStylesheet.prototype.checkFonts = function() {\n    var ready = true;\n    for (var key in this.fonts) {\n        ready = (ready && this.renderer.getFont(this.fonts[key]).isReady());\n    }\n\n    this.fontsReady = ready;\n\n    return ready;\n};\n\nMapStylesheet.prototype.isReady = function(doNotLoad, priority) {\n    if (this.loadState == 2) { //loaded\n        if (this.fontsReady) {\n            return true;\n        } else {\n            return this.checkFonts();\n        }\n\n    } else {\n        if (this.loadState == 0) { \n            if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                  //  this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            } else {\n                //not loaded\n                //add to loading queue or top position in queue\n                this.scheduleLoad(priority);\n            }\n        } //else load in progress\n    }\n\n    return false;\n};\n\n\nMapStylesheet.prototype.scheduleLoad = function(priority) {\n    this.map.loader.load(this.url, this.onLoad.bind(this), priority);\n};\n\n\nMapStylesheet.prototype.onLoad = function() {\n    //this.mapLoaderCallLoaded = onLoaded;\n    //this.mapLoaderCallError = onError;\n\n    this.loadState = 1;\n};\n\n\nMapStylesheet.prototype.onLoadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    //this.mapLoaderCallError();\n    //this.loadState = 2;\n};\n\nMapStylesheet.prototype.setFonts = function(data) {\n    this.fonts = data['fonts'] || {};\n    \n    if (!this.fonts['#default']) {\n        this.fonts['#default'] = this.map.core.config.mapDefaultFont;\n    }\n};\n\nMapStylesheet.prototype.onLoaded = function(data) {\n    if (this.map.killed){\n        return;\n    }\n    \n    this.data = data;\n    this.setFonts(data);\n\n    //this.mapLoaderCallLoaded();\n    this.loadState = 2;\n    this.map.markDirty();\n};\n\n\n// Returns RAM usage in bytes.\n//MapStylesheet.prototype.getSize = function () {\n  //  return this.size;\n//};\n\n//MapStylesheet.prototype.getFileSize = function () {\n  //  return this.fileSize;\n//};\n\nexport default MapStylesheet;\n\n","// An index-less mesh. Each triangle has three items in the array 'vertices'.\n\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport GpuMesh_ from '../renderer/gpu/mesh';\nimport BBox_ from '../renderer/bbox';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\nvar math = math_;\nvar GpuMesh = GpuMesh_;\nvar BBox = BBox_;\n\n\nvar MapSubmesh = function(mesh, stream) {\n    this.generateLines = true;\n    this.map = mesh.map;\n    this.vertices = null;\n    this.internalUVs = null;\n    this.externalUVs = null;\n    this.indices = null;\n    this.mesh = mesh;\n    this.statsCounter = 0;\n    this.valid = true;\n    this.killed = false;\n    this.use16bit = mesh.use16bit;\n    this.texture = null;\n\n    this.bbox = new BBox();\n    this.size = 0;    \n    this.faces = 0;\n    this.uvArea = 0;\n    this.uvAreaComputed = false;\n\n    this.flagsInternalTexcoords =  1;\n    this.flagsExternalTexcoords =  2;\n    this.flagsPerVertexUndulation =  4;\n    this.flagsTextureMode =  8;\n\n    if (stream) {\n        this.parseSubmesh(stream);\n    }\n};\n\n\nMapSubmesh.prototype.kill = function () {\n    this.killed = true;\n    this.vertices = null;\n    this.internalUVs = null;\n    this.externalUVs = null;\n    this.indices = null;\n    \n    if (this.texture) {\n        this.texture.kill();\n        this.texture = null;\n    }\n};\n\n\n// Reads the mesh from the binary representation.\nMapSubmesh.prototype.parseSubmesh = function (stream) {\n\n/*\nstruct MapSubmesh {\n    struct MapSubmeshHeader header;\n    struct VerticesBlock vertices;\n    struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )\n    struct FacesBlock faces;\n};\n*/\n    this.parseHeader(stream);\n    if (this.mesh.version >= 3) {\n        this.parseVerticesAndFaces2(stream);\n    } else {\n        this.parseVerticesAndFaces(stream);\n    }\n};\n\n\nMapSubmesh.prototype.parseHeader = function (stream) {\n\n/*\nstruct MapSubmeshHeader {\n    char flags;                    // bit 0 - contains internal texture coords\n                                   // bit 1 - contains external texture coords\n                                   // bit 2 - contains per vertex undulation\n                                   // bit 3 - texture mode (0 - internal, 1 - external)\n    \n    uchar surfaceReference;        // reference to the surface of origin, see bellow\n    ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id\n    double boundingBox[2][3];      // read more about bounding box bellow\n};\n*/\n\n    var streamData = stream.data;\n\n    this.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    if (this.mesh.version > 1) {\n        this.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;\n    } else {\n        this.surfaceReference = 0;\n    }\n\n    this.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;\n    this.textureLayer2 = this.textureLayer; //hack for presentation\n\n    var bboxMin = this.bbox.min;\n    var bboxMax = this.bbox.max;\n\n    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n\n    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    \n    this.bbox.updateMaxSize();\n};\n\n\nMapSubmesh.prototype.parseVerticesAndFaces = function (stream) {\n/*\nstruct VerticesBlock {\n    ushort numVertices;              // number of vertices\n\n    struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n        // vertex coordinates\n        ushort x;\n        ushort y;\n        ushort z;\n\n        // if header.flags & ( 1 << 1 ): external texture coordinates\n        // values in 2^16^ range represents the 0..1 normalized texture space\n        ushort eu;\n        ushort ev;\n\n        // if header.flags & ( 1 << 2 ): undulation delta\n        float16 undulationDelta;\n    } vertices[];\n};\n*/\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n\n    var numVertices = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        this.valid = false;\n    }\n\n    var internalUVs = null;\n    var externalUVs = null;\n    var onlyOneUVs = this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords);\n\n    var vertices = this.use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n\n    if (this.flags & this.flagsExternalTexcoords) {\n        if (onlyOneUVs) {\n            externalUVs = true;\n        } else {\n            externalUVs = this.use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n        }\n    }\n\n    var uvfactor = this.use16bit ? 1.0 : (1.0 / 65535);\n    var vindex = 0;\n    var uvindex = 0;\n    var i, li;\n\n    for (i = 0; i < numVertices; i++) {\n        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;\n        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;\n        vindex += 3;\n\n        if (externalUVs) {\n            if (!onlyOneUVs) {\n                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;\n                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;\n                uvindex += 2;\n            }\n            index += 10;\n        } else {\n            index += 6;\n        }\n    }\n\n\n    this.tmpVertices = vertices;\n    this.tmpExternalUVs = externalUVs;\n   \n/*\nstruct TexcoorsBlock {\n    ushort numTexcoords;              // number of texture coordinates\n\n    struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n        // internal texture coordinates\n        // values in 2^16^ range represents the 0..1 normalized texture space\n        ushort u;\n        ushort v;\n    } texcoords[];\n};\n*/\n\n    if (this.flags & this.flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n    \n        internalUVs = this.use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        //var uvfactor = 1.0 / 65535;\n    \n        for (i = 0, li = numUVs * 2; i < li; i+=2) {\n            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;\n            index += 4;\n        }\n    \n        this.tmpInternalUVs = internalUVs;\n    }\n\n/*\nstruct FacesBlock {\n    ushort numFaces;              // number of faces\n\n    struct Face {                 // array of faces, size of array is defined by numFaces property\n\n        ushort v[3]; // array of indices to stored vertices\n        ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n    } faces[];\n};\n*/\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && !(this.flags & this.flagsInternalTexcoords));\n    var onlyInternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = this.use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (this.flags & this.flagsInternalTexcoords) {\n            internalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (this.flags & this.flagsExternalTexcoords)) {\n            externalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = this.tmpVertices;\n    var eUVs = this.tmpExternalUVs;\n    var iUVs = this.tmpInternalUVs;\n    var v1, v2, v3, vv1, vv2, vv3, sindex;\n\n    if (onlyExternalIndices) {\n        vertices = this.tmpVertices;\n        externalUVs = this.tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = this.use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = this.tmpInternalUVs;\n    }\n\n    for (i = 0; i < numFaces; i++) {\n        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));\n        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));\n        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));\n\n        if (onlyIndices) {\n            vindex = i * 3;\n\n            if (internalUVs != null) {\n                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n\n                vertices[vv1*3] = vtmp[v1*3];\n                vertices[vv1*3+1] = vtmp[v1*3+1];\n                vertices[vv1*3+2] = vtmp[v1*3+2];\n\n                vertices[vv2*3] = vtmp[v2*3];\n                vertices[vv2*3+1] = vtmp[v2*3+1];\n                vertices[vv2*3+2] = vtmp[v2*3+2];\n\n                vertices[vv3*3] = vtmp[v3*3];\n                vertices[vv3*3+1] = vtmp[v3*3+1];\n                vertices[vv3*3+2] = vtmp[v3*3+2];\n\n                indices[vindex] = vv1;\n                indices[vindex+1] = vv2;\n                indices[vindex+2] = vv3;\n\n                index += 12;\n            } else {\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n\n                index += 6;\n            }\n\n        } else {\n            vindex = i * (3 * 3);\n\n            sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n\n            if (internalUVs != null) {\n                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n                index += 12;\n\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            } else {\n                index += 6;\n            }\n        }\n    }\n\n    this.vertices = vertices;\n    this.internalUVs = internalUVs;\n    this.externalUVs = externalUVs;\n    this.indices = indices;\n\n    this.tmpVertices = null;\n    this.tmpInternalUVs = null;\n    this.tmpExternalUVs = null;\n\n    stream.index = index;\n\n    this.size = this.vertices.byteLength;\n    if (this.internalUVs) this.size += this.internalUVs.byteLength;\n    if (this.externalUVs) this.size += this.externalUVs.byteLength;\n    if (this.indices) this.size += this.indices.byteLength;\n    this.faces = numFaces;\n};\n\n\nMapSubmesh.prototype.parseWord = function (data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);\n        res[1] += 2;\n    } else {\n        res[0] = value;\n        res[1] ++;\n    }\n};\n\n\nMapSubmesh.prototype.parseDelta = function (data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        value = (value & 0x7f) | (data[res[1]+1] << 7);\n\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] += 2;\n        } else {\n            res[0] = (value >> 1); \n            res[1] += 2;\n        }\n    } else {\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] ++;\n        } else {\n            res[0] = (value >> 1); \n            res[1] ++;\n        }\n    }\n};\n\n\nMapSubmesh.prototype.parseVerticesAndFaces2 = function (stream) {\n/*\nstruct VerticesBlock {\n    ushort numVertices;              // number of vertices\n    ushort geomQuantCoef;            // geometry quantization coefficient\n\n    struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n        // vertex coordinates\n        delta x;\n        delta y;\n        delta z;\n    } vertices[];\n};\n*/\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n    var onlyOneUVs = this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords);\n\n    var numVertices = data.getUint16(index, true); index += 2;\n    var quant = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        this.valid = false;\n    }\n\n    var center = this.bbox.center();\n    var scale = this.bbox.maxSize;\n\n    var multiplier = 1.0 / quant;\n    var externalUVs = null;\n\n    var vertices = this.use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n    var vindex;\n    \n    var x = 0, y = 0,z = 0;\n    var cx = center[0], cy = center[1], cz = center[2];\n    var mx = this.bbox.min[0];\n    var my = this.bbox.min[1];\n    var mz = this.bbox.min[2];\n    var sx = 1.0 / (this.bbox.max[0] - this.bbox.min[0]);\n    var sy = 1.0 / (this.bbox.max[1] - this.bbox.min[1]);\n    var sz = 1.0 / (this.bbox.max[2] - this.bbox.min[2]);\n    \n    var res = [0, index];\n    var i, li, t;\n\n    if (this.use16bit) {\n        for (i = 0; i < numVertices; i++) {\n            this.parseDelta(uint8Data, res);\n            x += res[0];\n            this.parseDelta(uint8Data, res);\n            y += res[0];\n            this.parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            t = ((x * multiplier * scale + cx) - mx) * sx;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex] = t * 65535;\n            t = ((y * multiplier * scale + cy) - my) * sy;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+1] = t * 65535;\n            t = ((z * multiplier * scale + cz) - mz) * sz;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+2] = t * 65535;\n        }\n    } else {\n        for (i = 0; i < numVertices; i++) {\n            this.parseDelta(uint8Data, res);\n            x += res[0];\n            this.parseDelta(uint8Data, res);\n            y += res[0];\n            this.parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;\n            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;\n            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;\n        }\n    }\n    \n    index = res[1];\n\n    if (this.flags & this.flagsExternalTexcoords) {\n        quant = data.getUint16(index, true); index += 2;\n        res[1] = index;\n\n        if (onlyOneUVs) {\n\n            for (i = 0; i < numVertices; i++) {\n                this.parseDelta(uint8Data, res);\n                this.parseDelta(uint8Data, res);\n            }\n\n        } else {\n            multiplier = (this.use16bit) ? (65535 / quant) : (1.0 / quant);\n            externalUVs = this.use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n            x = 0, y = 0;\n\n            if (this.use16bit) {\n                for (i = 0; i < numVertices; i++) {\n                    this.parseDelta(uint8Data, res);\n                    x += res[0];\n                    this.parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    t = x * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex] = t;\n                    t = y * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex+1] = 65535 - t;\n                }\n            } else {\n                for (i = 0; i < numVertices; i++) {\n                    this.parseDelta(uint8Data, res);\n                    x += res[0];\n                    this.parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    externalUVs[uvindex] = x * multiplier;\n                    externalUVs[uvindex+1] = 1 - (y * multiplier);\n                }\n            }\n        }\n    }\n\n    index = res[1];\n\n    this.tmpVertices = vertices;\n    this.tmpExternalUVs = externalUVs;\n    \n/*\nstruct TexcoorsBlock {\n    ushort numTexcoords;              // number of texture coordinates\n\n    struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n        // internal texture coordinates\n        // values in 2^16^ range represents the 0..1 normalized texture space\n        ushort u;\n        ushort v;\n    } texcoords[];\n};\n*/\n\n    if (this.flags & this.flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n        var quantU = data.getUint16(index, true); index += 2;\n        var quantV = data.getUint16(index, true); index += 2;\n        var multiplierU = (this.use16bit) ? (65536.0 / quantU) : (1.0 / quantU);\n        var multiplierV = (this.use16bit) ? (65536.0 / quantV) : (1.0 / quantV);\n        x = 0, y = 0;\n    \n        var internalUVs = this.use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        res[1] = index;7\n\n        if (this.use16bit) {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                this.parseDelta(uint8Data, res);\n                x += res[0];\n                this.parseDelta(uint8Data, res);\n                y += res[0];\n\n                t = x * multiplierU;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i] = t;\n                t = y * multiplierV;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i+1] = 65535 - t;\n            }\n        } else {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                this.parseDelta(uint8Data, res);\n                x += res[0];\n                this.parseDelta(uint8Data, res);\n                y += res[0];\n\n                internalUVs[i] = x * multiplierU;\n                internalUVs[i+1] = 1 - (y * multiplierV);\n            }\n        }\n\n        index = res[1];\n    \n        this.tmpInternalUVs = internalUVs;\n    }\n\n/*\nstruct FacesBlock {\n    ushort numFaces;              // number of faces\n\n    struct Face {                 // array of faces, size of array is defined by numFaces property\n\n        ushort v[3]; // array of indices to stored vertices\n        ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n    } faces[];\n};\n*/\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && !(this.flags & this.flagsInternalTexcoords));\n    var onlyInternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = this.use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (this.flags & this.flagsInternalTexcoords) {\n            internalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (this.flags & this.flagsExternalTexcoords)) {\n            externalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = this.tmpVertices;\n    var eUVs = this.tmpExternalUVs;\n    var iUVs = this.tmpInternalUVs;\n    var high = 0;\n    var v1, v2, v3, vv1, vv2, vv3;\n    res[1] = index;\n\n    for (i = 0; i < numFaces; i++) {\n        this.parseWord(uint8Data, res);\n        v1 = high - res[0];\n        if (!res[0]) { high++; }\n\n        this.parseWord(uint8Data, res);\n        v2 = high - res[0];\n        if (!res[0]) { high++; }\n\n        this.parseWord(uint8Data, res);\n        v3 = high - res[0];\n        if (!res[0]) { high++; }\n\n        if (onlyIndices) {\n            vindex = i * 3;\n            indices[vindex] = v1;\n            indices[vindex+1] = v2;\n            indices[vindex+2] = v3;\n        } else {\n            vindex = i * (3 * 3);\n            var sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n        }\n    }\n\n    if (onlyExternalIndices) {\n        vertices = this.tmpVertices;\n        externalUVs = this.tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = this.use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = this.tmpInternalUVs;\n    }\n\n    high = 0;\n\n    if (internalUVs != null) {\n        for (i = 0; i < numFaces; i++) {\n            this.parseWord(uint8Data, res);\n            v1 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            this.parseWord(uint8Data, res);\n            v2 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            this.parseWord(uint8Data, res);\n            v3 = high - res[0];\n            if (!res[0]) { high++; }\n\n            if (onlyInternalIndices) {\n                vindex = i * 3;\n\n                vv1 = indices[vindex] * 3;\n                vv2 = indices[vindex+1] * 3;\n                vv3 = indices[vindex+2] * 3;\n\n                vertices[v1*3] = vtmp[vv1];\n                vertices[v1*3+1] = vtmp[vv1+1];\n                vertices[v1*3+2] = vtmp[vv1+2];\n\n                vertices[v2*3] = vtmp[vv2];\n                vertices[v2*3+1] = vtmp[vv2+1];\n                vertices[v2*3+2] = vtmp[vv2+2];\n\n                vertices[v3*3] = vtmp[vv3];\n                vertices[v3*3+1] = vtmp[vv3+1];\n                vertices[v3*3+2] = vtmp[vv3+2];\n\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n            } else {\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            }\n        }\n    }\n\n    index = res[1];\n\n    this.vertices = vertices;\n    this.internalUVs = internalUVs;\n    this.externalUVs = externalUVs;\n    this.indices = indices;\n\n    this.tmpVertices = null;\n    this.tmpInternalUVs = null;\n    this.tmpExternalUVs = null;\n\n    stream.index = index;\n\n    this.size = this.vertices.byteLength;\n    if (this.internalUVs) this.size += this.internalUVs.byteLength;\n    if (this.externalUVs) this.size += this.externalUVs.byteLength;\n    if (this.indices) this.size += this.indices.byteLength;\n    this.faces = numFaces;\n};\n\n\n// Returns RAM usage in bytes.\nMapSubmesh.prototype.getSize = function () {\n    return this.size;\n};\n\n\nMapSubmesh.prototype.getFileSize = function () {\n    return this.fileSize;\n};\n\n\nMapSubmesh.prototype.buildGpuMesh = function () {\n    return new GpuMesh(this.map.renderer.gpu, {\n        bbox: this.bbox,\n        vertices: this.vertices,\n        uvs: this.internalUVs,\n        uvs2: this.externalUVs,\n        indices: this.indices\n    }, 1, this.map.core, true, this.use16bit);\n};\n\n\nMapSubmesh.prototype.computeUVArea = function (texture) {\n    var uvs = this.internalUVs || this.externalUVs;\n    var area = 0;\n    var fx = texture.width / 65535;\n    var fy = texture.height / 65535;\n\n    var faceArea = function(i1, i2, i3) {\n        var dx = (uvs[i2] - uvs[i1])*fx, dy = (uvs[i2+1] - uvs[i1+1])*fy;\n        var l1 = Math.sqrt(dx*dx+dy*dy);\n        dx = (uvs[i3] - uvs[i2])*fx, dy = (uvs[i3+1] - uvs[i2+1])*fy;\n        var l2 = Math.sqrt(dx*dx+dy*dy);\n        dx = (uvs[i1] - uvs[i3])*fy, dy = (uvs[i1+1] - uvs[i3+1])*fy;\n        var l3 = Math.sqrt(dx*dx+dy*dy);\n\n        var sp = (l1+l2+l3)*0.5; //semi perimeter\n\n        return Math.sqrt(Math.max(0.0,sp*(sp-l1)*(sp-l2)*(sp-l3)));\n    }\n\n    if (uvs) {\n        var indices = this.indices;\n\n        if (indices) {\n            for (var i = 0, ii = 0, li = this.faces; i < li; i++, ii+=3) {\n                area += faceArea(indices[i*3]*2, indices[i*3+1]*2, indices[i*3+2]*2);\n            }\n        } else {\n            for (var i = 0, ii = 0, li = this.faces; i < li; i++, ii+=3) {\n                area += faceArea(i*3*2, i*3*2 + 1, i*3*2 +2);\n            }\n        }\n    }\n\n    this.uvAreaComputed = true;\n    this.uvArea = area;\n};\n\n\nMapSubmesh.prototype.getWorldMatrix = function(geoPos, matrix) {\n    // Note: the current camera geographic position (geoPos) is not necessary\n    // here, in theory, but for numerical stability (OpenGL ES is float only)\n    // we get rid of the large UTM numbers in the following subtractions. The\n    // camera effectively stays in the position [0,0] and the tiles travel\n    // around it. (The Z coordinate is fine and is not handled in this way.)\n\n    var m = matrix;\n\n    if (m) {\n        m[0] = this.bbox.side(0); m[1] = 0; m[2] = 0; m[3] = 0;\n        m[4] = 0; m[5] = this.bbox.side(1); m[6] = 0; m[7] = 0;\n        m[8] = 0; m[9] = 0; m[10] = this.bbox.side(2); m[11] = 0;\n        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;\n    } else {\n        m = mat4.create();\n\n        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),\n                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);\n    }\n\n    return m;\n};\n\n\nMapSubmesh.prototype.getWorldMatrixSE = function(geoPos, matrix) {\n    var m = matrix;\n\n    if (m) {\n        m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;\n        m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;\n        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;\n        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;\n    } else {\n        m = math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]);\n    }\n\n    return m;\n};\n\n\nMapSubmesh.prototype.drawBBox = function(cameraPos) {\n    var renderer = this.map.renderer;\n\n    renderer.gpu.useProgram(renderer.progBBox, ['aPosition']);\n\n    var mvp = mat4.create();\n    var mv = mat4.create();\n\n    mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);\n\n    var proj = renderer.camera.getProjectionMatrix();\n    mat4.multiply(proj, mv, mvp);\n\n    renderer.progBBox.setMat4('uMVP', mvp);\n\n    //draw bbox\n    renderer.bboxMesh.draw(renderer.progBBox, 'aPosition');\n};\n\n\nexport default MapSubmesh;\n","\nimport {utils as utils_} from '../utils/utils';\nimport GpuTexture_ from '../renderer/gpu/texture';\n\n//get rid of compiler mess\nvar utils = utils_;\nvar GpuTexture = GpuTexture_;\n\n\nvar MapSubtexture = function(map, path, type, tile, internal) {\n    this.map = map;\n    this.stats = map.stats;\n    this.tile = tile; // used only for stats\n    this.internal = internal; // used only for stats\n    this.image = null;\n    this.imageData = null;\n    this.imageExtents = null;\n    this.gpuTexture = null;\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.neverReady = false;\n    this.mapLoaderUrl = path;\n    this.type = type || false;\n    this.statsCounter = 0;\n    this.checkStatus = 0;\n    this.checkType = null;\n    this.checkValue = null;\n    this.fastHeaderCheck = false;\n    this.gpuSize = 0;\n    this.fileSize = 0;\n    this.cacheItem = null; //store killImage\n    this.gpuCacheItem = null; //store killGpuTexture\n};\n\n\nMapSubtexture.prototype.kill = function() {\n    this.killImage();\n    this.killGpuTexture();\n    \n    if (this.mask) {\n        this.mask.killImage(); \n        this.mask.killGpuTexture(); \n    }\n    \n    //this.tile.validate();\n};\n\n\nMapSubtexture.prototype.killImage = function(killedByCache) {\n    this.image = null;\n    this.imageData = null;\n\n    if (killedByCache !== true && this.cacheItem) {\n        this.map.resourcesCache.remove(this.cacheItem);\n        //this.tile.validate();\n    }\n\n    if (this.mask) {\n        this.mask.killImage(); \n    }\n\n    if (!this.gpuTexture) {\n        this.loadState = 0;\n    } //else {\n        //this.loadState = this.loadState;\n    //}\n\n    this.cacheItem = null;\n};\n\n\nMapSubtexture.prototype.killGpuTexture = function(killedByCache) {\n/*\n    //debug only    \n    if (!this.map.lastRemoved) {\n        this.map.lastRemoved = [];\n    }\n\n    //debug only    \n    if (this.map.lastRemoved.indexOf(this.mapLoaderUrl) != -1) {\n        console.log(\"tex: \" + this.mapLoaderUrl);\n    }\n\n    //debug only    \n    this.map.lastRemoved.unshift(this.mapLoaderUrl);\n    this.map.lastRemoved = this.map.lastRemoved.slice(0,20);\n*/\n\n    if (this.gpuTexture != null) {\n        this.stats.gpuTextures -= this.gpuTexture.size;\n        this.gpuTexture.kill();\n\n        this.stats.graphsFluxTexture[1][0]++;\n        this.stats.graphsFluxTexture[1][1] += this.gpuTexture.size;\n\n        if (this.mask) {\n            this.mask.killGpuTexture(); \n        }\n    }\n\n    this.gpuTexture = null;\n\n    if (killedByCache !== true && this.gpuCacheItem) {\n        this.map.gpuCache.remove(this.gpuCacheItem);\n        //this.tile.validate();\n    }\n\n    if (!this.image && !this.imageData) {\n        this.loadState = 0;\n    }\n\n    this.gpuCacheItem = null;\n};\n\n\nMapSubtexture.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu, texture) {\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n    \n    if (this.neverReady) {\n        return false;\n    }\n\n    switch (texture.checkType) {\n    case VTS_TEXTURECHECK_TYPE:\n    case VTS_TEXTURECHECK_CODE:\n    case VTS_TEXTURECHECK_SIZE:\n        \n        if (this.checkStatus != 2) {\n            this.checkType = texture.checkType;\n            this.checkValue = texture.checkValue;\n\n            if (this.checkStatus == 0) {\n                this.scheduleHeadRequest(priority, (this.checkType == VTS_TEXTURECHECK_SIZE));\n            } else if (this.checkStatus == 3) { //loadError\n                if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                        performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n                    this.scheduleHeadRequest(priority, (this.checkType == VTS_TEXTURECHECK_SIZE));\n                }\n            } else if (this.checkStatus == -1) {\n            \n                if (texture.extraInfo) { //find at least texture with lower resolution\n                    if (!texture.extraBound) {\n                        texture.extraBound = { tile: texture.extraInfo.tile, layer: texture.extraInfo.layer};\n                        texture.setBoundTexture(texture.extraBound.tile.parent, texture.extraBound.layer);        \n                    }\n        \n                    while (texture.extraBound.texture.extraBound || texture.extraBound.texture.checkStatus == -1) {\n                        //while (texture.extraBound.texture.checkStatus == -1) {\n                        texture.setBoundTexture(texture.extraBound.sourceTile.parent, texture.extraBound.layer);        \n                    }\n                }\n            }\n    \n            return false;\n        }\n            \n        break;\n    }\n\n    if (this.loadState == 2) { //loaded\n        var t;\n\n        if (!doNotLoad && this.cacheItem) {\n            this.map.resourcesCache.updateItem(this.cacheItem);\n        }\n\n        /*\n        if (((this.type == VTS_TEXTURETYPE_HEIGHT && !this.imageData) || (this.type != VTS_TEXTURETYPE_HEIGHT && !this.gpuTexture)) &&\n              this.stats.renderBuild > this.map.config.mapMaxProcessingTime) {\n            //console.log(\"testure resource build overflow\");\n            this.map.markDirty();\n            return false;\n        }*/\n\n        if (doNotCheckGpu) {\n            if (this.type == VTS_TEXTURETYPE_HEIGHT) {\n                if (!this.imageData) {\n                    t = performance.now();\n                    this.buildHeightMap();\n                    this.stats.renderBuild += performance.now() - t; \n                }\n            }\n\n            return true;\n        }\n\n        if (this.type == VTS_TEXTURETYPE_HEIGHT) {\n            if (!this.imageData) {\n                t = performance.now();\n                this.buildHeightMap();\n                this.stats.renderBuild += performance.now() - t; \n            }\n        } else {\n            if (!this.gpuTexture) {\n                if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {\n                    return false;\n                }\n                \n                if (doNotUseGpu) {\n                    return false;\n                }\n\n                //if (this.stats.graphsFluxTexture [0][0] > 2) {\n                   // return false;\n                //}\n\n                t = performance.now();\n                this.buildGpuTexture();\n                this.stats.renderBuild += performance.now() - t; \n            }\n\n            if (!doNotLoad && this.gpuCacheItem) {\n                this.map.gpuCache.updateItem(this.gpuCacheItem);\n            }\n        }\n        \n        \n        return true;\n    } else {\n        if (this.loadState == 0) { \n            if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                    //this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            } else {\n                //not loaded\n                //add to loading queue or top position in queue\n                this.scheduleLoad(priority);\n            }\n        } else if (this.loadState == 3) { //loadError\n            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n\n                this.scheduleLoad(priority);                    \n            }\n        } //else load in progress\n    }\n\n    return false;\n};\n\n\nMapSubtexture.prototype.scheduleLoad = function(priority, header) {\n    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this, header), priority, this.tile, this.internal ? 'texture-in' : 'texture-ex');\n};\n\n\nMapSubtexture.prototype.onLoad = function(header, url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    var onerror = this.onLoadError.bind(this);\n    var onload = this.onLoaded.bind(this);\n\n    if (header) {\n        this.checkStatus = 1;\n    } else {\n        this.loadState = 1;\n    }\n\n    if (this.map.config.mapXhrImageLoad) {\n        //utils.loadBinary(url, this.onBinaryLoaded.bind(this), onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');\n        this.map.loader.processLoadBinary(url, this.onBinaryLoaded.bind(this), onerror, null, 'texture');\n    } else {\n        this.image = utils.loadImage(url, onload, onerror, (this.map.core.tokenCookieHost ? (url.indexOf(this.map.core.tokenCookieHost) != -1) : false));\n    }\n    //mapXhrImageLoad\n};\n\n\nMapSubtexture.prototype.onLoadError = function(killBlob) {\n    if (this.map.killed){\n        return;\n    }\n\n    if (killBlob) {\n        window.URL.revokeObjectURL(this.image.src);\n    }\n\n    this.loadState = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n    \n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n    \n    this.mapLoaderCallError();\n};\n\n\nMapSubtexture.prototype.onBinaryLoaded = function(data, direct, filesize) {\n    if (this.fastHeaderCheck && this.checkType && this.checkType != VTS_TEXTURECHECK_MEATATILE) {\n        this.onHeadLoaded(null, data, null /*status*/);\n        \n        if (this.checkStatus == -1) {\n            this.mapLoaderCallLoaded();\n            return;\n        }\n    }\n\n    if (direct) {\n        this.onLoaded(false, data)\n        this.fileSize = filesize;\n        return;\n    }\n\n    this.fileSize = data.size;\n\n    if (this.map.config.mapAsyncImageDecode) {\n        createImageBitmap(data).then(this.onLoaded.bind(this, false));\n    } else {\n        var image = new Image();\n        image.onerror = this.onLoadError.bind(this, true, null);\n        image.onload = this.onLoaded.bind(this, true, null);\n        this.image = image;\n        image.src = window.URL.createObjectURL(data);\n    }\n};\n\n\nMapSubtexture.prototype.onLoaded = function(killBlob, bitmap) {\n    if (this.map.killed){\n        return;\n    }\n\n    if (killBlob) {\n        window.URL.revokeObjectURL(this.image.src);\n    }\n\n    if (bitmap) {\n        this.image = bitmap;\n        this.image.naturalWidth = bitmap.width;\n        this.image.naturalHeight = bitmap.height;\n    }\n\n    var size = this.image.naturalWidth * this.image.naturalHeight * (this.heightMap ? 3 : 3);\n    this.gpuSize = this.image.naturalWidth * this.image.naturalHeight * 4;  //aproximate size \n\n    //if (!this.image.complete) {\n       // size = size;\n    //}\n    \n    //console.log(size);\n\n    this.cacheItem = this.map.resourcesCache.insert(this.killImage.bind(this, true), size);\n\n    this.map.markDirty();\n    this.loadState = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.mapLoaderCallLoaded();\n};\n\n\nMapSubtexture.prototype.scheduleHeadRequest = function(priority, downloadAll) {\n    if (this.map.config.mapXhrImageLoad && this.fastHeaderCheck) {\n        this.scheduleLoad(priority, true);\n    } else {\n        this.map.loader.load(this.mapLoaderUrl, this.onLoadHead.bind(this, downloadAll), priority, this.tile, this.internal, this.internal ? 'texture-in' : 'texture-ex');\n    }\n};\n\n\nMapSubtexture.prototype.onLoadHead = function(downloadAll, url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    var onerror = this.onLoadHeadError.bind(this, downloadAll);\n    var onload = this.onHeadLoaded.bind(this, downloadAll);\n\n    this.checkStatus = 1;\n\n    if (downloadAll) {\n        //utils.loadBinary(url, onload, onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');\n        this.map.loader.processLoadBinary(url, onLoad, onerror, null, 'texture');\n    } else {\n        utils.headRequest(url, onload, onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');\n    }\n};\n\n\nMapSubtexture.prototype.onLoadHeadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    this.checkStatus = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n    \n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n    \n    this.mapLoaderCallError();\n};\n\n\nMapSubtexture.prototype.onHeadLoaded = function(downloadAll, data, status) {\n    if (this.map.killed){\n        return;\n    }\n\n    this.checkStatus = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n\n    if (this.map.config.mapXhrImageLoad && this.fastHeaderCheck) {\n\n        switch (this.checkType) {\n        case VTS_TEXTURECHECK_SIZE:\n            if (data) {\n                if (data.size == this.checkValue) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n                \n        case VTS_TEXTURECHECK_TYPE:\n            if (data) {\n                if (data.type == this.checkValue) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n                \n        case VTS_TEXTURECHECK_CODE:\n            if (status) {\n                if (this.checkValue.indexOf(status) != -1) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n        }\n\n    } else {\n\n        switch (this.checkType) {\n        case VTS_TEXTURECHECK_SIZE:\n            if (data) {\n                if (data.byteLength == this.checkValue) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n                \n        case VTS_TEXTURECHECK_TYPE:\n            if (data) {\n                //if (!data.indexOf) {\n                  //  data = data;\n                //}\n                    \n                if (data.indexOf(this.checkValue) != -1) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n                \n        case VTS_TEXTURECHECK_CODE:\n            if (status) {\n                if (this.checkValue.indexOf(status) != -1) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n        }\n        \n        this.mapLoaderCallLoaded();\n    }\n};\n\n\nMapSubtexture.prototype.buildGpuTexture = function () {\n    if (this.map.config.mapCheckTextureSize && (this.image.naturalWidth > 1024 || this.image.naturalHeight > 1024)) {\n        console.log('very large texture: ' + this.image.naturalWidth + 'x' + this.image.naturalHeight + ' ' + this.mapLoaderUrl);\n\n        var size = 16;\n        var data = new Uint8Array( size * size * 4 );\n\n        for (var i = 0; i < size; i++) {\n            for (var j = 0; j < size; j++) {\n                var index = (i*size+j)*4;\n                data[index] = 0;\n                data[index + 1] = 0;\n                data[index + 2] = 0;\n                data[index + 3] = 255;\n            }\n        }\n\n        this.gpuTexture = new GpuTexture(this.map.renderer.gpu);\n        this.gpuTexture.createFromData(size, size, data);\n        this.gpuTexture.width = this.image.naturalWidth;\n        this.gpuTexture.height = this.image.naturalHeight;\n        //this.gpuTexture = this.map.renderer.blackTexture; \n        this.gpuSize = 0; //this.image.naturalWidth * this.image.naturalHeight * 4;\n        return;\n    }\n\n    this.gpuTexture = new GpuTexture(this.map.renderer.gpu, null, this.map.core);\n    this.gpuTexture.createFromImage(this.image, (this.type == VTS_TEXTURETYPE_CLASS) ? 'nearest' : 'linear', false);\n    this.gpuSize = this.gpuTexture.getSize();\n\n    this.stats.gpuTextures += this.gpuSize;\n\n    this.stats.graphsFluxTexture[0][0]++;\n    this.stats.graphsFluxTexture[0][1] += this.gpuSize;\n\n    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuTexture.bind(this, true), this.gpuSize);\n};\n\n\nMapSubtexture.prototype.buildHeightMap = function () {\n    var canvas = document.createElement('canvas');\n    canvas.width = this.image.naturalWidth;\n    canvas.height = this.image.naturalHeight;\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(this.image, 0, 0);\n    this.imageData = ctx.getImageData(0, 0, this.image.naturalWidth, this.image.naturalHeight).data;\n    this.imageExtents = [this.image.naturalWidth, this.image.naturalHeight];\n    this.image = null;\n};\n\n\nMapSubtexture.prototype.getGpuTexture = function() {\n    return this.gpuTexture;\n};\n\n\nMapSubtexture.prototype.getHeightMapValue = function(x, y) {\n    if (this.imageData) {\n        return this.imageData[(y * this.imageExtents[0] + x)*4];\n    }\n    \n    return 0;\n};\n\nexport default MapSubtexture;\n\n","\nvar MapSurfaceSequence = function(map) {\n    this.map = map;\n};\n\n\nMapSurfaceSequence.prototype.generateSurfaceSequence = function() {\n    var view = this.map.currentView;\n    var tree = this.map.tree;\n    \n    if (!tree) {\n        return;\n    }\n    \n    tree.surfaceSequence = [];\n    tree.surfaceSequenceIndices = []; //probably not used\n    tree.surfaceOnlySequence = [];\n\n    var vsurfaces = {}, surface, glue; \n    var vsurfaceCount = 0;\n    var list = [], listId, i, li, j , lj, key;\n    var strId = [];\n        \n    //add surfaces to the list\n    for (key in view.surfaces) {\n        surface = this.map.getSurface(key);\n        \n        if (surface) {\n            strId.push(surface.id);\n            vsurfaceCount++;\n            vsurfaces[key] = surface.index + 1; //add one to avoid zero \n            //list.push([\"\" + (surface.index + 1), surface, true]);    \n            list.push([ [(surface.index + 1)], surface, true, false]); //[surfaceId, surface, isSurface, isAlien]    \n        }\n    }\n\n\n    if (vsurfaceCount >= 1) { //do we have virtual surface?\n        strId.sort(); \n        strId = strId.join(';');\n\n        surface = this.map.virtualSurfaces[strId];\n        if (surface) {\n            list = [ [ [(surface.index + 1)], surface, true, false] ]; //[surfaceId, surface, isSurface, isAlien]    \n            vsurfaceCount = 1;\n        }\n    }\n    \n    if (vsurfaceCount > 1) {\n        \n        var glues = [];\n    \n        //add proper glues to the list\n        for (key in this.map.glues) {\n            glue = this.map.glues[key];\n\n            //add only glue which contains desired surfaces\n\n            if (!glue || !glue.id) continue;\n\n            var id = glue.id; \n            if (id.length <= vsurfaceCount) {\n    \n                var missed = false;\n                for (j = 0, lj = id.length; j < lj; j++) {\n                    if (!vsurfaces[id[j]]) {\n                        missed = true;\n                        break;\n                    }\n                }\n    \n                if (!missed) {\n                    //var listId = \"\";\n                    listId = [];\n                    \n                    //create glue id in reverse order for sorting\n                    for (j = 0, lj = id.length; j < lj; j++) {\n                        //listId = vsurfaces[id[j]] + (j ? \".\" : \"\") + listId;\n                        listId.unshift(vsurfaces[id[j]]);\n                    }\n    \n                    glues.push([listId, glue, false, false]); //[surfaceId, surface, isSurface, isAlien]   \n                }\n            }\n        }\n    \n        //process glue flags\n        for (i = 0, li = glues.length; i < li; i++) {\n            var item = glues[i];\n            glue = item[1];\n    \n            glue.flagProper = true;\n            glue.flagAlien = true;\n    \n            if (glue.flagProper) {\n                list.push(item);  \n            }\n                    \n            if (glue.flagAlien) {\n                //remove first surface from id\n                listId = item[0].slice(1);\n                            \n                //add same glue as alien\n                list.push([listId, item[1], false, true]); //[surfaceId, surface, isSurface, isAlien]   \n            }\n        }\n    \n        //sort list alphabetically\n        do {\n            var sorted = true;\n            \n            for (i = 0, li = list.length - 1; i < li; i++) {\n                var a1 = list[i][0];\n                var a2 = list[i+1][0];\n                \n                var lesser = false;\n                \n                for (j = 0, lj = Math.min(a1.length, a2.length); j < lj; j++) {\n                    if (a1[j] < a2[j] || (j == (lj -1) && a1[j] == a2[j] && a2.length > a1.length)) {\n                        lesser = true;\n                        break;                    \n                    }\n                }\n                \n                if (lesser) {\n                    var t = list[i];\n                    list[i] = list[i+1];\n                    list[i+1] = t;\n                    sorted = false;\n                } \n            }\n            \n        } while(!sorted);\n   \n        var lastIndex = vsurfaceCount - 1;\n    \n        //convert list to surface sequence\n        for (i = 0, li = list.length; i < li; i++) {\n            tree.surfaceSequence.push([list[i][1], list[i][3]]); //[surface, isAlien]\n            //this.surfaceSequence.push(list[i][1]); \n            list[i][1].viewSurfaceIndex = lastIndex; \n            \n            if (list[i][2]) {\n                lastIndex--;\n                tree.surfaceOnlySequence.push(list[i][1]);\n            }\n        }\n    \n        //this.generateSurfaceSequenceOld();\n        \n    } else {\n        if (vsurfaceCount == 1) {\n            tree.surfaceSequence.push([list[0][1], list[0][3]]); //[surface, isAlien]\n            list[0][1].viewSurfaceIndex = vsurfaceCount - 1;\n            tree.surfaceOnlySequence = [list[0][1]];\n        }\n    }\n\n    this.map.freeLayersHaveGeodata = false;\n\n    //free layers\n    for (key in view.freeLayers) {\n        var freeLayer = this.map.getFreeLayer(key);\n        if (freeLayer) {\n            freeLayer.surfaceSequence = [freeLayer];\n            freeLayer.surfaceOnlySequence = [freeLayer];\n            \n            if (freeLayer.geodata) {\n                this.map.freeLayersHaveGeodata = true;\n            }\n        }\n    }    \n\n    //just in case\n    this.map.renderer.draw.clearJobBuffer();\n};\n\n\nMapSurfaceSequence.prototype.generateBoundLayerSequence = function() {\n    var view = this.map.currentView;\n    var key, item, layer, alpha, i, li, item2;\n    \n    //zero bound layer filters\n    var layers = this.map.boundLayers;\n    for (var key in layers) {\n        layers[key].shaderFilters = null;\n    }\n\n    //surfaces\n    for (key in view.surfaces) {\n        var surfaceLayers = view.surfaces[key];\n        var surface = this.map.getSurface(key);\n        if (surface != null) {\n            surface.boundLayerSequence = [];\n            \n            for (i = 0, li = surfaceLayers.length; i < li; i++) {\n                item = surfaceLayers[i];\n        \n                if (typeof item === 'string') {\n                    layer = this.map.getBoundLayerById(item);\n                    if (layer) {\n                        surface.boundLayerSequence.push([layer, 1]);\n                    }\n                } else {\n                    layer = this.map.getBoundLayerById(item['id']);\n                    if (layer) {\n\n                        alpha = 1;\n                        if (typeof item['alpha'] !== 'undefined') {\n                            alpha = parseFloat(item['alpha']);\n                        }\n\n                        surface.boundLayerSequence.push([layer, alpha]);\n\n                        item2 = item['options'] || item;\n\n                        if (item2['shaderVarFlatShade']) {\n                            if (!layer.shaderFilters) {\n                                layer.shaderFilters = {};\n                            }\n                            \n                            if (!layer.shaderFilters[surface.id]) {\n                                layer.shaderFilters[surface.id] = {};\n                            }\n\n                            layer.shaderFilters[surface.id].varFlatShade = item2['shaderVarFlatShade'];\n                        }\n\n                        if (item2['shaderFilter']) {\n                            if (!layer.shaderFilters) {\n                                layer.shaderFilters = {};\n                            }\n                            \n                            if (!layer.shaderFilters[surface.id]) {\n                                layer.shaderFilters[surface.id] = {};\n                            }\n\n                            layer.shaderFilters[surface.id].filter = item2['shaderFilter'];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //free layers\n    for (key in view.freeLayers) {\n        var freeLayersProperties = view.freeLayers[key];\n        var freeLayer = this.map.getFreeLayer(key);\n        if (freeLayer != null && freeLayer.ready) {\n\n            freeLayer.options = freeLayersProperties['options'] || {};\n\n            freeLayer.boundLayerSequence = [];\n            \n            var boundLayers = freeLayersProperties['boundLayers'];\n            \n            if (boundLayers && Array.isArray(boundLayers)) {\n\n                for (i = 0, li = boundLayers.length; i < li; i++) {\n                    item = boundLayers[i];\n            \n                    if (typeof item === 'string') {\n                        layer = this.map.getBoundLayerById(item);\n                        if (layer) {\n                            freeLayer.boundLayerSequence.push([layer, 1]);\n                        }\n                    } else {\n                        layer = this.map.getBoundLayerById(item['id']);\n                        if (layer) {\n    \n                            alpha = 1;\n                            if (typeof item['alpha'] !== 'undefined') {\n                                alpha = parseFloat(item['alpha']);\n                            }\n    \n                            freeLayer.boundLayerSequence.push([layer, alpha]);\n\n                            if (item['shaderVarFlatShade']) {\n                                if (!layer.shaderFilters) {\n                                    layer.shaderFilters = {};\n                                }\n                                \n                                if (!layer.shaderFilters[surface.id]) {\n                                    layer.shaderFilters[surface.id] = {};\n                                }\n\n                                layer.shaderFilters[surface.id].varFlatShade = item['shaderVarFlatShade'];\n                            }\n\n                            if (item['shaderFilter']) {\n                                if (!layer.shaderFilters) {\n                                    layer.shaderFilters = {};\n                                }\n                                \n                                if (!layer.shaderFilters[surface.id]) {\n                                    layer.shaderFilters[surface.id] = {};\n                                }\n\n                                layer.shaderFilters[surface.id].filter = item['shaderFilter'];\n                            }\n                        }\n                    }\n                }\n            }  \n        }\n    }\n};\n\n\nexport default MapSurfaceSequence;\n\n","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport GpuTexture_ from '../renderer/gpu/texture';\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar GpuTexture = GpuTexture_;\nvar math = math_;\n\n var tileBorderTable = [\n    [-1, -1, 0, 0],\n    [0, -1, 0.5, 1], //\n    [1, -1, 1, 0],\n\n    [-1, 0, 0, 0.5],\n    [0, 0, 0.5, 0.5],\n    [1, 0, 1, 0.5],\n\n    [-1, 1, 0, 1],\n    [0, 1, 0.5, 0], //\n    [1, 1, 1, 1]\n];\n\nvar tileCornerTable = [\n    [0,1,3],\n    [2,1,5],\n    [6,3,7],\n    [8,7,5]\n];\n\n\nvar MapSurfaceTile = function(map, parent, id) {\n    this.map = map;\n    this.id = id;\n    this.parent = parent;\n    this.viewCounter = map.viewCounter;\n    this.drawCounter = 0;\n    this.childrenReadyCount = 0;\n    this.renderReady = false;\n    this.geodataCounter = 0;\n    this.gridRenderCounter = 0; //draw grid only once\n    this.texelSize = 1;\n    this.texelSize2 = 1;\n    this.distance = 1;\n    this.tiltAngle = 1;\n    this.seCounter = 0;\n\n    this.metanode = null;  //[metanode, cacheItem]\n    this.lastMetanode = null;\n    this.boundmetaresources = null; //link to bound layers metatile storage\n\n    this.surface = null; //surface or glue\n    this.surfaceMesh = null;\n    this.surfaceGeodata = null;     //probably only used in free layers\n    this.surfaceGeodataView = null; //probably only used in free layers\n    this.surfaceTextures = [];\n    this.resourceSurface = null; //surface directing to resources\n\n    this.virtual = false;\n    this.virtualReady = false;\n    this.virtualSurfaces = [];\n    \n    this.resetDrawCommands = false;\n    this.drawCommands = [[], [], []];\n\n    this.bounds = {};\n    this.boundLayers = {};\n    this.boundTextures = {};\n    this.updateBounds = true;\n\n    this.hmap = null;\n    this.heightMap = null;\n    this.drawCommands = [[], [], []];\n    this.imageryCredits = {};\n    this.glueImageryCredits = {};\n    this.mapdataCredits = {};\n    \n    this.resources = this.map.resourcesTree.findNode(id, true);   // link to resource tree\n    this.metaresources = this.map.resourcesTree.findAgregatedNode(id, 5, true); //link to meta resource tree\n    this.boundresources = this.map.resourcesTree.findAgregatedNode(id, 8, true); //link to meta resource tree\n    \n    this.children = [null, null, null, null];\n};\n\n\nMapSurfaceTile.prototype.kill = function() {\n    //kill children\n    for (var i = 0; i < 4; i++) {\n        if (this.children[i] != null) {\n            this.children[i].kill();\n        }\n    }\n/*\n    if (this.surfaceMesh != null) {\n        this.surfaceMesh.kill();\n    }\n\n    for (var key in this.surfaceTextures) {\n        if (this.surfaceTextures[key] != null) {\n            this.surfaceTextures[key].kill();\n        }\n    }\n\n    if (this.surfaceGeodata != null) {\n        this.surfaceGeodata.kill();\n    }\n\n    if (this.surfaceGeodataView != null) {\n        this.surfaceGeodataView.kill();\n    }\n\n    if (this.heightMap != null) {\n        this.heightMap.kill();\n    }\n\n    for (var key in this.boundTextures) {\n        if (this.boundTextures[key] != null) {\n            this.boundTextures[key].kill();\n        }\n    }\n*/\n    this.resources = null;\n    this.metaresources = null;\n    this.metanode = null;\n\n    this.surface = null;\n    this.surfaceMesh = null;\n    this.surfaceTextures = [];\n    this.surfaceGeodata = null;\n    this.surfaceGeodataView = null;\n    this.resourceSurface = null;\n\n    this.bounds = {};\n    this.boundLayers = {};\n    this.boundTextures = {};\n    this.updateBounds = true;\n\n    this.virtual = false;\n    this.virtualReady = false;\n    this.virtualSurfaces = [];\n\n    this.renderReady = false;\n    this.lastSurface = null;\n    this.lastState = null;\n    this.lastRenderState = null;\n        \n    this.hmap = null;\n    this.heightMap = null;\n    this.drawCommands = [[], [], []];\n    this.imageryCredits = {};\n    this.glueImageryCredits = {};\n    this.mapdataCredits = {};\n\n    this.verifyChildren = false;\n    this.children = [null, null, null, null];\n\n    var parent = this.parent;\n    this.parent = null;\n\n    if (parent != null) {\n        parent.removeChild(this);\n    }\n};\n\n\nMapSurfaceTile.prototype.validate = function() {\n    //is tile empty?\n    if (this.metaresources == null || !this.metaresources.getMetatile(this.surface, null, this)) {\n        //this.kill();\n    }\n};\n\n\nMapSurfaceTile.prototype.viewSwitched = function() {\n    //store last state for view switching\n    this.lastSurface = this.surface;\n    this.lastState = {\n        surfaceMesh : this.surfaceMesh,\n        surfaceTextures : this.surfaceTextures,\n        boundTextures : this.boundTextures,\n        surfaceGeodata : this.surfaceGeodata,\n        surfaceGeodataView : this.surfaceGeodataView,\n        resourceSurface : this.resourceSurface \n    };    \n\n    if (this.drawCommands[0].length > 0) {  // check only visible chanel\n        this.lastRenderState = {\n            drawCommands : this.drawCommands,\n            imageryCredits : this.imageryCredits,\n            mapdataCredits : this.mapdataCredits\n        };\n    } else {\n        this.lastRenderState = null;\n    }\n    \n    //zero surface related data    \n    this.verifyChildren = true;\n    this.renderReady = false;\n    this.lastMetanode = this.metanode;\n    this.metanode = null; //quick hack for switching virtual surfaeces //keep old value for smart switching\n\n    if (!this.map.config.mapSoftViewSwitch) {\n\n        if (this.metanode) {\n            this.metanode.border = null;\n            this.metanode.border2 = null;\n            this.metanode.border3 = null;\n            this.metanode.borderNodes = null;\n            this.metanode.borderReady = null;\n        }\n\n        this.lastState = null;\n        this.lastRenderState = null;\n        this.lastMetanode = null;\n        this.metanode = null;\n        this.gridPoints = null;\n    }\n\n    //this.lastMetanode = null;\n    //this.metanode = null;\n\n    for (var key in this.bounds) {\n        this.bounds[key] = {\n            sequence : [],\n            alpha : [],\n            transparent : false,\n            viewCoutner : 0\n        };\n    }\n\n    this.boundLayers = {};\n    this.boundTextures = {};\n    this.updateBounds = true;\n    this.transparentBounds = false;\n\n    this.surface = null;\n    this.surfaceMesh = null;\n    this.surfaceTextures = [];\n    this.surfaceGeodata = null;\n    this.surfaceGeodataView = null;\n    this.resourceSurface = null;\n    \n    this.virtual = false;\n    this.virtualReady = false;\n    this.virtualSurfaces = [];\n    this.virtualSurfacesUncomplete = false;\n    \n    this.drawCommands = [[], [], []];\n    this.imageryCredits = {};\n    this.glueImageryCredits = {};\n    this.mapdataCredits = {};\n};\n\n\nMapSurfaceTile.prototype.restoreLastState = function() {\n    if (!this.lastState) {\n        return;\n    }\n    this.surfaceMesh = this.lastState.surfaceMesh;\n    this.surfaceTextures = this.lastState.surfaceTextures; \n    this.boundTextures = this.lastState.boundTextures;\n    this.surfaceGeodata = this.lastState.surfaceGeodata;\n    this.surfaceGeodataView = this.lastState.surfaceGeodataView;\n    this.resourceSurface = this.lastState.resourceSurface; \n    this.lastSurface = null;\n    this.lastState = null;\n    this.lastResourceSurface = null;\n};\n\n\nMapSurfaceTile.prototype.addChild = function(index) {\n    if (this.children[index]) {\n        return;\n    }\n    \n    var id = this.id;\n    var childId = [id[0] + 1, id[1] << 1, id[2] << 1];\n\n    switch (index) {\n    case 1: childId[1]++; break;\n    case 2: childId[2]++; break;\n    case 3: childId[1]++; childId[2]++; break;\n    }\n\n    this.children[index] = new MapSurfaceTile(this.map, this, childId);\n};\n\n\nMapSurfaceTile.prototype.removeChildByIndex = function(index) {\n    if (this.children[index] != null) {\n        this.children[index].kill();\n        this.children[index] = null;\n    }\n    \n    //remove resrource node?\n};\n\n\nMapSurfaceTile.prototype.removeChild = function(tile) {\n    for (var i = 0; i < 4; i++) {\n        if (this.children[i] == tile) {\n            this.children[i].kill();\n            this.children[i] = null;\n        }\n    }\n};\n\n\nMapSurfaceTile.prototype.isMetanodeReady = function(tree, priority, preventLoad) {\n\n    //has map view changed?\n    if (this.map.viewCounter != this.viewCoutner) {\n        this.viewSwitched();\n        this.viewCoutner = this.map.viewCounter;\n        this.map.markDirty(); \n    }\n        \n    if (!preventLoad) {\n   \n        //provide surface for tile\n        if (this.virtualSurfacesUncomplete || (this.surface == null && this.virtualSurfaces.length == 0) ) { //|| this.virtualSurfacesUncomplete) {\n            this.checkSurface(tree, priority);\n        }\n   \n        //provide metanode for tile\n        if (this.metanode == null || this.lastMetanode) {\n            \n            if (!this.virtualSurfacesUncomplete) {\n                var ret = this.checkMetanode(tree, priority);\n                \n                if (!ret && !(this.metanode != null && this.lastMetanode)) { //metanode is not ready yet\n                    return false;\n                }\n            }\n            \n            /*if (this.lastMetanode) {\n                processFlag2 = true;\n            }*/\n        }\n        \n    }\n\n    if (this.metanode == null) { // || processFlag3) { //only for wrong data\n        return false;\n    }\n\n    this.metanode.metatile.used();\n\n    if (this.lastSurface && this.lastSurface == this.surface) {\n        this.lastSurface = null;\n        this.restoreLastState();\n        //return;\n    }\n\n    if (this.surface) {\n        if (this.surface.virtual) {\n            this.resourceSurface = this.surface.getSurface(this.metanode.sourceReference);\n            if (!this.resourceSurface) {\n                this.resourceSurface = this.surface;\n            }\n        } else {\n            this.resourceSurface = this.surface;\n        }\n    }\n\n    if (this.seCounter != this.map.renderer.seCounter) {\n        var renderer = this.map.renderer;\n        this.seCounter = renderer.seCounter;\n        var node = this.metanode;\n\n        if (renderer.useSuperElevation) {\n            node.minZ = renderer.getSuperElevatedHeight(node.minZ2);\n            node.maxZ = renderer.getSuperElevatedHeight(node.maxZ2);\n        } else {\n            node.minZ = node.minZ2;\n            node.maxZ = node.maxZ2;\n        }\n\n        if (renderer.seCounter > 0) {\n            this.gridPoints = null;\n            node.border = null;\n            node.border2 = null;\n            node.border3 = null;\n            node.borderReady = false;\n     \n            node.generateCullingHelpers();\n        }\n    }\n\n    return true;\n};\n\n\nMapSurfaceTile.prototype.checkSurface = function(tree, priority) {\n    this.surface = null;\n    this.virtual = false;\n    this.virtualReady = false;\n    this.virtualSurfaces = [];\n    this.virtualSurfacesUncomplete = false;\n    \n    if (tree.freeLayerSurface) {  //free layer has only one surface\n        this.surface = tree.freeLayerSurface;\n        return; \n    }\n\n    var sequence = tree.surfaceSequence;\n\n    //multiple surfaces\n    //build virtual surfaces array\n    //find surfaces with content\n    for (var i = 0, li = sequence.length; i < li; i++) {\n        var surface = sequence[i][0];\n        var alien = sequence[i][1];\n\n        var res = surface.hasTile2(this.id);\n        if (res[0]) {\n            \n            //check if tile exist\n            if (this.id[0] > 0) { //surface.lodRange[0]) {\n                // removed for debug !!!!!\n                // ????????\n                var parent = this.parent;\n                if (parent) { \n                    \n                    if (parent.virtualSurfacesUncomplete) {\n                        this.virtualSurfacesUncomplete = true;\n                        this.virtualSurfaces = [];\n                        return;\n                    }\n                    \n                    var metatile = parent.metaresources.getMetatile(surface, null, this);\n                    if (metatile) {\n                        \n                        if (!metatile.isReady(priority)) {\n                            this.virtualSurfacesUncomplete = true;\n                            continue;\n                        }\n                        \n                        var node = metatile.getNode(parent.id);\n                        if (node) {\n                            if (!node.hasChildById(this.id)) {\n                                continue;\n                            }\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                }\n            }\n    \n            //store surface\n            this.virtualSurfaces.push([surface, alien]);        \n        }\n    }\n\n    if (this.virtualSurfaces.length > 1) {\n        this.virtual = true;\n    } else {\n        this.surface = (this.virtualSurfaces[0]) ? this.virtualSurfaces[0][0] : null;\n    }\n};\n\n\nMapSurfaceTile.prototype.checkMetanode = function(tree, priority) {\n    if (this.virtual) {\n        if (this.isVirtualMetanodeReady(tree, priority)) {\n            this.metanode = this.createVirtualMetanode(tree, priority);\n            this.lastMetanode = null;\n            this.map.markDirty();\n        } else {\n            return false;\n        }\n    }\n\n    var surface = this.surface;\n\n    if (surface == null) {\n        return false;\n    }\n\n    var metatile = this.metaresources.getMetatile(surface, true, this);\n\n    if (metatile.isReady(priority)) {\n\n        if (!this.virtual) {\n            this.metanode = metatile.getNode(this.id);\n            this.lastMetanode = null;\n            this.map.markDirty(); \n        }\n\n        if (this.metanode != null) {\n            this.metanode.tile = this; //used only for validate\n            this.lastMetanode = null;\n            this.map.markDirty(); \n\n            for (var i = 0; i < 4; i++) {\n                if (this.metanode.hasChild(i)) {\n                    this.addChild(i);\n                } else {\n                    this.removeChildByIndex(i);\n                }\n            }\n        }\n\n    } else {\n        return false;\n    }\n    \n    return true;\n};\n\n\nMapSurfaceTile.prototype.isVirtualMetanodeReady = function(tree, priority) {\n    var surfaces = this.virtualSurfaces;\n    var readyCount = 0;\n\n    for (var i = 0, li = surfaces.length; i < li; i++) {\n        var surface = surfaces[i][0];\n        var metatile = this.metaresources.getMetatile(surface, true, this);\n\n        if (metatile.isReady(priority)) {\n            readyCount++;\n        }\n    }\n    \n    if (readyCount == li) {\n        return true;        \n    } else {\n        return false;\n    }\n};\n\n\nMapSurfaceTile.prototype.createVirtualMetanode = function(tree, priority) {\n    var surfaces = this.virtualSurfaces;\n    var node = null, i, li, surface, metatile, metanode;\n\n    //get top most existing surface\n    for (i = 0, li = surfaces.length; i < li; i++) {\n        surface = surfaces[i][0];\n        var alien = surfaces[i][1];\n        metatile = this.metaresources.getMetatile(surface, null, this);\n\n        if (metatile.isReady(priority)) {\n            metanode = metatile.getNode(this.id);\n\n            if (metanode != null) {\n                if (alien != metanode.alien) {\n                    continue;\n                }\n\n                //does metanode have surface reference?\n                //internalTextureCount is reference to surface\n                if (!alien && surface.glue && !metanode.hasGeometry() &&\n                    metanode.internalTextureCount > 0) {\n                    \n                    var desiredSurfaceIndex = metanode.internalTextureCount - 1;\n                    desiredSurfaceIndex = this.map.getSurface(surface.id[desiredSurfaceIndex]).viewSurfaceIndex;\n                    \n                    var jump = false; \n                        \n                    for (var j = i; j < li; j++) {\n                        if (surfaces[j].viewSurfaceIndex <= desiredSurfaceIndex) {\n                            jump = (j > i);\n                            i = j - 1;\n                            break;\n                        }\n                    }\n                    \n                    if (jump) {\n                        continue;\n                    }                         \n                }\n                \n                if (metanode.hasGeometry()) {\n                    node = metanode.clone();\n                    this.surface = surface;\n                    break;\n                }\n            }\n        }\n    }\n\n    //extend bbox, credits and children flags by other surfaces\n    for (i = 0, li = surfaces.length; i < li; i++) {\n        surface = surfaces[i][0];\n        metatile = this.metaresources.getMetatile(surface, null, this);\n\n        if (metatile.isReady(priority)) {\n            metanode = metatile.getNode(this.id);\n\n            if (metanode != null) {\n                //does metanode have surface reference?\n                //internalTextureCount is reference to surface\n                /*\n                if (surface.glue && !metanode.hasGeometry() &&\n                    metanode.internalTextureCount > 0) {\n                    i = this.map.surfaceSequenceIndices[metanode.internalTextureCount - 1] - 1;\n                    continue;\n                }*/\n\n                if (!node) { //just in case all surfaces are without geometry\n                    node = metanode.clone();\n                    this.surface = surface;\n                } else {\n                    node.flags |= metanode.flags & ((15)<<4); \n\n                    /*\n                    for (var j = 0, lj = metanode.credits.length; j <lj; j++) {\n                        if (node.credits.indexOf(metanode.credits[j]) == -1) {\n                            node.credits.push(metanode.credits[j]);\n                        } \n                    }*/\n                   \n                    if (metatile.useVersion < 4) {\n                        // removed for debug !!!!!\n                        node.bbox.min[0] = Math.min(node.bbox.min[0], metanode.bbox.min[0]); \n                        node.bbox.min[1] = Math.min(node.bbox.min[1], metanode.bbox.min[1]); \n                        node.bbox.min[2] = Math.min(node.bbox.min[2], metanode.bbox.min[2]); \n                        node.bbox.max[0] = Math.max(node.bbox.max[0], metanode.bbox.max[0]); \n                        node.bbox.max[1] = Math.max(node.bbox.max[1], metanode.bbox.max[1]); \n                        node.bbox.max[2] = Math.max(node.bbox.max[2], metanode.bbox.max[2]);\n                    }\n                }\n            }\n        }\n    }\n    \n    if (node) {\n        node.generateCullingHelpers(true);\n    }\n    \n    return node;\n};\n\n\nMapSurfaceTile.prototype.bboxVisible = function(id, bbox, cameraPos, node) {\n    var map = this.map;\n    var camera = map.camera;\n    if (id[0] < map.measure.minDivisionNodeDepth) {\n        return true;\n    }\n    \n    var skipGeoTest = map.config.mapDisableCulling;\n    if (!skipGeoTest && map.isGeocent) {\n        if (node) {\n            //if (true) {  //version with perspektive\n            var p2 = node.diskPos;\n            var p1 = camera.position;\n            var rayVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            var distance = vec3.normalize4(rayVec) * camera.distanceFactor;\n                //vec3.normalize(camVec);\n                \n            var a = vec3.dot(rayVec, node.diskNormal);\n            //} else { //version without perspektive\n            //    var a = vec3.dot(camera.vector, node.diskNormal);\n            //}\n            this.tiltAngle = a;\n            \n            if (distance > 150000 && a > node.diskAngle) {\n                return false;\n            }\n        }\n    }\n\n    if (node.metatile.useVersion >= 4) {\n        return camera.camera.pointsVisible(node.bbox2, cameraPos);\n    } else {\n        if (!(map.isGeocent && (map.config.mapPreciseBBoxTest)) || id[0] < 4) {\n            return camera.camera.bboxVisible(bbox, cameraPos);\n        } else {\n            return camera.camera.pointsVisible(node.bbox2, cameraPos);\n        }\n    }\n};\n\nMapSurfaceTile.prototype.insideCone = function(coneVec, angle, node) {\n\n    if (this.map.isGeocent) { // && node.diskPos && node.diskNormal) {\n        var a = Math.acos(vec3.dot(coneVec, node.diskNormal));\n\n        return (a < angle + node.diskAngle2A);\n    }\n\n    return false;\n};\n\n\nMapSurfaceTile.prototype.getPixelSize = function(bbox, screenPixelSize, cameraPos, worldPos, returnDistance) {\n    var min = bbox.min;\n    var max = bbox.max;\n    var tilePos1x = min[0] - cameraPos[0];\n    var tilePos1y = min[1] - cameraPos[1];\n    var tilePos2x = max[0] - cameraPos[0];\n    var tilePos2y = min[1] - cameraPos[1];\n    var tilePos3x = max[0] - cameraPos[0];\n    var tilePos3y = max[1] - cameraPos[1];\n    var tilePos4x = min[0] - cameraPos[0];\n    var tilePos4y = max[1] - cameraPos[1];\n    var h1 = min[2] - cameraPos[2];\n    var h2 = max[2] - cameraPos[2];\n    \n    //camera inside bbox\n    if (cameraPos[0] > min[0] && cameraPos[0] < max[0] &&\n        cameraPos[1] > min[1] && cameraPos[1] < max[1] &&\n        cameraPos[2] > min[2] && cameraPos[2] < max[2]) {\n\n        if (returnDistance) {\n            return [Number.POSITIVE_INFINITY, 0.1];\n        }\n    \n        return Number.POSITIVE_INFINITY;\n    }\n\n    var factor = 0;\n    var camera = this.map.camera.camera;\n\n    //find bbox sector\n    if (0 < tilePos1y) { //top row - zero means camera position in y\n        if (0 < tilePos1x) { // left top corner\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos1x, tilePos1y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos1x, tilePos1y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos1x, tilePos1y, (h1 + h2)*0.5], returnDistance);\n            }\n        } else if (0 > tilePos2x) { // right top corner\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos2x, tilePos2y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos2x, tilePos2y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos2x, tilePos2y, (h1 + h2)*0.5], returnDistance);\n            }\n        } else { //top side\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, (h1 + h2)*0.5], returnDistance);\n            }\n        }\n    } else if (0 > tilePos4y) { //bottom row\n        if (0 < tilePos4x) { // left bottom corner\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos4x, tilePos4y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos4x, tilePos4y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos4x, tilePos4y, (h1 + h2)*0.5], returnDistance);\n            }\n        } else if (0 > tilePos3x) { // right bottom corner\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos3x, tilePos3y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos3x, tilePos3y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos3x, tilePos3y, (h1 + h2)*0.5], returnDistance);\n            }\n        } else { //bottom side\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, (h1 + h2)*0.5], returnDistance);\n            }\n        }\n    } else { //middle row\n        if (0 < tilePos4x) { // left side\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);\n            }\n        } else if (0 > tilePos3x) { // right side\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);\n            }\n        } else { //center\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);\n            }\n        }\n    }\n\n    //console.log(\"new: \" + (factor * screenPixelSize) + \" old:\" + this.tilePixelSize2(node) );\n\n    if (returnDistance) {\n        return [(factor[0] * screenPixelSize), factor[1]];\n    }\n\n    return (factor * screenPixelSize);\n};\n\n\nMapSurfaceTile.prototype.getPixelSize3Old = function(node, screenPixelSize, factor) {\n    var camera = this.map.camera;\n    var d = (camera.geocentDistance*factor) - node.diskDistance;\n    if (d < 0) {\n        d = -d;\n        //return [Number.POSITIVE_INFINITY, 0.1];\n    } \n\n    var a = vec3.dot(camera.geocentNormal, node.diskNormal);\n    \n    if (a < node.diskAngle2) {\n        var a2 = Math.acos(a); \n        var a3 = Math.acos(node.diskAngle2);\n        a2 = a2 - a3; \n\n        var l1 = Math.tan(a2) * node.diskDistance;\n        d = Math.sqrt(l1*l1 + d*d);\n    }\n\n    factor = camera.camera.scaleFactor2(d);\n    return [factor * screenPixelSize, d];\n};\n\n\nMapSurfaceTile.prototype.getPixelSize3 = function(node, screenPixelSize) {\n    //if (this.map.drawIndices) {\n      //  return this.getPixelSize3Old(node, screenPixelSize, factor);\n    //}\n    var camera = this.map.camera;\n    var cameraDistance = camera.geocentDistance;// * factor;\n\n    var a = vec3.dot(camera.geocentNormal, node.diskNormal); //get angle between tile normal and cameraGeocentNormal\n    var d = cameraDistance - (node.diskDistance + (node.maxZ - node.minZ)), d2; //vertical distance from top bbox level\n\n    if (a < node.diskAngle2) { //is camera inside tile conus?\n        \n        //get horizontal distance\n        var a2 = Math.acos(a); \n        var a3 = node.diskAngle2A;\n        a2 = a2 - a3; \n        var l1 = Math.tan(a2) * node.diskDistance;// * factor;\n\n        if (d < 0) { //is camera is belown top bbox level?\n            d2 = cameraDistance - node.diskDistance;\n            if (d2 < 0) { //is camera is belown bottom bbox level?\n                d = -d2;\n                d = Math.sqrt(l1*l1 + d*d);\n            } else { //is camera inside bbox\n                d = l1;\n            }\n        } else {\n            d = Math.sqrt(l1*l1 + d*d);\n        }\n\n    } else {\n        if (d < 0) { //is camera is belown top bbox level?\n            d2 = cameraDistance - node.diskDistance;\n            if (d2 < 0) { //is camera is belown bottom bbox level?\n                d = -d2;\n            } else { //is camera inside bbox\n                return [Number.POSITIVE_INFINITY, 0.1];\n            }\n        } \n    }\n\n    return [camera.camera.scaleFactor2(d) * screenPixelSize, d];\n};\n\n/*\n\nMapSurfaceTile.prototype.getPixelSize22 = function(bbox, screenPixelSize, cameraPos, worldPos, returnDistance) {\n    var min = bbox.min;\n    var max = bbox.max;\n    var p1 = bbox.center();\n    bbox.updateMaxSize();\n    var d = bbox.maxSize * 0.5; \n    \n    var dd = [cameraPos[0]-p1[0],\n               cameraPos[1]-p1[1],\n               cameraPos[2]-p1[2]]; \n\n    var d2 = vec3.length(dd) - (bbox.maxSize * 0.5);\n\n    var factor = this.camera.scaleFactor2(d2);\n\n    if (returnDistance) {\n        return [(factor[0] * screenPixelSize), factor[1]];\n    }\n\n    return (factor * screenPixelSize);\n};\n*/\n\nMapSurfaceTile.prototype.updateTexelSize = function() {\n    var pixelSize, factor, v, p;\n    var map = this.map;\n    var draw = map.draw;\n    var camera = map.camera;\n    var texelSizeFit = draw.texelSizeFit;\n    var node = this.metanode;\n    var cameraPos = map.camera.position;\n    var preciseDistance = (map.isGeocent && (map.config.mapPreciseDistanceTest || node.metatile.useVersion >= 4));  \n\n    if (node.hasGeometry()) {\n        var screenPixelSize = Number.POSITIVE_INFINITY;\n\n        if (node.usedTexelSize()) {\n            screenPixelSize = draw.ndcToScreenPixel * node.pixelSize;\n        } else if (node.usedDisplaySize()) {\n            screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / node.displaySize);\n        }\n\n        if (camera.camera.ortho) {\n            var height = camera.camera.getViewHeight();\n            pixelSize = [(screenPixelSize*2.0) / height, height];\n        } else {\n            \n            if (node.usedDisplaySize()) { \n               \n                if (!preciseDistance) {\n                    screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / 256);\n\n                    factor = (node.displaySize / 256) * camera.distance;\n                    //var factor = (256 / 256) * this.map.cameraDistance;\n                    \n                    v = camera.vector; //move camera away hack\n                    p = [cameraPos[0] - v[0] * factor, cameraPos[1] - v[1] * factor, cameraPos[2] - v[2] * factor];\n\n                    pixelSize = this.getPixelSize(node.bbox, screenPixelSize, p, p, true);\n                } else {\n                    if (draw.isGeocent) {\n                        //screenPixelSize = draw.ndcToScreenPixel * ((node.diskAngle2A * draw.planetRadius * 2 * 0.70710678118) / 256) * (256 / node.displaySize);\n                        screenPixelSize = draw.ndcToScreenPixel * ((node.diskAngle2A * draw.planetRadius * 1.41421356236) / node.displaySize);\n                    } else {\n                        //screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / 256) * (256 / node.displaySize);\n                        screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / node.displaySize);\n                    }\n\n                    pixelSize = this.getPixelSize3(node, screenPixelSize);\n                }\n            } else {\n                \n                if (!preciseDistance && texelSizeFit > 1.1) {\n                    screenPixelSize = draw.ndcToScreenPixel * node.pixelSize * (texelSizeFit / 1.1);\n                    factor = (texelSizeFit / 1.1) * camera.distance;\n                    \n                    v = camera.vector; //move camera away hack\n                    p = [cameraPos[0] - v[0] * factor, cameraPos[1] - v[1] * factor, cameraPos[2] - v[2] * factor];\n                    \n                    pixelSize = this.getPixelSize(node.bbox, screenPixelSize, p, p, true);\n                } else {\n                    if (preciseDistance) {\n                        pixelSize = this.getPixelSize3(node, screenPixelSize);\n                    } else {\n                        pixelSize = this.getPixelSize(node.bbox, screenPixelSize, cameraPos, cameraPos, true);\n                    }\n                }\n            }\n        }\n    } else {\n        if (preciseDistance) {\n            pixelSize = this.getPixelSize3(node, 1, 1);\n        } else {\n            pixelSize = this.getPixelSize(node.bbox, 1, cameraPos, cameraPos, true);\n        }\n\n        //pixelSize = this.getPixelSize(node.bbox, 1, cameraPos, cameraPos, true);\n        pixelSize[0] = Number.POSITIVE_INFINITY;\n    }\n\n    this.texelSize = pixelSize[0];\n    this.distance = pixelSize[1];\n\n    //degrade horizont\n    if (!map.config.mapDegradeHorizon || draw.degradeHorizonFactor < 1.0) {\n        return;\n    }\n\n    var degradeHorizon = map.config.mapDegradeHorizonParams;\n    var degradeFadeStart = degradeHorizon[1];\n    var degradeFadeEnd = degradeHorizon[2];\n\n    //reduce degrade factor by tilt\n    var degradeFactor = draw.degradeHorizonFactor * draw.degradeHorizonTiltFactor; \n    var distance = this.distance * camera.distanceFactor;\n\n    //apply degrade factor smoothly from specified tile distance\n    if (distance < degradeFadeStart) {\n        degradeFactor = 1.0;\n    } else if (distance > degradeFadeStart && distance < degradeFadeEnd) {\n        degradeFactor = 1.0 + (degradeFactor-1.0) * ((distance - degradeFadeStart) / (degradeFadeEnd - degradeFadeStart));\n    }\n\n    degradeFactor = Math.max(degradeFactor, 1.0);\n\n    //reduce degrade factor by observed distance\n    var observerDistance = camera.perceivedDistance;\n    var distanceFade = degradeHorizon[3];\n\n    if (observerDistance > distanceFade) {\n        degradeFactor = 1.0;\n    } else if (observerDistance < distanceFade && degradeFactor > 1.0) {\n        degradeFactor = 1.0 + ((degradeFactor - 1.0) * (1.0-(observerDistance / distanceFade)));\n    }\n\n    //console.log(\"degrade: \" + degradeFactor);\n\n    this.texelSize /= degradeFactor;\n};\n\n\nMapSurfaceTile.prototype.drawGrid = function(cameraPos, divNode, angle, onlySetBorderData, subdiv) {\n    /* if (!(subdiv || onlySetBorderData)) {\n        if (this.gridRenderCounter != this.map.draw.drawCounter) {\n            this.gridRenderCounter = this.map.draw.drawCounter;\n        } else {\n            return; //prevent rendering same grid more then on time\n        }\n    } */\n\n    if ((this.texelSize == Number.POSITIVE_INFINITY || this.texelSize > 4.4) && this.metanode && this.metanode.hasChildren()) {\n        return;\n    }\n    \n    if (!this.metanode) {\n        return;\n    }\n\n    var map = this.map, node, ll, ur, res;\n\n    if (map.draw.gridSkipped) {\n        return;\n    }\n\n\n    if (divNode) {\n        node = divNode[0]; \n        ll = divNode[1][0];\n        ur = divNode[1][1];\n    } else {\n        res = map.measure.getSpatialDivisionNodeAndExtents(this.id);\n        node = res[0]; \n        ll = res[1][0];\n        ur = res[1][1];\n    }\n   \n    var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5];\n\n    var hasPoles = map.referenceFrame.hasPoles;\n\n    angle = angle || this.metanode.diskAngle2;\n    \n    if ((hasPoles && !node.isPole) &&  Math.acos(angle) > Math.PI*0.1) {\n        angle = Math.cos(Math.acos(angle) * 0.5); \n        \n        this.drawGrid(cameraPos, [node, [ [ll[0], ll[1]],  [middle[0], middle[1]] ] ], angle, false, true);\n        this.drawGrid(cameraPos, [node, [ [middle[0], ll[1]],  [ur[0], middle[1]] ] ], angle, false, true);\n\n        this.drawGrid(cameraPos, [node, [ [ll[0], middle[1]],  [middle[0], ur[1]] ] ], angle, false, true);\n        this.drawGrid(cameraPos, [node, [ [middle[0], middle[1]],  [ur[0], ur[1]] ] ], angle, false, true);\n       \n        return;\n    }\n     \n    var desiredSamplesPerViewExtent = 5;\n    var nodeExtent = node.extents.ur[1] - node.extents.ll[1];\n    var viewExtent = this.distance ;//* 0.1;\n    var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / map.log2;\n    lod = Math.max(0,lod - 8 + node.id[0]);\n   \n    var h, factor, prog, draw = map.draw; \n\n    var sx = cameraPos[0];\n    var sx = cameraPos[0];\n    var sy = cameraPos[1];\n    var sz = cameraPos[2];\n    var buffer = draw.planeBuffer;\n    var flatGrid = draw.gridFlat;\n    var joinGrids = draw.gridGlues; //this.map.draw.debug.drawFog;\n    var gridPoints = this.gridPoints;\n    var useSurrogatez = map.config.mapGridSurrogatez;\n\n    if (!gridPoints) {\n\n        h = useSurrogatez ? this.metanode.surrogatez : this.metanode.minZ;\n        var n1 = node.getPhysicalCoords([ur[0], ur[1], h], true);\n        var n2 = node.getPhysicalCoords([ur[0], ll[1], h], true);\n        var n3 = node.getPhysicalCoords([ll[0], ll[1], h], true);\n        var n4 = node.getPhysicalCoords([ll[0], ur[1], h], true);\n        var mtop = node.getPhysicalCoords([middle[0], ur[1], h], true);\n        var mbottom = node.getPhysicalCoords([middle[0], ll[1], h], true);\n        var mleft = node.getPhysicalCoords([ll[0], middle[1], h], true);\n        var mright = node.getPhysicalCoords([ur[0], middle[1], h], true);\n\n        middle[2] = h;\n        middle = node.getPhysicalCoords(middle, true);\n\n        if (!divNode) {\n\n            var gridPoints = [\n                n4[0], n4[1], n4[2],\n                mtop[0], mtop[1], mtop[2],\n                n1[0], n1[1], n1[2],\n\n                mleft[0], mleft[1], mleft[2],\n                middle[0], middle[1], middle[2],\n                mright[0], mright[1], mright[2],\n                \n                n3[0], n3[1], n3[2],\n                mbottom[0], mbottom[1], mbottom[2],\n                n2[0], n2[1], n2[2]\n            ];\n\n            this.gridPoints = gridPoints;\n\n        } else {\n            buffer[0] = n4[0] - sx;\n            buffer[1] = n4[1] - sy;\n            buffer[2] = n4[2] - sz;\n            \n            buffer[3] = mtop[0] - sx;\n            buffer[4] = mtop[1] - sy;\n            buffer[5] = mtop[2] - sz;\n\n            buffer[6] = n1[0] - sx;\n            buffer[7] = n1[1] - sy;\n            buffer[8] = n1[2] - sz;\n\n            buffer[9] = mleft[0] - sx;\n            buffer[10] = mleft[1] - sy;\n            buffer[11] = mleft[2] - sz;\n                    \n            buffer[12] = middle[0] - sx;\n            buffer[13] = middle[1] - sy;\n            buffer[14] = middle[2] - sz;\n                    \n            buffer[15] = mright[0] - sx;\n            buffer[16] = mright[1] - sy;\n            buffer[17] = mright[2] - sz;\n                \n            buffer[18] = n3[0] - sx;\n            buffer[19] = n3[1] - sy;\n            buffer[20] = n3[2] - sz;\n            \n            buffer[21] = mbottom[0] - sx;\n            buffer[22] = mbottom[1] - sy;\n            buffer[23] = mbottom[2] - sz;\n            \n            buffer[24] = n2[0] - sx;\n            buffer[25] = n2[1] - sy;\n            buffer[26] = n2[2] - sz;\n        }\n     }\n\n\n    if (!flatGrid) {\n\n        var mnode = this.metanode; \n           \n        var border = mnode.border, borderNodes = mnode.borderNodes;\n        var i, li, n, tree = map.tree, id = this.id;\n        \n        if (!border) {\n            mnode.border = new Array(9);\n            mnode.borderNodes = new Array(9);\n            border = mnode.border, borderNodes = mnode.borderNodes;\n            border[4] = useSurrogatez ? mnode.surrogatez : mnode.minZ;\n        }\n        \n\n        var borderTable = tileBorderTable;\n        var skip = false;\n\n        if (!mnode.borderReady) {\n            \n            for (i = 0; i < 9; i++) {\n                if (i != 4 && !borderNodes[i]) {\n                    n = tree.getNodeById([id[0], id[1] + borderTable[i][0], id[2] + borderTable[i][1]], true);\n\n                    if (n) {\n                        borderNodes[i] = n;\n                        border[i] = (useSurrogatez ? n.surrogatez : n.minZ);\n                    } else {\n                        border[i] = border[4];\n                        skip = true;\n                    }\n                }\n            }\n           \n        }\n\n        var border2 = mnode.border2;\n        h = useSurrogatez ? mnode.surrogatez : mnode.minZ\n\n        if (!border2 || !mnode.borderReady) {\n            border2 = [\n                ((border[0] + border[1] + border[3] + border[4]) * 0.25) - h, \n                ((border[1] + border[4]) * 0.5) - h,\n                ((border[2] + border[1] + border[5] + border[4]) * 0.25) - h,\n\n                ((border[3] + border[4]) * 0.5) - h,\n                border[4] - h,\n                ((border[5] + border[4]) * 0.5) - h,\n\n                ((border[6] + border[7] + border[3] + border[4]) * 0.25) - h,\n                ((border[7] + border[4]) * 0.5) - h,\n                ((border[8] + border[7] + border[5] + border[4]) * 0.25) - h\n            ];\n\n            mnode.border2 = border2;\n        }\n\n        if (!skip) {\n            mnode.borderReady = true;\n        }\n\n        if (onlySetBorderData) {\n            return;\n        }\n\n        if (joinGrids) {\n            var cornerTable = tileCornerTable;\n            var nodeTable = this.nodeTable;\n\n            if (!nodeTable) {\n                nodeTable = new Array(9);\n                this.nodeTable = nodeTable;\n            }\n\n            //get bodrer nodes\n            for (i = 0, li = borderTable.length; i < li; i++) {\n                if (i != 4) {\n                    nodeTable[i] = tree.getRenderedNodeById([id[0], id[1] + borderTable[i][0], id[2] + borderTable[i][1]], draw.drawCounter);\n                }\n            }\n\n            var border3 = mnode.border3;\n\n            if (!border3) {\n                border3 = new Array(9);\n                mnode.border3 = border3;\n            }\n\n            //solve corners\n            for (i = 0, li = cornerTable.length; i < li; i++) {\n                var lowestNode = nodeTable[cornerTable[i][0]];\n\n                for (var j = 1; j < 3; j++) {\n                    n = nodeTable[cornerTable[i][j]];\n\n                    if (n) {\n                        if (lowestNode) {\n                            if (n.id[0] < lowestNode.id[0]) {\n                                lowestNode = n;\n                            } \n                        } else {\n                            lowestNode = n;\n                        }\n                    }\n                }\n\n                nodeTable[cornerTable[i][0]] = lowestNode;\n            }\n\n            for (i = 0, li = borderTable.length; i < li; i++) {\n                n = nodeTable[i];\n\n                if (i != 4 && (n && n.id[0] < id[0])) {\n                    var bcoords;\n\n                    switch(i) {\n                        case 0:  bcoords = [mnode.llx, mnode.lly]; break;\n                        case 1:  bcoords = [(mnode.urx+mnode.llx)*0.5, mnode.lly]; break;\n                        case 2:  bcoords = [mnode.urx, mnode.lly]; break;\n                        \n                        case 3:  bcoords = [mnode.llx, (mnode.ury+mnode.lly)*0.5]; break;\n                        case 5:  bcoords = [mnode.urx, (mnode.ury+mnode.lly)*0.5]; break;\n\n                        case 6:  bcoords = [mnode.llx, mnode.ury]; break;\n                        case 7:  bcoords = [(mnode.urx+mnode.llx)*0.5, mnode.ury]; break;\n                        case 8:  bcoords = [mnode.urx, mnode.ury]; break;\n                    }\n\n                    if (!n.border2) {\n                        n.tile.drawGrid(cameraPos, divNode, angle, true);\n                    }\n\n                    if (n.border2) {\n                        mnode.border3[i] = (n.getGridHeight(bcoords, n.border2, 3) + (useSurrogatez ? n.surrogatez : n.minZ))  - h; \n                    } else {\n                        border2[i];\n                    }\n                } else {\n                    mnode.border3[i] = border2[i];\n                }\n            }\n        }                     \n    }\n\n    var renderer = map.renderer;\n    var mv = renderer.camera.getModelviewMatrix();\n    var proj = renderer.camera.getProjectionMatrix();\n\n    if (gridPoints) {\n        buffer[0] = gridPoints[0] - sx;\n        buffer[1] = gridPoints[1] - sy;\n        buffer[2] = gridPoints[2] - sz;\n        \n        buffer[3] = gridPoints[3] - sx;\n        buffer[4] = gridPoints[4] - sy;\n        buffer[5] = gridPoints[5] - sz;\n\n        buffer[6] = gridPoints[6] - sx;\n        buffer[7] = gridPoints[7] - sy;\n        buffer[8] = gridPoints[8] - sz;\n\n        buffer[9] = gridPoints[9] - sx;\n        buffer[10] = gridPoints[10] - sy;\n        buffer[11] = gridPoints[11] - sz;\n                \n        buffer[12] = gridPoints[12] - sx;\n        buffer[13] = gridPoints[13] - sy;\n        buffer[14] = gridPoints[14] - sz;\n                \n        buffer[15] = gridPoints[15] - sx;\n        buffer[16] = gridPoints[16] - sy;\n        buffer[17] = gridPoints[17] - sz;\n            \n        buffer[18] = gridPoints[18] - sx;\n        buffer[19] = gridPoints[19] - sy;\n        buffer[20] = gridPoints[20] - sz;\n        \n        buffer[21] = gridPoints[21] - sx;\n        buffer[22] = gridPoints[22] - sy;\n        buffer[23] = gridPoints[23] - sz;\n        \n        buffer[24] = gridPoints[24] - sx;\n        buffer[25] = gridPoints[25] - sy;\n        buffer[26] = gridPoints[26] - sz;\n    }\n\n    if (hasPoles && !map.poleRadius && node.id[0] == 1 && !node.isPole) {\n        var p = node.getPhysicalCoords([node.extents.ur[0], node.extents.ur[1], 0]);\n        map.poleRadius = Math.sqrt(p[0]*p[0]+p[1]*p[1]); \n        map.poleRadiusFactor = 8 * Math.pow(2.0, 552058 / map.poleRadius); \n    }\n\n    factor = 1;\n\n    var useTexture = (map.config.mapGridTextureLayer != '');\n\n    if (useTexture) {\n        if (!this.gridTexture) {\n\n            var layer = map.boundLayers[map.config.mapGridTextureLayer];\n            var sourceTile = this;\n\n            if (!layer || sourceTile < layer.lodRange[0]) {\n                useTexture = false;\n            } else {\n                var sourceLod = math.clamp(sourceTile.id[0] - map.config.mapGridTextureLevel, layer.lodRange[0], layer.lodRange[3]);\n\n                while (sourceTile.id[0] > sourceLod) {\n                    sourceTile = sourceTile.parent;\n                }\n\n                //(path, type, extraBound, extraInfo, tile, internal)\n                this.gridTexture = this.resources.getTexture(\"gmap#\"+map.config.mapGridTextureLayer, null, {sourceTile: sourceTile, layer:layer, tile: this }, null, null, null);\n                //this.gridTexture.isReady(false, 0, false);\n            }\n\n        }\n\n        if (useTexture && !this.gridTexture.isReady(false, 0, false)) {  //TODO: set params with max priority\n            useTexture = false;       \n        }     \n    }\n\n    var hitmapRender = renderer.onlyDepth;\n\n    if (hasPoles && node.isPole) {\n        factor = map.poleRadiusFactor; \n        prog = hitmapRender ? renderer.progPlane2D :renderer.progPlane2; \n        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        prog.setVec4('uParams4', [-sx, -sy, map.poleRadius, 0]);\n    } else {\n\n        if (!flatGrid) {\n            prog = hitmapRender ? renderer.progPlane3D : renderer.progPlane3; \n            renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n\n            var border;\n\n            if (joinGrids) {\n                border =  mnode.border3;\n            } else {\n                border = mnode.border2;\n            }\n\n            prog.setFloatArray('uHeights', border);\n            prog.setVec3('uVector', mnode.diskNormal);\n\n        } else {\n            prog = hitmapRender ? renderer.progPlane : renderer.progPlane; \n            renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        }\n    }\n\n    prog.setMat4('uMV', mv);\n    prog.setMat4('uProj', proj);\n    prog.setFloatArray('uPoints', buffer);\n    \n    /*\n    var lx = (ur[0] - ll[0]);\n    var ly = (ll[1] - ur[1]);\n    var px = (ll[0] - node.extents.ll[0]) / lx;\n    var py = (ur[1] - node.extents.ll[1]) / ly;\n    \n    var llx = (node.extents.ur[0] - node.extents.ll[0]) / lx;\n    var lly = (node.extents.ur[1] - node.extents.ll[1]) / ly;\n\n    px = px / llx;\n    py = py / lly;\n    llx = 1.0/llx;\n    lly = 1.0/lly;\n    \n    llx *= step1;\n    lly *= step1;\n    px *= step1;\n    py *= step1;\n    */\n\n    var step1 = node.gridStep1 * factor;\n\n    var lx = 1.0 / (ur[0] - ll[0]);\n    var ly = 1.0 / (ll[1] - ur[1]);\n    var llx = step1 / ((node.extents.ur[0] - node.extents.ll[0]) * lx);\n    var lly = step1 / ((node.extents.ur[1] - node.extents.ll[1]) * ly);\n    var px = (ll[0] - node.extents.ll[0]) * lx * llx;\n    var py = (ur[1] - node.extents.ll[1]) * ly * lly;\n\n\n    if (useTexture) {\n        renderer.gpu.bindTexture(this.gridTexture.getGpuTexture());\n        prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/15, node.gridStep2 * factor]);\n\n        var tt = this.gridTexture.getTransform();\n\n//        prog.setVec4('uParams3', [tt[2], tt[3]+tt[1], tt[0], tt[1]]);\n        prog.setVec4('uParams3', [tt[2], tt[3], tt[0], tt[1]]);\n\n        //prog.setVec4('uParams3', [(py - Math.floor(py)), (px - Math.floor(px)), lly*0.5, llx*0.5]);\n        prog.setVec4('uParams2', [0, 0, 0, 0]);\n    } else {\n        renderer.gpu.bindTexture(renderer.heightmapTexture);       \n        prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/15, node.gridStep2 * factor]);\n        prog.setVec4('uParams3', [(py - Math.floor(py)), (px - Math.floor(px)), lly, llx]);\n        prog.setVec4('uParams2', [0, 0, node.gridBlend, 0]);\n    }\n    \n    prog.setVec4('uFogColor', draw.atmoColor);\n\n    //draw bbox\n    renderer.planeMesh.draw(prog, 'aPosition', 'aTexCoord');    \n\n    this.map.stats.drawnFaces += renderer.planeMesh.polygons;\n}; \n\n\nMapSurfaceTile.prototype.drawHmapTile = function(cameraPos, divNode, angle, pipeline, texture) {\n    //if ((this.texelSize == Number.POSITIVE_INFINITY || this.texelSize > 4.4) && this.metanode && this.metanode.hasChildren()) {\n      //  return;\n    //}\n    \n    if (!this.metanode) {\n        return;\n    }\n\n    var map = this.map, node, ll, ur, res;\n    var renderer = map.renderer;\n\n    if (!renderer.progHmapPlane) {\n        renderer.initProceduralShaders();\n    }\n\n    if (divNode) {\n        node = divNode[0]; \n        ll = divNode[1][0];\n        ur = divNode[1][1];\n    } else {\n        res = map.measure.getSpatialDivisionNodeAndExtents(this.id);\n        node = res[0]; \n        ll = res[1][0];\n        ur = res[1][1];\n    }\n   \n    var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5];\n    var hasPoles = map.referenceFrame.hasPoles;\n    angle = angle || this.metanode.diskAngle2;\n    \n    if ((hasPoles && !node.isPole) &&  Math.acos(angle) > Math.PI*0.1) {\n        angle = Math.cos(Math.acos(angle) * 0.5); \n        \n        this.drawHmapTile(cameraPos, [node, [ [ll[0], ll[1]],  [middle[0], middle[1]] ] ], angle);\n        this.drawHmapTile(cameraPos, [node, [ [middle[0], ll[1]],  [ur[0], middle[1]] ] ], angle);\n\n        this.drawHmapTile(cameraPos, [node, [ [ll[0], middle[1]],  [middle[0], ur[1]] ] ], angle);\n        this.drawHmapTile(cameraPos, [node, [ [middle[0], middle[1]],  [ur[0], ur[1]] ] ], angle);\n       \n        return;\n    }\n     \n    var desiredSamplesPerViewExtent = 5;\n    var nodeExtent = node.extents.ur[1] - node.extents.ll[1];\n    var viewExtent = this.distance ;//* 0.1;\n    var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / map.log2;\n    lod = Math.max(0,lod - 8 + node.id[0]);\n   \n    var h, factor, prog, draw = map.draw; \n\n    var sx = cameraPos[0];\n    var sx = cameraPos[0];\n    var sy = cameraPos[1];\n    var sz = cameraPos[2];\n    var buffer = draw.planeBuffer;\n    var gridPoints = this.gridPoints;\n    var useSurrogatez = map.config.mapGridSurrogatez;\n\n    if (!gridPoints) {\n\n//        h = this.metanode.minZ;\n        h = 0;//this.metanode.minHeight;\n        var n1 = node.getPhysicalCoords([ur[0], ur[1], h], true);\n        var n2 = node.getPhysicalCoords([ur[0], ll[1], h], true);\n        var n3 = node.getPhysicalCoords([ll[0], ll[1], h], true);\n        var n4 = node.getPhysicalCoords([ll[0], ur[1], h], true);\n        var mtop = node.getPhysicalCoords([middle[0], ur[1], h], true);\n        var mbottom = node.getPhysicalCoords([middle[0], ll[1], h], true);\n        var mleft = node.getPhysicalCoords([ll[0], middle[1], h], true);\n        var mright = node.getPhysicalCoords([ur[0], middle[1], h], true);\n\n        middle[2] = h;\n        middle = node.getPhysicalCoords(middle, true);\n\n        if (!divNode) {\n\n            var gridPoints = [\n                n4[0], n4[1], n4[2],\n                mtop[0], mtop[1], mtop[2],\n                n1[0], n1[1], n1[2],\n\n                mleft[0], mleft[1], mleft[2],\n                middle[0], middle[1], middle[2],\n                mright[0], mright[1], mright[2],\n                \n                n3[0], n3[1], n3[2],\n                mbottom[0], mbottom[1], mbottom[2],\n                n2[0], n2[1], n2[2]\n            ];\n\n            this.gridPoints = gridPoints;\n\n        } else {\n            buffer[0] = n4[0] - sx;\n            buffer[1] = n4[1] - sy;\n            buffer[2] = n4[2] - sz;\n            \n            buffer[3] = mtop[0] - sx;\n            buffer[4] = mtop[1] - sy;\n            buffer[5] = mtop[2] - sz;\n\n            buffer[6] = n1[0] - sx;\n            buffer[7] = n1[1] - sy;\n            buffer[8] = n1[2] - sz;\n\n            buffer[9] = mleft[0] - sx;\n            buffer[10] = mleft[1] - sy;\n            buffer[11] = mleft[2] - sz;\n                    \n            buffer[12] = middle[0] - sx;\n            buffer[13] = middle[1] - sy;\n            buffer[14] = middle[2] - sz;\n                    \n            buffer[15] = mright[0] - sx;\n            buffer[16] = mright[1] - sy;\n            buffer[17] = mright[2] - sz;\n                \n            buffer[18] = n3[0] - sx;\n            buffer[19] = n3[1] - sy;\n            buffer[20] = n3[2] - sz;\n            \n            buffer[21] = mbottom[0] - sx;\n            buffer[22] = mbottom[1] - sy;\n            buffer[23] = mbottom[2] - sz;\n            \n            buffer[24] = n2[0] - sx;\n            buffer[25] = n2[1] - sy;\n            buffer[26] = n2[2] - sz;\n        }\n     }\n\n    var mv = renderer.camera.getModelviewMatrix();\n    var proj = renderer.camera.getProjectionMatrix();\n\n    if (gridPoints) {\n        buffer[0] = gridPoints[0] - sx;\n        buffer[1] = gridPoints[1] - sy;\n        buffer[2] = gridPoints[2] - sz;\n        \n        buffer[3] = gridPoints[3] - sx;\n        buffer[4] = gridPoints[4] - sy;\n        buffer[5] = gridPoints[5] - sz;\n\n        buffer[6] = gridPoints[6] - sx;\n        buffer[7] = gridPoints[7] - sy;\n        buffer[8] = gridPoints[8] - sz;\n\n        buffer[9] = gridPoints[9] - sx;\n        buffer[10] = gridPoints[10] - sy;\n        buffer[11] = gridPoints[11] - sz;\n                \n        buffer[12] = gridPoints[12] - sx;\n        buffer[13] = gridPoints[13] - sy;\n        buffer[14] = gridPoints[14] - sz;\n                \n        buffer[15] = gridPoints[15] - sx;\n        buffer[16] = gridPoints[16] - sy;\n        buffer[17] = gridPoints[17] - sz;\n            \n        buffer[18] = gridPoints[18] - sx;\n        buffer[19] = gridPoints[19] - sy;\n        buffer[20] = gridPoints[20] - sz;\n        \n        buffer[21] = gridPoints[21] - sx;\n        buffer[22] = gridPoints[22] - sy;\n        buffer[23] = gridPoints[23] - sz;\n        \n        buffer[24] = gridPoints[24] - sx;\n        buffer[25] = gridPoints[25] - sy;\n        buffer[26] = gridPoints[26] - sz;\n    }\n\n    if (hasPoles && !map.poleRadius && node.id[0] == 1 && !node.isPole) {\n        var p = node.getPhysicalCoords([node.extents.ur[0], node.extents.ur[1], 0]);\n        map.poleRadius = Math.sqrt(p[0]*p[0]+p[1]*p[1]); \n        map.poleRadiusFactor = 8 * Math.pow(2.0, 552058 / map.poleRadius); \n    }\n\n    var mnode = this.metanode; \n    var testMode = draw.debug.drawTestMode;\n\n    factor = 1;\n\n    if (hasPoles && node.isPole) {\n        factor = map.poleRadiusFactor; \n        prog = renderer.progPlane2; \n        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        prog.setVec4('uParams4', [-sx, -sy, map.poleRadius, 0]);\n    } else {\n\n        switch(testMode) {\n            default:\n            case 0: prog = renderer.progHmapPlane; break;\n            case 1: prog = renderer.progHmapPlane2; break;\n            case 2: prog = renderer.progHmapPlane5; break;\n            case 3: prog = renderer.progHmapPlane6; break;\n            case 4: prog = renderer.progHmapPlane7; break;\n\n            case 8: prog = renderer.progHmapPlane4; break;\n            case 9: prog = pipeline == 1 ? renderer.progHmapPlane3 : renderer.progHmapPlane8; break;\n        }\n\n\n        if (testMode == 3 || testMode == 4) {\n            if (!renderer.ntextures) {\n                renderer.ntextures = [ \n                    new GpuTexture(renderer.gpu, './textures/test/test001.png', renderer.core, null), //0\n                    new GpuTexture(renderer.gpu, './textures/test/test002.png', renderer.core, null), //1\n                    new GpuTexture(renderer.gpu, './textures/test003.jpg', renderer.core, null),      //2\n                    new GpuTexture(renderer.gpu, './textures/download.png', renderer.core, null),     //3\n                    new GpuTexture(renderer.gpu, './textures/test009.jpg', renderer.core, null),      //4\n                    new GpuTexture(renderer.gpu, './textures/test004.jpg', renderer.core, null),      //5\n                    new GpuTexture(renderer.gpu, './textures/test005.jpg', renderer.core, null),      //6\n                    new GpuTexture(renderer.gpu, './textures/nor_sand.jpg', renderer.core, null),     //7\n                    new GpuTexture(renderer.gpu, './textures/test007.jpg', renderer.core, null),      //8\n                    new GpuTexture(renderer.gpu, './textures/test008.jpg', renderer.core, null),      //9\n\n                    new GpuTexture(renderer.gpu, './textures/download (1).png', renderer.core, null),  //10\n                    new GpuTexture(renderer.gpu, './textures/test010.jpg', renderer.core, null),      //11\n                    new GpuTexture(renderer.gpu, './textures/test011.jpg', renderer.core, null),      //12\n                    new GpuTexture(renderer.gpu, './textures/test012.jpg', renderer.core, null),      //13\n                    new GpuTexture(renderer.gpu, './textures/test013.jpg', renderer.core, null),      //14\n                    new GpuTexture(renderer.gpu, './textures/test014.jpg', renderer.core, null),      //15\n                    new GpuTexture(renderer.gpu, './textures/test015.jpg', renderer.core, null),      //16\n                    new GpuTexture(renderer.gpu, './textures/test016.jpg', renderer.core, null),      //17\n                    new GpuTexture(renderer.gpu, './textures/test017.jpg', renderer.core, null),      //18\n                    new GpuTexture(renderer.gpu, './textures/test018.jpg', renderer.core, null)      //18\n\n                    ];\n            }\n        }\n\n//        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aBarycentric']);\n        //renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        renderer.gpu.useProgram(prog, ['aPosition']);\n        prog.setVec3('uVector', mnode.diskNormal);\n\n        //prog.setVec3('uRight', mnode.diskNormal);\n\n        if (gridPoints) {\n            var vecRight = [gridPoints[15] - gridPoints[12], gridPoints[16] - gridPoints[13], gridPoints[17] - gridPoints[14]];\n            var vecTop = [gridPoints[21] - gridPoints[12], gridPoints[22] - gridPoints[13], gridPoints[23] - gridPoints[14]];\n\n            vec3.normalize(vecRight);\n            vec3.normalize(vecTop);\n\n            var vecDir = mnode.diskNormal.slice();\n            //vecDir = [-vecDir[0], -vecDir[1], -vecDir[2]];\n\n            //prog.setVec3('uRight', vecRight);\n            //prog.setVec3('uTop', vecTop);\n\n\n            var mv = map.camera.camera.modelview;\n            var mv2 = vts.mat3.create();\n\n            vts.mat4.toInverseMat3(mv, mv2);\n\n            //vts.mat4.toMat3(mv, mv2);\n            vts.mat3.transpose(mv2);\n\n            vts.mat3.multiplyVec3(mv2, vecTop);\n            vts.mat3.multiplyVec3(mv2, vecDir);\n            vts.mat3.multiplyVec3(mv2, vecRight);\n\n            var space = [\n                vecRight[0], vecRight[1], vecRight[2],\n                vecTop[0], vecTop[1], vecTop[2],\n                vecDir[0], vecDir[1], vecDir[2],\n            ];\n\n            /*\n            var mv3 = vts.mat3.toMat4(mv2);\n            vts.mat4.multiply(mv3, vts.mat3.toMat4(space), mv3);\n            prog.setMat3('uSpace', vts.mat4.toMat3(mv3));\n            */\n            \n            prog.setMat3('uSpace', space);\n        }\n    }\n\n    prog.setMat4('uMV', mv);\n    prog.setMat4('uProj', proj);\n    prog.setFloatArray('uPoints', buffer);\n    \n\n    var step1 = node.gridStep1 * factor;\n    prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/127, node.gridStep2 * factor]);\n\n    if (testMode >= 3 && testMode <= 4) {\n        prog.setVec4('uParams3', [1,1,0,0]);\n    } else {\n        if (texture) {\n            prog.setVec4('uParams3', texture.getTransform());\n        } else {\n            var lx = 1.0 / (ur[0] - ll[0]);\n            var ly = 1.0 / (ll[1] - ur[1]);\n            var llx = step1 / ((node.extents.ur[0] - node.extents.ll[0]) * lx);\n            var lly = step1 / ((node.extents.ur[1] - node.extents.ll[1]) * ly);\n            var px = (ll[0] - node.extents.ll[0]) * lx * llx;\n            var py = (ur[1] - node.extents.ll[1]) * ly * lly;\n\n            prog.setVec4('uParams3', [lly, llx, (py - Math.floor(py)), (px - Math.floor(px))]);\n        }\n    }\n\n    prog.setVec4('uParams2', [0, 0, node.gridBlend, 0]);\n    prog.setVec4('uFogColor', draw.atmoColor);\n\n\n    if (this.hmap.extraBound) {\n        //get height form parent\n        mnode = this.hmap.extraBound.sourceTile.metanode;\n        prog.setVec3('uHeights', [mnode.minHeight, mnode.maxHeight, (1.0/mnode.pixelSize)]);\n        prog.setVec4('uTransform', this.hmap.getTransform());\n    } else {\n        prog.setVec3('uHeights', [mnode.minHeight, mnode.maxHeight, (1.0/mnode.pixelSize)]);\n        prog.setVec4('uTransform', [1,1,0,0]);\n    }\n\n    if (testMode >= 3 && testMode <= 4) {\n        if (!renderer.ntextures[draw.debug.drawTestData].loaded) {\n            return;\n        }\n        renderer.gpu.bindTexture(renderer.ntextures[draw.debug.drawTestData]);\n    } else {\n        if (texture) {\n            renderer.gpu.bindTexture(texture.getGpuTexture());\n        } else {\n            renderer.gpu.bindTexture(renderer.heightmapTexture);\n        }\n    }\n\n    prog.setSampler('uSampler', 0);    \n\n//    if(this.hmap) {\n        renderer.gpu.bindTexture(this.hmap.getGpuTexture(), 1);\n  //  } else {\n        //renderer.gpu.bindTexture(renderer.blackTexture, 1);\n  //      renderer.gpu.bindTexture(renderer.blackTexture2, 1);\n   // }\n\n    prog.setSampler('uSampler2', 1);    \n\n    //draw bbox\n    //renderer.planeMesh2.draw(prog, 'aPosition', 'aTexCoord');    \n    renderer.planeMesh2.draw(prog, 'aPosition');    \n\n    /*\n    if (vecRight && gridPoints) {\n        //renderer.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState);\n        renderer.draw.drawLineString([[gridPoints[12], gridPoints[13], gridPoints[14]], [gridPoints[15], gridPoints[16], gridPoints[17]]], false, 4, [1,0,0,1], null, false, false, false, false);\n        renderer.draw.drawLineString([[gridPoints[12], gridPoints[13], gridPoints[14]], [gridPoints[21], gridPoints[22], gridPoints[23]]], false, 4, [0,0,1,1], null, false, false, false, false);\n\n        renderer.draw.drawLineString([[0, 0, 0], [9000000, 0, 0]], false, 4, [1,0,0,1], null, false, false, false, false);\n        renderer.draw.drawLineString([[0, 0, 0], [0, 9000000, 0, 0]], false, 4, [0,1,0,1], null, false, false, false, false);\n        renderer.draw.drawLineString([[0, 0, 0], [0, 0, 9000000]], false, 4, [0,0,1,1], null, false, false, false, false);\n    }*/\n\n\n    this.map.stats.drawnFaces += renderer.planeMesh2.polygons;\n}; \n\n\nexport default MapSurfaceTile;\n\n\n","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport MapSurfaceTile_ from './surface-tile';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar MapSurfaceTile = MapSurfaceTile_;\n\n\nvar MapSurfaceTree = function(map, freeLayer, freeLayerSurface) {\n    this.map = map;\n    this.camera = map.camera;\n    this.rootId = [0,0,0];\n    this.freeLayer = freeLayer;\n    this.freeLayerSurface = freeLayerSurface;\n    this.metaBinaryOrder = this.map.referenceFrame.params.metaBinaryOrder;\n    //this.initialized = false;\n    //this.geocent = !this.map.getNavigationSrs().isProjected();\n\n    this.surfaceTree = new MapSurfaceTile(this.map, null, this.rootId);\n\n    //if (freeLayer !== true) {\n        //this.heightTracer = new MapMetanodeTracer(this, null, this.traceTileHeight.bind(this), this.traceHeightChild.bind(this));\n        //this.heightTracerNodeOnly = new MapMetanodeTracer(this, null, this.traceTileHeightNodeOnly.bind(this), this.traceHeightChild.bind(this));\n    //}\n\n    this.surfaceSequence = [];\n    this.surfaceOnlySequence = [];\n\n    this.config = this.map.config;\n    this.cameraPos = [0,0,0];\n    this.worldPos = [0,0,0];\n    this.ndcToScreenPixel = 1.0;\n    this.counter = 0;\n};\n\n\nMapSurfaceTree.prototype.kill = function() {\n    this.surfaceTree = null;\n    this.metastorageTree = null;\n    this.surfaceTracer = null;\n    this.heightTracer = null;\n};\n\n\n/*MapSurfaceTree.prototype.init = function() {\n    var url = this.map.url.makeUrl(surface.metaUrl, {lod:result[0], ix:result[1], iy:result[2] });  //result???\n    map.loader.load(url, metatile.load.bind(metatile, url));\n\n    this.metatileTree.load();\n    this.surfaceTree.metatile = 1;\n\n    this.initialized = true;\n};*/\n\n\nMapSurfaceTree.prototype.findSurfaceTile = function(id) {\n    var tile = this.surfaceTree;\n\n//    for (var lod = 1; lod <= id[0]; lod++) {\n//        var mask = 1 << (lod-1);\n//        var index = 0;\n\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n        \n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        tile = tile.children[index];\n\n        if (!tile) {\n            return null;\n        }\n    }\n    \n    return tile;\n};\n\n\nMapSurfaceTree.prototype.findNavTile = function(id) {\n    var tile = this.surfaceTree;\n    \n    if (id[0] == 0) {\n        if (tile.metanode && tile.metanode.hasNavtile()) {\n            return tile;\n        } else {\n            return null;\n        }\n    }\n    \n    var navtile = null;\n\n//    for (var lod = 1; lod <= id[0]; lod++) {\n//        var mask = 1 << (id[0] - lod);\n//        var index = 0;\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        tile = tile.children[index];\n\n        if (!tile) {\n            return navtile;\n        } else {\n            if (tile.metanode && tile.metanode.hasNavtile()) {\n                navtile = tile;\n            }\n        }\n    }\n    \n    return navtile;\n};\n\n\nMapSurfaceTree.prototype.draw = function(storeTilesOnly) {\n    this.cameraPos = [0,0,0];\n    this.worldPos = [0,0,0];\n\n    var map = this.map;\n    var draw = map.draw;\n    this.ndcToScreenPixel = draw.ndcToScreenPixel;\n    \n    var srs = map.getPhysicalSrs();\n\n    //var divisionNode = this.divisionNode;\n    var periodicity = srs.periodicity;\n\n    //if (this.map.config.mapBasicTileSequence) {\n        //this.surfaceTracer = this.surfaceTracerBasic;\n    //}\n    \n    if (this.freeLayerSurface && this.freeLayerSurface.geodata && draw.drawChannel != 0) {\n        return;\n    }\n\n    if (periodicity != null) {\n        this.drawSurface([0,0,0]);\n\n        if (periodicity.type == 'X') {\n            this.drawSurface([periodicity.period,0,0], storeTilesOnly);\n            this.drawSurface([-periodicity.period,0,0], storeTilesOnly);\n        }\n\n    } else {\n        var mode;\n\n        if (this.freeLayerSurface && this.freeLayerSurface.geodata) {\n            mode = map.config.mapGeodataLoadMode; \n        } else {\n            mode = map.config.mapLoadMode; \n        }\n\n        switch(mode) {\n        case 'topdown':\n\n            if (map.config.mapSplitMeshes) {\n                this.drawSurfaceWithSpliting([0,0,0], storeTilesOnly);\n            } else {\n                this.drawSurface([0,0,0], storeTilesOnly);\n            }\n\n            break;\n\n        case 'downtop': this.drawSurfaceDownTop([0,0,0], storeTilesOnly); break;\n        case 'fit':     this.drawSurfaceFit([0,0,0], storeTilesOnly); break;\n        case 'fitonly': this.drawSurfaceFitOnly([0,0,0], storeTilesOnly); break;\n        }\n\n    }\n};\n\n\nMapSurfaceTree.prototype.updateNodeHeightExtents = function(tile, node) {\n    \n    if (!node.heightReady && node.metatile.useVersion < 4) {\n        var parent = tile.parent;\n\n        //if (node.hasNavtile()) {\n          //  node = node;\n        //}\n        \n        while (parent) {\n            var parentNode = parent.metanode;  \n            if (parentNode.hasNavtile()) {\n\n                //if (node.hasNavtile()) {\n                  //  node = node;\n                //}\n\n                node.minHeight = parentNode.minHeight;\n                node.maxHeight = parentNode.maxHeight;\n                node.minZ = parentNode.minZ;\n                node.maxZ = parentNode.maxZ;\n                node.minZ2 = parentNode.minZ2;\n                node.maxZ2 = parentNode.maxZ2;\n                node.generateCullingHelpers();\n                break;\n            }\n            \n            parent = parent.parent;\n        }\n\n        node.heightReady = true;\n    }\n};\n\n\nMapSurfaceTree.prototype.logTileInfo = function(tile, node, cameraPos) {\n    if (!tile || !node) {\n        return;\n    }\n    \n    var visible = tile.bboxVisible(tile.id, node.bbox, cameraPos, node);\n    tile.updateTexelSize();\n    \n    // eslint-disable-next-line\n    console.log('tile: ' + JSON.stringify(tile.id) + ' visible: ' + visible + ' texelsize: ' +  tile.texelSize + ' center: '  + JSON.stringify(node.diskPos) + ' vec: ' + node.diskNormal + 'ang: ' + node.diskAngle + ' dist: ' + node.diskDistance);\n};\n\n\n//loadmode = topdown\nMapSurfaceTree.prototype.drawSurface = function(shift, storeTilesOnly) {\n    this.counter++;\n\n    var tile = this.surfaceTree;\n    \n    if (!tile.isMetanodeReady(this, 0)) {\n        return;\n    }\n    \n    var map = this.map;\n    var node = tile.metanode;\n    var cameraPos = map.camera.position;\n\n    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n        return;\n    }\n\n    tile.updateTexelSize();\n    \n    var typeFactor = this.freeLayerSurface ? 1 : 1;\n\n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var drawBuffer = draw.drawBuffer;\n    var processBuffer = draw.processBuffer;\n    var newProcessBuffer = draw.processBuffer2;\n    var drawBufferIndex = 0;\n    var processBufferIndex = 0;\n    var newProcessBufferIndex = 0;\n    var gpuNeeded = 0;\n    var gpuNeededForRender = 0;\n    var size = 0;\n    \n    processBuffer[0] = tile;\n    processBufferIndex = 1;\n   \n    var texelSizeFit = draw.texelSizeFit;\n\n    var best2 = 0;\n    var replay = draw.replay;\n    var storeNodes = replay.storeNodes || replay.storeFreeNodes;\n    var storeNodesBuffer = replay.nodeBuffer; \n   \n    draw.drawCounter++;\n    \n    var pocessedNodes = 1;\n    var pocessedMetatiles = 1;  \n    var usedNodes = 1;\n    var drawCounter = draw.drawCounter, i, j, lj;\n\n\n    do {\n        var best = 0;\n        newProcessBufferIndex = 0;\n        \n        for (i = processBufferIndex - 1; i >= 0; i--) {\n            tile = processBuffer[i];\n            node = tile.metanode;\n\n            if (node) {\n                pocessedNodes++;\n                if (node.metatile.drawCounter != drawCounter) {\n                    node.metatile.drawCounter = drawCounter;\n                    pocessedMetatiles++;\n                }\n            }\n            \n            //if (this.map.drawIndices) {\n              //  this.logTileInfo(tile, node, cameraPos);\n            //}\n\n            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n\n                usedNodes++;\n\n                if (tile.texelSize != Number.POSITIVE_INFINITY){\n                    if (tile.texelSize > best) {\n                        best = tile.texelSize;\n                    }\n                }\n                \n                if (storeNodes) { //used only for inspector\n                    storeNodesBuffer.push(tile);\n                }\n              \n                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit /*|| gpuNeeded > gpuMax*/) {\n                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);\n\n                    gpuNeeded += size;\n                    gpuNeededForRender += size;\n\n                    tile.drawCounter = draw.drawCounter;\n                    drawBuffer[drawBufferIndex] = tile;\n                    drawBufferIndex++;\n                    \n                } else { //go deeper\n                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);\n                    gpuNeeded += size;\n\n                    var childrenCount = 0;\n                    var readyCount = 0;\n                    var childrenBuffer = [];\n                    \n                    for (j = 0; j < 4; j++) {\n                        var child = tile.children[j];\n                        if (child) {\n                            childrenCount++;\n       \n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                var factor = 1;\n\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize(factor);\n                                \n                                var priority = child.id[0] * typeFactor * child.distance;\n                                \n                                if (!tile.surface || !child.metanode.hasGeometry()) {\n\n                                    readyCount++;\n                                    //child.updateTexelSize();\n                                    childrenBuffer.push(child);\n                                    \n                                } else {\n\n                                    //are draw buffers ready? preventRender=true, preventLoad=false, doNotCheckGpu=true\n                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, true)) {\n                                        \n                                        readyCount++;\n                                        //child.updateTexelSize();\n                                        childrenBuffer.push(child);\n                                    }\n                                    \n                                }\n                            }\n                        }\n                    }\n        \n                    if (/*!(gpuNeeded > gpuMax) &&*/ childrenCount > 0 && childrenCount == readyCount) {\n                        //sort children by distance\n    \n                        do {\n                            var sorted = true;\n                            \n                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {\n                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {\n                                    var t = childrenBuffer[j];\n                                    childrenBuffer[j] = childrenBuffer[j+1];\n                                    childrenBuffer[j+1] = t;\n                                    sorted = false;\n                                } \n                            }\n                            \n                        } while(!sorted);\n    \n    \n                        //add children to new process buffer \n                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {\n                            \n                            /*var n = childrenBuffer[j].metanode.divisionNode;\n                            if ((n.id[0] == 1 && n.id[1] == 1 && n.id[2] == 0)) {*/\n                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];\n                            newProcessBufferIndex++;\n                            /*}*/\n                            \n                        }\n                    } else {\n                        gpuNeededForRender += size;\n\n                        tile.drawCounter = draw.drawCounter;\n                        drawBuffer[drawBufferIndex] = tile;\n                        drawBufferIndex++;\n                    }\n                    \n                }\n            }\n        }\n\n        var tmp = processBuffer;\n        processBuffer = newProcessBuffer;\n        newProcessBuffer = tmp;\n        processBufferIndex = newProcessBufferIndex;\n\n    } while(processBufferIndex > 0);\n\n    if (storeTilesOnly) {\n        this.storeDrawBufferGeometry(drawBufferIndex);\n        return;\n    }\n    \n    if (best2 > draw.bestMeshTexelSize) {\n        draw.bestMeshTexelSize = best2;\n    }\n\n    var stats = map.stats;\n\n    stats.usedNodes = usedNodes;    \n    stats.processedNodes = pocessedNodes;    \n    stats.processedMetatiles = pocessedMetatiles;    \n    stats.gpuNeeded = gpuNeeded;    \n    \n    //console.log(\"texel: \"+ this.map.bestMeshTexelSize);\n    //console.log(\"more: \"+ more + \"more2: \" + more2);\n\n    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);\n};\n\n\n//loadmode = topdown + split\nMapSurfaceTree.prototype.drawSurfaceWithSpliting = function(shift, storeTilesOnly) {\n    this.counter++;\n\n    var tile = this.surfaceTree;\n    \n    if (!tile.isMetanodeReady(this, 0)) {\n        return;\n    }\n    \n    var map = this.map;\n    var node = tile.metanode;\n    var cameraPos = map.camera.position;\n\n    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n        return;\n    }\n\n    tile.updateTexelSize();\n    \n    var typeFactor = this.freeLayerSurface ? 1 : 1;\n\n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var drawBuffer = draw.drawBuffer;\n    var processBuffer = draw.processBuffer;\n    var newProcessBuffer = draw.processBuffer2;\n    var drawBufferIndex = 0;\n    var processBufferIndex = 0;\n    var newProcessBufferIndex = 0;\n    var gpuNeeded = 0;\n    var gpuNeededForRender = 0;\n    var size = 0;\n    \n    processBuffer[0] = tile;\n    processBufferIndex = 1;\n   \n    var texelSizeFit = draw.texelSizeFit;\n\n    var best2 = 0;\n    var replay = draw.replay;\n    var storeNodes = replay.storeNodes || replay.storeFreeNodes;\n    var storeNodesBuffer = replay.nodeBuffer; \n   \n    draw.drawCounter++;\n    \n    var pocessedNodes = 1;\n    var pocessedMetatiles = 1;  \n    var usedNodes = 1;\n    var drawCounter = draw.drawCounter, i, j, lj;\n\n\n    do {\n        var best = 0;\n        newProcessBufferIndex = 0;\n        \n        for (i = processBufferIndex - 1; i >= 0; i--) {\n            tile = processBuffer[i];\n            node = tile.metanode;\n\n            if (node) {\n                pocessedNodes++;\n                if (node.metatile.drawCounter != drawCounter) {\n                    node.metatile.drawCounter = drawCounter;\n                    pocessedMetatiles++;\n                }\n            }\n            \n            //if (this.map.drawIndices) {\n              //  this.logTileInfo(tile, node, cameraPos);\n            //}\n\n            tile.splitMask = null;\n            //tile.splitMask = [0,0,0,1];\n\n            if (tile.visibleCounter == drawCounter || tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n\n                usedNodes++;\n\n                if (tile.texelSize != Number.POSITIVE_INFINITY){\n                    if (tile.texelSize > best) {\n                        best = tile.texelSize;\n                    }\n                }\n                \n                if (storeNodes) { //used only for inspector\n                    storeNodesBuffer.push(tile);\n                }\n              \n                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit /*|| gpuNeeded > gpuMax*/) {\n\n                    if (tile.skipRenderCounter != drawCounter) {\n\n                        size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);\n\n                        gpuNeeded += size;\n                        gpuNeededForRender += size;\n\n                        //if (tile.parent && tile.parent.children[3] == tile) {\n                            tile.drawCounter = drawCounter;\n                            drawBuffer[drawBufferIndex] = tile;\n                            drawBufferIndex++;\n                        //}\n                    }\n                    \n                } else { //go deeper\n                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);\n                    gpuNeeded += size;\n\n                    var childrenCount = 0;\n                    var childrenBuffer = [];\n                    var mask = [1,1,1,1];\n                    var useMask = false;\n                    \n                    for (j = 0; j < 4; j++) {\n                        var child = tile.children[j];\n                        if (child) {\n                            childrenCount++;\n                            child.skipRenderCounter = tile.skipRenderCounter;\n       \n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                var factor = 1;\n\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize(factor);\n\n                                if (child.bboxVisible(child.id, child.metanode.bbox, cameraPos, child.metanode)) {\n                                    child.visibleCounter = draw.drawCounter;\n                                } else {\n                                    continue;\n                                }\n                                \n                                var priority = child.id[0] * typeFactor * child.distance;\n                                \n                                if (!tile.surface || !child.metanode.hasGeometry()) {\n                                    childrenBuffer.push(child);\n                                } else {\n                                    //are draw buffers ready? preventRender=true, preventLoad=false, doNotCheckGpu=true\n                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, true)) {\n                                        childrenBuffer.push(child);\n                                        mask[j] = 0;\n                                    } else {\n                                        childrenBuffer.push(child);\n                                        child.skipRenderCounter = drawCounter;\n                                        useMask = true;\n                                    }\n                                }\n\n                            } else {\n                                //mask[j] = 0;\n                                useMask = true;\n                            }\n                        }\n                    }\n        \n                    if (childrenBuffer.length > 0) {\n                        //sort children by distance\n    \n                        do {\n                            var sorted = true;\n                            \n                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {\n                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {\n                                    var t = childrenBuffer[j];\n                                    childrenBuffer[j] = childrenBuffer[j+1];\n                                    childrenBuffer[j+1] = t;\n                                    sorted = false;\n                                } \n                            }\n                            \n                        } while(!sorted);\n    \n    \n                        //add children to new process buffer \n                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {\n                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];\n                            newProcessBufferIndex++;\n                        }\n                    }\n\n                    if (childrenCount == 0 || useMask) {\n\n                        //if (tile.parent && tile.parent.children[3] == tile) {\n\n                        if (tile.skipRenderCounter != drawCounter) {\n                            gpuNeededForRender += size;\n                            tile.splitMask = useMask ? mask : null;\n                            tile.drawCounter = drawCounter;\n\n                            drawBuffer[drawBufferIndex] = tile;\n                            drawBufferIndex++;\n                        }\n\n                        //}\n                    }\n\n                    \n                }\n            }\n        }\n\n        var tmp = processBuffer;\n        processBuffer = newProcessBuffer;\n        newProcessBuffer = tmp;\n        processBufferIndex = newProcessBufferIndex;\n\n    } while(processBufferIndex > 0);\n\n    if (storeTilesOnly) {\n        this.storeDrawBufferGeometry(drawBufferIndex);\n        return;\n    }\n    \n    if (best2 > draw.bestMeshTexelSize) {\n        draw.bestMeshTexelSize = best2;\n    }\n\n    var stats = map.stats;\n\n    stats.usedNodes = usedNodes;    \n    stats.processedNodes = pocessedNodes;    \n    stats.processedMetatiles = pocessedMetatiles;    \n    stats.gpuNeeded = gpuNeeded;    \n    \n    //console.log(\"texel: \"+ this.map.bestMeshTexelSize);\n    //console.log(\"more: \"+ more + \"more2: \" + more2);\n\n    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);\n};\n\n\n//loadmode = fitonly\nMapSurfaceTree.prototype.drawSurfaceFitOnly = function(shift, storeTilesOnly, useDrawBufferOnly) {\n    this.counter++;\n//    this.surfaceTracer.trace(this.surfaceTree);//this.rootId);\n\n    var tile = this.surfaceTree;\n    \n    if (!tile.isMetanodeReady(this, 0)) {\n        return;\n    }\n    \n    var map = this.map;\n    var node = tile.metanode;\n    var cameraPos = map.camera.position;\n\n    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n        return;\n    }\n\n    tile.updateTexelSize();\n    \n    //var typeFactor = this.freeLayerSurface ? 1 : 1;\n    \n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var drawBuffer = draw.drawBuffer;\n    var processBuffer = draw.processBuffer;\n    var newProcessBuffer = draw.processBuffer2;\n    var drawBufferIndex = 0;\n    var processBufferIndex = 0;\n    var newProcessBufferIndex = 0;\n    \n    processBuffer[0] = tile;\n    processBufferIndex = 1;\n\n    var texelSizeFit = draw.texelSizeFit;\n\n    var replay = map.draw.replay;\n    var storeNodes = replay.storeNodes || replay.storeFreeNodes;\n    var storeNodesBuffer = replay.nodeBuffer; \n\n    draw.drawCounter++;\n    \n    var usedNodes = 1;\n    var pocessedNodes = 1;\n    var pocessedMetatiles = 1;  \n    var drawCounter = draw.drawCounter, i, j, lj;\n    var grids = false; \n    \n    do {\n        var best = 0;\n        newProcessBufferIndex = 0;\n       \n        for (i = processBufferIndex - 1; i >= 0; i--) {\n            tile = processBuffer[i];\n            node = tile.metanode;\n\n            if (node) {\n                pocessedNodes++;\n                if (node.metatile.drawCounter != drawCounter) {\n                    node.metatile.drawCounter = drawCounter;\n                    pocessedMetatiles++;\n                }\n            }\n\n            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n\n                usedNodes++;\n\n                if (storeNodes) { //used only for inspector\n                    storeNodesBuffer.push(tile);\n                }\n\n                if (tile.texelSize  != Number.POSITIVE_INFINITY){\n                    if (tile.texelSize > best) {\n                        best = tile.texelSize;\n                    }\n                }\n                \n                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit) {\n                   \n                    tile.drawCounter = draw.drawCounter;\n                    drawBuffer[drawBufferIndex] = tile;\n                    drawBufferIndex++;\n                    \n                } else { //go deeper\n\n                    var childrenCount = 0;\n                    var nodesReadyCount = 0;\n                    var childrenBuffer = [];\n        \n                    for (j = 0; j < 4; j++) {\n                        var child = tile.children[j];\n                        if (child) {\n                            childrenCount++;\n       \n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize();\n\n                                childrenBuffer.push(child);\n                                nodesReadyCount++;\n\n                            } /*else if (useDrawBufferOnly) { //used in downtop\n                                //drawBuffer[drawBufferIndex] = [child, true];\n                                //drawBufferIndex++;\n                            }*/\n                        }\n                    }\n        \n                    if (childrenCount > 0 && (!useDrawBufferOnly || childrenCount == nodesReadyCount)) {\n                        //sort children by distance\n    \n                        do {\n                            var sorted = true;\n                            \n                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {\n                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {\n                                    var t = childrenBuffer[j];\n                                    childrenBuffer[j] = childrenBuffer[j+1];\n                                    childrenBuffer[j+1] = t;\n                                    sorted = false;\n                                } \n                            }\n                            \n                        } while(!sorted);\n    \n                        //add childrn to new process buffer \n                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {\n\n                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];\n                            newProcessBufferIndex++;\n                        }\n                    } else {\n                        tile.drawCounter = draw.drawCounter;\n                        drawBuffer[drawBufferIndex] = tile;\n                        drawBufferIndex++;\n                    }\n                    \n                }\n            }\n        }\n        \n        var tmp = processBuffer;\n        processBuffer = newProcessBuffer;\n        newProcessBuffer = tmp;\n        processBufferIndex = newProcessBufferIndex;\n        \n    } while(processBufferIndex > 0);\n\n    if (storeTilesOnly) {\n        if (useDrawBufferOnly) {\n            var tmp = draw.drawBuffer2;\n            draw.drawBuffer2 = draw.drawBuffer;\n            draw.drawBuffer = tmp;\n            //draw.drawBufferIndex = drawBufferIndex;            \n        } else {\n            this.storeDrawBufferGeometry(drawBufferIndex);\n        }\n        return drawBufferIndex;\n    }\n\n    var stats = map.stats;\n\n    stats.usedNodes = usedNodes;    \n    stats.processedNodes = pocessedNodes;    \n    stats.processedMetatiles = pocessedMetatiles;    \n\n    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);\n};\n\n\n//loadmode = fit\nMapSurfaceTree.prototype.drawSurfaceFit = function(shift, storeTilesOnly) {\n    this.counter++;\n\n    var tile = this.surfaceTree;\n    \n    if (!tile.isMetanodeReady(this, 0)) {\n        return;\n    }\n    \n    var map = this.map;\n    var node = tile.metanode;\n    var cameraPos = map.camera.position;\n\n    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n        return;\n    }\n\n    tile.updateTexelSize();\n\n    var geodata = tile.surface ? tile.surface.geodata : null;\n    var maxLod = tile.surface.maxLod || tile.surface.lodRange[1];\n    var free = tile.surface ? tile.surface.free : null;\n    var drawGrid = (!geodata && !free && map.config.mapHeightfiledWhenUnloaded);\n    var checkGpu = true;\n    \n    var lodShift = 4;//this.freeLayerSurface ? 1 : 1;\n    var typeFactor = 2000;//this.freeLayerSurface ? 1 : 1;\n\n    if (this.freeLayerSurface) {\n        lodShift = 0;//this.freeLayerSurface ? 1 : 1;\n        typeFactor = 0.1;//this.freeLayerSurface ? 1 : 1;\n    }\n    \n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var replay = draw.replay;\n    var drawBuffer = draw.drawBuffer;\n    var processBuffer = draw.processBuffer;\n    var newProcessBuffer = draw.processBuffer2;\n    var drawBufferIndex = 0;\n    var processBufferIndex = 0;\n    var newProcessBufferIndex = 0;\n    \n    processBuffer[0] = [tile, 0];\n    processBufferIndex = 1;\n\n    var texelSizeFit = draw.texelSizeFit;\n\n    var storeNodes = replay.storeNodes || replay.storeFreeNodes;\n    var storeNodesBuffer = replay.nodeBuffer; \n\n    draw.drawCounter++;\n    \n    var usedNodes = 1;\n    var pocessedNodes = 1;\n    var pocessedMetatiles = 1;  \n    var drawCounter = draw.drawCounter;\n    var maxHiresLodLevels = map.config.mapMaxHiresLodLevels, i, j, lj, child, priority, parent, parent2, children2;\n    var grids = false; \n    \n    do {\n        var best = 0;\n        newProcessBufferIndex = 0;\n\n        /*if (this.map.drawIndices) {\n            console.log(\"processed begin==============================================\");\n        }*/            \n       \n        for (i = processBufferIndex - 1; i >= 0; i--) {\n            var pack = processBuffer[i];\n            tile = pack[0];\n            var depth = pack[1];\n\n            tile.childrenReadyCount = 0;\n            \n            /*if (this.map.drawIndices) {\n                console.log(JSON.stringify(tile.id));\n            }*/\n            \n            if (depth >= maxHiresLodLevels) {\n                if (drawGrid) {\n                    parent = tile;\n\n                    //make sure that we draw grid with lowest possible detail \n                    parent2 = parent.parent;                    \n\n                    if (parent.id[0] > 3 && depth !=0 && parent2 && parent2.childrenReadyCount == 0) {\n                        children2 = parent2.children;\n\n                        if (!(depth >= 1 && parent.parent && ((children2[0] && children2[0].childrenReadyCount != 0) || \n                             (children2[1] && children2[1].childrenReadyCount != 0) ||\n                             (children2[2] && children2[2].childrenReadyCount != 0) ||\n                             (children2[3] && children2[3].childrenReadyCount != 0)))) {\n                            parent = parent.parent;\n                        }\n                    }\n\n                    //make sure that grid tile is rendered only one time\n                    if (parent.drawCounter != draw.drawCounter && (!parent.parent || parent.parent.drawCounter != draw.drawCounter )) { \n                        parent.drawCounter = draw.drawCounter;\n                        \n                        drawBuffer[drawBufferIndex] = [parent, true]; //draw grid\n                        drawBufferIndex++;\n                        grids = true;\n                    }\n                }\n\n                continue;\n            }\n            \n            node = tile.metanode;\n\n            if (node) {\n                pocessedNodes++;\n                if (node.metatile.drawCounter != drawCounter) {\n                    node.metatile.drawCounter = drawCounter;\n                    pocessedMetatiles++;\n                }\n            }\n\n\n            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n\n                usedNodes++;\n\n                if (tile.texelSize  != Number.POSITIVE_INFINITY){\n                    if (tile.texelSize > best) {\n                        best = tile.texelSize;\n                    }\n                }\n\n                if (storeNodes) { //used only for inspaector\n                    storeNodesBuffer.push(tile);\n                }\n                \n                var lastProcessBufferIndex = newProcessBufferIndex;\n                var lastDrawBufferIndex = drawBufferIndex;\n\n                if (!node.hasChildren() || tile.texelSize <= texelSizeFit || (geodata && tile.id[0] >= maxLod)) {\n\n                    priority = ((tile.id[0] + lodShift) * typeFactor) * tile.distance; \n            \n                    if (node.hasChildren() && !drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, (depth > 0), checkGpu)) {\n\n                        depth++; //we dont have tile ready, so we try to draw more detailed tiles\n\n                        for (j = 0; j < 4; j++) {\n                            child = tile.children[j];\n                            if (child) {\n           \n                                if (child.isMetanodeReady(this, child.id[0], true)) { //lod is used as priority\n\n                                    this.updateNodeHeightExtents(child, child.metanode);\n                                    child.updateTexelSize();\n                                    \n                                    //are draw buffers ready? preventRender=true, preventLoad=false\n                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, (depth > 0), checkGpu)) {\n                                        tile.childrenReadyCount++;\n                                        child.drawCounter = draw.drawCounter;\n                                        \n                                        drawBuffer[drawBufferIndex] = [child, false];\n                                        drawBufferIndex++;\n                                    } else {\n                                        newProcessBuffer[newProcessBufferIndex] = [child, depth];\n                                        newProcessBufferIndex++;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (lastProcessBufferIndex == newProcessBufferIndex && lastDrawBufferIndex == drawBufferIndex) {\n                            depth--; \n                        }\n\n                    } else {\n                        tile.drawCounter = draw.drawCounter;\n\n                        drawBuffer[drawBufferIndex] = [tile, false];\n                        drawBufferIndex++;\n                    }\n                    \n                } else if (depth == 0 && node.hasGeometry() && tile.texelSize <= (texelSizeFit * 2)) {\n                    \n                    //are all children ready? if not then draw carser lod\n                    var childrenCount = 0;\n                    var readyCount = 0;\n                    var childrenBuffer = [];\n        \n                    for (j = 0; j < 4; j++) {\n                        child = tile.children[j];\n                        if (child) {\n                            childrenCount++;\n       \n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize();\n                                \n                                priority = ((child.id[0] + lodShift) * typeFactor) * child.distance; \n                               \n                                //are draw buffers ready? preventRender=true, preventLoad=true\n                                if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, true, checkGpu)) {\n                                    readyCount++;\n                                    childrenBuffer.push(child);\n                                }\n                            }\n                        }\n                    }\n        \n                    if (childrenCount > 0 && childrenCount == readyCount) {\n                        //sort children by distance\n    \n                        do {\n                            var sorted = true;\n                            \n                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {\n                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {\n                                    var t = childrenBuffer[j];\n                                    childrenBuffer[j] = childrenBuffer[j+1];\n                                    childrenBuffer[j+1] = t;\n                                    sorted = false;\n                                } \n                            }\n                            \n                        } while(!sorted);\n    \n                        //add children to new process buffer \n                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {\n                            newProcessBuffer[newProcessBufferIndex] = [childrenBuffer[j], depth];\n                            newProcessBufferIndex++;\n                        }\n                    } else {\n                        \n                        //can i use coarser lod\n                        priority = ((tile.id[0] + lodShift) * typeFactor) * tile.distance; \n\n                        if (drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, true, checkGpu)) {\n                            tile.drawCounter = draw.drawCounter;\n\n                            drawBuffer[drawBufferIndex] = [tile, false];\n                            drawBufferIndex++;\n\n                            for (j = 0; j < 4; j++) {\n                                child = tile.children[j];\n                                if (child) {\n                                    if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                        priority = ((child.id[0] + lodShift) * typeFactor) * child.distance; \n                                        drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, checkGpu);\n                                    }\n                                }\n                            }\n\n                        } else {\n\n                            //add children to new process buffer \n                            for (j = 0; j < 4; j++) {\n                                child = tile.children[j];\n                                if (child) {\n                                    if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                        this.updateNodeHeightExtents(child, child.metanode);\n                                        child.updateTexelSize();\n\n                                        newProcessBuffer[newProcessBufferIndex] = [child, depth];\n                                        newProcessBufferIndex++;\n                                    }\n                                }\n                            }\n\n                        } \n                    }\n\n                }  else  {  //go deeper\n                    \n                    \n                    for (j = 0; j < 4; j++) {\n                        child = tile.children[j];\n                        if (child) {\n\n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize();\n                                \n                                newProcessBuffer[newProcessBufferIndex] = [child, depth];\n                                newProcessBufferIndex++;\n                            }\n                        }\n                    }                    \n                }\n            }\n\n\n            if (drawGrid && lastProcessBufferIndex == newProcessBufferIndex && lastDrawBufferIndex == drawBufferIndex) {\n                parent = tile;\n\n                //make sure that we draw grid with lowest possible detail \n                parent2 = parent.parent;                    \n\n                if (parent.id[0] > 3 && depth !=0 && parent2 && parent2.childrenReadyCount == 0) {\n                    children2 = parent2.children;\n\n                    if (!(depth >= 1 && parent.parent && ((children2[0] && children2[0].childrenReadyCount != 0) || \n                         (children2[1] && children2[1].childrenReadyCount != 0) ||\n                         (children2[2] && children2[2].childrenReadyCount != 0) ||\n                         (children2[3] && children2[3].childrenReadyCount != 0)))) {\n                        parent = parent.parent;\n                    }\n                }\n\n                //make sure that grid tile is rendered only one time\n                if (parent && parent.drawCounter != draw.drawCounter) { \n                    parent.drawCounter = draw.drawCounter;\n\n                    drawBuffer[drawBufferIndex] = [parent, true]; //draw grid\n                    drawBufferIndex++;\n                    grids = true;\n                }\n            }\n\n        }\n\n        /*if (this.map.drawIndices) {\n            console.log(\"processed end==============================================\");\n        }*/\n        \n        var tmp = processBuffer;\n        processBuffer = newProcessBuffer;\n        newProcessBuffer = tmp;\n        processBufferIndex = newProcessBufferIndex;\n        \n    } while(processBufferIndex > 0);\n\n    if (storeTilesOnly) {\n        this.storeDrawBufferGeometry(drawBufferIndex);\n        return;\n    }\n\n    var stats = map.stats;\n\n    stats.usedNodes = usedNodes;    \n    stats.processedNodes = pocessedNodes;    \n    stats.processedMetatiles = pocessedMetatiles;    \n\n    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex);\n};\n\n\n//loadmode = downtop\nMapSurfaceTree.prototype.drawSurfaceDownTop = function(shift, storeTilesOnly) {\n    this.counter++;\n\n    var map = this.map;\n    var cameraPos = map.camera.position;\n    var tile = this.surfaceTree;\n\n    if (!tile.isMetanodeReady(this, 0)) {\n        return;\n    }\n\n    tile.updateTexelSize();\n\n    var root = tile;\n    var node = tile.metanode;\n\n    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n        return;\n    }\n\n    //var drawBufferIndex2 = this.drawSurfaceFitOnly(shift, true, true);\n    //if (drawBufferIndex2 == 0) {\n      //  return;\n    //}\n\n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var drawBuffer = draw.drawBuffer;\n    var drawBuffer2 = draw.drawBuffer2;\n    var drawBufferIndex = 0;\n    var grids = false; \n    var texelSizeFit = draw.texelSizeFit;    \n    var tilesToLoad = 0, priority, parent, child;\n\n    var processBuffer = draw.processBuffer;\n    var newProcessBuffer = draw.processBuffer2;\n    var processBufferIndex = 0;\n    var newProcessBufferIndex = 0;\n    \n    processBuffer[0] = tile;\n    processBufferIndex = 1;\n\n    var texelSizeFit = draw.texelSizeFit;\n\n    draw.drawCounter++;\n    \n    var replay = map.draw.replay;\n    var storeNodes = replay.storeNodes || replay.storeFreeNodes;\n    var storeNodesBuffer = replay.nodeBuffer; \n\n    var usedNodes = 1;\n    var pocessedNodes = 1;\n    var pocessedMetatiles = 1;  \n    var drawCounter = draw.drawCounter, i, j, lj;\n    var grids = false, item, hit; \n    \n    do {\n        var best = 0;\n        newProcessBufferIndex = 0;\n       \n        for (i = processBufferIndex - 1; i >= 0; i--) {\n            tile = processBuffer[i];\n            node = tile.metanode;\n\n            if (node) {\n                pocessedNodes++;\n                if (node.metatile.drawCounter != drawCounter) {\n                    node.metatile.drawCounter = drawCounter;\n                    pocessedMetatiles++;\n                }\n            }\n\n            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n\n                usedNodes++;\n\n                if (storeNodes) { //used only for inspector\n                    storeNodesBuffer.push(tile);\n                }\n\n                if (tile.texelSize  != Number.POSITIVE_INFINITY){\n                    if (tile.texelSize > best) {\n                        best = tile.texelSize;\n                    }\n                }\n                \n                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit) {\n                   \n                    tile.drawCounter = drawCounter;\n                    drawBuffer[drawBufferIndex] = tile;\n                    drawBufferIndex++;\n                    \n                } else { //go deeper\n\n                    var childrenCount = 0;\n                    var nodesReadyCount = 0;\n                    var childrenBuffer = [];\n        \n                    for (j = 0; j < 4; j++) {\n                        var child = tile.children[j];\n                        if (child) {\n                            childrenCount++;\n       \n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize();\n\n                                childrenBuffer.push(child);\n                                nodesReadyCount++;\n\n                            } /*else if (useDrawBufferOnly) { //used in downtop\n                                //drawBuffer[drawBufferIndex] = [child, true];\n                                //drawBufferIndex++;\n                            }*/\n                        }\n                    }\n        \n                    if (childrenCount > 0 && (childrenCount == nodesReadyCount)) {\n                        //sort children by distance\n    \n                        do {\n                            var sorted = true;\n                            \n                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {\n                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {\n                                    var t = childrenBuffer[j];\n                                    childrenBuffer[j] = childrenBuffer[j+1];\n                                    childrenBuffer[j+1] = t;\n                                    sorted = false;\n                                } \n                            }\n                            \n                        } while(!sorted);\n    \n                        //add childrn to new process buffer \n                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {\n\n                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];\n                            newProcessBufferIndex++;\n                        }\n                    } else {\n                        tile.drawCounter = drawCounter;\n                        drawBuffer[drawBufferIndex] = [tile,true];\n                        drawBufferIndex++;\n                    }\n                    \n                }\n            }\n        }\n        \n        var tmp = processBuffer;\n        processBuffer = newProcessBuffer;\n        newProcessBuffer = tmp;\n        processBufferIndex = newProcessBufferIndex;\n        \n    } while(processBufferIndex > 0);\n\n    if (drawBufferIndex == 0) {\n        return;\n    }\n\n    var tmp = draw.drawBuffer2;\n    draw.drawBuffer2 = draw.drawBuffer;\n    draw.drawBuffer = tmp;\n\n    drawBuffer = draw.drawBuffer;\n    var drawBuffer2 = draw.drawBuffer2;\n    var drawBufferIndex2 = drawBufferIndex;\n    drawBufferIndex = 0;\n\n    //draw.drawCounter++;\n    //drawCounter++;\n\n    var lodShift = 4;\n    var typeFactor = 2000;\n\n    if (this.freeLayerSurface) {\n        lodShift = 0;\n        typeFactor = 0.1;\n    }    \n\n    var findLoadedParent = (function(){\n\n        //TODO: NEW RULES\n            // search parent\n               // if exist load from parent down (there can be configurable limit e.g. max 3 lods up)\n               // if not exist (root) load only fit lod\n\n\n        var hasLoadedParent = false;\n\n        if (/*tile.texelSize != 1 && tile.texelSize <= texelSizeFit &&*/ tile != root) {\n            parent = tile.parent;\n\n            while (parent != root) {\n                priority = ((parent.id[0] + lodShift) * typeFactor);\n\n                // preventRender=true, preventLoad=true, checkGpu = false\n                if (drawTiles.drawSurfaceTile(parent, parent.metanode, cameraPos, parent.texelSize, priority, true, true, false)) {\n                    //render parent\n                    drawBuffer[drawBufferIndex] = [parent, false];\n                    parent.drawCounter = drawCounter;\n                    hasLoadedParent = true;\n\n                    //load children\n                    for (var j = 0; j < 4; j++) {\n                        child = parent.children[j];\n                        if (child) {\n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                // preventRender=true, preventLoad=false, checkGpu = false\n                                if (!drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, false)) {\n                                    tilesToLoad++;\n                                }\n                            }\n                        }\n                    }\n\n                    break;\n                }\n\n                parent = parent.parent;\n            }\n\n\n            if (!hasLoadedParent) {\n                priority = ((tile.id[0] + lodShift) * typeFactor);\n\n                // preventRender=true, preventLoad=false, checkGpu = false\n                if (!drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, false, false)) {\n                    drawBuffer[drawBufferIndex] = [tile, true];\n                    tile.drawCounter = drawCounter;\n                    tilesToLoad++;\n                } else {\n                    drawBuffer[drawBufferIndex] = [tile, false];\n                    tile.drawCounter = drawCounter;\n                }\n            }\n        }\n\n\n    });\n\n\n    //draw surface\n    for (i = drawBufferIndex2 - 1; i >= 0; i--) {\n        item = drawBuffer2[i];\n        //tile = (noGrid) ? item : item[0];\n\n        if (item[1]) {\n            tile = item[0];\n\n            if (!tile.isMetanodeReady(this, tile.id[0])) { //lod is used as priority\n                continue;\n            }\n\n            drawBuffer[drawBufferIndex] = [tile, true];\n            grids = true; \n            priority = 20;\n\n            //TODO: search parents\n                // if parent exist render parent (limit parent level?), load children, \n                // remove parent children from draw buffer?\n\n            //if (!node.hasChildren() || ) {\n\n            findLoadedParent();\n\n        } else {\n            tile = item;\n            node = tile.metanode;\n            drawBuffer[drawBufferIndex] = [tile, false];\n            priority = ((tile.id[0] + lodShift) * typeFactor);\n           \n            //are draw buffers ready? preventRender=true, preventLoad=false, checkGpu = false\n            if (!drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, false, false)) {\n\n                findLoadedParent();\n\n                tilesToLoad++;\n            } else {\n                tile.drawCounter = drawCounter;\n            }\n        }\n\n        drawBufferIndex++;\n    }\n\n\n    //filter out children\n    var tmp = drawBuffer2;\n    drawBuffer2 = drawBuffer;\n    drawBuffer = tmp;\n\n    var drawBufferIndex2 = drawBufferIndex;\n    drawBufferIndex = 0;\n\n    for (i = 0; i < drawBufferIndex2; i++) {\n        item = drawBuffer2[i];\n\n        tile = item[0];\n        hit = false;\n\n        if (tile != root) {\n            parent = tile.parent;\n\n            while (parent != root) {\n\n                if (parent.drawCounter == drawCounter) {\n                    hit = true;\n                    break;\n                }\n\n                parent = parent.parent;\n            }\n        }\n\n        if (!hit) {\n            drawBuffer[drawBufferIndex] = drawBuffer2[i];\n            drawBufferIndex++;\n        }\n    }\n  \n\n    //TODO: if everything loaded then load parents\n        // use drawCounter as optimization \n\n    if (tilesToLoad == 0) {\n\n        for (i = 0; i < drawBufferIndex; i++) {\n            item = drawBuffer[i];\n\n            tile = item[0];\n            hit = false;\n\n            if (tile != root) {\n                parent = tile.parent;\n\n                while (parent != root) {\n\n                    priority = (((100-tile.id[0]) + lodShift) * typeFactor);\n\n                    //are draw buffers ready? preventRender=true, preventLoad=false, checkGpu = false\n                    if (!drawTiles.drawSurfaceTile(parent, parent.metanode, cameraPos, parent.texelSize, priority, true, false, false)) {\n                        break;\n                    }\n\n                    parent = parent.parent;\n                }\n            }\n\n        }\n\n    }\n\n\n    //if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit) {\n\n    var stats = map.stats;\n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var replay = draw.replay;\n\n    var geodata = tile.surface ? tile.surface.geodata : null;\n    var free = tile.surface ? tile.surface.free : null;\n    var drawGrid = (!geodata && !free && map.config.mapHeightfiledWhenUnloaded);\n\n    //stats.usedNodes = usedNodes;    \n    //stats.processedNodes = pocessedNodes;    \n    //stats.processedMetatiles = pocessedMetatiles;    \n\n    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex);\n};\n\n\nMapSurfaceTree.prototype.processDrawBuffer = function(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex, noGrid) {\n\n    if (replay.storeTiles || replay.storeFreeTiles) { //used only in inspectors\n        if (!draw.tileBuffer[0]) {\n            draw.tileBuffer[0] = [];\n        }\n        \n        var tiles = draw.tileBuffer[0];\n        for (i = drawBufferIndex - 1; i >= 0; i--) {\n            tiles.push(drawBuffer[i]);\n        }\n    }\n\n    var scanExtents = (!this.freeLayerSurface && map.config.mapFeatureStickMode[0] == 2); // && this.freeLayerSurface.geodata && draw.drawChannel == 0);\n    var hmax = -999999, hmin = 999999;\n    var renderer = map.renderer;\n    var mvp = this.camera.getMvpMatrix(), p1, p2, camVec, length, tilt, factor, i, tile, node; \n\n    map.gpuCache.skipCostCheck = true;\n\n    var underSurfaceGrid = (drawGrid && map.config.mapGridUnderSurface > 0 && grids);\n    \n    if (underSurfaceGrid) {\n        //draw only grid\n        for (i = drawBufferIndex - 1; i >= 0; i--) {\n            drawBuffer[i][0].drawGrid(cameraPos); \n        }\n\n        //clear zbuffer\n        map.renderer.gpu.clear(true, false);\n    }\n\n    //draw surface\n    for (i = drawBufferIndex - 1; i >= 0; i--) {\n        var item = drawBuffer[i];\n        tile = (noGrid) ? item : item[0];\n        node = tile.metanode;\n\n        if (scanExtents && node) {\n            // TODO noramlize by distance and tilt\n\n            p2 = node.diskPos;\n            p1 = renderer.cameraPosition;\n            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            length = vec3.normalize4(camVec);\n            tilt = -vec3.dot(camVec, node.diskNormal);\n\n            if (tilt < 0) {\n                tilt = 0;\n            }\n\n            tilt = 1 - tilt;\n\n            factor = (renderer.camera.fovDist / length) * tilt;\n            //renderer.camera.scaleFactor2(d) * screenPixelSize\n            //pp = this.renderer.project2(tile.diskPos, mvp);                \n\n            if (node.minZ * factor < hmin) {\n                hmin = node.minZ * factor;\n            }\n\n            if (node.maxZ * factor > hmax) {\n                hmax = node.maxZ * factor;\n            }\n        }\n\n\n        if (noGrid)  {\n\n            if (stats.gpuRenderUsed >= draw.maxGpuUsed)  {\n                break;\n            }\n\n            //draw tile,  preventRender=false, preventLoad=false\n            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false);\n\n        } else {\n\n            if (underSurfaceGrid) {\n\n                if (!item[1] && !(stats.gpuRenderUsed >= draw.maxGpuUsed))  {\n                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false /*, checkGpu*/);\n                } else {\n                    if (drawTiles.debug.drawBBoxes) {\n                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);\n                    }\n                }\n\n            } else {\n\n                if ((drawGrid && item[1]) || stats.gpuRenderUsed >= draw.maxGpuUsed)  {\n\n                    if (drawTiles.debug.drawBBoxes) {\n                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);\n                    }\n\n                    tile.drawGrid(cameraPos); \n                } else if (!item[1]) {\n                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false /*, checkGpu*/);\n                }\n            }\n\n        }\n    }\n\n    if (scanExtents) {\n        renderer.gridHmax = hmax;\n        renderer.gridHmin = hmin;\n    }\n\n    map.gpuCache.skipCostCheck = false;\n    map.gpuCache.checkCost();\n\n};\n\n\n\nMapSurfaceTree.prototype.storeDrawBufferGeometry = function(drawBufferIndex) {\n    var map = this.map;\n    var drawBuffer = map.draw.drawBuffer;\n\n    this.storeGeometry(drawBuffer, drawBufferIndex);\n};\n\n\nMapSurfaceTree.prototype.storeGeometry = function(array, length) {\n    var map = this.map;\n    var drawBuffer = array;\n    map.storedTilesRes = new Array(length);        \n\n    for (var i = length - 1; i >= 0; i--) {\n        var tile = drawBuffer[i];\n\n        if (tile.metanode && tile.surface && tile.metanode.hasGeometry() &&\n            tile.surfaceMesh && tile.surfaceMesh.isReady(true, 0, true)) {\n\n            var mesh = tile.surfaceMesh;\n            var submeshes = [];\n\n            for (var j = 0, lj = mesh.submeshes.length; j < lj; j++) {\n                var submesh = mesh.submeshes[j],\n                    vertices = submesh.vertices.slice(),\n                    min = submesh.bbox.min,\n                    max = submesh.bbox.max,\n                    delta = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n\n                for (var k = 0, lk = vertices.length; k < lk; k+=3) {\n                    vertices[k] = vertices[k]*delta[0] + min[0];\n                    vertices[k+1] = vertices[k+1]*delta[1] + min[1];\n                    vertices[k+2] = vertices[k+2]*delta[2] + min[2];\n                }\n\n                submeshes.push({ \n                    \"bbox\": [min.slice(), max.slice()],\n                    \"vertices\" : vertices });\n            }\n\n            map.storedTilesRes[i] = {\n                \"id\": tile.id.slice(),\n                \"type\": \"mesh\",\n                \"submeshes\": submeshes\n            };\n        }\n    }\n};\n\n\nMapSurfaceTree.prototype.traceHeight = function(tile, params, nodeOnly) {\n    if (!tile) {\n        return;\n    }\n\n    this.params = params;\n\n    var heightFunction = nodeOnly ? this.traceHeightTileByNodeOnly : this.traceHeightTileByMap;  \n\n    if (tile.id[0] == 1) { //update root, get height in VTS2015 starts in division node which has lod 1\n        this.traceHeightTile(tile.parent, 0, true);\n        if (!tile.parent.metanode) {\n            return;\n        }\n    }\n    \n    this.traceHeightTile(tile, 0, false, heightFunction);\n};\n\n\nMapSurfaceTree.prototype.traceHeightTile = function(tile, priority, nodeReadyOnly, heightFunction) {\n    if (tile == null) {\n        return;\n    }\n\n    if (!tile.isMetanodeReady(this, 0) || nodeReadyOnly) {\n        this.params.waitingForNode = true;\n        return;\n    }\n\n    tile.metanode.metatile.used();\n\n    if (tile.lastSurface && tile.lastSurface == tile.surface) {\n        tile.lastSurface = null;\n        tile.restoreLastState();\n        //return;\n    }\n    \n    //process tile e.g. draw or get height\n    var res = heightFunction(tile, this.params, priority); \n    \n    if (res) { //we need to go deeper\n        var childIndex = this.traceHeightChild(tile, this.params);\n        var child = tile.children[childIndex];\n        \n        if (!child) {\n            this.params.finalNode = true;\n        }\n\n        this.traceHeightTile(child, 0, false, heightFunction);\n    }\n};\n\n\nMapSurfaceTree.prototype.traceHeightChild = function(tile, params) {\n    var coords = params.coords;\n    var extents = params.extents;\n    var center = [(extents.ll[0] + extents.ur[0]) *0.5,\n        (extents.ll[1] + extents.ur[1]) *0.5];\n\n    //ul,ur,ll,lr\n    //deside in which quadrant are provided coodinates\n    var right = (coords[0] >= center[0]);\n    var bottom = (coords[1] >= center[1]);\n\n    if (right) {\n        extents.ll[0] = center[0];\n        if (bottom) {\n            extents.ll[1] = center[1];\n        } else {\n            extents.ur[1] = center[1];\n        }\n    } else {\n        extents.ur[0] = center[0];\n        if (bottom) {\n            extents.ll[1] = center[1];\n        } else {\n            extents.ur[1] = center[1];\n        }\n    }\n\n    /*\n    if (extents.ll[0] > extents.ur[0]) {\n        right = !right;\n    }\n\n    if (extents.ll[1] < extents.ur[1]) {\n        bottom = !bottom;\n    }*/\n\n    //trace only resulting quadrant \n    if (right) {\n        return bottom ? 1 : 3;\n    } else {\n        return bottom ? 0 : 2;\n    }\n};\n\n\nMapSurfaceTree.prototype.traceHeightTileByMap = function(tile, params) {\n    if (!tile || (tile.id[0] > params.desiredLod && params.heightMap)) {\n        return false;\n    }\n\n    var node = tile.metanode;\n\n    if (!node) {\n        return false;\n    }\n\n    if (node.hasNavtile()) {\n        params.bestHeightMap = tile.id[0];\n\n        if (!tile.heightMap) {\n            //if (!preventLoad) {\n                //if (!tile.surface || tile.surface.virtual) {\n            if (!tile.surface || !tile.resourceSurface) { //surface.virtual) {\n                return false; //is it best way how to do it?\n            }\n                \n            if (!tile.resourceSurface.getNavUrl) { //virtual surface is as resource surface. Is it bug??!!\n                return false; //is it best way how to do it?\n            }\n                \n            var path = tile.resourceSurface.getNavUrl(tile.id);\n            tile.heightMap = tile.resources.getTexture(path, true);\n            //}\n        } else {\n            if (tile.heightMap.isReady(null, null, true)) {\n                params.parent = {\n                    metanode : params.metanode,\n                    heightMap : params.heightMap,\n                    heightMapExtents : params.heightMapExtents\n                };\n                \n                params.metanode =  node;\n                params.heightMap = tile.heightMap;\n                params.heightMapExtents = {\n                    ll : params.extents.ll.slice(),\n                    ur : params.extents.ur.slice()\n                };\n                return (tile.id[0] != params.desiredLod);\n            }\n        }\n    } else {\n        if (!params.heightMap) {\n            params.metanode =  node;\n        }\n        \n        return true;\n    }\n\n    return false;\n};\n\n\nMapSurfaceTree.prototype.traceHeightTileByNodeOnly = function(tile, params) {\n    if (!tile || tile.id[0] > params.desiredLod) {\n        return false;\n    }\n\n    var node = tile.metanode;\n\n    if (!node) {\n        return false;\n    }\n\n    params.parent = {\n        metanode : params.metanode\n    };\n\n    params.metanode =  node;\n    return (tile.id[0] != params.desiredLod);\n};\n\n\nMapSurfaceTree.prototype.getNodeById = function(id, preventLoad) {\n    var tile = this.surfaceTree;\n\n    if (tile == null) {\n        return;\n    }\n\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        if (!tile.children[index]) {\n\n            if (!tile.isMetanodeReady(this, 0, preventLoad)) {\n                return null;\n            }\n\n            if (!tile.metanode.hasChild(index)) {\n                return null;\n            }\n\n            tile.addChild(index);\n        } \n\n        tile = tile.children[index];\n    }\n\n    if (!tile) {\n        return;\n    }\n\n    if (!tile.isMetanodeReady(this, 0, preventLoad)) {\n        return;\n    }\n\t\n    var node = tile.metanode;\n    tile.metanode.metatile.used();\n\n    return node;\n\n\t/*\n    if (tile.lastSurface && tile.lastSurface == tile.surface) {\n        tile.lastSurface = null;\n        tile.restoreLastState();\n        //return;\n    }*/\n};\n\n\nMapSurfaceTree.prototype.getRenderedNodeById = function(id, drawCounter) {\n    var tile = this.surfaceTree;\n\n    if (tile == null) {\n        return;\n    }\n\n    if (tile.drawCounter == drawCounter) {\n        if (!tile.isMetanodeReady(this, 0)) {\n            return;\n        }\n\n        return tile.metanode;\n    }\n\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        if (!tile.children[index]) {\n\n            if (!tile.isMetanodeReady(this, 0)) {\n                return;\n            }\n\n            if (!tile.metanode.hasChild(index)) {\n                return;\n            }\n        } \n\n        tile = tile.children[index];\n\n        if (tile.drawCounter == drawCounter) {\n            if (!tile.isMetanodeReady(this, 0)) {\n                return;\n            }\n\n            return tile.metanode;\n        } else {\n            if (lod == 1) { //rendered lod is probably from more detailed lod so we take one which is from same lod\n                return tile.metanode;\n            }\n        }\n    }\n\n    return;\n};\n\n\nMapSurfaceTree.prototype.chekTileMesh = function(tile) {\n    if (this.params.loadMeshes || this.params.loadTextures) {\n\n        var tmp = this.config.mapNoTextures;\n        this.config.mapNoTextures = !this.params.loadTextures;\n\n        //are resources ready? priority=0, preventRender=true, preventLoad=false, doNotCheckGpu=true\n        if (!this.map.draw.drawTiles.drawSurfaceTile(tile, tile.metanode, this.map.renderer.cameraPosition, tile.texelSize, 0, true, false, true)) {\n            this.params.loaded = false;\n        }\n\n        this.config.mapNoTextures = tmp;\n    }\n};\n\n\nMapSurfaceTree.prototype.traceAreaTiles = function(tile, priority, nodeReadyOnly) {\n    if (tile == null) {\n        return;\n    }\n\n    if (!tile.isMetanodeReady(this, 0) || nodeReadyOnly) {\n        this.params.loaded = false;\n        //console.log('(L)' + JSON.stringify(tile.id));\n        tile.isMetanodeReady(this, 0);\n        return;\n    }\n\n    tile.metanode.metatile.used();\n\n    if (tile.lastSurface && tile.lastSurface == tile.surface) {\n        tile.lastSurface = null;\n        tile.restoreLastState();\n        //return;\n    }\n\n    if (!tile.insideCone(this.params.coneVec, this.params.coneAngle, tile.metanode)) {\n        return;\n    }\n\n    var fit = (this.params.mode == 'lod') ? (tile.id[0] >= this.params.limit) : (tile.metanode.pixelSize <= this.params.limit);\n\n    if (fit) {\n        //console.log('(A)' + JSON.stringify(tile.id));\n        this.chekTileMesh(tile);\n        this.params.areaTiles.push(tile);\n        return;\n    }\n\n    if (!tile.metanode.hasChildren()) {\n        //console.log('(A)' + JSON.stringify(tile.id));\n        this.chekTileMesh(tile);\n        this.params.areaTiles.push(tile);\n    } else {\n        for (var i = 0; i < 4; i++) {\n            this.traceAreaTiles(tile.children[i], priority, nodeReadyOnly);\n        }\n    }\n};\n\n\n\nexport default MapSurfaceTree;\n","import MapCredit_ from './credit';\nimport MapStylesheet_ from './stylesheet';\nimport MapSurfaceTree_ from './surface-tree';\nimport BBox_ from '../renderer/bbox';\nimport {utils as utils_} from '../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../utils/url';\n\n//get rid of compiler mess\nvar MapCredit = MapCredit_;\nvar MapStylesheet = MapStylesheet_;\nvar MapSurfaceTree = MapSurfaceTree_;\nvar BBox = BBox_;\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\n\n\nvar MapSurface = function(map, json, type) {\n    this.map = map;\n    this.id = null;\n    this.type = 'basic';\n    this.metaBinaryOrder = 1;\n    this.metaUrl = '';\n    this.navUrl = '';\n    this.navDelta = 1;\n    this.meshUrl = '';\n    this.textureUrl = '';\n    this.baseUrl = this.map.url.baseUrl;\n    this.baseUrlSchema = this.map.url.baseUrlSchema;\n    this.baseUrlOrigin = this.map.url.baseUrlOrigin;\n    this.lodRange = [0,0];\n    this.tileRange = [[0,0],[0,0]];\n    this.textureLayer = null;\n    this.boundLayerSequence = [];\n    this.glue = (type == 'glue');\n    this.free = (type == 'free');\n    this.virtual = false;\n    this.zFactor = 0;\n    this.ready = false;\n    this.geodataProcessor = null;\n    this.geodataCounter = 0;\n    this.geodataNavtileInfo = false;\n    this.monoGeodata = null;\n    this.monoGeodataView = null;\n    this.monoGeodataCounter = -1;\n    this.creditsNumbers = [];\n    this.surfaceCounter = map.surfaceCounter;\n    map.surfaceCounter++;\n\n    this.style = null;\n    this.stylesheet = null;\n    this.originalStyle = null;\n    this.originalStylesheet = null;\n    this.styleChanged = true;\n    \n    if (this.free) { //each free layer has its own data tree\n        this.tree = new MapSurfaceTree(this.map, true, this);\n    } else {\n        this.tree = null;\n    }\n    \n    if (typeof json === 'string') {\n        this.jsonUrl = this.map.url.processUrl(json);\n        this.baseUrl = utilsUrl.getBase(this.jsonUrl);\n        this.baseUrlSchema = utilsUrl.getSchema(this.jsonUrl);\n        this.baseUrlOrigin = utilsUrl.getOrigin(this.jsonUrl);\n        \n        var onLoaded = (function(data){\n            this.parseJson(data);            \n            this.ready = true;\n            this.map.refreshView();\n        }).bind(this);\n        \n        var onError = (function(){ }).bind(this);\n\n        utils.loadJSON(this.jsonUrl, onLoaded, onError, null,(utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n        //utils.loadJSON(this.url, onLoaded, onError, null, utils.useCredentials);\n    } else {\n        this.parseJson(json);\n        this.ready = true;\n    }\n};\n\n\nMapSurface.prototype.parseJson = function(json) {\n    this.id = json['id'] || null;\n    this.type = json['type'] || 'basic';\n    this.metaBinaryOrder = json['metaBinaryOrder'] || 1;\n    this.metaUrl = this.processUrl(json['metaUrl'], '');\n    this.navUrl = this.processUrl(json['navUrl'], '');\n    this.hmapUrl = this.processUrl(json['hmapUrl'], json['navUrl'] + '00');\n    //this.cmapUrl = this.processUrl(json['cmapUrl'], '');\n    this.pipeline = this.map.config.mapForcePipeline ? this.map.config.mapForcePipeline : (json['pipeline']); // || VTS_PIPELINE_HMAP);//VTS_PIPELINE_BASIC);\n    //this.pipeline = json['pipeline'] || VTS_PIPELINE_BASIC;\n    this.navDelta = json['navDelta'] || 1;\n    this.meshUrl = this.processUrl(json['meshUrl'], '');\n    this.textureUrl = this.processUrl(json['textureUrl'], '');\n    this.geodataUrl = this.processUrl(json['geodataUrl'] || json['geodata'], '');\n    this.lodRange = json['lodRange'] || [0,0];\n    this.tileRange = json['tileRange'] || [[0,0],[0,0]];\n    this.textureLayer = json['textureLayer'] || null;\n    this.geodata = (this.type == 'geodata' || this.type == 'geodata-tiles');\n    this.credits = json['credits'] || [];\n    this.creditsUrl = null;\n    this.displaySize = json['displaySize'] || 1024;\n\n    var i, li;\n    \n    if (json['extents']) {\n        var ll = json['extents']['ll'];\n        var ur = json['extents']['ur'];\n        this.extents = new BBox(ll[0], ll[1], ll[2], ur[0], ur[1], ur[2]);\n    } else {\n        this.extents = new BBox(0,0,0,1,1,1);\n    }\n\n    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    \n    \n    switch(typeof this.credits) {\n    case 'string':\n        this.creditsUrl = this.credits;\n        this.credits = [];\n        break;\n\n    case 'object':\n        \n        if (!Array.isArray(this.credits)) {\n            var credits = this.credits;\n            this.credits = [];\n                \n            for (var key in credits){\n                this.map.addCredit(key, new MapCredit(this.map, credits[key]));\n                this.credits.push(key);\n            }\n        }\n\n        for (i = 0, li = this.credits.length; i < li; i++) {\n            var credit = this.map.getCreditById(this.credits[i]);\n            this.creditsNumbers.push(credit ? credit.id : null); \n        }\n        \n        break;\n    }    \n\n\n    if (this.geodataUrl && (typeof this.geodataUrl === 'string') && this.geodataUrl.indexOf('{geonavtile}') != -1) {\n        //this.geodataNavtileInfo = true;\n        this.geodataNavtileInfo = false;\n    }\n\n    //load stylesheet\n    if (this.geodata) {\n        var style = json['style'];\n\n        if (typeof this.credits === 'string') {\n            style = this.processUrl(style, '');\n        }\n\n        this.originalStyle = style;\n        \n        if (style) {\n            this.setStyle(style);\n            this.originalStylesheet = this.stylesheet;\n        }\n    }\n\n    this.surfaceReference = [];\n    if (this.glue) {\n        for (i = 0, li = this.id.length; i < li; i++) {\n            this.surfaceReference.push(this.map.getSurface(this.id[i]));\n        }\n    }\n};\n\n\nMapSurface.prototype.kill = function() {\n    if (this.geodataProcessor) {\n        this.geodataProcessor.kill();\n        this.geodataProcessor = null;\n    }\n\n    this.geodataUrl = null;\n    this.style = null;\n    this.stylesheet = null;\n    this.originalStyle = null;\n    this.originalStylesheet = null;\n};\n\n\nMapSurface.prototype.setOptions = function() {\n};\n\n\nMapSurface.prototype.getOptions = function() {\n    return this.getInfo();\n};\n\n\nMapSurface.prototype.getInfo = function() {\n    if (this.geodata) {\n        return {\n            'type' : this.type,\n            'metaUrl' : this.metaUrl,\n            'geodataUrl' : this.geodataUrl,\n            'lodRange' : this.lodRange,\n            'tileRange' : this.tileRange,\n            'style' : this.originalStyle\n        };\n    } else {\n        return {\n            'type' : this.type,\n            'metaUrl' : this.metaUrl,\n            'navUrl' : this.navUrl,\n            'meshUrl' : this.meshUrl,\n            'textureUrl' : this.textureUrl,\n            'lodRange' : this.lodRange,\n            'tileRange' : this.tileRange,\n            'textureLayer' : this.textureLayer\n        };\n    }\n};\n\n\nMapSurface.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n\n    if (typeof url !== 'string') {\n        return url;\n    }\n\n    url = url.trim();\n    \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.baseUrlOrigin + url;\n    } else {  //relative\n        return this.baseUrl + url; \n    }\n};\n\n\nMapSurface.prototype.hasTile = function(id) {\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift < 0) {\n        return false;\n    }\n\n    var x = id[1] >> shift;\n    var y = id[2] >> shift;\n\n    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||\n        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n        return false;\n    }\n\n    return true;\n};\n\n\nMapSurface.prototype.hasTile2 = function(id) {\n    var shift = id[0] - this.lodRange[0];\n    var above = (shift < 0);\n\n    if (id[0] < this.lodRange[0]) {\n        shift = -shift;\n        var x1 = this.tileRange[0][0] >> shift;\n        var y1 = this.tileRange[0][1] >> shift;\n        var x2 = this.tileRange[1][0] >> shift;\n        var y2 = this.tileRange[1][1] >> shift;\n    \n        if (id[0] > this.lodRange[1] ||\n            id[1] < x1 || id[1] > x2 ||\n            id[2] < y1 || id[2] > y2 ) {\n            return [false , false];\n        }\n    } else {\n        var x = id[1] >> shift;\n        var y = id[2] >> shift;\n    \n        if (id[0] > this.lodRange[1] ||\n            x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n            return [false , false];\n        }\n    }\n\n    return [true, above];\n};\n\n\nMapSurface.prototype.hasMetatile = function(id) {\n    if (id[0] > this.lodRange[1]) {\n        return false;\n    }\n\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift >= 0) {\n        var x = id[1] >> shift;\n        var y = id[2] >> shift;\n\n        if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n            return false;\n        }\n    } else {\n        shift = -shift;\n\n        if (id[1] < (this.tileRange[0][0]>>shift) || id[1] > (this.tileRange[1][0]>>shift) ||\n            id[2] < (this.tileRange[0][1]>>shift) || id[2] > (this.tileRange[1][1]>>shift) ) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\nMapSurface.prototype.setStyle = function(style) {\n    if (this.style == style) {\n        return;\n    }\n\n    var id = style;\n\n    if (typeof id !== 'object') {\n        id = this.processUrl(id, '');\n    } else {\n        id = JSON.stringify(id);\n        id = utils.getHash(id);\n        id = \"#obj#\" + id.toString(16); \n    }\n    \n    this.stylesheet = this.map.getStylesheet(id);\n    \n    if (!this.stylesheet) {\n        this.stylesheet = new MapStylesheet(this.map, id, style, this);\n        this.map.addStylesheet(id, this.stylesheet); \n    } \n\n    this.style = style;\n    this.styleChanged = true;\n    this.geodataCounter++;\n\n    //this.map.setStylesheetData(id); //force update\n    \n    this.map.markDirty();\n};\n\n\n//used only for glues\nMapSurface.prototype.getSurfaceReference = function(index) {\n    return this.surfaceReference[index - 1];\n};\n\n\nMapSurface.prototype.getMetaUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getNavUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.navUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getHMapUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.hmapUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\nMapSurface.prototype.getMeshUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.meshUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getTextureUrl = function(id, subId, skipBaseUrl) {\n    return this.map.url.makeUrl(this.textureUrl, {lod:id[0], ix:id[1], iy:id[2] }, subId, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getGeodataUrl = function(id, navtileStr, skipBaseUrl) {\n//    return this.map.makeUrl(this.geodataUrl + \"&v=1\", {lod:id[0], ix:id[1], iy:id[2] }, navtileStr, skipBaseUrl);\n    return this.map.url.makeUrl(this.geodataUrl, {lod:id[0], ix:id[1], iy:id[2] }, navtileStr, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getMonoGeodataUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.geodataUrl, {}, null, skipBaseUrl);\n};\n\n\nexport default MapSurface;\n\n\n\n  ","\nimport MapSubtexture_ from './subtexture';\n\n//get rid of compiler mess\nvar MapSubtexture = MapSubtexture_;\n\n\nvar MapTexture = function(map, path, type, extraBound, extraInfo, tile, internal) {\n    this.map = map;\n    this.stats = map.stats;\n    this.tile = tile; // used only for stats\n    this.internal = internal; // used only for stats\n    \n    if (tile) {\n        this.mainTexture = tile.resources.getSubtexture(this, path, type, tile, internal); \n    } else {\n        this.mainTexture = new MapSubtexture(map, path, type, tile, internal); \n    }\n\n    this.maskTexture = null; \n\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.neverReady = false;\n    this.maskTexture = null;\n    this.mapLoaderUrl = path;\n    this.type = type || VTS_TEXTURETYPE_COLOR;\n    this.extraBound = extraBound;\n    this.extraInfo = extraInfo;\n    this.statsCounter = 0;\n    this.checkStatus = 0;\n    this.checkType = null;\n    this.checkValue = null;\n    this.fastHeaderCheck = false;\n    this.fileSize = 0;\n\n    if (extraInfo && extraInfo.layer) {\n        var layer = extraInfo.layer;\n        \n        if (layer.availability) {\n            this.checkType = layer.availability.type;\n            switch (this.checkType) {\n            case VTS_TEXTURECHECK_TYPE: this.checkValue = layer.availability.mime; break;\n            case VTS_TEXTURECHECK_CODE: this.checkValue = layer.availability.codes; break;\n            case VTS_TEXTURECHECK_SIZE: this.checkValue = layer.availability.size; break;\n            }\n        }       \n    }\n};\n\n\nMapTexture.prototype.kill = function() {\n    this.mainTexture.killImage();\n    this.mainTexture.killGpuTexture();\n    this.mainTexture = null;\n    \n    if (this.maskTexture) {\n        this.maskTexture.killImage(); \n        this.maskTexture.killGpuTexture(); \n    }\n};\n\n\nMapTexture.prototype.killImage = function() {\n    this.mainTexture.killImage();\n\n    if (this.maskTexture) {\n        this.maskTexture.killImage(); \n    }\n};\n\n\nMapTexture.prototype.killGpuTexture = function() {\n    this.mainTexture.killGpuTexture();\n\n    if (this.maskTexture) {\n        this.maskTexture.killGpuTexture(); \n    }\n};\n\n\nMapTexture.prototype.setBoundTexture = function(tile, layer, hmap) {\n    if (tile) {\n        if (hmap) {\n            this.extraBound.sourceTile = tile;\n            this.extraBound.hmap = hmap;\n\n            if (!tile.hmap) {\n                var path = tile.resourceSurface.getHMapUrl(tile.id, true);\n                tile.hmap = tile.resources.getTexture(path, null, null, {tile: tile, hmap: hmap}, this.tile, this.internal);\n            }\n\n            this.extraBound.texture = tile.hmap; \n\n        } else if (layer) {\n            this.extraBound.sourceTile = tile;\n            this.extraBound.layer = layer;\n            \n            if (!tile.boundTextures[layer.id]) {\n                tile.boundLayers[layer.id] = layer;\n                var path = layer.getUrl(tile.id);\n                tile.boundTextures[layer.id] = tile.resources.getTexture(path, null, null, {tile: tile, layer: layer}, this.tile, this.internal);\n            }\n\n            this.extraBound.texture = tile.boundTextures[layer.id]; \n        }\n        \n        this.extraBound.transform = this.map.draw.drawTiles.getTileTextureTransform(tile, this.extraBound.tile);\n        this.map.markDirty();\n    }\n};\n\n\nMapTexture.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n/*   \n   if (this.mapLoaderUrl == \"https://ecn.t3.tiles.virtualearth.net/tiles/a1202310323212333.jpeg?g=5549\") {\n       this.mapLoaderUrl = this.mapLoaderUrl;\n   }\n*/\n    if (this.neverReady) {\n        return false;\n    }\n\n    var parent;\n   \n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            while (this.extraBound.texture.extraBound || this.extraBound.texture.checkStatus == -1) {\n//            while (this.extraBound.texture.checkStatus == -1) {\n                parent = this.extraBound.sourceTile.parent;\n\n                if (this.extraBound.hmap) {\n                    if (!parent || parent.id[0] < 1) {\n                        this.neverReady = true;\n                        this.extraBound.tile.resetDrawCommands = true;\n                        this.map.markDirty();\n                        return false;\n                    }\n                } else if (this.extraBound.layer) {\n                    if (parent.id[0] < this.extraBound.layer.lodRange[0]) {\n                        this.neverReady = true;\n                        this.extraBound.tile.resetDrawCommands = true;\n                        this.map.markDirty();\n                        return false;\n                    }\n                }\n \n                this.setBoundTexture(parent, this.extraBound.layer);\n            }\n            \n            var ready = this.extraBound.texture.isReady(doNotLoad, priority, doNotCheckGpu);\n            \n            if (ready && this.checkMask) {\n                this.extraBound.tile.resetDrawCommands = (this.extraBound.texture.getMaskTexture() != null);\n                this.checkMask = false;\n            }\n\n            return ready;\n            \n        } else {\n            this.setBoundTexture(this.extraBound.sourceTile, this.extraBound.layer, this.extraBound.hmap);        \n            return this.isReady(doNotLoad, priority, doNotCheckGpu);\n        }\n        \n        return false;\n    }\n\n    /*\n    if (!this.extraBound && this.extraInfo && !this.maskTexture) {\n        var layer = this.extraInfo.layer;\n        \n        if (layer && layer.maskUrl && this.checkType != \"metatile\") {\n            var path = layer.getMaskUrl(this.tile.id);\n            this.maskTexture = this.tile.resources.getTexture(path, null, null, null, this.tile, this.internal);\n        }\n    }*/\n\n    switch (this.checkType) {\n    case VTS_TEXTURECHECK_MEATATILE:\n\n        if (this.checkStatus != 2) {\n            if (this.checkStatus == 0) {\n                if (this.extraInfo && this.extraInfo.tile) {\n                    var metaresources = this.extraInfo.tile.boundmetaresources;\n                    if (!metaresources) {\n                        metaresources = this.map.resourcesTree.findAgregatedNode(this.extraInfo.tile.id, 8);\n                        this.extraInfo.tile.boundmetaresources = metaresources;\n                    }\n                        \n                    var layer = this.extraInfo.layer;\n                    var path = this.extraInfo.metaPath;\n\t\t\t\t\t\t\n                    if(!this.extraInfo.metaPath) {\n                        path = layer.getMetatileUrl(metaresources.id);\t\n                        this.extraInfo.metaPath = path;\n                    }\n\t\t\t\t\t\t\n                    var texture = metaresources.getTexture(path, true, null, null, this.tile, this.internal);\n                        \n                    if (this.maskTexture) {\n                        if (this.maskTexture.isReady(doNotLoad, priority, doNotCheckGpu, this)) {\n                            this.checkStatus = 2;\n                        }\n                    } else {\n                        if (texture.isReady(doNotLoad, priority, doNotCheckGpu)) {\n                            var tile = this.extraInfo.tile;\n                            var value = texture.getHeightMapValue(tile.id[1] & 255, tile.id[2] & 255);\n                            this.checkStatus = (value & 128) ? 2 : -1;\n                                \n                            if (this.checkStatus == 2) {\n                                if (!(value & 64)) { //load mask\n                                    path = layer.getMaskUrl(tile.id);\n                                    this.maskTexture = tile.resources.getTexture(path, null, null, null, this.tile, this.internal);\n                                    this.checkStatus = 0;\n                                }\n                            }\n\n                            tile.resetDrawCommands = true;\n                            this.map.markDirty();\n                        }\n                    }\n                }\n            }\n                \n            if (this.checkStatus == -1) {\n                if (!this.extraBound) {\n                    parent = this.extraInfo.tile.parent;\n                    if (parent.id[0] < this.extraInfo.layer.lodRange[0]) {\n                        this.neverReady = true;\n                        this.extraInfo.tile.resetDrawCommands = true;\n                        this.map.markDirty();\n                        return false;\n                    }\n\n                    this.extraBound = { tile: this.extraInfo.tile, layer: this.extraInfo.layer};\n                    this.setBoundTexture(this.extraBound.tile.parent, this.extraBound.layer);\n                    this.checkMask = true;\n                }\n\n                while (this.extraBound.texture.extraBound || this.extraBound.texture.checkStatus == -1) {\n                    //while (this.extraBound.texture.checkStatus == -1) {\n                    parent = this.extraBound.sourceTile.parent;\n                    if (parent.id[0] < this.extraBound.layer.lodRange[0]) {\n                        this.neverReady = true;\n                        this.extraBound.tile.resetDrawCommands = true;\n                        this.map.markDirty();\n                        return false;\n                    }\n                        \n                    this.setBoundTexture(parent, this.extraBound.layer);        \n                }\n            }\n\n            return false;\n        }\n        \n        break;\n    }\n\n    var maskState = true;\n\n    if (this.maskTexture) {\n        maskState = this.maskTexture.isReady(doNotLoad, priority, doNotCheckGpu, this);\n    }\n    \n\n    return this.mainTexture.isReady(doNotLoad, priority, doNotCheckGpu, this) && maskState;\n};\n\nMapTexture.prototype.isMaskPosible = function() {\n    var texture = this;\n\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            texture = this.extraBound.texture;\n        }\n    }\n\n    if (texture.checkType == VTS_TEXTURECHECK_MEATATILE) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nMapTexture.prototype.isMaskInfoReady = function() {\n    var texture = this;\n\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            texture = this.extraBound.texture;\n        }\n    }\n\n    if (texture.checkType == VTS_TEXTURECHECK_MEATATILE) {\n        if (this.maskTexture || texture.checkStatus == 2 || texture.checkStatus ==  -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    return true;\n}\n\nMapTexture.prototype.getGpuTexture = function() {\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            return this.extraBound.texture.getGpuTexture();\n        }\n        return null;\n    } \n\n    return this.mainTexture.getGpuTexture();\n};\n\n\nMapTexture.prototype.getMaskTexture = function() {\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            return this.extraBound.texture.getMaskTexture();\n        }\n    } \n\n    return this.maskTexture;\n};\n\n\nMapTexture.prototype.getGpuMaskTexture = function() {\n    if (this.extraBound) {\n        if (this.extraBound.texture && this.extraBound.texture.maskTexture) {\n            return this.extraBound.texture.getGpuMaskTexture();\n        }\n        return null;\n    } \n\n    if (this.maskTexture) {\n        return this.maskTexture.getGpuTexture();\n    }\n    \n    return null;\n};\n\nMapTexture.prototype.getGpuSize = function() {\n    return (this.mainTexture ? (this.mainTexture.gpuSize ? this.mainTexture.gpuSize : 0) : 0) + (this.maskTexture ? (this.maskTexture.gpuSize ? this.maskTexture.gpuSize : 0) : 0);\n};\n\nMapTexture.prototype.getImageData = function() {\n    return this.mainTexture.imageData;\n};\n\n\nMapTexture.prototype.getImageExtents = function() {\n    return this.mainTexture.imageExtents;\n};\n\n\nMapTexture.prototype.getHeightMapValue = function(x, y) {\n    return this.mainTexture.getHeightMapValue(x, y);\n};\n\n\nMapTexture.prototype.getTransform = function() {\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            return this.extraBound.transform;\n        }\n        return null;\n    } \n\n    return [1,1,0,0];\n};\n\n\nexport default MapTexture;\n\n","\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar math = math_;\n\n\nvar MapTrajectory = function(map, p1, p2, options) {\n    this.map = map;\n    this.p1 = p1.clone();\n    this.p2 = p2.clone();\n    this.op2 = p2.clone();\n\n    var hm1 = this.p1.getHeightMode();\n    var hm2 = this.p2.getHeightMode();\n    \n    if (hm1 == 'fix' && hm2 == 'float') {\n        this.p1 = this.map.convert.convertPositionHeightMode(this.p1, 'float', true);\n    } else if (hm1 == 'float' && hm2 == 'fix') {\n        this.p1 = this.map.convert.convertPositionHeightMode(this.p1, 'fix', true);\n    } \n    \n    var vm1 = this.p1.getViewMode();\n    var vm2 = this.p2.getViewMode();\n\n    if (vm1 == 'subj' && vm2 == 'obj') {\n        this.p2 = this.map.convert.convertPositionViewMode(this.p2, 'subj');\n    } else if (vm1 == 'obj' && vm2 == 'subj') {\n        this.p1 = this.map.convert.convertPositionViewMode(this.p1, 'subj');\n    } \n    \n    this.p1.pos[5] = this.p1.pos[5] < 0 ? (360 + (this.p1.pos[5] % 360)) : (this.p1.pos[5] % 360);  \n    this.p2.pos[5] = this.p2.pos[5] < 0 ? (360 + (this.p2.pos[5] % 360)) : (this.p2.pos[5] % 360);  \n    \n    this.pp1 = this.p1.clone();\n\n    this.mode = options['mode'] || 'auto';\n    this.submode = options['submode'] || 'none';\n    this.submode = 'none';\n    this.maxHeight = options['maxHeight'] || 1000000000;\n    this.minDuration = options['minDuration'] || 0;\n    this.maxDuration = options['maxDuration'] || 10000;\n    this.samplePeriod = options['samplePeriod'] || 10;\n    this.fade = options['fade'] || 'none';\n    this.fadePower = options['fadePower'] || 1;\n    this.yawInterpolation = options['yawInterpolation'] || 'shortest';\n\n    this.pv = options['pv'] || 0.15;\n\n    if (!this.map.getNavigationSrs().isProjected()) {\n        this.geodesic = this.map.measure.getGeodesic();\n    } \n    \n    if (options['distanceAzimuth']) {\n        this.distanceAzimuth = true;\n        \n        this.pp2 = this.p1.clone();\n        if (options['destHeight']) {\n            this.pp2.setHeight(options['destHeight']);\n        }\n\n        if (options['destOrientation']) {\n            this.pp2.setHeight(options['destOrientation']);\n        }\n        \n        if (options['destFov']) {\n            this.pp2.setHeight(options['destFov']);\n        }\n\n        this.geoAzimuth = options['azimuth'] || 0; \n        this.geoDistance = options['distance'] || 100;\n        this.distance = this.geoDistance; \n        this.azimuth = this.geoAzimuth % 360;\n        this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;\n\n    } else {\n        this.distanceAzimuth = false;\n            \n        this.pp2 = this.p2.clone();\n\n        //get distance and azimut\n        var res = this.map.measure.getDistance(this.pp1.getCoords(), this.pp2.getCoords());\n        this.distance = res[0];\n        this.azimuth = (res[1] + 90) % 360;\n        this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;\n\n        if (!this.map.getNavigationSrs().isProjected()) {\n            res = this.geodesic.Inverse(this.pp1.pos[2], this.pp1.pos[1], this.pp2.pos[2], this.pp2.pos[1]);\n            this.geoAzimuth = res.azi1; \n            this.geoDistance = res.s12;\n            this.azimuth = this.geoAzimuth % 360;\n            this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;\n        }\n    }\n    \n    //console.log(\"azim: \" + Math.round(this.azimuth) + \" p1: \" + this.p1.pos[5]  + \" p2: \" + this.p2.pos[5]);\n\n    this.detectMode();\n    this.detectDuration();\n    this.detectFlightHeight(options['height']);\n};\n\n\nMapTrajectory.prototype.detectFlightHeight = function(flightHeight) {\n    if (this.mode == 'ballistic') {\n        this.flightHeight = Math.max(this.pp1.getHeight(), this.pp2.getHeight());\n        this.flightHeight += flightHeight || (this.distance * 0.5);\n        this.flightHeight = Math.min(this.flightHeight, this.maxHeight);\n        this.flightHeight -= Math.max(this.pp1.getHeight(), this.pp2.getHeight());\n    }\n};\n\n\nMapTrajectory.prototype.detectMode = function() {\n    if (this.mode == 'auto') {\n        this.mode = (this.distance > 2000) ? 'ballistic' : 'direct';\n    }\n};\n\n\nMapTrajectory.prototype.detectDuration = function() {\n    this.duration = 0;\n    this.headingDuration = 1000;\n    \n    if (this.distance < 500) {\n        this.duration = 1000;\n    } else if (this.distance < 2000) {\n        this.duration = 2000;\n    } else {\n        this.duration = this.distance / 100;\n\n        if (this.duration < 300) {\n            this.duration = 3000;\n        } else {\n            this.headingDuration = 1500;\n        }\n        \n        if (this.duration < 6000) {\n            this.duration = 6000;\n        }\n\n        if (this.duration > 10000) {\n            this.duration = 10000;\n        }\n\n        if (this.mode != 'direct') {\n            this.duration *= 1.8;\n            this.headingDuration *= 1.8;\n        }\n    }\n    \n    if (this.mode != 'direct') {\n        var minDuration = 3 * this.headingDuration; \n        this.duration = Math.max(this.duration, minDuration);\n        \n        if (this.maxDuration < minDuration) {\n            this.duration = this.maxDuration;\n            this.headingDuration = this.maxDuration / 3;\n        }   \n    }    \n    \n    this.duration = Math.min(this.duration, this.maxDuration);\n    this.duration = Math.max(this.duration, this.minDuration);\n};\n\n    \nMapTrajectory.prototype.generate = function() {\n    var samples = new Array(Math.ceil(this.duration / this.samplePeriod)+(this.distanceAzimuth?0:1));\n    var index = 0;\n    \n    for (var time = 0; time <= this.duration; time += this.samplePeriod) {\n        var factor = time / this.duration;\n\n        var p = this.pp1.clone(), x, coords;\n        \n        if (this.mode == 'direct') {\n\n            x = factor;\n            \n            switch(this.fade) {\n            case 'in':\n                switch(this.fadePower) {\n                case 1: factor = x*x; break;\n                case 2: factor = x*x*x; break;\n                case 3: factor = x*x*x*x; break;\n                case 4: factor = x*x*x*x*x; break;\n                case 5: factor = x*x*x*x*x*x; break;\n                case 6: factor = x*x*x*x*x*x*x; break;\n                }\n                break;\n\n            case 'out':\n                x = 1 - x;\n                switch(this.fadePower) {\n                case 1: factor = 1 - (x*x); break;\n                case 2: factor = 1 - (x*x*x); break;\n                case 3: factor = 1 - (x*x*x*x); break;\n                case 4: factor = 1 - (x*x*x*x*x); break;\n                case 5: factor = 1 - (x*x*x*x*x*x); break;\n                case 6: factor = 1 - (x*x*x*x*x*x*x); break;\n                }\n                break;\n\n            case 'inout':\n                switch(this.fadePower) {\n                case 1: factor = x*x*(3 - 2*x); break;\n                case 2: factor = x*x*x * (x * (6*x - 15) + 10); break;\n                case 3: factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); break;\n                case 4: factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); break;\n                case 5: factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); break;\n                case 6: factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); break;\n                }\n                break;\n            }\n            \n            p.setCoords(this.getInterpolatedCoords(factor));\n            p.setHeight(this.getInterpolatedHeight(factor));\n            \n            var o1 = this.pp1.getOrientation(); \n            var o2 = this.pp2.getOrientation(); \n\n            p.setOrientation(this.getInterpolatedOrinetation(o1, o2, factor));\n            p.setFov(this.getInterpolatedFov(factor));\n            p.setViewExtent(this.getInterpolatedViewExtent(factor));\n            \n            samples[index] = p.pos;\n            index++;\n        } else {\n\n            //http://en.wikipedia.org/wiki/Smoothstep\n            x = factor;\n            factor =  x*x*(3 - 2*x);\n            x = factor;\n            factor =  x*x*(3 - 2*x);\n\n            //factor2 includes slow start and end of flight\n            var factor2 =  this.getSmoothFactor(time);\n            \n            if (this.submode == 'piha') {\n                \n                var distanceFactor = (this.distance / this.duration * (time - this.duration / (2 * Math.PI) * Math.sin(2 * Math.PI / this.duration * time))) / this.distance;\n\n                //var f = (time / this.duration) * Math.PI * 2;\n                //var distanceFactor = ((f - Math.sin(f)) / (2 * Math.PI));\n                \n                var pv = this.pv;\n                var h1 = this.pp1.getCoords()[2]; \n                var h2 = this.pp2.getCoords()[2]; \n\n                var height = this.distance / ((this.duration*0.001) * pv * Math.tan(math.radians(this.pp1.getFov()) * 0.5))\n                              * (1 - Math.cos(2 * Math.PI * time / this.duration))\n                              + h1 + (h2 - h1) * time  / this.duration;\n\n                coords = this.getInterpolatedCoords(distanceFactor);\n\n                p.setCoords(coords);\n                p.setHeight(height);            \n            } else {\n\n                coords = this.getInterpolatedCoords(factor2);\n    \n                p.setCoords(coords);\n                p.setHeight(this.getSineHeight(factor));            \n            }\n            \n            if (coords[3] != null) { //used for correction in planet mode\n                this.azimuth = -coords[3];\n            }\n\n            p.setOrientation(this.getFlightOrienation(time));\n            p.setFov(this.getInterpolatedFov(factor));\n            p.setViewExtent(this.getInterpolatedViewExtent(factor));\n            \n            //p.convertViewMode(\"subj\");\n            //console.log(\"pos: \" + p.toString());\n\n            samples[index] = p.pos;\n            samples[index] = p.pos;\n            index++;\n        }\n    }\n    \n    if (!this.distanceAzimuth) {\n        samples[index] = this.op2.clone().pos;\n    }\n\n    //console.log(\"pos2: \" + this.p2.toString());\n\n    return samples;\n};\n\n\nMapTrajectory.prototype.getInterpolatedCoords = function(factor) {\n    var c1 = this.pp1.getCoords(); \n    var c2 = this.pp2.getCoords(); \n\n    if (!this.map.getNavigationSrs().isProjected()) {\n        var res = this.geodesic.Direct(c1[1], c1[0], this.geoAzimuth, this.geoDistance * factor);\n\n        var azimut = res.azi1 - res.azi2;\n\n        //var azimut = (azimut - 90) % 360;\n        azimut = (this.azimuth < 0) ? (360 + azimut) : azimut;\n\n        //azimut = this.azimuth;\n\n\n        return [ res.lon2, res.lat2,\n            c1[2] + (c2[2] - c1[2]) * factor, azimut];\n\n    } else {\n        return [ c1[0] + (c2[0] - c1[0]) * factor,\n            c1[1] + (c2[1] - c1[1]) * factor,\n            c1[2] + (c2[2] - c1[2]) * factor ];\n    }\n};\n\n\nMapTrajectory.prototype.getInterpolatedOrinetation = function(o1, o2, factor) {\n    var od1 = o2[0] - o1[0];\n    var od2 = o2[1] - o1[1];\n    var od3 = o2[2] - o1[2];\n\n    if (this.yawInterpolation == 'shortest' || this.yawInterpolation == 'longest') {\n        if (Math.abs(od1) > 180) {\n            if (od1 > 0) {\n                od1 = -(360 - od1);\n            } else {\n                od1 = 360 - Math.abs(od1);\n            }\n        }\n    }\n\n    if (this.yawInterpolation == 'longest') {\n        if (od1 < 0) {\n            od1 = 360 + od1;\n        } else {\n            od1 = (-360) + od1;\n        }\n    }\n\n    return [ o1[0] + od1 * factor,\n        o1[1] + od2 * factor,\n        o1[2] + od3 * factor ];\n};\n\n\nMapTrajectory.prototype.getInterpolatedFov = function(factor) {\n    var f1 = this.pp1.getFov(); \n    var f2 = this.pp2.getFov(); \n    return f1 + (f2 - f1) * factor;\n};\n\n\nMapTrajectory.prototype.getInterpolatedViewExtent = function(factor) {\n    var v1 = this.pp1.getViewExtent(); \n    var v2 = this.pp2.getViewExtent(); \n    return v1 + (v2 - v1) * factor;\n};\n\n\nMapTrajectory.prototype.getInterpolatedHeight = function(factor) {\n    var h1 = this.pp1.getHeight(); \n    var h2 = this.pp2.getHeight(); \n    return h1 + (h2 - h1) * factor;\n};\n\n\nMapTrajectory.prototype.getSineHeight = function(factor) {\n    var c1 = this.pp1.getCoords(); \n    var c2 = this.pp2.getCoords(); \n\n    return c1[2] + (c2[2] - c1[2]) * factor +\n           Math.sin(Math.PI * factor) * this.flightHeight;\n};\n\n\nMapTrajectory.prototype.getSmoothFactor = function(time) {\n    var x = 0;\n\n    if (time < this.headingDuration) {\n        x = 0;\n    } else if (time > (this.duration - this.headingDuration)) {\n        x = 1.0;\n    } else {\n        x = Math.min(1.0, (time-this.headingDuration) / (this.duration - this.headingDuration*2));\n    }\n\n    x = x*x*(3 - 2*x);\n    return x*x*(3 - 2*x);\n};\n\n\nMapTrajectory.prototype.getFlightOrienation = function(time) {\n    var o1 = null;\n    var o2 = null;\n    var fo = [0, -90, 0]; //flight orientation\n    var factor = 0;\n\n    //get fly direction angle\n    fo[0] = this.azimuth % 360;\n\n    if (fo[0] < 0) {\n        fo[0] = 360 - Math.abs(fo[0]);\n    }\n\n    if (time <= this.headingDuration) { //start sequence\n        factor = time / this.headingDuration;\n        o1 = this.pp1.getOrientation();\n        o2 = fo;\n    } else if (time >= this.duration - this.headingDuration) { //end sequence\n        factor = (time - (this.duration - this.headingDuration)) / this.headingDuration;\n        o1 = fo;\n        o2 = this.pp2.getOrientation();\n    } else { //fly sequence\n        factor = 0;\n        o1 = fo;\n        o2 = fo;\n    }    \n    \n    return this.getInterpolatedOrinetation(o1, o2, factor);\n};\n\n\nexport default MapTrajectory;\n\n\n\n","\nimport {utils as utils_} from '../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../utils/url';\n\n//get rid of compiler mess\nvar utilsUrl = utilsUrl_;\nvar utils = utils_;\n\n\nvar MapUrl = function(map, path) {\n    this.map = map;\n\n    path = path.trim();\n    this.baseUrl = utilsUrl.getBase(path);\n    this.baseUrlSchema = utilsUrl.getSchema(path);\n    this.baseUrlOrigin = utilsUrl.getOrigin(path); \n\n    this.urlCounter = 0;\n};\n\n\nMapUrl.prototype['quad'] = function(lod, ix, iy) {\n    var quadKey = '';\n    //ty = Math.pow(2,zoom - 1) - ty;\n    for (var i = lod; i > 0; i--) {\n        var digit = 0;\n        var mask = 1 << (i-1);\n        if ((ix & mask) != 0) {\n            digit += 1;\n        }\n\n        if ((iy & mask) != 0) {\n            digit += 2;\n        }\n\n        quadKey += digit;\n    }\n\n    return quadKey;\n};\n\n\nMapUrl.prototype['msDigit'] = function(iy, ix) {\n    return (((iy & 3) << 1) + (ix & 1));\n};\n\n\nMapUrl.prototype.hex = function(v) {\n    var s = v.toString(16);\n    while (s.length < 8) {\n        s = '0' + s;\n    }\n    return s;\n};\n\n\nMapUrl.prototype['ppx'] = function(lod, ix) {\n    return this.hex(ix << (28 - lod), 7);\n};\n\n\nMapUrl.prototype['ppy'] = function(lod, iy) {\n    return this.hex((1 << 28) - ((iy + 1) << (28 - lod)), 7);\n};\n\n\nMapUrl.prototype.processUrlFunction = function(id, counter, string) {\n    var string2, fc;\n    if (typeof string == 'string') {\n        if (string.indexOf('quad') != -1) {\n            string2 = '(function(lod,x,y,loclod,locx,locy){' + string.replace('quad', 'return this.quad') + '})';\n\n            try {\n                fc = eval(string2).bind(this);\n                return fc(id.lod, id.ix, id.iy, id.loclod, id.locx, id.locy);\n            } catch(e) {\n                return string;\n            }\n        } else if (string.indexOf('msdigit') != -1) {\n            string2 = '(function(x,y,loclod,locx,locy){' + string.replace('msdigit', 'return this.msDigit') + '})';\n\n            try {\n                fc = eval(string2).bind(this);\n                return fc(id.ix, id.iy, id.loclod, id.locx, id.locy);\n            } catch(e) {\n                return string;\n            }\n\n        } else if (string.indexOf('alt') != -1) {\n            var result = /\\(([^)]*)\\)/.exec(string);\n\n            if (result && result[1]) {\n                var strings = result[1].match(/([^,]+)/g);\n\n                if (strings.length > 0) {\n                    return strings[(counter % strings.length)];\n                }\n            }\n\n            return string;\n\n        } else if (string.indexOf('ppx') != -1) {\n            string2 = '(function(lod,x,loclod,locx){' + string.replace('ppx', 'return this.ppx') + '})';\n\n            try {\n                fc = eval(string2).bind(this);\n                return fc(id.lod, id.ix, id.loclod, id.locx);\n            } catch(e) {\n                return string;\n            }\n\n        } else if (string.indexOf('ppy') != -1) {\n            string2 = '(function(lod,y,loclod,locy){' + string.replace('ppy', 'return this.ppy') + '})';\n\n            try {\n                fc = eval(string2).bind(this);\n                return fc(id.lod, id.iy, id.loclod, id.locy);\n            } catch(e) {\n                return string;\n            }\n\n        } else {\n            return string;\n        }\n\n    } else {\n        return string;\n    }\n};\n\n\nMapUrl.prototype.findLocalRoot = function(id) {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n    var validNodes = [];  \n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i];\n        \n        var delta = id[0] - node.id[0];\n        var ix = id[1] >> delta;\n        var iy = id[2] >> delta;\n        \n        if (ix == node.id[1] && iy == node.id[2]) {\n            validNodes.push(node);           \n        }\n    }\n\n    var bestNode = null;\n    var bestLod = -1;\n    \n    for (i = 0, li = validNodes.length; i < li; i++) {\n        if (validNodes[i].id[0] > bestLod) {\n            bestNode = validNodes[i]; \n        }\n    }\n    \n    if (bestNode) {\n        return bestNode.id.slice();\n    } else {\n        return [0,0,0];\n    }\n};\n\n\nMapUrl.prototype.makeUrl = function(templ, id, subId, skipBaseUrl) {\n    //if (templ.indexOf(\"jpg\") != -1) {\n       //templ = \"{lod}-{easting}-{northing}.jpg?v=4\";\n       //templ = \"{lod}-{x}-{y}.jpg?v=4\";\n       //templ = \"{quad(lod,x,y)}.jpg?v=4\";\n       //templ = \"{quad(lod,x+1,y*2)}.jpg?v=4\";\n       //templ = \"{lod}-{msdigit(x,y)}.jpg?v=4\";\n    //}\n    //templ = \"maps{alt(1,2,3,4)}.irist-test.citationtech.net/map/{lod}-{x}-{y}.jpg?v=4\";\n\n    var locx = 0;\n    var locy = 0;\n    var loclod = 0;\n\n    if (id.lod) {\n        var localRoot = this.findLocalRoot([id.lod, id.ix, id.iy]);    \n        loclod = id.lod - localRoot[0];\n        var mask = (1 << loclod) - 1;\n        locx = id.ix & mask;\n        locy = id.iy & mask;        \n    }\n    \n    var id2 = {\n        lod: id.lod,\n        ix : id.ix,\n        iy : id.iy,\n        loclod: loclod,\n        locx : locx,\n        locy : locy\n    };\n\n    //remove white spaces from template\n    templ = templ.replace(/ /g, '');\n\n    var url = utils.simpleFmtObjOrCall(templ, {'lod':id.lod,  'x':id.ix, 'y':id.iy, 'sub': subId,\n        'locx':locx, 'locy':locy, 'loclod':loclod, 'geonavtile': subId,\n        'hereappid': 'abcde', 'hereappcode':'12345'},\n                                               this.processUrlFunction.bind(this, id2, this.urlCounter));\n\n    this.urlCounter++;\n\n    skipBaseUrl = (url.indexOf('//') != -1);\n\n    /* //useful for debug\n    var tmp;\n\n    if (skipBaseUrl) {\n        tmp =  url;\n    } else {\n        tmp = this.baseUrl + url;\n    }\n    */\n\n    if (skipBaseUrl) {\n        if (url.indexOf('//') == 0) {\n            return this.baseUrlSchema + url;\n        } else {\n            return url;\n        }\n    } else {\n        return this.baseUrl + url;\n    }\n};\n\n\nMapUrl.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n    \n    url = url.trim();\n\n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.baseUrlOrigin + url;\n    } else {  //relative\n        return this.baseUrl + url; \n    }\n};\n\n\nexport default MapUrl;\n\n","\nvar MapView = function(map, json, fixPaths) {\n    this.map = map;\n    //this.id = json[\"id\"] || null;\n    this.parse(json, fixPaths);\n};\n\n\nMapView.prototype.parse = function(json, fixPaths) {\n    //this.description = json['description'] || '';\n    //this.boundLayers = json[\"boundLayers\"] || [];\n    this.freeLayers = json['freeLayers'] || {};\n    this.surfaces = {};    \n    this.options = json['options'] || {};    \n\n    if (json['surfaces']) {\n        var surfaces = json['surfaces']; \n        if (Array.isArray(surfaces)) { //convert from old version\n            for (var i = 0, li = surfaces.length; i < li; i++) {\n                this.surfaces[surfaces[i]] = [];\n            }\n        } else {\n            this.surfaces = surfaces;            \n        }\n    }\n\n    if (!this.freeLayers || Array.isArray(this.freeLayers)) { //convert from old version\n        this.freeLayers = {};\n    } else {\n        this.freeLayers = JSON.parse(JSON.stringify(this.freeLayers));\n\n        if (fixPaths) {\n            for (var key in this.freeLayers) {\n                var layer = this.freeLayers[key];\n\n                if (typeof layer['style'] === 'string') {\n                    layer['style'] = this.processUrl(layer['style'], '');\n                }\n            }\n        }\n    }\n    \n    this.surfaces = JSON.parse(JSON.stringify(this.surfaces));\n    this.options = JSON.parse(JSON.stringify(this.options));\n};\n\n\nMapView.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n\n    if (typeof url !== 'string') {\n        return url;\n    }\n\n    url = url.trim();\n\n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.map.url.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.map.url.baseUrlOrigin + url;\n    } else {  //relative\n        return this.map.url.baseUrl + url; \n    }\n};\n\n\nMapView.prototype.getInfo = function() {\n    var view = {\n        //'description' : JSON.parse(JSON.stringify(this.description)),\n        'surfaces' : JSON.parse(JSON.stringify(this.surfaces)),\n        'freeLayers' : JSON.parse(JSON.stringify(this.freeLayers)),\n        'options' : JSON.parse(JSON.stringify(this.options)),\n    };\n\n    var renderer = this.map.renderer;\n\n    if (this.map.renderer.getSuperElevationState()) {\n        var se = this.map.renderer.getSuperElevation();\n\n        view['options'] = {\n            'superelevation' : [[se[0],se[2]],[se[1],se[3]]]\n        }\n    }\n\n    return view;\n};\n\n\nexport default MapView;\n\n","\nimport {utils as utils_} from '../utils/utils';\nimport BBox_ from '../renderer/bbox';\n\n//get rid of compiler mess\nvar BBox = BBox_;\nvar utils = utils_;\n\n\nvar MapVirtualSurface = function(map, json) {\n    this.map = map;\n    this.id = null;\n    this.metaUrl = '';\n    this.mappingUrl = '';\n    this.baseUrl = this.map.url.baseUrl;\n    this.baseUrlSchema = this.map.url.baseUrlSchema;\n    this.baseUrlOrigin = this.map.url.baseUrlOrigin;\n    this.lodRange = [0,0];\n    this.tileRange = [[0,0],[0,0]];\n    this.surfaces = [];\n    this.parseJson(json);\n    this.virtual = true;\n    this.ready = false;\n};\n\n\nMapVirtualSurface.prototype.parseJson = function(json) {\n    this.id = json['id'] || null;\n    this.metaUrl = this.processUrl(json['metaUrl'], '');\n    this.mappingUrl = this.processUrl(json['mapping'], '');\n    this.lodRange = json['lodRange'] || [0,0];\n    this.tileRange = json['tileRange'] || [[0,0],[0,0]];\n    this.strId = this.id ? this.id.join(';') : null;\n\n    if (this.id) {\n        var tmp = this.id.slice();\n        tmp.sort(); \n        this.strId = tmp.join(';');\n    }\n\n    if (json['extents']) {\n        var ll = json['extents']['ll'];\n        var ur = json['extents']['ur'];\n        this.extents = new BBox(ll[0], ll[1], ll[2], ur[0], ur[1], ur[2]);\n    } else {\n        this.extents = new BBox(0,0,0,1,1,1);\n    }\n\n    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    \n\n    utils.loadBinary(this.mappingUrl, this.onMappingFileLoaded.bind(this), this.onMappingFileLoadError.bind(this), (utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n};\n\n\nMapVirtualSurface.prototype.onMappingFileLoaded = function(data) {\n    this.parseMappingFile(new DataView(data));            \n    this.ready = true;\n    this.map.refreshView();\n};\n\n\nMapVirtualSurface.prototype.onMappingFileLoadError = function() {\n};\n\n\nMapVirtualSurface.prototype.parseMappingFile = function(data) {\n    var index = 0;\n\n    var magic = '';\n    magic += String.fromCharCode(data.getUint8(index, true)); index += 1;\n    magic += String.fromCharCode(data.getUint8(index, true)); index += 1;\n\n    if (magic != 'TM') {\n        return false;\n    }\n\n    var count = data.getUint16(index, true); index += 2;\n\n    for (var i = 0; i < count; i++) {\n        var size = data.getUint8(index, true); index += 1;\n        var id = [];\n\n        for (var j = 0; j < size; j++) {\n            var s = data.getUint16(index, true); index += 2;\n            s = this.id[s];\n            \n            if (s) {\n                id.push(s);\n            }\n        }\n        \n        if (id.length == 1) { //get surface\n            this.surfaces.push(this.map.getSurface(id[0]));\n        } else { //get glue\n            this.surfaces.push(this.map.getGlue(id.join(';')));\n        }\n    }\n\n    return true;    \n};\n\n\nMapVirtualSurface.prototype.getInfo = function() {\n    return {\n        'metaUrl' : this.metaUrl,\n        'mapping' : this.mappingUrl,\n        'lodRange' : this.lodRange,\n        'tileRange' : this.tileRange\n    };\n};\n\n\nMapVirtualSurface.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n\n    url = url.trim();\n    \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.baseUrlOrigin + url;\n    } else {  //relative\n        return this.baseUrl + url; \n    }\n};\n\n\nMapVirtualSurface.prototype.hasTile = function(id) {\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift < 0) {\n        return false;\n    }\n\n    var x = id[1] >> shift;\n    var y = id[2] >> shift;\n\n    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||\n        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n        return false;\n    }\n\n    return true;\n};\n\n\nMapVirtualSurface.prototype.hasTile2 = function(id) {\n    var shift = id[0] - this.lodRange[0];\n    var above = (shift < 0);\n\n    if (id[0] < this.lodRange[0]) {\n        shift = -shift;\n        var x1 = this.tileRange[0][0] >> shift;\n        var y1 = this.tileRange[0][1] >> shift;\n        var x2 = this.tileRange[1][0] >> shift;\n        var y2 = this.tileRange[1][1] >> shift;\n    \n        if (id[0] > this.lodRange[1] ||\n            id[1] < x1 || id[1] > x2 ||\n            id[2] < y1 || id[2] > y2 ) {\n            return [false , false];\n        }\n    } else {\n        var x = id[1] >> shift;\n        var y = id[2] >> shift;\n    \n        if (id[0] > this.lodRange[1] ||\n            x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n            return [false , false];\n        }\n    }\n\n    return [true, above];\n};\n\n\nMapVirtualSurface.prototype.hasMetatile = function(id) {\n    if (id[0] > this.lodRange[1]) {\n        return false;\n    }\n\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift >= 0) {\n        var x = id[1] >> shift;\n        var y = id[2] >> shift;\n\n        if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n            return false;\n        }\n\n    } else {\n        shift = -shift;\n\n        if (id[1] < (this.tileRange[0][0]>>shift) || id[1] > (this.tileRange[1][0]>>shift) ||\n            id[2] < (this.tileRange[0][1]>>shift) || id[2] > (this.tileRange[1][1]>>shift) ) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\n//used only for glues\nMapVirtualSurface.prototype.getSurface = function(index) {\n    return this.surfaces[index - 1];\n};\n\n\nMapVirtualSurface.prototype.getMetaUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nexport default MapVirtualSurface;\n\n","\nvar BBox = function(xmin, ymin, zmin, xmax, ymax, zmax) {\n    this.min = [];\n    this.max = [];\n\n    this.min[0] = (xmin != null) ? xmin : Number.POSITIVE_INFINITY;\n    this.min[1] = (ymin != null) ? ymin : Number.POSITIVE_INFINITY;\n    this.min[2] = (zmin != null) ? zmin : Number.POSITIVE_INFINITY;\n\n    this.max[0] = (xmax != null) ? xmax : Number.NEGATIVE_INFINITY;\n    this.max[1] = (ymax != null) ? ymax : Number.NEGATIVE_INFINITY;\n    this.max[2] = (zmax != null) ? zmax : Number.NEGATIVE_INFINITY;\n\n    this.updateMaxSize();\n};\n\n\nBBox.prototype.clone = function() {\n    return new BBox(this.min[0], this.min[1], this.min[2],\n                    this.max[0], this.max[1], this.max[2]);\n};\n\n\nBBox.prototype.side = function(index) {\n    return this.max[index] - this.min[index];\n};\n\n\nBBox.prototype.updateMaxSize = function() {\n    this.maxSize = Math.abs(Math.max(this.max[0] - this.min[0],\n                                     this.max[1] - this.min[1],\n                                     this.max[2] - this.min[2]));\n};\n\n\nBBox.prototype.center = function(vec) {\n    if (vec != null) {\n        vec[0] = (this.min[0] + this.max[0])*0.5;\n        vec[1] = (this.min[1] + this.max[1])*0.5;\n        return vec;\n    } else {\n        if (!this.middle) {\n            this.middle = [(this.min[0] + this.max[0])*0.5, (this.min[1] + this.max[1])*0.5, (this.min[2] + this.max[2])*0.5];\n\n            if (isNaN(this.middle[0])) {\n                this.middle[0] = 0;\n            }\n\n            if (isNaN(this.middle[1])) {\n                this.middle[1] = 0;\n            }\n\n            if (isNaN(this.middle[2])) {\n                this.middle[2] = 0;\n            }\n        } \n\n        return this.middle;\n    }\n};\n\n\nBBox.prototype.translateXY = function(delta) {\n    return new BBox(this.min[0] - delta[0], this.min[1] - delta[1], this.min[2],\n                    this.max[0] - delta[0], this.max[1] - delta[1], this.max[2]);\n};\n\n\nexport default BBox;\n\n","\nimport {vec3 as vec3_, vec4 as vec4_, mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar vec3 = vec3_, vec4 = vec4_, mat4 = mat4_;\nvar math = math_;\n\n\nvar Camera = function(parent, fov, near, far) {\n    this.parent = parent;\n    this.position = [0,0,0];\n    this.orientation = [0,0,0];\n    this.aspect = 1;\n    this.fov = fov;\n    this.fovTan = Math.tan(fov * Math.PI / 180.0);\n    this.fovDist = 1;\n    this.near = near;\n    this.far = far;\n    this.rotationByMatrix = false;\n\n    // derived quantities, calculated from camera parameters by update()\n    this.modelview = mat4.create();\n    this.rotationview = mat4.create();\n    this.projection = mat4.create();\n    this.mvp = mat4.create();\n    this.mvp32 = new Float32Array(16);\n    this.modelview32 = new Float32Array(16);\n    this.rotationview32 = new Float32Array(16);\n    this.projection32 = new Float32Array(16);\n\n    this.frustumPlanes = [ [0,0,0,0], [0,0,0,0], [0,0,0,0],\n                           [0,0,0,0], [0,0,0,0], [0,0,0,0] ];\n    this.bboxPoints = [\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ]\n    ];\n\n    //reduce garbage collection\n    this.scaleFactorVec = [0,0,0,0];\n    this.dirty = true;\n};\n\n\nCamera.prototype.setPosition = function(position) {\n    this.position = position;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setOrientation = function(orientation) {\n    this.rotationByMatrix = false;\n    this.orientation = orientation;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setRotationMatrix = function(matrix){\n    this.rotationByMatrix = true;\n    this.rotationview = matrix.slice();\n    this.dirty = true;\n};\n\n\n// Sets the viewport aspect ratio (width / height). Should be called\n// whenever the rendering viewport changes.\nCamera.prototype.setAspect = function(aspect) {\n    this.aspect = aspect;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setViewHeight = function(height) {\n    this.viewHeight = height;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setOrtho = function(state) {\n    this.ortho = state;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setParams = function(fov, near, far) {\n    this.fov = fov;\n    this.near = near;\n    this.far = far;\n    this.dirty = true;\n};\n\n\nCamera.prototype.clone = function(newFov) {\n    var camera = new Camera(this. parent, (newFov != null) ? newFov : this.getFov(), this.getNear(), this.getFar());\n\n    camera.setPosition(this.getPosition());\n    camera.setOrientation(this.getOrientation());\n    camera.setAspect(this.getAspect());\n    camera.update();\n\n    return camera;\n};\n\n\n// simple getters\nCamera.prototype.getPosition = function(){ return [this.position[0], this.position[1], this.position[2]]; };\nCamera.prototype.getOrientation = function(){ return [this.orientation[0], this.orientation[1], this.orientation[2]]; };\nCamera.prototype.getAspect = function(){ return this.aspect; };\nCamera.prototype.getFov = function(){ return this.fov; };\nCamera.prototype.getNear = function(){ return this.near; };\nCamera.prototype.getFar = function(){ return this.far; };\nCamera.prototype.getViewHeight = function(){ return this.viewHeight; };\nCamera.prototype.getOrtho = function(){ return this.ortho; };\n\n\n// Returns rotation matrix\nCamera.prototype.getRotationviewMatrix = function() {\n    if (this.dirty) this.update();\n    return this.rotationview;\n};\n\nCamera.prototype.getRotationviewFMatrix = function() {\n    if (this.dirty) this.update();\n    return this.rotationview32;\n};\n\n// Returns a matrix that transforms the world space to camera space.\nCamera.prototype.getModelviewMatrix = function(){\n    if (this.dirty) this.update();\n    return this.modelview;\n};\n\nCamera.prototype.getModelviewFMatrix = function(){\n    if (this.dirty) this.update();\n    return this.modelview32;\n};\n\n\n// Returns a matrix that transforms the camera space to screen space.\nCamera.prototype.getProjectionMatrix = function() {\n    if (this.dirty) this.update();\n    return this.projection;\n};\n\nCamera.prototype.getProjectionFMatrix = function() {\n    if (this.dirty) this.update();\n    return this.projection32;\n};\n\n\n// Returns projectionMatrix() * modelviewMatrix()\nCamera.prototype.getMvpMatrix = function() {\n    if (this.dirty) this.update();\n    return this.mvp;\n};\n\nCamera.prototype.getMvpFMatrix = function() {\n    if (this.dirty) this.update();\n    return this.mvp32;\n};\n\n// Returns how much a length unit located at a point in world space is\n// stretched when projected to the sceen space.\nCamera.prototype.scaleFactor = function(worldPos, returnDist) {\n    if (this.dirty) this.update();\n\n    //var camPos = vec4.create();\n    //mat4.multiplyVec4(this.modelview, worldPos, camPos);\n    mat4.multiplyVec3(this.modelview, worldPos, this.scaleFactorVec);\n    var dist = vec3.length(this.scaleFactorVec); // distance from camera\n\n    // the expression \"projection(0,0) / depth\" is the derivative of the\n    // screen X position by the camera space X coordinate.\n\n    // ('dist' is used instead of camera depth (camPos(2)) to make the tile\n    // resolution independent of camera rotation)\n\n    if (returnDist) {\n        if (dist < this.near) return [Number.POSITIVE_INFINITY, dist];\n        return [this.projection[0] / dist, dist]; \n        //return [(this.projection[5]*0.5) / dist, dist]; //projection by sy\n    }\n\n    if (dist < this.near) return Number.POSITIVE_INFINITY;\n    return this.projection[0] / dist;\n    //return (this.projection[5]*0.5) / dist; //projection by sy\n};\n\n\nCamera.prototype.scaleFactor2 = function(dist) {\n    if (this.dirty) this.update();\n\n    if (dist < this.near) return Number.POSITIVE_INFINITY;\n    return this.projection[0] / dist;\n    //return (this.projection[5]*0.5) / dist; //projection by sy\n};\n\n\nCamera.prototype.distance = function(worldPos) {\n    var delta = vec3.create();\n    vec3.subtract(this.position, worldPos, delta);\n    return vec3.length(delta);\n};\n\n\n// Returns true if point is inside camera frustum.\nCamera.prototype.pointVisible = function(point, shift) {\n    if (this.dirty) this.update();\n\n    var p;\n\n    if (shift) {\n        p = [ point[0] - shift[0], point[1] - shift[1], point[2] - shift[2], 1 ];\n    } else {\n        p = [ point[0], point[1], point[2], 1 ];\n    }\n\n    // test all frustum planes quickly\n    for (var i = 0; i < 6; i++) {\n        // check if point lie on the negative side of the frustum plane\n        if (vec4.dot(this.frustumPlanes[i], p) < 0) {\n            return false;\n        }\n    }\n\n    // the box might be inside - further testing should be done here - TODO!\n    return true;\n};\n\n\n// Returns true if the box intersects the camera frustum.\nCamera.prototype.pointsVisible = function(points, shift) {\n    if (this.dirty) this.update();\n   \n    var planes = this.frustumPlanes;\n    var lj = points.length, sx, sy, sz;\n\n    if (shift) {\n        sx = shift[0];\n        sy = shift[1];\n        sz = shift[2];\n    } else {\n        sx = 0;\n        sy = 0;\n        sz = 0;\n    }\n        \n    var dot = vec4.dot3;\n\n    // test all frustum planes quickly\n    for (var i = 0; i < 6; i++) {\n        // check if all points lie on the negative side of the frustum plane\n        var negative = true;\n        var plane = planes[i];\n        for (var j = 0; j < lj; j+=3) {\n            if (dot(plane, points, j, sx, sy, sz) >= 0) {\n                //return false;\n                negative = false;\n                break;\n            }\n        }\n        if (negative) return false;\n    }\n\n    return true;\n};\n\n\nCamera.prototype.pointsVisible2 = function(points, shift) {\n    if (this.dirty) this.update();\n   \n    var planes = this.frustumPlanes;\n    var lj = points.length, sx, sy, sz;\n\n    if (shift) {\n        sx = shift[0];\n        sy = shift[1];\n        sz = shift[2];\n    } else {\n        sx = 0;\n        sy = 0;\n        sz = 0;\n    }\n        \n    var dot = vec4.dot3;\n\n    // test all frustum planes quickly\n    for (var i = 0; i < 6; i++) {\n        // check if all points lie on the negative side of the frustum plane\n        var negative = true;\n        var plane = planes[i];\n        for (var j = 0; j < lj; j++) {\n            if (dot(plane, points[j], 0, sx, sy, sz) >= 0) {\n                //return false;\n                negative = false;\n                break;\n            }\n        }\n        if (negative) return false;\n    }\n\n    return true;\n};\n\n\n// Returns true if the box intersects the camera frustum.\nCamera.prototype.bboxVisible = function(bbox, shift) {\n    if (this.dirty) this.update();\n\n    var min = bbox.min;\n    var max = bbox.max;\n    var points = this.bboxPoints;\n    var p, minX, minY, minZ, maxX, maxY, maxZ;\n\n    if (shift) {\n        minX = min[0] - shift[0];        \n        minY = min[1] - shift[1];        \n        minZ = min[2] - shift[2];        \n       \n        maxX = max[0] - shift[0];        \n        maxY = max[1] - shift[1];        \n        maxZ = max[2] - shift[2];        \n    } else {\n        minX = min[0];        \n        minY = min[1];        \n        minZ = min[2];        \n\n        maxX = max[0];        \n        maxY = max[1];        \n        maxZ = max[2];        \n    }\n\n    p = points[0];\n    p[0] = minX;  p[1] = minY; p[2] = minZ; \n    p = points[1];\n    p[0] = minX;  p[1] = minY; p[2] = maxZ; \n    p = points[2];\n    p[0] = minX;  p[1] = maxY; p[2] = minZ; \n    p = points[3];\n    p[0] = minX;  p[1] = maxY; p[2] = maxZ; \n\n    p = points[4];\n    p[0] = maxX;  p[1] = minY; p[2] = minZ; \n    p = points[5];\n    p[0] = maxX;  p[1] = minY; p[2] = maxZ; \n    p = points[6];\n    p[0] = maxX;  p[1] = maxY; p[2] = minZ; \n    p = points[7];\n    p[0] = maxX;  p[1] = maxY; p[2] = maxZ; \n\n\n    var dot = vec4.dot2;\n    var planes = this.frustumPlanes;\n\n    // test all frustum planes quickly\n    for (var i = 0; i < 6; i++) {\n        // check if all points lie on the negative side of the frustum plane\n        var negative = true;\n        var plane = planes[i];\n        for (var j = 0; j < 8; j++) {\n            if (dot(plane, points[j]) >= 0) {\n                //return false;\n                negative = false;\n                break;\n            }\n        }\n        if (negative) return false;\n    }\n\n    // the box might be inside - further testing should be done here - TODO!\n    return true;\n};\n\n\nCamera.prototype.update = function(zoffset) {\n    // modelview matrix, this is essentially the inverse of a matrix that\n    // brings the camera from the origin to its world position (the inverse\n    // is trivial here -- negative angles, reverse order of transformations)\n    //this.modelview = mat4.create();\n\n    if (!this.rotationByMatrix) {\n        mat4.multiply(math.rotationMatrix(2, math.radians(-this.orientation[2])), math.rotationMatrix(0, math.radians(-this.orientation[1] - 90.0)), this.rotationview);\n        mat4.multiply(this.rotationview, math.rotationMatrix(2, math.radians(-this.orientation[0])), this.rotationview);\n    }\n\n    mat4.multiply(this.rotationview, math.translationMatrix(-this.position[0], -this.position[1], -this.position[2]), this.modelview);\n\n    if (this.ortho) {\n        this.projection = math.orthographicMatrix(this.viewHeight, this.aspect, this.near, this.far);\n    } else {\n        this.projection = math.perspectiveMatrix(this.fov, this.aspect, this.near, this.far);\n    }\n\n    mat4.multiply(this.projection, this.modelview, this.mvp);\n\n    // prepare frustum planes (in normalized device coordinates)\n    this.frustumPlanes[0] = [ 0, 0, 1, 1 ]; // far\n    this.frustumPlanes[1] = [ 0, 0,-1, 1 ]; // near\n    this.frustumPlanes[2] = [ 1, 0, 0, 1 ]; // left\n    this.frustumPlanes[3] = [-1, 0, 0, 1 ]; // right\n    this.frustumPlanes[4] = [ 0, 1, 0, 1 ]; // bottom\n    this.frustumPlanes[5] = [ 0,-1, 0, 1 ]; // top\n\n    // transform the frustum planes to the world space, remember that\n    // planes in homogeneous coordinates transform as p' = M^{-T} * p, where\n    // M^{-T} is the transpose of inverse of M\n    var mvpt = mat4.create();\n    mat4.transpose(this.mvp, mvpt); //without zoffset\n    for (var i = 0; i < 6; i++) {\n        this.frustumPlanes[i] = mat4.multiplyVec4(mvpt, this.frustumPlanes[i]);\n    }\n\n    this.mvp32.set(this.mvp);\n    this.projection32.set(this.projection);\n    this.modelview32.set(this.modelview);\n    this.rotationview32.set(this.rotationview);\n\n    this.fovDist = (this.parent.curSize[1] *0.5) / this.fovTan;\n\n    // the derived quantities are now in sync with the parameters\n    this.dirty = false;\n};\n\n\nexport default Camera;\n","\nimport {vec3 as vec3_, mat3 as mat3_, mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport {processGMap as processGMap_, processGMap4 as processGMap4_, processGMap5 as processGMap5_,\n        processGMap6 as processGMap6_, processGMap7 as processGMap7_, radixDepthSortFeatures as radixDepthSortFeatures_ } from './gmap';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat3 = mat3_, mat4 = mat4_;\nvar math = math_;\nvar processGMap = processGMap_;\nvar processGMap4 = processGMap4_;\nvar processGMap5 = processGMap5_;\nvar processGMap6 = processGMap6_;\nvar processGMap7 = processGMap7_;\nvar radixDepthSortFeatures = radixDepthSortFeatures_;\n\n\nvar RendererDraw = function(renderer) {\n    this.renderer = renderer;\n    this.core = renderer.core;\n    this.gpu = renderer.gpu;\n    this.gl = renderer.gpu.gl;\n    this.rmap = renderer.rmap;\n    this.mBuffer = new Float32Array(16);\n    this.mBuffer2 = new Float32Array(16);\n    this.vBuffer = new Float32Array(4);\n};\n\n\nRendererDraw.prototype.drawSkydome = function(texture, shader) {\n    if (!texture) {\n        return;\n    }\n\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n    \n    var lower = 400; // put the dome a bit lower\n    var normMat = mat4.create();\n    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);\n\n    var domeMat = mat4.create();\n\n    var pos = renderer.camera.getPosition();\n    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2] - lower), math.scaleMatrixf(Math.min(renderer.camera.getFar()*0.9,600000)), domeMat);\n\n    var mvp = mat4.create();\n    mat4.multiply(renderer.camera.getMvpMatrix(), domeMat, mvp);\n    mat4.multiply(mvp, normMat, mvp);\n\n\n    gpu.useProgram(shader, ['aPosition', 'aTexCoord']);\n    gpu.bindTexture(texture);\n\n    shader.setSampler('uSampler', 0);\n    shader.setMat4('uMVP', mvp);\n\n    gl.depthMask(false);\n\n    renderer.skydomeMesh.draw(shader, 'aPosition', 'aTexCoord');\n\n    gl.depthMask(true);\n    gl.enable(gl.CULL_FACE);\n\n    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();\n};\n\n\nRendererDraw.prototype.drawTBall = function(position, size, shader, texture, size2, nocull) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (nocull) {\n        //gl.disable(gl.CULL_FACE);\n    }\n\n    var normMat = mat4.create();\n    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);\n\n    var pos = [position[0], position[1], position[2] ];\n\n    size = (size != null) ? size : 1.5;\n\n    var domeMat = mat4.create();\n    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrix(size, size, size2 || size), domeMat);\n\n    var mvp = mat4.create();\n    mat4.multiply(renderer.camera.getMvpMatrix(), domeMat, mvp);\n    mat4.multiply(mvp, normMat, mvp);\n\n    gpu.useProgram(shader, ['aPosition', 'aTexCoord']);\n    gpu.bindTexture(texture || renderer.redTexture);\n\n    shader.setSampler('uSampler', 0);\n    shader.setMat4('uMVP', mvp);\n\n    renderer.skydomeMesh.draw(shader, 'aPosition', 'aTexCoord');\n\n    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();\n\n    if (nocull) {\n        //gl.enable(gl.CULL_FACE);\n    }\n};\n\n\nRendererDraw.prototype.drawBall = function(position, size, size2, shader, params, params2, params3, color, color2, normals) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    var normMat = mat4.create();\n    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);\n\n    var pos = [position[0], position[1], position[2] ];\n\n    var domeMat = mat4.create();\n    size = size || 1.5;\n    size2 = size2 || 1.5;\n    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrix(size, size, size2), domeMat);\n\n    var mv = mat4.create();\n    mat4.multiply(renderer.camera.getModelviewMatrix(), domeMat, mv);\n    mat4.multiply(mv, normMat, mv);\n    var proj = renderer.camera.getProjectionMatrix();\n\n    var norm = [0,0,0, 0,0,0, 0,0,0];\n    mat4.toInverseMat3(mv, norm);\n    mat3.transpose(norm);\n    \n    gpu.useProgram(shader, ['aPosition']);\n    //gpu.bindTexture(renderer.redTexture);\n\n    //shader.setSampler('uSampler', 0);\n    shader.setMat4('uProj', proj);\n    shader.setMat4('uMV', mv);\n    \n    if (normals) {\n        shader.setMat3('uNorm', norm);\n        gl.cullFace(gl.FRONT);\n        //gl.disable(gl.DEPTH_TEST);\n    }\n    \n    if (params) {\n        shader.setVec4('uParams', params);\n    }\n\n    if (params2) {\n        shader.setVec4('uParams2', params2);\n    }\n\n    if (params2) {\n        shader.setVec4('uParams3', params3);\n    }\n\n    if (color) {\n        shader.setVec4('uFogColor', color);\n    }\n\n    if (color2) {\n        shader.setVec4('uFogColor2', color2);\n    }\n\n    renderer.atmoMesh.draw(shader, 'aPosition', null /*\"aTexCoord\"*/);\n\n    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();\n\n    if (normals) {\n        gl.cullFace(gl.BACK);\n    }\n};\n\n\nRendererDraw.prototype.drawBall2 = function(position, size, shader, nfactor, dir, radius2) {\n    var gpu = this.gpu;\n    var renderer = this.renderer;\n\n    var normMat = mat4.create();\n    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);\n\n    var pos = [position[0], position[1], position[2] ];\n\n    var domeMat = mat4.create();\n    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrixf(size != null ? size : 1.5), domeMat);\n\n    var mv = mat4.create();\n    mat4.multiply(renderer.camera.getModelviewMatrix(), domeMat, mv);\n    mat4.multiply(mv, normMat, mv);\n    var proj = renderer.camera.getProjectionMatrix();\n\n    var norm = [0,0,0, 0,0,0, 0,0,0];\n    mat4.toInverseMat3(mv, norm);\n    mat3.transpose(norm);\n    \n    gpu.useProgram(shader, ['aPosition']);\n    gpu.bindTexture(renderer.redTexture);\n\n    shader.setSampler('uSampler', 0);\n    shader.setMat4('uProj', proj);\n    shader.setMat4('uMV', mv);\n    shader.setMat3('uNorm', norm);\n    shader.setFloat('uNFactor', nfactor);\n    shader.setVec3('uCenter', position);\n    shader.setVec2('uRadius', [size, radius2]);\n\n    renderer.atmoMesh.draw(shader, 'aPosition', null /*\"aTexCoord\"*/);\n    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();\n};\n\n\nRendererDraw.prototype.drawLineString = function(points, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n    var index = 0, p, i;\n\n    var totalPoints = points.length; \n   \n    if (totalPoints > 32) {\n        for (i = 0; i < totalPoints; i += 31) {\n            p = points.slice(i, i + 32); \n            this.drawLineString(p, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState);\n        }\n        return;\n    }\n\n    var plineBuffer = renderer.plineBuffer;\n\n\n    if (screenSpace) { \n\n        //fill points\n        for (i = 0; i < totalPoints; i++) {\n            p = points[i];\n            plineBuffer[index] = p[0];\n            plineBuffer[index+1] = p[1];\n            plineBuffer[index+2] = p[2] || 0;\n            index += 3;\n        }\n\n    } else { //covert points from physical space\n\n        var mvp = renderer.camera.getMvpMatrix();\n        var curSize = renderer.curSize;\n        var cameraPos = renderer.cameraPosition;\n\n        for (i = 0; i < totalPoints; i++) {\n            p = points[i];\n\n            plineBuffer[index] = p[0] - cameraPos[0];\n            plineBuffer[index+1] = p[1] - cameraPos[1];\n            plineBuffer[index+2] = p[2] - cameraPos[2];\n\n            index += 3;\n        }\n    }\n\n    if (useState !== true) {\n        var tmpState = gpu.currentState;\n\n        gpu.setState({\n            ztest: !(depthTest !== true),\n            blend: (transparent === true),\n            zwrite: !(writeDepth === false),\n            stencil: false,\n            culling: false,\n            zequal: false\n        });\n    }\n\n    var prog = (!screenSpace) ? renderer.progLine5 : renderer.progLine4;\n\n    gpu.useProgram(prog, ['aPosition']);\n\n    if (screenSpace) { \n        prog.setMat4('uMVP', renderer.imageProjectionMatrix, depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);\n    } else {\n        prog.setMat4('uMV', renderer.camera.getModelviewFMatrix(), null); //depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);\n        prog.setMat4('uProj', renderer.camera.getProjectionFMatrix(), null);\n    }\n\n    prog.setVec3('uScale', [(2 / renderer.curSize[0]), (2 / renderer.curSize[1]), size*0.5]);\n    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));\n    prog.setVec3('uPoints', plineBuffer);\n\n    renderer.plines.draw(prog, 'aPosition', totalPoints);\n\n    if (useState !== true) {\n        gpu.setState(tmpState);\n    }\n};\n\n\n//draw 2d circle - used for debuging\nRendererDraw.prototype.drawCircle = function(point, radius, lineWidth, color, depthOffset, depthTest, transparent, writeDepth, useState) {\n    var points = [];\n    var circleSides = 16;\n    var angle = 0, step = (2.0*Math.PI) / circleSides;\n\n    for (var i = 0; i < circleSides; i++) {\n        points[i] = [-Math.sin(angle)*radius+point[0], Math.cos(angle)*radius+point[1], point[2]];\n        angle += step;\n    }\n\n    points[circleSides] = [point[0], radius+point[1], point[2]];;\n\n    this.drawLineString(points, true, lineWidth, color, depthOffset, depthTest, transparent, writeDepth, useState);\n};\n\n\n//draw 2d image - used for debuging\nRendererDraw.prototype.drawImage = function(x, y, lx, ly, texture, color, depth, depthOffset, depthTest, transparent, writeDepth, useState) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (texture == null || renderer.imageProjectionMatrix == null) {\n        return;\n    }\n\n    if (useState !== true) {\n        var tmpState = gpu.currentState;\n\n        gpu.setState({\n            ztest: !(depthTest !== true),\n            blend: (transparent === true),\n            zwrite: !(writeDepth === false),\n            stencil: false,\n            culling: false,\n            zequal: false\n        });\n    }\n\n    var prog = renderer.progImage;\n\n    gpu.useProgram(prog, ['aPosition']);\n    gpu.bindTexture(texture);\n\n    var vertices = renderer.rectVerticesBuffer;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n    var indices = renderer.rectIndicesBuffer;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n\n    prog.setMat4('uData', [\n        x, y,  0, 0,\n        x + lx, y,  1, 0,\n        x + lx, y + ly, 1, 1,\n        x,  y + ly,  0, 1  ]);\n\n    if (depthOffset) {\n        depth = depth * (1 + renderer.getZoffsetFactor(depthOffset) * 2);\n    }\n\n    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));\n    prog.setFloat('uDepth', depth);\n\n    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n    if (useState !== true) {\n        gpu.setState(tmpState);\n    }\n};\n\n\nRendererDraw.prototype.drawBillboard = function(mvp, texture, color, depthOffset, depthTest, transparent, writeDepth, useState) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (useState !== true) {\n        var tmpState = gpu.currentState;\n\n        gpu.setState({\n            ztest: !(depthTest !== true),\n            blend: (transparent === true),\n            zwrite: !(writeDepth === false),\n            stencil: false,\n            culling: false,\n            zequal: false\n        });\n    }\n\n    var prog = renderer.progImage;\n\n    gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n    gpu.bindTexture(texture);\n    prog.setSampler('uSampler', 0);\n\n    var vertices = renderer.rectVerticesBuffer;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n    var indices = renderer.rectIndicesBuffer;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n    prog.setMat4('uProjectionMatrix', mvp, depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);\n\n    var x = 0, y = 0, lx = 1, ly = 1;\n\n    prog.setMat4('uData', [\n        x, y,  0, 0,\n        x + lx, y,  1, 0,\n        x + lx, y + ly, 1, 1,\n        x,  y + ly,  0, 1  ]);\n\n    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));\n    prog.setFloat('uDepth', 0);\n\n    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n    if (useState !== true) {\n        gpu.setState(tmpState);\n    }\n};\n\n\n//draw flat 2d image - used for debuging\nRendererDraw.prototype.drawFlatImage = function(x, y, lx, ly, texture, color, depth, depthOffset) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (texture == null || renderer.imageProjectionMatrix == null) {\n        return;\n    }\n\n    var prog = renderer.progImage;\n\n    gpu.useProgram(prog, ['aPosition']);\n    gpu.bindTexture(texture);\n\n    var vertices = renderer.rectVerticesBuffer;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n    var indices = renderer.rectIndicesBuffer;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n\n    prog.setMat4('uData', [\n        x, y,  0, 0,\n        x + lx, y,  1, 0,\n        x + lx, y + ly, 1, 1,\n        x,  y + ly,  0, 1  ]);\n\n    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));\n    prog.setFloat('uDepth', depth != null ? depth : 0);\n\n    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n};\n\n\n//draw 2d text - used for debuging\nRendererDraw.prototype.drawText = function(x, y, size, text, color, depth, useState) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (renderer.imageProjectionMatrix == null) {\n        return;\n    }\n\n    if (useState !== true) {\n        var tmpState = gpu.currentState;\n\n        gpu.setState({\n          ztest: !(depth == null),\n          blend: false,\n          zwrite: !(depth == null),\n          stencil: false,\n          culling: false,\n          zequal: !(depth == null)\n        });\n    }\n\n    var prog = renderer.progImage;\n\n    gpu.useProgram(prog, ['aPosition']);\n    gpu.bindTexture(renderer.textTexture2);\n\n    var vertices = renderer.rectVerticesBuffer;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n    var indices = renderer.rectIndicesBuffer;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n    prog.setVec4('uColor', color);\n    prog.setFloat('uDepth', depth != null ? depth : 0);\n\n    var sizeX = size - 1;\n    var sizeY = size;\n\n    var sizeX2 = Math.round(size*0.5);\n\n    var texelX = 1 / 256;\n    var texelY = 1 / 128;\n\n    var lx = this.getTextSize(size, text) + 2;\n\n    //draw black line before text\n    var char = 0;\n    var charPosX = (char & 15) << 4;\n    var charPosY = (char >> 4) << 4;\n\n    prog.setMat4('uData', [\n        x-2, y-2,  (charPosX * texelX), (charPosY * texelY),\n        x-2 + lx, y-2,  ((charPosX+15) * texelX), (charPosY * texelY),\n        x-2 + lx, y + sizeY+1, ((charPosX + 15) * texelX), ((charPosY+15) * texelY),\n        x-2,  y + sizeY+1,  (charPosX * texelX), ((charPosY+15) * texelY) ]);\n\n    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n    \n\n    for (var i = 0, li = text.length; i < li; i++) {\n        char = text.charCodeAt(i) - 32;\n        charPosX = (char & 15) << 4;\n        charPosY = (char >> 4) << 4;\n\n        switch(char) {\n        case 12:\n        case 14:\n        case 27: //:\n        case 28: //;\n        case 64: //'\n        case 73: //i\n        case 76: //l\n        case 84: //t\n\n            prog.setMat4('uData', [\n                x, y,  (charPosX * texelX), (charPosY * texelY),\n                x + sizeX2, y,  ((charPosX+8) * texelX), (charPosY * texelY),\n                x + sizeX2, y + sizeY, ((charPosX + 8) * texelX), ((charPosY+16) * texelY),\n                x,  y + sizeY,  (charPosX * texelX), ((charPosY+16) * texelY) ]);\n\n            x += sizeX2;\n            break;\n\n        default:\n\n            prog.setMat4('uData', [\n                x, y,  (charPosX * texelX), (charPosY * texelY),\n                x + sizeX, y,  ((charPosX+15) * texelX), (charPosY * texelY),\n                x + sizeX, y + sizeY, ((charPosX + 15) * texelX), ((charPosY+16) * texelY),\n                x,  y + sizeY,  (charPosX * texelX), ((charPosY+16) * texelY) ]);\n\n            x += sizeX;\n                \n            break;\n        }\n\n        gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n    }\n\n    if (useState !== true) {\n        gpu.setState(tmpState);\n    }\n};\n\n\nRendererDraw.prototype.getTextSize = function(size, text) {\n    var sizeX = size - 1;\n    var sizeX2 = Math.round(size*0.5);\n    var x = 0;\n\n    for (var i = 0, li = text.length; i < li; i++) {\n        var char = text.charCodeAt(i) - 32;\n\n        switch(char) {\n        case 12:\n        case 14:\n        case 27: //:\n        case 28: //;7\n        case 64: //'\n        case 73: //i\n        case 76: //l\n        case 84: //t\n            x += sizeX2;\n            break;\n\n        default:\n            x += sizeX;\n            break;\n        }\n    }\n    \n    return x;\n};\n\n\nRendererDraw.prototype.drawGpuJobs = function() {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n    var sortHysteresis = renderer.config.mapSortHysteresis;\n    var timerWait = renderer.config.mapHysteresisWait;\n\n    renderer.geoRenderCounter++;\n    renderer.totalJobs = 0;\n    renderer.drawnJobs = 0;\n    renderer.jobsTimer4 = 0;\n    renderer.jobsTimer3 = 0;\n    renderer.jobsTimer2 = 0;\n    renderer.jobsTimer1 = performance.now();\n\n    //setup stencil\n    gl.stencilMask(0xFF);\n    gl.clear(gl.STENCIL_BUFFER_BIT);\n    gl.stencilFunc(gl.EQUAL, 0, 0xFF);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n\n    var screenPixelSize = [1.0/renderer.curSize[0], 1.0/renderer.curSize[1]];\n    var rmap = this.rmap;\n    var clearPass = 513;\n    var clearPassIndex = 0;\n    var clearStencilPasses = renderer.clearStencilPasses;\n    var jobZBuffer = renderer.jobZBuffer;\n    var jobZBufferSize = renderer.jobZBufferSize;\n    var jobZBuffer2 = renderer.jobZBuffer2;\n    var jobZBuffer2Size = renderer.jobZBuffer2Size;\n    var onlyHitLayers = renderer.onlyHitLayers;\n    var onlyAdvancedHitLayers = renderer.onlyAdvancedHitLayers;\n    var geoRenderCounter = renderer.geoRenderCounter;\n    var job, key, hitmapRender = renderer.onlyHitLayers;\n    //var logDebugInfo = false;\n\n    var hsortBuff = renderer.jobHSortBuffer;\n    var hsortBuffSize = 0;\n\n    if (clearStencilPasses.length > 0) {\n        clearPass = clearStencilPasses[0];\n        clearPassIndex++;\n    }\n\n    if (this.rmap.counter != this.renderer.geoRenderCounter) {\n        this.rmap.clear();\n    }\n\n    renderer.gmapIndex = 0;\n    renderer.gmapUseVersion = 1;\n\n    var forceUpdate = false;\n\n    var ret, frameTime = renderer.frameTime, sortHbuffer = false;\n\n    //console.log(\"\" + frameTime);\n\n    //draw job buffer and also clean buffer\n    for (var i = 0, li = jobZBuffer.length; i < li; i++) {\n        var j, lj = jobZBufferSize[i], lj2 = jobZBuffer2Size[i];\n        var buffer = jobZBuffer[i];\n        var buffer2 = jobZBuffer2[i];\n        renderer.jobHBuffer = {};\n\n        renderer.totalJobs += lj;\n\n        if (lj > 0 && i >= clearPass) {\n            gl.clear(gl.STENCIL_BUFFER_BIT);\n\n            if (clearStencilPasses.length > clearPassIndex) {\n                clearPass = clearStencilPasses[clearPassIndex];\n                clearPassIndex++;\n            } else {\n                clearPass = 513;\n            }\n        }\n\n        if (onlyHitLayers) {\n            if (onlyAdvancedHitLayers) {\n                for (j = 0; j < lj; j++) {\n                    if (buffer[j].advancedHit) {\n                        this.drawGpuJob(gpu, gl, renderer, buffer[j], screenPixelSize, true);\n                    }\n                }\n            } else {\n                for (j = 0; j < lj; j++) {\n                    var job = buffer[j];\n                    if (job.hitable) {\n                        this.drawGpuJob(gpu, gl, renderer, job, screenPixelSize);\n                        if (job.advancedHit) {\n                            renderer.advancedPassNeeded = true;\n                        }\n                    }\n                }\n            }\n        } else {\n\n            for (j = 0; j < lj; j++) {\n \n                job = buffer[j];\n                this.drawGpuJob(gpu, gl, renderer, job, screenPixelSize);\n            }\n\n            /*if (logDebugInfo) {\n                for (j = 0; j < lj; j++) {\n                    job = buffer[j];\n                    console.log('' + j + ' ' + job.id);\n                }\n            }*/\n        }\n    \n        renderer.jobsTimer3 = performance.now();\n\n        if (renderer.gmapIndex > 0) {\n            switch(renderer.gmapUseVersion) {\n                case 1: //scr-count4\n                    processGMap(gpu, gl, renderer, screenPixelSize, this);\n                    break;\n                case 2:  //scr-count5\n                    processGMap4(gpu, gl, renderer, screenPixelSize, this);\n                    break;\n                case 3: //scr-count6\n                    processGMap5(gpu, gl, renderer, screenPixelSize, this);\n                    break;\n                case 4: //scr-count7\n                    processGMap6(gpu, gl, renderer, screenPixelSize, this);\n                    break;\n                case 5: //scr-count8\n                    processGMap7(gpu, gl, renderer, screenPixelSize, this);\n                    break;\n            }\n            renderer.gmapIndex = 0;\n        }\n\n        if (rmap.rectanglesCount > 0 || rmap.rectangles2Count > 0) {\n            rmap.processRectangles(gpu, gl, renderer, screenPixelSize);\n        }\n\n        renderer.jobsTimer4 += performance.now() - renderer.jobsTimer3;\n\n        //lj2 = jobZBuffer2Size[i]; //probably no op\n\n        lj2 = false;\n        var hbuffer = renderer.jobHBuffer;\n\n        for (key in hbuffer) {\n            lj2 = true;\n            break;\n        }\n\n        for (key in buffer2) {\n            lj2 = true;\n            break;\n        }\n\n        if (lj2) {\n\n            if (!hitmapRender) {\n\n                for (key in hbuffer) {\n                    job = hbuffer[key];\n\n                     if (job.hysteresis && job.id) {\n                        var job2 = buffer2[job.id];\n\n                        if (!job2) {\n                            job.timerShow = 0;\n                            job.timerHide = 0;\n                            job.draw = false;\n                            job.hysteresisCounter = renderer.geoRenderCounter;\n                            buffer2[job.id] = job;\n                            jobZBuffer2Size[i]++;\n                            forceUpdate = true;\n                        } else {\n\n                            if (job == job2) {\n                                job2.hysteresisCounter = renderer.geoRenderCounter;\n                            } else {\n                                job2.hysteresisBackup = job;\n                            }\n\n                        }\n\n                        //if (job.hysteresis[3] === true) {\n                            sortHbuffer = true;\n                        //}\n                    }\n                }\n            }\n\n            for (key in buffer2) {\n                job = buffer2[key];\n                job2 = hbuffer[key];\n\n                renderer.drawnJobs++;\n\n                if (!hitmapRender) {\n                    if (job2) {\n                        if (isNaN(job.timerShow)) {\n                            job.timerShow = 0;\n                            job.timerHide = 0;\n                            job.draw = false;\n                        }\n\n                        if (!job.draw) {\n                            job.timerShow += frameTime;\n\n                            if ((job.timerShow - timerWait) > (job.hysteresis[0])) {\n                                job.draw = true;\n                                job.timerShow = 0;\n                            } else {\n                                forceUpdate = true;\n                            }\n                        } else if (job.timerHide) {\n                            job.draw = false;\n                            job.timerShow = timerWait + (job.hysteresis[0]) * (1.0-(job.timerHide / (job.hysteresis[1])));\n                        }\n\n                        job.timerHide = 0;\n\n                    } else {\n                        //job = buffer2[key];\n\n                        if (job.draw) {\n                            job.timerHide += frameTime;\n\n                            if (job.timerHide > (job.hysteresis[1])) {\n                                delete buffer2[key];\n                                jobZBuffer2Size[i]--;\n                                job.draw = false;\n                                job.timerHide = 0;\n                            } else {\n                                forceUpdate = true;\n                            }\n                        } else if (job.timerShow) {\n                            job.draw = true;\n                            job.timerHide = (job.hysteresis[1]) * (1.0-((job.timerShow-timerWait) / (job.hysteresis[0])));\n                        }\n\n                        job.timerShow = 0;\n                    }\n                }\n\n                var draw = job.draw, fade = null;\n\n                if (!hitmapRender && job.hysteresis[3] === true) {\n \n                    if (draw) {\n                        if (job.timerHide != 0) {\n                            fade = job.timerHide / (job.hysteresis[1]+1);\n                            fade = 1.0 - Math.min(1.0, fade);\n                        }\n                    } else {\n                        if (job.timerShow != 0 && (job.timerShow-timerWait) > 0) {\n                            fade = (job.timerShow -timerWait) / (job.hysteresis[0]+1);\n                            fade = Math.min(1.0, fade);\n                            draw = true;\n                        }\n                    }\n                }\n\n\n                if (draw) {\n\n                    if (job.hysteresisCounter != renderer.geoRenderCounter && job.hysteresisBackup) {\n                        var job3 = job.hysteresisBackup;\n                        buffer2[key] = job3;\n\n                        job3.timerShow = job.timerShow;\n                        job3.timerHide = job.timerHide;\n                        job3.draw = job.draw;\n\n                        job = job3;\n                    }\n\n                    // update job matricies\n                    if (job.renderCounter[0][0] !== geoRenderCounter && job.renderCounter[0][0] !== null) { \n                        job.updatePos = true;\n\n                        var renderCounter = job.renderCounter[0];\n\n                        var mvp = mat4.create();\n                        var mv = mat4.create();\n                        var group = renderCounter[3];\n                        var bbox = group.bbox;\n                        var geoPos = renderer.cameraPosition;\n                    \n                        var m = math.translationMatrix(bbox.min[0] - geoPos[0], bbox.min[1] - geoPos[1], bbox.min[2] - geoPos[2]);\n                        mat4.multiply(renderer.camera.getModelviewMatrix(), m, mv);\n\n                        var proj = renderer.camera.getProjectionMatrix();\n                        mat4.multiply(proj, mv, mvp);\n\n                        job.mv = mv;\n                        job.mvp = mvp;\n                    }                    \n\n                    if (sortHysteresis) {\n\n                        job.fade = fade;\n\n                        hsortBuff[hsortBuffSize] = job;\n                        hsortBuffSize++;\n\n                    } else {\n\n                        switch(job.type) {\n                            case VTS_JOB_VSPOINT:\n                                var viewExtent = renderer.viewExtent;\n                                var slayers = job.vswitch[job.vswitchIndex];\n\n                                if (slayers) {\n                                    slayers = slayers[1];\n\n                                    for (var k = 0, lk = slayers.length; k < lk; k++) {\n                                        var sjob = slayers[k];\n                                        sjob.updatePos = job.updatePos;\n                                        sjob.mvp = job.mvp;\n                                        sjob.mv = job.mv;\n                                        this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, sjob.lastSubJob, fade);\n                                    }\n                                }\n\n                                break;\n\n                            case VTS_JOB_LINE_LABEL:\n                                this.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, fade);\n                                break;\n\n                            default:\n                                this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, fade);\n                                break;\n                        }\n\n                        job.updatePos = false;\n                    }\n                }\n\n                job.hysteresisBackup = null;\n            }\n        }\n    }\n\n    if (sortHysteresis && hsortBuffSize) {\n\n        radixDepthSortFeatures(renderer, hsortBuff, hsortBuffSize, renderer.gmap2);\n\n        for (i = 0; i < hsortBuffSize; i++) {\n            job = hsortBuff[i];\n\n            switch(job.type) {\n                case VTS_JOB_VSPOINT:\n                    var viewExtent = renderer.viewExtent;\n                    var slayers = job.vswitch[job.vswitchIndex];\n\n                    if (slayers) {\n                        slayers = slayers[1];\n\n                        for (var k = 0, lk = slayers.length; k < lk; k++) {\n                            var sjob = slayers[k];\n                            sjob.updatePos = job.updatePos;\n                            sjob.mvp = job.mvp;\n                            sjob.mv = job.mv;\n                            this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, sjob.lastSubJob, job.fade);\n                        }\n                    }\n\n                break;\n\n                case VTS_JOB_LINE_LABEL:\n                    this.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, job.fade);\n                    break;\n\n                default:\n                    this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, job.fade);\n                    break;\n            }\n\n            job.updatePos = false;\n        }\n\n    }\n\n    if (forceUpdate) {\n        this.core.markDirty();\n    }\n\n    renderer.jobsTimer2 = performance.now();\n};\n\n\nRendererDraw.prototype.clearJobBuffer = function() {\n    var renderer = this.renderer;\n    var jobZBuffer = renderer.jobZBuffer;\n    var jobZBufferSize = renderer.jobZBufferSize;\n\n    //clean job buffer\n    for (var i = 0, li = jobZBuffer.length; i < li; i++) {\n        var lj = jobZBufferSize[i];\n        var buffer = jobZBuffer[i];\n\n        for (var j = 0; j < lj; j++) {\n            buffer[j] = null;\n        }\n\n        jobZBufferSize[i] = 0;\n    }\n};\n\n\nRendererDraw.prototype.clearJobHBuffer = function() {\n    var renderer = this.renderer;\n    var jobZBuffer2 = renderer.jobZBuffer2;\n    var jobZBuffer2Size = renderer.jobZBuffer2Size;\n\n    //clean job hbuffer\n    for (var i = 0, li = jobZBuffer2.length; i < li; i++) {\n        jobZBuffer2[i] = {};\n        jobZBuffer2Size[i] = 0;\n    }\n};\n\n\nRendererDraw.prototype.paintGL = function() {   //remove this??\n    var renderer = this.renderer;\n\n    this.gpu.clear(true, false);\n\n    if (!renderer.onlyLayers) {\n        if (!renderer.onlyDepth && !renderer.onlyHitLayers) {\n            this.drawSkydome();\n        }\n    }\n};\n\n\nRendererDraw.prototype.processNoOverlap = function(renderer, job, pp, p1, p2, camVec, l, stickShift, texture, files, color) {\n    var res = { \n        exit: true\n    };\n\n    var reduce78 = (job.reduce && (job.reduce[0] >= 7 && job.reduce[0] <= 11));\n\n    if (!renderer.drawAllLabels && job.noOverlap) { \n        if (!pp) {\n            //if (job.type == VTS_JOB_LINE_LABEL) {\n              //  pp = renderer.project2(job.center2, job.mvp, [0,0,0]);\n            //} else {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);\n            //}\n        }\n\n        res.pp = pp;\n        var o = job.noOverlap, depth = pp[2];\n\n        if (depth < 0 || depth > 1.0) {\n            return res;\n        }\n\n        if (job.type == VTS_JOB_LINE_LABEL) {\n            if (renderer.benevolentMargins) {\n                if (!renderer.rmap.checkRectangle(pp[0]-200, pp[1]-200, pp[0]+200, pp[1]+200, 0)) {\n                    return res;\n                }\n            } else{ \n                if (!renderer.rmap.checkRectangle(pp[0], pp[1], pp[0], pp[1], 0)) {\n                    return res;\n                }\n            }\n        } else {\n            if (!renderer.rmap.checkRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], stickShift)) {\n                return res;\n            }\n        }\n\n        if (o[4] !== null) {\n            if (o[4] === VTS_NO_OVERLAP_DIRECT) {\n                depth = o[5];\n            } else {\n                if (l === null) {\n                    p2 = job.center2;\n                    p1 = renderer.cameraPosition;\n                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                    l = vec3.length(camVec) + 0.0001;\n                }\n\n                if (!job.reduce || (job.reduce && !(job.reduce[0] >= 8 && job.reduce[0] <= 11))) {  //not overlap code not used for reduce==8\n                    depth = o[5] / l;\n                }\n            } \n        }\n\n        job.lastSubJob = [job, stickShift, texture, files, color, pp, true, depth, o];\n\n        if (reduce78) {\n            renderer.gmapUseVersion = (job.reduce[0] >= 8 && job.reduce[0] <= 11) ? (job.reduce[0] - 6) : 1;\n            renderer.gmap[renderer.gmapIndex] = job.lastSubJob;\n            renderer.gmapIndex++;\n\n            if (renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists\n                if (l === null) {\n                    p2 = job.center2;\n                    p1 = renderer.cameraPosition;\n                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                    l = vec3.length(camVec) + 0.0001;\n                }\n\n                if (l > renderer.fmaxDist) renderer.fmaxDist = l;\n                if (l < renderer.fminDist) renderer.fminDist = l;\n\n                job.reduce[1] = job.reduce[2];\n                job.reduce[4] = l;\n            }\n            return res;\n        }\n\n        if (job.type == VTS_JOB_LINE_LABEL) {\n            if (!renderer.rmap.addLineLabel(job.lastSubJob)) {\n                //renderer.rmap.storeRemovedLineLabel(job.lastSubJob);\n                return res;\n            }\n        } else {\n            if (!renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], depth, job.lastSubJob)) {\n                renderer.rmap.storeRemovedRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], depth, job.lastSubJob);\n                return res;\n            }\n        }\n\n        return res; //draw all labe from same z-index together\n    } else {\n        if (reduce78) {\n            if (!pp) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);\n            }\n\n            job.lastSubJob = [job, stickShift, texture, files, color, pp, false];\n\n            renderer.gmapUseVersion = (job.reduce[0] >= 8 && job.reduce[0] <= 11) ? (job.reduce[0] - 6) : 1;\n            renderer.gmap[renderer.gmapIndex] = job.lastSubJob;\n            renderer.gmapIndex++;\n\n            if (renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists\n                if (l === null) {\n                    p2 = job.center2;\n                    p1 = renderer.cameraPosition;\n                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                    l = vec3.length(camVec) + 0.0001;\n                }\n\n                if (l > renderer.fmaxDist) renderer.fmaxDist = l;\n                if (l < renderer.fminDist) renderer.fminDist = l;\n\n                job.reduce[1] = job.reduce[2];\n                job.reduce[4] = l;\n            }\n\n            res.pp = pp;\n            return res;\n        }\n    }\n\n    if (job.hysteresis && job.id) {\n        if (!pp) {\n            pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);\n        }\n\n        job.lastSubJob = [job, stickShift, texture, files, color, pp];\n        renderer.jobHBuffer[job.id] = job;\n        res.pp = pp;\n        return res;\n     } else {\n        res.pp = pp;\n     }\n\n    res.exit = false;\n\n    return res;\n}\n\nRendererDraw.prototype.drawGpuJob = function(gpu, gl, renderer, job, screenPixelSize, advancedHitPass, ignoreFilters) {\n    if (!job.ready) {\n        return;\n    }\n\n    //if (!(job.tile.id[0] == 14 && job.tile.id[1] == 4383 && job.tile.id[2] == 2863)) {\n      //  return;\n    //}\n\n    if (!job.eventInfo) {\n        return;\n    }\n\n    var state = job.state & 0xff;\n    var id = job.eventInfo['#id'];\n\n    if (id != null) {\n\n        if (job.state & (2 << 8)) { //has selection layers?\n\n            if (renderer.geodataSelection.indexOf(id) != -1) {  // is selected\n\n                if (job.state & (3 << 8)) { //has hover layers?\n\n                    if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {\n                        if (state != 3) {\n                            return;\n                        }\n                    } else {\n                        if (state != 2) {\n                            return;\n                        }\n                    }\n                }\n            } else if (job.state & (1 << 8)) { //has hover layers?\n\n                if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {\n                    if (state != 1) {\n                        return;\n                    }\n                } else {\n                    if (state != 0) {\n                        return;\n                    }\n                }\n\n            } else {\n                if (state != 0) {\n                    return;\n                }        \n            }\n        \n        } else if (job.state & (1 << 8)) { //has hover layers?\n\n            if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {\n                if (state != 1) {\n                    return;\n                }\n            } else {\n                if (state != 0) {\n                    return;\n                }\n            }\n\n        } else {\n            if (state != 0) {\n                return;;\n            }        \n        }\n\n    } else {\n        if (state != 0) {\n            return;\n        }        \n    }\n\n    var mvp = job.mvp, prog, texture, res;\n    var vertexPositionAttribute, vertexTexcoordAttribute,\n        vertexNormalAttribute, vertexOriginAttribute, vertexElementAttribute;\n\n    var hitmapRender = job.hitable && renderer.onlyHitLayers;\n    var screenPixelSize2, color = job.color;\n    var useSuperElevation = renderer.useSuperElevation;\n\n    if (hitmapRender) {\n        var c = renderer.hoverFeatureCounter;\n        //color = [(c&255)/255, ((c>>8)&255)/255, ((c>>16)&255)/255, 1];\n        color = [(c&255)/255, ((c>>8)&255)/255, 0, 0];\n        renderer.hoverFeatureList[c] = [job.eventInfo, job.center, job.clickEvent, job.hoverEvent, job.enterEvent, job.leaveEvent, advancedHitPass];\n        renderer.hoverFeatureCounter++;\n    }\n\n    switch(job.type) {\n    case VTS_JOB_FLAT_LINE:\n    case VTS_JOB_POLYGON:\n\n        if (job.type == VTS_JOB_POLYGON) {\n            if (hitmapRender) {\n                if (job.stencil) {\n                    gpu.setState(job.culling ? renderer.polygonB0S1C1tate : renderer.polygonB0S1C0tate);\n                } else {\n                    gpu.setState(job.culling ? renderer.polygonB0S0C1tate : renderer.polygonB0S0C0tate);\n                }\n            } else {\n                if (job.stencil) {\n                    gpu.setState(job.culling ? renderer.polygonB1S1C1tate : renderer.polygonB1S1C0tate);\n                } else {\n                    gpu.setState(job.culling ? renderer.polygonB1S0C1tate : renderer.polygonB1S0C0tate);\n                }\n            }\n        } else {\n            gpu.setState(hitmapRender ? renderer.stencilLineHitState : renderer.stencilLineState);\n        }\n\n        var debugWires = (gpu === 0); //just generate false value to avoid compiler warnings;\n\n        if (useSuperElevation) {\n            prog = advancedHitPass ? job.program2 : renderer.progLineSE;\n        } else {            \n            prog = advancedHitPass ? job.program2 : debugWires ? renderer.progLineWireframe : job.program;\n        }\n\n        var flatShade = (!advancedHitPass && job.type == VTS_JOB_POLYGON && job.style == 1);\n\n        if (flatShade) { \n            prog = useSuperElevation ? renderer.progCFlatShadeTileSE : renderer.progCFlatShadeTile;\n        }\n\n        gpu.useProgram(prog, advancedHitPass ? ['aPosition', 'aElement'] : debugWires ? ['aPosition', 'aBarycentric'] : ['aPosition']);\n\n        if (useSuperElevation) {\n            var m = this.mBuffer;\n            var se = renderer.superElevation;\n\n            m[0] = job.bbox.min[0];\n            m[1] = job.bbox.min[1];\n            m[2] = job.bbox.min[2];\n\n            m[3] = 1;\n            m[4] = 1;\n            m[5] = 1;\n\n            m[9] = se[0]; // h1\n            m[10] = se[1]; // f1\n            m[11] = se[2]; // h2\n            m[12] = se[6]; // inv dh\n            m[13] = se[5]; // df\n\n            m[14] = renderer.earthRadius;\n            m[15] = renderer.earthERatio;\n\n            prog.setMat4('uParamsSE', m);\n        }\n\n        if (flatShade) { \n            prog.setMat4('uMV', job.mv);\n            prog.setMat4('uProj', renderer.camera.getProjectionFMatrix(), renderer.getZoffsetFactor(job.zbufferOffset));\n            prog.setVec4('uColor', color);\n        } else {\n            prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n            prog.setVec4('uColor', color);\n        }\n\n        vertexPositionAttribute = prog.getAttribute('aPosition');\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        if (advancedHitPass) {\n            vertexElementAttribute = prog.getAttribute('aElement');\n            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);\n            gl.vertexAttribPointer(vertexElementAttribute, job.vertexElementBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n\n        if (debugWires) {\n            var barycentericAttribute = prog.getAttribute('aBarycentric');\n            gl.bindBuffer(gl.ARRAY_BUFFER, gpu.barycentricBuffer);\n            gl.vertexAttribPointer(barycentericAttribute, gpu.barycentricBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n        \n        //draw polygons\n        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n\n        var drawDebugLines = renderer.debug.drawPolyWires;// false;//true;\n\n        if (drawDebugLines) {\n\n            var program = useSuperElevation ? renderer.progWireFrameBasicSE : renderer.progWireFrameBasic;\n            renderer.gpu.useProgram(program, ['aPosition']);\n\n            if (useSuperElevation) {\n                program.setMat4('uParamsSE', m);\n            }\n\n            program.setMat4('uMV', job.mv);\n            program.setVec4('uColor', [0,0,0,1]);\n\n            program.setMat4('uProj', renderer.camera.getProjectionFMatrix(), renderer.getZoffsetFactor(job.zbufferOffset));\n\n            for (var i = 0, li = job.vertexPositionBuffer.numItems*2; i < li; i+=3) {\n                gl.drawArrays(gl.LINE_LOOP, i, 3);\n            }\n\n\n        }\n\n        break;\n\n    case VTS_JOB_FLAT_RLINE:\n    case VTS_JOB_FLAT_TLINE:\n    case VTS_JOB_PIXEL_LINE:\n    case VTS_JOB_PIXEL_TLINE:\n        gpu.setState(hitmapRender ? renderer.stencilLineHitState : renderer.stencilLineState);\n\n        prog = advancedHitPass ? job.program2 : job.program;\n        texture = null;\n        var textureParams = [0,0,0,0];\n        screenPixelSize2 = screenPixelSize;\n\n        if (hitmapRender) {\n            if (job.type == VTS_JOB_PIXEL_TLINE) {\n                if (job.widthByRatio) {\n                    screenPixelSize2 = [ screenPixelSize[0] * renderer.curSize[1], screenPixelSize[1] * renderer.curSize[1]];\n                }\n                prog = advancedHitPass ? this.renderer.progELine3 : this.renderer.progLine3;\n                if (!prog.isReady()) {\n                    return;\n                }\n            }\n        }\n\n        if (job.type != VTS_JOB_PIXEL_LINE) {\n\n            if (job.type == VTS_JOB_FLAT_RLINE) {\n                textureParams = [0, 0, 0, job.widthByRatio ? renderer.cameraViewExtent : 1];\n            } else {\n                if (hitmapRender) {\n                    texture = renderer.whiteTexture;\n\n                    if (job.type == VTS_JOB_FLAT_TLINE || job.type == VTS_JOB_FLAT_RLINE) {\n                        textureParams = [0, 0, 0, job.widthByRatio ? renderer.cameraViewExtent : 1];\n                    }\n\n                } else {\n                    var t = job.texture;\n                    if (t == null || t[0] == null) {\n                        return;\n                    }\n\n                    texture = t[0];\n                    textureParams = [0, t[1]/t[0].height, (t[1]+t[2])/t[0].height, job.widthByRatio ? renderer.cameraViewExtent : 1];\n\n                    if (job.type == VTS_JOB_FLAT_TLINE || job.type == VTS_JOB_FLAT_RLINE) {\n                        if (job.widthByRatio) {\n                            textureParams[0] = 1/(renderer.cameraViewExtent2*job.lineWidth)/(texture.width/t[2]);\n                        } else {\n                            textureParams[0] = 1/job.lineWidth/(texture.width/t[2]);    \n                        }\n                    } else {\n                        if (job.widthByRatio) {\n                            textureParams[0] = 1/(renderer.cameraViewExtent2/renderer.curSize[1])/(texture.width/t[2]);\n                            textureParams[0] /= (renderer.curSize[1]*job.lineWidth*0.5);\n                            //textureParams[3] = renderer.curSize[1]*(1.0/job.lineWidth)*0.5;\n                            textureParams[3] = renderer.curSize[1];\n                        } else {\n                            textureParams[0] = 1/(renderer.cameraViewExtent2/renderer.curSize[1])/(texture.width/t[2]);\n                            textureParams[0] /= (job.lineWidth*0.5);\n                            textureParams[3] = 1;\n                        }    \n                    }\n                }\n\n                if (!texture.loaded) {\n                    return;\n                }\n\n                gpu.bindTexture(texture);\n            }\n\n        } else if (job.widthByRatio) {\n            screenPixelSize2 = [ screenPixelSize[0] * renderer.curSize[1], screenPixelSize[1] * renderer.curSize[1]];\n        }\n\n        if (useSuperElevation) {\n            prog = advancedHitPass ? job.program2 : renderer.progLine3SE;\n\n            var m = this.mBuffer;\n            var se = renderer.superElevation;\n\n            m[0] = job.bbox.min[0];\n            m[1] = job.bbox.min[1];\n            m[2] = job.bbox.min[2];\n\n            m[3] = 1;\n            m[4] = 1;\n            m[5] = 1;\n\n            m[9] = se[0]; // h1\n            m[10] = se[1]; // f1\n            m[11] = se[2]; // h2\n            m[12] = se[6]; // inv dh\n            m[13] = se[5]; // df\n\n            m[14] = renderer.earthRadius;\n            m[15] = renderer.earthERatio;\n\n            gpu.useProgram(prog, advancedHitPass ? ['aPosition','aNormal','aElement'] : ['aPosition','aNormal']);\n            prog.setMat4('uParamsSE', m);\n\n        } else {\n            gpu.useProgram(prog, advancedHitPass ? ['aPosition','aNormal','aElement'] : ['aPosition','aNormal']);\n        }           \n\n        prog.setVec4('uColor', color);\n        prog.setVec2('uScale', screenPixelSize2);\n        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n\n        if (job.type != VTS_JOB_PIXEL_LINE) {\n            if (job.background != null) {\n                prog.setVec4('uColor2', hitmapRender ? [0,0,0,0] : job.background);\n            }\n            prog.setVec4('uParams', textureParams);\n            prog.setSampler('uSampler', 0);\n        }\n\n        vertexPositionAttribute = prog.getAttribute('aPosition');\n        vertexNormalAttribute = prog.getAttribute('aNormal');\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind vetex normals\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);\n        gl.vertexAttribPointer(vertexNormalAttribute, job.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        if (advancedHitPass) {\n            vertexElementAttribute = prog.getAttribute('aElement');\n            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);\n            gl.vertexAttribPointer(vertexElementAttribute, job.vertexElementBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n\n        //draw polygons\n        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n\n        break;\n\n    case VTS_JOB_LINE_LABEL:\n        var files = job.files;\n\n        if (files.length > 0) {\n            for (var i = 0, li = files.length; i < li; i++) {\n                if (files[i].length > 0) {\n                    var font = job.fonts[i];\n                    if (font && !font.areTexturesReady(files[i])) {\n                        return;\n                    }\n                }\n            }\n\n        } else {\n            if (!hitmapRender) {\n                return;\n            }\n\n            texture = renderer.whiteTexture;\n        }\n\n        if (renderer.useSuperElevation) {\n            if (job.seCounter != renderer.seCounter) {\n                job.seCounter = renderer.seCounter;\n                job.labelPointsBuffer.id = -1;\n                job.center2 = renderer.transformPointBySE(job.center);\n            }\n        } else {\n            job.center2 = job.center;\n        }\n\n        var gamma = job.outline[2] * 1.4142 / 20;\n        var gamma2 = job.outline[3] * 1.4142 / 20;\n\n        if (job.singleBuffer) {\n\n            var p1, p2, camVec, ll, l = null, localTilt;\n\n            if (job.culling != 180) {\n                p2 = job.center2;\n                p1 = renderer.cameraPosition;\n                camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n                if (job.visibility) {\n                    l = vec3.length(camVec);\n\n                    switch(job.visibility.length) {\n                        case 1:\n                            if (l > job.visibility[0]) {\n                                return;\n                            }\n                            break;\n\n                        case 2:\n                            ll = l * renderer.localViewExtentFactor;\n                            if (ll < job.visibility[0] || ll > job.visibility[1]) {\n                                return;\n                            }\n\n                            break;\n\n                        case 4:\n                            ll = l * renderer.localViewExtentFactor;\n                            var diameter = job.visibility[0] * job.visibility[1];\n                            if (diameter < (job.visibility[2] * ll) || diameter > (job.visibility[3] * ll)) {\n                                return;\n                            }\n\n                            break;\n                    }\n\n                    l = 1/l;\n                    camVec[0] *= l;                       \n                    camVec[1] *= l;                       \n                    camVec[2] *= l;                       \n                } else {\n                    vec3.normalize(camVec);\n                }\n                    \n                job.normal = [0,0,0];\n                vec3.normalize(job.center2, job.normal);\n                    \n                localTilt = -vec3.dot(camVec, job.normal);\n\n                if (localTilt < Math.cos(math.radians(job.culling))) {\n                    return;\n                }\n                \n            } else if (job.visibility) {\n\n                p2 = job.center2;\n                p1 = renderer.cameraPosition;\n                camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                l = vec3.length(camVec);\n\n                switch(job.visibility.length) {\n                    case 1:\n                        if (l > job.visibility[0]) {\n                            return;\n                        }\n                        break;\n\n                    case 2:\n                        l *= renderer.localViewExtentFactor;\n                        if (l < job.visibility[0] || l > job.visibility[1]) {\n                            return;\n                        }\n\n                        break;\n\n                    case 4:\n                        l *= renderer.localViewExtentFactor;\n\n                        var diameter = job.visibility[0] * job.visibility[1];\n                        if (diameter < (job.visibility[2] * l) || diameter > (job.visibility[3] * l)) {\n                            return;\n                        }\n\n                        break;\n                }\n            }\n\n            res = this.processNoOverlap(renderer, job, pp, p1, p2, camVec, l, stickShift, texture, files, color); //, pointsIndex);\n\n            if (res.exit) {\n                return;\n            } else {\n                //pp = res.pp;\n                //p1 = res.p1;\n                //p2 = res.p2;\n                //camVec = res.camVec;\n                //l = res.l;\n            }\n           \n            this.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, [job,0,texture,files,color,pp]);\n\n            /*\n            if (bl > 384) { vbuff = renderer.textQuads128; prog = renderer.progLineLabel128; } else\n            if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLineLabel96; } else\n            if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLineLabel64; } else\n            if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLineLabel48; } else\n            if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLineLabel32; }\n            else { vbuff = renderer.textQuads16; prog = renderer.progLineLabel16; }\n\n            gpu.useProgram(prog, ['aPosition']);\n            prog.setSampler('uSampler', 0);\n            prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n\n            prog.setVec4('uColor', hitmapRender ? color : job.color2);\n            prog.setVec2('uParams', [job.outline[0], gamma2]);\n            lj = hitmapRender ? 1 : 2;\n\n            var vertexPositionAttribute = prog.getAttribute('aPosition');\n\n            prog.setVec4('uData', b);\n\n            //bind vetex positions\n            gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);\n            gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);\n\n            //draw polygons\n            for(var j = 0; j < (hitmapRender ? 1 : 2); j++) {\n                if (j == 1) {\n                    prog.setVec4('uColor', color);\n                    prog.setVec2('uParams', [job.outline[1], gamma]);\n                }\n\n                for (var i = 0, li = files.length; i < li; i++) {\n                    var fontFiles = files[i];\n\n                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                        var file = fontFiles[k];\n                        prog.setFloat('uFile', Math.round(file+i*1000));\n                        gpu.bindTexture(job.fonts[i].getTexture(file));\n                        gl.drawArrays(gl.TRIANGLES, 0, vitems / 3); //TODO: demystify vitems\n                    }\n                }\n            }\n\n            if (renderer.drawLabelBoxes) {\n                if (job.labelPoints.length > 0) {\n                    var points = job.labelPoints[0][pointsIndex];\n\n                    for(j = 0; j < points.length; j++) {\n                        pp = renderer.project2(points[j], mvp, [0,0,0], true);\n                        this.drawCircle(pp, points[j][3] *renderer.camera.scaleFactor2(pp[3])*0.5*renderer.curSize[1]*(renderer.curSize[0]/renderer.curSize[1]), 1, [255, 0, 255, 255], null, null, null, null, null);\n                    }\n                }\n            }*/\n\n            return;\n        }\n\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n\n        prog = renderer.useSuperElevation ? renderer.progText2SE : job.program;\n        gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n\n        if (useSuperElevation) {\n            var m = this.mBuffer;\n            var se = renderer.superElevation;\n\n            m[0] = job.bbox.min[0];\n            m[1] = job.bbox.min[1];\n            m[2] = job.bbox.min[2];\n\n            m[3] = 1;\n            m[4] = 1;\n            m[5] = 1;\n\n            m[9] = se[0]; // h1\n            m[10] = se[1]; // f1\n            m[11] = se[2]; // h2\n            m[12] = se[6]; // inv dh\n            m[13] = se[5]; // df\n\n            m[14] = renderer.earthRadius;\n            m[15] = renderer.earthERatio;\n\n            prog.setMat4('uParamsSE', m);\n        }  \n\n        prog.setSampler('uSampler', 0);\n        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n        prog.setVec4('uVec', renderer.labelVector);\n\n        prog.setVec4('uColor', (hitmapRender ? color : job.color2));\n        prog.setVec2('uParams', [job.outline[0], gamma2]);\n\n        vertexPositionAttribute = prog.getAttribute('aPosition');\n        vertexTexcoordAttribute = prog.getAttribute('aTexCoord');\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind vetex texcoords\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n        gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //draw polygons\n        for(var j = 0; j < (hitmapRender ? 1 : 2); j++) {\n            if (j == 1) {\n                prog.setVec4('uColor', color);\n                prog.setVec2('uParams', [job.outline[1], gamma]);\n            }\n\n            if (files.length > 0) {\n                for (var i = 0, li = files.length; i < li; i++) {\n                    var fontFiles = files[i];\n\n                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                        var file = fontFiles[k];\n                        prog.setFloat('uFile', Math.round(file+i*1000));\n                        gpu.bindTexture(job.fonts[i].getTexture(file));\n                        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n                    }\n                }\n\n            } else {\n                gpu.bindTexture(texture);\n                gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n            }\n        }\n\n        break;\n\n    case VTS_JOB_ICON:\n    case VTS_JOB_LABEL:\n    case VTS_JOB_PACK:\n    case VTS_JOB_VSPOINT:\n\n\n        if (job.reduce && !(job.reduce[0] >= 7 && job.reduce[0] <= 11)) {\n            var a, r = job.reduce;\n\n            if (r[0] > 4) {\n                \n                if (r[0] == 4) {\n                    a = Math.max(r[1], Math.floor(r[2] / Math.max(1, renderer.drawnGeodataTiles)));\n\n                    if (job.index >= a) {\n                        return;\n                    } \n                    r[5] = a; //for debug\n                } else {\n                    a = Math.pow(job.texelSize * job.tiltAngle, VTS_TILE_COUNT_FACTOR); \n                    a = Math.max(r[1], Math.round(r[2] * (a / Math.max(0.00001, this.renderer.drawnGeodataTilesFactor))));\n\n                    if (job.index >= a) {\n                        return;\n                    } \n                    r[5] = a; //for debug\n                }\n\n            } else {\n                a = job.tiltAngle;\n\n                if (r[0] == 1) {\n                    a = 1.0 - (Math.acos(a) * (1.0/(Math.PI*0.5)));\n                } else if (r[0] == 3) {\n                    a = (Math.cos(Math.acos(a) * 2) + 1.0) * 0.5;\n                }\n\n                var indexLimit = (Math.round(r[1] + (a*r[2]))-1);\n\n                if (job.index > indexLimit) {\n                    return;\n                } \n                r[5] = indexLimit; //for debug\n            }\n        }\n\n        var files = job.files;\n\n        if (job.type != VTS_JOB_VSPOINT) {\n            if (job.type == VTS_JOB_PACK) {\n\n                var notready = false;\n                \n                for (var j = 0, lj = job.subjobs.length; j < lj; j++) {\n                    var subjob = job.subjobs[j];\n\n                    files = subjob.files;\n\n                    if (files.length > 0) {\n                        for (var i = 0, li = files.length; i < li; i++) {\n                            if (files[i].length > 0) {\n                                var font = subjob.fonts[i];\n                                if (font && !font.areTexturesReady(files[i])) {\n                                    notready = true;\n                                }\n                            }\n                        }\n\n                    } else {\n                        texture = hitmapRender ? renderer.whiteTexture : subjob.texture;\n                        if (!texture.loaded) {\n                            notready = true;\n                        }\n                    }\n                }\n\n                if (notready) {\n                    return;\n                }\n\n            } else {\n                files = job.files;\n\n                if (files.length > 0) {\n                    for (var i = 0, li = files.length; i < li; i++) {\n                        if (files[i].length > 0) {\n                            var font = job.fonts[i];\n                            if (font && !font.areTexturesReady(files[i])) {\n                                return;\n                            }\n                        }\n                    }\n\n                } else {\n                    texture = hitmapRender ? renderer.whiteTexture : job.texture;\n                    if (!texture.loaded) {\n                        return;\n                    }\n                }\n            }\n        }\n\n        var p1, p2, camVec, ll, l = null, localTilt;\n\n        if (renderer.useSuperElevation) {\n            if (job.seCounter != renderer.seCounter) {\n                job.seCounter = renderer.seCounter;\n                job.center2 = renderer.transformPointBySE(job.center);\n            }\n        } else {\n            job.center2 = job.center;\n        }\n\n        if (job.culling != 180) {\n            p2 = job.center2;\n            p1 = renderer.cameraPosition;\n            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n            if (job.visibility) {\n                l = vec3.length(camVec);\n\n                switch(job.visibility.length) {\n                    case 1:\n                        if (l > job.visibility[0]) {\n                            return;\n                        }\n                        break;\n\n                    case 2:\n                        ll = l * renderer.localViewExtentFactor;\n                        if (ll < job.visibility[0] || ll > job.visibility[1]) {\n                            return;\n                        }\n\n                        break;\n\n                    case 4:\n                        ll = l * renderer.localViewExtentFactor;\n                        var diameter = job.visibility[0] * job.visibility[1];\n                        if (diameter < (job.visibility[2] * ll) || diameter > (job.visibility[3] * ll)) {\n                            return;\n                        }\n\n                        break;\n                }\n\n                l = 1/l;\n                camVec[0] *= l;                       \n                camVec[1] *= l;                       \n                camVec[2] *= l;                       \n            } else {\n                vec3.normalize(camVec);\n            }\n                \n            job.normal = [0,0,0];\n            vec3.normalize(job.center2, job.normal);\n                \n            localTilt = -vec3.dot(camVec, job.normal);\n\n            if (localTilt < Math.cos(math.radians(job.culling))) {\n                return;\n            }\n            \n        } else if (job.visibility) {\n\n            p2 = job.center2;\n            p1 = renderer.cameraPosition;\n            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            l = vec3.length(camVec);\n\n            switch(job.visibility.length) {\n                case 1:\n                    if (l > job.visibility[0]) {\n                        return;\n                    }\n                    break;\n\n                case 2:\n                    l *= renderer.localViewExtentFactor;\n                    if (l < job.visibility[0] || l > job.visibility[1]) {\n                        return;\n                    }\n\n                    break;\n\n                case 4:\n                    l *= renderer.localViewExtentFactor;\n\n                    var diameter = job.visibility[0] * job.visibility[1];\n                    if (diameter < (job.visibility[2] * l) || diameter > (job.visibility[3] * l)) {\n                        return;\n                    }\n\n                    break;\n            }\n        }\n\n        if (job.type == VTS_JOB_VSPOINT) {\n            //TODO: solve switch an call render\n            var viewExtent = renderer.viewExtent;\n            var lastViewExtent = 0, vswitch = job.vswitch;\n            job.vswitchIndex = 0;\n\n            for (i = 0, li = vswitch.length; i < li; i++) {\n                if (viewExtent <= vswitch[i][0] || i == (li-1)) {\n                    job.vswitchIndex = i;\n                    var slayers = job.vswitch[i];\n\n                    if (slayers) {\n                        slayers = slayers[1];\n\n                        for (j = 0, lj = slayers.length; j < lj; j++) {\n                            var sjob = slayers[j];\n                            sjob.mv = job.mv;\n                            sjob.mvp = job.mvp;\n                            sjob.updatePos = job.updatePos;\n                            sjob.hysteresis = job.hysteresis;\n                            sjob.vswitchIndex = i;\n                            sjob.renderCounter = job.renderCounter;\n                            sjob.localTilt = localTilt;\n                            sjob.id = job.id;\n                            this.drawGpuJob(gpu, gl, renderer, sjob, screenPixelSize, advancedHitPass, ignoreFilters);\n                        }\n                    }\n\n                    return;\n                }\n            }\n\n            return;\n        }\n\n        var s = job.stick;\n        var stickShift = 0, pp, o, depth, stickMode, stickHeight;\n\n        if (s[0] != 0) {\n            stickMode = renderer.config.mapFeatureStickMode;\n            stickHeight = s[0];\n\n            if (stickMode[0]) {\n                if (!localTilt) {\n                    localTilt = job.localTilt;\n\n                    if (!localTilt) {\n                        p2 = job.center2;\n                        p1 = renderer.cameraPosition;\n                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                        vec3.normalize(camVec);\n                        job.normal = [0,0,0];\n                        vec3.normalize(job.center2, job.normal);\n                            \n                        localTilt = -vec3.dot(camVec, job.normal);\n                    }\n                }\n\n                if (stickMode[0] == 2) {\n\n                    var hdelta = renderer.gridHmax - renderer.gridHmin;\n\n                    if (hdelta < 0) {\n                        hdelta = 0;\n                    }\n\n                    if (hdelta < stickHeight) {\n                        stickHeight = hdelta;\n                    }\n                }\n\n                if (localTilt < 0) {\n                    localTilt = 0;\n                }\n               \n                stickShift = Math.pow(1-localTilt,stickMode[1]) * stickHeight * renderer.cameraTiltFator;\n\n            } else {\n                stickShift = renderer.cameraTiltFator * s[0];\n            }\n                \n            if (stickShift < s[1]) {\n                stickShift = 0;\n            }\n\n            if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {\n                stickShift += s[7];\n            }\n\n            //else if (s[2] != 0) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n                pp[0] = Math.round(pp[0]);\n                pp[1] -= stickShift;\n            //}\n        }\n\n        res = this.processNoOverlap(renderer, job, pp, p1, p2, camVec, l, stickShift, texture, files, color);\n\n        if (res.exit) {\n            return;\n        } else {\n            pp = res.pp;\n            p1 = res.p1;\n            p2 = res.p2;\n            camVec = res.camVec;\n            l = res.l;\n        }\n        \n        if (job.type == VTS_JOB_PACK) {\n            return;\n        }\n\n        if (renderer.drawLabelBoxes) {\n            o = job.noOverlap;\n\n            if (o) {\n                if (!pp) {\n                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n                }\n\n                gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n                this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],\n                                     [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);\n\n                if (job.reduce) {\n                    if (job.reduce[0] >= 10) {\n                        this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);\n                    } else {\n                        this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);\n                    }\n                }\n            }\n        }\n\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);\n\n        if (s[0] != 0 && s[2] != 0) {\n            if (!pp) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n            }\n\n            this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], s[6]], null, null, null, null, true);\n        }\n\n        /*if (dinfo) { //debug only\n            if (!pp) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n            }\n\n            var stmp = \"\" + dinfo[0].toFixed(0) + \" \" + dinfo[1].toFixed(0) + \" \" + dinfo[2].toFixed(0) + \" \" + dinfo[3].toFixed(0) + \" \" + dinfo[4].toFixed(0);\n            this.drawText(Math.round(pp[0]-this.getTextSize(10,stmp)*0.5), Math.round(pp[1]), 10, stmp, [1,1,1,1], 0);\n        }*/\n\n        prog = job.program; //renderer.progIcon;\n\n        if (job.singleBuffer) {\n            if (!pp) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n            }\n\n            if (prog == renderer.progIcon) {\n                var b = job.singleBuffer;\n                prog = renderer.progImage;\n\n                if (!job.singleBuffer2) {\n                    job.singleBuffer2 = new Float32Array(b);\n\n                    var tx = 1 / texture.width, ty = 1 / texture.height;\n                    b[2] *= tx; b[3] *= ty;\n                    b[6] *= tx; b[7] *= ty;\n                    b[10] *= tx; b[11] *= ty;\n                    b[14] *= tx; b[15] *= ty;\n                }\n\n                if (job.updatePos) {\n                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n                    pp[1] -= stickShift;\n                }\n\n                var b2 = job.singleBuffer2;\n\n                b[0] = pp[0] + b2[0];\n                b[1] = pp[1] + b2[1];\n\n                b[4] = pp[0] + b2[4];\n                b[5] = pp[1] + b2[5];\n\n                b[8] = pp[0] + b2[8];\n                b[9] = pp[1] + b2[9];\n\n                b[12] = pp[0] + b2[12];\n                b[13] = pp[1] + b2[13];\n\n                gpu.useProgram(prog, ['aPosition']);\n                gpu.bindTexture(texture);\n\n                var vertices = renderer.rectVerticesBuffer;\n                gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n                gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n                var indices = renderer.rectIndicesBuffer;\n                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n                prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n                prog.setMat4('uData', job.singleBuffer );\n                prog.setVec4('uColor', color);\n                prog.setFloat('uDepth', pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2));\n\n                gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n            } else {\n\n                var b = job.singleBuffer, bl = b.length, vbuff, vitems = (b.length / 4) * 6, color2 = job.color2, j = 0;\n\n                if (bl > 384) { vbuff = renderer.textQuads128; prog = renderer.progLabel128; } else\n                if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLabel96; } else\n                if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLabel64; } else\n                if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLabel48; } else\n                if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLabel32; }\n                else { vbuff = renderer.textQuads16; prog = renderer.progLabel16; }\n\n                if (job.updatePos) {\n                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n                    pp[1] -= stickShift;\n                }\n\n                gpu.useProgram(prog, ['aPosition']);\n                prog.setSampler('uSampler', 0);\n                prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n\n                prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], 1, stickShift*2]);\n                prog.setVec3('uOrigin', [pp[0],pp[1],pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2)]);\n                prog.setVec4('uColor', hitmapRender ? color : color2);\n                prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);\n                lj = hitmapRender ? 1 : 2;\n\n                var vertexPositionAttribute = prog.getAttribute('aPosition');\n\n                prog.setVec4('uData', b);\n\n                //bind vetex positions\n                gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);\n                gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);\n\n                //draw polygons\n                for(;j<lj;j++) {\n                    if (j == 1) {\n                        prog.setVec4('uColor', color);\n                        prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);\n                    }\n\n                    for (var i = 0, li = files.length; i < li; i++) {\n                        var fontFiles = files[i];\n\n                        for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                            var file = fontFiles[k];\n                            prog.setFloat('uFile', Math.round(file+i*1000));\n                            gpu.bindTexture(job.fonts[i].getTexture(file));\n                            gl.drawArrays(gl.TRIANGLES, 0, vitems);\n                        }\n                    }\n                }\n\n            }\n            \n            return;   \n        }\n\n        gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aOrigin']);\n        prog.setSampler('uSampler', 0);\n        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n        prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], (job.type == VTS_JOB_LABEL ? 1.0 : 1.0 / texture.width), stickShift*2]);\n\n        var j = 0, lj = 1;\n\n        if (prog != renderer.progIcon) {\n            prog.setVec4('uColor', hitmapRender ? color : job.color2);\n            prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);\n            lj = hitmapRender ? 1 : 2;\n        } else {\n            prog.setVec4('uColor', color);\n        }\n\n        vertexPositionAttribute = prog.getAttribute('aPosition');\n        vertexTexcoordAttribute = prog.getAttribute('aTexCoord');\n        vertexOriginAttribute = prog.getAttribute('aOrigin');\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind vetex texcoordds\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n        gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind vetex origin\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);\n        gl.vertexAttribPointer(vertexOriginAttribute, job.vertexOriginBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //draw polygons\n        for(;j<lj;j++) {\n            if (j == 1) {\n                prog.setVec4('uColor', color);\n                prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);\n            }\n\n            if (files.length > 0) {\n                for (var i = 0, li = files.length; i < li; i++) {\n                    var fontFiles = files[i];\n\n                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                        var file = fontFiles[k];\n                        prog.setFloat('uFile', Math.round(file+i*1000));\n                        gpu.bindTexture(job.fonts[i].getTexture(file));\n                        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n                    }\n                }\n\n            } else {\n                gpu.bindTexture(texture);\n                gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n            }\n        }\n\n        break;\n    }\n\n    return;\n};\n\nRendererDraw.prototype.drawGpuSubJob = function(gpu, gl, renderer, screenPixelSize, subjob, fade) {\n    if (!subjob) {\n        return;\n    }\n\n    var job = subjob[0], stickShift = subjob[1], texture = subjob[2],\n        files = subjob[3], color = subjob[4], pp = subjob[5], s = job.stick,\n        o = job.noOverlap, localTilt, p2, p1, camVec;\n\n    if (renderer.useSuperElevation) {\n        if (job.seCounter != renderer.seCounter) {\n            job.seCounter = renderer.seCounter;\n            job.center2 = renderer.transformPointBySE(job.center);\n        }\n    } else {\n        job.center2 = job.center;\n    }\n\n    if (job.hysteresis && job.id) {\n\n        /*\n        if (job.culling != 180) {\n            p2 = job.center2;\n            p1 = renderer.cameraPosition;\n            var camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            vec3.normalize(camVec);\n                \n            job.normal = [0,0,0];\n            vec3.normalize(job.center2, job.normal);\n                \n            localTilt = -vec3.dot(camVec, job.normal);\n            if (localTilt < Math.cos(math.radians(job.culling))) {\n                return;\n            }\n        }\n\n        //if (o) {\n            //var x1 = pp[0]+o[0], y1 = pp[1]+o[1], \n              //  x2 = pp[0]+o[2], y2 = pp[1]+o[3]+stickShift;\n\n            /*\n            if (s[0] != 0) {\n                stickShift = renderer.cameraTiltFator * s[0];\n                    \n                if (stickShift < s[1]) {\n                    stickShift = 0;\n                }\n            }*/\n\n            /* \n            var rmap = renderer.rmap;\n\n            //screen including credits\n            if (x1 < 0 || x2 > rmap.slx || y1 < 0 || y2 > rmap.sly) {\n                return false;\n            }\n\n            //compass\n            if (x1 < rmap.clx && x2 > 0 && y1 <= rmap.sly && y2 > (rmap.sly - rmap.cly)) {\n                return false;\n            }\n\n            //serach bar\n            if (x1 < rmap.blx && x2 > 0 && y1 <= rmap.bly && y2 > 0) {\n                return false;\n            }*/\n        //}\n\n        if (s[0] != 0) {\n            var stickMode = renderer.config.mapFeatureStickMode;\n            var stickHeight = s[0];\n\n            if (stickMode[0]) {\n                if (!localTilt) {\n                    localTilt = job.localTilt;\n\n                    if (!localTilt) {\n                        p2 = job.center2;\n                        p1 = renderer.cameraPosition;\n                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                        vec3.normalize(camVec);\n                        job.normal = [0,0,0];\n                        vec3.normalize(job.center2, job.normal);\n                            \n                        localTilt = -vec3.dot(camVec, job.normal);\n                    }\n                }\n\n                if (stickMode[0] == 2) {\n\n                    var hdelta = renderer.gridHmax - renderer.gridHmin;\n\n                    if (hdelta < 0) {\n                        hdelta = 0;\n                    }\n\n                    if (hdelta < stickHeight) {\n                        stickHeight = hdelta;\n                    }\n                }\n\n                if (localTilt < 0) {\n                    localTilt = 0;\n                }\n               \n                stickShift = Math.pow(1-localTilt,stickMode[1]) * stickHeight * renderer.cameraTiltFator;\n\n            } else {\n                stickShift = renderer.cameraTiltFator * s[0];\n            }\n              \n            if (stickShift < s[1]) {\n                stickShift = 0;\n            }\n\n            if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {\n                stickShift += s[7];\n            }\n\n\n             //else if (s[2] != 0) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n                pp[0] = Math.round(pp[0]);\n                pp[1] -= stickShift;\n            //}\n\n        }\n\n    }\n\n    var hitmapRender = job.hitable && renderer.onlyHitLayers;\n\n    if (job.type == VTS_JOB_PACK) {\n        if (renderer.drawLabelBoxes && o) {\n            gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n            this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],\n                                 [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);\n\n            if (job.reduce) {\n                if (job.reduce[0] >= 10) {\n                    this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);\n                } else {\n                    this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);\n                }\n            }\n        }\n\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);\n\n        if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {\n            this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], ((fade !== null) ? s[6] * fade : s[6]) ], null, null, null, null, true);\n            //stickShift += s[7];\n        }\n\n        for (var i = 0, li = job.subjobs.length; i < li; i++) {\n            var subjob2 = job.subjobs[i], job2;\n            subjob2.mvp = job.mvp;\n            subjob2.updatePos = job.updatePos;\n\n            var depth = subjob[7];\n\n            o = null;\n            files = subjob2.files;\n\n            if (hitmapRender) {\n                color = subjob[4];\n                texture = renderer.whiteTexture;\n            } else {\n                color = subjob2.color;\n                texture = subjob2.texture;\n            }\n\n            this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, [subjob2, stickShift, texture, files, color, pp, true, depth, o], fade);\n        }\n\n        return;\n    }\n\n\n    if (renderer.drawLabelBoxes && o) {\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n        this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],\n                             [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);\n\n        if (job.reduce) {\n            if (job.reduce[0] >= 10) {\n                this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);\n                //this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.fade, [1,0,0,1], 0.5);\n            } else {\n                this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);\n            }\n        }\n    }\n\n    gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);\n\n    var j = 0, lj = 1, color2 = job.color2;\n\n    if (fade !== null) {\n        color = [color[0], color[1], color[2], color[3] * fade];\n\n        if (color2) {\n            color2 = [color2[0], color2[1], color2[2], color2[3] * fade];\n        }\n    }\n\n    if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {\n        this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], ((fade !== null) ? s[6] * fade : s[6]) ], null, null, null, null, true);\n    }\n\n    var prog = job.program; //renderer.progIcon;\n\n    if (job.singleBuffer) {\n\n        if (prog == renderer.progIcon) {\n            var b = job.singleBuffer;\n            prog = renderer.progImage;\n\n            if (!job.singleBuffer2) {\n                job.singleBuffer2 = new Float32Array(b);\n\n                var tx = 1 / texture.width, ty = 1 / texture.height;\n                b[2] *= tx; b[3] *= ty;\n                b[6] *= tx; b[7] *= ty;\n                b[10] *= tx; b[11] *= ty;\n                b[14] *= tx; b[15] *= ty;\n            }\n\n            if (job.updatePos) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n                pp[1] -= stickShift;\n            }\n\n            var b2 = job.singleBuffer2;\n\n            b[0] = pp[0] + b2[0];\n            b[1] = pp[1] + b2[1];\n\n            b[4] = pp[0] + b2[4];\n            b[5] = pp[1] + b2[5];\n\n            b[8] = pp[0] + b2[8];\n            b[9] = pp[1] + b2[9];\n\n            b[12] = pp[0] + b2[12];\n            b[13] = pp[1] + b2[13];\n\n            gpu.useProgram(prog, ['aPosition']);\n            gpu.bindTexture(texture);\n\n            var vertices = renderer.rectVerticesBuffer;\n            gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n            gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n            var indices = renderer.rectIndicesBuffer;\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n            prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n            prog.setMat4('uData', job.singleBuffer );\n            prog.setVec4('uColor', color);\n            prog.setFloat('uDepth', pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2));\n\n            gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n        } else {\n\n            var b = job.singleBuffer, bl = b.length, vbuff, vitems = (b.length / 4) * 6;\n\n            if (bl > 384) { vbuff = renderer.textQuads128; prog = renderer.progLabel128; } else\n            if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLabel96; } else\n            if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLabel64; } else\n            if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLabel48; } else\n            if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLabel32; }\n            else { vbuff = renderer.textQuads16; prog = renderer.progLabel16; }\n\n            if (job.updatePos) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);\n                pp[1] -= stickShift;\n            }\n\n            gpu.useProgram(prog, ['aPosition']);\n            prog.setSampler('uSampler', 0);\n            prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n\n            prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], 1, stickShift*2]);\n            prog.setVec3('uOrigin', [pp[0],pp[1],pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2)]);\n            prog.setVec4('uColor', hitmapRender ? color : color2);\n            prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);\n            lj = hitmapRender ? 1 : 2;\n\n            var vertexPositionAttribute = prog.getAttribute('aPosition');\n\n            prog.setVec4('uData', b);\n\n            //bind vetex positions\n            gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);\n            gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);\n\n            //draw polygons\n            for(;j<lj;j++) {\n                if (j == 1) {\n                    prog.setVec4('uColor', color);\n                    prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);\n                }\n\n                for (var i = 0, li = files.length; i < li; i++) {\n                    var fontFiles = files[i];\n\n                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                        var file = fontFiles[k];\n                        prog.setFloat('uFile', Math.round(file+i*1000));\n                        gpu.bindTexture(job.fonts[i].getTexture(file));\n                        gl.drawArrays(gl.TRIANGLES, 0, vitems);\n                    }\n                }\n            }\n\n        }\n        \n        return;   \n    }\n\n    gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aOrigin']);\n    prog.setSampler('uSampler', 0);\n    prog.setMat4('uMVP', job.mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n    prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], (job.type == VTS_JOB_LABEL ? 1.0 : 1.0 / texture.width), stickShift*2]);\n\n    if (prog != renderer.progIcon) {\n        prog.setVec4('uColor', hitmapRender ? color : color2);\n        prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);\n        lj = hitmapRender ? 1 : 2;\n    } else {\n        prog.setVec4('uColor', color);\n    }\n\n    var vertexPositionAttribute = prog.getAttribute('aPosition');\n    var vertexTexcoordAttribute = prog.getAttribute('aTexCoord');\n    var vertexOriginAttribute = prog.getAttribute('aOrigin');\n\n    //bind vetex positions\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n    gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    //bind vetex texcoordds\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n    gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    //bind vetex origin\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);\n    gl.vertexAttribPointer(vertexOriginAttribute, job.vertexOriginBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    //draw polygons\n    for(;j<lj;j++) {\n        if (j == 1) {\n            prog.setVec4('uColor', color);\n            prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);\n        }\n\n        if (files.length > 0) {\n            for (var i = 0, li = files.length; i < li; i++) {\n                var fontFiles = files[i];\n\n                for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                    var file = fontFiles[k];\n                    prog.setFloat('uFile', Math.round(file+i*1000));\n                    gpu.bindTexture(job.fonts[i].getTexture(file));\n                    gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n                }\n            }\n\n        } else {\n            gpu.bindTexture(texture);\n            gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n        }\n    }\n};\n\n\nfunction q4Slerp(a, b, t, out) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  var bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n  var omega, cosom, sinom, scale0, scale1;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if ( cosom < 0.0 ) {\n    cosom = -cosom;\n    bx = - bx;\n    by = - by;\n    bz = - bz;\n    bw = - bw;\n  }\n  // calculate coefficients\n  if ( (1.0 - cosom) > 0.000001) {\n    // standard case (slerp)\n    omega  = Math.acos(cosom);\n    sinom  = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n\n  return out;\n}\n\nRendererDraw.prototype.drawGpuSubJobLineLabel = function(gpu, gl, renderer, screenPixelSize, subjob, fade) {\n    if (!subjob) {\n        return;\n    }\n\n    var job = subjob[0], texture = subjob[2],\n        files = subjob[3], color = subjob[4], pp = subjob[5],\n        o = job.noOverlap, localTilt, p2, p1, camVec, prog,\n        useSE = renderer.useSuperElevation;\n\n    if (useSE) {\n        if (job.seCounter != renderer.seCounter) {\n            job.seCounter = renderer.seCounter;\n            job.labelPointsBuffer.id = -1;\n            job.center2 = renderer.transformPointBySE(job.center);\n        }\n    } else {\n        job.center2 = job.center;\n    }\n\n    var hitmapRender = job.hitable && renderer.onlyHitLayers, j, lj, p, p2;\n\n    var gamma = job.outline[2] * 1.4142 / 20;\n    var gamma2 = job.outline[3] * 1.4142 / 20;\n\n    if (job.singleBuffer) {\n\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n\n        //if (job.labelPoints.length < 1) return;\n\n        pp = subjob[5];\n\n        if (!pp || job.updatePos) {\n            pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);                    \n        }\n\n        var targetSize = job.labelSize * 0.5; \n        var sizeFactor = renderer.camera.scaleFactor2(pp[3])*0.5*renderer.curSize[1]*(renderer.curSize[0]/renderer.curSize[1]);\n        var labelPoints = job.labelPoints;\n        var labelIndex = job.labelIndex;\n        var labelMorph = 0;\n\n        lj = labelPoints.length;\n\n        if (lj <= 1 || labelPoints[lj -1][0]*sizeFactor < targetSize) {\n            return;\n        }\n\n        lj--;\n\n        for (j = 0; j < lj; j++) {\n            var s2 = labelPoints[j+1][0] * sizeFactor;\n\n            if (s2 > targetSize) {\n                var s1 = labelPoints[j][0] * sizeFactor;\n\n                labelIndex = j;\n                labelMorph = (targetSize - s1) / (s2 - s1);\n                break;                \n            }\n        }\n\n        var pointsIndex = (vec3.dot(labelPoints[labelIndex][1], renderer.labelVector) >= 0) ? 3 : 2;\n\n        var b = (pointsIndex == 3) ? job.singleBuffer2 : job.singleBuffer, bl = b.length, vbuff, vitems = (b.length / 4) * 6;\n\n        var points = labelPoints[labelIndex][pointsIndex], index = 0;\n        var points2 = (labelPoints[labelIndex+1]) ? labelPoints[labelIndex+1][pointsIndex] : points;\n        var q = [0,0,0,0], buffer;\n\n        if (useSE) {\n            buffer = job.labelPointsBuffer;\n\n            if (buffer.id != (labelIndex * 1024 + pointsIndex)) {\n                buffer.id = (labelIndex * 1024 + pointsIndex);\n                if (buffer.points.length != points.length) {\n                    buffer.points = new Array(points.length);\n                    buffer.points2 = new Array(points.length);\n                }\n\n                var sePoints = buffer.points;\n                var sePoints2 = buffer.points2;\n\n                for(j = 0, lj = points.length; j < lj; j++) {\n                    sePoints[j] = renderer.transformPointBySE2(points[j]);\n                    sePoints2[j] = renderer.transformPointBySE2(points2[j]);\n                }\n\n                points = sePoints;\n                points2 = sePoints2;\n\n            } else {\n                points = buffer.points;\n                points2 = buffer.points2;\n            }\n        }\n\n        if (!points.length || !points2.length) {\n            return;\n        }\n\n        for(j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n            p2 = points2[j];\n\n            if (useSE) {\n                b[index] = (p[4]+p[13]) + ((p2[4]+p2[13]) - (p[4]+p[13])) * labelMorph;\n                b[index+1] = (p[5]+p[14]) + ((p2[5]+p2[14]) - (p[5]+p[14])) * labelMorph;\n                b[index+2] = (p[6]+p[15]) + ((p2[6]+p2[15]) - (p[6]+p[15])) * labelMorph;\n            } else {\n                b[index] = p[4] + (p2[4] - p[4]) * labelMorph;\n                b[index+1] = p[5] + (p2[5] - p[5]) * labelMorph;\n                b[index+2] = p[6] + (p2[6] - p[6]) * labelMorph;\n            }\n\n            q4Slerp([p[7],p[8],p[9],p[10]], [p2[7],p2[8],p2[9],p2[10]], labelMorph, q);\n\n            b[index+3] = q[0];\n            b[index+4] = q[1];\n            b[index+5] = q[2];\n            b[index+6] = q[3];\n\n            b[index+7] = p[11] + (p2[11] - p[11]) * labelMorph;\n            b[index+8] = p[12] + (p2[12] - p[12]) * labelMorph;\n\n            index += 12;\n        }\n\n        if (bl > 384) { vbuff = renderer.textQuads128; prog = renderer.progLineLabel128; } else\n        if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLineLabel96; } else\n        if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLineLabel64; } else\n        if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLineLabel48; } else\n        if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLineLabel32; }\n        else { vbuff = renderer.textQuads16; prog = renderer.progLineLabel16; }\n\n        var color2 = job.color2;\n\n        if (fade !== null) {\n            color = [color[0], color[1], color[2], color[3] * fade];\n\n            if (color2) {\n                color2 = [color2[0], color2[1], color2[2], color2[3] * fade];\n            }\n        }\n\n        gpu.useProgram(prog, ['aPosition']);\n        prog.setSampler('uSampler', 0);\n        prog.setMat4('uMVP', job.mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n\n        prog.setVec4('uColor', hitmapRender ? color : color2);\n        prog.setVec2('uParams', [job.outline[0], gamma2]);\n        var lj = hitmapRender ? 1 : 2;\n\n        var vertexPositionAttribute = prog.getAttribute('aPosition');\n\n        prog.setVec4('uData', b);\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);\n        gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);\n\n        //draw polygons\n        for(j = 0, lj = (hitmapRender ? 1 : 2); j < lj; j++) {\n            if (j == 1) {\n                prog.setVec4('uColor', color);\n                prog.setVec2('uParams', [job.outline[1], gamma]);\n            }\n\n            for (var i = 0, li = files.length; i < li; i++) {\n                var fontFiles = files[i];\n\n                for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                    var file = fontFiles[k];\n                    prog.setFloat('uFile', Math.round(file+i*1000));\n                    gpu.bindTexture(job.fonts[i].getTexture(file));\n                    gl.drawArrays(gl.TRIANGLES, 0, vitems / 3); //TODO: demystify vitems\n                }\n            }\n        }\n\n        if (renderer.drawLabelBoxes) {\n            var margin = o ? o[0] : 1, pp = [0,0,0], r;\n\n            for(j = 0, lj = points.length; j < lj; j++) {\n                p = points[j];\n                p2 = points2[j];\n\n                pp[0] = p[0] + (p2[0] - p[0]) * labelMorph;\n                pp[1] = p[1] + (p2[1] - p[1]) * labelMorph;\n                pp[2] = p[2] + (p2[2] - p[2]) * labelMorph;\n                r = p[3] + (p2[3] - p[3]) * labelMorph;\n\n                pp = renderer.project2(pp, renderer.camera.mvp, renderer.cameraPosition, true);                    \n                this.drawCircle(pp, r*sizeFactor*margin, 1, [255, 0, 255, 255], null, null, null, null, null);\n            }\n\n            pp = subjob[5];\n\n            if (!pp) {\n                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition, true);                    \n            }\n\n            this.drawCircle(pp, 8, 1, [255, 255, 0, 255], null, null, null, null, null);\n\n            if (job.reduce) {\n                if (job.reduce[0] >= 10) {\n                    this.drawText(pp[0], pp[1]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);\n                } else {\n                    this.drawText(pp[0], pp[1]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);\n                }\n            }\n        }\n\n        return;\n    }\n\n};\n\nexport default RendererDraw;\n","\nimport BBox_ from './bbox';\n\n//get rid of compiler mess\nvar BBox = BBox_;\n\n\nvar RendererGeometry = {};\n\n\nRendererGeometry.setFaceVertices = function(vertices, a, b, c, index) {\n    vertices[index] = a[0];\n    vertices[index+1] = a[1];\n    vertices[index+2] = a[2];\n\n    vertices[index+3] = b[0];\n    vertices[index+4] = b[1];\n    vertices[index+5] = b[2];\n\n    vertices[index+6] = c[0];\n    vertices[index+7] = c[1];\n    vertices[index+8] = c[2];\n};\n\n\nRendererGeometry.setFaceUVs = function(uvs, a, b, c, index) {\n    uvs[index] = a[0];\n    uvs[index+1] = a[1];\n\n    uvs[index+2] = b[0];\n    uvs[index+3] = b[1];\n\n    uvs[index+4] = c[0];\n    uvs[index+5] = c[1];\n};\n\n\n// Procedural mesh representing a heightmap block\n// Creates a grid of size x size vertices, all coords are [0..1].\nRendererGeometry.buildHeightmap = function(size, use16bit) {\n    size--;\n\n    var g = RendererGeometry;\n    var numFaces = (size* size) * 2;\n    var vertices = new Float32Array(numFaces * 3 * 3);//[];\n    var uvs = new Float32Array(numFaces * 3 * 2);//[];\n\n    var factor = 1.0 * size;\n    var index = 0;\n    var index2 = 0;\n\n    for (var i = 0; i < size; i++) {\n        for (var j = 0; j < size; j++) {\n            var x1 = (j) * factor;\n            var x2 = (j+1) * factor;\n\n            var y1 = (i) * factor;\n            var y2 = (i+1) * factor;\n\n            g.setFaceVertices(vertices, [x1, y1, 0], [x2, y1, 0], [x2, y2, 0], index);\n            g.setFaceUVs(uvs, [x1, y1], [x2, y1], [x2, y2], index2);\n            index += 9;\n            index2 += 6;\n\n            g.setFaceVertices(vertices, [x2, y2, 0], [x1, y2, 0], [x1, y1, 0], index);\n            g.setFaceUVs(uvs, [x2, y2], [x1, y2], [x1, y1], index2);\n            index += 9;\n            index2 += 6;\n        }\n    }\n\n    var bbox = new BBox(0,0,0,1,1,1);\n\n    if (use16bit) {\n        return { bbox:bbox, vertices:this.covnetTo16Bit(vertices), uvs: this.covnetTo16Bit(uvs)};\n    } else {\n        return { bbox:bbox, vertices:vertices, uvs: uvs};\n    }\n};\n\n\nRendererGeometry.buildPlane = function(size, use16bit) {\n    size--;\n\n    var g = RendererGeometry;\n    var numFaces = (size* size) * 2;\n    var vertices = (use16bit) ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n    var uvs = new Float32Array(numFaces * 3 * 2);//[];\n\n    var factor = 1.0 / (size);\n    var index = 0, index2 = 0;\n    var x1, y1, x2, y2, xx1, xx2, yy1, yy2;\n\n    for (var i = 0; i < size; i++) {\n        for (var j = 0; j < size; j++) {\n            x1 = j;\n            x2 = j+1;\n            y1 = i;\n            y2 = i+1;\n\n            xx1 = j * factor;\n            xx2 = (j+1) * factor;\n            yy1 = (i) * factor;\n            yy2 = (i+1) * factor;\n\n            g.setFaceVertices(vertices, [x1, y1, 0], [x1, y2, 0], [x2, y2, 0], index);\n            g.setFaceUVs(uvs, [xx1, yy1], [xx1, yy2], [xx2, yy2], index2);\n            index += 9;\n            index2 += 6;\n\n            g.setFaceVertices(vertices, [x2, y2, 0], [x2, y1, 0], [x1, y1, 0], index);\n            g.setFaceUVs(uvs, [xx2, yy2], [xx2, yy1], [xx1, yy1], index2);\n            index += 9;\n            index2 += 6;\n        }\n    }\n\n    var bbox = new BBox(0,0,0,1,1,1);\n\n    if (use16bit) {\n        return { bbox:bbox, vertices:vertices, uvs: this.covnetTo16Bit(uvs)};\n    } else {\n        return { bbox:bbox, vertices:vertices, uvs: uvs};\n    }\n};\n\nRendererGeometry.spherePos = function(lon, lat) {\n    lat *= Math.PI;\n    lon *= 2*Math.PI;\n\n    return [Math.cos(lon)*Math.sin(lat)*0.5 + 0.5,\n        Math.sin(lon)*Math.sin(lat)*0.5 + 0.5,\n        Math.cos(lat) * 0.5 + 0.5];\n};\n\n\n// Creates an approximation of a unit sphere, note that all coords are\n// in the range [0..1] and the center is in (0.5, 0.5). Triangle \"normals\"\n// are oriented inwards.\nRendererGeometry.buildSkydome = function(latitudeBands, longitudeBands, use16bit, useIndices) {\n    var g = RendererGeometry;\n    var numFaces = (latitudeBands * longitudeBands) * 2;\n    var numVertices = (latitudeBands * longitudeBands) * (useIndices ? 1 : 3);\n    var vertices = new Float32Array(numVertices * 3);\n    var uvs = new Float32Array(numVertices * 2);\n    var indices = useIndices ? (new Uint16Array(numFaces * 3)) : null;\n    var index = 0, index2 = 0;\n    var g = RendererGeometry, lat, lon, lon2, lat2, v, flon, flat;\n\n    if (useIndices) {\n\n        for (lat = 0; lat < latitudeBands; lat++) {\n            for (lon = 0; lon < longitudeBands; lon++) {\n\n                flon = lon / longitudeBands;\n                flat = lat / latitudeBands;\n                v = g.spherePos(flon, flat);\n\n                vertices[index] = v[0];\n                vertices[index+1] = v[1];\n                vertices[index+2] = v[2];\n\n                uvs[index2] = flon;\n                uvs[index2+1] = flat;\n\n                index += 3;\n                index2 += 2;\n            }\n        }\n\n        index = 0;\n\n        for (lat = 0; lat < (latitudeBands - 1); lat++) {\n            for (lon = 0; lon < longitudeBands; lon++) {\n\n                lat2 = lat + 1;\n                lon2 = lon + 1;\n\n                if (lon2 >= longitudeBands) {\n                    lon2 = 0;\n                }\n\n                indices[index] = (lat2 * longitudeBands) + lon;\n                indices[index+1] = (lat * longitudeBands) + lon;\n                indices[index+2] = (lat * longitudeBands) + lon2;\n\n                indices[index+3] = (lat * longitudeBands) + lon2;\n                indices[index+4] = (lat2 * longitudeBands) + lon2;\n                indices[index+5] = (lat2 * longitudeBands) + lon;\n\n                index += 6;\n            }\n        }\n\n    } else {\n\n        for (var lat = 0; lat < latitudeBands; lat++) {\n            for (var lon = 0; lon < longitudeBands; lon++) {\n\n                var lon1 = ((lon) / longitudeBands);\n                var lon2 = ((lon+1) / longitudeBands);\n\n                var lat1 = ((lat) / latitudeBands);\n                var lat2 = ((lat+1) / latitudeBands);\n\n                g.makeQuad(lon1, lat1, lon2, lat2, vertices, index, uvs, index2);\n                index += 9*2;\n                index2 += 6*2;\n            }\n        }\n\n    }\n\n    var bbox = new BBox(0,0,0,1,1,1);\n\n    if (use16bit) {\n        return { bbox:bbox, vertices:this.covnetTo16Bit(vertices), uvs: this.covnetTo16Bit(uvs), indices:indices};\n    } else {\n        return { bbox:bbox, vertices:vertices, uvs: uvs, indices:indices};\n    }\n};\n\nRendererGeometry.covnetTo16Bit = function(array) {\n    var t, array2 = new Uint16Array(array.length);\n\n    for (var i = 0, li = array.length; i < li; i++) {\n        t = array[i] * 65535;\n        if (t < 0) t = 0; if (t > 65535) t = 65535;\n        array2[i] = t;\n    }\n\n    return array2;\n}\n\n\nRendererGeometry.makeQuad = function(lon1, lat1, lon2, lat2, vertices, index, uvs, index2) {\n    var g = RendererGeometry;\n    var a = g.spherePos(lon1, lat1), ta = [lon1, lat1];\n    var b = g.spherePos(lon1, lat2), tb = [lon1, lat2];\n    var c = g.spherePos(lon2, lat1), tc = [lon2, lat1];\n    var d = g.spherePos(lon2, lat2), td = [lon2, lat2];\n    g.setFaceVertices(vertices, b, a, c, index);\n    g.setFaceUVs(uvs, tb, ta, tc, index2);\n    g.setFaceVertices(vertices, c, d, b, index+9);\n    g.setFaceUVs(uvs, tc, td, tb, index2+6);\n};\n\n\nexport default RendererGeometry;\n\n\n","\n\nfunction processGMap(gpu, gl, renderer, screenPixelSize, draw) {\n    if (!renderer.config.mapFeaturesReduceParams) {\n        return;\n    }\n\n    var tileCount = renderer.config.mapFeaturesReduceParams[1]; //31; //labelGridCells\n    var featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[0]; //0.6614; //labelsPerSquareInch\n    var ppi = 96 * (window.devicePixelRatio || 1);\n    var screenLX = renderer.curSize[0];\n    var screenLY = renderer.curSize[1];\n    var featureCount = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch); \n    var i, li, top = renderer.config.mapFeaturesSortByTop;\n\n    if (tileCount <= 0) {\n        tileCount = featureCount * 2; //31; //labelGridCells\n    } else {\n        tileCount = tileCount;\n    }\n\n    //renderer.debugStr = '<br>featuresPerScr: ' + featureCount + '<br>gridCells: ' + tileCount + '';\n\n    //get top features\n    var featureCache = renderer.gmap;\n    var featureCacheSize = renderer.gmapIndex;\n    var topFeatures = renderer.gmapTop;\n    var featureCount2 = featureCount;\n\n    if (featureCount > featureCacheSize) {\n        featureCount2 = featureCacheSize;\n    }\n\n    //distribute top features\n    var tileSize = Math.floor(Math.sqrt((screenLX*screenLY) / tileCount));\n    var hitMap = renderer.gmapHit, usedFeatures = 0;\n    var tileFeatures, count, feature, job;\n    var drawAllLabels = renderer.drawAllLabels;\n\n    var colors = [\n        [0, 0, 255, 255],\n        [128, 0, 255, 255],\n        [255, 0, 0, 255],\n        [255, 128, 0, 255],\n        [0, 255, 0, 255],\n        [0, 255, 128, 255],\n        [128, 255, 128, 255]\n    ];\n\n    var colorIndex = 0;\n\n    do {\n        var a,b,c,d,ix,iy,is,pp,tx,ty,mx,my,v,index,o,j;\n\n        ix = screenLX / tileSize;\n        iy = screenLY / tileSize;\n        is = ix * iy;\n        mx = Math.floor(ix);\n        my = Math.floor(iy);\n        ix = ix - mx;\n        iy = iy - my;\n\n        a = 1 / is;\n        b = ix / is;\n        c = iy / is;\n        d = (ix*iy) / is;\n\n        a = Math.floor(a * featureCount);\n        b = Math.floor(b * featureCount);\n        c = Math.floor(c * featureCount);\n        d = Math.floor(d * featureCount);\n\n        var hitMap = renderer.gmapStore;\n        var hitMapCount = renderer.gmapHit;\n\n        if (renderer.drawGridCells) {\n            gpu.setState(renderer.lineLabelState);\n\n            var x = 0, y = 0, j, lj;\n\n            for (j = 0, lj = (my + 1); j < lj; j++) {\n                for (i = 0, li = (mx + 1); i < li; i++) {\n                    x = tileSize * i;\n                    y = tileSize * j;\n\n                    v = a;\n\n                    if (i >= mx) {\n                        if (j >= my) {\n                            v =d;\n                        } else {\n                            v = b;\n                        }\n\n                    } else {\n                        if (j >= my) {\n                            v = b;\n                        }\n                    }\n\n                    draw.drawLineString([[x, y, 0.5], [x+tileSize, y, 0.5],\n                                         [x+tileSize, y+tileSize, 0.5], [x, y+tileSize, 0.5]], true, 1, colors[colorIndex], null, true, null, null, null);\n\n                    draw.drawText(Math.round(x+5), Math.round(y + 5 + colorIndex * 15), 10, '' + v, colors[colorIndex], 0.5);\n                }\n            }\n\n        }\n\n\n        //clear hit-map\n        for (i = 0, li = (mx+1) * (my+1); i < li; i++) {\n            hitMap[i] = null;\n        }\n\n        for (i = 0, li = featureCacheSize; i < li; i++) {\n            feature = featureCache[i];\n            if (!feature) {\n                continue;\n            }\n\n            pp = feature[5];\n\n            if (pp[0] < 30 || pp[0] >= (screenLX-30) || pp[1] < 30 || pp[1] >= (screenLY-30)) {\n                featureCache[i] = null;\n                continue;\n            }\n\n            tx = pp[0] / tileSize;\n            ty = pp[1] / tileSize;\n\n            if (tx > mx) {\n                if (ty > my) {\n                    v = d;\n                } else {\n                    v = b;\n                }\n            } else if (ty > my) {\n                v = c;\n            } else {\n                v = a;\n            }\n\n            if (v > 0) {\n                index = Math.floor(tx) + Math.floor(ty) * (mx + 1);\n\n                tileFeatures = hitMap[index];\n\n                if (tileFeatures) {\n                    hitMap[index].push(i);\n                } else {\n                    hitMap[index] = [i];\n                    hitMapCount[index] = v;\n                }\n            }\n        }\n\n        for (i = 0, li = (mx+1) * (my+1); i < li; i++) {\n            tileFeatures = hitMap[i];\n\n            if (tileFeatures && tileFeatures.length) {\n                count = hitMapCount[i];\n\n                if (count > tileFeatures.length) {\n                    count = tileFeatures.length;\n                }\n\n                sortFeatures(tileFeatures, top, count, renderer);\n\n                for (j = 0; j < count; j++){\n                    index = topFeatures[j]\n                    feature = featureCache[index];\n                    topFeatures[j] = null;\n                    featureCache[index] = null;\n                    job = feature[0];\n\n                    //render job\n                    if (!drawAllLabels && feature[6]) { //no-overlap \n                        pp = feature[5];\n                        o = feature[8];\n\n                        if (!renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob)) {\n                        }\n\n                        if (job.type == VTS_JOB_LINE_LABEL) {\n                            if (renderer.rmap.addLineLabel(job.lastSubJob, depthParams)) {\n                                //renderer.rmap.storeRemovedLineLabel(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob);\n                            }\n                        } else {\n                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, depthParams)) {\n                                renderer.rmap.storeRemovedRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob);\n                            }\n                        }\n\n                    } else {\n                        if (job.hysteresis) {\n                            renderer.jobHBuffer[job.id] = job;\n                        } else {\n                            renderer.drawnJobs++;\n\n                            if (job.type == VTS_JOB_LINE_LABEL) {\n                                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                            } else {\n                                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                            }\n                        }\n                    }\n                }\n\n            }\n        }\n\n        a *= mx * my;\n        b *= mx;\n        c *= my;\n\n        usedFeatures += a + b + c + d;\n        featureCount -= a + b + c + d;\n        tileSize *= 2;\n\n        colorIndex++;\n\n    } while(usedFeatures < featureCount2);\n\n}\n\n\nfunction sortFeatures(features, top, count, renderer) {\n    var value, feature;\n    var currentIndex = 0;\n    var currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n    var topFeatures = renderer.gmapTop;\n    var topFeaturesIndex = 0;\n    var topFeaturesIndex2 = 0;\n\n    //remove feature from cache\n    var featureCache = renderer.gmap, index;\n\n\n    do {\n        var currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n        topFeaturesIndex2 = topFeaturesIndex;\n\n        for (var i = 0, li = features.length; i < li; i++) {\n            index = features[i];\n            feature = featureCache[index];\n            value = feature[0].reduce[1];\n\n            if (((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {\n                if (currentValue != value) {\n                    topFeaturesIndex = topFeaturesIndex2;\n                }\n\n                topFeatures[topFeaturesIndex] = index;\n                topFeaturesIndex++;\n                currentValue = value;\n            }\n        }\n\n        currentValue2 = currentValue;\n        currentIndex++;\n\n    } while(currentIndex < count);\n\n}\n\nfunction storeFeatureToHitmap(id, feature, ix, iy, mx, my, hitMap, hcache, hcacheSize) {\n    var x1 = ix - 1, y1 = iy - 1, x,\n        x2 = ix + 1, y2 = iy + 1, index, blockFeatures;\n\n    if (x1 < 0) x1 = 0;\n    if (y1 < 0) y1 = 0;\n    if (x2 > mx) x2 = mx;\n    if (y2 > my) y2 = my;\n\n    for (; y1 <= y2; y1++) {\n        for (x = x1; x <= x2; x++) {\n            index = (y1 * mx + x) * 2;\n            blockFeatures = hitMap[index];\n\n            if (!hitMap[index]) {\n                hitMap[index] = hcacheSize;\n                hitMap[index+1] = hcacheSize+1;\n                hcache[hcacheSize] = feature;\n                hcache[hcacheSize+1] = 0;\n                hcacheSize +=2;\n            } else {\n                hcache[hitMap[index+1]] = hcacheSize;\n                hitMap[index+1] = hcacheSize+1;\n                hcache[hcacheSize] = feature;\n                hcache[hcacheSize+1] = 0;\n                hcacheSize +=2;\n            }\n        }\n    }\n\n    return hcacheSize;\n}\n\n\nfunction processGMap4(gpu, gl, renderer, screenPixelSize, draw) {\n    if (!renderer.config.mapFeaturesReduceParams) {\n        return;\n    }\n\n    var ppi = 96 * (window.devicePixelRatio || 1);\n\n    var maxRadius = renderer.config.mapFeaturesReduceParams[0] * ppi; //mapFeatureRadius\n    var maxHitcount = renderer.config.mapFeaturesReduceParams[1]; //0.6614; //mapFeatureMaxOverlays\n\n    var screenLX = renderer.curSize[0];\n    var screenLY = renderer.curSize[1];\n    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp;\n    var feature, feature2, pp, pp2, o, job;\n    var drawAllLabels = renderer.drawAllLabels;\n\n    //get top features\n    var featureCache = renderer.gmap;\n    var featureCacheSize = renderer.gmapIndex;\n\n    var hcache = renderer.gmap2;\n    var hcacheSize = 1;\n    var hmap = renderer.gmap3;\n    var hmapSize = renderer.gmap3Size;\n    var hmap = renderer.gmap3;\n\n\n    var hmin = 10000;\n    var hmax = 0, h, r;\n\n    var divByDist = (renderer.config.mapFeaturesReduceFactor >= 1);\n\n    if (divByDist) { // imp / dists\n        if (renderer.fmaxDist == Number.NEGATIVE_INFINITY || renderer.fminDist == Number.POSITIVE_INFINITY) {\n            return;\n        }\n\n        var ub = 1 - Math.log(renderer.fminDist) / Math.log(101);\n        var lb = -Math.log(renderer.fmaxDist) / Math.log(101); \n    }\n\n    //filter features and sort them by importance\n    for (i = 0, li = featureCacheSize; i < li; i++) {\n        feature = featureCache[i];\n        if (!feature) {\n            continue;\n        }\n\n        pp = feature[5];\n\n        if (divByDist) {\n            r = feature[0].reduce;\n            h = Math.round(-5000 + ( ( Math.log(r[1]+1) - Math.log(r[4]) ) / Math.log(101) - lb ) / ( ub-lb ) * 10000) + 5000;\n            r[5] = h; //for debug\n        } else {\n            h = Math.round(feature[0].reduce[1]);            \n        }\n\n        if (h < 0) h = 0;\n        if (h >= 10000) h = 9999;\n        if (h < hmin) hmin = h;\n        if (h > hmax) hmax = h;\n\n        hmap[h][hmapSize[h]++] = feature;\n    }\n\n    var invMaxRadius = 1 / maxRadius, index, ix, iy, features;\n    var mx = Math.floor(screenLX * invMaxRadius);\n    var my = Math.floor(screenLY * invMaxRadius);\n\n    var hitMap = renderer.gmapStore;\n    var hitMapCount = renderer.gmapHit;\n\n    //clear hit-map\n    for (i = 0, li = (mx+1) * (my+1) * 2; i < li; i+=2) {\n        hitMap[i] = 0;\n    }\n\n    //var hitCache = renderer.gmapHit2;\n    var hitCacheSize = 0, j, lj, k, lk, hitCount, dx, dy, blockFeatures;\n\n    maxRadius *= maxRadius;\n\n    for (i = hmax, li = hmin; i >= 0; i--) {\n\n        if (hmapSize[i] > 0) {\n            var features = hmap[i];\n\n            for (j = 0, lj = hmapSize[i]; j < lj; j++) {\n                feature = features[j];\n                job = feature[0];\n\n                hitCount = 0;\n                pp = feature[5];\n\n                //check area\n                ix = Math.floor(pp[0] * invMaxRadius);\n                iy = Math.floor(pp[1] * invMaxRadius);\n                index = ((iy * mx) + ix) * 2;\n                //blockFeatures = hitMap[index];\n\n                //check\n                if (hitMap[index]) {\n                    index = hitMap[index];\n                    do {\n                        feature2 = hcache[index];\n                        pp2 = feature2[5];\n\n                        dx = pp[0] - pp2[0];\n                        dy = pp[1] - pp2[1];\n\n                        if ((dx*dx+dy*dy) < maxRadius) {\n                            hitCount++;\n                            if (hitCount > maxHitcount) {\n                                break;\n                            }\n                        }\n\n                        index = hcache[index+1];\n                    } while (index);\n                }\n\n                // check                \n                if (hitCount <= maxHitcount) {\n                    index = hitCacheSize;\n\n                    //render job\n                    if (!drawAllLabels && feature[6]) { //no-overlap \n                        pp = feature[5];\n                        o = feature[8];\n\n                        if (job.type == VTS_JOB_LINE_LABEL) {\n                            if (renderer.rmap.addLineLabel(job.lastSubJob, null)) {\n                                hitCacheSize++;\n                            }\n                        } else {\n                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, null)) {\n                                hitCacheSize++;\n                            }\n                        }\n\n                    } else {\n                        if (job.hysteresis) {\n                            renderer.jobHBuffer[job.id] = job;\n                        } else {\n                            renderer.drawnJobs++;\n\n                            if (job.type == VTS_JOB_LINE_LABEL) {\n                                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                            } else {\n                                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                            }\n                        }\n\n                        //hitCache[hitCacheSize] = feature;\n                        hitCacheSize++;\n                    }\n\n                    //store to hitmap\n                    if (index != hitCacheSize) {\n                        hcacheSize = storeFeatureToHitmap(index, feature, ix, iy, mx, my, hitMap, hcache, hcacheSize);\n                    }\n                }\n\n            }\n\n            hmapSize[i] = 0;  //zero size\n        }\n    }\n}\n\nfunction processGMap5(gpu, gl, renderer, screenPixelSize, draw) {\n    if (!renderer.config.mapFeaturesReduceParams) {\n        return;\n    }\n\n    var ppi = 96 * (window.devicePixelRatio || 1);\n\n    var screenLX = renderer.curSize[0];\n    var screenLY = renderer.curSize[1];\n    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp;\n    var feature, feature2, pp, pp2, o, job;\n    var drawAllLabels = renderer.drawAllLabels;\n\n    //get top features\n    var featureCache = renderer.gmap;\n    var featureCacheSize = renderer.gmapIndex;\n\n    var hcache = renderer.gmap2;\n    var hcacheSize = 1;\n    var hmap = renderer.gmap3;\n    var hmapSize = renderer.gmap3Size;\n    var hmap = renderer.gmap3;\n\n\n    var hmin = 10000;\n    var hmax = 0, h, r;\n\n    var divByDist = (renderer.config.mapFeaturesReduceFactor >= 1);\n\n    if (divByDist) { // imp / dists\n        if (renderer.fmaxDist == Number.NEGATIVE_INFINITY || renderer.fminDist == Number.POSITIVE_INFINITY) {\n            return;\n        }\n\n        var ub = 1 - Math.log(renderer.fminDist) / Math.log(101);\n        var lb = -Math.log(renderer.fmaxDist) / Math.log(101); \n    }\n\n    //filter features and sort them by importance\n    for (i = 0, li = featureCacheSize; i < li; i++) {\n        feature = featureCache[i];\n        if (!feature) {\n            continue;\n        }\n\n        pp = feature[5];\n\n        if (divByDist) {\n            r = feature[0].reduce;\n            h = Math.round(-5000 + ( ( Math.log(r[1]+1) - Math.log(r[4]) ) / Math.log(101) - lb ) / ( ub-lb ) * 10000) + 5000;\n            r[5] = h; //for debug\n        } else {\n            h = Math.round(feature[0].reduce[1]);            \n        }\n\n        if (h < 0) h = 0;\n        if (h >= 10000) h = 9999;\n        if (h < hmin) hmin = h;\n        if (h > hmax) hmax = h;\n\n        hmap[h][hmapSize[h]++] = feature;\n    }\n\n    var j, lj;\n\n    for (i = hmax, li = hmin; i >= 0; i--) {\n\n        if (hmapSize[i] > 0) {\n            var features = hmap[i];\n\n            for (j = 0, lj = hmapSize[i]; j < lj; j++) {\n                feature = features[j];\n                job = feature[0];\n                pp = feature[5];\n\n                // check                \n\n                //render job\n                if (!drawAllLabels && feature[6]) { //no-overlap is always enabled\n                    pp = feature[5];\n                    o = feature[8];\n\n                    if (job.type == VTS_JOB_LINE_LABEL) {\n                        if (renderer.rmap.addLineLabel(job.lastSubJob, null)) {\n                            //hitCache[hitCacheSize] = feature;\n                        }\n                    } else {\n                        if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, null)) {\n                            //hitCache[hitCacheSize] = feature;\n                        }\n                    }\n\n                } else {\n                    if (job.hysteresis) {\n                        renderer.jobHBuffer[job.id] = job;\n                    } else {\n                        renderer.drawnJobs++;\n\n                        if (job.type == VTS_JOB_LINE_LABEL) {\n                            draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                        } else {\n                            draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                        }\n                    }\n                }\n            }\n\n            hmapSize[i] = 0;  //zero size\n        }\n    }\n}\n\n\nfunction radixSortFeatures(renderer, input, inputSize, tmp, depthOnly) {\n    var count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32; \n    var item, val, bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32, i, r, pp;\n    var distanceFactor = renderer.config.mapFeaturesReduceFactor;\n    //var screenDistanceFactor = renderer.config.mapFeaturesReduceFactor2 * 0.5, e100 = 1.0/Math.exp(100);\n    //var centerOffset = renderer.config.mapFeaturesReduceFactor3;\n\n    var depthTest = true;\n\n    var sx = renderer.curSize[0], sy = renderer.curSize[1];\n    var cx = sx * 0.5, cy = sy * 0.5;\n    var invcx = 1.0 / (cx+0.0001), invcy = 1.0 / (cy+0.0001), dx, dy, yy;\n    var invsy = 1.0 / (sy+0.0001);\n\n    if (count.fill) {\n        count.fill(0);\n    } else { //IE fallback\n        for (i = 0; i < (256*4); i++) {\n            count[i] = 0;\n        }\n    }\n\n    // count all bytes in one pass\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        r = item[0].reduce;\n\n        // optical center\n        //pp = item[5]; \n        //yy = Math.pow(pp[1] * invsy, centerOffset) * sy;\n        //dx = (cx - pp[0]) * invcx;\n        //dy = (cy - yy) * invcx;\n\n        val = r[3] - distanceFactor * Math.log(r[4]); // - screenDistanceFactor * Math.log(dx*dx + dy*dy + e100);\n        r[6] = val;\n        val += 10000;\n        if (val < 0) val = 0;\n        bfloat32[0] = val;\n        val = bunit32[0];\n        r[5] = val;\n        count[val & 0xFF]++;\n        count[((val >> 8) & 0xFF) + 256]++;\n        count[((val >> 16) & 0xFF) + 512]++;\n        count[((val >> 24) & 0xFF) + 768]++;\n    }\n\n    // create summed array\n    for (var j = 0; j < 4; j++) {\n        var t = 0, sum = 0, offset = j * 256;\n\n        for (i = 0; i < 256; i++) {\n            t = count[i + offset];\n            count[i + offset] = sum;\n            sum += t;\n        }\n    }\n\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        val = item[0].reduce[5];\n        tmp[count[val & 0xFF]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = tmp[i];\n        val = item[0].reduce[5];\n        input[count[((val >> 8) & 0xFF) + 256]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        val = item[0].reduce[5];\n        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = tmp[i];\n        val = item[0].reduce[5];\n        input[count[((val >> 24) & 0xFF) + 768]++] = item;\n    }\n\n    if (i == -123) { //debug\n        for (i = 0; i < inputSize; i++) {\n            val = input[i][0].reduce[5];\n            console.log('' + val +  ' ' + input[i][0].id);\n        }\n    }\n\n    return input;\n}\n\n//used for scr-count7\nfunction processGMap6(gpu, gl, renderer, screenPixelSize, draw) {\n    if (!renderer.config.mapFeaturesReduceParams) {\n        return;\n    }\n\n    var featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[1]; //0.6614; //labelsPerSquareInch\n    var ppi = 96 * (window.devicePixelRatio || 1);\n    var screenLX = renderer.curSize[0];\n    var screenLY = renderer.curSize[1];\n    var maxFeatures = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch); \n    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp, job;\n    var feature, feature2, pp, pp2, o, featureCount = 0;\n    var drawAllLabels = renderer.drawAllLabels;\n\n    var depthTest = (renderer.config.mapFeaturesReduceFactor2 != 0);\n    var depthOffset = -renderer.config.mapFeaturesReduceFactor3;\n    var depthParams = null;\n\n    renderer.debugStr = '<br>featuresPerScr: ' + maxFeatures;\n\n    //get top features\n    var featureCache = renderer.gmap;\n    var featureCacheSize = renderer.gmapIndex;\n    var featureCache2 = renderer.gmap2;\n\n    if (drawAllLabels) {\n        maxFeatures = featureCacheSize;\n    }\n\n    //filter features and sort them by importance\n    radixSortFeatures(renderer, featureCache, featureCacheSize, featureCache2);\n\n    for (i = featureCacheSize - 1; i >= 0; i--) {\n        feature = featureCache[i];\n        job = feature[0];\n\n        // check                \n\n        //render job\n        if (!drawAllLabels && feature[6]) { //no-overlap is always enabled\n            pp = feature[5];\n            o = feature[8];\n            \n            depthParams = depthTest ? [pp[0],pp[1]+feature[1],job.reduce,depthOffset] : null;\n\n            if (job.type == VTS_JOB_LINE_LABEL) {\n                if (renderer.rmap.addLineLabel(job.lastSubJob, depthParams)) {\n                    featureCount++;\n                }\n            } else {\n                if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, depthParams)) {\n                    featureCount++;\n                }\n            }\n\n            if (featureCount >= maxFeatures) {\n                return;\n            }\n\n        } else {\n            if (job.hysteresis) {\n                renderer.jobHBuffer[job.id] = job;\n            } else {\n                renderer.drawnJobs++;\n\n                if (job.type == VTS_JOB_LINE_LABEL) {\n                    draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                } else {\n                    draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                }\n            }\n        }\n    }\n\n}\n\n\nfunction radixDepthSortFeatures(renderer, input, inputSize, tmp) {\n    var count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32; \n    var item, val, bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32, i, r, pp;\n    var distanceFactor = renderer.config.mapFeaturesReduceFactor;\n    //var screenDistanceFactor = renderer.config.mapFeaturesReduceFactor2 * 0.5, e100 = 1.0/Math.exp(100);\n    //var centerOffset = renderer.config.mapFeaturesReduceFactor3;\n\n    var depthTest = true;\n\n    if (count.fill) {\n        count.fill(0);\n    } else { //IE fallback\n        for (i = 0; i < (256*4); i++) {\n            count[i] = 0;\n        }\n    }\n\n    // count all bytes in one pass\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        val = 1 - item.lastSubJob[5][2];\n        bfloat32[0] = val;\n        val = bunit32[0];\n        item.depth = val;\n        count[val & 0xFF]++;\n        count[((val >> 8) & 0xFF) + 256]++;\n        count[((val >> 16) & 0xFF) + 512]++;\n        count[((val >> 24) & 0xFF) + 768]++;\n    }\n\n    // create summed array\n    for (var j = 0; j < 4; j++) {\n        var t = 0, sum = 0, offset = j * 256;\n\n        for (i = 0; i < 256; i++) {\n            t = count[i + offset];\n            count[i + offset] = sum;\n            sum += t;\n        }\n    }\n\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        val = item.depth;\n        tmp[count[val & 0xFF]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = tmp[i];\n        val = item.depth;\n        input[count[((val >> 8) & 0xFF) + 256]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        val = item.depth;\n        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = tmp[i];\n        val = item.depth;\n        input[count[((val >> 24) & 0xFF) + 768]++] = item;\n    }\n\n    /*if (i == -123) { //debug\n        for (i = 0; i < inputSize; i++) {\n            item = input[i];\n            val = item.depth;\n            console.log('' + val +  ' ' + item.lastSubJob[0].id);\n        }\n    }*/\n\n    return input;\n}\n\n\nfunction fillVMapHoles(vmap, mx, my) {\n    var holesCount = 0, v;\n    var x0, y0, x1, y1, x2, y2;\n    var maxX = mx - 1;\n    var maxY = my - 1;\n\n    for (var j = 0, lj = my; j < lj; j++) {\n        for (var i = 0, li = mx; i < li; i++) {\n\n            v = vmap[j*mx+i];\n\n            if (v === null) {\n\n                //find \n                x0 = i - 1;\n                y0 = j - 1;\n\n                x1 = i;\n                y1 = j;\n\n                x2 = i + 1;\n                y2 = j + 1;\n\n                if (x0 < 0) x0 = 0;\n                if (y0 < 0) y0 = 0;\n\n                if (x2 > maxX) x2 = maxX;\n                if (y2 > maxY) y2 = maxY;\n\n                var vv = [vmap[y0*mx+x0],\n                          vmap[y0*mx+x1],\n                          vmap[y0*mx+x2],\n                          vmap[y1*mx+x0],\n                          vmap[y1*mx+x2],\n                          vmap[y2*mx+x0],\n                          vmap[y2*mx+x1],\n                          vmap[y2*mx+x2]];\n\n                var vcount = 0;\n                var vsum = 0;\n\n                for (var k= 0; k < 8; k++) {\n                    if (vv[k] !== null) {\n                        vcount++;\n                        vsum += vv[k];\n                    }\n                }\n\n                if (vcount != 0) {\n                    vmap[j*mx+i] = vsum / vcount;\n                } else {\n                    holesCount++;\n                }\n            }\n        }\n    }\n\n    if (holesCount != 0 && holesCount != (mx * my)) {\n        fillVMapHoles(vmap, mx, my);\n    }\n}\n\n\nfunction getVMapValue(vmap, x, y, mx, my) {\n    x -= 0.5;\n    y -= 0.5;\n\n    var maxX = mx - 1;\n    var maxY = my - 1;\n\n    if (x < 0) { x = 0; }\n    if (y < 0) { y = 0; }\n    if (x > maxX) { x = maxX; }\n    if (y > maxY) { y = maxY; }\n\n    var ix = Math.floor(x);\n    var iy = Math.floor(y);\n    var fx = x - ix;\n    var fy = y - iy;\n\n    var index = iy * mx;\n    var index2 = (iy == maxY) ? index : index + mx;\n    var ix2 = (ix == maxX) ? ix : ix + 1; \n    var v00 = vmap[index + ix];\n    var v01 = vmap[index + ix2];\n    var v10 = vmap[index2 + ix];\n    var v11 = vmap[index2 + ix2];\n    var w0 = (v00 + (v01 - v00)*fx);\n    var w1 = (v10 + (v11 - v10)*fx);\n   \n    return (w0 + (w1 - w0)*fy);\n}\n\n\nfunction radixDeltaSortFeatures(renderer, input, inputSize, tmp) {\n    var count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32; \n    var item, val, bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32, i, r, pp;\n\n    if (count.fill) {\n        count.fill(0);\n    } else { //IE fallback\n        for (i = 0; i < (256*4); i++) {\n            count[i] = 0;\n        }\n    }\n\n    // count all bytes in one pass\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        //val = 1 - item.lastSubJob[5][2];\n        bfloat32[0] = item[0].delta;\n        val = bunit32[0];\n        item[0].delta = val;\n        count[val & 0xFF]++;\n        count[((val >> 8) & 0xFF) + 256]++;\n        count[((val >> 16) & 0xFF) + 512]++;\n        count[((val >> 24) & 0xFF) + 768]++;\n    }\n\n    // create summed array\n    for (var j = 0; j < 4; j++) {\n        var t = 0, sum = 0, offset = j * 256;\n\n        for (i = 0; i < 256; i++) {\n            t = count[i + offset];\n            count[i + offset] = sum;\n            sum += t;\n        }\n    }\n\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        val = item[0].delta;\n        tmp[count[val & 0xFF]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = tmp[i];\n        val = item[0].delta;\n        input[count[((val >> 8) & 0xFF) + 256]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = input[i];\n        val = item[0].delta;\n        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;\n    }\n    for (i = 0; i < inputSize; i++) {\n        item = tmp[i];\n        val = item[0].delta;\n        input[count[((val >> 24) & 0xFF) + 768]++] = item;\n    }\n\n    /*if (i == -123) { //debug\n        for (i = 0; i < inputSize; i++) {\n            item = input[i];\n            val = item.depth;\n            console.log('' + val +  ' ' + item.lastSubJob[0].id);\n        }\n    }*/\n\n    return input;\n}\n\n\n//used for scr-count8\nfunction processGMap7(gpu, gl, renderer, screenPixelSize, draw) {\n    if (!renderer.config.mapFeaturesReduceParams) {\n        return;\n    }\n\n    var tileCount = renderer.config.mapFeaturesReduceParams[5];\n    var featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[1];\n    var ppi = 96 * (window.devicePixelRatio || 1);\n    var screenLX = renderer.curSize[0];\n    var screenLY = renderer.curSize[1];\n    var maxFeatures = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch); \n    var featuresPerTile = maxFeatures / (tileCount * tileCount); \n    var featuresPerTileInt = Math.floor(featuresPerTile); \n    var featuresPerTileFract = featuresPerTile - featuresPerTileInt; \n    var tileSizeX = screenLX / tileCount;\n    var tileSizeY = screenLY / tileCount;\n\n    renderer.debugStr = '<br>featuresPerScr: ' + maxFeatures + '<br>featuresPerTile: ' + featuresPerTile.toFixed(2);\n\n    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp, job, featureCount = 0;\n    //var feature, feature2, pp, pp2, o, featureCount = 0;\n    //var drawAllLabels = renderer.drawAllLabels;\n\n    var depthTest = (renderer.config.mapFeaturesReduceFactor2 != 0);\n    var depthOffset = -renderer.config.mapFeaturesReduceFactor3;\n    var depthParams = null;\n\n    //get top features\n    var featureCache = renderer.gmap;\n    var featureCacheSize = renderer.gmapIndex;\n    var featureCache2 = renderer.gmap2;\n    var featureCacheSize2 = 0;\n    var vmap = renderer.gmap4;\n    var drawAllLabels = renderer.drawAllLabels;\n\n    if (drawAllLabels) {\n        maxFeatures = featureCacheSize;\n    }\n\n    if (featureCacheSize > 0) {\n\n        //filter features and sort them by importance\n        radixSortFeatures(renderer, featureCache, featureCacheSize, featureCache2);\n\n        if (drawAllLabels) {\n\n            for (i = featureCacheSize - 1; i >= 0; i--) {\n                feature = featureCache[i];\n                job = feature[0];\n\n                if (feature[0].hysteresis) {\n                    renderer.jobHBuffer[feature[0].id] = job;\n                } else {\n                    renderer.drawnJobs++;\n                    job = feature[0];\n                    if (job.type == VTS_JOB_LINE_LABEL) {\n                        draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                    } else {\n                        draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                    }\n                }\n            }\n\n        } else {\n\n            //distribute top features\n            var hitMap = renderer.gmapHit, usedFeatures = 0;\n            var tileFeatures, count, feature;\n\n            var ix,iy,is,pp,tx,ty,mx,my,v,v2,index,o,j;\n\n            ix = screenLX / tileSizeX;\n            iy = screenLY / tileSizeY;\n            mx = Math.round(ix);\n            my = Math.round(iy);\n            //ix = ix - mx;\n            //iy = iy - my;\n\n            var hitMap = renderer.gmapStore;\n            var hitMapCount = renderer.gmapHit;\n\n            //clear hit-map\n            for (i = 0, li = mx * my; i < li; i++) {\n                hitMap[i] = null;\n                vmap[i] = null;\n            }\n\n            for (i = featureCacheSize - 1; i >= 0; i--) {\n\n                feature = featureCache[i];\n                if (!feature) {\n                    continue;\n                }\n\n                pp = feature[5];\n\n                if (pp[0] < 30 || pp[0] >= (screenLX-30) || pp[1] < 30 || pp[1] >= (screenLY-30)) {\n                    featureCache[i] = null;\n                    continue;\n                }\n\n                tx = pp[0] / tileSizeX;\n                ty = pp[1] / tileSizeY;\n\n                index = Math.floor(tx) + Math.floor(ty) * (mx);\n\n                tileFeatures = hitMap[index];\n\n                if (tileFeatures) {\n                    hitMap[index].push(i);\n                } else {\n                    hitMap[index] = [i];\n                    //hitMapCount[index] = v;\n                }\n            }\n\n\n            for (i = 0, li = (mx) * (my); i < li; i++) {\n                tileFeatures = hitMap[i];\n\n                if (tileFeatures && tileFeatures.length) {\n                    count = tileFeatures.length;\n\n                    if (count == 0) {\n                        vmap[i] = null;\n                    } else {\n                        if (count > featuresPerTileInt) {\n                            count = featuresPerTileInt;\n\n                            index = tileFeatures[count];\n                            feature = featureCache[index];\n                            v = feature[0].reduce[6];\n\n                            if (tileFeatures.length > count+1) {\n                                index = tileFeatures[count+1];\n                                feature = featureCache[index];\n                                v2 = feature[0].reduce[6];\n                                v = v + (v2 - v) * featuresPerTileFract;\n                            }\n                        } else {\n                            index = tileFeatures[count - 1];\n                            feature = featureCache[index];\n                            v = feature[0].reduce[6];\n                        }\n\n                        vmap[i] = v;\n                    }\n                }\n            }\n\n            fillVMapHoles(vmap, mx, my);\n\n            for (i = featureCacheSize - 1; i >= 0; i--) {\n                feature = featureCache[i];\n                if (!feature) {\n                    continue;\n                }\n\n                job = feature[0];\n                v = job.reduce[6];\n                pp = feature[5];\n\n                var vmax = getVMapValue(vmap, pp[0] / tileSizeX, pp[1] / tileSizeY, mx, my);\n\n                if (v >= vmax) {\n\n                    //render job\n                    if (/*!drawAllLabels &&*/ feature[6]) { //no-overlap is always enabled\n                        pp = feature[5];\n                        o = feature[8];\n\n                        depthParams = depthTest ? [pp[0],pp[1]+feature[1],job.reduce,depthOffset] : null;\n                        \n                        if (job.type == VTS_JOB_LINE_LABEL) {\n                            if (renderer.rmap.addLineLabel(job.lastSubJob, depthParams)) {\n                                featureCount++;\n                            }\n                        } else {\n                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, depthParams)) {\n                                featureCount++;\n                            }\n                        }\n\n\n                    } else {\n                        if (job.hysteresis) {\n                            renderer.jobHBuffer[job.id] = job;\n                        } else {\n                            renderer.drawnJobs++;\n\n                            if (job.type == VTS_JOB_LINE_LABEL) {\n                                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                            } else {\n                                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                            }\n                        }\n                    }\n                } else {\n                    //store v delta\n                    feature[0].delta = Math.abs(vmax - v);\n                    featureCache2[featureCacheSize2] = feature; \n                    featureCacheSize2++;\n                }\n            }\n\n            if (featureCount < maxFeatures && featureCacheSize2 > 0) {\n                //sort deltas\n                radixDeltaSortFeatures(renderer, featureCache2, featureCacheSize2, featureCache);\n\n                for (i = featureCacheSize2 - 1; i >= 0; i--) {\n                    feature = featureCache2[i];\n                    job = feature[0];\n\n                    //render job\n                    if (/*!drawAllLabels &&*/ feature[6]) { //no-overlap is always enabled\n                        pp = feature[5];\n                        o = feature[8];\n\n                        depthParams = depthTest ? [pp[0],pp[1]+feature[1],job.reduce,depthOffset] : null;\n                        \n                        if (job.type == VTS_JOB_LINE_LABEL) {\n                            if (renderer.rmap.addLineLabel(job.lastSubJob, depthParams)) {\n                                featureCount++;\n                            }\n                        } else {\n                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], job.lastSubJob, true, depthParams)) {\n                                featureCount++;\n                            }\n                        }\n\n                    } else {\n                        if (job.hysteresis) {\n                            renderer.jobHBuffer[job.id] = job;\n                        } else {\n                            renderer.drawnJobs++;\n\n                            if (job.type == VTS_JOB_LINE_LABEL) {\n                                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                            } else {\n                                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, null);\n                            }\n                        }\n                    }\n\n                    if (featureCount >= maxFeatures) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n\n    if (renderer.drawGridCells) {\n        gpu.setState(renderer.lineLabelState);\n\n        var x = 0, y = 0, j, lj;\n\n        for (j = 0, lj = my; j < lj; j++) {\n            for (i = 0, li = mx; i < li; i++) {\n                x = tileSizeX * i;\n                y = tileSizeY * j;\n\n                var v = vmap[j*mx+i];\n\n                draw.drawLineString([[x, y, 0.5], [x+tileSizeX, y, 0.5],\n                                     [x+tileSizeX, y+tileSizeY, 0.5], [x, y+tileSizeY, 0.5]], true, 1, [0,0,255,255], null, true, null, null, null);\n\n                if (v) {\n                    draw.drawText(Math.round(x+5), Math.round(y + 5), 11, '' + v.toFixed(2), [255,255,255,255], 0.5);\n                }\n            }\n        }\n    }\n\n}\n\n\nexport {processGMap, processGMap4, processGMap5, processGMap6, processGMap7, radixDepthSortFeatures};\n\n","\n\nvar GpuBBox = function(gpu, free) {\n    this.gl = gpu.gl;\n\n    var gl = this.gl;\n\n    if (gl == null)\n        return;\n\n    this.free = free;\n    this.vertexPositionBuffer = null;\n\n    //create vertex buffer\n    this.vertexPositionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);\n\n    var vertices;\n\n    if (free) {\n        vertices = [0,0,0, 0,0,1,\n            0,0,1, 0,0,2,\n            0,0,2, 0,0,3,\n            0,0,3, 0,0,0,\n\n            0,0,4, 0,0,5,\n            0,0,5, 0,0,6,\n            0,0,6, 0,0,7,\n            0,0,7, 0,0,4,\n\n            0,0,0, 0,0,4,\n            0,0,1, 0,0,5,\n            0,0,2, 0,0,6,\n            0,0,3, 0,0,7 ];\n    } else {\n        vertices = [0,0,0, 1,0,0,\n            1,0,0, 1,1,0,\n            1,1,0, 0,1,0,\n            0,1,0, 0,0,0,\n\n            0,0,1, 1,0,1,\n            1,0,1, 1,1,1,\n            1,1,1, 0,1,1,\n            0,1,1, 0,0,1,\n\n            0,0,0, 0,0,1,\n            1,0,0, 1,0,1,\n            1,1,0, 1,1,1,\n            0,1,0, 0,1,1 ];\n    }\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    this.vertexPositionBuffer.itemSize = 3;\n    this.vertexPositionBuffer.numItems = vertices.length / 3;\n\n    this.size = 4 + 4 * 8;\n    this.lines = this.vertexPositionBuffer.numItems / 3;\n};\n\n//destructor\nGpuBBox.prototype.kill = function() {\n    this.gl.deleteBuffer(this.vertexPositionBuffer);\n};\n\n// Draws the mesh, given the two vertex shader attributes locations.\nGpuBBox.prototype.draw = function(program, attrPosition) {\n    var gl = this.gl;\n    if (gl == null)\n        return;\n\n    var vertexPositionAttribute = program.getAttribute(attrPosition);\n\n    //bind vetex positions\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);\n    gl.vertexAttribPointer(vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    //draw lines\n    gl.drawArrays(gl.LINES, 0, this.vertexPositionBuffer.numItems);\n\n};\n\n\nexport default GpuBBox;\n\n","\n\nvar GpuDevice = function(renderer, div, size, keepFrameBuffer, antialias, aniso) {\n    this.renderer = renderer;\n    this.div = div;\n    this.canvas =  null;\n    this.curSize = size;\n    this.currentProgram = null;\n    this.maxAttributesCount = 8;\n    this.newAttributes = new Uint8Array(this.maxAttributesCount);\n    this.enabledAttributes = new Uint8Array(this.maxAttributesCount);\n    this.noTextures = false;\n    this.barycentricBuffer = null;\n   \n    //state of device when first initialized\n    this.defaultState = this.createState({blend:false, stencil:false, zequal: false, ztest:false, zwrite: false, culling:false}); \n    this.currentState = this.defaultState;\n    this.currentOffset = 0; //used fot direct offset\n\n    this.keepFrameBuffer = (keepFrameBuffer == null) ? false : keepFrameBuffer;\n    this.antialias = antialias ? true : false;\n    this.anisoLevel = aniso;\n};\n\n\nGpuDevice.prototype.init = function() {\n    var canvas = document.createElement('canvas');\n\n    if (canvas == null) {\n        //canvas not supported\n        return;\n    }\n\n    this.canvas = canvas;\n\n    canvas.width = this.curSize[0];\n    canvas.height = this.curSize[1];\n    canvas.style.display = 'block';\n\n    if (canvas.getContext == null) {\n        //canvas not supported\n        return;\n    }\n\n    canvas.addEventListener(\"webglcontextlost\", this.contextLost.bind(this), false);\n    canvas.addEventListener(\"webglcontextrestored\", this.contextRestored.bind(this), false);\n\n    var gl;\n\n    try {\n        gl = canvas.getContext('webgl', {preserveDrawingBuffer: this.keepFrameBuffer, antialias: this.antialias, stencil: true}) || canvas.getContext('experimental-webgl', {preserveDrawingBuffer: this.keepFrameBuffer});\n    } catch(e) {\n        //webgl not supported\n    }\n\n    if (!gl) {\n        //webgl not supported\n        return;\n    }\n\n    this.gl = gl;\n\n    if (!gl.getExtension('OES_standard_derivatives')) {\n    }\n\n    this.anisoExt = (\n      gl.getExtension('EXT_texture_filter_anisotropic') ||\n      gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||\n      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')\n    );\n\n    if (this.anisoExt) {\n        this.maxAniso = gl.getParameter(this.anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\n        if (this.anisoLevel) {\n            if (this.anisoLevel == -1) {\n                this.anisoLevel = this.maxAniso;\n            } else {\n                this.anisoLevel = Math.min(this.anisoLevel, this.maxAniso);\n            }\n        }\n    } else {\n        this.maxAniso = 0;\n        this.anisoLevel = 0;\n    }\n\n    this.div.appendChild(canvas);\n\n    gl.viewportWidth = canvas.width;\n    gl.viewportHeight = canvas.height;\n\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    //gl.enable(gl.DEPTH_TEST);\n\n    //initial state\n    gl.disable(gl.BLEND);\n\n    gl.disable(gl.STENCIL_TEST);\n    gl.depthMask(false);\n    gl.enable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LESS);\n    gl.disable(gl.CULL_FACE);\n\n    //clear screen\n    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n};\n\n\nGpuDevice.prototype.kill = function() {\n    this.div.removeChild(this.canvas);\n    delete this.canvas;\n    this.canvas = null;\n};\n\n\nGpuDevice.prototype.contextLost = function(event) {\n    event.preventDefault();\n    this.renderer.core.contextLost = true;\n    this.renderer.core.callListener('gpu-context-lost', {});\n};\n\n\nGpuDevice.prototype.contextRestored = function() {\n    this.renderer.core.callListener('gpu-context-restored', {});\n};\n\n\nGpuDevice.prototype.resize = function(size, skipCanvas) {\n    this.curSize = size;\n    var canvas = this.canvas, gl = this.gl;\n\n    if (canvas != null && skipCanvas !== true) {\n        canvas.width = this.curSize[0];\n        canvas.height = this.curSize[1];\n    }\n\n    if (gl != null) {\n        gl.viewportWidth = canvas.width;\n        gl.viewportHeight = canvas.height;\n    }\n};\n\n\nGpuDevice.prototype.setAniso = function(aniso) {\n    if (this.anisoExt) {\n        if (this.anisoLevel) {\n            if (aniso == -1) {\n                this.anisoLevel = this.maxAniso;\n            } else {\n                this.anisoLevel = Math.min(aniso, this.maxAniso);\n            }\n        }\n    }\n};\n\n\nGpuDevice.prototype.getCanvas = function() {\n    return this.canvas;\n};\n\n\nGpuDevice.prototype.setViewport = function() {\n    this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);\n};\n\n\nGpuDevice.prototype.clear = function(clearDepth, clearColor, color) {\n    if (color != null) {\n        this.gl.clearColor(color[0]/255, color[1]/255, color[2]/255, color[3]/255);\n    }\n    \n    this.gl.clear((clearColor ? this.gl.COLOR_BUFFER_BIT : 0) |\n                  (clearDepth ? this.gl.DEPTH_BUFFER_BIT : 0) );\n};\n\n\nGpuDevice.prototype.useProgram = function(program, attributes, nextSampler) {\n    if (this.currentProgram != program) {\n        this.gl.useProgram(program.program);\n        this.currentProgram = program;\n\n        program.setSampler('uSampler', 0);\n        \n        if (nextSampler) {\n            program.setSampler('uSampler2', 1);\n        }\n\n        var newAttributes = this.newAttributes;\n        var enabledAttributes = this.enabledAttributes; \n       \n        //reset new attributes list\n        for (var i = 0, li = newAttributes.length; i < li; i++){\n            newAttributes[i] = 0;\n        }\n        \n        for (i = 0, li = attributes.length; i < li; i++){\n            var index = program.getAttribute(attributes[i]);\n            \n            if (index != -1){\n                newAttributes[index] = 1;\n            }\n        }\n\n        //enable or disable current attributes according to new attributes list\n        for (i = 0, li = newAttributes.length; i < li; i++){\n            if (enabledAttributes[i] != newAttributes[i]) {\n                if (newAttributes[i]) {\n                    this.gl.enableVertexAttribArray(i);\n                    enabledAttributes[i] = 1;\n                } else {\n                    this.gl.disableVertexAttribArray(i);\n                    enabledAttributes[i] = 0;\n                }\n            }\n        }\n    }\n};\n\n\nGpuDevice.prototype.bindTexture = function(texture, id) {\n    if (!texture.loaded) {\n        return;\n    }\n\n    this.gl.activeTexture(id ? this.gl.TEXTURE1 : this.gl.TEXTURE0);\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texture);\n};\n\n\nGpuDevice.prototype.setFramebuffer = function(texture) {\n    if (texture != null) {\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.framebuffer);\n    } else {\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n    }\n};\n\n\nGpuDevice.prototype.createState = function(state) {\n    if (state.blend == null) { state.blend = false; }\n    if (state.stencil == null) { state.stencil = false; }\n    if (state.zwrite == null) { state.zwrite = true; }\n    if (state.ztest == null) { state.ztest = true; }\n    if (state.zequal == null) { state.zequal = false; }\n    if (state.culling == null) { state.culling = true; }\n\n    return state;\n};\n\n\nGpuDevice.prototype.setState = function(state) {\n    if (!state) {\n        return;\n    }\n\n    var gl = this.gl;\n    var currentState = this.currentState;\n\n    if (currentState.blend != state.blend) {\n        if (state.blend) {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        } else {\n            gl.disable(gl.BLEND);\n        }\n    }\n\n    if (currentState.stencil != state.stencil) {\n        if (state.stencil) {\n            gl.enable(gl.STENCIL_TEST);\n        } else {\n            gl.disable(gl.STENCIL_TEST);\n        }\n    }\n\n    if (currentState.zwrite != state.zwrite) {\n        if (state.zwrite) {\n            gl.depthMask(true);\n        } else {\n            gl.depthMask(false);\n        }\n    }\n\n    if (currentState.ztest != state.ztest) {\n        if (state.ztest != 0) {\n            gl.enable(gl.DEPTH_TEST);\n        } else {\n            gl.disable(gl.DEPTH_TEST);\n        }\n    }\n\n    if (currentState.zequal != state.zequal) {\n        if (state.zequal != 0) {\n            gl.depthFunc(gl.LEQUAL);\n        } else {\n            gl.depthFunc(gl.LESS);\n        }\n    }\n\n    if (currentState.culling != state.culling) {\n        if (state.culling) {\n            gl.enable(gl.CULL_FACE);\n        } else {\n            gl.disable(gl.CULL_FACE);\n        }\n    }\n\n    this.currentState = state;\n};\n\n\nexport default GpuDevice;\n\n\n\n\n","\nimport GpuTexture_ from './texture';\nimport {utils as utils_} from '../../utils/utils';\n\n//get rid of compiler mess\nvar GpuTexture = GpuTexture_;\nvar utils = utils_;\n\n\nvar GpuFont = function(gpu, core, font, size, path) {\n    this.bbox = null;\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.core = core;\n\n    this.data = null;\n    this.path = path;\n\n    this.texture = {width:256, height:256}; //hack\n\n    this.textures = [];\n    this.images = [];\n    this.ready = false;    \n    this.version = 1;    \n\n    this.load(path);\n};\n\n\n//destructor\nGpuFont.prototype.kill = function() {\n};\n\n// Returns GPU RAM used, in bytes.\nGpuFont.prototype.getSize = function(){ return this.size; };\n\n\nGpuFont.prototype.load = function(path) {\n    utils.loadBinary(path, this.onLoaded.bind(this), this.onError.bind(this));\n};\n\nGpuFont.prototype.onLoaded = function(data) {\n    this.data = data;\n    this.ready = true;    \n    this.core.markDirty();\n};\n\nGpuFont.prototype.isReady = function() {\n    return this.ready;\n};\n\nGpuFont.prototype.onError = function() {\n\n};\n\nGpuFont.prototype.onFileLoaded = function(index, data) {\n    this.core.markDirty();\n    this.textures[index].createFromData(256, 256, new Uint8Array(data), 'linear');\n};\n\nGpuFont.prototype.onFileLoadError = function() {\n};\n\nGpuFont.prototype.areTexturesReady = function(files) {\n    var ready = true;\n    for (var i = 0, li = files.length; i < li; i++) {\n        var index = files[i];//Math.round( (planes[i] - (planes[i] % 3)) );\n\n        if (!this.textures[index]) {\n            utils.loadBinary(this.path + (index+2), this.onFileLoaded.bind(this, index), this.onFileLoadError.bind(this));\n            this.textures[index] = new GpuTexture(this.gpu, null, this.core);\n            ready = false;\n        } else {\n            ready = (ready && this.textures[index].loaded);\n        }\n    }\n\n    return ready;\n};\n\nGpuFont.prototype.getTexture = function(file) {\n    //if (!this.textures[file]) {\n        //debugger;\n    //}\n\n    return this.textures[file];\n};\n\nexport default GpuFont;\n\n\n","\nimport {vec3 as vec3_, mat4 as mat4_} from '../../utils/matrix';\nimport BBox_ from '../bbox';\nimport {math as math_} from '../../utils/math';\nimport {utils as utils_} from '../../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../../utils/url';\nimport MapResourceNode_ from '../../map/resource-node';\nimport MapGeodataImport3DTiles_ from '../../map/geodata-import/3dtiles';\nimport MapGeodataImport3DTiles2_ from '../../map/geodata-import/3dtiles2';\nimport MapGeodataBuilder_ from '../../map/geodata-builder';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat4 = mat4_;\nvar BBox = BBox_;\nvar math = math_;\nvar utils = utils_;\nvar MapResourceNode = MapResourceNode_;\nvar MapGeodataImport3DTiles = MapGeodataImport3DTiles_;\nvar MapGeodataImport3DTiles2 = MapGeodataImport3DTiles2_;\nvar MapGeodataBuilder = MapGeodataBuilder_;\nvar utilsUrl = utilsUrl_;\n\nvar localTest = false;\n\nvar GpuGroup = function(id, bbox, origin, gpu, renderer) {\n    this.id = id;\n    this.bbox = null;\n    this.origin = origin || [0,0,0];\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.renderer = renderer;\n    this.jobs = [];\n    this.reduced = 0;\n    this.geometries = {};\n    this.subjob = null;\n    this.mv = new Float32Array(16);\n    this.mvp = new Float32Array(16);\n    this.loadMode = 0;\n    //this.geFactor = 1/38;\n    this.geFactor = 1/16;\n    this.geFactor2 = 0.5;\n    this.geNormalized = false;\n    \n    if (bbox != null && bbox[0] != null && bbox[1] != null) {\n        this.bbox = new BBox(bbox[0][0], bbox[0][1], bbox[0][2], bbox[1][0], bbox[1][1], bbox[1][2]);\n    }\n\n    this.binFiles = [];\n\n    this.size = 0;\n    this.polygons = 0;\n};\n\n//destructor\nGpuGroup.prototype.kill = function() {\n    for (var i = 0, li = this.jobs.length; i < li; i++) {\n        var job = this.jobs[i]; \n\n        switch(job.type) {\n        case VTS_JOB_FLAT_LINE:\n        case VTS_JOB_POLYGON:\n            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);\n            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);\n            break;\n\n        case VTS_JOB_FLAT_TLINE:\n        case VTS_JOB_FLAT_RLINE:\n        case VTS_JOB_PIXEL_LINE:\n        case VTS_JOB_PIXEL_TLINE:\n            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);\n            if (job.vertexNormalBuffer) this.gl.deleteBuffer(job.vertexNormalBuffer);\n            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);\n            break;\n\n        case VTS_JOB_LINE_LABEL:\n            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);\n            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);\n            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);\n            break;\n\n        case VTS_JOB_ICON:\n        case VTS_JOB_LABEL:\n            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);\n            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);\n            if (job.vertexOriginBuffer) this.gl.deleteBuffer(job.vertexOriginBuffer);\n            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);\n            break;\n        }\n    }\n\n    //remove geometries\n    for (var key in this.geometries) {\n        var geometries = this.geometries[key];\n        var globalGeometry = this.renderer.geometries[key];\n        this.geometries[key] = null;\n\n        //remove geometry from glbal stack\n        for (i = 0, li = geometries.length; i < li; i++) {\n            if (geometries[i] == globalGeometry) {\n                this.renderer.geometries[key] = null;\n            }\n        }\n    }\n};\n\n\nGpuGroup.prototype.getSize = function() {\n    return this.size;\n};\n\n\nGpuGroup.prototype.getZbufferOffset = function() {\n    return this.size;\n};\n\nGpuGroup.prototype.addGeometry = function(data) {\n    var id = data['id'];\n\n    if (!this.geometries[id]) {\n        this.geometries[id] = [data];\n    } else {\n        this.geometries[id].push(data);\n    }\n\n    this.renderer.geometries[id] = data;\n};\n\nGpuGroup.prototype.convertColor = function(c) {\n    var f = 1.0/255;\n    return [c[0]*f, c[1]*f, c[2]*f, c[3]*f];\n};\n\nGpuGroup.prototype.addLineJob = function(data) {\n    var gl = this.gl;\n\n    var vertices = data.vertexBuffer;\n\n    var job = {};\n\n    if (data.type == VTS_WORKER_TYPE_POLYGON) {\n        job.type = VTS_JOB_POLYGON;\n    } else {\n        job.type = VTS_JOB_FLAT_LINE;\n    }\n\n    job.program = this.renderer.progLine;\n    job.color = this.convertColor(data['color']);\n    job.zIndex = data['z-index'] + 256;\n    job.clickEvent = data['click-event'];\n    job.hoverEvent = data['hover-event'];\n    job.enterEvent = data['enter-event'];\n    job.leaveEvent = data['leave-event'];\n    job.advancedHit = data['advancedHit'];\n    job.hitable = data['hitable'];\n    job.eventInfo = data['eventInfo'];\n    job.style = data['style'] || 0;\n    job.stencil = (data['stencil'] === false) ? false : true;\n    job.culling = data['culling'] || 0;\n    job.state = data['state'];\n    job.center = data['center'];\n    job.lod = data['lod'];\n    job.lineWidth = data['line-width'];\n    job.zbufferOffset = data['zbuffer-offset'];\n    job.reduced = false;\n    job.ready = true;\n    job.bbox = this.bbox;\n\n    if (!job.program.isReady()) {\n        return;\n    }\n\n    if (job.advancedHit) {\n        job.program2 = this.renderer.progELine;\n\n        if (!job.program2.isReady()) {\n            return;\n        }\n    }\n\n    //create vertex buffer\n    job.vertexPositionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n    job.vertexPositionBuffer.itemSize = 3;\n    job.vertexPositionBuffer.numItems = vertices.length / 3;\n\n    if (job.advancedHit) {\n        job.program = this.renderer.progLine;\n\n        var elements = data.elementBuffer;\n\n        job.vertexElementBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);\n        job.vertexElementBuffer.itemSize = 1;\n        job.vertexElementBuffer.numItems = elements.length;\n    }\n\n    this.jobs.push(job);\n\n    this.size += vertices.length * 4;\n    this.polygons += vertices.length / (3 * 3);\n};\n\n\nGpuGroup.prototype.addExtentedLineJob = function(data) {\n    var gl = this.gl;\n\n    var vertices = data.vertexBuffer;\n    var normals = data.normalBuffer;\n\n    var job = {};\n    job.type = data['type'];\n\n    \n    switch(job.type) {\n    case VTS_WORKER_TYPE_FLAT_LINE:  job.type = VTS_JOB_FLAT_TLINE;  break;\n    case VTS_WORKER_TYPE_FLAT_RLINE:  job.type = VTS_JOB_FLAT_RLINE;  break;\n    case VTS_WORKER_TYPE_PIXEL_LINE:  job.type = VTS_JOB_PIXEL_LINE;  break;\n    case VTS_WORKER_TYPE_PIXEL_TLINE: job.type = VTS_JOB_PIXEL_TLINE; break;\n    }\n\n    job.color = this.convertColor(data['color']);\n    job.zIndex = data['z-index'] + 256;\n    job.clickEvent = data['click-event'];\n    job.hoverEvent = data['hover-event'];\n    job.hitable = data['hitable'];\n    job.eventInfo = data['eventInfo'];\n    job.enterEvent = data['enter-event'];\n    job.leaveEvent = data['leave-event'];\n    job.advancedHit = data['advancedHit'];\n    job.widthByRatio = data['width-units'] == 'ratio',\n    job.state = data['state'];\n    job.center = data['center'];\n    job.lod = data['lod'];\n    job.lineWidth = data['line-width'];\n    job.zbufferOffset = data['zbuffer-offset'];\n    job.reduced = false;\n    job.ready = true;\n    job.bbox = this.bbox;\n\n    if (data['texture'] != null) {\n        var texture = data['texture'];\n        var bitmap = texture[0];\n        job.texture = [this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false),\n            texture[1], texture[2], texture[3], texture[4]];\n        var background = this.convertColor(data['background']);\n\n        if (background[3] != 0) {\n            job.background = background;\n        }\n    }\n\n    switch(job.type) {\n    case VTS_JOB_FLAT_TLINE:   job.program = (background[3] != 0) ? this.renderer.progTBLine : this.renderer.progTLine;  break;\n    case VTS_JOB_FLAT_RLINE:   job.program = this.renderer.progRLine;  break;\n    case VTS_JOB_PIXEL_LINE:   job.program = this.renderer.progLine3;  break;\n    case VTS_JOB_PIXEL_TLINE:  job.program = (background[3] != 0) ? this.renderer.progTPBLine : this.renderer.progTPLine; break;\n    }\n\n    if (!job.program.isReady()) {\n        return;\n    }\n\n    if (job.advancedHit) {\n        switch(job.type) {\n        case VTS_JOB_FLAT_TLINE:   job.program2 = this.renderer.progETLine;  break;\n        case VTS_JOB_FLAT_RLINE:   job.program2 = this.renderer.progERLine;  break;\n        case VTS_JOB_PIXEL_LINE:   job.program2 = this.renderer.progELine3;  break;\n        case VTS_JOB_PIXEL_TLINE:  job.program2 = this.renderer.progETPLine; break;\n        }\n\n        if (!job.program2.isReady()) {\n            return;\n        }\n    }\n\n    //create vertex buffer\n    job.vertexPositionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n    job.vertexPositionBuffer.itemSize = 4;\n    job.vertexPositionBuffer.numItems = vertices.length / 4;\n\n    //create normal buffer\n    job.vertexNormalBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\n    job.vertexNormalBuffer.itemSize = 4;\n    job.vertexNormalBuffer.numItems = normals.length / 4;\n\n    if (job.advancedHit) {\n        var elements = data.elementBuffer;\n\n        job.vertexElementBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);\n        job.vertexElementBuffer.itemSize = 1;\n        job.vertexElementBuffer.numItems = elements.length;\n    }\n\n    this.jobs.push(job);\n\n    this.size += vertices.length * 4 + normals.length * 4;\n    this.polygons += vertices.length / (4 * 3);\n};\n\n\nGpuGroup.prototype.processReduce = function(job) {\n    if (job.reduce) {\n        switch(job.reduce[0]) {\n            case 'tilt':       job.reduce[0] = 1; break;\n            case 'tilt-cos':   job.reduce[0] = 2; break;\n            case 'tilt-cos2':  job.reduce[0] = 3; break;\n            case 'scr-count':  job.reduce[0] = 4; break;\n            case 'scr-count2': job.reduce[0] = 5; this.renderer.drawnGeodataTilesUsed = true; break;\n            case 'scr-count3': job.reduce[0] = 6; this.renderer.drawnGeodataTilesUsed = true; break;\n            case 'scr-count4': job.reduce[0] = 7; break;\n            case 'scr-count5': job.reduce[0] = 8; break;\n            case 'scr-count6': job.reduce[0] = 9; break;\n            case 'scr-count7': job.reduce[0] = 10; break;\n            case 'scr-count8': job.reduce[0] = 11; break;\n        }\n\n        job.reduce[5] = 0; //zero debug value\n        job.reduce[6] = 0;\n        job.reduce[7] = 0;\n\n        if (job.reduce[0] >= 7 && job.reduce[0] <= 11) {\n\n            if (job.reduce[0] == 10 || job.reduce[0] == 11) {\n                job.reduce[1] = Math.abs(job.reduce[1]);\n                job.reduce[3] = job.reduce[1] * job.reduce[2];\n                job.reduce[2] = job.reduce[1];\n                job.reduce[4] = 0;\n            } else {\n                job.reduce[2] = Math.abs(job.reduce[1]); //copy prominence for prom / dist support\n\n                if (this.renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists\n                    job.reduce[1] = job.reduce[2];\n                } else {\n                    if (job.reduce[0] == 9) {\n                        job.reduce[1] = job.reduce[2];\n                    } else {\n                        job.reduce[1] = Math.floor((Math.log(job.reduce[2] * 500) / Math.log(1.0017)) + 5000);\n                    }\n                }\n            }\n        }\n    }\n};\n\n\nGpuGroup.prototype.addLineLabelJob = function(data) {\n    var gl = this.gl;\n\n    if (data.singleBuffer) {\n        var singleBuffer = data.singleBuffer;\n        var singleBuffer2 = data.singleBuffer2;\n    } else {\n        var vertices = data.vertexBuffer;\n        var texcoords = data.texcoordsBuffer;\n    }\n\n    var job = {};\n    job.type = VTS_JOB_LINE_LABEL;\n    job.program = this.renderer.progText;\n    job.color = this.convertColor(data['color']);\n    job.color2 = this.convertColor(data['color2']);\n    job.outline = data['outline'];\n    job.zIndex = data['z-index'] + 256;\n    job.visibility = data['visibility'];\n    job.culling = data['culling'];\n    job.clickEvent = data['click-event'];\n    job.hoverEvent = data['hover-event'];\n    job.enterEvent = data['enter-event'];\n    job.leaveEvent = data['leave-event'];\n    job.hitable = data['hitable'];\n    job.eventInfo = data['eventInfo'];\n    job.state = data['state'];\n    job.center = data['center'];\n    job.lod = data['lod'];\n    job.labelPoints = data['labelPoints'];\n    job.labelIndex = data['labelIndex'];\n    job.labelSize = data['labelSize'];\n    job.zbufferOffset = data['zbuffer-offset'];\n    job.hysteresis = data['hysteresis'];\n    job.noOverlap = data['noOverlap'];\n    job.labelPointsBuffer = { id: -1, points: [], points2: [] },\n    job.id = job.hysteresis ? job.hysteresis[2] : null;\n    job.reduced = false;\n    job.ready = true;\n    job.bbox = this.bbox;\n    job.reduce = data['reduce'];\n\n    this.processReduce(job);\n    \n    job.files = data['files'] || [];\n    var fonts = data['fonts'] || ['#default'];\n    job.fonts = fonts;\n\n    for (var i = 0, li = fonts.length; i < li; i++) {\n        fonts[i] = this.renderer.fonts[fonts[i]];\n    }\n\n    job.program = this.renderer.progText2;\n\n    if (!job.program.isReady()) {\n        return;\n    }\n\n    if (singleBuffer) {\n\n        job.singleBuffer = singleBuffer;\n        job.singleBuffer2 = singleBuffer2;\n        job.textVector = data['textVector'];\n\n        //this.size += vertices.length * 4 + texcoords.length * 4;\n        this.polygons += (singleBuffer.length / 12) * 2;\n\n    } else {\n        //create vertex buffer\n        job.vertexPositionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n        job.vertexPositionBuffer.itemSize = 4;\n        job.vertexPositionBuffer.numItems = vertices.length / 4;\n\n        //create normal buffer\n        job.vertexTexcoordBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);\n        job.vertexTexcoordBuffer.itemSize = 4;\n        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;\n\n        this.size += vertices.length * 4 + texcoords.length * 4;\n        this.polygons += vertices.length / (4 * 3);\n    }\n\n    this.jobs.push(job);\n};\n\n\nGpuGroup.prototype.addIconJob = function(data, label, tile) {\n    var gl = this.gl;\n\n    var vertices = data.vertexBuffer;\n    var texcoords = data.texcoordsBuffer;\n    var origins = data.originBuffer;\n    var singleBuffer = data.singleBuffer;\n    var s = data['stick'];\n    var f = 1.0/255;\n\n    var job = { tile: tile };\n    job.type = label ? VTS_JOB_LABEL : VTS_JOB_ICON;\n    job.program = this.renderer.progIcon;\n    job.color = this.convertColor(data['color']);\n    job.zIndex = data['z-index'] + 256;\n    job.visibility = data['visibility'];\n    job.culling = data['culling'];\n    job.clickEvent = data['click-event'];\n    job.hoverEvent = data['hover-event'];\n    job.enterEvent = data['enter-event'];\n    job.leaveEvent = data['leave-event'];\n    job.hitable = data['hitable'];\n    job.eventInfo = data['eventInfo'];\n    job.state = data['state'];\n    job.center = data['center'];\n    job.stick = [s[0], s[1], s[2], s[3]*f, s[4]*f, s[5]*f, s[6]*f, s[7]];\n    job.lod = data['lod'];\n    job.zbufferOffset = data['zbuffer-offset'];\n    job.hysteresis = data['hysteresis'];\n    job.noOverlap = data['noOverlap'];\n    job.id = job.hysteresis ? job.hysteresis[2] : null;\n    job.reduced = false;\n    job.ready = true;\n    job.reduce = data['reduce'];\n\n    this.processReduce(job);\n\n    if (!job.program.isReady()) {\n        return;\n    }\n\n    if (label !== true) {\n        var icon = data['icon'];\n        job.texture = this.renderer.getBitmap(null, icon['filter'] || 'linear', icon['tiled'] || false, icon['hash'], true);\n        job.files = [];\n    } else {\n        job.color2 = this.convertColor(data['color2']);\n        job.outline = data['outline'];\n        job.size = data['size'];\n        job.origin = data['origin'];\n        job.files = data['files'] || [];\n        job.index = data['index'] || 0;\n        var fonts = data['fonts'] || ['#default'];\n        job.fonts = fonts;\n        job.gamma = [job.outline[2] * 1.4142 / job.size, job.outline[3] * 1.4142 / job.size];\n\n        if (job.origin) {\n            job.origin = new Float32Array(job.origin);\n        }\n\n        for (var i = 0, li = fonts.length; i < li; i++) {\n            fonts[i] = this.renderer.fonts[fonts[i]];\n        }\n\n        job.program = this.renderer.progIcon2;\n    }\n\n    if (job.visibility != null && !Array.isArray(job.visibility)) {\n        job.visibility = [job.visibility];\n    }\n\n    if (singleBuffer) {\n        job.singleBuffer = singleBuffer;\n        this.polygons += 2;\n\n    } else {\n        //create vertex buffer\n        job.vertexPositionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n        job.vertexPositionBuffer.itemSize = 4;\n        job.vertexPositionBuffer.numItems = vertices.length / 4;\n\n        //create normal buffer\n        job.vertexTexcoordBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);\n        job.vertexTexcoordBuffer.itemSize = 4;\n        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;\n\n        //create origin buffer\n        job.vertexOriginBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, origins, gl.STATIC_DRAW);\n        job.vertexOriginBuffer.itemSize = 3;\n        job.vertexOriginBuffer.numItems = origins.length / 3;\n\n        this.size += job.vertexPositionBuffer.numItems * 4 +\n                      job.vertexOriginBuffer.numItems * 4 +\n                      job.vertexTexcoordBuffer.numItems * 4;\n        this.polygons += job.vertexPositionBuffer.numItems / (4 * 3);\n    }\n\n\n    if (this.subjobs) {\n        this.subjobs.push(job);\n    } else {\n        if (this.vsjobs) {\n            this.vsjobs.push(job);\n        } else {\n            this.jobs.push(job);\n        }\n    }\n\n};\n\n\nGpuGroup.prototype.addPack = function(data) {\n    if (!this.subjobs.length) {\n        this.subjobs = null;\n        return;\n    }\n\n    var job = {\n        type : VTS_JOB_PACK,\n        subjobs: this.subjobs,\n        culling : 180,\n        zIndex : 0,\n        ready : true\n    };\n\n    //extract no overlap, remove it form subjobs\n    for (var i = 0, li = job.subjobs.length; i < li; i++) {\n        var subjob = job.subjobs[i];\n\n        if (subjob.noOverlap) {\n            \n            if (!job.noOverlap) {\n                job.noOverlap = subjob.noOverlap;\n            } else {\n                var o = job.noOverlap;\n                var o2 = subjob.noOverlap;\n\n                if (o2[0] < o[0]) o[0] = o2[0];\n                if (o2[1] < o[1]) o[1] = o2[1];\n                if (o2[2] > o[2]) o[2] = o2[2];\n                if (o2[3] > o[3]) o[3] = o2[3];\n            }\n\n            subjob.noOverlap = null;\n        }\n\n        if (subjob.culling <= job.culling) {\n            job.culling = subjob.culling;\n            subjob.culling = 180;\n        }\n\n        if (subjob.visibility) {\n            job.visibility = subjob.visibility;\n            subjob.visibility = null;\n        }\n\n        if (subjob.stick) {\n            job.stick = subjob.stick;\n            subjob.stick = [0,0,0,255,255,255,255,0];\n        }\n\n        if (subjob.zIndex > job.zIndex) {\n            job.zIndex = subjob.zIndex;\n        }\n\n        if (subjob.center) {\n            job.center = subjob.center;\n        }\n\n        job.eventInfo = subjob.eventInfo;\n        job.reduce = subjob.reduce;\n\n        job.hysteresis = subjob.hysteresis;\n        job.id = subjob.id;\n    }\n\n    if (this.vsjobs) {\n        this.vsjobs.push(job);\n    } else {\n        this.jobs.push(job);\n    }\n    \n    this.subjobs = null;\n};\n\n\nGpuGroup.prototype.addVSPoint = function(data, tile){\n    var job = { tile: tile };\n    job.type = VTS_JOB_VSPOINT;\n    job.zIndex = data['z-index'] + 256;\n    job.visibility = data['visibility'];\n    job.culling = data['culling'];\n    job.hitable = false;\n    job.eventInfo = data['eventInfo'];\n    job.state = data['state'];\n    job.center = data['center'];\n    job.lod = data['lod'];\n    job.hysteresis = data['hysteresis'];\n    job.id = job.hysteresis ? job.hysteresis[2] : null;\n    job.reduced = false;\n    job.ready = true;\n    job.reduce = data['reduce'];\n    job.vswitch = [];\n\n    this.vsjob = job;\n};\n\n\nGpuGroup.prototype.storeVSJobs = function(data){\n    this.vsjob.vswitch.push([data.viewExtent, this.vsjobs]);\n    this.vsjobs = [];\n};\n\n\nGpuGroup.prototype.addVSwitch = function(){\n    if (this.vsjob) {\n        this.jobs.push(this.vsjob);\n    }\n\n    this.vsjobs = null;\n};\n\nGpuGroup.prototype.addMeshJob = function(data, lod) {\n    var job = {};\n\n    job.type = VTS_JOB_MESH;\n    job.path = data['path'];\n    \n    job.textures = [];\n\n    job.resources = new MapResourceNode(this.renderer.core.map, null, null);\n\n    if (job.path) {\n        var stmp = job.path.split(\".\");\n        if (stmp.length > 1) {\n            stmp.pop();\n            job.texturePath = stmp.join('.');\n        }\n\n        job.mesh = job.resources.getMesh(job.path, null);\n    }\n\n    this.jobs.push(job);\n};\n\n\nGpuGroup.prototype.copyBuffer = function(buffer, source, index) {\n    var tmp = new Uint8Array(buffer.buffer);\n    tmp.set(new Uint8Array(source.buffer, index, buffer.byteLength));\n    return buffer;\n};\n\n\nGpuGroup.prototype.addRenderJob2 = function(buffer, index, tile, direct) {\n    var data, str, length, tmp, type;\n\n    if (direct) {\n        type = direct.type;\n        data = direct.data;\n    } else {\n        var view = new DataView(buffer.buffer);\n        type = buffer[index]; index += 1;\n\n        if (type != VTS_WORKER_TYPE_PACK_BEGIN && type != VTS_WORKER_TYPE_PACK_END && \n            type != VTS_WORKER_TYPE_VSWITCH_BEGIN && type != VTS_WORKER_TYPE_VSWITCH_END && type != VTS_WORKER_TYPE_VSWITCH_STORE) {\n\n            length = view.getUint32(index); index += 4;\n            str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;\n            data = JSON.parse(str);\n        }\n    }\n\n    switch(type) {\n        case VTS_WORKER_TYPE_POLYGON:\n        case VTS_WORKER_TYPE_FLAT_LINE:\n            data.type = type;\n            length = view.getUint32(index); index += 4;\n            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;\n\n            if (data['advancedHit']) {\n                length = view.getUint32(index); index += 4;\n                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;\n            }\n\n            this.addLineJob(data);\n            break;\n\n        case VTS_WORKER_TYPE_FLAT_TLINE:\n        case VTS_WORKER_TYPE_FLAT_RLINE:\n        case VTS_WORKER_TYPE_PIXEL_LINE:\n        case VTS_WORKER_TYPE_PIXEL_TLINE:\n            data.type = type;\n            length = view.getUint32(index); index += 4;\n            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.normalBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.normalBuffer.byteLength;\n\n            if (data['advancedHit']) {\n                length = view.getUint32(index); index += 4;\n                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;\n            }\n\n            this.addExtentedLineJob(data);\n            break;\n\n        case VTS_WORKER_TYPE_LINE_LABEL:\n\n            length = view.getUint32(index); index += 4;\n            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;\n            this.addLineLabelJob(data);\n            break;\n\n        case VTS_WORKER_TYPE_LINE_LABEL2:\n\n            length = view.getUint32(index); index += 4;\n            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.singleBuffer2 = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer2.byteLength;\n            this.addLineLabelJob(data);\n            break;\n\n        case VTS_WORKER_TYPE_ICON:\n        case VTS_WORKER_TYPE_LABEL:\n\n            length = view.getUint32(index); index += 4;\n            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;\n            this.addIconJob(data, (type == VTS_WORKER_TYPE_LABEL), tile);\n            break;\n\n        case VTS_WORKER_TYPE_ICON2:\n        case VTS_WORKER_TYPE_LABEL2:\n\n            length = view.getUint32(index); index += 4;\n            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.originBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.originBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;\n            this.addIconJob(data, (type == VTS_WORKER_TYPE_LABEL2), tile);\n            break;\n\n        case VTS_WORKER_TYPE_POINT_GEOMETRY:\n        case VTS_WORKER_TYPE_LINE_GEOMETRY:\n\n            length = view.getUint32(index); index += 4;\n            data.geometryBuffer = this.copyBuffer(new Float64Array(length), buffer, index); index += data.originBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.indicesBuffer = this.copyBuffer(new Uint32Array(length), buffer, index); index += data.indicesBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            this.addGeometry(data);\n            break;\n\n        case VTS_WORKER_TYPE_PACK_BEGIN:\n            this.subjobs = []; index += 4;\n            break;\n\n        case VTS_WORKER_TYPE_PACK_END:\n            this.addPack(); index += 4;\n            break;\n\n        case VTS_WORKER_TYPE_VSPOINT:\n            this.addVSPoint(data, tile);\n            break;\n\n        case VTS_WORKER_TYPE_VSWITCH_BEGIN:\n            this.vsjobs = []; this.vsjob = null; index += 4;\n            break;\n\n        case VTS_WORKER_TYPE_VSWITCH_END:\n            this.addVSwitch(); index += 4;\n            break;\n\n        case VTS_WORKER_TYPE_VSWITCH_STORE:\n            data = { viewExtent: view.getUint32(index) }; index += 4;\n            this.storeVSJobs(data);\n            break;\n\n        case VTS_WORKER_TYPE_NODE_BEGIN:\n\n            var node = data;\n            node.nodes = [];\n            node.jobs = [];\n            node.parent = this.currentNode;\n\n            if (node.volume) {\n                var p = node.volume.points;\n                var points = [\n                    p[0][0],p[0][1],p[0][2],\n                    p[1][0],p[1][1],p[1][2],\n                    p[2][0],p[2][1],p[2][2],\n                    p[3][0],p[3][1],p[3][2],\n                    p[4][0],p[4][1],p[4][2],\n                    p[5][0],p[5][1],p[5][2],\n                    p[6][0],p[6][1],p[6][2],\n                    p[7][0],p[7][1],p[7][2]\n                ];\n\n                node.volume.points2 = points;\n            }\n\n            if (this.rootNode) {\n                this.currentNode.nodes.push(node);\n                this.currentNode = node;\n            } else {\n                this.rootNode = node;\n                this.currentNode = node;\n\n                this.oldJobs = this.jobs;\n            }\n\n            this.jobs = node.jobs;\n\n            break;\n\n        case VTS_WORKER_TYPE_NODE_END:\n\n            if (this.currentNode.parent) {\n                this.currentNode = this.currentNode.parent;\n                this.jobs = this.currentNode.jobs;\n            } else {\n                this.currentNode = this.currentNode.parent;\n                this.jobs = this.oldJobs;\n            }\n\n            break;\n\n        case VTS_WORKER_TYPE_MESH:\n            this.addMeshJob(data, tile);\n            break;\n\n        case VTS_WORKER_TYPE_LOAD_NODE:\n            if(this.currentNode) {\n                this.currentNode.path = data['path'];\n            }\n            break;\n\n    }\n\n    return index;\n};\n\n\nGpuGroup.prototype.addRenderJob = function(data, tile) {\n    switch(data['type']) {\n    case 'polygon':\n    case 'flat-line':     this.addLineJob(data); break;\n    case 'flat-tline':\n    case 'flat-rline':\n    case 'pixel-line':\n    case 'pixel-tline':    this.addExtentedLineJob(data); break;\n    case 'line-label':     this.addLineLabelJob(data); break;\n    case 'icon':           this.addIconJob(data); break;\n    case 'label':          this.addIconJob(data, true, tile); break;\n    case 'point-geometry': this.addGeometry(data); break;\n    case 'line-geometry':  this.addGeometry(data); break;\n    case 'pack-begin':     this.subjobs = []; break;\n    case 'pack-end':       this.addPack(); break;\n    case 'vspoint':        this.addVSPoint(data, tile); break;\n    case 'vswitch-begin':  this.vsjobs = []; this.vsjob = null; break;\n    case 'vswitch-store':  this.storeVSJobs(data); break;\n    case 'vswitch-end':    this.addVSwitch(); break;\n    case 'node-begin':     this.nodeBegin(); break;\n    case 'node-end':       this.nodeEnd(); break;\n    case 'mesh':           this.addMesh(); break;\n    }\n};\n\n\nfunction drawLineString(options, renderer) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (options['points'] == null) {\n        return this;    \n    }\n\n    var points = options['points'];\n    var color = options['color'] || [255,255,255,255];\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n    var size = options['size'] || 2;\n    var screenSpace = (options['screenSpace'] != null) ? options['screenSpace'] : true;\n    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;\n    var blend = (options['blend'] != null) ? options['blend'] : false;\n    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;\n    var useState = (options['useState'] != null) ? options['useState'] : false;\n\n    color = [ color[0] * (1.0/255), color[1] * (1.0/255), color[2] * (1.0/255), color[3] * (1.0/255) ];\n\n    renderer.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, blend, writeDepth, useState);\n    return this;    \n};\n\n\nGpuGroup.prototype.getNodeLOD = function(node) {\n    var lod = 0;\n\n    while(node.parent) {\n        lod++;\n        node = node.parent;\n    }\n\n    return lod;\n};\n\n\nGpuGroup.prototype.getNodeTexelSize = function(node, screenPixelSize) {\n    var pos = node.volume.center;\n    var cameraPos = this.renderer.cameraPosition;\n    var d = vec3.length(\n        [pos[0] - cameraPos[0],\n         pos[1] - cameraPos[1],\n         pos[2] - cameraPos[2]]);\n\n    d -= node.volume.radius;\n\n    if (d <= 0) {\n        return [Number.POSITIVE_INFINITY, 0.1];\n    }\n\n    return [this.renderer.camera.scaleFactor2(d) * screenPixelSize, d];\n};\n\n\nGpuGroup.prototype.drawNodeVolume = function(points, color) {\n    var renderer = this.renderer;\n\n    drawLineString({\n        points : [points[0], points[1], points[2], points[3], points[0],\n                  points[4], points[5], points[6], points[7], points[4]\n        ],\n        size : 1.0,\n        color : color,\n        depthTest : false,\n        //depthTest : true,\n        //depthOffset : [-0.01,0,0],\n        screenSpace : false, //switch to physical space\n        blend : false\n        }, renderer);\n\n    drawLineString({\n        points : [points[1], points[5]],\n        size : 1.0,\n        color : color,\n        depthTest : false,\n        //depthTest : true,\n        //depthOffset : [-0.01,0,0],\n        screenSpace : false, //switch to physical space\n        blend : false\n        }, renderer);\n\n    drawLineString({\n        points : [points[2], points[6]],\n        size : 1.0,\n        color : color,\n        depthTest : false,\n        //depthTest : true,\n        //depthOffset : [-0.01,0,0],\n        screenSpace : false, //switch to physical space\n        blend : false\n        }, renderer);\n\n    drawLineString({\n        points : [points[3], points[7]],\n        size : 1.0,\n        color : color,\n        depthTest : false,\n        //depthTest : true,\n        //depthOffset : [-0.01,0,0],\n        screenSpace : false, //switch to physical space\n        blend : false\n        }, renderer);\n}\n\nGpuGroup.prototype.drawNode = function(node, noSkip, splitMask, splitSpace) {\n    var renderer = this.renderer;\n    var debug = this.map.draw.debug;\n    var jobs = node.jobs;\n\n    renderer.drawnNodes++;\n\n    if (debug.drawNBBoxes) {\n        var points = node.volume.points;\n        var color = [255,0,255,255];\n\n        if (node.tileset) {\n            color = [0,255,0,255];           \n        }\n\n        if (noSkip) {\n            color = [255,255,0,255];\n        }\n                 \n        if (debug.drawSpaceBBox && node.volume2) {\n            this.drawNodeVolume(node.volume2.points, [255,0,0,255]);\n        } else {\n            this.drawNodeVolume(points, color);\n        }\n\n        /*\n        for (var i = 0, li = node.nodes.length; i < li; i++) {\n            var node2 = node.nodes[i];\n\n            if (node2.volume2.octant == 7) {\n                this.drawNodeVolume(node2.volume2.points, [255,0,0,255]);\n            }\n        }*/\n\n        var cameraPos = this.renderer.cameraPosition;\n        var pos = node.volume.center;\n\n        var shift = [cameraPos[0] - pos[0],\n               cameraPos[1] - pos[1],\n               cameraPos[2] - pos[2]];\n\n        vec3.normalize(shift);\n        vec3.scale(shift, node.volume.radius);\n\n        pos = [pos[0]+shift[0]-cameraPos[0],  \n               pos[1]+shift[1]-cameraPos[1],\n               pos[2]+shift[2]-cameraPos[2]];\n\n        /*pos = [pos[0]-cameraPos[0],  \n               pos[1]-cameraPos[1],\n               pos[2]-cameraPos[2]];*/\n\n        pos = this.renderer.core.getRendererInterface().getCanvasCoords(\n            pos,\n            /*[pos[0] - cameraPos[0],\n             pos[1] - cameraPos[1],\n             pos[2] - cameraPos[2]],*/\n             this.renderer.camera.getMvpMatrix());\n\n        var factor = 2, text;\n\n        if (debug.drawLods) {\n            text = '' + node.lod;//this.getNodeLOD(node);\n            renderer.draw.drawText(Math.round(pos[0]-renderer.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-4*factor), 4*factor, text, [1,0,0,1], pos[2]);\n        }\n\n        if (debug.drawOctants) {\n            text = '' + node.index;//this.getNodeLOD(node);\n            renderer.draw.drawText(Math.round(pos[0]-renderer.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [1,1,0,1], pos[2]);\n        }\n        \n        if (debug.drawDistance) {\n            var res = this.getNodeTexelSize(node, node.precision * renderer.curSize[0]);\n            text = '' + res[1].toFixed(2) + ' ' + res[0].toFixed(2) + ' ' + node.precision.toFixed(3);\n            renderer.draw.drawText(Math.round(pos[0]-renderer.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [0.5,0.5,1,1], pos[2]);\n        }\n\n        if (debug.drawFaceCount) {\n            var mesh = (jobs[0] && jobs[0].type == VTS_JOB_MESH) ? jobs[0].mesh : null;\n            if (mesh) {\n                text = '' + mesh.faces + ' - ' + mesh.submeshes.length;\n                renderer.draw.drawText(Math.round(pos[0]-renderer.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n            }\n        }\n\n        if (debug.drawResources && jobs[0]) {\n            text = '' + (this.getGpuSize(jobs[0])/(1024*1024)).toFixed(2) + 'MB';\n            renderer.draw.drawText(Math.round(pos[0]-renderer.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,0,1], pos[2]);\n        }\n\n        if (debug.drawSurfaces && jobs[0]) {\n            var text = '';\n\n            var mesh = (jobs[0] && jobs[0].type == VTS_JOB_MESH) ? jobs[0].mesh : null;\n            if (mesh) {\n                var path = mesh.mapLoaderUrl;\n                path = path.replace('.mesh', '');\n                var parts = path.split('/');\n\n                if (parts.length > 1) {\n                    text = parts[parts.length-2] + '/' + parts[parts.length-1];\n                } else {\n                    text = parts[0];\n                }\n            }\n\n            renderer.draw.drawText(Math.round(pos[0]-renderer.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n        }\n\n        if (debug.drawTextureSize) {\n            var mesh = (jobs[0] && jobs[0].type == VTS_JOB_MESH) ? jobs[0].mesh : null;\n            if (mesh) {\n                var submeshes = mesh.submeshes;\n                for (i = 0, li = submeshes.length; i < li; i++) {\n\n                    if (submeshes[i].internalUVs) {\n                        var texture;\n                        if (jobs[0].direct) {\n                            texture = submeshes[i].texture;\n                        } else {\n                            texture = jobs[0].textures[i];\n                        }\n                        \n                        if (texture) {\n                            var gpuTexture = texture.getGpuTexture();\n                            if (gpuTexture) {\n                                text = '[' + i + ']: ' + gpuTexture.width + ' x ' + gpuTexture.height;\n                                renderer.draw.drawText(Math.round(pos[0]-renderer.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n                            }\n                        }\n                    } else {\n                        text = '[' + i + ']: 256 x 256';\n                        renderer.draw.drawText(Math.round(pos[0]-renderer.draw.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n                    }\n                }\n            }\n        }\n    }\n\n    //debug.drawNBBoxes = true;\n\n    if (!noSkip) {\n        //return true;\n    }\n\n    for (var i = 0, li = jobs.length; i < li; i++) {\n        var job = jobs[i];\n        \n        if (job.type == VTS_JOB_MESH) {\n\n            if (this.isMeshReady(job, null, null, null, true, node)) {\n                this.drawMesh(job, node, splitMask, splitSpace);\n            }\n        }\n    }\n\n};\n\n\nGpuGroup.prototype.isMeshReady = function(job, doNotLoad, priority, skipGpu, skipStats, node) {\n    var mesh = job.mesh;\n    var submeshes = mesh.submeshes;\n    var ready = true;\n    var stats = this.map.stats;\n\n    //console.log('' + stats.gpuNeeded + '  ' + job.texturePath);\n\n    if (mesh.isReady(doNotLoad, priority, skipGpu)) {\n        if (!skipStats) {\n            stats.gpuNeeded += mesh.gpuSize;\n            \n            //if (job.texturePath) {\n                //console.log('--' + node.lod + '--' + job.texturePath + '    ' + stats.gpuNeeded);\n            //}\n        }\n\n        for (var i = 0, li = submeshes.length; i < li; i++) {\n            var submesh = submeshes[i];\n            \n            if (submesh.internalUVs) {\n                \n                var texture;\n\n                if (job.direct) {\n                    if (!submesh.texture) {\n                        var path = mesh.mapLoaderUrl;\n                        path = path.replace('.mesh', '-' + i + '.jpg');\n                        var resource = new MapResourceNode(this.renderer.core.map, null, null);\n                        submesh.texture = resource.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, null /*tile*/, true);\n                    }\n                    \n                    texture = submesh.texture;\n                } else {\n                    if (!job.texturePath) {\n                        continue;\n                    }\n\n                    if (!job.textures[i]) {\n                        var path = job.texturePath + '-' + i + '.jpg';\n                        job.textures[i] = job.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, null /*tile*/, true);\n                    } \n                    \n                    texture = job.textures[i];\n                }\n\n\n                if (!texture.isReady(doNotLoad, priority, skipGpu)) {\n                    ready = false;\n                }\n\n                if (!skipStats) {\n                    stats.gpuNeeded += texture.getGpuSize();\n                }\n            }\n        }\n\n    } else {\n        ready = false;\n    }\n\n    //console.log('' + stats.gpuNeeded + '  finish');\n\n    return ready;\n}\n\n\nGpuGroup.prototype.getGpuSize = function(job) {\n    var mesh = job.mesh;\n\n    if (!mesh) return 0;\n\n    var submeshes = mesh.submeshes;\n    var size = 0;\n    var doNotLoad = true;\n\n    if (mesh.isReady(doNotLoad)) {\n        size += mesh.gpuSize;\n\n        for (var i = 0, li = submeshes.length; i < li; i++) {\n            var submesh = submeshes[i];\n            \n            if (submesh.internalUVs && job.texturePath) {\n                if (job.textures[i]) {\n                    size += job.textures[i].getGpuSize();\n                }\n            }\n        }\n    }\n\n    return size;\n}\n\n\nGpuGroup.prototype.drawMesh = function(job ,node, splitMask, splitSpace) {\n    var mesh = job.mesh;\n    var submeshes = mesh.submeshes;\n    var cameraPos = this.renderer.cameraPosition;\n\n    for (var i = 0, li = submeshes.length; i < li; i++) {\n        var submesh = submeshes[i];\n        \n        if (job.direct) {\n            if (submesh.texture) {\n                mesh.drawSubmesh(cameraPos, i, submesh.texture, VTS_MATERIAL_INTERNAL /*type*/, null /*alpha*/, null /*layer*/, null /*surface*/,  splitMask, splitSpace);\n            }\n        } else {\n            if (job.textures[i]) {\n                mesh.drawSubmesh(cameraPos, i, job.textures[i], VTS_MATERIAL_INTERNAL /*type*/, null /*alpha*/, null /*layer*/, null /*surface*/,  splitMask, splitSpace);\n            }\n        }\n    }\n}\n\n\nGpuGroup.prototype.traverseBinNode = function(cindex, points, center, radius, texelSize, lod, index, file, visible, isready, skipRender) {\n    \n    var renderer = this.renderer;\n    var cameraPos = this.renderer.cameraPosition;\n\n    if (!visible && !renderer.camera.pointsVisible2(points, cameraPos)) {\n        return;        \n    }\n\n    var index2 = index * 9;\n    var tree = file.tree;\n\n    var res = this.getBinNodeTexelSize(center, radius, texelSize * renderer.curSize[0]);\n\n    var pathFlags = tree[index2];\n    var pathIndex = (pathFlags & 0xfffffff);\n    \n    if (pathFlags & (1 << 31)) {  // has json, jump to another tree (bin file) \n        var tab = file.pathTable;\n        \n        if (tab[pathIndex] == 2) { //loaded\n            var fileIndex = tab[pathIndex+1] | tab[pathIndex+2] << 8 | tab[pathIndex+3] << 16; // | | tab[pathIndex+3] << 24;\n            file = this.binFiles[fileIndex];\n            tree = file.tree;\n            index = 0;\n            index2 = 0;\n            pathFlags = tree[index2];\n            pathIndex = (pathFlags & 0xfffffff);\n        } else {\n            return;\n        }\n    }\n        \n    var hasMesh = (pathIndex != 0); \n\n    if (this.loadMode == 1) { // topdown with splitting\n\n        var priority = lod * res[1];\n        \n        var noChildren = (!tree[index2+1] && !tree[index2+2] && !tree[index2+3] && !tree[index2+4] &&\n                          !tree[index2+5] && !tree[index2+6] && !tree[index2+7] && !tree[index2+8]);\n\n        if (noChildren || (res[0] <= this.map.draw.texelSizeFit && (hasMesh || !this.map.config.mapTraverseToMeshNode))) {\n\n            if (!skipRender && (/*node.parent ||*/ this.isBinNodeReady(points, center, index, file, null, priority, null, true))) { \n\n                var node = {\n                    lod : lod,\n                    index: cindex,\n                    precision: texelSize,\n                    volume: {\n                        points: points,\n                        center: center,\n                        radius: radius,\n                    },\n                    jobs: hasMesh ? [\n                        {\n                            type: VTS_JOB_MESH,\n                            mesh: file.meshes[index],\n                            direct: true\n                        }\n                    ] : []\n                };\n\n                this.drawNode(node);\n\n                //var mask = [0,0,0,1,1,1,1,1];\n\n                //this.drawNode(node, null, mask, points);\n                \n            }\n\n        } else {\n\n            //are nodes ready\n            var ready = true;\n            var mask = [0,0,0,0,0,0,0,0];\n            var childPointsCache = [];\n            var childCenterCache = [];\n            var useMask = false;\n            var readyCount = 0;\n            var splitLods = this.map.config.mapSplitLods;\n\n            var childPriority = (lod+1) * res[1];\n\n            var xv = [(points[1][0] - points[0][0])*0.5, (points[1][1] - points[0][1])*0.5, (points[1][2] - points[0][2])*0.5];\n            var yv = [(points[2][0] - points[1][0])*0.5, (points[2][1] - points[1][1])*0.5, (points[2][2] - points[1][2])*0.5];\n            var zv = [(points[0][0] - points[4][0])*0.5, (points[0][1] - points[4][1])*0.5, (points[0][2] - points[4][2])*0.5];\n            var xf, yf, zf;\n            \n            zv[0] = -zv[0];\n            zv[1] = -zv[1];\n            zv[2] = -zv[2];\n\n            for (var i = 0, li = 8; i < li; i++) {\n\n                var childIndex = tree[index2 + 1 + i];\n                \n                if (childIndex) {\n                    var childIndex2 = childIndex * 9;\n\n                    switch(i) {\n                        case 0: xf = -1, yf = -1, zf = -1; break;\n                        case 1: xf = 0, yf = -1, zf = -1; break;\n                        case 2: xf = -1, yf = 0, zf = -1; break;\n                        case 3: xf = 0, yf = 0, zf = -1; break;\n                        case 4: xf = -1, yf = -1, zf = 0; break;\n                        case 5: xf = 0, yf = -1, zf = 0; break;\n                        case 6: xf = -1, yf = 0, zf = 0; break;\n                        case 7: xf = 0, yf = 0, zf = 0; break;\n                    }\n\n                    var p = [center[0] + xv[0] * xf + yv[0] * yf + zv[0] * zf,\n                             center[1] + xv[1] * xf + yv[1] * yf + zv[1] * zf,\n                             center[2] + xv[2] * xf + yv[2] * yf + zv[2] * zf];\n\n                    var childPoints = [\n\n                        [p[0],\n                         p[1],\n                         p[2]],\n\n                        [p[0] + xv[0],\n                         p[1] + xv[1],\n                         p[2] + xv[2]],\n\n                        [p[0] + xv[0] + yv[0],\n                         p[1] + xv[1] + yv[1],\n                         p[2] + xv[2] + yv[2]],\n\n                        [p[0] + yv[0],\n                         p[1] + yv[1],\n                         p[2] + yv[2]],\n\n                        [p[0] + zv[0],\n                         p[1] + zv[1],\n                         p[2] + zv[2]],\n\n                        [p[0] + xv[0] + zv[0],\n                         p[1] + xv[1] + zv[1],\n                         p[2] + xv[2] + zv[2]],\n\n                        [p[0] + xv[0] + yv[0] + zv[0],\n                         p[1] + xv[1] + yv[1] + zv[1],\n                         p[2] + xv[2] + yv[2] + zv[2]],\n\n                        [p[0] + yv[0] + zv[0],\n                         p[1] + yv[1] + zv[1],\n                         p[2] + yv[2] + zv[2]]\n\n                    ];\n\n                    var childCenter = [ (childPoints[0][0]+childPoints[1][0]+childPoints[2][0]+childPoints[3][0]+childPoints[4][0]+childPoints[5][0]+childPoints[6][0]+childPoints[7][0])/8,\n                                   (childPoints[0][1]+childPoints[1][1]+childPoints[2][1]+childPoints[3][1]+childPoints[4][1]+childPoints[5][1]+childPoints[6][1]+childPoints[7][1])/8,\n                                   (childPoints[0][2]+childPoints[1][2]+childPoints[2][2]+childPoints[3][2]+childPoints[4][2]+childPoints[5][2]+childPoints[6][2]+childPoints[7][2])/8 ];\n\n/*\n                    var childCenter = [p[0] + xv[0]*0.5 + yv[0]*0.5 + zv[0]*0.5,\n                                       p[1] + xv[1]*0.5 + yv[1]*0.5 + zv[1]*0.5,\n                                       p[2] + xv[2]*0.5 + yv[2]*0.5 + zv[2]*0.5];\n*/                                       \n                    childPointsCache[i] = childPoints;\n                    childCenterCache[i] = childCenter;\n\n                    if (splitLods) {\n                        var res2 = this.getBinNodeTexelSize(childCenter, radius*0.5, texelSize*0.5 * renderer.curSize[0]);\n                        if (res2[0] <= this.map.draw.texelSizeFit) {\n                            tree[childIndex2] |= (1 << 29);  // set good lod flag true\n                        } else {\n                            tree[childIndex2] &= ~(1 << 29);  // set good lod flag false\n                        }\n                    }\n\n                    if (renderer.camera.pointsVisible2(childPoints, cameraPos)) {\n                        tree[childIndex2] |= (1 << 30);  // set visible flag true\n                    } else {\n                        tree[childIndex2] &= ~(1 << 30);  // set visible flag false\n                        continue;\n                    }\n\n                    if (!this.isBinNodeReady(childPoints, childCenter, childIndex, file, null, childPriority, true, skipRender) || (splitLods && (tree[index2] & (1 << 29) /* good lod flag*/ ))) {\n                        //ready = false;\n                        useMask = true;\n                        mask[i] = 1;\n                    } else {\n                        readyCount++;\n                    }\n                }\n            }\n\n            for (var i = 0, li = 8; i < li; i++) {\n                var childIndex = tree[index2 + 1 + i];\n                \n                if (childIndex) {\n                    var childIndex2 = childIndex * 9;\n\n                    if ((tree[childIndex2] & (1 << 30) /* visibility flag*/ ) && !(splitLods && (tree[childIndex2] & (1 << 29) /* good lod flag*/ ))) {\n                        var skipChildRender = (skipRender || (mask[i] == 1));\n\n                        this.traverseBinNode(i, childPointsCache[i], childCenterCache[i], radius * 0.5, texelSize * 0.5, lod+1, childIndex, file, true, null, skipChildRender);\n                    }\n                }\n            }\n\n            if (useMask) { // some children are not ready, draw parent as fallback\n                if (!skipRender && this.isBinNodeReady(points, center, index, file, null, priority, null, true)) {\n                    \n                    var node = {\n                        lod : lod,\n                        precision: texelSize,\n                        index: cindex,\n                        volume: {\n                            points: points,\n                            center: center,\n                            radius: radius,\n                        },\n                        jobs: hasMesh ? [\n                            {\n                                type: VTS_JOB_MESH,\n                                mesh: file.meshes[index],\n                                direct: true\n                            }\n                        ] : []\n                    };\n                    \n                    if (readyCount > 0) {\n                        this.drawNode(node, null, mask, points);\n                    } else {\n                        this.drawNode(node);\n                    }\n                }\n            }\n\n        }\n    }\n    \n};\n\n\nGpuGroup.prototype.getPath = function(tab, index) {\n    var stmp = '';\n    while(tab[index] != 0) {\n        stmp += String.fromCharCode(tab[index++]);\n        if (stmp.length > 700) {\n            debugger\n        }\n    }\n    \n    return stmp;\n};\n\n\nGpuGroup.prototype.isBinNodeReady = function(points, center, index, file, doNotLoad, priority, skipGpu, skipStats) {\n    var ready = true;\n\n    var tree = file.tree;\n    var index2 = index * 9;\n    var pathFlags = tree[index2];\n    var pathIndex = (pathFlags & 0xfffffff);\n\n    if (pathFlags & (1 << 31)) {  // has json, jump to another tree (bin file) \n        var tab = file.pathTable;\n        \n        if (tab[pathIndex] == 2) { //loaded\n            var fileIndex = tab[pathIndex+1] | tab[pathIndex+2] << 8 | tab[pathIndex+3] << 16;// | tab[pathIndex+4] << 24;\n            file = this.binFiles[fileIndex];\n            tree = file.tree;\n            index = 0;\n            index2 = 0;\n            pathFlags = tree[index2];\n            pathIndex = (pathFlags & 0xfffffff);\n        } else {\n\n            if (tab[pathIndex] == 0) { \n                tab[pathIndex] = 1;\n\n                this.binFiles.push({});\n\n                var path = this.getPath(tab, pathIndex+4);\n                path = utilsUrl.getProcessUrl(path, this.rootPath);\n\n                if (localTest) {\n                    var importer = new MapGeodataImport3DTiles2();\n                    importer.navSrs = this.map.getNavigationSrs();\n                    importer.physSrs = this.map.getPhysicalSrs();\n                    importer.srs = importer.navSrs;\n\n                    importer.loadJSON(path + '.json', {index: this.binFiles.length-1, nodeFile:file.index, nodeOffset:pathIndex, root: false}, this.onBinFileLoaded.bind(this));\n                } else {\n                    this.map.loader.processLoadBinary(path + '.json', this.onBinFileLoaded.bind(this,{index: this.binFiles.length-1, nodeFile:file.index, nodeOffset:pathIndex, root: false }), null, \"text\", 'direct-3dtiles', {root: false});\n                }\n            }\n\n            return false;\n        }\n    }\n\n    var hasMesh = (pathIndex != 0); \n\n    if (hasMesh) {\n        if (!file.meshes[index]) {\n            var path = this.getPath(file.pathTable, pathIndex);\n            path = utilsUrl.getProcessUrl(path, this.rootPath);\n            var resource = new MapResourceNode(this.renderer.core.map, null, null);\n            file.meshes[index] = resource.getMesh(path + '.mesh', null);\n            //file.textures[index] = resource.getTexture(path + '-0.jpg', VTS_TEXTURETYPE_COLOR, null, null, null /*tile*/, true);\n        }\n        \n        var job = {\n            mesh: file.meshes[index],\n            //textures: [file.textures[index]],\n            direct: true\n        };\n        \n        if (!this.isMeshReady(job, doNotLoad, priority, skipGpu, skipStats /*, node*/)) {\n            ready = false;\n        }\n    }\n\n    return ready;\n};\n\n\nGpuGroup.prototype.getBinNodeTexelSize = function(pos, radius, screenPixelSize) {\n    var cameraPos = this.renderer.cameraPosition;\n    var d = vec3.length(\n        [pos[0] - cameraPos[0],\n         pos[1] - cameraPos[1],\n         pos[2] - cameraPos[2]]);\n\n    d -= radius;\n\n    if (d <= 0) {\n        return [Number.POSITIVE_INFINITY, 0.1];\n    }\n\n    return [this.renderer.camera.scaleFactor2(d) * screenPixelSize * 0.5, d];\n};\n\n\nGpuGroup.prototype.onBinFileLoaded = function(info, data) {\n    var binFile = this.binFiles[info.index];\n    binFile.loadState = 2;\n    binFile.tree = data.bintree;\n    binFile.pathTable = data.pathTable;\n    binFile.rootSize = data.rootSize;\n    binFile.meshes = new Array(data.totalNodes);\n    binFile.index = info.index;\n\n    this.map.stats.octoNodes += data.totalNodes;\n    this.map.stats.octoNodesMemSize += binFile.tree.byteLength + binFile.pathTable.byteLength + \n                                       binFile.meshes.length*4 + 8*2 + 16*2 + 24;\n\n    if (info.nodeOffset) {\n        var tab = this.binFiles[info.nodeFile].pathTable;\n        tab[info.nodeOffset] = 2; //load state\n        tab[info.nodeOffset+1] = (info.index & 0xff);\n        tab[info.nodeOffset+2] = (info.index >> 8) & 0xff;\n        tab[info.nodeOffset+3] = (info.index >> 16) & 0xff;\n        //table[info.nodeOffset+3] = (info.index >> 24) & 0xff;\n    }\n\n    if (info.root) {\n        this.rootPoints = data.points;\n        this.rootCenter = data.center;\n        this.rootRadius = data.radius;\n        this.rootTexelSize = data.texelSize;\n    }\n\n    this.renderer.core.map.dirty = true;\n};\n\n\nGpuGroup.prototype.draw = function(mv, mvp, applyOrigin, tiltAngle, texelSize) {\n    if (this.id != null) {\n        if (this.renderer.layerGroupVisible[this.id] === false) {\n            return;\n        }\n    }\n\n    var renderer = this.renderer;\n    var renderCounter = [[renderer.geoRenderCounter, mv, mvp, this]];\n    var map = renderer.core.map;\n    this.map = map;\n    \n    if (this.binPath) {\n        \n        if (this.binFiles.length == 0) {\n            this.binFiles.push(\n                {\n                    loadState : 1\n                } \n            );\n\n            this.rootPath = utilsUrl.makeAbsolute(this.binPath);\n            this.rootPath = utilsUrl.getBase(this.rootPath);\n\n            if (localTest) {\n                var importer = new MapGeodataImport3DTiles2();\n                importer.navSrs = this.map.getNavigationSrs();\n                importer.physSrs = this.map.getPhysicalSrs();\n                importer.srs = importer.navSrs;\n\n                importer.loadJSON(this.binPath, {index: 0, root: true}, this.onBinFileLoaded.bind(this));\n            } else {\n                map.loader.processLoadBinary(this.binPath, this.onBinFileLoaded.bind(this,{index:0, root: true}), null, \"text\", 'direct-3dtiles', {root: true});\n            }\n            \n            return;\n        } else if (this.binFiles[0].loadState == 1) {\n            return;\n        }\n\n        renderer.drawnNodes = 0;\n\n        var mode = this.map.config.mapLoadMode; \n\n        switch(mode) {\n        case 'topdown': this.loadMode = 1; /*((this.map.config.mapSplitMeshes) ? 1 : 0);*/ break;\n        case 'fit':     this.loadMode = 2; break; \n        case 'fitonly': this.loadMode = 3; break;\n        }\n\n        var file = this.binFiles[0];\n\n        this.traverseBinNode(0, this.rootPoints, this.rootCenter, this.rootRadius, this.rootTexelSize, 0, 0, file, null, null, null);\n    }\n\n    if (applyOrigin) {\n        var mvp2 = mat4.create();\n        var mv2 = mat4.create();\n        var pos = this.renderer.position;\n\n        /*\n        var transform = this.renderer.layerGroupTransform[this.id];\n\n        if (transform != null) {\n            origin = transform[1];\n            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];\n            mat4.multiply(math.translationMatrix(origin[0], origin[1], origin[2]), transform[0], mv2);\n            mat4.multiply(mv, mv2, mv2);\n        } else {*/\n            var origin = this.origin;\n            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];\n            mat4.multiply(mv, math.translationMatrix(origin[0], origin[1], origin[2]), mv2);\n        /*}*/\n\n        mat4.multiply(mvp, mv2, mvp2);\n        mv = mv2;\n        mvp = mvp2;\n    }\n\n    var cameraPos = renderer.cameraPosition;\n    var jobZBuffer = renderer.jobZBuffer;\n    var jobZBufferSize = renderer.jobZBufferSize;\n    var jobZBuffer2 = renderer.jobZBuffer2;\n    var jobZBuffer2Size = renderer.jobZBuffer2Size;\n\n    var onlyHitable = renderer.onlyHitLayers;\n\n    for (var i = 0, li = this.jobs.length; i < li; i++) {\n        var job = this.jobs[i];\n\n        if ((job.type == VTS_JOB_ICON || job.type == VTS_JOB_LABEL) && job.visibility > 0) {\n            var center = job.center;\n            if (vec3.length([center[0]-cameraPos[0],\n                center[1]-cameraPos[1],\n                center[2]-cameraPos[2]]) > job.visibility) {\n                continue;\n            }\n        }\n\n        if (onlyHitable && !job.hitable) {\n            continue;\n        }\n\n        job.mv = mv;\n        job.mvp = mvp;\n        job.renderCounter = renderCounter;\n        job.tiltAngle = tiltAngle;\n        job.texelSize = texelSize;\n\n        var zIndex = job.zIndex;\n\n        jobZBuffer[zIndex][jobZBufferSize[zIndex]] = job;\n        jobZBufferSize[zIndex]++;\n    }\n};\n\n\nexport default GpuGroup;\n","\nvar GpuMesh = function(gpu, meshData, fileSize, core, direct, use16bit, verticesUnnormalized) {\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.bbox = meshData.bbox; //< bbox copy from Mesh\n    this.fileSize = fileSize; //used for stats\n    this.core = core;\n    this.vertexBuffer = null;\n    this.uvBuffer = null;\n    this.uv2Buffer = null;\n    this.use16bit = use16bit ? true : false;\n    this.verticesUnnormalized = verticesUnnormalized ? true : false;\n    this.size = 0;\n\n    var vertices = meshData.vertices;\n    var uvs = meshData.uvs;\n    var uvs2 = meshData.uvs2;\n    var indices = meshData.indices;\n    var vertexSize = meshData.vertexSize || 3;\n    var uvSize = meshData.uvSize || 2;\n    var uv2Size = meshData.uv2Size || 2;\n\n    var gl = this.gl;\n\n    if (!vertices || !gl) {\n        return;\n    }\n\n    //create vertex buffer\n    this.vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    //when direct mode is used vertices can be also unit16\n    gl.bufferData(gl.ARRAY_BUFFER, direct ? vertices : (new Float32Array(vertices)), gl.STATIC_DRAW);\n    this.vertexBuffer.itemSize = vertexSize;\n    this.vertexBuffer.numItems = vertices.length / vertexSize;\n\n    if (uvs != null) {\n        //create texture coords buffer\n        this.uvBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n        gl.bufferData(gl.ARRAY_BUFFER, direct ? uvs : (new Float32Array(uvs)), gl.STATIC_DRAW);\n        this.uvBuffer.itemSize = uvSize;\n        this.uvBuffer.numItems = uvs.length / uvSize;\n    }\n\n    if (uvs2 != null) {\n        //create texture coords buffer\n        this.uv2Buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);\n\n        gl.bufferData(gl.ARRAY_BUFFER, direct ? uvs2 : (new Float32Array(uvs2)), gl.STATIC_DRAW);\n        this.uv2Buffer.itemSize = uv2Size;\n        this.uv2Buffer.numItems = uvs2.length / uv2Size;\n    }\n\n    if (indices != null) {\n        //create index buffer\n        this.indexBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, direct ? indices : (new Uint16Array(indices)), gl.STATIC_DRAW);\n        this.indexBuffer.itemSize = 1;\n        this.indexBuffer.numItems = indices.length;\n    }\n\n    var varSize = this.use16bit ? 2 : 4;\n    this.size = this.vertexBuffer.numItems * vertexSize * varSize;\n    this.size += (uvs) ? this.uvBuffer.numItems * uvSize * varSize : 0;\n    this.size += (uvs2) ? this.uv2Buffer.numItems * uv2Size * varSize : 0;\n    this.size += (indices) ? indices.length * 2 : 0;\n    this.polygons = (indices) ? indices.length / 3 : this.vertexBuffer.numItems / 3;\n\n    this.valid = true;\n};\n\n//destructor\nGpuMesh.prototype.kill = function() {\n    if (!this.gl || !this.valid) {\n        return;\n    }\n\n    if (this.vertexBuffer) {\n        this.gl.deleteBuffer(this.vertexBuffer);\n    }\n    \n    if (this.uvBuffer) {\n        this.gl.deleteBuffer(this.uvBuffer);\n    }\n\n    if (this.uv2Buffer) {\n        this.gl.deleteBuffer(this.uv2Buffer);\n    }\n\n    if (this.indexBuffer) {\n        this.gl.deleteBuffer(this.indexBuffer);\n    }\n    \n    this.vertexBuffer = null;\n    this.uvBuffer = null;\n    this.uv2Buffer = null;\n    this.indexBuffer = null;\n};\n\n// Draws the mesh, given the two vertex shader attributes locations.\nGpuMesh.prototype.draw = function(program, attrVertex, attrUV, attrUV2, attrBarycenteric, skipDraw) {\n    var gl = this.gl;\n    if (gl == null || !this.valid) {\n        return;\n    }\n\n    if (this.use16bit) {\n        //bind vetex positions\n        var vertexAttribute = program.getAttribute(attrVertex);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.vertexAttribPointer(vertexAttribute, this.vertexBuffer.itemSize, gl.UNSIGNED_SHORT, !this.verticesUnnormalized, 0, 0);\n\n        //bind texture coords\n        if (this.uvBuffer && attrUV) {\n            var uvAttribute = program.getAttribute(attrUV);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n            gl.vertexAttribPointer(uvAttribute, this.uvBuffer.itemSize, gl.UNSIGNED_SHORT, true, 0, 0);\n        }\n\n        if (this.uv2Buffer && attrUV2) {\n            var uv2Attribute = program.getAttribute(attrUV2);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);\n            gl.vertexAttribPointer(uv2Attribute, this.uv2Buffer.itemSize, gl.UNSIGNED_SHORT, true, 0, 0);\n        }\n    } else {\n        //bind vetex positions\n        var vertexAttribute = program.getAttribute(attrVertex);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.vertexAttribPointer(vertexAttribute, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind texture coords\n        if (this.uvBuffer && attrUV) {\n            var uvAttribute = program.getAttribute(attrUV);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n            gl.vertexAttribPointer(uvAttribute, this.uvBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n\n        if (this.uv2Buffer && attrUV2) {\n            var uv2Attribute = program.getAttribute(attrUV2);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);\n            gl.vertexAttribPointer(uv2Attribute, this.uv2Buffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n    }\n\n    if (attrBarycenteric && attrBarycenteric) {\n        var barycentericAttribute = program.getAttribute(attrBarycenteric);\n        \n        if (barycentericAttribute != -1) {\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.gpu.barycentricBuffer);\n            gl.vertexAttribPointer(barycentericAttribute, this.gpu.barycentricBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n    }\n\n    //draw polygons\n    if (this.indexBuffer) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        if (!skipDraw) gl.drawElements(gl.TRIANGLES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);\n    }  else {\n        if (!skipDraw) gl.drawArrays(gl.TRIANGLES, 0, this.vertexBuffer.numItems);\n    }\n};\n\n\n// Returns GPU RAM used, in bytes.\nGpuMesh.prototype.getSize = function(){ return this.size; };\n\n\nGpuMesh.prototype.getBBox = function(){ return this.bbox; };\n\n\nGpuMesh.prototype.getPolygons = function(){ return this.polygons; };\n\n\nexport default GpuMesh;\n\n","\nvar GpuPixelLine3 = function(gpu, core, lines, maxLines, joins, joinSides) {\n    this.bbox = null;\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.core = core;\n\n    var gl = this.gl;\n\n    if (gl == null){\n        return;\n    }\n\n    this.vertices = [];\n    this.normals = [];\n    this.vertexBuffer = null;\n    this.lines = lines;\n    this.joins = joins;\n    this.joinSides = joinSides;\n    this.maxLines = maxLines;\n\n    this.init();\n};\n\n//destructor\nGpuPixelLine3.prototype.kill = function() {\n    this.gl.deleteBuffer(this.vertexBuffer);\n};\n\n\nGpuPixelLine3.prototype.init = function() {\n    var i;\n    if (this.lines) {\n        if (this.joins) {\n            this.addCircle(0, this.joinSides);\n        }\n\n        for (i = 0; i < this.maxLines; i++) {\n            this.addLine(i, i+1);\n\n            if (this.joins) {\n                this.addCircle(i+1, this.joinSides);\n            }\n        }\n    } else if (this.joins) {\n        for (i = 0; i <= this.maxLines; i++) {\n            this.addCircle(i, this.joinSides);\n        }\n    }\n\n    this.compile();\n};\n\n//add line to vertices buffer\nGpuPixelLine3.prototype.addLine = function(i1, i2) {\n    var index = this.vertices.length;\n\n    //first polygon\n    this.vertices[index] = i1;\n    this.vertices[index+1] = i2;\n    this.vertices[index+2] = 1;\n\n    this.vertices[index+3] = i1;\n    this.vertices[index+4] = i2;\n    this.vertices[index+5] = -1;\n\n    this.vertices[index+6] = i2;\n    this.vertices[index+7] = i1;\n    this.vertices[index+8] = 1;\n\n    //next polygon\n    this.vertices[index+9] = i1;\n    this.vertices[index+10] = i2;\n    this.vertices[index+11] = 1;\n\n    this.vertices[index+12] = i2;\n    this.vertices[index+13] = i1;\n    this.vertices[index+14] = 1;\n\n    this.vertices[index+15] = i2;\n    this.vertices[index+16] = i1;\n    this.vertices[index+17] = -1;\n\n    this.polygons += 2;\n};\n\n//add circle to vertices buffer\nGpuPixelLine3.prototype.addCircle = function(i1, sides) {\n    var index = this.vertices.length;\n    var step = (2.0*Math.PI) / sides;\n\n    for (var i = 0; i < sides; i++) {\n        this.vertices[index] = i1;\n        this.vertices[index+1] = -1;\n        this.vertices[index+2] = 0;\n\n        this.vertices[index+3] = i1;\n        this.vertices[index+4] = -2;\n        this.vertices[index+5] = step * i;\n\n        this.vertices[index+6] = i1;\n        this.vertices[index+7] = -2;\n        this.vertices[index+8] = step * (i+1);\n\n        index += 9;\n    }\n\n    this.polygons += sides;\n};\n\n//compile content of vertices buffer into gpu buffer\nGpuPixelLine3.prototype.compile = function() {\n    var gl = this.gl;\n\n    //create vertex buffer\n    this.vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\n    this.vertexBuffer.itemSize = 3;\n    this.vertexBuffer.numItems = this.vertices.length / 3;\n\n    this.size = this.vertexBuffer.numItems * 3 * 4 * 2;\n    this.polygons = this.vertexBuffer.numItems / 3;\n};\n\n// Draws the mesh, given the two vertex shader attributes locations.\nGpuPixelLine3.prototype.draw = function(program, attrPosition, points) {\n    var gl = this.gl;\n    if (gl == null || this.vertexBuffer == null || points > this.maxLines){\n        return;\n    }\n\n    var vertexPositionAttribute = program.getAttribute(attrPosition);\n\n    //bind vetex positions\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.vertexAttribPointer(vertexPositionAttribute, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    var size = 0;\n\n    if (this.lines) {\n        size += ((points-1) * 3 * 2);\n    }\n\n    if (this.joins) {\n        size += points * (this.joinSides * 3);\n    }\n\n    //draw polygons\n    gl.drawArrays(gl.TRIANGLES, 0, size);\n};\n\n// Returns GPU RAM used, in bytes.\nGpuPixelLine3.prototype.getSize = function(){ return this.size; };\n\n\nGpuPixelLine3.prototype.getBbox = function(){ return this.bbox; };\n\n\nGpuPixelLine3.prototype.getPolygons = function(){ return this.polygons; };\n\n\nexport default GpuPixelLine3;","\nvar GpuProgram = function(gpu, vertex, fragment, variants) {\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.vertex = vertex;\n    this.fragment = fragment;\n    this.program = null;\n    this.uniformLocationCache = [];\n    this.attributeLocationCache = [];\n    this.m = new Float32Array(16);\n    this.ready = false;\n    this.createProgram(vertex, fragment);\n    this.variants = variants || [];\n    this.programs = {};\n};\n\n\nGpuProgram.prototype.createShader = function(source, vertexShader) {\n    var gl = this.gl;\n\n    if (!source || !gl) {\n        return null;\n    }\n\n    var shader;\n\n    if (vertexShader !== true) {\n        shader = gl.createShader(gl.FRAGMENT_SHADER);\n    } else {\n        shader = gl.createShader(gl.VERTEX_SHADER);\n    }\n\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        var info = gl.getShaderInfoLog(shader);\n        console.log('An error occurred compiling the ' + ((vertexShader !== true) ? 'fragment' : 'vertex') + ' shaders: ' + info);\n        this.gpu.renderer.core.callListener('renderer-shader-error', { 'where':'compilation', 'info' : info });\n        return null;\n    }\n\n    return shader;\n};\n\n\nGpuProgram.prototype.createProgram = function(vertex, fragment) {\n    var gl = this.gl;\n    if (gl == null) return;\n\n    var vertexShader = this.createShader(vertex, true);\n    var fragmentShader = this.createShader(fragment, false);\n\n    if (!vertexShader ||  !fragmentShader) {\n        return;\n    }\n\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.log('Unable to initialize the shader program.');\n        this.gpu.renderer.core.callListener('renderer-shader-error', { 'where':'linking' });\n    }\n\n    gl.useProgram(program);\n\n    this.program = program;\n    this.ready = true;\n};\n\n\nGpuProgram.prototype.setSampler = function(name, index) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform1i(key, index);\n    }\n};\n\nGpuProgram.prototype.isReady = function(name, index) {\n    return this.ready;\n};\n\nGpuProgram.prototype.setMat4 = function(name, m, zoffset) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        if (zoffset) {\n            zoffset = ((1+zoffset)*2)-1;\n           \n            var m3 = this.m;\n            \n            m3[0] = m[0];  \n            m3[1] = m[1];  \n            m3[2] = m[2] * zoffset;  \n            m3[3] = m[3];  \n\n            m3[4] = m[4];  \n            m3[5] = m[5];  \n            m3[6] = m[6] * zoffset;  \n            m3[7] = m[7];  \n\n            m3[8] = m[8];\n            m3[9] = m[9];\n            m3[10] = m[10] * zoffset;  \n            m3[11] = m[11];\n\n            m3[12] = m[12];  \n            m3[13] = m[13];  \n            m3[14] = m[14] * zoffset;  \n            m3[15] = m[15];  \n\n            gl.uniformMatrix4fv(key, false, m3);\n            \n        } else {\n            gl.uniformMatrix4fv(key, false, m);\n        }\n    }\n};\n\n\nGpuProgram.prototype.setMat3 = function(name, m) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniformMatrix3fv(key, false, m);\n    }\n};\n\n\nGpuProgram.prototype.setVec2 = function(name, m) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform2fv(key, m);\n    }\n};\n\n\nGpuProgram.prototype.setVec3 = function(name, m) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform3fv(key, m);\n    }\n};\n\n\nGpuProgram.prototype.setVec4 = function(name, m) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform4fv(key, m);\n    }\n};\n\n\nGpuProgram.prototype.setFloat = function(name, value) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform1f(key, value);\n    }\n};\n\n\nGpuProgram.prototype.setFloatArray = function(name, array) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform1fv(key, array);\n    }\n};\n\n\nGpuProgram.prototype.getAttribute = function(name) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var location = this.attributeLocationCache[name];\n\n    if (location == null) {\n        location = gl.getAttribLocation(this.program, name);\n        this.attributeLocationCache[name] = location;\n    }\n\n    return location;\n};\n\n\nGpuProgram.prototype.getUniform = function(name) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var location = this.uniformLocationCache[name];\n\n    if (location == null) {\n        location = gl.getUniformLocation(this.program, name);\n        this.uniformLocationCache[name] = location;\n    }\n    \n    return location;\n};\n\n\nexport default GpuProgram;\n","\nvar GpuShaders = {};\n\nGpuShaders.bboxVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'void main(){ \\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n    '}';\n\n\nGpuShaders.bbox2VertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform float uPoints[8*3];\\n'+\n    'void main(){ \\n'+\n        'int index = int(aPosition.z) * 3; \\n'+\n        'gl_Position = uMVP * vec4(uPoints[index], uPoints[index+1], uPoints[index+2], 1.0);\\n'+\n    '}';\n\n\nGpuShaders.bboxFragmentShader = 'precision mediump float;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\\n'+\n    '}';\n\nGpuShaders.text2VertexShader =\n    'attribute vec4 aPosition;\\n'+\n    'void main(){ \\n'+\n    '}';\n\n\nGpuShaders.lineVertexShader = //line\n    '#ifndef dataPoints2\\n'+\n        'uniform mat4 uMVP;\\n'+\n    '#else\\n'+\n        'uniform mat4 uMV, uProj;\\n'+\n    '#endif\\n'+\n\n    '#ifdef pixelLine\\n'+\n        '#ifdef dataPoints2\\n'+\n            'attribute vec3 aPosition;\\n'+\n        '#else\\n'+\n            'attribute vec4 aPosition;\\n'+\n            'attribute vec4 aNormal;\\n'+\n        '#endif\\n'+\n\n        '#ifdef dataPoints\\n'+\n            'uniform vec3 uScale;\\n'+\n            'uniform vec3 uPoints[32];\\n'+\n        '#else\\n'+\n            'uniform vec2 uScale;\\n'+\n        '#endif\\n'+\n\n        '#ifdef dataPoints2\\n'+\n\n        'vec4 getClippedPixelLinePoint(vec3 p1, vec3 p2, vec3 params) {\\n'+\n            'vec2 pp1, pp2, n;\\n'+\n            'vec4 wp0 = (uMV * vec4(p1.xyz, 1.0)), pp0, pp3;\\n'+\n            'float near = gl_DepthRange.near + 0.1;\\n'+\n            //'float near = gl_DepthRange.near + 0.1 + 30000.0;\\n'+\n            'if (params.y < 0.0) {\\n'+\n                //'return vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                'if (wp0.z > -near) return vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                'pp0 = uProj * wp0;\\n'+\n                'if (params.y == -1.0) return pp0;\\n'+\n                'return pp0 + vec4((vec3(-sin(params.z)*uScale.x*uScale.z*pp0.w, cos(params.z)*uScale.y*uScale.z*pp0.w, 0.0)), 0.0);\\n'+\n            '} else {\\n'+\n                'vec3 p2 = uPoints[int(params.y)];\\n'+\n                'vec4 wp3 = (uMV * vec4(p2.xyz, 1.0));\\n'+\n                'if (wp0.z > -near) {\\n'+\n                    'vec3 dir = (wp3.xyz - wp0.xyz);\\n'+\n                    'float l = length(dir);\\n'+\n                    'dir = normalize(dir);\\n'+\n                    'float denominator = -dir.z;\\n'+\n                    'if (abs(denominator) < 0.0000001) return vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                    'float t = (near + wp0.z) / denominator;\\n'+\n                    'if (t < 0.0 || t > l) return vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                    'wp0.xyz = wp0.xyz + (dir * t);\\n'+\n                '}\\n'+\n                'pp0 = uProj * wp0;\\n'+\n                'pp3 = uProj * wp3;\\n'+\n                'pp1 = pp0.xy / pp0.w;\\n'+\n                'pp2 = pp3.xy / pp3.w;\\n'+\n                //'pp1 = pp0.xy;\\n'+\n                //'pp2 = pp3.xy;\\n'+\n                'n = normalize(pp2 - pp1);\\n'+\n                'return pp0 + vec4((vec3(-n.y*uScale.x*params.z*uScale.z*pp0.w, n.x*uScale.y*params.z*uScale.z*pp0.w, 0.0)), 0.0);\\n'+\n            '}\\n'+\n        '}\\n'+\n\n        '#endif\\n'+\n\n    '#else\\n'+\n\n        '#ifdef lineLabel2\\n'+\n\n            'attribute vec2 aPosition;\\n'+\n            'uniform vec4 uData[DSIZE];\\n'+\n            'uniform float uFile;\\n'+\n            'varying vec2 vTexCoord;\\n'+\n\n        '#else\\n'+\n\n            '#ifdef lineLabel\\n'+\n                'attribute vec4 aPosition;\\n'+\n                'attribute vec4 aTexCoord;\\n'+\n                'uniform vec4 uVec;\\n'+\n                'uniform float uFile;\\n'+\n                'varying vec2 vTexCoord;\\n'+\n            '#else\\n'+\n                'attribute vec3 aPosition;\\n'+\n            '#endif\\n'+\n\n            '#ifdef dynamicWidth\\n'+\n                'attribute vec4 aNormal;\\n'+\n                'uniform vec4 uParams;\\n'+\n            '#endif\\n'+\n\n        '#endif\\n'+\n\n    '#endif\\n'+\n\n    '#ifdef applySE\\n'+\n        'uniform mat4 uParamsSE;\\n'+\n    '#endif\\n'+\n\n    '#ifdef withElements\\n'+\n        'attribute float aElement;\\n'+\n        'varying float vElement;\\n'+\n    '#endif\\n'+\n\n\n    'void main() {\\n'+\n\n        '#ifdef withElements\\n'+\n            'vElement = aElement;\\n'+\n        '#endif\\n'+\n\n        '#ifdef dataPoints\\n'+\n            'vec3 p1 = uPoints[int(aPosition.x)];\\n'+\n        '#else \\n'+\n            '#ifndef lineLabel2\\n'+\n                'vec3 p1 = aPosition.xyz;\\n'+\n            '#endif\\n'+\n        '#endif\\n'+\n\n        '#ifdef pixelLine\\n'+\n            '#ifndef dataPoints\\n'+\n                'vec3 p2 = aNormal.xyz;\\n'+\n            '#endif\\n'+\n        '#endif\\n'+\n\n        '#ifdef applySE\\n'+\n            'vec3 geoPos2 = p1.xyz*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\\n'+\n            'vec3 geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\\n'+\n            'geoPos.z *= uParamsSE[3][3];\\n'+\n            'float ll = length(geoPos);\\n'+\n            'vec3 v = geoPos * (1.0/(ll+0.0001));\\n'+\n            'float h = ll - uParamsSE[3][2];\\n'+\n            'float h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\\n'+\n            'float h3 = h;\\n'+\n            'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\\n'+\n            'geoPos2.xyz += v * (h - h3);\\n'+\n\n            '#ifdef pixelLine\\n'+\n\n                'vec4 pp0 = uMVP * vec4(geoPos2, 1.0);\\n'+\n\n                'if (aNormal.w == 0.0) {\\n'+\n                    'gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\\n'+\n                '} else {\\n'+\n                    'geoPos2 = p2.xyz*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\\n'+\n                    'geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\\n'+\n                    'geoPos.z *= uParamsSE[3][3];\\n'+\n                    'll = length(geoPos);\\n'+\n                    'v = geoPos * (1.0/(ll+0.0001));\\n'+\n                    'h = ll - uParamsSE[3][2];\\n'+\n                    'h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\\n'+\n                    'h3 = h;\\n'+\n                    'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\\n'+\n                    'geoPos2.xyz += v * (h - h3);\\n'+\n\n                    'vec4 pp3 = uMVP * vec4(geoPos2, 1.0);\\n'+\n                    'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n                    'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n                    'vec2 n = normalize(pp2 - pp1);\\n'+\n                    'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\\n'+\n                '}\\n'+\n\n            '#else\\n'+\n\n                '#ifdef lineLabel\\n'+\n\n                    'vTexCoord = aTexCoord.xy;\\n'+\n                    'if (dot(uVec.xyz, vec3(aTexCoord.z, aTexCoord.w, aPosition.w)) < 0.0) {\\n'+\n                        'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                    '}else{\\n'+\n                        'float file = floor(aTexCoord.y/4.0);\\n'+\n                        'vTexCoord.y = mod(aTexCoord.y,4.0);\\n'+\n                        'if (file != floor(uFile)) {\\n'+\n                            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                        '}else{\\n'+\n                            'gl_Position = uMVP * vec4(geoPos2, 1.0);\\n'+\n                        '}\\n'+\n                    '}\\n'+\n\n                '#else\\n'+\n\n                    'gl_Position = uMVP * vec4(geoPos2, 1.0);\\n'+\n\n                '#endif\\n'+\n\n            '#endif\\n'+\n\n        '#else\\n'+\n\n            '#ifdef pixelLine\\n'+\n\n                '#ifdef dataPoints2\\n'+\n\n                    'vec3 p2 = uPoints[int(aPosition.y)];\\n'+\n                    'gl_Position = getClippedPixelLinePoint(p1.xyz, p2.xyz, aPosition.xyz);\\n'+\n\n                '#else\\n'+\n\n                    'vec4 pp0 = (uMVP * vec4(p1.xyz, 1.0));\\n'+\n\n                    '#ifdef dataPoints\\n'+\n\n                        'if (aPosition.y < 0.0) {\\n'+\n                            'if (aPosition.y == -1.0) {\\n'+\n                                'gl_Position = pp0;\\n'+\n                            '} else {\\n'+\n                                'gl_Position = pp0 + vec4((vec3(-sin(aPosition.z)*uScale.x*uScale.z, cos(aPosition.z)*uScale.y*uScale.z, 0.0)), 0.0);\\n'+\n                            '}\\n'+\n                        '} else {\\n'+\n                            'vec3 p2 = uPoints[int(aPosition.y)];\\n'+\n                            'vec4 pp3 = (uMVP * vec4(p2.xyz, 1.0));\\n'+\n                            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n                            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n                            'vec2 n = normalize(pp2 - pp1);\\n'+\n                            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aPosition.z*uScale.z, n.x*uScale.y*aPosition.z*uScale.z, 0.0)), 0.0);\\n'+\n                        '}\\n'+\n\n                    '#else\\n'+\n\n                        'if (aNormal.w == 0.0) {\\n'+\n                            'gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\\n'+\n                        '} else {\\n'+\n                            'vec4 pp3 = (uMVP * vec4(p2.xyz, 1.0));\\n'+\n                            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n                            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n                            'vec2 n = normalize(pp2 - pp1);\\n'+\n                            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\\n'+\n                        '}\\n'+\n\n                    '#endif\\n'+\n\n                '#endif\\n'+\n\n            '#else\\n'+\n\n                '#ifdef lineLabel2\\n'+\n\n                    'int index = int(aPosition.x) * 3;\\n'+\n                    'vec4 data = uData[index];\\n'+\n                    'vec4 data2 = uData[index+1];\\n'+\n                    'vec4 data3 = uData[index+2];\\n'+\n\n                    'vec3 pos = vec3(data[0],data[1],data[2]);\\n'+\n                    'vec4 q = vec4(data[3],data2[0],data2[1],data2[2]);\\n'+\n                    'vec2 factor = vec2(data2[3],data3[0]);\\n'+\n                    'vec2 uv = vec2(data3[1],data3[2]);\\n'+\n                    'float duv = data3[3];\\n'+\n//                    'vec3 up = vec3(1.0,0.0,0.0);\\n'+\n  //                  'vec3 right = vec3(0.0,1.0,0.0);\\n'+\n\n                    //get up, right vectors from quaternion\n                    'float x=q[0], y=q[1], z=q[2], w=q[3];\\n'+\n                    'float x2=x+x, y2=y+y, z2=z+z, xx=x*x2, yx=y*x2, yy=y*y2;\\n'+\n                    'float zx=z*x2, zy=z*y2, zz=z*z2, wx=w*x2, wy=w*y2, wz=w*z2;\\n'+\n\n                    'vec3 right = vec3(1.0-yy-zz, yx-wz, zx+wy) * factor.x;\\n'+\n                    'vec3 up = vec3(yx+wz, 1.0-xx-zz, zy-wx) * (-factor.y);\\n'+\n\n                    /*\n                      out[0] = 1 - yy - zz;\n                      out[3] = yx - wz;\n                      out[6] = zx + wy;\n                      out[1] = yx + wz;\n                      out[4] = 1 - xx - zz;\n                      out[7] = zy - wx;\n                      out[2] = zx - wy;\n                      out[5] = zy + wx;\n                      out[8] = 1 - xx - yy;\n                    */\n\n                    'float file = floor(uv.y/4.0);\\n'+\n                    'uv.y = (uv.y-file*4.0);\\n'+\n\n                    'int corner = int(aPosition.y);\\n'+\n                    'if (corner==1){ pos+=right; uv.x+=floor(duv)*(1.0/1024.0);  }\\n'+\n                    'if (corner==2){ pos+=right; pos+=up; uv.x+=floor(duv)*(1.0/1024.0); uv.y+=fract(duv); }\\n'+\n                    'if (corner==3){ pos+=up; uv.y+=fract(duv); }\\n'+\n\n                    'vTexCoord = uv;\\n'+\n\n                    'if (file != floor(uFile)) {\\n'+\n                        'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                    '}else{\\n'+\n                        'gl_Position = uMVP * vec4(pos.xyz, 1.0);\\n'+\n                    '}\\n'+\n\n                '#else\\n'+\n\n                    '#ifdef lineLabel\\n'+\n\n                        'vTexCoord = aTexCoord.xy;\\n'+\n                        'if (dot(uVec.xyz, vec3(aTexCoord.z, aTexCoord.w, aPosition.w)) < 0.0) {\\n'+\n                            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                        '}else{\\n'+\n                            'float file = floor(aTexCoord.y/4.0);\\n'+\n                            'vTexCoord.y = mod(aTexCoord.y,4.0);\\n'+\n                            'if (file != floor(uFile)) {\\n'+\n                                'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n                            '}else{\\n'+\n                                'gl_Position = uMVP * vec4(aPosition.xyz, 1.0);\\n'+\n                            '}\\n'+\n                        '}\\n'+\n\n                    '#else\\n'+\n\n                        '#ifdef dynamicWidth\\n'+\n                            'gl_Position = uMVP * vec4(aPosition.xyz + aNormal.xyz*(abs(aNormal.w)*uParams[3]), 1.0);\\n'+\n                        '#else\\n'+\n                            'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n                        '#endif\\n'+\n\n                    '#endif\\n'+\n\n                '#endif\\n'+\n\n            '#endif\\n'+\n\n        '#endif\\n'+\n\n    '}';\n\n\nGpuShaders.lineFragmentShader = 'precision mediump float;\\n'+ //line\n\n    'uniform vec4 uColor;\\n'+\n\n    '#ifdef withElements\\n'+\n        'varying float vElement;\\n'+\n    '#endif\\n'+\n\n    'void main() {\\n'+\n\n        '#ifdef withElements\\n'+\n            'gl_FragColor.xyz = fract(vec3(1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vElement) + (-0.5/255.0);\\n'+\n            'gl_FragColor.w = 1.0;\\n'+\n        '#else\\n'+\n            'gl_FragColor = uColor;\\n'+\n        '#endif\\n'+\n\n    '}';\n\nGpuShaders.tlineVertexShader = // textured line\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'vec4 p=vec4(aPosition.xyz, 1.0);\\n'+\n        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\\n'+\n        'if (aNormal.w < 0.0){\\n'+\n            'vTexCoord=vec2(abs(aPosition.w)*uParams[0], (uParams[1]+uParams[2])*0.5);\\n'+\n        '} else {\\n'+\n            'vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\\n'+\n        '}\\n'+\n\n        'gl_Position = uMVP * p;\\n'+\n    '}';\n\n\nGpuShaders.etlineVertexShader = // textured line elements\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'attribute float aElement;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying float vElement;\\n'+\n    'void main(){ \\n'+\n        'vec4 p=vec4(aPosition.xyz, 1.0);\\n'+\n        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\\n'+\n        'vElement = aElement;\\n'+\n        'gl_Position = uMVP * p;\\n'+\n    '}';\n\nGpuShaders.tplineVertexShader = // textured pixel line\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\\n'+\n        'vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\\n'+\n        'if (aNormal.w == 0.0) {\\n'+\n            'gl_Position = pp0 + vec4((vec3(aNormal.x*uParams[3]*uScale.x*pp0.w, aNormal.y*uParams[3]*uScale.y*pp0.w, 0.0)), 0.0);\\n'+\n        '} else {\\n'+\n            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\\n'+\n            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n            'vec2 n = normalize(pp2 - pp1);\\n'+\n            'gl_Position = pp0 + vec4((vec3(-n.y*uParams[3]*uScale.x*aNormal.w*pp0.w, n.x*uParams[3]*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\\n'+\n        '}\\n'+\n    '}';\n\nGpuShaders.etplineVertexShader = // textured pixel line elements\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'attribute float aElement;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying float vElement;\\n'+\n    'void main(){ \\n'+\n        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\\n'+\n        'vElement = aElement;\\n'+\n        'if (aNormal.w == 0.0) {\\n'+\n            'gl_Position = pp0 + vec4((vec3(aNormal.x*uParams[3]*uScale.x*pp0.w, aNormal.y*uParams[3]*uScale.y*pp0.w, 0.0)), 0.0);\\n'+\n        '} else {\\n'+\n            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\\n'+\n            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n            'vec2 n = normalize(pp2 - pp1);\\n'+\n            'gl_Position = pp0 + vec4((vec3(-n.y*uParams[3]*uScale.x*aNormal.w*pp0.w, n.x*uParams[3]*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\\n'+\n        '}\\n'+\n    '}';\n\nGpuShaders.tlineFragmentShader = 'precision mediump float;\\n'+ // textured line\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'uniform vec4 uColor2;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main() {\\n'+\n        'vec4 c=texture2D(uSampler, vTexCoord)*uColor;\\n'+\n        'gl_FragColor = c;\\n'+\n    '}';\n\n\nGpuShaders.tblineFragmentShader = 'precision mediump float;\\n'+  // textured line with background color\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'uniform vec4 uColor2;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main() {\\n'+\n        'vec4 c1=texture2D(uSampler, vTexCoord)*uColor;\\n'+\n        'vec4 c2=uColor2,c=c1;\\n'+\n        'c.xyz*=c.w; c2.xyz*=c2.w;\\n'+\n        'c=mix(c,c2,1.0-c.w);\\n'+\n        'c.xyz/=(c.w+0.00001);\\n'+\n        'c.w=max(c1.w,c2.w);\\n'+\n        'gl_FragColor = c;\\n'+\n    '}';\n\n\nGpuShaders.polygonVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec3 aNormal;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform mat4 uRot;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'varying vec4 vColor;\\n'+\n    'void main(){ \\n'+\n        'float l = dot((uRot*vec4(aNormal,1.0)).xyz, vec3(0.0,0.0,1.0)) * 0.5;\\n'+\n        'vec3 c = uColor.xyz;\\n'+\n        'c = (l > 0.0) ? mix(c,vec3(1.0,1.0,1.0),l) : mix(vec3(0.0,0.0,0.0),c,1.0+l);\\n'+\n        'vColor = vec4(c, uColor.w);\\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n    '}';\n\n\nGpuShaders.polygonFragmentShader = 'precision mediump float;\\n'+\n    'varying vec4 vColor;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = vColor;\\n'+\n    '}';\n\n\nGpuShaders.iconVertexShader =\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aTexCoord;\\n'+\n    'attribute vec3 aOrigin;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec4 uScale;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'vTexCoord = aTexCoord.xy * uScale[2];\\n'+\n        'vec4 pos = (uMVP * vec4(aOrigin, 1.0));\\n'+\n        'gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, (aPosition.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\\n'+\n    '}';\n\nGpuShaders.icon2VertexShader =\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aTexCoord;\\n'+\n    'attribute vec3 aOrigin;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec4 uScale;\\n'+\n    'uniform float uFile;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    //'float round(float x) { return floor(x + 0.5); }\\n'+\n    'void main(){ \\n'+\n        'vTexCoord = aTexCoord.xy * uScale[2];\\n'+\n        'float file = floor(aTexCoord.y/4.0);\\n'+\n        'vTexCoord.y = mod(aTexCoord.y,4.0);\\n'+\n        'if (file != floor(uFile)) {\\n'+\n            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n        '}else{\\n'+\n            'vec4 pos = (uMVP * vec4(aOrigin, 1.0));\\n'+\n            //'pos.x = (floor((pos.x/pos.w)*800.0+0.5)/800.0)*pos.w;\\n'+\n            //'pos.y = (floor((pos.y/pos.w)*410.0+0.5)/410.0)*pos.w;\\n'+\n            'gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, (aPosition.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\\n'+\n        '}'+\n    '}';\n\n\nGpuShaders.icon3VertexShader =\n    'attribute vec2 aPosition;\\n'+\n    'uniform mat4 uProjectionMatrix;\\n'+\n    'uniform vec4 uScale;\\n'+\n    'uniform vec3 uOrigin;\\n'+\n    'uniform vec4 uData[DSIZE];\\n'+\n    'uniform float uFile;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'int index = int(aPosition.x);\\n'+\n        'vec4 data = uData[index];\\n'+\n        'vec4 data2 = uData[index+1];\\n'+\n        'vec4 v;\\n'+\n        'int corner = int(aPosition.y);\\n'+\n        'if (corner==0) v = vec4(data.x, data.y, data2.x, data2.y);\\n'+\n        'if (corner==1) v = vec4(data.z, data.y, data2.z, data2.y);\\n'+\n        'if (corner==2) v = vec4(data.z, data.w, data2.z, data2.w);\\n'+\n        'if (corner==3) v = vec4(data.x, data.w, data2.x, data2.w);\\n'+\n        'vTexCoord = vec2(v.z, v.w);\\n'+\n        'float file = floor(v.w/4.0);\\n'+\n        //'vTexCoord.y = mod(v.w,4.0);\\n'+\n        'vTexCoord.y = (v.w-file*4.0);\\n'+\n\n        'if (file != floor(uFile)) {\\n'+\n            'gl_Position = uProjectionMatrix * vec4(2.0, 0.0, 0.0, 2.0);\\n'+\n        '}else{\\n'+\n            'vec4 pos = (uProjectionMatrix * vec4(uOrigin.xyz, 1.0));\\n'+\n            'gl_Position = pos + vec4(v.x*uScale.x*pos.w, v.y*uScale.y*pos.w, 0.0, 0.0);\\n'+\n        '}'+\n    '}';\n\nGpuShaders.textFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main() {\\n'+\n        'vec4 c=texture2D(uSampler, vTexCoord);\\n'+\n        'if(c.w < 0.01){ discard; }\\n'+\n        'gl_FragColor = c*uColor;\\n'+\n    '}';\n\nGpuShaders.text2FragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'uniform vec2 uParams;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'float round(float x) { return floor(x + 0.5); }\\n'+\n\n    'void main() {\\n'+\n        'vec2 uv=(vTexCoord);\\n'+\n        'uv.y=fract(uv.y);\\n'+\n        'vec4 c=texture2D(uSampler, uv);\\n'+\n\n        'float r = 0.0;\\n'+\n        'int i=int(floor(vTexCoord.y));\\n'+\n\n        'if (i == 0) r=c.x;else\\n'+\n        'if (i == 1) r=c.y;else\\n'+\n        'if (i == 2) r=c.z;else\\n'+\n        'if (i == 3) r=c.w;\\n'+\n\n        'float u_buffer = uParams[0];\\n'+\n        'float u_gamma = uParams[1];\\n'+\n        'float alpha = uColor.a * smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, r);\\n'+\n\n        //'gl_FragColor = vec4(0.0,0.0,1.0,1.0);\\n'+\n\n        'if(alpha < 0.01){ discard; }\\n'+\n        'gl_FragColor = vec4(uColor.rgb, alpha);\\n'+\n    '}';\n\nGpuShaders.skydomeVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n        'vTexCoord = aTexCoord;\\n'+\n    '}';\n\n\nGpuShaders.skydomeFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'const vec4 gray = vec4(0.125, 0.125, 0.125, 1.0);\\n'+\n    'void main() {\\n'+\n        'float fade = smoothstep(0.51, 0.55, vTexCoord.t);\\n'+\n        'gl_FragColor = mix(texture2D(uSampler, vTexCoord), gray, fade);\\n'+\n    '}';\n\n\nGpuShaders.stardomeFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = texture2D(uSampler, vTexCoord);\\n'+\n    '}';\n\n\nGpuShaders.atmoVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform mat3 uNorm;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'varying vec4 vPosition;\\n'+\n    'void main(){ \\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'vec4 c = uMV * vec4(aPosition, 1.0);\\n'+\n        'vNormal = (aPosition.xyz - vec3(0.5));\\n'+\n        'vPosition = camSpacePos;\\n'+\n    '}';\n\n\nGpuShaders.atmoFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uParams;\\n'+       //[radius, atmoSize, 0 ,0]\n    'uniform vec4 uParams2;\\n'+       //[radius, atmoSize, 0 ,0]\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'uniform vec4 uFogColor;\\n'+ //= vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'uniform vec4 uFogColor2;\\n'+ //= vec4(72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'float l = dot(normalize(vNormal),-uParams2.xyz);\\n'+\n        'l = (1.0-pow(abs(l),uParams.x));\\n'+\n        'vec4 c = mix(uFogColor2, uFogColor, l);\\n'+\n        'gl_FragColor = vec4(c.xyz, c.w*l);\\n'+\n    '}';\n\n\nGpuShaders.atmoFragmentShader2 = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform float uNFactor;\\n'+\n    'uniform vec2 uRadius;\\n'+\n    'uniform vec3 uPos;\\n'+\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'uniform vec4 uFogColor;\\n'+ //= vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec3 ldir = normalize(-vPosition.xyz);\\n'+\n        'vec3 diff = uPos;\\n'+\n        'float a = dot(ldir, ldir);\\n'+\n        'float b = 2 * dot(ldir, diff);\\n'+\n        'float c = dot(diff, diff) - (uRadius[0] * uRadius[0]);\\n'+\n        'float i = 0;\\n'+\n        'float discr = b * b - 4 * a * c;\\n'+\n        'if (discr > 0.0) {}\\n'+\n\n        '}\\n'+\n        'gl_FragColor = uFogColor;\\n'+\n    '}';\n\n\nGpuShaders.atmoVertexShader3 =\n    'attribute vec3 aPosition;\\n'+\n    //'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    //\"uniform mat3 uNorm;\\n\"+\n    'uniform vec4 uParams;\\n'+       //[surfaceRadius, surfaceRadius, strech ,safetyfactor]\n    'uniform vec4 uParams2;\\n'+       //[cameraPos, 1]\n\n    'varying vec2 vTexcoords;\\n'+\n\n    'void main(){ \\n'+\n        'gl_Position = uProj * (uMV * vec4(aPosition, 1.0));\\n'+\n\n        'vec3 position = (aPosition.xyz - vec3(0.5)) * vec3(uParams.w * 2.0);\\n'+\n        'vec4 camPos = uParams2;\\n'+\n        'float SurfaceRadius = uParams.x;\\n'+\n        'float AtmosphereRadius = uParams.y;\\n'+\n        'float StretchAmt = uParams.z;\\n'+\n\n        'float camHeight = length(camPos.xyz);\\n'+\n        'vec3 camToPos = position - camPos.xyz;\\n'+\n        'float farDist = length(camToPos);\\n'+\n\n        // get distance to surface horizon\n        'float altitude = max(0.0,camHeight - SurfaceRadius);\\n'+\n        'float horizonDist = sqrt((altitude*altitude) + (2.0 * SurfaceRadius * altitude));\\n'+\n        'float maxDot = horizonDist / camHeight;\\n'+\n\n        // get distance to atmosphere horizon - use max(0,...) because we can go into the atmosphere\n        'altitude = max(0.0,camHeight - AtmosphereRadius);\\n'+\n        'horizonDist = sqrt((altitude*altitude) + (2.0 * AtmosphereRadius * altitude));\\n'+\n\n        // without this, the shift between inside and outside atmosphere is  jarring\n        'float tweakAmount = 0.1;\\n'+\n        'float minDot = max(tweakAmount,horizonDist / camHeight);\\n'+\n\n        // scale minDot from 0 to -1 as we enter the atmosphere\n        'float minDot2 = ((camHeight - SurfaceRadius) * (1.0 / (AtmosphereRadius  - SurfaceRadius))) - (1.0 - tweakAmount);\\n'+\n        'minDot = min(minDot, minDot2);\\n'+\n\n        // get dot product of the vertex we're looking out\n        'float posDot = dot(camToPos / farDist,-camPos.xyz / camHeight) - minDot;\\n'+\n\n        // calculate the height from surface in range 0..1\n        'float height = posDot * (1.0 / (maxDot - minDot));\\n'+\n\n        'vTexcoords.y = height;\\n'+\n\n        'height -= min(0.0,minDot2 + ((1.0 + StretchAmt) * minDot2));\\n'+\n        'vTexcoords.x = height;\\n'+\n    '}';\n\n\nGpuShaders.atmoFragmentShader3 = 'precision mediump float;\\n'+\n    'varying vec2 vTexcoords;\\n'+\n    'uniform vec4 uParams3;\\n'+       //[treshold, mutiplier, 0,0]\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'uniform vec4 uFogColor2;\\n'+ // = vec4(72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0);\\n'+\n    'const vec4 fogColor3 = vec4(0.0/255.0, 0.0/255.0, 0.0/255.0, 1.0);\\n'+\n\n    'void main() {\\n'+\n        'float l = vTexcoords.y;\\n'+\n        'if (l > uParams3.z){ discard; } else {\\n'+\n            'float l2 = clamp((l*l)*0.9+0.1, 0.0, 1.5);\\n'+\n            'vec4 c = mix(uFogColor2, uFogColor, l2);\\n'+\n            'gl_FragColor = vec4(c.xyz, c.w*l);\\n'+\n\n            'if (l > uParams3.x){ gl_FragColor.xyz = mix(gl_FragColor.xyz, fogColor3.xyz, (l-uParams3.x)*uParams3.y); }\\n'+\n        '}'+\n\n    '}';\n\n\n//heightmap tile\nGpuShaders.heightmapVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'uniform mat4 uGridMat;\\n'+\n    'uniform float uGridStep1, uGridStep2;\\n'+\n    'const int HMSize = 5;\\n'+\n    'const float HMSize1 = float(HMSize-1);\\n'+\n    'uniform float uHeight[HMSize*HMSize];\\n'+\n    'varying vec2 vTexCoord1;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+\n    'float round(float x) { return floor(x + 0.5); }\\n'+\n    'void main() {\\n'+\n        'vec3 pos = aPosition;\\n'+\n        'float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\\n'+\n        'vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uFogDensity * camDist);\\n'+\n        'vec4 gridCoord = uGridMat * vec4(pos, 1.0);\\n'+\n        'vTexCoord1 = aTexCoord;\\n'+\n        'vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\\n'+\n        'vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\\n'+\n    '}';\n\n\nGpuShaders.heightmapFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform float uGridBlend;\\n'+\n    'varying vec2 vTexCoord1;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec4 gridColor = mix(texture2D(uSampler, vTexCoord1), texture2D(uSampler, vTexCoord2), uGridBlend);\\n'+\n        'gl_FragColor = mix(uFogColor, gridColor, vFogFactor);\\n'+\n    '}';\n\n\n//depth encoded heightmap tile\nGpuShaders.heightmapDepthVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'uniform mat4 uGridMat;\\n'+\n    'uniform float uGridStep1, uGridStep2;\\n'+\n    'const int HMSize = 5;\\n'+\n    'const float HMSize1 = float(HMSize-1);\\n'+\n    'uniform float uHeight[HMSize*HMSize];\\n'+\n    'varying vec2 vTexCoord1;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vDepth;\\n'+\n    'float round(float x) { return floor(x + 0.5); }\\n'+\n    'void main() {\\n'+\n        'vec3 pos = aPosition;\\n'+\n        'float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\\n'+\n        'vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vDepth = camDist;\\n'+\n        'vec4 gridCoord = uGridMat * vec4(pos, 1.0);\\n'+\n        'vTexCoord1 = aTexCoord;\\n'+\n        'vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\\n'+\n        'vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\\n'+\n    '}';\n\n\nGpuShaders.heightmapDepthFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform float uGridBlend;\\n'+\n    'varying vec2 vTexCoord1;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vDepth;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\\n'+\n    '}';\n\nGpuShaders.quadPoint =\n    'vec3 quadPoint(int i1, int i2, int i3, float t, float t2) {\\n'+\n        'float p1x = uPoints[i1], p1y = uPoints[i1+1], p1z = uPoints[i1+2];\\n'+\n        'float p3x = uPoints[i3], p3y = uPoints[i3+1], p3z = uPoints[i3+2];\\n'+\n        'float p2x = 2.0*uPoints[i2]-p1x*0.5-p3x*0.5;\\n'+\n        'float p2y = 2.0*uPoints[i2+1]-p1y*0.5-p3y*0.5;\\n'+\n        'float p2z = 2.0*uPoints[i2+2]-p1z*0.5-p3z*0.5;\\n'+\n        'return vec3(t2*t2*p1x+2.0*t2*t*p2x+t*t*p3x, t2*t2*p1y+2.0*t2*t*p2y+t*t*p3y, t2*t2*p1z+2.0*t2*t*p2z+t*t*p3z); }\\n';\n\nGpuShaders.planeVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform vec4 uParams;\\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]\n    'uniform vec4 uParams3;\\n'+    //[px, py, sx, sy]\n    'uniform float uPoints[9*3];\\n'+\n\n    '#ifndef poles\\n'+\n        'uniform vec3 uVector;\\n'+\n        'uniform float uHeights[9];\\n'+\n    '#endif\\n'+\n\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+ GpuShaders.quadPoint +\n\n    '#ifndef poles\\n'+\n        'float linearHeight(float x, float y) {\\n'+\n            'int ix = int(x);\\n'+\n            'int iy = int(y);\\n'+\n            'int index = (2-iy)*3+ix;\\n'+\n            'int index2 = (2-(iy+1))*3+ix;\\n'+\n            'float fx = fract(x);\\n'+\n            'float fy = fract(y);\\n'+\n            'float w0 = (uHeights[index] + (uHeights[index+1] - uHeights[index])*fx);\\n'+\n            'float w1 = (uHeights[index2] + (uHeights[index2+1] - uHeights[index2])*fx);\\n'+\n            'return (w0 + (w1 - w0)*fy);\\n'+\n        '}\\n'+\n    '#endif\\n'+\n\n    'void main() {\\n'+\n        'vec3 indices = aPosition;\\n'+\n        'float t = aPosition.y * uParams[2];\\n'+  //vertical index\n        'float tt = t;\\n'+\n        'float t2 = (1.0-t);\\n'+\n        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\\n'+\n        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\\n'+\n        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\\n'+\n        't = aPosition.x * uParams[2];\\n'+  //horizontal index\n        'float tt2 = t;\\n'+\n        't2 = (1.0-t);\\n'+\n        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\\n'+\n        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\\n'+\n        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\\n'+\n        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\\n'+\n\n        '#ifndef poles\\n'+\n            '#ifndef flat\\n'+\n                'p.xyz += uVector * linearHeight(tt*2.0, tt2*2.0);\\n'+\n            '#endif\\n'+\n        '#endif\\n'+\n\n        'vec4 camSpacePos = uMV * p;\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n\n        '#ifdef depth\\n'+\n            'vFogFactor = camDist;\\n'+\n        '#else\\n'+\n            'vFogFactor = exp(uParams[1] * camDist);\\n'+\n        '#endif\\n'+\n\n        'vec2 uv;\\n'+\n        'uv.x = aTexCoord.y * uParams3[2] + uParams3[0];\\n'+\n        'uv.y = (1.0-aTexCoord.x) * uParams3[3] + uParams3[1];\\n'+\n        'vTexCoord = uv;\\n'+\n        'vTexCoord2 = p.xy;\\n'+\n    '}';\n\nGpuShaders.planeFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uParams2;\\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]\n\n    '#ifdef poles\\n'+\n        'uniform vec4 uParams4;\\n'+    //[pole-x, pole-y, pole-radius, 0]\n        'varying vec2 vTexCoord2;\\n'+\n    '#endif\\n'+\n\n    'varying vec2 vTexCoord;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        '#ifdef poles\\n'+\n            'if (length(uParams4.xy - vTexCoord2.xy) > uParams4.z){ discard; }\\n'+\n        '#endif\\n'+\n\n        '#ifdef depth\\n'+\n            'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vFogFactor) + (-0.5/255.0);\\n'+\n        '#else\\n'+\n            'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\\n'+\n            'gl_FragColor = mix(uFogColor, c, vFogFactor);\\n'+\n        '#endif\\n'+\n    '}';\n\nGpuShaders.getHFNormal =\n    'vec3 getHFNormal(vec2 uv, float texelSize, float heightDelta) {\\n'+\n        'vec4 h;\\n'+\n        'h[0] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0,-1.0))).r * heightDelta;\\n'+\n        'h[1] = texture2D(uSampler2, uv + (texelSize * vec2(-1.0, 0.0))).r * heightDelta;\\n'+\n        'h[2] = texture2D(uSampler2, uv + (texelSize * vec2( 1.0, 0.0))).r * heightDelta;\\n'+\n        'h[3] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0, 1.0))).r * heightDelta;\\n'+\n        'return normalize(vec3(h[1] - h[2], h[3] - h[0], 2.0));}\\n';\n\nGpuShaders.getHFNormal2 =\n    'vec2 getHFNormal2(vec2 uv, float texelSize, float heightDelta) {\\n'+\n        'vec4 h;\\n'+\n        'h[0] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0,-1.0))).r * heightDelta;\\n'+\n        'h[1] = texture2D(uSampler2, uv + (texelSize * vec2(-1.0, 0.0))).r * heightDelta;\\n'+\n        'h[2] = texture2D(uSampler2, uv + (texelSize * vec2( 1.0, 0.0))).r * heightDelta;\\n'+\n        'h[3] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0, 1.0))).r * heightDelta;\\n'+\n        'return vec2(h[1] - h[2], h[3] - h[0]);}\\n';\n\nGpuShaders.planeVertex4Shader =\n    '#define newspace\\n'+\n    'uniform sampler2D uSampler2;\\n'+\n    'attribute vec3 aPosition;\\n'+\n    //'attribute vec2 aTexCoord;\\n'+\n    //'attribute vec3 aBarycentric;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform vec4 uParams;\\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]\n    'uniform vec4 uParams3;\\n'+    //[px, py, sx, sy]\n    'uniform float uPoints[9*3];\\n'+\n    'uniform vec3 uVector;\\n'+\n    'uniform vec3 uHeights;\\n'+   //[hmin, hmax]\n    'uniform vec4 uTransform;\\n'+\n    //'uniform vec4 uTransform2;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n\n    '#ifdef newspace\\n'+\n        'varying mat3 vTBN;\\n'+\n    '#else\\n'+\n        'varying vec3 vNormal;\\n'+\n    '#endif\\n'+\n\n    'varying float vFogFactor;\\n'+ GpuShaders.quadPoint +  GpuShaders.getHFNormal + GpuShaders.getHFNormal2 +\n    //'float random(vec2 p) { return fract(cos(dot(p,vec2( 23.14069263277926, 2.665144142690225)))*12345.6789);}\\n'+\n\n    'void main() {\\n'+\n        'vec3 indices = aPosition;\\n'+\n        'float t = aPosition.y * uParams[2];\\n'+  //vertical index\n        'float tt = t;\\n'+\n        'float t2 = (1.0-t);\\n'+\n        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\\n'+\n        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\\n'+\n        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\\n'+\n        't = aPosition.x * uParams[2];\\n'+  //horizontal index\n        'float tt2 = t;\\n'+\n        't2 = (1.0-t);\\n'+\n        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\\n'+\n        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\\n'+\n        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\\n'+\n        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\\n'+\n        'vec2 uv2 = vec2(tt, 1.0-tt2);\\n'+\n        'uv2 = vec2(uTransform[0] * uv2[0] + uTransform[2], uTransform[1] * uv2[1] + uTransform[3]);\\n'+\n\n        'p.xyz += uVector * (uHeights[0] + (uHeights[1]-uHeights[0])*texture2D(uSampler2, uv2).x);\\n'+\n\n        'vec4 camSpacePos = uMV * p;\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uParams[1] * camDist);\\n'+\n\n        'vec2 uv = vec2(tt, 1.0-tt2);\\n'+\n        'uv.x = uv.x * uParams3[0] + uParams3[2];\\n'+\n        'uv.y = uv.y * uParams3[1] + uParams3[3];\\n'+\n        'vTexCoord = uv;\\n'+\n\n        'vBarycentric = camSpacePos.xyz;\\n'+\n\n        '#ifdef newspace\\n'+\n            'vec2 d = getHFNormal2(uv2, 1.0/(128.0), (uHeights[1]-uHeights[0]) * uHeights[2]);\\n'+\n            'vec3 T = vec3(2.0,0.0,-d.x); vec3 B = vec3(0.0,2.0,-d.y);\\n'+\n            'vTBN = mat3(normalize(T), normalize(B), cross(T,B));\\n'+\n        '#else\\n'+\n            'vec3 n = getHFNormal(uv2, 1.0/(128.0), (uHeights[1]-uHeights[0]) * uHeights[2]);\\n'+\n            'vNormal = normalize(n);\\n'+\n        '#endif\\n'+\n\n    '}';\n\nGpuShaders.planeFragmentShader2 = 'precision mediump float;\\n'+\n    '#extension GL_OES_standard_derivatives : enable\\n'+\n    '#define newspace\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uParams2;\\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]\n    'uniform mat3 uSpace;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying float vFogFactor;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n\n    '#ifdef newspace\\n'+\n        'varying mat3 vTBN;\\n'+\n    '#else\\n'+\n        'varying vec3 vNormal;\\n'+\n    '#endif\\n'+\n\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec3 ldir = normalize(-vBarycentric);\\n'+\n\n        '#ifdef flat\\n'+\n            'vec3 nx = dFdx(vBarycentric);\\n'+\n            'vec3 ny = dFdy(vBarycentric);\\n'+\n            'vec3 normal2 = normalize(cross(nx,ny));\\n'+\n            'vec4 c2 = vec4(vec3(max(0.0,normal2.z*(204.0/255.0))+(32.0/255.0)),1.0);\\n'+\n        '#else\\n'+\n\n            '#ifdef newspace\\n'+\n                //'vec3 normal = cross(normalize(vTangent), normalize(vBitangent));\\n'+\n\n                '#ifdef nmix\\n'+\n                    'vec3 normal = vTBN * normalize((texture2D(uSampler, vTexCoord).xyz-0.5)*2.0);\\n'+\n                '#else\\n'+\n                    'vec3 normal = vTBN * vec3(0.0,0.0,1.0);\\n'+\n                '#endif\\n'+\n\n            '#else\\n'+\n                'vec3 normal = vNormal;\\n'+\n            '#endif\\n'+\n\n            'normal = normalize(uSpace * normal);\\n'+\n\n            'vec3 eyeDir = ldir;\\n'+\n            'vec3 refDir = reflect(-ldir, normal);\\n'+\n            'float specW = min(1.0, pow(max(dot(refDir, eyeDir), 0.0), 90.0));\\n'+\n            'float diffW = min(1.0, max(dot(normal, ldir), 0.0));\\n'+\n            'float lcolor = (dot(normal, ldir) + 1.0) * 0.5;\\n'+\n            //'float lcolor = 0.25+(0.5*diffW)+(0.25*specW);\\n'+\n            //'float lcolor = 0.25+(0.75*diffW);\\n'+\n\n            '#ifdef normals\\n'+\n                'vec4 c2 = vec4(normal*0.5+0.5,1.0);\\n'+\n            '#else\\n'+\n                'vec4 c2 = vec4(vec3(dot(vec3(0.0,0.0,1.0), normal)),1.0);\\n'+\n            '#endif\\n'+\n            //'vec4 c2 = vec4(normalize(ldir)*0.5+0.5,1.0);\\n'+\n            //'vec4 c2 = vec4(vec3(lcolor),1.0);\\n'+\n        '#endif\\n'+\n\n        '#ifdef grid\\n'+\n            'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\\n'+\n            'c = mix(c, c2, 0.5);\\n'+\n        '#else\\n'+\n            '#ifdef exmap\\n'+\n\n                'vec4 c = texture2D(uSampler, vTexCoord);\\n'+\n\n                '#ifdef classmap\\n'+\n                    'int i = int(c.x*255.0);\\n'+\n\n                    /*\n                    'if (i == 0) c = vec4(0.3, 0.44, 0.64, 1.0);\\n'+\n                    'if (i == 1) c = vec4(0.0, 0.24, 0.0, 1.0);\\n'+\n                    'if (i == 2) c = vec4(0.58, 0.61, 0.44, 1.0);\\n'+\n                    'if (i == 3) c = vec4(0.0, 0.39, 0.0, 1.0);\\n'+\n                    'if (i == 4) c = vec4(0.12, 0.67, 0.02, 1.0);\\n'+\n                    'if (i == 5) c = vec4(0.08, 0.55, 0.24, 1.0);\\n'+\n                    'if (i == 6) c = vec4(0.36, 0.46, 0.17, 1.0);\\n'+\n                    'if (i == 7) c = vec4(0.7, 0.62, 0.18, 1.0);\\n'+\n                    'if (i == 8) c = vec4(0.7, 0.54, 0.2, 1.0);\\n'+\n                    'if (i == 9) c = vec4(0.91, 0.86, 0.37, 1.0);\\n'+\n                    'if (i == 10) c = vec4(0.88, 0.81, 0.54, 1.0);\\n'+\n                    'if (i == 11) c = vec4(0.61, 0.46, 0.33, 1.0);\\n'+\n                    'if (i == 12) c = vec4(0.73, 0.83, 0.56, 1.0);\\n'+\n                    'if (i == 13) c = vec4(0.25, 0.54, 0.45, 1.0);\\n'+\n                    'if (i == 14) c = vec4(0.42, 0.64, 0.54, 1.0);\\n'+\n                    'if (i == 15) c = vec4(0.9, 0.68, 0.4, 1.0);\\n'+\n                    'if (i == 16) c = vec4(0.66, 0.67, 0.68, 1.0);\\n'+\n                    'if (i == 17) c = vec4(0.86, 0.13, 0.15, 1.0);\\n'+\n                    'if (i == 18) c = vec4(0.3, 0.44, 0.64, 1.0);\\n'+\n                    'if (i == 19) c = vec4(1.0, 0.98, 1.0, 1.0);\\n'+\n                    'c = c * c2;\\n'+\n                    */\n\n                    'if (i == 1 || i == 2 || i == 5 || i == 6) c = vec4(146.0, 178.0, 144.0, 255.0);\\n'+\n                    'if (i == 3 || i == 4) c = vec4(94.0, 169.0, 133.0, 255.0);\\n'+\n                    'if (i == 8 || i == 11) c = vec4(238.0, 221.0, 185.0, 255.0);\\n'+\n                    'if (i == 7) c = vec4(226.0, 192.0, 154.0, 255.0);\\n'+\n                    'if (i == 9 || i == 10 || i == 12) c = vec4(250.0, 246.0, 167.0, 255.0);\\n'+\n                    'if (i == 13 || i == 16) c = vec4(245.0, 236.0, 211.0, 255.0);\\n'+\n                    'if (i == 14) c = vec4(139.0, 185.0, 166.0, 255.0);\\n'+\n                    'if (i == 15) c = vec4(199.0, 219.0, 155.0, 255.0);\\n'+\n                    'if (i == 17) c = vec4(149.0, 132.0, 162.0, 255.0);\\n'+\n                    'if (i == 18 || i == 0) c = vec4(188.0, 221.0, 255.0, 255.0);\\n'+\n                    'if (i == 19) c = vec4(255.0, 255.0, 255.0, 255.0);\\n'+\n                    'c = (c*(1.0/255.0)) * c2;\\n'+\n                '#endif\\n'+\n\n            '#else\\n'+\n                'vec4 c = c2;\\n'+\n            '#endif\\n'+\n        '#endif\\n'+\n\n        '#ifdef fog\\n'+\n            'gl_FragColor = mix(uFogColor, c, vFogFactor);\\n'+\n        '#else\\n'+\n            'gl_FragColor = c;\\n'+\n        '#endif\\n'+\n    '}';\n\n\n//textured tile mesh\nGpuShaders.tileVertexShader =\n    'attribute vec3 aPosition;\\n'+\n\n    '#ifdef onlyFog\\n'+\n        'varying float vFogFactor;\\n'+\n    '#else\\n'+\n\n        '#ifdef externalTex\\n'+\n            'attribute vec2 aTexCoord2;\\n'+\n        '#else\\n'+\n            'attribute vec2 aTexCoord;\\n'+\n        '#endif\\n'+\n\n        'varying vec3 vTexCoord;\\n'+  //u,v,fogFactor\n\n    '#endif\\n'+\n\n    '#ifdef clip4\\n'+\n        '#ifndef externalTex\\n'+\n            'attribute vec2 aTexCoord2;\\n'+\n        '#endif\\n'+\n\n        'varying vec2 vClipCoord;\\n'+\n    '#endif\\n'+\n\n    '#ifdef clip8\\n'+\n        '#ifndef externalTex\\n'+\n            'attribute vec2 aTexCoord2;\\n'+\n        '#endif\\n'+\n\n        'varying vec3 vClipCoord;\\n'+\n\n        'uniform mat4 uParamsC8;\\n'+  //c,x,y,z\n\n        'float getLinePointParametricDist(vec3 c, vec3 v, vec3 p) {\\n'+\n            'vec3 w = p - c;\\n'+\n            'float c1 = dot(w,v);\\n'+\n            'if (c1 <= 0.0) return 0.0;\\n'+\n            'float c2 = dot(v,v);\\n'+\n            'if (c2 <= c1) return 1.0;\\n'+\n            'return c1 / c2;\\n'+\n        '}\\n'+\n\n    '#endif\\n'+\n\n    '#ifdef depth\\n'+\n        'varying float vDepth;\\n'+\n    '#endif\\n'+\n\n    '#ifdef flatShadeVar\\n'+\n        ///'attribute vec3 aBarycentric;\\n'+\n        'varying vec3 vBarycentric;\\n'+\n    '#endif\\n'+\n\n                                             //0-3                            4-7          8-11            12-15\n    'uniform mat4 uMV, uProj, uParams;\\n'+  //[zfactor, fogDensity, scale.xy][camVec.xyzw][transform.xyzw][scale.z, trans.xyz]\n\n    '#ifdef applySE\\n'+\n        'uniform mat4 uParamsSE;\\n'+\n    '#endif\\n'+\n\n    'void main() {\\n'+\n\n        '#ifdef applySE\\n'+\n            'vec3 geoPos2 = aPosition*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\\n'+\n            'vec3 geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\\n'+\n            'geoPos.z *= uParamsSE[3][3];\\n'+\n            'float ll = length(geoPos);\\n'+\n            'vec3 v = geoPos * (1.0/(ll+0.0001));\\n'+\n            'float h = ll - uParamsSE[3][2];\\n'+\n            'float h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\\n'+\n            'float h3 = h;\\n'+\n            'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\\n'+\n            'geoPos2.xyz += v * (h - h3);\\n'+\n            'vec4 camSpacePos = uMV * vec4(geoPos2, 1.0);\\n'+\n            'float l = dot(v, vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\\n'+\n        '#else\\n'+\n            'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n            'vec3 worldPos = vec3(aPosition.x * uParams[0][2] + uParams[3][1], aPosition.y * uParams[0][3] + uParams[3][2], aPosition.z * uParams[3][0] + uParams[3][3]);\\n'+\n            'float l = dot(normalize(worldPos.xyz), vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\\n'+\n        '#endif\\n'+\n\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n\n        '#ifdef depth\\n'+\n            'vDepth = camDist;\\n'+\n        '#endif\\n'+\n\n        '#ifdef flatShadeVar\\n'+\n            'vBarycentric = camSpacePos.xyz;\\n'+\n        '#endif\\n'+\n\n        'float fogFactor = 1.0-exp(uParams[0][1] * camDist);\\n'+\n        'fogFactor = clamp((1.0-abs(l))*uParams[1][3] + fogFactor, 0.0, 1.0);\\n'+\n\n        '#ifdef onlyFog\\n'+\n            'vFogFactor = fogFactor;\\n'+\n        '#else\\n'+\n            'vTexCoord.z = fogFactor;\\n'+\n\n            '#ifdef externalTex\\n'+\n                'vTexCoord.xy = vec2(uParams[2][0] * aTexCoord2[0] + uParams[2][2], uParams[2][1] * aTexCoord2[1] + uParams[2][3]);\\n'+\n            '#else\\n'+\n                'vTexCoord.xy = aTexCoord;\\n'+\n            '#endif\\n'+\n\n        '#endif\\n'+\n\n        '#ifdef clip4\\n'+\n            'vClipCoord.xy = aTexCoord2.xy;\\n'+\n        '#endif\\n'+\n\n        '#ifdef clip8\\n'+\n            //'vClipCoord.x = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[1][0],uParamsC8[1][1],uParamsC8[1][2]), camSpacePos.xyz);\\n'+\n            //'vClipCoord.y = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[2][0],uParamsC8[2][1],uParamsC8[2][2]), camSpacePos.xyz);\\n'+\n            //'vClipCoord.z = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[3][0],uParamsC8[3][1],uParamsC8[3][2]), camSpacePos.xyz);\\n'+\n\n            'vec3 worldPos2 = vec3(aPosition.x * uParams[0][2] + uParamsC8[0][3], aPosition.y * uParams[0][3] + uParamsC8[1][3], aPosition.z * uParams[3][0] + uParamsC8[2][3]);\\n'+\n\n            'vClipCoord.x = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[1][0],uParamsC8[1][1],uParamsC8[1][2]), worldPos2.xyz);\\n'+\n            'vClipCoord.y = getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[2][0],uParamsC8[2][1],uParamsC8[2][2]), worldPos2.xyz);\\n'+\n            'vClipCoord.z = 1.0-getLinePointParametricDist(vec3(uParamsC8[0][0],uParamsC8[0][1],uParamsC8[0][2]), vec3(uParamsC8[3][0],uParamsC8[3][1],uParamsC8[3][2]), worldPos2.xyz);\\n'+\n            //'vClipCoord.xyz = vec3(0.0, 0.0, 1.0);\\n'+\n        '#endif\\n'+\n    '}';\n\nGpuShaders.tileFragmentShader = 'precision mediump float;\\n'+\n\n    '#ifdef clip4\\n'+\n        'uniform float uClip[4];\\n'+\n        'varying vec2 vClipCoord;\\n'+\n    '#endif\\n'+\n\n    '#ifdef clip8\\n'+\n        'uniform float uClip[8];\\n'+\n        'varying vec3 vClipCoord;\\n'+\n    '#endif\\n'+\n\n\n    '#ifdef onlyFog\\n'+\n        'varying float vFogFactor;\\n'+\n    '#else\\n'+\n\n        'varying vec3 vTexCoord;\\n'+\n        'uniform sampler2D uSampler;\\n'+\n\n        '#ifdef mask\\n'+\n            'uniform sampler2D uSampler2;\\n'+\n        '#endif\\n'+\n\n    '#endif\\n'+\n\n    '#ifdef depth\\n'+\n        'varying float vDepth;\\n'+\n    '#endif\\n'+\n\n    '#ifdef flatShadeVar\\n'+\n        'varying vec3 vBarycentric;\\n'+\n\n        '#ifdef fogAndColor\\n'+\n            'uniform vec4 uColor;\\n'+\n        '#endif\\n'+\n\n    '#endif\\n'+\n\n    'uniform vec4 uParams2;\\n'+\n    'void main() {\\n'+\n\n        '#ifdef clip4_nomargin\\n'+\n            'if (vClipCoord.y > 0.5){\\n'+\n                'if (vClipCoord.x > 0.5){\\n'+\n                    'if (uClip[3] == 0.0) discard;\\n'+\n                '} else {\\n'+\n                    'if (uClip[2] == 0.0) discard;\\n'+\n                '}\\n'+\n            '} else {\\n'+\n                'if (vClipCoord.x > 0.5){\\n'+\n                    'if (uClip[1] == 0.0) discard;\\n'+\n                '} else {\\n'+\n                    'if (uClip[0] == 0.0) discard;\\n'+\n                '}\\n'+\n            '}\\n'+\n        '#endif\\n'+\n\n        '#ifdef clip4\\n'+\n            'if (vClipCoord.y > 0.5){\\n'+\n                'if (vClipCoord.x > 0.5){\\n'+\n                    'if (uClip[3] == 0.0 && !(vClipCoord.x < TMAX && uClip[2] != 0.0) && !(vClipCoord.y < TMAX && uClip[1] != 0.0)) discard;\\n'+\n                '} else {\\n'+\n                    'if (uClip[2] == 0.0 && !(vClipCoord.x > TMIN && uClip[3] != 0.0) && !(vClipCoord.y < TMAX && uClip[0] != 0.0)) discard;\\n'+\n                '}\\n'+\n            '} else {\\n'+\n                'if (vClipCoord.x > 0.5){\\n'+\n                    'if (uClip[1] == 0.0 && !(vClipCoord.x < TMAX && uClip[0] != 0.0) && !(vClipCoord.y > TMIN && uClip[3] != 0.0)) discard;\\n'+\n                '} else {\\n'+\n                    'if (uClip[0] == 0.0 && !(vClipCoord.x > TMIN && uClip[1] != 0.0) && !(vClipCoord.y > TMIN && uClip[2] != 0.0)) discard;\\n'+\n                '}\\n'+\n            '}\\n'+\n        '#endif\\n'+\n\n        '#ifdef clip8\\n'+\n            'if (vClipCoord.z <= 0.5){\\n'+\n                'if (vClipCoord.y <= 0.5){\\n'+\n                    'if (vClipCoord.x > 0.5){\\n'+\n                        'if (uClip[5] == 0.0) discard;\\n'+\n                    '} else {\\n'+\n                        'if (uClip[4] == 0.0) discard;\\n'+\n                    '}\\n'+\n                '} else {\\n'+\n                    'if (vClipCoord.x > 0.5){\\n'+\n                        'if (uClip[7] == 0.0) discard;\\n'+\n                    '} else {\\n'+\n                        'if (uClip[6] == 0.0) discard;\\n'+\n                    '}\\n'+\n                '}\\n'+\n            '} else {\\n'+\n                'if (vClipCoord.y <= 0.5){\\n'+\n                    'if (vClipCoord.x > 0.5){\\n'+\n                        'if (uClip[1] == 0.0) discard;\\n'+\n                    '} else {\\n'+\n                        'if (uClip[0] == 0.0) discard;\\n'+\n                    '}\\n'+\n                '} else {\\n'+\n                    'if (vClipCoord.x > 0.5){\\n'+\n                        'if (uClip[3] == 0.0) discard;\\n'+\n                    '} else {\\n'+\n                        'if (uClip[2] == 0.0) discard;\\n'+\n                    '}\\n'+\n                '}\\n'+\n            '}\\n'+\n        '#endif\\n'+\n\n        '#ifdef flatShadeVar\\n'+\n\n            '#ifdef flatShadeVarFallback\\n'+\n                'vec4 flatShadeData = vec4(1.0);\\n'+\n            '#else\\n'+\n                '#ifdef GL_OES_standard_derivatives\\n'+\n                    'vec3 nx = dFdx(vBarycentric);\\n'+\n                    'vec3 ny = dFdy(vBarycentric);\\n'+\n                    'vec3 normal=normalize(cross(nx,ny));\\n'+\n                    'vec4 flatShadeData = vec4(vec3(max(0.0,normal.z*(204.0/255.0))+(32.0/255.0)),1.0);\\n'+\n                '#else\\n'+\n                    'vec4 flatShadeData = vec4(1.0);\\n'+\n                '#endif\\n'+\n            '#endif\\n'+\n\n        '#endif\\n'+\n\n        '#ifdef flatShade\\n'+\n\n            '#ifdef fogAndColor\\n'+\n               // 'gl_FragColor = vec4(mix(uColor.xyz * flatShadeData.xyz, uParams2.xyz, vTexCoord.z), uColor.w);\\n'+\n                'gl_FragColor = vec4(uColor.xyz * flatShadeData.xyz, uColor.w);\\n'+\n            '#else\\n'+\n                'gl_FragColor = vec4(flatShadeData.xyz, 1.0);\\n'+\n            '#endif\\n'+\n\n        '#else\\n'+\n\n            'vec4 fogColor = vec4(uParams2.xyz, 1.0);\\n'+\n\n            '#ifdef onlyFog\\n'+\n                'gl_FragColor = vec4(fogColor.xyz, vFogFactor);\\n'+\n            '#else\\n'+\n\n                '#ifdef depth\\n'+\n                    'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\\n'+\n                '#else\\n'+\n\n                    '#ifdef externalTex\\n'+\n                        'vec4 c = texture2D(uSampler, vTexCoord.xy);\\n'+'__FILTER__' +\n                        'vec4 cc = mix(c, fogColor, vTexCoord.z);\\n'+\n                        '#ifdef mask\\n'+\n                            'vec4 c2 = texture2D(uSampler2, vTexCoord.xy);\\n'+\n                            'cc.w = c.w * uParams2.w * c2.x;\\n'+\n                        '#else\\n'+\n                            'cc.w = c.w * uParams2.w;\\n'+\n                        '#endif\\n'+\n\n                        'gl_FragColor = cc;\\n'+\n                    '#else\\n'+\n                        'gl_FragColor = mix(texture2D(uSampler, vTexCoord.xy), fogColor, vTexCoord.z);\\n'+\n                    '#endif\\n'+\n\n                '#endif\\n'+\n\n            '#endif\\n'+\n\n        '#endif\\n'+\n\n        // '#ifdef clip8\\n'+\n          //  'gl_FragColor = vec4(vClipCoord.x, vClipCoord.y, vClipCoord.z, 1.0);\\n'+\n        // '#endif\\n'+\n    '}';\n\n\nGpuShaders.shadedMeshVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'attribute vec3 aNormal;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform mat3 uNorm;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'varying float vFogFactor;\\n'+\n    'void main() {\\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uFogDensity * camDist);\\n'+\n        'vTexCoord = aTexCoord;\\n'+\n        'vPosition = camSpacePos;\\n'+\n        'vNormal = aNormal * uNorm;\\n'+\n    '}';\n\n\nGpuShaders.shadedMeshFragmentShader = 'precision mediump float;\\n'+\n    '#ifdef textured\\n'+\n        'uniform sampler2D uSampler;\\n'+\n        'varying vec2 vTexCoord;\\n'+\n    '#endif\\n'+\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'uniform mat4 uMaterial;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+\n    'void main() {\\n'+\n        'vec3 ldir = normalize(-vPosition.xyz);\\n'+\n        'vec3 normal = normalize(vNormal);\\n'+\n        'vec3 eyeDir = ldir;\\n'+\n        'vec3 refDir = reflect(-ldir, normal);\\n'+\n        'float specW = min(1.0, pow(max(dot(refDir, eyeDir), 0.0), uMaterial[3][0]));\\n'+\n        'float diffW = min(1.0, max(dot(normal, ldir), 0.0));\\n'+\n        'vec4 lcolor = uMaterial[0]+(uMaterial[1]*diffW)+(uMaterial[2]*specW);\\n'+\n        '#ifdef textured\\n'+\n            'vec4 tcolor = texture2D(uSampler, vTexCoord);\\n'+\n            'gl_FragColor = mix(uFogColor, vec4(lcolor.xyz*(1.0/255.0), 1.0) * tcolor, vFogFactor); gl_FragColor.w *= uMaterial[3][1];\\n'+\n        '#else\\n'+\n            'gl_FragColor = mix(uFogColor, vec4(lcolor.xyz*(1.0/255.0), 1.0), vFogFactor);  gl_FragColor.w = uMaterial[3][1];\\n'+\n        '#endif\\n'+\n\n    '}';\n\nGpuShaders.tileWireFrameBasicShader = 'precision mediump float;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = uColor;\\n'+\n    '}';\n\n\n//used for 2d images\nGpuShaders.imageVertexShader = '\\n'+\n    'attribute vec4 aPosition;\\n'+\n    'uniform mat4 uProjectionMatrix;\\n'+\n    'uniform mat4 uData;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'uniform float uDepth;\\n'+\n    'varying vec4 vColor;\\n'+\n    'varying vec2 vTexcoords;\\n'+\n    'void main(void){\\n'+\n        'int i=int(aPosition.x);\\n'+\n        //\"gl_Position=uProjectionMatrix*vec4(floor(uData[i][0]+0.1),floor(uData[i][1]+0.1),0.0,1.0);\\n\"+\n        //IE11 :(\n\n        'vec4 p;\\n'+\n\n        'if(i==0) p = vec4(floor(uData[0][0]+0.1),floor(uData[0][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[0][2], uData[0][3]);\\n'+\n        'if(i==1) p = vec4(floor(uData[1][0]+0.1),floor(uData[1][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[1][2], uData[1][3]);\\n'+\n        'if(i==2) p = vec4(floor(uData[2][0]+0.1),floor(uData[2][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[2][2], uData[2][3]);\\n'+\n        'if(i==3) p = vec4(floor(uData[3][0]+0.1),floor(uData[3][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[3][2], uData[3][3]);\\n'+\n\n        'gl_Position=uProjectionMatrix*p;\\n'+\n        'vec4 c=uColor;\\n'+\n        'c.w*=1.0;\\n'+\n        'vColor=c;\\n'+\n    '}';\n\n\nGpuShaders.imageFragmentShader = 'precision mediump float;\\n'+\n    'varying vec4 vColor;\\n'+\n    'varying vec2 vTexcoords;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'void main(void){\\n'+\n        'vec4 c=texture2D(uSampler, vec2(vTexcoords.x, vTexcoords.y) );\\n'+\n        'c*=vColor;\\n'+\n        'if(c.w < 0.01){ discard; }\\n'+\n        'gl_FragColor = c;\\n'+\n    '}';\n\n\nexport default GpuShaders;\n","\nimport {utils as utils_} from '../../utils/utils';\n\n//get rid of compiler mess\nvar utils = utils_;\n\nvar GpuTexture = function(gpu, path, core, fileSize, direct, repeat, filter, keepImage, onLoaded, onError) {\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.texture = null;\n    this.framebuffer = null;\n    this.size = 0;\n    this.fileSize = fileSize; //used for stats\n    this.width = 0;\n    this.height = 0;\n    this.repeat = repeat || false;\n    this.filter = filter || 'linear';\n\n    this.image = null;\n    this.loaded = false;\n    this.trilinear = false;//true;\n    this.core = core;\n\n    if (path != null) {\n        this.load(path, onLoaded, onError, direct, keepImage);\n    }\n};\n\n//destructor\nGpuTexture.prototype.kill = function() {\n    this.gl.deleteTexture(this.texture);\n    \n    this.texture = null;\n};\n\n// Returns GPU RAM used, in bytes.\nGpuTexture.prototype.getSize = function() {\n    return this.size;\n};\n\nGpuTexture.prototype.createFromData = function(lx, ly, data, filter, repeat) {\n    var gl = this.gl;\n\n    this.texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n    if (repeat){\n        repeat = gl.REPEAT;\n        this.repeat = true;\n    } else {\n        repeat = gl.CLAMP_TO_EDGE;\n    }\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat);\n    var mipmaps = false;\n\n    switch (filter) {\n    case 'linear':\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        break;\n    case 'trilinear':\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        mipmaps = true;\n        break;\n    default:\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        break;\n    }\n\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lx, ly, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n    if (mipmaps) {\n        gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    this.width = lx;\n    this.height = ly;\n    this.size = lx * ly * 4;\n    this.loaded = true;\n};\n\nGpuTexture.prototype.createFromImage = function(image, filter, repeat, aniso) {\n    var gl = this.gl;\n\n    //filter = 'trilinear'; aniso = null; this.gpu.anisoLevel = 0;\n    var width = image.naturalWidth;\n    var height = image.naturalHeight;\n    var data = image;\n\n    this.texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n    if (repeat) {\n        repeat = gl.REPEAT;\n        this.repeat = true;\n    } else {\n        repeat = gl.CLAMP_TO_EDGE;\n    }\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat);\n    var mipmaps = false;\n    this.filter = filter;\n\n    switch (filter) {\n    case 'linear':\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        break;\n    case 'trilinear':\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        mipmaps = true;\n        break;\n    default:\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        break;\n    }\n\n    //resize image to nearest power of two\n    if ((this.repeat || mipmaps) && (!utils.isPowerOfTwo(width) || !utils.isPowerOfTwo(height))) {\n        width = utils.nearestPowerOfTwo(width);\n        height = utils.nearestPowerOfTwo(height);\n        var canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        var context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0, width, height); \n        data = canvas;\n    }\n\n    var gpu = this.gpu;\n\n    if (gpu.anisoLevel) {\n        gl.texParameterf(gl.TEXTURE_2D, gpu.anisoExt.TEXTURE_MAX_ANISOTROPY_EXT, gpu.anisoLevel);\n    }\n\n    if (gpu.noTextures !== true) { //why is it here and not at the beginig of the code?\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n        if (mipmaps) {\n            gl.generateMipmap(gl.TEXTURE_2D);\n        }\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    this.width = width;\n    this.height = height;\n    this.size = width * height * 4;\n    this.loaded = true;\n};\n\nGpuTexture.prototype.load = function(path, onLoaded, onError, direct, keepImage) {\n    this.image = utils.loadImage(path, (function () {\n        if (this.core != null && this.core.killed) {\n            return;\n        }\n\n        this.createFromImage(this.image, this.filter, this.repeat);\n        if (!keepImage) {\n            this.image = null;\n        }\n\n        if (onLoaded) {\n            onLoaded();\n        } else {\n            if (this.core.map && this.core.map.markDirty) {\n                this.core.map.markDirty();\n            }\n        }\n\n    }).bind(this), (function () {\n\n        if (this.core != null && this.core.killed) {\n            return;\n        }\n\n        if (onError) {\n            onError();\n        }\n    }).bind(this),\n     \n     null, direct\n     \n     );\n\n};\n\n\nGpuTexture.prototype.createFramebufferFromData = function(lx, ly, data) {\n    var gl = this.gl;\n\n    var framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    framebuffer.width = lx;\n    framebuffer.height = ly;\n\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lx, ly, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n\n\n    var renderbuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, lx, ly);\n\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n    this.width = lx;\n    this.height = ly;\n    this.size = lx * ly * 4;\n\n    this.texture = texture;\n    this.renderbuffer = renderbuffer;\n    this.framebuffer = framebuffer;\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n};\n\n\nGpuTexture.prototype.createFramebuffer = function(lx, ly) {\n    if (this.texture == null){\n        return;\n    }\n\n    var gl = this.gl;\n\n    var framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    framebuffer.width = lx;\n    framebuffer.height = ly;\n\n    gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n    var renderbuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, lx, ly);\n\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    this.framebuffer = framebuffer;\n    this.renderbuffer = renderbuffer;\n};\n\n\nGpuTexture.prototype.readFramebufferPixels = function(x, y, lx, ly, fastMode, data) {\n    if (this.texture == null) {\n        return;\n    }\n\n    this.gpu.bindTexture(this);\n\n    if (!fastMode) {\n        this.gpu.setFramebuffer(this);\n    }\n\n    var gl = this.gl;\n\n    // Read the contents of the framebuffer (data stores the pixel data)\n    if (!data) {\n        data = new Uint8Array(lx * ly * 4);        \n    }\n    gl.readPixels(x, y, lx, ly, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n    if (!fastMode) {\n        this.gpu.setFramebuffer(null);\n    }\n\n    return data;\n};\n\nexport default GpuTexture;\n\n\n","\nimport RendererGeometry_ from './geometry';\nimport GpuBBox_ from './gpu/bbox';\nimport GpuFont_ from './gpu/font';\nimport GpuMesh_ from './gpu/mesh';\nimport GpuPixelLine3_ from './gpu/pixel-line3';\nimport GpuProgram_ from './gpu/program';\nimport GpuShaders_ from './gpu/shaders';\nimport GpuTexture_ from './gpu/texture';\n\n//get rid of compiler mess\nvar RendererGeometry = RendererGeometry_;\nvar GpuBBox = GpuBBox_;\nvar GpuFont = GpuFont_;\nvar GpuMesh = GpuMesh_;\nvar GpuPixelLine3 = GpuPixelLine3_;\nvar GpuProgram = GpuProgram_;\nvar GpuShaders = GpuShaders_;\nvar GpuTexture = GpuTexture_;\n\n\nvar RendererInit = function(renderer) {\n    this.renderer = renderer;\n    this.core = renderer.core;\n    this.gpu = renderer.gpu;\n\n    //renderer.font = new GpuFont(this.gpu, this.core);\n    //renderer.fonts['#default'] = renderer.font;\n    //renderer.font = new GpuFont(this.gpu, this.core, null, null, './allinone.fnt');\n\n    this.initShaders();\n    this.initHeightmap();\n    this.initSkydome();\n    this.initHitmap();\n    this.initTextMap();\n    this.initImage();\n    this.initTestMap();\n    this.initBBox();\n    this.initLines();\n    this.initBaricentricBuffer();\n};\n\n\nRendererInit.prototype.initShaders = function() {\n    var shaders = GpuShaders;\n    var renderer = this.renderer;\n    var gpu = this.gpu;\n\n    renderer.progTile = [new GpuProgram(gpu, '#define variants\\n' +shaders.tileVertexShader, '#define variants\\n' + shaders.tileFragmentShader)];\n    renderer.progTile2 = [new GpuProgram(gpu, '#define variants\\n#define externalTex\\n' + shaders.tileVertexShader, '#define variants\\n#define externalTex\\n' + shaders.tileFragmentShader.replace('__FILTER__', ''))];\n    renderer.progTile3 = [new GpuProgram(gpu, '#define variants\\n#define externalTex\\n' + shaders.tileVertexShader, '#define variants\\n#define externalTex\\n#define mask\\n' + shaders.tileFragmentShader.replace('__FILTER__', ''))];\n\n    renderer.progFogTile = [new GpuProgram(gpu, '#define variants\\n#define onlyFog\\n' + shaders.tileVertexShader, '#define variants\\n#define onlyFog\\n' + shaders.tileFragmentShader)];\n\n    var sdExt = '#extension GL_OES_standard_derivatives : enable\\n';\n\n    renderer.progFlatShadeTile = [new GpuProgram(gpu, '#define variants\\n#define flatShadeVar\\n' + shaders.tileVertexShader, sdExt+'#define variants\\n#define flatShadeVar\\n#define flatShade\\n' + shaders.tileFragmentShader)];\n    renderer.progFlatShadeTileSE = [new GpuProgram(gpu, '#define variants\\n#define applySE\\n#define flatShadeVar\\n' + shaders.tileVertexShader, sdExt+'#define variants\\n#define flatShadeVar\\n#define flatShade\\n' + shaders.tileFragmentShader)];\n    renderer.progCFlatShadeTile = new GpuProgram(gpu, '#define flatShadeVar\\n' + shaders.tileVertexShader, (sdExt+'#define flatShadeVar\\n#define flatShade\\n#define fogAndColor\\n' + shaders.tileFragmentShader).replace('mediump', 'highp'));\n    renderer.progCFlatShadeTileSE = new GpuProgram(gpu, '#define applySE\\n#define flatShadeVar\\n' + shaders.tileVertexShader, (sdExt+'#define flatShadeVar\\n#define flatShade\\n#define fogAndColor\\n' + shaders.tileFragmentShader).replace('mediump', 'highp'));\n\n    renderer.progDepthTile = [new GpuProgram(gpu, '#define variants\\n#define depth\\n' + shaders.tileVertexShader, ('#define variants\\n#define depth\\n' + shaders.tileFragmentShader).replace('mediump', 'highp'))];\n    renderer.progDepthHeightmap = new GpuProgram(gpu, shaders.heightmapDepthVertexShader, (shaders.heightmapDepthFragmentShader).replace('mediump', 'highp'));\n\n    renderer.progWireFrameBasic = [new GpuProgram(gpu, '#define variants\\n' + shaders.tileVertexShader, '#define variants\\n' + shaders.tileWireFrameBasicShader)];\n\n    renderer.progShadedTile = new GpuProgram(gpu, shaders.shadedMeshVertexShader, shaders.shadedMeshFragmentShader);\n    renderer.progTShadedTile = new GpuProgram(gpu, shaders.shadedMeshVertexShader, '#define textured\\n' + shaders.shadedMeshFragmentShader);\n\n    renderer.progHeightmap = new GpuProgram(gpu, shaders.heightmapVertexShader, shaders.heightmapFragmentShader);\n    renderer.progPlane = new GpuProgram(gpu, '#define flat\\n' + shaders.planeVertexShader, shaders.planeFragmentShader); //flat\n    renderer.progPlane2 = new GpuProgram(gpu, '#define poles\\n' + shaders.planeVertexShader, '#define poles\\n' + shaders.planeFragmentShader); //poles\n    renderer.progPlane3 = new GpuProgram(gpu, shaders.planeVertexShader, shaders.planeFragmentShader); // grid\n    renderer.progPlaneD = new GpuProgram(gpu, '#define depth\\n#define flat\\n' + shaders.planeVertexShader, '#define depth\\n' + shaders.planeFragmentShader); //flat\n    renderer.progPlane2D = new GpuProgram(gpu, '#define depth\\n#define poles\\n' + shaders.planeVertexShader, '#define depth\\n#define poles\\n' + shaders.planeFragmentShader); //poles\n    renderer.progPlane3D = new GpuProgram(gpu, '#define depth\\n' + shaders.planeVertexShader, '#define depth\\n' + shaders.planeFragmentShader); // grid\n\n    renderer.progSkydome = new GpuProgram(gpu, shaders.skydomeVertexShader, shaders.skydomeFragmentShader);\n    renderer.progStardome = new GpuProgram(gpu, shaders.skydomeVertexShader, shaders.stardomeFragmentShader);\n    \n    renderer.progAtmo2 = new GpuProgram(gpu, shaders.atmoVertexShader, shaders.atmoFragmentShader);\n    renderer.progAtmo = new GpuProgram(gpu, shaders.atmoVertexShader3, shaders.atmoFragmentShader3);\n\n    renderer.progBBox = new GpuProgram(gpu, shaders.bboxVertexShader, shaders.bboxFragmentShader);\n    renderer.progBBox2 = new GpuProgram(gpu, shaders.bbox2VertexShader, shaders.bboxFragmentShader);\n\n    renderer.progLine = new GpuProgram(gpu, shaders.lineVertexShader, shaders.lineFragmentShader); //line\n    renderer.progLineSE = new GpuProgram(gpu, '#define applySE\\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //line SE\n    renderer.progELine = new GpuProgram(gpu, '#define withElements\\n' + shaders.lineVertexShader, '#define withElements\\n' + shaders.lineFragmentShader); //line elements \n    renderer.progELineSE = new GpuProgram(gpu, '#define applySE\\n#define withElements\\n' + shaders.lineVertexShader, '#define withElements\\n' + shaders.lineFragmentShader); //line SE elements \n    renderer.progLine3 = new GpuProgram(gpu, '#define pixelLine\\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //pixel line\n    renderer.progELine3 = new GpuProgram(gpu, '#define pixelLine\\n#define withElements\\n' + shaders.lineVertexShader, '#define withElements\\n' + shaders.lineFragmentShader); //pixel line elements\n    renderer.progLine3SE = new GpuProgram(gpu, '#define applySE\\n#define pixelLine\\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //pixel line SE\n    renderer.progELine3SE = new GpuProgram(gpu, '#define applySE\\n#define pixelLine\\n#define withElements\\n' + shaders.lineVertexShader, '#define withElements\\n' + shaders.lineFragmentShader); //pixel line SE elements\n    renderer.progLine4 = new GpuProgram(gpu, '#define pixelLine\\n#define dataPoints\\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //direct linestring pixel line\n    renderer.progLine5 = new GpuProgram(gpu, '#define pixelLine\\n#define dataPoints\\n#define dataPoints2\\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //clipped direct linestring pixel line, physical coords\n    renderer.progRLine = new GpuProgram(gpu, '#define dynamicWidth\\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //dynamic width line\n    renderer.progRLineSE = new GpuProgram(gpu, '#define applySE\\n#define dynamicWidth\\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //dynamic width line\n    renderer.progERLine = new GpuProgram(gpu, '#define dynamicWidth\\n#define withElements\\n' + shaders.lineVertexShader, '#define withElements\\n' + shaders.lineFragmentShader); //dynamic width line elements\n    renderer.progERLineSE = new GpuProgram(gpu, '#define applySE\\n#define dynamicWidth\\n#define withElements\\n' + shaders.lineVertexShader, '#define withElements\\n' + shaders.lineFragmentShader); //dynamic width line elements\n\n    renderer.progTLine = new GpuProgram(gpu, shaders.tlineVertexShader, shaders.tlineFragmentShader); //textured line\n    renderer.progTPLine = new GpuProgram(gpu, shaders.tplineVertexShader, shaders.tlineFragmentShader); //textured pixed line\n    renderer.progTBLine = new GpuProgram(gpu, shaders.tlineVertexShader, shaders.tblineFragmentShader); //textured line with background color\n    renderer.progTPBLine = new GpuProgram(gpu, shaders.tplineVertexShader, shaders.tblineFragmentShader); //textured pixel line with background color\n    renderer.progETLine = new GpuProgram(gpu, shaders.etlineVertexShader, shaders.elineFragmentShader); //textured line elements\n    renderer.progETPLine = new GpuProgram(gpu, shaders.etplineVertexShader, shaders.elineFragmentShader); //textured pixed line elements\n    //renderer.progLineWireframe = new GpuProgram(gpu, shaders.lineWireframeVertexShader, shaders.lineWireframeFragmentShader); //line with wireframe for debugging\n\n    renderer.progText2 = new GpuProgram(gpu, '#define lineLabel\\n' + shaders.lineVertexShader, shaders.text2FragmentShader); //line label \n    renderer.progText2SE = new GpuProgram(gpu, '#define applySE\\n#define lineLabel\\n' + shaders.lineVertexShader, shaders.text2FragmentShader); //line label \n\n    renderer.progLineLabel16 = new GpuProgram(gpu, '#define DSIZE 16\\n#define lineLabel2\\n' + shaders.lineVertexShader, shaders.text2FragmentShader); \n    renderer.progLineLabel32 = new GpuProgram(gpu, '#define DSIZE 32\\n#define lineLabel2\\n' + shaders.lineVertexShader, shaders.text2FragmentShader); \n    renderer.progLineLabel48 = new GpuProgram(gpu, '#define DSIZE 48\\n#define lineLabel2\\n' + shaders.lineVertexShader, shaders.text2FragmentShader); \n    renderer.progLineLabel64 = new GpuProgram(gpu, '#define DSIZE 64\\n#define lineLabel2\\n' + shaders.lineVertexShader, shaders.text2FragmentShader); \n    renderer.progLineLabel96 = new GpuProgram(gpu, '#define DSIZE 96\\n#define lineLabel2\\n' + shaders.lineVertexShader, shaders.text2FragmentShader); \n    renderer.progLineLabel128 = new GpuProgram(gpu, '#define DSIZE 128\\n#define lineLabel2\\n' + shaders.lineVertexShader, shaders.text2FragmentShader); \n\n    renderer.progPolygon = new GpuProgram(gpu, shaders.polygonVertexShader, shaders.polygonFragmentShader);\n    renderer.progImage = new GpuProgram(gpu, shaders.imageVertexShader, shaders.imageFragmentShader);\n    renderer.progIcon = new GpuProgram(gpu, shaders.iconVertexShader, shaders.textFragmentShader); //label or icon\n    renderer.progIcon2 = new GpuProgram(gpu, shaders.icon2VertexShader, shaders.text2FragmentShader); //label\n\n    renderer.progLabel16 = new GpuProgram(gpu, '#define DSIZE 16\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); //label with singleBuffer\n    renderer.progLabel32 = new GpuProgram(gpu, '#define DSIZE 32\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);\n    renderer.progLabel48 = new GpuProgram(gpu, '#define DSIZE 48\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);\n    renderer.progLabel64 = new GpuProgram(gpu, '#define DSIZE 64\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);\n    renderer.progLabel96 = new GpuProgram(gpu, '#define DSIZE 96\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); \n    renderer.progLabel128 = new GpuProgram(gpu, '#define DSIZE 128\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); \n};\n\nRendererInit.prototype.initProceduralShaders = function() {\n    var shaders = GpuShaders;\n    var renderer = this.renderer;\n    var gpu = this.gpu;\n    renderer.progHmapPlane = new GpuProgram(gpu, shaders.planeVertex4Shader, shaders.planeFragmentShader2);\n    renderer.progHmapPlane2 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define grid\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane3 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define exmap\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane4 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define flat\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane5 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define normals\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane6 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define nmix\\n#define normals\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane7 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define nmix\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane8 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define exmap\\n#define classmap\\n' + shaders.planeFragmentShader2);\n}\n\nRendererInit.prototype.initHeightmap = function() {\n    var renderer = this.renderer;\n    var use16Bit = renderer.core.config.map16bitMeshes;\n    var gpu = this.gpu;\n\n    // initialize heightmap geometry\n    var meshData = RendererGeometry.buildHeightmap(5, true);\n    //renderer.heightmapMesh = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit);\n\n    meshData = RendererGeometry.buildPlane(16, true);\n    renderer.planeMesh = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit, true);\n\n    meshData = RendererGeometry.buildPlane(128, true);\n    renderer.planeMesh2 = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit, true);\n\n    // create heightmap texture\n    var size = 64;\n    var halfLineWidth = 1;\n    var data = new Uint8Array( size * size * 4 );\n\n    for (var i = 0; i < size; i++) {\n        for (var j = 0; j < size; j++) {\n\n            var index = (i*size+j)*4;\n\n            if (i < halfLineWidth || i >= size-halfLineWidth || j < halfLineWidth || j >= size-halfLineWidth) {\n                data[index] = 255;\n                data[index + 1] = 255;\n                data[index + 2] = 255;\n            } else {\n                data[index] = 32;\n                data[index + 1] = 32;\n                data[index + 2] = 32;\n            }\n\n            data[index + 3] = 255;\n        }\n    }\n\n\n    renderer.heightmapTexture = new GpuTexture(gpu);\n    renderer.heightmapTexture.createFromData(size, size, data, 'trilinear', true);\n};\n\n\nRendererInit.prototype.initHitmap = function() {\n    var renderer = this.renderer;\n    var size = renderer.hitmapSize;\n    var data = new Uint8Array( size * size * 4 );\n\n    if (renderer.hitmapMode > 2) {\n        renderer.hitmapData = data;\n    }\n\n    renderer.hitmapTexture = new GpuTexture(this.gpu);\n    renderer.hitmapTexture.createFromData(size, size, data);\n    renderer.hitmapTexture.createFramebuffer(size, size);\n\n    renderer.geoHitmapTexture = new GpuTexture(this.gpu);\n    renderer.geoHitmapTexture.createFromData(size, size, data);\n    renderer.geoHitmapTexture.createFramebuffer(size, size);\n\n    renderer.geoHitmapTexture2 = new GpuTexture(this.gpu);\n    renderer.geoHitmapTexture2.createFromData(size, size, data);\n    renderer.geoHitmapTexture2.createFramebuffer(size, size);\n};\n\n\nRendererInit.prototype.initTestMap = function() {\n    var renderer = this.renderer;\n    var gpu = this.gpu;\n\n   // create red texture\n    var size = 16, i, j, index;\n    var data = new Uint8Array( size * size * 4 );\n\n    for (i = 0; i < size; i++) {\n        for (j = 0; j < size; j++) {\n            index = (i*size+j)*4;\n            data[index] = 255;\n            data[index + 1] = 0;\n            data[index + 2] = 0;\n            data[index + 3] = 255;\n        }\n    }\n\n    renderer.redTexture = new GpuTexture(gpu);\n    renderer.redTexture.createFromData(size, size, data);\n\n    data = new Uint8Array( size * size * 4 );\n\n    for (i = 0; i < size; i++) {\n        for (j = 0; j < size; j++) {\n            index = (i*size+j)*4;\n            data[index] = 255;\n            data[index + 1] = 255;\n            data[index + 2] = 255;\n            data[index + 3] = 255;\n        }\n    }\n\n    renderer.whiteTexture = new GpuTexture(gpu);\n    renderer.whiteTexture.createFromData(size, size, data);\n\n    data = new Uint8Array( size * size * 4 );\n\n    for (i = 0; i < size; i++) {\n        for (j = 0; j < size; j++) {\n            index = (i*size+j)*4;\n            data[index] = 0;\n            data[index + 1] = 0;\n            data[index + 2] = 0;\n            data[index + 3] = 255;\n        }\n    }\n\n    renderer.blackTexture = new GpuTexture(gpu);\n    renderer.blackTexture.createFromData(size, size, data);\n};\n\n\nRendererInit.prototype.initTextMap = function() {\n    var renderer = this.renderer;\n\n    //font texture\n    var texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACACAMAAADTa0c4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRFAAAA////pdmf3QAABIFJREFUeNrsnNuyqzAIhsP7v/Se6Yxra0L4OUVNCzetVqP5DAQItrVOiLg95739NnfOaR99RDj6esBw+CKZXiMK4PiuBkAcANoHAP3J5fzzAV2jePQIt6f4Ndb/MIChlVcCEFpAACZPfN4KUAF0/ufboDW3AuBMFgBwHTCfg2ftYgDUKBuA1ABuHKvA2P+5XdONIEt7BO2o2MdlAJoTQOsV6GEAswt0Zq/bsBhdeQQkqEDMwmIAnJHzA8i3ASkWRFKBbADyLGB3mlYD6DyhA4DfBlgsBDtirUPcBgC5woStYMgVtgKATWcB6DskKUEkGFLYrGw3+l3ydR16wKbbPDlWp4Xfo9vZwR1jtOMA6GkABrdvNmt1Vluy6pyvxu4Xt62fquyTggCTsIkCoIuv8gAA08w+ATBXAdSRY56xPDFPx/VPWFZp5v65kFMPgFjP70YASMfRsDn01xLPcwkRq1HLMoK647hR8v+nId74MQBjvIbUQePra42ZVXVcBCR3mIY89mYAlNGLflqA0V1seosCQNMg80B0bsLGAIDNwvFyiqu66ngVGGMGVBwyWwIwpty2DqEr/qf0Bq+DbjYkkcr4VUoOxiRjrYn3YY5SC4BQB/cF0Lq4kD1RCJ+tN4g6Jps5zfWu+QmSz9sUABkA0BIAXocmBwCJ99MDIASATkmtLQAIft4IgE/ZDStZ59yQbOQQAGZWYMbZ3FFCAGRHnwHQznegGAE+zwxNi8kALCOgS9tzAC4jYG1Qo0myRm0Ae/z8eleqewBoZLwfUswCsbT1KgBZD6QAzAEoXUe3K+xxVf2uLf5U3nBeMPRyACW/LtrwVX989id3PRQOG5Io6vh9XwC6stHIdGdJozun03lxNlwvH4u6UgDM8/LmJyx7ak12feEebaXmUwCOYJWk1JcYKsl74HL74wAaH93NqkE1FSKXc4cv0AjaPEEPgE4ru/ieWdvzVq/4psG3AYDFHlEAioQCuEgMgPjK1VDrqlkbTABAiQBGK38B0BlBSf9xtiAJQDM4NtDqMlaeyduTtkDjHgAtEQBj5ZGK2QE0aCcMAIxLSw0WVYlGDgOQXWE+afouAM0S398O4Nej3wIQf4cIHSfz9pbWugyep4MFIAFARvspbm8BcE2DOdvWnCJQAWFhJ/hKzh4AaB2A7NxedKmLPc+6PN4cL2S8GYC1QMIEQJvmFsJfxdvkEQAoLV4AogBS8/kNvdXlWe5GKhABvQUAZASDALJffY1XfsrToFXFbvYD1gBo6wC8LR7/uvj9CwHcfWuoUJItsVl5nwWAnhxxqsXatUq0OYCcaS/fkbK61u5H8jwAuUIEZXHNL1Jmub5oSKZWiDR9FttM4HEAigqRpn8TeB2AuWNiByAXSHCGbB7/3qYCfgCgPgADEEskbjCCaJDB/+kR6wP4P1Obl8jsBwDUB4yAxqKkthaATjX0KmCtDyCxm+yIMLjCbwBgrg94FYC3h8vLPPmfAVBSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlLy9fJPgAEAvWMULbGsSjwAAAAASUVORK5CYII=';\n    renderer.textTexture2 = new GpuTexture(this.gpu, texture, this.core, null, true);\n};\n\n\nRendererInit.prototype.initImage = function() {\n    var renderer = this.renderer;\n    var gl = this.gpu.gl;\n\n    //create vertices buffer for rect\n    renderer.rectVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, renderer.rectVerticesBuffer);\n\n    var vertices = [ 0, 0, 0, 1,   1, 0, 0, 1,   2, 0, 0, 1,   3, 0, 0, 1 ];\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    renderer.rectVerticesBuffer.itemSize = 4;\n    renderer.rectVerticesBuffer.numItems = 4;\n\n    //create indices buffer for rect\n    renderer.rectIndicesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderer.rectIndicesBuffer);\n\n    var indices = [ 0, 2, 1,    0, 3, 2 ];\n\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n    renderer.rectIndicesBuffer.itemSize = 1;\n    renderer.rectIndicesBuffer.numItems = 6;\n\n    renderer.textBuff16 = new Float32Array(16 * 4);\n    renderer.textBuff32 = new Float32Array(32 * 4);\n    renderer.textBuff48 = new Float32Array(48 * 4);\n    renderer.textBuff64 = new Float32Array(64 * 4);\n\n    renderer.textQuads16 = this.generateTextQuads(16);\n    renderer.textQuads32 = this.generateTextQuads(32);\n    renderer.textQuads48 = this.generateTextQuads(48);\n    renderer.textQuads64 = this.generateTextQuads(64);\n    renderer.textQuads96 = this.generateTextQuads(96);\n    renderer.textQuads128 = this.generateTextQuads(128);\n};\n\n\nRendererInit.prototype.generateTextQuads = function(num) {\n    var renderer = this.renderer;\n    var gl = this.gpu.gl;\n\n    var buffer = new Float32Array(num * 2 * 6);\n    var index, j;\n\n    for (var i = 0; i < num; i++) {\n        index = i * 6 * 2;\n\n        j = 0;\n        buffer[index] = i;\n        buffer[index+1] = j;\n\n        j = 1;\n        buffer[index+2] = i;\n        buffer[index+3] = j;\n\n        j = 2;\n        buffer[index+4] = i;\n        buffer[index+5] = j;\n\n        j = 2;\n        buffer[index+6] = i;\n        buffer[index+7] = j;\n\n        j = 3;\n        buffer[index+8] = i;\n        buffer[index+9] = j;\n\n        j = 0;\n        buffer[index+10] = i;\n        buffer[index+11] = j;\n    }\n\n    //create vertices buffer for rect\n    var vbuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);\n\n    gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n    vbuffer.itemSize = 2;\n    vbuffer.numItems = num * 6;\n\n    return vbuffer;\n};\n\nRendererInit.prototype.initSkydome = function() {\n    var renderer = this.renderer;\n    var use16Bit = renderer.core.config.map16bitMeshes;\n    var meshData = RendererGeometry.buildSkydome(32, 64, use16Bit);\n    renderer.skydomeMesh = new GpuMesh(this.gpu, meshData, null, this.core, true, use16Bit);\n    //this.skydomeTexture = new GpuTexture(this.gpu, \"./skydome.jpg\", this.core);\n\n    meshData = RendererGeometry.buildSkydome(128, 256, use16Bit, true);\n//    var meshData = RendererGeometry.buildSkydome(256, 512);\n    renderer.atmoMesh = new GpuMesh(this.gpu, meshData, null, this.core, true, use16Bit);\n};\n\n\nRendererInit.prototype.initBBox = function() {\n    var renderer = this.renderer;\n    var gpu = this.gpu;\n    renderer.bboxMesh = new GpuBBox(gpu);\n    renderer.bboxMesh2 = new GpuBBox(gpu, true);\n};\n\n\nRendererInit.prototype.initLines = function() {\n    var gpu = this.gpu;\n    var renderer = this.renderer;\n    renderer.plineBuffer = new Float32Array(32*3);\n    renderer.plines = new GpuPixelLine3(gpu, this.core, true, 64, true, 8);\n    renderer.plineJoints = new GpuPixelLine3(gpu, this.core, false, 64, true, 8);\n\n    renderer.stencilLineState = gpu.createState({blend:true, stencil:true, culling: false});\n    renderer.lineLabelState = gpu.createState({blend:true, culling: false, zequal: true, zwrite:false});\n    renderer.labelState = gpu.createState({blend:true, culling: false, zequal: true});\n    renderer.stencilLineHitState = gpu.createState({blend:false, stencil:true, culling: false});\n    renderer.lineLabelHitState = gpu.createState({blend:false, culling: false});\n\n    renderer.polygonB1S1C1tate = gpu.createState({blend:true, stencil:true, culling: true, zequal: true});\n    renderer.polygonB1S0C1tate = gpu.createState({blend:true, stencil:false, culling: true, zequal: true});\n    renderer.polygonB1S1C0tate = gpu.createState({blend:true, stencil:true, culling: false, zequal: true});\n    renderer.polygonB1S0C0tate = gpu.createState({blend:true, stencil:false, culling: false, zequal: true});\n\n    renderer.polygonB0S1C1tate = gpu.createState({blend:false, stencil:true, culling: true, zequal: true});\n    renderer.polygonB0S0C1tate = gpu.createState({blend:false, stencil:false, culling: true, zequal: true});\n    renderer.polygonB0S1C0tate = gpu.createState({blend:false, stencil:true, culling: false, zequal: true});\n    renderer.polygonB0S0C0tate = gpu.createState({blend:false, stencil:false, culling: false, zequal: true});\n\n};\n\n\nRendererInit.prototype.initBaricentricBuffer = function() {\n    var gpu = this.gpu;\n    var buffer = new Array(65535*3);\n\n    for (var i = 0; i < 65535*3; i+=9) {\n        buffer[i] = 1.0;\n        buffer[i+1] = 0;\n        buffer[i+2] = 0;\n\n        buffer[i+3] = 0;\n        buffer[i+4] = 1.0;\n        buffer[i+5] = 0;\n\n        buffer[i+6] = 0;\n        buffer[i+7] = 0;\n        buffer[i+8] = 1.0;\n    }\n\n    var gl = gpu.gl;\n    gpu.barycentricBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, gpu.barycentricBuffer);\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer), gl.STATIC_DRAW);\n    gpu.barycentricBuffer.itemSize = 3;\n    gpu.barycentricBuffer.numItems = buffer.length / 3;\n};\n\n\nexport default RendererInit;\n","\nimport GpuTexture_ from './gpu/texture';\nimport GpuMesh_ from './gpu/mesh';\nimport GpuProgram_ from './gpu/program';\nimport {Octree as Octree_, OctreeRaycaster as OctreeRaycaster_} from './octree.js';\n\n//get rid of compiler mess\nvar GpuTexture = GpuTexture_;\nvar GpuMesh = GpuMesh_;\nvar GpuProgram = GpuProgram_;\nvar Octree = Octree_;\nvar OctreeRaycaster = OctreeRaycaster_;\n\nvar RendererInterface = function(renderer) {\n    this.renderer = renderer;\n    this.gpu = renderer.gpu;\n};\n\n\nRendererInterface.prototype.clear = function(options) {\n    if (options != null) {\n        this.gpu.clear((options['clearDepth'] || true),\n                        (options['clearColor'] || false),\n                        (options['color'] || [255,255,255,255]),\n                        ((options['depth'] != null) ? options['depth'] : 1.0) );\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.createState = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n    \n    var stateOptions = {\n        blend : (options['blend'] != null) ? options['blend'] : false,\n        stencil : (options['stencil'] != null) ? options['stencil'] : false,\n        zoffset : (options['zoffset'] != null) ? options['zoffset'] : 0,\n        zwrite : (options['zwrite'] != null) ? options['zwrite'] : true,\n        ztest : (options['ztest'] != null) ? options['ztest'] : true,\n        zequal : (options['zequal'] != null) ? options['zequal'] : true,\n        culling : (options['culling'] != null) ? options['culling'] : true\n    };\n\n    return this.gpu.createState(stateOptions);\n};\n\n\nRendererInterface.prototype.setState = function(state) {\n    if (state != null) {\n        this.gpu.setState(state);\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.createTexture = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return null;\n    }\n\n    var source = options['source'];\n    if (source == null) {\n        return null;\n    }\n\n    var filter = options['filter'] || 'linear';\n    var repeat = options['repeat'] || false, texture;\n\n    if (source instanceof Uint8Array) {\n        var width = options['width'];\n        var height = options['height'];\n\n        if (width && height) {\n            texture = new GpuTexture(this.gpu);\n            texture.createFromData(width, height, source, filter, repeat);\n            return texture;\n        }\n    }\n\n    if (source instanceof Image) {\n        texture = new GpuTexture(this.gpu);\n        texture.createFromImage(source, filter, repeat);\n        return texture;\n    }\n\n    return null;\n};\n\n\nRendererInterface.prototype.removeTexture = function(texture) {\n    if (texture) {\n        texture.kill();\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.createMesh = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return null;\n    }\n\n    var data = {\n        vertices : options['vertices'],\n        uvs : options['uvs'],\n        uvs2 : options['normals'],\n        vertexSize : options['vertexSize'],\n        uvSize : options['uvSize'],\n        uv2Size : options['normalSize'] || 3,\n        vertexAttr : options['vertexAttr'],\n        uvAttr : options['uvAttr'],\n        uv2Attr : options['normalAttr'],\n        bbox : options['bbox']\n    };\n\n    return new GpuMesh(this.gpu, data, 0, this.renderer.core);\n};\n\n\nRendererInterface.prototype.removeMesh = function(mesh) {\n    if (mesh) {\n        mesh.kill();\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.createShader = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return null;\n    }\n\n    var vertexShader = options['vertexShader'];\n    var fragmentShader = options['fragmentShader'];\n\n    if (vertexShader != null && fragmentShader) {\n        return new GpuProgram(this.gpu, vertexShader, fragmentShader);\n    }\n};\n\n\nRendererInterface.prototype.removeResource = function(resource) {\n    if (resource != null && resource.kill != null) {\n        resource.kill();\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.addJob = function(/*options*/) {\n    return this;    \n};\n\n\nRendererInterface.prototype.clearJobs = function(/*options*/) {\n    return this;    \n};\n\n\nRendererInterface.prototype.drawMesh = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (!options['mesh'] == null || !options['shaderVariables']) {\n        return this;    \n    }\n\n    //var shaderAttributes = options['shaderAttributes'];\n    var vertexAttr = options['vertex'] || 'aPosition';\n    var uvAttr = options['uv'] || 'aTexCoord';\n    var uv2Attr = options['normal'] || 'aNormal';\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n\n    var shaderVariables = options['shaderVariables'];\n    var shader = options['shader'] || 'textured';\n\n   \n    var renderer = this.renderer; \n    var mesh = options['mesh'];\n    var texture = options['texture'];\n    var mv = renderer.camera.getModelviewMatrix();\n    var proj = renderer.camera.getProjectionMatrix();\n    var fogDensity = renderer.fogDensity;\n    \n    if (typeof shader === 'string') {\n        switch(shader) {\n        case 'hit':\n\n            if (!shaderVariables['uMV']) {\n                shaderVariables['uMV'] = ['mat4', mv];\n            } \n\n            if (!shaderVariables['uProj']) {\n                shaderVariables['uProj'] = ['mat4', proj];\n            } \n\n            uvAttr = null;\n            uv2Attr = null;\n            texture = null;\n            shader = renderer.progDepthTile[0];\n            break;\n\n        case 'shaded':\n            uvAttr = null;\n\n        // eslint-disable-next-line\n        case 'textured':\n        case 'textured-and-shaded':\n\n            if (!shaderVariables['uMV']) {\n                shaderVariables['uMV'] = ['mat4', mv];\n            } \n\n            if (!shaderVariables['uProj']) {\n                shaderVariables['uProj'] = ['mat4', proj];\n            } \n\n            if (!shaderVariables['uFogDensity']) {\n                shaderVariables['uFogDensity'] = ['float', fogDensity];\n            } \n            \n            uv2Attr = (shader == 'textured') ? null : 'aNormal';\n            shader = (shader == 'textured') ? renderer.progTile[0] : ((shader == 'shaded') ? renderer.progShadedTile : renderer.progTShadedTile);\n            break;\n        }\n    }\n\n    if (!shader || !shader.isReady()) {\n        return;\n    }\n\n    var attributes = [vertexAttr];\n    if (uvAttr){\n        attributes.push(uvAttr);        \n    } \n    if (uv2Attr){\n        attributes.push(uv2Attr);        \n    } \n\n    renderer.gpu.useProgram(shader, attributes);\n\n    for (var key in shaderVariables) {\n        var item = shaderVariables[key];\n        \n        if (item.length == 2) {\n            switch(item[0]){\n            case 'floatArray':\n                shader.setFloatArray(key, item[1]);\n                break;\n            case 'float':\n                shader.setFloat(key, item[1]);\n                break;\n            case 'mat3':\n                shader.setMat3(key, item[1]);\n                break;\n            case 'mat4':\n                if (depthOffset && key == 'uProj') {\n                    shader.setMat4(key, item[1], renderer.getZoffsetFactor(depthOffset));\n                } else {\n                    shader.setMat4(key, item[1]);\n                }\n                break;\n            case 'vec2':\n                shader.setVec2(key, item[1]);\n                break;\n            case 'vec3':\n                shader.setVec3(key, item[1]);\n                break;\n            case 'vec4':\n                shader.setVec4(key, item[1]);\n                break;\n            case 'sampler':\n                shader.setSampler(key, item[1]);\n                break;\n            } \n        }\n    }\n\n    if (texture) {\n        renderer.gpu.bindTexture(texture);\n    }\n    \n    //mesh.draw(shader, vertexAttr, texture ? uvAttr : null, uv2Attr, null);\n    mesh.draw(shader, vertexAttr, uvAttr, uv2Attr, null);\n    return this;    \n};\n\n\nRendererInterface.prototype.drawImage = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (options['texture'] == null || options['rect'] == null) {\n        return this;    \n    }\n\n    var rect = options['rect'];\n    var color = options['color'] || [255,255,255,255];\n    var depth = (options['depth'] != null) ? options['depth'] : 0;\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;\n    var blend = (options['blend'] != null) ? options['blend'] : false;\n    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;\n    var useState = (options['useState'] != null) ? options['useState'] : false;\n    color = [ color[0] * (1.0/255), color[1] * (1.0/255), color[2] * (1.0/255), color[3] * (1.0/255) ];\n\n    this.renderer.draw.drawImage(rect[0], rect[1], rect[2], rect[3], options['texture'], color, depth, depthOffset, depthTest, blend, writeDepth, useState);\n    return this;    \n};\n\n\nRendererInterface.prototype.drawBillboard = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (options['texture'] == null || options['mvp'] == null) {\n        return this;    \n    }\n\n    var mvp = options['mvp'];\n    var color = options['color'] || [255,255,255,255];\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;\n    var blend = (options['blend'] != null) ? options['blend'] : false;\n    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;\n    var useState = (options['useState'] != null) ? options['useState'] : false;\n    color[0] *= 1.0/255;\n    color[1] *= 1.0/255;\n    color[2] *= 1.0/255;\n    color[3] *= 1.0/255;\n\n    this.renderer.draw.drawBillboard(mvp, options['texture'], color, depthOffset, depthTest, blend, writeDepth, useState);\n    return this;    \n};\n\n\nRendererInterface.prototype.drawLineString = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (options['points'] == null) {\n        return this;    \n    }\n\n    var points = options['points'];\n    var color = options['color'] || [255,255,255,255];\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n    var size = options['size'] || 2;\n    var screenSpace = (options['screenSpace'] != null) ? options['screenSpace'] : true;\n    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;\n    var blend = (options['blend'] != null) ? options['blend'] : false;\n    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;\n    var useState = (options['useState'] != null) ? options['useState'] : false;\n    color[0] *= 1.0/255;\n    color[1] *= 1.0/255;\n    color[2] *= 1.0/255;\n    color[3] *= 1.0/255;\n\n    this.renderer.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, blend, writeDepth, useState);\n    return this;    \n};\n\n\nRendererInterface.prototype.drawJobs = function(/*options*/) {\n    return this;    \n};\n\n\nRendererInterface.prototype.drawBBox = function(/*options*/) {\n    return this;    \n};\n\n\nRendererInterface.prototype.drawDebugText = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    var text = options['text'];\n    var coords = options['coords'];\n\n    if (!text || !coords) {\n        return this;    \n    }\n    \n    var color = options['color'] || [255,255,255,255];\n    var size = options['size'] || 16;\n    var depth = options['depth'];\n    var useState = options['useState'] || false;\n    color[0] *= 1.0/255;\n    color[1] *= 1.0/255;\n    color[2] *= 1.0/255;\n    color[3] *= 1.0/255;\n\n    var lx = this.renderer.draw.getTextSize(size, text);\n\n    this.renderer.draw.drawText(coords[0] - (lx * 0.5), coords[1], size, text, color, depth, useState);\n\n    return this;    \n};\n\n\nRendererInterface.prototype.buildOctreeFromGeometry = function(geometry) {\n    var octree = new Octree();\n    octree.buildFromGeometry(geometry);\n    return octree;\n};\n\n\nRendererInterface.prototype.raycastOctreeGeometry = function(octree, rayPos, rayDir) {\n    var raycaster = new OctreeRaycaster(), intersects = [];\n    raycaster.intersectOctree(rayPos, rayDir, octree, intersects);\n    return raycaster.intersectOctants(rayPos, rayDir, intersects);\n};\n\nRendererInterface.prototype.saveScreenshot = function(output, filename, filetype) {\n    return this.renderer.saveScreenshot(output, filename, filetype);\n};\n\n\nRendererInterface.prototype.getCanvasCoords = function(point, mvp) {\n    return this.renderer.project2(point, mvp);\n};\n\n\nRendererInterface.prototype.getCanvasSize = function() {\n    return this.renderer.curSize.slice();\n};\n\n\nRendererInterface.prototype.setConfigParams = function(params) {\n    this.renderer.setConfigParams(params);\n    return this;\n};\n\n\nRendererInterface.prototype.setConfigParam = function(key, value) {\n    this.renderer.setConfigParam(key, value);\n    return this;\n};\n\n\nRendererInterface.prototype.getConfigParam = function(key) {\n    return this.renderer.getConfigParam(key);\n};\n\n\nRendererInterface.prototype.getGLInterface = function() {\n    return {\n        canvas : this.gpu.canvas,\n        gl : this.gpu.gl\n    };\n};\n\n\nRendererInterface.prototype.setSuperElevation = function(h1, f1, h2, f2) {\n    return this.renderer.setSuperElevation(h1, f1, h2, f2);\n};\n\n\nRendererInterface.prototype.setMarginFlags = function(flags) {\n    return this.renderer.marginFlags = flags;\n};\n\n\nRendererInterface.prototype.getMarginFlags = function() {\n    return this.renderer.marginFlags;\n};\n\n\nexport default RendererInterface;\n","\nimport {vec3 as vec3_} from '../utils/matrix';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\n\n\nvar Octree = function() {\n    this.root = null;\n    this.maxItemsPerNode = 20;\n    this.maxDepth = 20;\n\n    this.depthCount = [];\n    for (var i = 0; i < 1000; i++) {\n        this.depthCount[i] = 0;\n    }\n\n    /**\n     * A binary pattern that describes the standard octant layout:\n     *\n     * ```text\n     *    3____7\n     *  2/___6/|\n     *  | 1__|_5\n     *  0/___4/\n     * ```\n     *\n     * This common layout is crucial for positional assumptions.\n     *\n     */\n\n    this.pattern = [\n        new Uint8Array([0, 0, 0]),\n        new Uint8Array([0, 0, 1]),\n        new Uint8Array([0, 1, 0]),\n        new Uint8Array([0, 1, 1]),\n\n        new Uint8Array([1, 0, 0]),\n        new Uint8Array([1, 0, 1]),\n        new Uint8Array([1, 1, 0]),\n        new Uint8Array([1, 1, 1])\n    ];\n};\n\n\nOctree.prototype.clear = function() {\n};\n\n\nOctree.prototype.buildFromGeometry = function(data) {\n    if (!data) {\n        return;\n    }\n\n    var i, li, j, lj, k, lk, v, item, submeshes, submesh, bbox, index,\n        minX, minY, minZ, maxX, maxY, maxZ, geometry, vertices;\n\n    minX = minY = minZ = Number.POSITIVE_INFINITY;\n    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;\n\n    //get gemetery bbox\n    for (i = 0, li = data.length; i < li; i++) {\n        geometry = data[i];\n        if (geometry[\"type\"] == \"mesh\") {\n            submeshes = geometry[\"submeshes\"];\n\n            for (j = 0, lj = submeshes.length; j < lj; j++) {\n                submesh = submeshes[j];\n                bbox = submesh[\"bbox\"];\n                \n                if (bbox[0][0] < minX) minX = bbox[0][0];\n                if (bbox[0][1] < minY) minY = bbox[0][1];\n                if (bbox[0][2] < minZ) minZ = bbox[0][2];\n\n                if (bbox[1][0] > maxX) maxX = bbox[1][0];\n                if (bbox[1][1] > maxY) maxY = bbox[1][1];\n                if (bbox[1][2] > maxZ) maxZ = bbox[1][2];\n            }\n        }\n    }\n\n    this.root = new OctreeNode([minX, minY, minZ], [maxX, maxY, maxZ]);\n\n    //get gemetery bbox\n    for (i = 0, li = data.length; i < li; i++) {\n        geometry = data[i];\n        if (geometry[\"type\"] == \"mesh\") {\n            submeshes = geometry[\"submeshes\"];\n\n            for (j = 0, lj = submeshes.length; j < lj; j++) {\n                submesh = submeshes[j];\n\n                vertices = submesh[\"vertices\"];\n\n                for (k = 0, lk = vertices.length; k < lk; k += 9) {\n\n                    minX = minY = minZ = Number.POSITIVE_INFINITY;\n                    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;\n\n                    for (v = 0; v < 3; v ++) {\n                        index = k + v * 3;\n\n                        if (vertices[index] < minX) minX = vertices[index];\n                        if (vertices[index+1] < minY) minY = vertices[index+1];\n                        if (vertices[index+2] < minZ) minZ = vertices[index+2];\n\n                        if (vertices[index] > maxX) maxX = vertices[index];\n                        if (vertices[index+1] > maxY) maxY = vertices[index+1];\n                        if (vertices[index+2] > maxZ) maxZ = vertices[index+2];\n                    }\n\n                    //this.root.add([minX, minY, minZ], [maxX, maxY, maxZ], [vertices, k])\n                    this.root.add([minX, minY, minZ, maxX, maxY, maxZ, vertices, k], this)\n                }\n\n            }\n        }\n    }\n\n\n};\n\n\nvar OctreeNode = function(min, max) {\n    this.min = min;\n    this.max = max;\n    this.children = null;\n    this.items = null;\n};\n\nOctreeNode.prototype.add = function(item, octree, depth) {\n    if (this.children) {\n        if (!depth) {\n            depth = 0; \n        }\n\n        for (var i = 0; i < 8; i++) {\n            var child = this.children[i],\n                min = child.min,\n                max = child.max;\n\n            if (item[0] < max[0] && item[3] > min[0] &&\n                item[1] < max[1] && item[4] > min[1] &&\n                item[2] < max[2] && item[5] > min[2]) {\n\n                //collision detected, add item\n                child.add(item, octree, depth + 1);\n            }\n        }\n\n        return;\n    }\n\n    if (!this.items) {\n        this.items = [];\n    }\n\n    this.items.push(item);\n\n    if (depth < octree.maxDepth && this.items.length >= octree.maxItemsPerNode) {\n        this.split(octree, depth + 1);\n    }\n};\n\nOctreeNode.prototype.split = function(octree, depth) {\n    var min = this.min,\n        max = this.max,\n        mid = [(max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5],\n        i, li, j;\n\n    this.children = [\n        null, null,\n        null, null,\n        null, null,\n        null, null\n    ];\n\n    this.depthCount[depth]++;\n\n    for (i = 0; i < 8; i++) {\n        var combination = octree.pattern[i];\n\n        this.children[i] = new OctreeNode(\n            [\n                (combination[0] === 0) ? min[0] : mid[0],\n                (combination[1] === 0) ? min[1] : mid[1],\n                (combination[2] === 0) ? min[2] : mid[2]\n            ],\n\n            [\n                (combination[0] === 0) ? mid[0] : max[0],\n                (combination[1] === 0) ? mid[1] : max[1],\n                (combination[2] === 0) ? mid[2] : max[2]\n            ]\n        );\n    }\n\n    var items = this.items;\n\n    //distribute items\n    if (items) {\n        for (i = 0, li = items.length; i < li; i++) {\n            var item = items[i];\n\n            for (j = 0; j < 8; j++) {\n                var child = this.children[j];\n                min = child.min;\n                max = child.max;\n\n                if (item[0] < max[0] && item[3] > min[0] &&\n                    item[1] < max[1] && item[4] > min[1] &&\n                    item[2] < max[2] && item[5] > min[2]) {\n\n                    //collision detected, add item\n                    child.add(item, octree);\n                }\n            }\n        }\n    }\n\n    this.items = null;   \n};\n\n\nvar OctreeRaycaster = function() {\n\n    // A lookup-table containing octant ids. Used to determine the exit plane from an octant.\n    this.octantTable = [\n        new Uint8Array([4, 2, 1]),\n        new Uint8Array([5, 3, 8]),\n        new Uint8Array([6, 8, 3]),\n        new Uint8Array([7, 8, 8]),\n        new Uint8Array([8, 6, 5]),\n        new Uint8Array([8, 7, 8]),\n        new Uint8Array([8, 8, 7]),\n        new Uint8Array([8, 8, 8])\n    ];\n\n    // A byte that stores raycasting flags.\n    this.flags = 0;\n};\n\n\n/**\n * Finds the entry plane of the first octant that a ray travels through.\n *\n * Determining the first octant requires knowing which of the t0s is the\n * largest. The tms of the other axes must also be compared against that\n * largest t0.\n * \n * tx0, ty0,tz0 - Ray projection parameter.\n * txm, tym, tzm - Ray projection parameter mean.\n * returns - index of the first octant that the ray travels through.\n */\n\nOctreeRaycaster.prototype.findEntryOctant = function(tx0, ty0, tz0, txm, tym, tzm) {\n    var entry = 0;\n\n    // Find the entry plane.\n    if(tx0 > ty0 && tx0 > tz0) {\n\n        // YZ-plane.\n        if (tym < tx0) {\n            entry |= 2;\n        }\n\n        if (tzm < tx0) {\n            entry |= 1;\n        }\n\n    } else if (ty0 > tz0) {\n\n        // XZ-plane.\n        if (txm < ty0) {\n            entry |= 4;\n        }\n\n        if (tzm < ty0) {\n            entry |= 1;\n        }\n\n    } else {\n\n        // XY-plane.\n        if (txm < tz0) {\n            entry |= 4;\n        }\n\n        if (tym < tz0) {\n            entry |= 2;\n        }\n    }\n\n    return entry;\n}\n\n/**\n * Finds the next octant that intersects with the ray based on the exit plane of\n * the current one.\n *\n * urrentOctant - The index of the current octant.\n * tx1, ty1, tz1 - Ray projection parameter.\n * returns - index of the next octant that the ray travels through.\n */\n\nOctreeRaycaster.prototype.findNextOctant = function(currentOctant, tx1, ty1, tz1) {\n    var min;\n    var exit = 0;\n\n    // Find the exit plane.\n    if (tx1 < ty1) {\n        min = tx1;\n        exit = 0; // YZ-plane.\n    } else {\n        min = ty1;\n        exit = 1; // XZ-plane.\n    }\n\n    if (tz1 < min) {\n        exit = 2; // XY-plane.\n    }\n\n    return this.octantTable[currentOctant][exit];\n}\n\n/**\n * Finds all octants that intersect with the given ray.\n *\n * octant - The current octant.\n * tx0 - Ray projection parameter. Initial tx0 = (minX - rayOriginX) / rayDirectionX.\n * ty0 - Ray projection parameter. Initial ty0 = (minY - rayOriginY) / rayDirectionY.\n * tz0 - Ray projection parameter. Initial tz0 = (minZ - rayOriginZ) / rayDirectionZ.\n * tx1 - Ray projection parameter. Initial tx1 = (maxX - rayOriginX) / rayDirectionX.\n * ty1 - Ray projection parameter. Initial ty1 = (maxY - rayOriginY) / rayDirectionY.\n * tz1 - Ray projection parameter. Initial tz1 = (maxZ - rayOriginZ) / rayDirectionZ.\n * intersects - An array to be filled with the intersecting octants.\n * returns\n */\n\nOctreeRaycaster.prototype.raycastOctant = function(octant, tx0, ty0, tz0, tx1, ty1, tz1, intersects) {\n    var children = octant.children;\n    var currentOctant;\n    var txm, tym, tzm;\n\n    if (tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {\n\n        if (!children) {\n\n            // Leaf.\n            if (octant.items) {\n                intersects.push(octant);\n            }\n\n        } else {\n\n            // Compute means.\n            txm = 0.5 * (tx0 + tx1);\n            tym = 0.5 * (ty0 + ty1);\n            tzm = 0.5 * (tz0 + tz1);\n\n            currentOctant = this.findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);\n\n            do {\n\n                /* The possibilities for the next node are passed in the same respective\n                 * order as the t-values. Hence, if the first value is found to be the\n                 * greatest, the fourth one will be returned. If the second value is the\n                 * greatest, the fifth one will be returned, etc.\n                 */\n\n                switch(currentOctant) {\n\n                    case 0:\n                        this.raycastOctant(children[this.flags], tx0, ty0, tz0, txm, tym, tzm, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, txm, tym, tzm);\n                        break;\n\n                    case 1:\n                        this.raycastOctant(children[this.flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, txm, tym, tz1);\n                        break;\n\n                    case 2:\n                        this.raycastOctant(children[this.flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, txm, ty1, tzm);\n                        break;\n\n                    case 3:\n                        this.raycastOctant(children[this.flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, txm, ty1, tz1);\n                        break;\n\n                    case 4:\n                        this.raycastOctant(children[this.flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, tx1, tym, tzm);\n                        break;\n\n                    case 5:\n                        this.raycastOctant(children[this.flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, tx1, tym, tz1);\n                        break;\n\n                    case 6:\n                        this.raycastOctant(children[this.flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, tx1, ty1, tzm);\n                        break;\n\n                    case 7:\n                        this.raycastOctant(children[this.flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, intersects);\n                        // Far top right octant. No other octants can be reached from here.\n                        currentOctant = 8;\n                        break;\n\n                }\n\n            } while(currentOctant < 8);\n\n        }\n\n    }\n\n}\n\nOctreeRaycaster.prototype.hitFace = function(origin, dir, index, vertices) {\n    var EPSILON = 0.0000001,\n        v1 = [vertices[index], vertices[index+1], vertices[index+2]],\n        v2 = [vertices[index+3], vertices[index+4], vertices[index+5]],\n        v3 = [vertices[index+6], vertices[index+7], vertices[index+8]];\n\n    var h = [0,0,0], q = [0,0,0], s, a, f, u, v,\n        edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]],\n        edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];\n\n    vec3.cross(dir, edge2, h);\n    a = vec3.dot(edge1, h);\n\n    if (a > -EPSILON && a < EPSILON) {\n        return [false];\n    }\n\n    f = 1/a;\n    s = [origin[0] - v1[0], origin[1] - v1[1], origin[2] - v1[2]];\n    u = f * (vec3.dot(s, h));\n\n    if (u < 0.0 || u > 1.0) {\n        return [false];\n    }\n\n    q = vec3.cross(s, edge1);\n    v = f * vec3.dot(dir, q);\n    if (v < 0.0 || u + v > 1.0) {\n        return [false];\n    }\n\n    // At this stage we can compute t to find out where the intersection point is on the line.\n    var t = f * vec3.dot(edge2, q);\n    //if (t > EPSILON) { // ray intersection\n        return [true, t]; //[origin[0] + dir[0] * t, origin[1] + dir[1] * t, origin[2] + dir[2] * t ]];\n    //} else { // This means that there is a line intersection but not a ray intersection.\n     //   return [false];\n    //}\n};\n\n\n/**\n * Finds the octants that intersect with the given ray. The intersecting\n * octants are sorted by distance, closest first.\n *\n * octree - An octree.\n * intersects - A list to be filled with intersecting octants.\n */\n\n// https://github.com/vanruesc/sparse-octree/blob/master/src/core/OctreeRaycaster.js\n\nOctreeRaycaster.prototype.intersectOctree = function(rayPos, rayDir, octree, intersects) {\n    // Translate the octree extents to the scene origin.\n    var min = [0,0,0];\n    var max = [octree.root.max[0] - octree.root.min[0],\n               octree.root.max[1] - octree.root.min[1],\n               octree.root.max[2] - octree.root.min[2]] \n\n    var dimensions = [max[0], max[1], max[2]];\n    var halfDimensions = [dimensions[0]*0.5, dimensions[1]*0.5, dimensions[2]*0.5];\n\n    var origin = [rayPos[0],rayPos[1],rayPos[2]];\n    var direction = [rayDir[0], rayDir[1], rayDir[2]];\n\n    var invDirX, invDirY, invDirZ;\n    var tx0, tx1, ty0, ty1, tz0, tz1;\n\n    var center = [(octree.root.max[0] + octree.root.min[0]) * 0.5,\n                  (octree.root.max[1] + octree.root.min[1]) * 0.5,\n                  (octree.root.max[2] + octree.root.min[2]) * 0.5] \n\n    // Translate the ray to the center of the octree.\n    //origin.sub(octree.getCenter(v[2])).add(halfDimensions);\n    origin[0] = (origin[0] - center[0]) + halfDimensions[0]; \n    origin[1] = (origin[1] - center[1]) + halfDimensions[1]; \n    origin[2] = (origin[2] - center[2]) + halfDimensions[2]; \n\n    // Reset all flags.\n    this.flags = 0;\n\n    // Handle rays with negative directions.\n    if (direction[0] < 0.0) {\n        origin[0] = dimensions[0] - origin[0];\n        direction[0] = -direction[0];\n        this.flags |= 4;\n    }\n\n    if (direction[1] < 0.0) {\n        origin[1] = dimensions[1] - origin[1];\n        direction[1] = -direction[1];\n        this.flags |= 2;\n    }\n\n    if (direction[2] < 0.0) {\n        origin[2] = dimensions[2] - origin[2];\n        direction[2] = -direction[2];\n        this.flags |= 1;\n    }\n\n    // Improve IEEE double stability.\n    invDirX = 1.0 / direction[0];\n    invDirY = 1.0 / direction[1];\n    invDirZ = 1.0 / direction[2];\n\n    // Project the ray to the root's boundaries.\n    tx0 = (min[0] - origin[0]) * invDirX;\n    tx1 = (max[0] - origin[0]) * invDirX;\n    ty0 = (min[1] - origin[1]) * invDirY;\n    ty1 = (max[1] - origin[1]) * invDirY;\n    tz0 = (min[2] - origin[2]) * invDirZ;\n    tz1 = (max[2] - origin[2]) * invDirZ;\n\n    // Check if the ray hits the octree.\n    if (Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {\n        // Find the intersecting octants.\n        this.raycastOctant(octree.root, tx0, ty0, tz0, tx1, ty1, tz1, intersects);\n    }\n};\n\nOctreeRaycaster.prototype.intersectOctants = function(rayPos, rayDir, octants) {\n    var hits = [];\n    var t = Number.POSITIVE_INFINITY;\n\n    for (var i = 0, li = octants.length; i < li; i++) {\n        var items = octants[i].items;\n\n        for (var j = 0, lj = items.length; j < lj; j++) {\n            var item = items[j];\n            var res = this.hitFace(rayPos, rayDir, item[7], item[6]);\n\n            if (res[0] && res[1] < t) {\n                t = res[1];\n            }\n        }\n    }\n\n    if (t !== Number.POSITIVE_INFINITY) {\n        hits = [t];\n    }\n\n    return hits;\n};\n\nexport {Octree, OctreeRaycaster};\n","\nimport {vec3 as vec3_, mat4 as mat4_} from '../utils/matrix';\nimport GpuDevice_ from './gpu/device';\nimport GpuTexture_ from './gpu/texture';\nimport GpuFont_ from './gpu/font';\nimport Camera_ from './camera';\nimport RenderInit_ from './init';\nimport RenderDraw_ from './draw';\nimport RenderRMap_ from './rmap';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat4 = mat4_;\nvar GpuDevice = GpuDevice_;\nvar GpuTexture = GpuTexture_;\nvar GpuFont = GpuFont_;\nvar Camera = Camera_;\nvar RenderInit = RenderInit_;\nvar RenderDraw = RenderDraw_;\nvar RenderRMap = RenderRMap_;\n\nvar Renderer = function(core, div, onUpdate, onResize, config) {\n    this.config = config || {};\n    this.core = core;\n    this.marginFlags = 0;\n    this.progTile = null;\n    this.progHeightmap = null;\n    this.progSkydome = null;\n    this.progWireframeTile = null;\n    this.progWireframeTile2 = null;\n    this.progText = null;\n    this.div = div;\n    this.onUpdate = onUpdate;\n    this.killed = false;\n    this.onlyDepth = false;\n    this.onlyLayers = false;\n    this.onlyHitLayers = false;\n    this.onlyAdvancedHitLayers = false;\n    this.advancedPassNeeded = false;\n    this.hitmapCounter = 0;\n    this.geoRenderCounter = 0;\n    this.geoHitmapCounter = 0;\n    this.frameTime = 0;\n    this.geometries = {};\n    this.clearStencilPasses = [];\n    this.onResizeCall = onResize;\n    //this.math = Math;\n    this.stencilLineState = null;\n    this.drawLabelBoxes = false;\n    this.drawGridCells = false;\n    this.drawAllLabels = false;\n    this.debug = {};\n    this.mapHack = null;\n\n    this.geodataSelection = [];\n    this.hoverFeatureCounter = 0;\n    this.hoverFeatureList = [];\n\n    this.touchSurfaceEvent = [];\n\n    var rect = this.div.getBoundingClientRect();\n\n    this.winSize = [rect.width, rect.height]; //QSize\n    this.curSize = [rect.width, rect.height]; //QSize\n    this.oldSize = [rect.width, rect.height]; //QSize\n    this.dirty = true;\n    this.cameraVector = [0,1,0];\n    this.viewExtent = 1;\n    //this.texelSizeLimit = this.core.mapConfig.texelSize * texelSizeFactor;\n\n    this.gpu = new GpuDevice(this, div, this.curSize, this.config.rendererAllowScreenshots, this.config.rendererAntialiasing, this.config.rendererAnisotropic);\n    this.camera = new Camera(this, 45, 2, 1200000.0);\n\n    //reduce garbage collection\n    this.drawTileMatrix = mat4.create();\n    this.drawTileMatrix2 = mat4.create();\n    this.drawTileVec = [0,0,0];\n    this.drawTileWorldMatrix = mat4.create();\n    this.pixelTileSizeMatrix = mat4.create();\n\n    this.heightmapMesh = null;\n    this.heightmapTexture = null;\n\n    this.skydomeMesh = null;\n    this.skydomeTexture = null;\n\n    this.hitmapTexture = null;\n    this.geoHitmapTexture = null;\n    this.hitmapSize = this.config.mapDMapSize;\n    this.hitmapMode = this.config.mapDMapMode;\n    this.updateHitmap = true;\n    this.updateGeoHitmap = true;\n\n    this.redTexture = null;\n\n    this.rectVerticesBuffer = null;\n    this.rectIndicesBuffer = null;\n    this.imageProjectionMatrix = null;\n\n    this.font = null;\n    this.fonts = {};\n    this.fogDensity = 0;\n\n    this.gmap = new Array(2048);\n    this.gmap2 = new Array(2048);\n    this.gmap3 = new Array(10000);\n    this.gmap3Size = new Array(10000);\n    this.gmap4 = new Array(10000);\n    this.gmapIndex = 0;\n    this.gmapTop = new Array(512);\n    this.gmapHit = new Array(512);\n    this.gmapStore = new Array(512);\n    this.fmaxDist = 0;\n    this.fminDist = 0;\n\n    this.jobZBuffer = new Array(512);\n    this.jobZBufferSize = new Array(512);\n\n    this.jobZBuffer2 = new Array(512);\n    this.jobZBuffer2Size = new Array(512);\n    \n    this.jobHBuffer = {};\n    this.jobHBufferSize = 0;\n    this.jobHSortBuffer = new Array(2048);\n\n\n    for (var i = 0, li = this.jobZBuffer.length; i < li; i++) {\n        this.jobZBuffer[i] = [];\n        this.jobZBufferSize[i] = 0;\n        this.jobZBuffer2[i] = {};\n        this.jobZBuffer2Size[i] = 0;\n    }\n\n    for (i = 0, li = this.gmap3.length; i < li; i++) {\n        this.gmap3[i] = [];\n        this.gmap3Size[i] = 0;\n    }\n\n    this.radixCountBuffer16 = new Uint16Array(256*4);\n    this.radixCountBuffer32 = new Uint32Array(256*4);\n    //this.radixOutputBufferUint32 = new Uint32Array(256*256);\n    //this.radixOutputBufferFloat32 = new Uint32Array(256*256);\n\n    this.buffFloat32 = new Float32Array(1);\n    this.buffUint32 = new Uint32Array(this.buffFloat32.buffer);\n\n    this.layerGroupVisible = [];\n    this.bitmaps = {};\n    \n    this.cameraPosition = [0,0,0];\n    this.cameraOrientation = [0,0,0];\n    this.cameraTiltFator = 1;\n    this.cameraViewExtent = 1;\n    this.distanceFactor = 1;\n    this.tiltFactor = 1;\n    this.localViewExtentFactor = 1;\n    this.cameraVector = [0,0,0];\n    this.labelVector = [0,0,0];\n    this.drawnGeodataTiles = 0;\n    this.drawnGeodataTilesFactor = 0;\n    this.drawnGeodataTilesUsed = false;\n    this.progMap = {};\n    this.gridHmax = 0;\n    this.gridHmin = 0;\n    this.seCounter = 0;\n\n    //hack for vts maps\n    //this.vtsHack = true;\n    //this.vtsHack = false;\n\n    //reduce garbage collection\n    this.updateCameraMatrix = mat4.create();\n\n    this.seTmpVec = [0,0,0];\n    this.seTmpVec2 = [0,0,0];\n    this.seTmpVec3 = [0,0,0];\n\n    //debug\n    this.lastHitPosition = [0,0,100];\n    this.logTilePos = null;\n    this.setSuperElevation(0,2,4000,1.5);\n\n    window.addEventListener('resize', (this.onResize).bind(this), false);\n\n    this.gpu.init();\n\n    //intit resources\n    // eslint-disable-next-line\n    this.init = new RenderInit(this);\n    this.rmap = new RenderRMap(this, 50);\n    this.draw = new RenderDraw(this);\n\n    var factor = 1;\n    this.resizeGL(Math.floor(this.curSize[0]*factor), Math.floor(this.curSize[1]*factor));\n};\n\nRenderer.prototype.initProceduralShaders = function() {\n    this.init.initProceduralShaders();\n};\n\n\nRenderer.prototype.onResize = function() {\n    if (this.killed){\n        return;\n    }\n\n    var rect = this.div.getBoundingClientRect();\n    this.resizeGL(Math.floor(rect.width), Math.floor(rect.height));\n    \n    if (this.onResizeCall) {\n        this.onResizeCall();\n    }\n};\n\n\nRenderer.prototype.kill = function() {\n    if (this.killed){\n        return;\n    }\n\n    this.killed = true;\n\n    if (this.heightmapMesh) this.heightmapMesh.kill();\n    if (this.heightmapTexture) this.heightmapTexture.kill();\n    if (this.skydomeMesh) this.skydomeMesh.kill();\n    if (this.skydomeTexture) this.skydomeTexture.kill();\n    if (this.hitmapTexture) this.hitmapTexture.kill();\n    if (this.geoHitmapTexture) this.geoHitmapTexture.kill();\n    if (this.redTexture) this.redTexture.kill();\n    if (this.whiteTexture) this.whiteTexture.kill();\n    if (this.blackTexture) this.blackTexture.kill();\n    if (this.lineTexture) this.lineTexture.kill();\n    if (this.textTexture2) this.textTexture2.kill();\n    if (this.atmoMesh) this.atmoMesh.kill();\n    if (this.bboxMesh) this.bboxMesh.kill();\n    if (this.font) this.font.kill();\n    if (this.plines) this.plines.kill();\n    if (this.plineJoints) this.plineJoints.kill();\n \n    this.gpu.kill();\n    //this.div.removeChild(this.gpu.getCanvas());\n};\n\n\nRenderer.prototype.resizeGL = function(width, height, skipCanvas, skipPaint) {\n    this.camera.setAspect(width / height);\n    this.curSize = [width, height];\n    this.oldSize = [width, height];\n    this.gpu.resize(this.curSize, skipCanvas);\n\n    //if (skipPaint !== true) { //remove this??\n       // this.draw.paintGL();\n    //}\n\n    var m = new Float32Array(16);\n    m[0] = 2.0/width; m[1] = 0; m[2] = 0; m[3] = 0;\n    m[4] = 0; m[5] = -2.0/height; m[6] = 0; m[7] = 0;\n    m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;\n    m[12] = -width*0.5*m[0]; m[13] = -height*0.5*m[5]; m[14] = 0; m[15] = 1;\n\n    this.imageProjectionMatrix = m;\n};\n\n\nRenderer.prototype.project2 = function(point, mvp, cameraPos, includeDistance) {\n    var p = [0, 0, 0, 1];\n\n    if (cameraPos) {\n        p = mat4.multiplyVec4(mvp, [point[0] - cameraPos[0], point[1] - cameraPos[1], point[2] - cameraPos[2], 1 ]);\n    } else {\n        p = mat4.multiplyVec4(mvp, [point[0], point[1], point[2], 1 ]);\n    }\n\n    //project point coords to screen\n    if (p[3] != 0) {\n        var sp = [0,0,0];\n\n        //x and y are in screen pixels\n        sp[0] = ((p[0]/p[3])+1.0)*0.5*this.curSize[0];\n        sp[1] = (-(p[1]/p[3])+1.0)*0.5*this.curSize[1];\n\n        //depth in meters\n        sp[2] = p[2]/p[3];\n\n        if (includeDistance) {\n            sp[3] = p[2];\n        }\n\n        return sp;\n    } else {\n        return [0, 0, 0];\n    }\n};\n\n\nRenderer.prototype.setSuperElevationState = function(state) {\n    if (this.useSuperElevation != state) {\n        this.useSuperElevation = state;\n        this.seCounter++;\n    }\n};\n\n\nRenderer.prototype.getSuperElevationState = function() {\n    return this.useSuperElevation;\n};\n\n\nRenderer.prototype.setSuperElevation = function(h1, f1, h2, f2) {\n    if (f1 == 1 && f2 == 1) {\n        if (this.useSuperElevation != false) {\n            this.useSuperElevation = false;\n            this.seCounter++;\n        }\n\n        if (h1 == h2) { h2 = h1 + 1; }\n        this.superElevation = [h1, f1, h2, f2, h2-h1, f2-f1, 1.0 / (h2-h1)];\n        return;\n    }\n\n    if (h1 == h2) { h2 = h1 + 1; }\n    this.superElevation = [h1, f1, h2, f2, h2-h1, f2-f1, 1.0 / (h2-h1)];\n    this.seCounter++;\n};\n\n\nRenderer.prototype.getSuperElevation = function() {\n    return this.superElevation.slice();\n};\n\n\nRenderer.prototype.getSuperElevatedHeight = function(height) {\n    var se = this.superElevation, h = height;\n\n    if (h < se[0]) {  // 0 - h1, 1 - f1, 2 - h2, 3 - f2, 4 - dh, 5 - df, 6 - invdh\n        h = se[0];\n    }\n\n    if (h > se[2]) {\n        h = se[2];\n    }\n\n    return height * (se[1] + ((h - se[0]) * se[6]) * se[5]);\n};\n\nRenderer.prototype.getUnsuperElevatedHeight = function(height) {\n    var se = this.superElevation, s = height;\n\n    if (se[1] == se[3]) {\n        return s / se[1];\n    }\n\n    if (s <= se[0] * se[1]) {  // 0 - h1, 1 - f1, 2 - h2, 3 - f2, 4 - dh, 5 - df, 6 - invdh\n        return s / se[1];\n    }\n\n    if (s >= se[2] * se[3]) {\n        return s / se[3];\n    }\n\n\n    var h1 = se[0], f1 = se[1], h2 = se[2], f2 = se[3];\n\n    // and f1!=f2 and h1!=h2\n\n    return -(Math.sqrt(-2*f2*(f1*h1*h2 + 2*h1*s - 2*h2*s) + f1*(f1*h2*h2 + 4*h1*s - 4*h2*s) + f2*f2*h1*h1) - f1*h2 + f2*h1)/(2*(f1 - f2));\n};\n\n\nRenderer.prototype.getEllipsoidHeight = function(pos, shift) {\n    var p, p2;\n    this.seTmpVec3 = [0,0,0];\n\n    if (shift) {\n        p = this.seTmpVec;\n        p2 = [pos[0] + shift[0], pos[1] + shift[1], (pos[2] + shift[2]) * this.earthERatio];\n    } else {\n        p = pos;\n        p2 = [p[0], p[1], p[2] * this.earthERatio];\n    }\n\n    var l = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);\n\n    return l - this.earthRadius;\n};\n\n\nRenderer.prototype.transformPointBySE = function(pos, shift) {\n    var p = pos, p2;\n    this.seTmpVec3 = [0,0,0];\n\n    if (shift) {\n        p2 = [pos[0] + shift[0], pos[1] + shift[1], (pos[2] + shift[2]) * this.earthERatio];\n    } else {\n        p2 = [p[0], p[1], p[2] * this.earthERatio];\n    }\n\n    var l = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);\n    var v = this.seTmpVec2;\n\n    var m = (1.0/(l+0.0001));\n    v[0] = p2[0] * m;\n    v[1] = p2[1] * m;\n    v[2] = p2[2] * m;\n\n    var h = l - this.earthRadius;\n    var h2 = this.getSuperElevatedHeight(h);\n    m = (h2 - h);\n\n    p2[0] = p[0] + v[0] * m;\n    p2[1] = p[1] + v[1] * m;\n    p2[2] = p[2] + v[2] * m;\n\n    return p2;\n};\n\n\nRenderer.prototype.transformPointBySE2 = function(pos, shift) {\n    var p = pos, p2;\n    this.seTmpVec3 = [0,0,0];\n\n    if (shift) {\n        p2 = [pos[0] + shift[0], pos[1] + shift[1], (pos[2] + shift[2]) * this.earthERatio];\n    } else {\n        p2 = [p[0], p[1], p[2] * this.earthERatio];\n    }\n\n    var l = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);\n    var v = this.seTmpVec2;\n\n    var m = (1.0/(l+0.0001));\n    v[0] = p2[0] * m;\n    v[1] = p2[1] * m;\n    v[2] = p2[2] * m;\n\n    var h = l - this.earthRadius;\n    var h2 = this.getSuperElevatedHeight(h);\n    m = (h2 - h);// * 10;\n\n    pos = pos.slice();\n\n    pos[0] = p[0] + v[0] * m;\n    pos[1] = p[1] + v[1] * m;\n    pos[2] = p[2] + v[2] * m;\n\n    pos[13] = v[0] * m;\n    pos[14] = v[1] * m;\n    pos[15] = v[2] * m;\n\n    return pos;\n};\n\n\nRenderer.prototype.project = function(point) {\n    //get mode-view-projection matrix\n    var mvp = this.camera.getMvpMatrix();\n\n    //get camera position relative to position\n    var cameraPos2 = this.camera.getPosition();\n\n    //get global camera position\n    var cameraPos = this.cameraPosition();\n\n    //get point coords relative to camera\n    var p = [point[0] - cameraPos[0] + cameraPos2[0], point[1] - cameraPos[1] + cameraPos2[1], point[2] - cameraPos[2] + cameraPos2[2], 1 ];\n\n    //project point coords to screen\n    var p2 = [0, 0, 0, 1];\n    p2 = mat4.multiplyVec4(mvp, p);\n\n    if (p2[3] != 0) {\n\n        var sp = [0,0,0];\n\n        //x and y are in screen pixels\n        sp[0] = ((p2[0]/p2[3])+1.0)*0.5*this.curSize[0];\n        sp[1] = (-(p2[1]/p2[3])+1.0)*0.5*this.curSize[1];\n\n        //depth in meters\n        sp[2] = p2[2]/p2[3];\n\n        return sp;\n    } else {\n        return [0, 0, 0];\n    }\n};\n\n\nRenderer.prototype.getScreenRay = function(screenX, screenY) {\n    if (this.camera == null) {\n        return [0,0,1.0];\n    }\n\n    this.camera.dirty = true; //???? why is projection matrix distored so I have to refresh\n\n    //convert screen coords\n    var x = (2.0 * screenX) / this.curSize[0] - 1.0;\n    var y = 1.0 - (2.0 * screenY) / this.curSize[1];\n    \n    var rayNormalizeDeviceSpace = [x, y, 1.0];\n\n    var rayClipCoords = [rayNormalizeDeviceSpace[0], rayNormalizeDeviceSpace[1], -1.0, 1.0];\n\n    var invProjection = mat4.create();\n    invProjection = mat4.inverse(this.camera.getProjectionMatrix());\n\n    //console.log(\"--\" + JSON.stringify(rayClipCoords));\n    //console.log(\"----\" + JSON.stringify(invProjection));\n\n    var rayEye = [0,0,0,0];\n    mat4.multiplyVec4(invProjection, rayClipCoords, rayEye); //inverse (projectionmatrix) * rayClipCoords;\n    rayEye[2] = -1.0;\n    rayEye[3] = 0.0;\n\n    var invView = mat4.create();\n    invView = mat4.inverse(this.camera.getModelviewMatrix());\n\n    var rayWorld = [0,0,0,0];\n    mat4.multiplyVec4(invView, rayEye, rayWorld); //inverse (projectionmatrix) * rayClipCoords;\n\n    // don't forget to normalise the vector at some point\n    rayWorld = vec3.normalize([rayWorld[0], rayWorld[1], rayWorld[2]]); //normalise (raywor);\n\n    return rayWorld;\n};\n\n\nRenderer.prototype.hitTestGeoLayers = function(screenX, screenY, secondTexture) {\n    var gl = this.gpu.gl;\n\n    //probably not needed\n    //if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {\n      //  return [false, 0,0,0,0];\n    //}\n\n    var surfaceHit = false, pixel;\n\n    if (screenX >= 0 && screenX < this.curSize[0] &&\n        screenY >= 0 && screenY < this.curSize[1]) {\n\n        //convert screen coords to texture coords\n        var x = 0, y = 0;\n\n        //get screen coords\n        x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));\n        y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));\n\n        //get pixel value from framebuffer\n\n        if (secondTexture) {\n            pixel = this.geoHitmapTexture2.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);\n        } else {\n            pixel = this.geoHitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);\n        }\n\n        surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);\n    }\n\n    if (surfaceHit) {\n        return [true, pixel[0], pixel[1], pixel[2], pixel[3]];\n    } \n\n    return [false, 0,0,0,0];\n};\n\n\nRenderer.prototype.switchToFramebuffer = function(type, texture) {\n    var gl = this.gpu.gl, size, width, height;\n    \n    switch(type) {\n    case 'base':\n        width = this.oldSize[0];\n        height = this.oldSize[1];\n    \n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    \n        gl.viewport(0, 0, width, height);\n        this.gpu.setFramebuffer(null);\n    \n        this.camera.setAspect(width / height);\n        this.curSize = [width, height];\n        this.gpu.resize(this.curSize, true);\n        this.camera.update();\n            //this.updateCamera();\n        this.onlyDepth = false;\n        this.onlyHitLayers = false;\n        this.onlyAdvancedHitLayers = false;\n        this.advancedPassNeeded = false;\n        break;\n\n    case 'depth':\n        //set texture framebuffer\n        this.gpu.setFramebuffer(this.hitmapTexture);\n\n        this.oldSize = [ this.curSize[0], this.curSize[1] ];\n   \n        gl.clearColor(1.0,1.0, 1.0, 1.0);\n        gl.enable(gl.DEPTH_TEST);\n\n        size = this.hitmapSize;\n    \n        //clear screen\n        gl.viewport(0, 0, size, size);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    \n        this.curSize = [size, size];\n\n        //this.gpu.clear();\n        this.camera.update();\n        this.onlyDepth = true;\n        this.onlyHitLayers = false;\n        this.onlyAdvancedHitLayers = false;\n        this.advancedPassNeeded = false;\n        break;\n\n    case 'geo':\n    case 'geo2':\n\n        this.hoverFeatureCounter = 0;\n        size = this.hitmapSize;\n            \n        //set texture framebuffer\n        this.gpu.setFramebuffer(type == 'geo' ? this.geoHitmapTexture : this.geoHitmapTexture2);\n            \n        width = size;\n        height = size;\n            \n        gl.clearColor(1.0,1.0, 1.0, 1.0);\n        gl.enable(gl.DEPTH_TEST);\n            \n        //clear screen\n        gl.viewport(0, 0, size, size);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            \n        this.curSize = [width, height];\n            \n        //render scene\n        this.onlyHitLayers = true;\n        this.advancedPassNeeded = false;\n        this.onlyAdvancedHitLayers = (type == 'geo2');\n            \n        //this.gpu.clear();\n        this.camera.update();\n        break;\n\n    case 'texture':\n        //set texture framebuffer\n        this.gpu.setFramebuffer(texture);\n\n        this.oldSize = [ this.curSize[0], this.curSize[1] ];\n   \n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\n        gl.enable(gl.DEPTH_TEST);\n\n        //clear screen\n        gl.viewport(0, 0, this.gpu.canvas.width, this.gpu.canvas.height);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    \n        this.curSize = [this.gpu.canvas.width, this.gpu.canvas.height];\n\n        //this.gpu.clear();\n        this.camera.update();\n        this.onlyDepth = false;\n        this.onlyHitLayers = false;\n        this.onlyAdvancedHitLayers = false;\n        this.advancedPassNeeded = false;\n        break;        \n    }\n};\n\n\nRenderer.prototype.hitTest = function(screenX, screenY) {\n    var gl = this.gpu.gl;\n\n    //get screen ray\n    var screenRay = this.getScreenRay(screenX, screenY);\n    var cameraPos = this.camera.getPosition();\n\n    //probably not needed\n    //if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {  \n      //  return [0, 0, 0, null, screenRay, Number.MAX_VALUE, cameraPos];\n    //}\n\n    //convert screen coords to texture coords\n    var x = 0, y = 0;\n\n    //get screen coords\n    x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));\n    y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));\n\n    //get pixel value from framebuffer\n    var pixel = this.hitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);\n\n    //convert rgb values into depth\n    var depth = (pixel[0] * (1.0/255)) + (pixel[1]) + (pixel[2]*255.0) + (pixel[3]*65025.0);// + (pixel[3]*16581375.0);\n\n    var surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);\n\n    //compute hit postion\n    this.lastHitPosition = [cameraPos[0] + screenRay[0]*depth, cameraPos[1] + screenRay[1]*depth, cameraPos[2] + screenRay[2]*depth];\n\n    return [this.lastHitPosition[0], this.lastHitPosition[1], this.lastHitPosition[2], surfaceHit, screenRay, depth, cameraPos];\n};\n\n\nRenderer.prototype.copyHitmap = function() {\n    this.hitmapTexture.readFramebufferPixels(0,0,this.hitmapSize,this.hitmapSize, false, this.hitmapData);\n};\n\n\nRenderer.prototype.getDepth = function(screenX, screenY) {\n    var x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));\n    var y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));\n\n    if (this.hitmapMode <= 2) {\n        //get pixel value from framebuffer\n        var pixel = this.hitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1, (this.hitmapMode == 2));\n\n        //convert rgb values into depth\n        var depth = (pixel[0] * (1.0/255)) + (pixel[1]) + (pixel[2]*255.0) + (pixel[3]*65025.0);// + (pixel[3]*16581375.0);\n        var surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);\n\n    } else {\n        var pixels = this.hitmapData;\n        var index = (x + (this.hitmapSize - y - 1) * this.hitmapSize) * 4;\n        var r = pixels[index], g = pixels[index+1], b = pixels[index+2], a = pixels[index+3];\n\n        var depth = (r * (1.0/255)) + (g) + (b*255.0) + (a*65025.0);// + (pixel[3]*16581375.0);\n        var surfaceHit = !(r == 255 && g == 255 && b == 255 && a == 255);\n    }\n\n    return [surfaceHit, depth];\n};\n\n\nRenderer.prototype.getZoffsetFactor = function(params) {\n    return (params[0] + params[1]*this.distanceFactor + params[2]*this.tiltFactor)*0.0001;\n};\n\n\nRenderer.prototype.saveScreenshot = function(output, filename, filetype) {\n    var gl = this.gpu.gl;\n\n    //get current screen size\n    var width = this.curSize[0];\n    var height = this.curSize[1];\n\n    //read rgba data from frame buffer\n    //works only when webgl context is initialized with preserveDrawingBuffer: true\n    var data2 = new Uint8Array(width * height * 4);\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data2);\n\n    //flip image vertically\n    var data = new Uint8Array(width * height * 4);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n\n        var index2 = ((height-1) - y) * width * 4;\n\n        for (var x = 0; x < width; x++) {\n            data[index] = data2[index2];\n            data[index+1] = data2[index2+1];\n            data[index+2] = data2[index2+2];\n            data[index+3] = data2[index2+3];\n            index+=4;\n            index2+=4;\n        }\n    }\n\n    // Create a 2D canvas to store the result\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var context = canvas.getContext('2d');\n\n    // Copy the pixels to a 2D canvas\n    var imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    context.putImageData(imageData, 0, 0);\n\n    filetype = filetype || 'jpg'; \n   \n    if (output == 'file') {\n        var a = document.createElement('a');\n\n        var dataURI= canvas.toDataURL('image/' + filetype);\n\n        var byteString = atob(dataURI.split(',')[1]);\n        \n        // write the bytes of the string to an ArrayBuffer\n        var ab = new ArrayBuffer(byteString.length);\n        var ia = new Uint8Array(ab);\n        for (var i = 0; i < byteString.length; i++) {\n            ia[i] = byteString.charCodeAt(i);\n        }\n      \n        var file = new Blob([ab], {type: filetype});\n\n        var url = URL.createObjectURL(file);\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        setTimeout(function() {\n            document.body.removeChild(a);\n            window.URL.revokeObjectURL(url);  \n        }, 0); \n    } if (output == 'tab') {\n        //open image in new window\n        window.open(canvas.toDataURL('image/' + filetype));\n    }\n    \n    return imageData;\n};\n\n\nRenderer.prototype.getBitmap = function(url, filter, tiled, hash, useHash) {\n    var id = (useHash ? hash : url) + '*' + filter + '*' + tiled;\n\n    var texture = this.bitmaps[id];\n    if (!texture && url) {\n        texture = new GpuTexture(this.gpu, url, this.core, null, null, tiled, filter);\n        this.bitmaps[id] = texture;\n    }\n\n    return texture;\n};\n\n\nRenderer.prototype.getFont = function(url) {\n    var font = this.fonts[url];\n    if (!font) {\n        font = new GpuFont(this.gpu, this.core, null, null, url);\n        this.fonts[url] = font;\n    }\n\n    return font;\n};\n\n\nexport default Renderer;\n","\nimport {vec3 as vec3_} from '../utils/matrix';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\n\n\nvar RendererRMap = function(renderer, blockSize, maxBlockRectangles) {\n    this.renderer = renderer;\n    this.drawAllLabels = false;\n    this.maxBlockRectangles = maxBlockRectangles || 500;\n    this.blockSize = blockSize;\n    this.blockSizeFactor = 1/blockSize;\n    this.blocks = [];\n    this.blocks2 = [];\n    this.blocksRCount = [];\n    this.blocks2RCount = [];\n    this.allocatedBlocks = 0;\n    this.lx = 1;\n    this.ly = 1;\n    this.counter = 0;\n    this.rectangles = null;\n    this.rectanglesCount = 0;\n    this.rectangles2 = null;\n    this.rectangles2Count = 0;\n    this.rectanglesR = null;\n    this.rectanglesRCount = 0;\n    this.benevolentMargins = false;\n    this.positionsBuffer = new Float64Array(256*4);\n};\n\n\nRendererRMap.prototype.clear = function() {\n    var renderer = this.renderer;\n\n    this.sx2 = renderer.curSize[0];\n    this.sy2 = renderer.curSize[1];\n\n    //reduce by credits\n    this.sy2 = Math.max(1, this.sy2 - 55);\n    this.sy1 = 1;\n    this.sx1 = 1;\n\n    //compass size\n    this.cx2 = 135;\n    this.cy1 = renderer.curSize[1] - 145;\n\n    //search bar size\n    this.bx2 = 245;\n    this.by2 = 45;\n\n    this.lx = Math.floor(renderer.curSize[0] * this.blockSizeFactor) + 1;\n    this.ly = Math.floor(renderer.curSize[1] * this.blockSizeFactor) + 1;\n\n    if (renderer.marginFlags & 4096) {\n        this.sx1 = Math.min(34, this.sx2);\n        this.sx2 = Math.max(1, renderer.curSize[0] - 34);\n        this.sy1 = Math.min(50, this.sy2);\n        this.sy2 = Math.max(1, renderer.curSize[1] - 68);\n    }\n\n    var totalNeeded = this.ly * this.lx;\n    \n    if (!this.rectangles) {\n        this.rectangles = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles\n    }\n\n    if (!this.rectangles2) {\n        this.rectangles2 = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles\n    }\n\n    if (!this.rectanglesR) {\n        this.rectanglesR = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles\n    }\n\n    if (this.rectanglesCount > 0 || this.allocatedBlocks != totalNeeded) {\n\n        for (var i = 0; i < totalNeeded; i++) { //check if all rectangles are preallocated and reset coutner\n            if (!this.blocks[i]) {\n                this.blocks[i] = [];\n            }\n\n            this.blocksRCount[i] = 0;\n        }\n    }\n\n    if (this.rectangles2Count > 0 || this.allocatedBlocks != totalNeeded) {\n\n        for (var i = 0; i < totalNeeded; i++) { //check if all rectangles are preallocated and reset coutner\n            if (!this.blocks2[i]) {\n                this.blocks2[i] = [];\n            }\n\n            this.blocks2RCount[i] = 0;\n        }\n    }\n\n    this.allocatedBlocks = totalNeeded;\n    this.drawAllLabels = renderer.debug.drawAllLabels;\n    this.benevolentMargins = renderer.benevolentMargins;\n\n    this.rectanglesCount = 0;\n    this.rectangles2Count = 0;\n    this.rectanglesRCount = 0;\n    this.counter = renderer.geoRenderCounter;\n};\n\n\nRendererRMap.prototype.storeRemovedRectangle = function(x1, y1, x2, y2, z, subjob) {\n    var rectangles2 = this.rectanglesR;\n    var rectangles2Count = this.rectanglesRCount;\n\n    rectangles2[rectangles2Count] = x1;\n    rectangles2[rectangles2Count+1] = y1;\n    rectangles2[rectangles2Count+2] = x2;\n    rectangles2[rectangles2Count+3] = y2;\n    rectangles2[rectangles2Count+4] = z;\n    rectangles2[rectangles2Count+5] = subjob;\n    this.rectanglesRCount += 6;\n};\n\n\n//aabbox circle\n//http://www.firenibbler.com/2016/04/27/how-to-js-collision-detection-cheat-sheets-learn-aabb-box-circle-and-point-detection/\nRendererRMap.prototype.circleAABBoxCollide = function(x1, y1, x2, y2, cx, cy, cr){\n    // Get the distance between the two objects\n    var hwidth = (x2 - x1) * 0.5;\n    var hheight = (y2 - y1) * 0.5;\n    var distX = Math.abs(cx - x1 - hwidth);\n    var distY = Math.abs(cy - y2 - hheight);\n\n    // Check to make sure it is definitely not overlapping\n    if (distX > (hwidth + cr) || distY > (hheight + cr)) {\n        return false;\n    }\n    // Check to see if it is definitely overlapping\n    if (distX <= hwidth || distY <= hheight) {\n        return true;\n    }\n\n    // Last Resort to see if they are overlapping\n    var dx = distX - hwidth;\n    var dy = distY - hheight;\n    return (dx * dx + dy * dy <= (cr * cr));\n};\n\n\n//aabbox line\n//https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms\nRendererRMap.prototype.lineAABBoxCollide = function(x1, y1, x2, y2, rx1, ry1, rx2, ry2) {\n    var dx = 1 / ( (rx2 != rx1) ? (rx2 - rx1) : 0.00001);\n    var tx1 = (x1 - rx1)*dx;\n    var tx2 = (x2 - rx1)*dx;\n\n    var tmin = Math.min(tx1, tx2);\n    var tmax = Math.max(tx1, tx2);\n\n    var dy = 1 / ( (ry2 != ry1) ? (ry2 - ry1) : 0.00001);\n    var ty1 = (y1 - ry1)*dy;\n    var ty2 = (y2 - ry1)*dy;\n\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\n\n    return tmax >= tmin;\n};\n\n\nRendererRMap.prototype.checkRectangle = function(x1, y1, x2, y2, y3) {\n    var t;\n\n    if (x1 > x2) { t = x1; x1 = x2; x2 = t; }\n    if (y1 > y2) { t = y1; y1 = y2; y2 = t; }\n\n    y3 += y2;\n\n    if (this.benevolentMargins) {\n        //screen including credits\n        return !(x2 < this.sx1 || x1 > this.sx2 || y3 < this.sy1 || y1 > this.sy2);\n    }\n    \n    //screen including credits\n    if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y3 > this.sy2) {\n        return false;\n    }\n\n    //compass\n    if ((this.renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y3 > this.cy1) {\n        return false;\n    }\n\n    //search bar\n    if ((this.renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y3 > 0) {\n        return false;\n    }\n\n    return true;\n}\n\nRendererRMap.prototype.addRectangle = function(x1, y1, x2, y2, z, subjob, any, checkDepthMap) {\n    var x, y, i, index, blockRectangles, blockRectanglesCount,\n        rectangleIndex, t, renderer = this.renderer;\n\n    if (this.drawAllLabels) {\n        return true;\n    }\n\n    if (x1 > x2) { t = x1; x1 = x2; x2 = t; }\n    if (y1 > y2) { t = y1; y1 = y2; y2 = t; }\n\n    var y3 = y2 + subjob[1]; //add stick shift\n\n    if (this.benevolentMargins) {\n        //screen including credits\n        if (x2 < this.sx1 || x1 > this.sx2 || y3 < this.sy1 || y1 > this.sy2) {\n            return false;\n        }\n    } else {\n        //screen including credits\n        if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y3 > this.sy2) {\n            return false;\n        }\n\n        //compass\n        if ((renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y3 > this.cy1) {\n            return false;\n        }\n\n        //search bar\n        if ((renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y3 > 0) {\n            return false;\n        }\n    }\n\n    var xx1 = Math.floor(x1 * this.blockSizeFactor);\n    var yy1 = Math.floor(y1 * this.blockSizeFactor);\n    var xx2 = Math.floor(x2 * this.blockSizeFactor);\n    var yy2 = Math.floor(y2 * this.blockSizeFactor);\n\n    if (xx2 < 0 || yy2 < 0 || xx1 >= this.lx || yy1 >= this.ly) {\n        return false;\n    }\n\n    if (xx1 < 0) xx1 = 0;\n    if (xx2 >= this.lx) xx2 = this.lx - 1;\n\n    if (yy1 < 0) yy1 = 0;\n    if (yy2 >= this.ly) yy2 = this.ly - 1;\n\n    var lx = (xx2 - xx1) + 1;\n    var ly = (yy2 - yy1) + 1;\n    var removeList = {};\n    var exit = false;\n\n    var top = renderer.config.mapFeaturesSortByTop,\n        rectangles = this.rectangles, rectangles2 = this.rectangles2;\n\n    //test collision\n    for (y = 0; y < ly; y++) {\n        for (x = 0; x < lx; x++) {\n            index = (yy1 + y)*this.lx + (xx1 + x);\n\n            blockRectangles = this.blocks[index];\n            blockRectanglesCount = this.blocksRCount[index];\n\n            //test rectangles\n            for (i = 0; i < blockRectanglesCount; i++) {\n                rectangleIndex = blockRectangles[i];\n\n                if (x1 < rectangles[rectangleIndex + 2] && x2 > rectangles[rectangleIndex + 0] &&\n                    y1 < rectangles[rectangleIndex + 3] && y2 > rectangles[rectangleIndex + 1]) {\n\n                    if (any) {\n                        return false;\n                    }\n\n                    if (top) {\n                        if (z < rectangles[rectangleIndex + 4]) {\n                            return false;\n                        }\n                    } else {\n                        if (z > rectangles[rectangleIndex + 4]) {\n                            return false;\n                        }\n                    }\n\n                    removeList[rectangleIndex] = true;\n                }\n            }\n\n            if ((blockRectanglesCount + 1) >= this.maxBlockRectangles) {\n                return false;\n            }\n\n            blockRectangles = this.blocks2[index];\n            blockRectanglesCount = this.blocks2RCount[index];\n\n            //test circles\n            for (i = 0; i < blockRectanglesCount; i++) {\n                rectangleIndex = blockRectangles[i];\n\n//                if (this.circleAABBoxCollide(rectangles2[rectangleIndex + 0], rectangles2[rectangleIndex + 1], rectangles[rectangleIndex + 2], rectangles[rectangleIndex + 3], x, y, r)) {\n                if (this.circleAABBoxCollide(x1, y1, x2, y2, rectangles2[rectangleIndex + 0], rectangles2[rectangleIndex + 1], rectangles[rectangleIndex + 3])) {\n\n                 //   if (any) {\n                        return false;\n                  //  }                    \n                }\n            }\n\n\n        }\n    }\n\n    //remove rectangles\n    for (var key in removeList) {\n        this.removeRectangle(parseInt(key));\n    }\n\n    if (checkDepthMap) {\n\n        var reduce = checkDepthMap[2];\n        var depth = renderer.mapHack.getScreenDepth(checkDepthMap[0], checkDepthMap[1], (reduce[4] > 10000000));\n\n        if (depth[0]) {\n            var delta = depth[1] - reduce[4];\n            reduce[7] = delta;\n\n            if (!renderer.drawHiddenLabels && delta < checkDepthMap[3]) {\n                return false;\n            }\n        }\n    }\n\n    //there is no collision so we can store rectangle\n    rectangleIndex = this.rectanglesCount;\n    rectangles[rectangleIndex] = x1;\n    rectangles[rectangleIndex+1] = y1;\n    rectangles[rectangleIndex+2] = x2;\n    rectangles[rectangleIndex+3] = y2;\n    rectangles[rectangleIndex+4] = z;\n    rectangles[rectangleIndex+5] = subjob;\n    this.rectanglesCount += 6;\n\n    for (y = 0; y < ly; y++) {\n        for (x = 0; x < lx; x++) {\n            index = (yy1 + y)*this.lx + (xx1 + x);\n            this.blocks[index][this.blocksRCount[index]] = rectangleIndex;\n            this.blocksRCount[index]++;\n        }\n    }\n\n    return true;\n};\n\n\nRendererRMap.prototype.addLineLabel = function(subjob, checkDepthMap) {\n    var job = subjob[0], blockRectangles, blockRectanglesCount, rectangleIndex;\n    var x1 = Number.POSITIVE_INFINITY, x2 = Number.NEGATIVE_INFINITY,\n        y1 = Number.POSITIVE_INFINITY, y2 = Number.NEGATIVE_INFINITY;\n    var x, y, r, rr = 0, xx, yy, renderer = this.renderer, i, li, pp = [0,0,0,0];\n    var pbuff = this.positionsBuffer;\n    var index = 0, pindex = 0;\n    var margin = job.noOverlap ? job.noOverlap[0] : 1;\n\n    var targetSize = job.labelSize * 0.5; \n    var sizeFactor = renderer.camera.scaleFactor2(subjob[5][3])*0.5*renderer.curSize[1]*(renderer.curSize[0]/renderer.curSize[1]);\n    var pointsIndex = subjob[9];\n    var labelPoints = job.labelPoints;\n    var labelIndex = job.labelIndex;\n    var labelMorph = 0;\n\n    li = labelPoints.length;\n\n    if (li <= 1 || labelPoints[li -1][0]*sizeFactor < targetSize) {\n        return;\n    }\n\n    li--;\n\n    for (i = 0; i < li; i++) {\n        var s2 = labelPoints[i+1][0] * sizeFactor;\n\n        if (s2 > targetSize) {\n            var s1 = labelPoints[i][0] * sizeFactor;\n\n            labelIndex = i;\n            labelMorph = (targetSize - s1) / (s2 - s1);\n            break;                \n        }\n    }\n\n    var pointsIndex = (vec3.dot(labelPoints[labelIndex][1], renderer.labelVector) >= 0) ? 3 : 2;\n    var points = labelPoints[labelIndex][pointsIndex];\n    var points2 = (labelPoints[labelIndex+1]) ? labelPoints[labelIndex+1][pointsIndex] : points;\n    var p, p2, buffer, benevolentMargins = this.benevolentMargins;\n\n    if (renderer.useSuperElevation) {\n        buffer = job.labelPointsBuffer;\n\n        if (buffer.id != (labelIndex * 1024 + pointsIndex)) {\n            buffer.id = (labelIndex * 1024 + pointsIndex);\n            if (buffer.points.length != points.length) {\n                buffer.points = new Array(points.length);\n                buffer.points2 = new Array(points.length);\n            }\n\n            var sePoints = buffer.points;\n            var sePoints2 = buffer.points2;\n\n            for(i = 0, li = points.length; i < li; i++) {\n                sePoints[i] = renderer.transformPointBySE2(points[i]);\n                sePoints2[i] = renderer.transformPointBySE2(points2[i]);\n            }\n\n            points = sePoints;\n            points2 = sePoints2;\n\n        } else {\n            points = buffer.points;\n            points2 = buffer.points2;\n        }\n    }\n\n    if (!points.length || !points2.length) {\n        return false;\n    }\n\n    for (i = 0, li = points.length; i < li; i++) {\n\n        p = points[i];\n        p2 = points2[i];\n\n        pp[0] = p[0] + (p2[0] - p[0]) * labelMorph;\n        pp[1] = p[1] + (p2[1] - p[1]) * labelMorph;\n        pp[2] = p[2] + (p2[2] - p[2]) * labelMorph;\n        r = (p[3] + (p2[3] - p[3]) * labelMorph)*sizeFactor*margin;\n\n        pp = renderer.project2(pp, renderer.camera.mvp, renderer.cameraPosition, true);\n\n        if (pp[0] > x2) x2 = pp[0];\n        if (pp[1] > y2) y2 = pp[1];\n        if (pp[0] < x1) x1 = pp[0];\n        if (pp[1] < y1) y1 = pp[1];\n\n        //minX, maxX, minY, maxY;\n        pbuff[pindex] = pp[0];\n        pbuff[pindex+1] = pp[1];\n        pbuff[pindex+2] = pp[2];\n        pbuff[pindex+3] = r;\n\n        if (r > rr) {\n            rr = r;\n        }\n\n        pindex += 4;\n    }\n\n    x1 -= rr, x2 += rr, y1 -= rr, y2 += rr;\n\n    if (benevolentMargins) {\n        //screen including credits\n        if (x2 < this.sx1 || x1 > this.sx2 || y2 < this.sy1 || y1 > this.sy2) {\n            return false;\n        }\n    } else {\n        //screen including credits\n        if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y2 > this.sy2) {\n            return false;\n        }\n\n        //compass\n        if ((renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y2 > this.cy1) {\n            return false;\n        }\n\n        //search bar\n        if ((renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y2 > 0) {\n            return false;\n        }\n    }\n\n    var blockSizeFactor = this.blockSizeFactor, xx1, yy1, xx2, yy2, dx, dy, llx = this.lx, lly = this.ly;\n    var top = renderer.config.mapFeaturesSortByTop, j,\n        rectangles = this.rectangles, rectangles2 = this.rectangles2;\n\n    pindex = 0;\n\n    for (i = 0, li = points.length; i < li; i++) {\n\n        xx = pbuff[pindex];\n        yy = pbuff[pindex+1];\n        r = pbuff[pindex+3];\n\n        xx1 = Math.floor((xx-r) * blockSizeFactor);\n        yy1 = Math.floor((yy-r) * blockSizeFactor);\n        xx2 = Math.floor((xx+r) * blockSizeFactor);\n        yy2 = Math.floor((yy+r) * blockSizeFactor);\n\n        if (benevolentMargins) {\n            if (xx2 < 0 || xx1 >= llx || yy2 < 0 || yy1 >= lly) {\n              pindex += 4;\n              continue;  \n            } \n            if (xx1 < 0) xx1 = 0;\n            if (yy1 < 0) yy1 = 0;\n            if (xx2 >= llx) xx2 = llx - 1;\n            if (yy2 >= lly) yy2 = lly - 1;\n        }\n\n        var lx = (xx2 - xx1) + 1;\n        var ly = (yy2 - yy1) + 1;\n\n        //test collision\n        for (y = 0; y < ly; y++) {\n            for (x = 0; x < lx; x++) {\n                index = (yy1 + y)*llx + (xx1 + x);\n\n                blockRectangles = this.blocks[index];\n                blockRectanglesCount = this.blocksRCount[index];\n\n                //test rectangles\n                for (j = 0; j < blockRectanglesCount; j++) {\n                    rectangleIndex = blockRectangles[j];\n\n                    if (this.circleAABBoxCollide(x1, y1, x2, y2, rectangles[rectangleIndex + 0], rectangles[rectangleIndex + 1], rectangles[rectangleIndex + 2])) {\n\n                        //if (any) {\n                            return false;\n                        //}                    \n                    }\n                }\n\n                blockRectangles = this.blocks2[index];\n                blockRectanglesCount = this.blocks2RCount[index];\n\n                //test circles\n                for (j = 0; j < blockRectanglesCount; j++) {\n                    rectangleIndex = blockRectangles[j];\n\n                    dx = xx - rectangles2[rectangleIndex + 0];\n                    dy = yy - rectangles2[rectangleIndex + 1];\n                    rr = rectangles2[rectangleIndex + 2] + r;\n\n                    if ((dx*dx + dy*dy) < (rr * rr)) {\n\n                        //if (any) {\n                            return false;\n                        //}                    \n                    }\n                }\n            }\n        }\n\n        pindex += 4;\n    }\n\n    //there is no collision so we can store line label\n    pindex = 0;\n\n    for (i = 0, li = points.length; i < li; i++) {\n\n        xx = pbuff[pindex];\n        yy = pbuff[pindex+1];\n        r = pbuff[pindex+3];\n\n        xx1 = Math.floor((xx-r) * blockSizeFactor);\n        yy1 = Math.floor((yy-r) * blockSizeFactor);\n        xx2 = Math.floor((xx+r) * blockSizeFactor);\n        yy2 = Math.floor((yy+r) * blockSizeFactor);\n\n        if (benevolentMargins) {\n            if (xx2 < 0 || xx1 >= llx || yy2 < 0 || yy1 >= lly) {\n              pindex += 4;\n              continue;  \n            } \n            if (xx1 < 0) xx1 = 0;\n            if (yy1 < 0) yy1 = 0;\n            if (xx2 >= llx) xx2 = llx - 1;\n            if (yy2 >= lly) yy2 = lly - 1;\n        }\n\n        var lx = (xx2 - xx1) + 1;\n        var ly = (yy2 - yy1) + 1;\n\n        rectangleIndex = this.rectangles2Count;\n        rectangles2[rectangleIndex] = xx;\n        rectangles2[rectangleIndex+1] = yy;\n        rectangles2[rectangleIndex+2] = r;\n        rectangles2[rectangleIndex+3] = subjob;\n        this.rectangles2Count += 4;\n\n        //test collision\n        for (y = 0; y < ly; y++) {\n            for (x = 0; x < lx; x++) {\n                index = (yy1 + y)*this.lx + (xx1 + x);\n\n                //console.log('' + index);\n\n                //if (typeof this.blocks2[index][this.blocks2RCount[index]] === 'undefined') {\n                  //  debugger\n                //}\n\n                this.blocks2[index][this.blocks2RCount[index]] = rectangleIndex;\n                this.blocks2RCount[index]++;\n            }\n        }\n\n        pindex += 4;\n    }\n\n    return true;\n};\n\n\nRendererRMap.prototype.removeRectangle = function(rectangleIndex) {\n    var rectangles = this.rectangles, x1, y1, x2, y2, x, y, i, index,\n        blockRectangles, blockRectanglesCount;\n\n    x1 = rectangles[rectangleIndex];\n    y1 = rectangles[rectangleIndex+1];\n    x2 = rectangles[rectangleIndex+2];\n    y2 = rectangles[rectangleIndex+3];\n\n    //store removed rectangels for second pass\n    var rectangles2 = this.rectanglesR;\n    var rectangles2Count = this.rectanglesRCount;\n\n    rectangles2[rectangles2Count] = x1;\n    rectangles2[rectangles2Count+1] = y1;\n    rectangles2[rectangles2Count+2] = x2;\n    rectangles2[rectangles2Count+3] = y2;\n    rectangles2[rectangles2Count+4] = rectangles[rectangleIndex+4];\n    rectangles2[rectangles2Count+5] = rectangles[rectangleIndex+5];\n    this.rectanglesRCount += 6;\n\n    //remove subjob\n    rectangles[rectangleIndex+5] = null;\n\n    var xx1 = Math.floor(x1 * this.blockSizeFactor);\n    var yy1 = Math.floor(y1 * this.blockSizeFactor);\n    var xx2 = Math.floor(x2 * this.blockSizeFactor);\n    var yy2 = Math.floor(y2 * this.blockSizeFactor);\n\n    if (xx1 < 0) xx1 = 0;\n    if (xx2 >= this.lx) xx2 = this.lx - 1;\n\n    if (yy1 < 0) yy1 = 0;\n    if (yy2 >= this.ly) yy2 = this.ly - 1;\n\n    var lx = (xx2 - xx1) + 1;\n    var ly = (yy2 - yy1) + 1;\n\n    for (y = 0; y < ly; y++) {\n        for (x = 0; x < lx; x++) {\n            index = (yy1 + y)*this.lx + (xx1 + x);\n\n            blockRectangles = this.blocks[index];\n            blockRectanglesCount = this.blocksRCount[index];\n\n            for (i = 0; i < blockRectanglesCount; i++) {\n                if (blockRectangles[i] == rectangleIndex) {\n                    blockRectangles[i] = blockRectangles[blockRectanglesCount - 1];\n                    this.blocksRCount[index]--;\n                    break;\n                }\n            }\n\n        }\n    }\n};\n\nRendererRMap.prototype.processRectangles = function(gpu, gl, renderer, screenPixelSize) {\n    var rectangles = this.rectangles;\n    var rectangles2 = this.rectangles2;\n    var rectanglesR = this.rectanglesR;\n    var draw = renderer.draw;\n\n    // second pass\n    // add removed rectangles\n    for (var i = 0, li = this.rectanglesRCount; i < li; i+=6) {\n        var x1 = rectanglesR[i],\n            y1 = rectanglesR[i+1],\n            x2 = rectanglesR[i+2],\n            y2 = rectanglesR[i+3],\n            z = rectanglesR[i+4],\n            subjob = rectanglesR[i+5];\n\n        this.addRectangle(x1, y1, x2, y2, z, subjob);\n    }\n\n    this.rectanglesRCount = 0;\n\n    //labels\n    for (i = 0, li = this.rectanglesCount; i < li; i+=6) {\n        var subjob = rectangles[i+5];\n\n        if (subjob) {\n            if (subjob[0].hysteresis) {\n                renderer.jobHBuffer[subjob[0].id] = subjob[0];\n            } else {\n                renderer.drawnJobs++;\n                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, subjob, null);\n            }\n        }\n    }\n\n    //line labels\n    for (i = 0, li = this.rectangles2Count; i < li; i+=4) {\n        var subjob = rectangles2[i+3];\n\n        if (subjob) {\n            var job = subjob[0];\n\n            if (job.hysteresis) {\n                renderer.jobHBuffer[job.id] = job;\n            } else {\n                renderer.drawnJobs++;\n                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, subjob, null);\n            }\n\n            var l = job.labelPoints[0][2].length;\n\n            if (l > 0) {\n                i += (4 * (l - 1));\n            }\n        }\n    }\n\n    this.clear();\n};\n\nexport default RendererRMap;\n\n","\nimport {mat4 as mat4_} from './matrix';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\n\n\nvar math = {};\n\n\nmath.isEqual = function(value, value2, delta) {\n    return (Math.abs(value - value2) < delta);\n};\n\n\nmath.clamp = function(value, min, max) {\n    if (value < min) value = min;\n    else if (value > max) value = max;\n\n    return value;\n};\n\n\nmath.radians = function(degrees) {\n    return degrees * Math.PI / 180;\n};\n\n\nmath.degrees = function(radians) {\n    return (radians / Math.PI) * 180;\n};\n\n\nmath.mix = function(a, b, c) {\n    return a + (b - a) * c;\n};\n\n\nmath.frustumMatrix = function(left, right, bottom, top, near, far) {\n    var w = (right - left);\n    var h = (top - bottom);\n    var d = (far - near);\n\n    var m = mat4.create([2*near/w, 0, (right+left)/w, 0,\n        0, 2*near/h, (top+bottom)/h, 0,\n        0, 0, -(far+near)/d, -2*far*near/d,\n        0, 0, -1, 0]);\n\n    mat4.transpose(m);\n    return m;\n};\n\n\nmath.perspectiveMatrix = function(fovy, aspect, near, far) {\n    var ymax = near * Math.tan(fovy * Math.PI / 180.0);\n    var xmax = ymax * aspect;\n    return math.frustumMatrix(-xmax, xmax, -ymax, ymax, near, far);\n};\n\n\nmath.orthographicMatrix = function(vsize, aspect, near, far) {\n    //vsize *= 0.020;\n    var w = vsize* 0.5 * aspect;\n    var h = vsize * 0.5;\n    var d = (far - near);\n\n    var m = mat4.create([1/w, 0, 0, 0,\n        0, 1/h, 0, 0,\n        0, 0, -2/d, -((far+near)/d),\n        0, 0, 0, 1]);\n\n    mat4.transpose(m);\n    return m;\n};\n\n\nmath.rotationMatrix = function(axis, angle) {\n    var ca = Math.cos(angle), sa = Math.sin(angle);\n\n    /*    var m;\n    switch (axis) {\n    case 0:\n        m = [\n            1,  0,  0, 0,\n            0, ca,-sa, 0,\n            0, sa, ca, 0,\n            0,  0,  0, 1 ];\n        break;\n    case 1:\n        m = [\n            ca, 0,-sa, 0,\n            0, 1,  0,  0,\n            sa, 0, ca, 0,\n            0, 0,  0, 1 ];\n        break;\n    default:\n        m = [\n            ca,-sa, 0, 0,\n            sa, ca, 0, 0,\n            0,  0,  1, 0,\n            0,  0,  0, 1 ];\n        break;\n    }\n    mat4.transpose(m);\n    return m; */\n\n    switch (axis) {\n    case 0:\n        return [\n            1,   0,   0,  0,\n            0,  ca,  sa,  0,\n            0, -sa,  ca,  0,\n            0,   0,   0,  1 ];\n    case 1:\n        return [\n             ca,  0,  sa,  0,\n              0,  1,   0,  0,\n            -sa,  0,  ca,  0,\n              0,  0,   0,  1 ];\n    default:\n        return [\n             ca, sa,  0,  0,\n            -sa, ca,  0,  0,\n              0,  0,  1,  0,\n              0,  0,  0,  1 ];\n    }\n\n};\n\n\nmath.scaleMatrix = function(sx, sy, sz) {\n    /*var m = [\n        sx,  0,  0, 0,\n        0, sy,  0, 0,\n        0,  0, sz, 0,\n        0,  0,  0, 1 ];\n\n    mat4.transpose(m);\n    return m;*/\n    return [\n        sx,   0,   0,   0,\n        0,   sy,   0,   0,\n        0,    0,  sz,   0,\n        0,    0,   0,   1 ];\n};\n\n\nmath.scaleMatrixf = function(s) {\n    return math.scaleMatrix(s, s, s);\n};\n\n\nmath.translationMatrix = function(tx, ty, tz) {\n    /*\n    var m = [\n        1, 0, 0, tx,\n        0, 1, 0, ty,\n        0, 0, 1, tz,\n        0, 0, 0, 1 ];\n\n    mat4.transpose(m);\n    */\n\n    return [\n        1,   0,  0,  0,\n        0,   1,  0,  0,\n        0,   0,  1,  0,\n        tx, ty, tz,  1 ];\n};\n\n\nmath.translationMatrix2f = function(t) {\n    return math.translationMatrix(t[0], t[1], 0);\n};\n\n\nmath.translationMatrix3f = function(t) {\n    return math.translationMatrix(t[0], t[1], t[2]);\n};\n\n\nexport {math};\n","\n\nvar vec2 = {};\n\n\nvec2.create = function (a) {\n    var b = new Array(2);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n    }\n    return b;\n};\n\n\nvar vec4 = {};\n\n\nvec4.create = function (a) {\n    var b = new Array(4);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n    }\n    return b;\n};\n\n\nvec4.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n};\n\n\nvec4.dot2 = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3];\n};\n\n\nvec4.dot3 = function (a, b, i, x, y, z) {\n    return a[0] * (b[i]-x) + a[1] * (b[i+1]-y) + a[2] * (b[i+2]-z) + a[3];\n};\n\n\nvar vec3 = {};\n\n\nvec3.create = function (a) {\n    var b = new Array(3);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n    }\n    return b;\n};\n\n\nvec3.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    return b;\n};\n\n\nvec3.add = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] += b[0];\n        a[1] += b[1];\n        a[2] += b[2];\n        return a;\n    }\n    c[0] = a[0] + b[0];\n    c[1] = a[1] + b[1];\n    c[2] = a[2] + b[2];\n    return c;\n};\n\n\nvec3.subtract = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] -= b[0];\n        a[1] -= b[1];\n        a[2] -= b[2];\n        return a;\n    }\n    c[0] = a[0] - b[0];\n    c[1] = a[1] - b[1];\n    c[2] = a[2] - b[2];\n    return c;\n};\n\n\nvec3.negate = function (a, b) {\n    b || (b = a);\n    b[0] = -a[0];\n    b[1] = -a[1];\n    b[2] = -a[2];\n    return b;\n};\n\n\nvec3.scale = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] *= b;\n        a[1] *= b;\n        a[2] *= b;\n        return a;\n    }\n    c[0] = a[0] * b;\n    c[1] = a[1] * b;\n    c[2] = a[2] * b;\n    return c;\n};\n\n\nvec3.normalize = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return b;\n};\n\n\nvec3.normalize2 = function (a, i, b) {\n    var c = a[i],\n        d = a[i+1],\n        e = a[i+2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n};\n\n\nvec3.normalize3 = function (a, i, b, j) {\n    var c = a[i],\n        d = a[i+1],\n        e = a[i+2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[j] = c;\n            b[j+1] = d;\n            b[j+2] = e;\n            return b;\n        }\n    } else {\n        b[j] = 0;\n        b[j+1] = 0;\n        b[j+2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[j] = c * g;\n    b[j+1] = d * g;\n    b[j+2] = e * g;\n};\n\n\nvec3.normalize4 = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    var dd = g;\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return dd;\n};\n\n\nvec3.cross = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1];\n    a = a[2];\n    var g = b[0],\n        f = b[1];\n    b = b[2];\n    c[0] = e * b - a * f;\n    c[1] = a * g - d * b;\n    c[2] = d * f - e * g;\n    return c;\n};\n\n\nvec3.length = function (a) {\n    var b = a[0],\n        c = a[1];\n    a = a[2];\n    return Math.sqrt(b * b + c * c + a * a);\n};\n\n\nvec3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\n\nvec3.dot2 = function (a, b, i) {\n    return a[0] * b[i] + a[1] * b[i+1] + a[2] * b[i+2];\n};\n\n\nvec3.dot3 = function (a, i, b, j) {\n    return a[i] * b[j] + a[i+1] * b[j+1] + a[i+2] * b[j+2];\n};\n\nvec3.distance = function (a, b) {\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    var dz = b[2] - a[2];\n    return Math.sqrt(dx*dx + dy*dy + dz*dz);\n};\n\nvec3.squareDistance = function (a, b) {\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    var dz = b[2] - a[2];\n    return dx*dx + dy*dy + dz*dz;\n};\n\n\nvec3.direction = function (a, b, c) {\n    c || (c = a);\n    var d = a[0] - b[0],\n        e = a[1] - b[1];\n    a = a[2] - b[2];\n    b = Math.sqrt(d * d + e * e + a * a);\n    if (!b) {\n        c[0] = 0;\n        c[1] = 0;\n        c[2] = 0;\n        return c;\n    }\n    b = 1 / b;\n    c[0] = d * b;\n    c[1] = e * b;\n    c[2] = a * b;\n    return c;\n};\n\n\nvec3.lerp = function (a, b, c, d) {\n    d || (d = a);\n    d[0] = a[0] + c * (b[0] - a[0]);\n    d[1] = a[1] + c * (b[1] - a[1]);\n    d[2] = a[2] + c * (b[2] - a[2]);\n    return d;\n};\n\n\nvec3.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ']';\n};\n\n\nvar mat3 = {};\n\n\nmat3.create = function (a) {\n    var b = new Array(9);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n        b[4] = a[4];\n        b[5] = a[5];\n        b[6] = a[6];\n        b[7] = a[7];\n        b[8] = a[8];\n        b[9] = a[9];\n    }\n    return b;\n};\n\n\nmat3.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    return b;\n};\n\n\nmat3.identity = function (a) {\n    a[0] = 1;\n    a[1] = 0;\n    a[2] = 0;\n    a[3] = 0;\n    a[4] = 1;\n    a[5] = 0;\n    a[6] = 0;\n    a[7] = 0;\n    a[8] = 1;\n    return a;\n};\n\n\nmat3.transpose = function (a, b) {\n    if (!b || a == b) {\n        var c = a[1],\n            d = a[2],\n            e = a[5];\n        a[1] = a[3];\n        a[2] = a[6];\n        a[3] = c;\n        a[5] = a[7];\n        a[6] = d;\n        a[7] = e;\n        return a;\n    }\n    b[0] = a[0];\n    b[1] = a[3];\n    b[2] = a[6];\n    b[3] = a[1];\n    b[4] = a[4];\n    b[5] = a[7];\n    b[6] = a[2];\n    b[7] = a[5];\n    b[8] = a[8];\n    return b;\n};\n\n\nmat3.toMat4 = function (a, b) {\n    b || (b = mat4.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = 0;\n    b[4] = a[3];\n    b[5] = a[4];\n    b[6] = a[5];\n    b[7] = 0;\n    b[8] = a[6];\n    b[9] = a[7];\n    b[10] = a[8];\n    b[11] = 0;\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\nmat3.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    c[0] = a[0] * d + a[3] * e + a[6] * b;\n    c[1] = a[1] * d + a[4] * e + a[7] * b;\n    c[2] = a[2] * d + a[5] * e + a[8] * b;\n    return c;\n};\n\n\nmat3.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ']';\n};\n\n\nvar mat4 = {};\n\n\nmat4.create = function (a) {\n    var b = new Array(16);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n        b[4] = a[4];\n        b[5] = a[5];\n        b[6] = a[6];\n        b[7] = a[7];\n        b[8] = a[8];\n        b[9] = a[9];\n        b[10] = a[10];\n        b[11] = a[11];\n        b[12] = a[12];\n        b[13] = a[13];\n        b[14] = a[14];\n        b[15] = a[15];\n    }\n    return b;\n};\n\n\nmat4.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = a[12];\n    b[13] = a[13];\n    b[14] = a[14];\n    b[15] = a[15];\n    return b;\n};\n\n\nmat4.identity = function (a) {\n    a[0] = 1;\n    a[1] = 0;\n    a[2] = 0;\n    a[3] = 0;\n    a[4] = 0;\n    a[5] = 1;\n    a[6] = 0;\n    a[7] = 0;\n    a[8] = 0;\n    a[9] = 0;\n    a[10] = 1;\n    a[11] = 0;\n    a[12] = 0;\n    a[13] = 0;\n    a[14] = 0;\n    a[15] = 1;\n    return a;\n};\n\n\nmat4.transpose = function (a, b) {\n    if (!b || a == b) {\n        var c = a[1],\n            d = a[2],\n            e = a[3],\n            g = a[6],\n            f = a[7],\n            h = a[11];\n        a[1] = a[4];\n        a[2] = a[8];\n        a[3] = a[12];\n        a[4] = c;\n        a[6] = a[9];\n        a[7] = a[13];\n        a[8] = d;\n        a[9] = g;\n        a[11] = a[14];\n        a[12] = e;\n        a[13] = f;\n        a[14] = h;\n        return a;\n    }\n    b[0] = a[0];\n    b[1] = a[4];\n    b[2] = a[8];\n    b[3] = a[12];\n    b[4] = a[1];\n    b[5] = a[5];\n    b[6] = a[9];\n    b[7] = a[13];\n    b[8] = a[2];\n    b[9] = a[6];\n    b[10] = a[10];\n    b[11] = a[14];\n    b[12] = a[3];\n    b[13] = a[7];\n    b[14] = a[11];\n    b[15] = a[15];\n    return b;\n};\n\n\nmat4.determinant = function (a) {\n    var b = a[0],\n        c = a[1],\n        d = a[2],\n        e = a[3],\n        g = a[4],\n        f = a[5],\n        h = a[6],\n        i = a[7],\n        j = a[8],\n        k = a[9],\n        l = a[10],\n        o = a[11],\n        m = a[12],\n        n = a[13],\n        p = a[14];\n    a = a[15];\n    return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;\n};\n\n\nmat4.inverse = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = a[4],\n        h = a[5],\n        i = a[6],\n        j = a[7],\n        k = a[8],\n        l = a[9],\n        o = a[10],\n        m = a[11],\n        n = a[12],\n        p = a[13],\n        r = a[14],\n        s = a[15],\n        A = c * h - d * f,\n        B = c * i - e * f,\n        t = c * j - g * f,\n        u = d * i - e * h,\n        v = d * j - g * h,\n        w = e * j - g * i,\n        x = k * p - l * n,\n        y = k * r - o * n,\n        z = k * s - m * n,\n        C = l * r - o * p,\n        D = l * s - m * p,\n        E = o * s - m * r,\n        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);\n    b[0] = (h * E - i * D + j * C) * q;\n    b[1] = (-d * E + e * D - g * C) * q;\n    b[2] = (p * w - r * v + s * u) * q;\n    b[3] = (-l * w + o * v - m * u) * q;\n    b[4] = (-f * E + i * z - j * y) * q;\n    b[5] = (c * E - e * z + g * y) * q;\n    b[6] = (-n * w + r * t - s * B) * q;\n    b[7] = (k * w - o * t + m * B) * q;\n    b[8] = (f * D - h * z + j * x) * q;\n    b[9] = (-c * D + d * z - g * x) * q;\n    b[10] = (n * v - p * t + s * A) * q;\n    b[11] = (-k * v + l * t - m * A) * q;\n    b[12] = (-f * C + h * y - i * x) * q;\n    b[13] = (c * C - d * y + e * x) * q;\n    b[14] = (-n * u + p * B - r * A) * q;\n    b[15] = (k * u - l * B + o * A) * q;\n    return b;\n};\n\n\nmat4.toRotationMat = function (a, b) {\n    b || (b = mat4.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\n\nmat4.toMat3 = function (a, b) {\n    b || (b = mat3.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[4];\n    b[4] = a[5];\n    b[5] = a[6];\n    b[6] = a[8];\n    b[7] = a[9];\n    b[8] = a[10];\n    return b;\n};\n\n\nmat4.toInverseMat3 = function (a, b) {\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[4],\n        f = a[5],\n        h = a[6],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = k * f - h * j,\n        o = -k * g + h * i,\n        m = j * g - f * i,\n        n = c * l + d * o + e * m;\n    if (!n) return null;\n    n = 1 / n;\n    b || (b = mat3.create());\n    b[0] = l * n;\n    b[1] = (-k * d + e * j) * n;\n    b[2] = (h * d - e * f) * n;\n    b[3] = o * n;\n    b[4] = (k * c - e * i) * n;\n    b[5] = (-h * c + e * g) * n;\n    b[6] = m * n;\n    b[7] = (-j * c + d * i) * n;\n    b[8] = (f * c - d * g) * n;\n    return b;\n};\n\n\nmat4.multiply = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1],\n        g = a[2],\n        f = a[3],\n        h = a[4],\n        i = a[5],\n        j = a[6],\n        k = a[7],\n        l = a[8],\n        o = a[9],\n        m = a[10],\n        n = a[11],\n        p = a[12],\n        r = a[13],\n        s = a[14];\n    a = a[15];\n    var A = b[0],\n        B = b[1],\n        t = b[2],\n        u = b[3],\n        v = b[4],\n        w = b[5],\n        x = b[6],\n        y = b[7],\n        z = b[8],\n        C = b[9],\n        D = b[10],\n        E = b[11],\n        q = b[12],\n        F = b[13],\n        G = b[14];\n    b = b[15];\n    c[0] = A * d + B * h + t * l + u * p;\n    c[1] = A * e + B * i + t * o + u * r;\n    c[2] = A * g + B * j + t * m + u * s;\n    c[3] = A * f + B * k + t * n + u * a;\n    c[4] = v * d + w * h + x * l + y * p;\n    c[5] = v * e + w * i + x * o + y * r;\n    c[6] = v * g + w * j + x * m + y * s;\n    c[7] = v * f + w * k + x * n + y * a;\n    c[8] = z * d + C * h + D * l + E * p;\n    c[9] = z * e + C * i + D * o + E * r;\n    c[10] = z *\n        g + C * j + D * m + E * s;\n    c[11] = z * f + C * k + D * n + E * a;\n    c[12] = q * d + F * h + G * l + b * p;\n    c[13] = q * e + F * i + G * o + b * r;\n    c[14] = q * g + F * j + G * m + b * s;\n    c[15] = q * f + F * k + G * n + b * a;\n    return c;\n};\n\n\nmat4.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];\n    c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];\n    c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];\n    return c;\n};\n\n\nmat4.multiplyVec4 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1],\n        g = b[2];\n    b = b[3];\n    c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;\n    c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;\n    c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;\n    c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;\n    return c;\n};\n\n\nmat4.translate = function (a, b, c) {\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    if (!c || a == c) {\n        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];\n        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];\n        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];\n        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];\n        return a;\n    }\n    var g = a[0],\n        f = a[1],\n        h = a[2],\n        i = a[3],\n        j = a[4],\n        k = a[5],\n        l = a[6],\n        o = a[7],\n        m = a[8],\n        n = a[9],\n        p = a[10],\n        r = a[11];\n    c[0] = g;\n    c[1] = f;\n    c[2] = h;\n    c[3] = i;\n    c[4] = j;\n    c[5] = k;\n    c[6] = l;\n    c[7] = o;\n    c[8] = m;\n    c[9] = n;\n    c[10] = p;\n    c[11] = r;\n    c[12] = g * d + j * e + m * b + a[12];\n    c[13] = f * d + k * e + n * b + a[13];\n    c[14] = h * d + l * e + p * b + a[14];\n    c[15] = i * d + o * e + r * b + a[15];\n    return c;\n};\n\n\nmat4.scale = function (a, b, c) {\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    if (!c || a == c) {\n        a[0] *= d;\n        a[1] *= d;\n        a[2] *= d;\n        a[3] *= d;\n        a[4] *= e;\n        a[5] *= e;\n        a[6] *= e;\n        a[7] *= e;\n        a[8] *= b;\n        a[9] *= b;\n        a[10] *= b;\n        a[11] *= b;\n        return a;\n    }\n    c[0] = a[0] * d;\n    c[1] = a[1] * d;\n    c[2] = a[2] * d;\n    c[3] = a[3] * d;\n    c[4] = a[4] * e;\n    c[5] = a[5] * e;\n    c[6] = a[6] * e;\n    c[7] = a[7] * e;\n    c[8] = a[8] * b;\n    c[9] = a[9] * b;\n    c[10] = a[10] * b;\n    c[11] = a[11] * b;\n    c[12] = a[12];\n    c[13] = a[13];\n    c[14] = a[14];\n    c[15] = a[15];\n    return c;\n};\n\n\nmat4.rotate = function (a, b, c, d) {\n    var e = c[0],\n        g = c[1];\n    c = c[2];\n    var f = Math.sqrt(e * e + g * g + c * c);\n    if (!f) return null;\n    if (f != 1) {\n        f = 1 / f;\n        e *= f;\n        g *= f;\n        c *= f;\n    }\n    var h = Math.sin(b),\n        i = Math.cos(b),\n        j = 1 - i;\n    b = a[0];\n    f = a[1];\n    var k = a[2],\n        l = a[3],\n        o = a[4],\n        m = a[5],\n        n = a[6],\n        p = a[7],\n        r = a[8],\n        s = a[9],\n        A = a[10],\n        B = a[11],\n        t = e * e * j + i,\n        u = g * e * j + c * h,\n        v = c * e * j - g * h,\n        w = e * g * j - c * h,\n        x = g * g * j + i,\n        y = c * g * j + e * h,\n        z = e * c * j + g * h;\n    e = g * c * j - e * h;\n    g = c * c * j + i;\n    if (d) {\n        if (a != d) {\n            d[12] = a[12];\n            d[13] = a[13];\n            d[14] = a[14];\n            d[15] = a[15];\n        }\n    } else d = a;\n    d[0] = b * t + o * u + r * v;\n    d[1] = f * t + m * u + s * v;\n    d[2] = k * t + n * u + A * v;\n    d[3] = l * t + p * u + B *\n        v;\n    d[4] = b * w + o * x + r * y;\n    d[5] = f * w + m * x + s * y;\n    d[6] = k * w + n * x + A * y;\n    d[7] = l * w + p * x + B * y;\n    d[8] = b * z + o * e + r * g;\n    d[9] = f * z + m * e + s * g;\n    d[10] = k * z + n * e + A * g;\n    d[11] = l * z + p * e + B * g;\n    return d;\n};\n\n\nmat4.rotateX = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[4],\n        g = a[5],\n        f = a[6],\n        h = a[7],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = a[11];\n    if (c) {\n        if (a != c) {\n            c[0] = a[0];\n            c[1] = a[1];\n            c[2] = a[2];\n            c[3] = a[3];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[4] = e * b + i * d;\n    c[5] = g * b + j * d;\n    c[6] = f * b + k * d;\n    c[7] = h * b + l * d;\n    c[8] = e * -d + i * b;\n    c[9] = g * -d + j * b;\n    c[10] = f * -d + k * b;\n    c[11] = h * -d + l * b;\n    return c;\n};\n\n\nmat4.rotateY = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[0],\n        g = a[1],\n        f = a[2],\n        h = a[3],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = a[11];\n    if (c) {\n        if (a != c) {\n            c[4] = a[4];\n            c[5] = a[5];\n            c[6] = a[6];\n            c[7] = a[7];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[0] = e * b + i * -d;\n    c[1] = g * b + j * -d;\n    c[2] = f * b + k * -d;\n    c[3] = h * b + l * -d;\n    c[8] = e * d + i * b;\n    c[9] = g * d + j * b;\n    c[10] = f * d + k * b;\n    c[11] = h * d + l * b;\n    return c;\n};\n\n\nmat4.rotateZ = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[0],\n        g = a[1],\n        f = a[2],\n        h = a[3],\n        i = a[4],\n        j = a[5],\n        k = a[6],\n        l = a[7];\n    if (c) {\n        if (a != c) {\n            c[8] = a[8];\n            c[9] = a[9];\n            c[10] = a[10];\n            c[11] = a[11];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[0] = e * b + i * d;\n    c[1] = g * b + j * d;\n    c[2] = f * b + k * d;\n    c[3] = h * b + l * d;\n    c[4] = e * -d + i * b;\n    c[5] = g * -d + j * b;\n    c[6] = f * -d + k * b;\n    c[7] = h * -d + l * b;\n    return c;\n};\n\n\nmat4.frustum = function (a, b, c, d, e, g, f) {\n    f || (f = mat4.create());\n    var h = b - a,\n        i = d - c,\n        j = g - e;\n    f[0] = e * 2 / h;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = e * 2 / i;\n    f[6] = 0;\n    f[7] = 0;\n    f[8] = (b + a) / h;\n    f[9] = (d + c) / i;\n    f[10] = -(g + e) / j;\n    f[11] = -1;\n    f[12] = 0;\n    f[13] = 0;\n    f[14] = -(g * e * 2) / j;\n    f[15] = 0;\n    return f;\n};\n\n\nmat4.perspective = function (a, b, c, d, e) {\n    a = c * Math.tan(a * Math.PI / 360);\n    b = a * b;\n    return mat4.frustum(-b, b, -a, a, c, d, e);\n};\n\n\nmat4.ortho = function (a, b, c, d, e, g, f) {\n    f || (f = mat4.create());\n    var h = b - a,\n        i = d - c,\n        j = g - e;\n    f[0] = 2 / h;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = 2 / i;\n    f[6] = 0;\n    f[7] = 0;\n    f[8] = 0;\n    f[9] = 0;\n    f[10] = -2 / j;\n    f[11] = 0;\n    f[12] = -(a + b) / h;\n    f[13] = -(d + c) / i;\n    f[14] = -(g + e) / j;\n    f[15] = 1;\n    return f;\n};\n\n\nmat4.lookAt = function (a, b, c, d) {\n    d || (d = mat4.create());\n    var e = a[0],\n        g = a[1];\n    a = a[2];\n    var f = c[0],\n        h = c[1],\n        i = c[2];\n    c = b[1];\n    var j = b[2];\n    if (e == b[0] && g == c && a == j) return mat4.identity(d);\n    var k, l, o, m;\n    c = e - b[0];\n    j = g - b[1];\n    b = a - b[2];\n    m = 1 / Math.sqrt(c * c + j * j + b * b);\n    c *= m;\n    j *= m;\n    b *= m;\n    k = h * b - i * j;\n    i = i * c - f * b;\n    f = f * j - h * c;\n    m = Math.sqrt(k * k + i * i + f * f);\n    if (m) {\n        m = 1 / m;\n        k *= m;\n        i *= m;\n        f *= m;\n    } else f = i = k = 0;\n    h = j * f - b * i;\n    l = b * k - c * f;\n    o = c * i - j * k;\n    m = Math.sqrt(h * h + l * l + o * o);\n    if (m) {\n        m = 1 / m;\n        h *= m;\n        l *= m;\n        o *= m;\n    } else o = l = h = 0;\n    d[0] = k;\n    d[1] = h;\n    d[2] = c;\n    d[3] = 0;\n    d[4] = i;\n    d[5] = l;\n    d[6] = j;\n    d[7] = 0;\n    d[8] = f;\n    d[9] =\n        o;\n    d[10] = b;\n    d[11] = 0;\n    d[12] = -(k * e + i * g + f * a);\n    d[13] = -(h * e + l * g + o * a);\n    d[14] = -(c * e + j * g + b * a);\n    d[15] = 1;\n    return d;\n};\n\n\nmat4.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ']';\n};\n\n\nvar quat4 = {};\n\n\nquat4.create = function (a) {\n    var b = new Array(4);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n    }\n    return b;\n};\n\n\nquat4.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    return b;\n};\n\n\nquat4.calculateW = function (a, b) {\n    var c = a[0],\n        d = a[1],\n        e = a[2];\n    if (!b || a == b) {\n        a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n        return a;\n    }\n    b[0] = c;\n    b[1] = d;\n    b[2] = e;\n    b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n    return b;\n};\n\n\nquat4.inverse = function (a, b) {\n    if (!b || a == b) {\n        a[0] *= 1;\n        a[1] *= 1;\n        a[2] *= 1;\n        return a;\n    }\n    b[0] = -a[0];\n    b[1] = -a[1];\n    b[2] = -a[2];\n    b[3] = a[3];\n    return b;\n};\n\n\nquat4.length = function (a) {\n    var b = a[0],\n        c = a[1],\n        d = a[2];\n    a = a[3];\n    return Math.sqrt(b * b + c * c + d * d + a * a);\n};\n\n\nquat4.normalize = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = Math.sqrt(c * c + d * d + e * e + g * g);\n    if (f == 0) {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        b[3] = 0;\n        return b;\n    }\n    f = 1 / f;\n    b[0] = c * f;\n    b[1] = d * f;\n    b[2] = e * f;\n    b[3] = g * f;\n    return b;\n};\n\n\nquat4.multiply = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1],\n        g = a[2];\n    a = a[3];\n    var f = b[0],\n        h = b[1],\n        i = b[2];\n    b = b[3];\n    c[0] = d * b + a * f + e * i - g * h;\n    c[1] = e * b + a * h + g * f - d * i;\n    c[2] = g * b + a * i + d * h - e * f;\n    c[3] = a * b - d * f - e * h - g * i;\n    return c;\n};\n\n\nquat4.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1],\n        g = b[2];\n    b = a[0];\n    var f = a[1],\n        h = a[2];\n    a = a[3];\n    var i = a * d + f * g - h * e,\n        j = a * e + h * d - b * g,\n        k = a * g + b * e - f * d;\n    d = -b * d - f * e - h * g;\n    c[0] = i * a + d * -b + j * -h - k * -f;\n    c[1] = j * a + d * -f + k * -b - i * -h;\n    c[2] = k * a + d * -h + i * -f - j * -b;\n    return c;\n};\n\n\nquat4.toMat3 = function (a, b) {\n    b || (b = mat3.create());\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = c + c,\n        h = d + d,\n        i = e + e,\n        j = c * f,\n        k = c * h;\n    c = c * i;\n    var l = d * h;\n    d = d * i;\n    e = e * i;\n    f = g * f;\n    h = g * h;\n    g = g * i;\n    b[0] = 1 - (l + e);\n    b[1] = k - g;\n    b[2] = c + h;\n    b[3] = k + g;\n    b[4] = 1 - (j + e);\n    b[5] = d - f;\n    b[6] = c - h;\n    b[7] = d + f;\n    b[8] = 1 - (j + l);\n    return b;\n};\n\n\nquat4.toMat4 = function (a, b) {\n    b || (b = mat4.create());\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = c + c,\n        h = d + d,\n        i = e + e,\n        j = c * f,\n        k = c * h;\n    c = c * i;\n    var l = d * h;\n    d = d * i;\n    e = e * i;\n    f = g * f;\n    h = g * h;\n    g = g * i;\n    b[0] = 1 - (l + e);\n    b[1] = k - g;\n    b[2] = c + h;\n    b[3] = 0;\n    b[4] = k + g;\n    b[5] = 1 - (j + e);\n    b[6] = d - f;\n    b[7] = 0;\n    b[8] = c - h;\n    b[9] = d + f;\n    b[10] = 1 - (j + l);\n    b[11] = 0;\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\n\nquat4.slerp = function (a, b, c, d) {\n    d || (d = a);\n    var e = c;\n    if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;\n    d[0] = 1 - c * a[0] + e * b[0];\n    d[1] = 1 - c * a[1] + e * b[1];\n    d[2] = 1 - c * a[2] + e * b[2];\n    d[3] = 1 - c * a[3] + e * b[3];\n    return d;\n};\n\n\nquat4.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ']';\n};\n\nexport {vec2, vec3, vec4, mat3, mat4};\n\n","\nvar platform = {\n\n    initialized : false,\n\n    init: function () {\n\n        var self = platform;\n\n        self.browser = self.searchString(self.dataBrowser) || 'An unknown browser';\n        self.version = self.searchVersion(navigator.userAgent.toLowerCase()) || self.searchVersion(navigator.appVersion) || 'an unknown version';\n        self.OS = self.searchString(self.dataOS) || 'an unknown os: ua: ' + navigator.userAgent + ' pl: ' + navigator.platform;\n\n        self.mobile = (self.OS == 'iphone/ipod' || self.OS == 'android' || self.OS == 'ipad' || self.OS == 'windows ce'  || self.OS == 'windows phone' || self.OS == 'kindle');\n        self.mobileAndroid = (self.OS == 'android');\n        self.initialized = true;\n    },\n\n    getBrowser : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.browser;\n    },\n\n    getBrowserVersion : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.browser;\n    },\n\n    getOS : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.browser;\n    },\n\n    isMobile : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.mobile;\n    },\n    \n    isAndroid : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.mobileAndroid;\n    },\n\n    searchString: function (data) {\n        var self = platform;\n        for (var i=0; i<data.length; i++) {\n            var dataString = data[i].string;\n            var dataProp = data[i].prop;\n            self.versionSearchString = data[i].versionSearch || data[i].identity;\n\n            if (dataString) {\n                if (dataString.toLowerCase().indexOf(data[i].subString) != -1) {\n                    if (data[i].version != null) {\n                        self.version = data[i].version;\n                    }\n                    return data[i].identity;\n                }\n            } else if (dataProp) {\n                return data[i].identity;\n            }\n        }\n    },\n\n    searchVersion: function (dataString) {\n        var self = platform;\n        if (self.version != null) {\n            return self.version;\n        }\n        var index = dataString.indexOf(self.versionSearchString);\n        if (index == -1) return;\n        return parseFloat(dataString.substring(index+self.versionSearchString.length+1));\n    },\n\n    dataBrowser: [\n        {\n            string: navigator.userAgent,\n            subString: 'chrome',\n            identity: 'chrome'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'firefox',\n            identity: 'firefox'\n        },\n        {\n            string: navigator.vendor,\n            subString: 'apple',\n            identity: 'safari',\n            versionSearch: 'version'\n        },\n        {\n            prop: window.opera,\n            identity: 'opera',\n            versionSearch: 'version'\n        },\n        {\n            string: navigator.vendor,\n            subString: 'icab',\n            identity: 'icab'\n        },\n        {\n            string: navigator.vendor,\n            subString: 'kde',\n            identity: 'konqueror'\n        },\n        {\n            string: navigator.vendor,\n            subString: 'camino',\n            identity: 'camino'\n        },\n        {       // for newer Netscapes (6+)\n            string: navigator.userAgent,\n            subString: 'netscape',\n            identity: 'netscape'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'msie',\n            identity: 'explorer',\n            versionSearch: 'msie'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'trident/',\n            identity: 'explorer',\n            version: '11'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'edge/',\n            identity: 'explorer',\n            version: '12'\n        },\n        {   string: navigator.userAgent,\n            subString: 'omniweb',\n            versionSearch: 'omniweb/',\n            identity: 'omniweb'\n        },\n        {   string: navigator.userAgent,\n            subString: 'silk',\n            versionSearch: 'silk/',\n            identity: 'silk'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'gecko',\n            identity: 'mozilla',\n            versionSearch: 'rv'\n        },\n        {       // for older Netscapes (4-)\n            string: navigator.userAgent,\n            subString: 'mozilla',\n            identity: 'netscape',\n            versionSearch: 'mozilla'\n        }\n    ],\n\n    dataOS : [\n        {\n            string: navigator.userAgent,\n            subString: 'windows ce',\n            identity: 'windows ce'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'windows phone',\n            identity: 'windows phone'\n        },\n        {\n            string: navigator.platform,\n            subString: 'win',\n            identity: 'windows'\n        },\n        {\n            string: navigator.platform,\n            subString: 'mac',\n            identity: 'mac'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'iphone',\n            identity: 'iphone/ipod'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'ipod',\n            identity: 'iphone/ipod'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'ipad',\n            identity: 'ipad'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'android',\n            identity: 'android'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'silk',\n            identity: 'kindle'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'blackberry',\n            identity: 'blackberry'\n        },\n        {\n            string: navigator.platform,\n            subString: 'linux',\n            identity: 'linux'\n        }\n    ]\n\n};\n\nexport {platform};\n\n","\nvar utilsUrl = {};\n\n\nutilsUrl.isSameOrigin = function(url) {\n    if (typeof url !== 'string') {\n        return false;\n    }\n    var docHost = document.location.hostname;\n    var parser = utilsUrl.parse(url);\n    return parser['hostname'] === docHost;\n};\n\n\nutilsUrl.parse = function(url) {\n    if (typeof url !== 'string') {\n        return null;\n    }\n\n    var parser = document.createElement('a');\n    parser['href'] = url;\n    return parser;\n};\n\n\nutilsUrl.getParamsFromUrl = function(url) {\n    var parser = utilsUrl.parse(url);\n    var queryString = {};\n    var query = parser['search'].substring(1);\n    var vars = query.split('&');\n    if (!(vars.length == 1 && vars[0] == '')) {\n        for (var i=0; i < vars.length; i++) {\n            var pair = vars[i].split('=');\n            if (typeof queryString[pair[0]] === 'undefined') {\n                queryString[pair[0]] = pair[1];\n            } else if (typeof queryString[pair[0]] === 'string') {\n                var arr = [ queryString[pair[0]], pair[1] ];\n                queryString[pair[0]] = arr;\n            } else {\n                queryString[pair[0]].push(pair[1]);\n            }\n        }\n    }\n    return queryString;\n};\n\n\nutilsUrl.getHost = function(url) {\n    var location = document.createElement('a');\n    location.href = url;\n    return location.hostname; \n};\n\n\nutilsUrl.getSchema = function(url) {\n    //if (window.location.href.indexOf(\"file://\") != -1) {\n    if (url.indexOf('http://') != -1) {\n        return 'http:';\n    } else if (url.indexOf('https://') != -1) {\n        return 'https:';\n    } else {\n        var location = document.createElement('a');\n        location.href = url;\n        return location.protocol;\n    }\n};\n\n\nutilsUrl.getOrigin = function(url) {\n    var location = document.createElement('a');\n    location.href = url;\n\n    if (!location.origin) {  //IE11 hack\n      return location.protocol + \"//\" + location.hostname + (location.port ? ':' + location.port: '');\n    }\n\n    return location.origin; \n};\n\n\nutilsUrl.getBase = function(url) {\n    return url.split('?')[0].split('/').slice(0, -1).join('/')+'/';\n};\n\n\nutilsUrl.makeAbsolute = function(href) {\n    var link = document.createElement(\"a\");\n    link.href = href;\n    return link.href;\n};\n\nutilsUrl.getProcessUrl = function(url, originUrl) {\n    if (!url || !originUrl) {\n        return url;\n    }\n\n    url = url.trim();\n    originUrl= originUrl.trim();\n    var baseUrl = utilsUrl.getBase(originUrl);\n    var baseUrlSchema = utilsUrl.getSchema(originUrl);\n    var baseUrlOrigin = utilsUrl.getOrigin(originUrl); \n   \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return baseUrlOrigin + url;\n    } else {  //relative\n        return baseUrl + url; \n    }\n};\n\n\nexport {utilsUrl};\n","\nimport {math as math_} from './math';\nimport {utilsUrl as utilsUrl_} from './url';\n\n//get rid of compiler mess\nvar math = math_;\nvar utilsUrl = utilsUrl_;\n\n\nvar utils = {};\nutils.useCredentials = false;\nutils.instanceCounter = 0;\n\n\nutils.validateBool = function(value, defaultValue) {\n    if (typeof value === 'boolean') {\n        return value;\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.validateNumber = function(value, minValue, maxValue, defaultValue) {\n    if (typeof value === 'number') {\n        return math.clamp(value, minValue, maxValue);\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.validateNumberArray = function(array, arraySize, minValues, maxValues, defaultValues) {\n    if (Array.isArray(array) && array.length == arraySize) {\n        for (var i = 0; i < arraySize; i++) {\n            array[i] = math.clamp(array[i], minValues[i], maxValues[i]);\n        }\n        return array;\n    } else {\n        return defaultValues;\n    }\n};\n\n\nutils.validateString = function(value, defaultValue) {\n    if (typeof value === 'string') {\n        return value;\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.padNumber = function(n, width) {\n    var z = '0';\n\n    if (n < 0) {\n        n = (-n) + '';\n        width--;     //7\n        return n.length >= width ? ('-' + n) : '-' + (new Array(width - n.length + 1).join(z) + n);\n    } else {\n        n = n + '';\n        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n    }\n};\n\n\nutils.decodeFloat16 = function(binary) {\n    var exponent = (binary & 0x7C00) >> 10;\n    var fraction = binary & 0x03FF;\n    return (binary >> 15 ? -1 : 1) * (\n        exponent ?\n        (\n            exponent === 0x1F ?\n            fraction ? NaN : Infinity :\n            Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n        ) :\n        6.103515625e-5 * (fraction / 0x400)\n    );\n};\n\n\nutils.simpleFmtObj = (function obj(str, obj) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    return str.replace(/\\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\\}/g, function(s, match) {\n        return (match in obj ? obj[match] : s);\n    });\n});\n\n\nutils.simpleWikiLinks = (function obj(str, plain) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    var str2 = utils.simpleFmtObj(str, {'copy':'&copy;', 'Y': (new Date().getFullYear())}); \n    \n    return str2.replace(/\\[([^\\]]*)\\]/g, function(s, match) {\n        match  = match.trim();\n        var urls = match.split(' ');//, 1);\n        \n        if (urls[0].indexOf('//') != -1) {\n            if (plain) {\n                if (urls.length > 1) {\n                    return '' + match.substring(urls[0].length);\n                } else {\n                    return '' + urls[0];\n                }\n            } else {\n                if (urls.length > 1) {\n                    return '<a href=' + urls[0] + ' target=\"blank\">' + match.substring(urls[0].length)+'</a>';\n                } else {\n                    return '<a href=' + urls[0] + ' target=\"blank\">' + urls[0]+'</a>';\n                }\n            }\n        }\n        \n        return match;\n    });\n});\n\n\nutils.simpleFmtObjOrCall = (function obj(str, obj, call) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    return str.replace(/\\{([$a-zA-Z(-9][$a-zA-Z(-9]*)\\}/g, function(s, match) {\n        return (match in obj ? obj[match] : call(match));\n    });\n});\n\n\nutils.getABGRFromHexaCode = (function(code) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(code);\n\n    return result ?\n    [ parseInt(result[4], 16),\n        parseInt(result[3], 16),\n        parseInt(result[2], 16),\n        parseInt(result[1], 16)]\n    : [0,0,0,255];\n});\n\n\nutils.stringifyFunction = (function(fn) {\n    // Stringify the code\n    return '(' + fn + ').call(self);';\n});\n\n\nutils.isPowerOfTwo = (function(value) {\n    return (value & (value - 1)) === 0 && value !== 0;\n});\n\n\nutils.nearestPowerOfTwo = (function(value) {\n    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));\n});   \n\n\nutils.fitToPowerOfTwo = (function(value) {\n    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n});   \n\n\nutils.getHash = function(str) {\n    if (!str || str.length === 0) {\n        return 0;    \n    }\n\n    var hash = 0, c;\n    for (var i = 0, li = str.length; i < li; i++) {\n        c   = str.charCodeAt(i);\n        hash  = ((hash << 5) - hash) + c;\n        hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n};\n\n\nutils.convertRGB2YCbCr = function(r, g, b) {\n  return [( .299 * r + .587 * g  +  0.114 * b) + 0,\n          ( -.169 * r + -.331 * g +  0.500 * b) + 128,\n          ( .500 * r + -.419 * g +  -0.081 * b) + 128];\n};\n\n\nutils.convertYCbCr2RGB = function(y, cb, cr) {\n  return [1 * y +  0 * (cb-128)      +  1.4 * (cr-128),\n          1 * y +  -.343 * (cb-128)  +  -.711 * (cr-128),\n          1 * y +  1.765 * (cb-128)  +  0 * (cr-128)];\n};\n\n\nutils.convertHSL2RGB = function(h, s, l){\n   var r, g, b, m, c, x;\n\n    h /= 60;\n    if (h < 0) h = 6 - (-h % 6);\n    h %= 6;\n\n    s = Math.max(0, Math.min(1, s / 100));\n    l = Math.max(0, Math.min(1, l / 100));\n\n    c = (1 - Math.abs((2 * l) - 1)) * s;\n    x = c * (1 - Math.abs((h % 2) - 1));\n\n    if (h < 1) {\n        r = c, g = x, b = 0;\n    } else if (h < 2) {\n        r = x, g = c, b = 0;\n    } else if (h < 3) {\n        r = 0, g = c, b = x;\n    } else if (h < 4) {\n        r = 0, g = x, b = c;\n    } else if (h < 5) {\n        r = x, g = 0, b = c;\n    } else {\n        r = c, g = 0, b = x;\n    }\n\n    m = l - c / 2\n    \n    return [(r + m),\n            (g + m),\n            (b + m)];\n}\n\n\nutils.getHashColor = function(str) {\n    var h = utils.getHash(str);\n    var c = utils.convertRGB2YCbCr(h&255,(h>>8)&255,(h>>16)&255);\n    c[0] = math.clamp(c[0], 50, 200);\n    return utils.convertRGB2YCbCr(c[0],c[1],c[2]);\n};\n\n\nutils.getHashColor2 = function(counter) {\n    var h = Math.floor(counter / 18);\n    var l = 50;\n\n    if (h >= 1) {\n        if (h % 2) {\n            l = 50 + ((l * 10) % 30);\n        } else {\n            l = 50 - (((l-1) * 10) % 30);\n        }\n     }\n\n    h = (counter % 18) * 20;\n\n    return utils.convertHSL2RGB(h,100,l);\n};\n\n\nutils.loadText = function(path, onLoaded, onError, withCredentials, xhrParams) {\n    utils.loadJSON(path, onLoaded, onError, true, withCredentials, xhrParams);\n};\n\n\nutils.loadXML = function(path, onLoaded, onError, withCredentials, xhrParams) {\n    var onLoaded2 = (function(data){\n        var parser = new DOMParser();\n        data = parser.parseFromString(data, 'text/xml');\n        if (onLoaded) {\n            onLoaded(data);\n        }\n    });\n\n    utils.loadJSON(path, onLoaded2, onError, true, withCredentials, xhrParams);\n};\n\n\nutils.loadJSON = function(path, onLoaded, onError, skipParse, withCredentials, xhrParams) {\n    var xhr = new XMLHttpRequest();\n\n    //xhr.onload  = (function() {\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    onError(xhr.status);\n                }\n                break;\n            }\n    \n            var data = xhr.response;\n            var parsedData = data;\n                \n            if (!skipParse) {\n                try {\n                        //var parsedData = skipParse ? data : eval(\"(\"+data+\")\");\n                    parsedData = JSON.parse(data);\n                } catch(e) {\n                    // eslint-disable-next-line\n                    console.log('JSON Parse Error ('+path+'): ' + (e['message'] ? e['message'] : ''));\n                        \n                    if (onError ) {\n                        onError(xhr.status);\n                    }\n                \n                    return;\n                }\n            }\n                \n            if (onLoaded) {\n                onLoaded(parsedData);\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n\n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET',  path, true);\n    xhr.withCredentials = withCredentials;\n    \n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    if (xhrParams && xhrParams['charset']) {\n        xhr.overrideMimeType('text/xml; charset=' + xhrParams['charset']);\n        //xhr.setRequestHeader('Content-type', xhrParams['Content-type']);\n    }\n    \n    xhr.send('');\n};\n\n\nutils.loadBinary = function(path, onLoaded, onError, withCredentials, xhrParams, responseType) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    onError(xhr.status);\n                }\n                break;\n            }\n    \n            var abuffer = xhr.response;\n                    \n            if (!abuffer) {\n                if (onError) {\n                    onError();\n                }\n                break;\n            }\n                    \n                    //if (!responseType || responseType == \"arraybuffer\") {\n                        //var data = new DataView(abuffer);\n                    //} else {\n                      //  var data = abuffer;\n                    //}\n    \n            if (onLoaded) {\n                onLoaded(abuffer);\n            }\n    \n            break;\n    \n        default:\n    \n            if (onError) {\n                onError();\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n    \n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET', path, true);\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nutils.headRequest = function(url, onLoaded, onError, withCredentials, xhrParams) { \n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n            if (onLoaded != null) {\n                onLoaded(xhr.getAllResponseHeaders(), xhr.status);\n                    //onLoaded(xhr.getResponseHeader(\"X-VE-Tile-Info\"), xhr.status);\n            }\n            break;\n    \n        default:\n    \n            if (onError != null) {\n                onError();\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n\n    xhr.onerror  = (function() {\n        if (onError != null) {\n            onError();\n        }\n    }).bind(this);\n\n    xhr.open('HEAD', url, true);\n    //xhr.responseType = responseType ? responseType : \"arraybuffer\";\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nutils.loadImage = function(url, onload, onerror, withCredentials, direct) {\n    var image = new Image();\n    image.onerror = onerror;\n    image.onload = onload;\n\n    if (!direct){\n        image.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';\n    }\n\n    image.src = url;\n    return image;\n};\n\n\nutils.getParamsFromUrl = function(url) {\n    return utilsUrl.getParamsFromUrl(url);\n};\n\n\n//var textDecoderUtf8 = null; //(typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\nvar textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\n\nutils.unint8ArrayToString = function(array) {\n    if (textDecoderUtf8) {\n        return textDecoderUtf8.decode(array);\n    } else {\n//        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\n\n        /*\n        var buff = new Uint16Array(array.buffer, array.byteOffset, array.byteLength);\n        var getChar = String.fromCharCode;\n        //var buff2 = new Array(buff.length);\n        var str = '';\n\n        for (var i = 0, li = buff.length; i < li; i++) {\n            //buff2[i] = getChar(buff[i]);\n            str += getChar(buff[i]);\n        }\n\n        return str;\n        //return buff2.join('');\n        */\n\n        var s = '';\n        //var code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        var code_points2 = new Uint8Array(array.byteLength);\n        code_points2.set(array);\n        var code_points = new Uint32Array(code_points2.buffer);\n\n        for (var i = 0, li = code_points.length; i < li; ++i) {\n          var cp = code_points[i];\n          if (cp <= 0xFFFF) {\n            s += String.fromCharCode(cp);\n          } else {\n            cp -= 0x10000;\n            s += String.fromCharCode((cp >> 10) + 0xD800,\n                                     (cp & 0x3FF) + 0xDC00);\n          }\n        }\n        return s;\n\n    }\n}\n\n\nexport {utils};\n\n// only implement if no native implementation is available\n/*\nif (typeof Array.isArray === 'undefined') {\n  Array.isArray = (function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  });\n}*/\n"],"sourceRoot":""}