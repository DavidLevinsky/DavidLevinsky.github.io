{"version":3,"sources":["webpack://vts/webpack/bootstrap","webpack://vts/./src/core/map/loader/worker-globals.js","webpack://vts/./src/core/map/loader/worker-mesh.js","webpack://vts/./src/core/map/loader/worker-main.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","globals","parseSubmesh","mesh","stream","submesh","valid","streamData","data","flags","getUint8","index","version","surfaceReference","textureLayer","getUint16","textureLayer2","bboxMin","bboxMax","getFloat64","parseHeader","tmpVertices","tmpExternalUVs","tmpInternalUVs","uint8Data","use16bit","config","map16bitMeshes","onlyOneUVs","mapOnlyOneUVs","numVertices","quant","vindex","li","bmin","bmax","center","scale","Math","abs","max","multiplier","externalUVs","vertices","Uint16Array","Float32Array","x","y","z","cx","cy","cz","mx","my","mz","sx","sy","sz","res","parseDelta","uvindex","numUVs","quantU","quantV","multiplierU","multiplierV","internalUVs","numFaces","indices","onlyExternalIndices","mapIndexBuffers","onlyInternalIndices","onlyIndices","v1","v2","v3","vv1","vv2","vv3","vtmp","eUVs","iUVs","high","parseWord","sindex","length","size","byteLength","faces","parseVerticesAndFaces2","uvfactor","parseVerticesAndFaces","magic","String","fromCharCode","Uint8Array","buffer","meanUndulation","numSubmeshes","submeshes","gpuSize","push","transferables","packedEvents","packedTransferables","postPackedMessage","message","mapPackLoaderEvents","concat","postMessage","self","onmessage","e","path","onLoaded","onError","withCredentials","xhrParams","responseType","kind","xhr","XMLHttpRequest","onreadystatechange","readyState","status","abuffer","response","createImageBitmap","then","bitmap","this","DataView","open","setRequestHeader","send","loadBinary"],"mappings":"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","file":"e31ae36eedf805edb5df.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\nvar globals = {};\n\nexport {globals};\n","\nimport {globals as globals_} from './worker-globals.js';\n\n//get rid of compiler mess\nvar globals = globals_;\n\nvar flagsInternalTexcoords =  1;\nvar flagsExternalTexcoords =  2;\nvar flagsPerVertexUndulation =  4;\nvar flagsTextureMode =  8;\n\n\nfunction parseMesh(stream) {\n    /*\n    struct MapMesh {\n        struct MapMeshHeader {\n            char magic[2];                // letters \"ME\"\n            ushort version;               // currently 1\n            double meanUndulation;        // read more about undulation below\n            ushort numSubmeshes;          // number of submeshes\n        } header;\n        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property\n    };\n    */\n\n    var mesh = {}, i, li, submesh;\n\n    //parase header\n    var streamData = stream.data;\n    var magic = '';\n\n    if (streamData.length < 2) {\n        return false;\n    }\n\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n\n    if (magic != 'ME') {\n        return false;\n    }\n\n    mesh.version = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    if (mesh.version > 3) {\n        return false;\n    }\n    \n    stream.uint8Data = new Uint8Array(stream.data.buffer);\n\n    mesh.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;\n    mesh.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    mesh.submeshes = [];\n    mesh.gpuSize = 0; \n    mesh.faces = 0;\n    mesh.size = 0;\n\n    var use16bit = globals.config.map16bitMeshes;\n\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\n        var submesh = parseSubmesh(mesh, stream);\n        if (submesh.valid) {\n            mesh.submeshes.push(submesh); \n            mesh.size += submesh.size;\n            mesh.faces += submesh.faces;\n\n            //aproximate size\n            mesh.gpuSize += submesh.size;\n        }\n    }\n    \n    mesh.numSubmeshes = mesh.submeshes.length;\n\n    //prevent minification\n\n    var submeshes = [];\n    var transferables = [];\n\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\n        submesh = mesh.submeshes[i];\n        submeshes.push({\n\n            'bboxMax': submesh.bboxMax,\n            'bboxMin': submesh.bboxMin,\n            'externalUVs': (submesh.externalUVs) ? submesh.externalUVs.buffer : null,\n            'faces': submesh.faces,\n            'flags': submesh.flags,\n            'gpuSize': submesh.gpuSize,\n            'indices': (submesh.indices) ? submesh.indices.buffer : null,\n            'internalUVs': (submesh.internalUVs) ? submesh.internalUVs.buffer : null,\n            'size': submesh.size,\n            'surfaceReference': submesh.surfaceReference,\n            'textureLayer': submesh.textureLayer,\n            'textureLayer2': submesh.textureLayer2,\n            //'valid': submesh.valid\n            'vertices': submesh.vertices.buffer\n\n        });\n\n        if (submesh.externalUVs) transferables.push(submesh.externalUVs.buffer);\n        if (submesh.internalUVs) transferables.push(submesh.internalUVs.buffer);\n        if (submesh.vertices) transferables.push(submesh.vertices.buffer);\n        if (submesh.indices) transferables.push(submesh.indices.buffer);\n    }\n\n    return { mesh:{\n               'faces': mesh.faces,\n               'gpuSize': mesh.gpuSize,\n               'meanUndulation': mesh.meanUndulation,\n               'numSubmeshes': mesh.numSubmeshes,\n               'size': mesh.size,\n               'submeshes': mesh.submeshes,\n               'version': mesh.version\n             },\n             transferables:transferables\n           };\n};\n\n\nfunction parseSubmesh(mesh, stream) {\n    /*\n    struct MapSubmesh {\n        struct MapSubmeshHeader header;\n        struct VerticesBlock vertices;\n        struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )\n        struct FacesBlock faces;\n    };\n    */\n\n    var submesh = { valid:true };\n\n    parseHeader(mesh, submesh, stream);\n    if (mesh.version >= 3) {\n        parseVerticesAndFaces2(mesh, submesh, stream);\n    } else {\n        parseVerticesAndFaces(mesh, submesh, stream);\n    }\n\n    return submesh;\n};\n\n\nfunction parseHeader(mesh, submesh, stream) {\n    /*\n    struct MapSubmeshHeader {\n        char flags;                    // bit 0 - contains internal texture coords\n                                       // bit 1 - contains external texture coords\n                                       // bit 2 - contains per vertex undulation\n                                       // bit 3 - texture mode (0 - internal, 1 - external)\n        \n        uchar surfaceReference;        // reference to the surface of origin, see bellow\n        ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id\n        double boundingBox[2][3];      // read more about bounding box bellow\n    };\n    */\n\n    //debugger\n    var streamData = stream.data;\n\n    submesh.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    if (mesh.version > 1) {\n        submesh.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;\n    } else {\n        submesh.surfaceReference = 0;\n    }\n\n    submesh.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;\n    submesh.textureLayer2 = submesh.textureLayer; //hack for presentation\n\n    var bboxMin = [];\n    var bboxMax = [];\n\n    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n\n    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    \n    submesh.bboxMin = bboxMin;\n    submesh.bboxMax = bboxMax;\n};\n\n\nfunction parseVerticesAndFaces(mesh, submesh, stream) {\n    /*\n    struct VerticesBlock {\n        ushort numVertices;              // number of vertices\n\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n            // vertex coordinates\n            ushort x;\n            ushort y;\n            ushort z;\n\n            // if header.flags & ( 1 << 1 ): external texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort eu;\n            ushort ev;\n\n            // if header.flags & ( 1 << 2 ): undulation delta\n            float16 undulationDelta;\n        } vertices[];\n    };\n    */\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n\n    var use16bit = globals.config.map16bitMeshes;\n\n    var numVertices = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        submesh.valid = false;\n    }\n\n    var internalUVs = null;\n    var externalUVs = null;\n    var onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\n    var tmpVertices, tmpExternalUVs, tmpInternalUVs;\n\n    var vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n\n    if (submesh.flags & flagsExternalTexcoords) {\n        if (onlyOneUVs) {\n            externalUVs = true;\n        } else {\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n        }\n    }\n\n    var uvfactor = use16bit ? 1.0 : (1.0 / 65535);\n    var vindex = 0;\n    var uvindex = 0;\n    var i, li;\n\n    for (i = 0; i < numVertices; i++) {\n        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;\n        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;\n        vindex += 3;\n\n        if (externalUVs) {\n            if (!onlyOneUVs) {\n                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;\n                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;\n                uvindex += 2;\n            }\n            index += 10;\n        } else {\n            index += 6;\n        }\n    }\n\n\n    tmpVertices = vertices;\n    tmpExternalUVs = externalUVs;\n   \n    /*\n    struct TexcoorsBlock {\n        ushort numTexcoords;              // number of texture coordinates\n\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n            // internal texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort u;\n            ushort v;\n        } texcoords[];\n    };\n    */\n\n    if (submesh.flags & flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n    \n        internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        //var uvfactor = 1.0 / 65535;\n    \n        for (i = 0, li = numUVs * 2; i < li; i+=2) {\n            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;\n            index += 4;\n        }\n    \n        tmpInternalUVs = internalUVs;\n    }\n\n    /*\n    struct FacesBlock {\n        ushort numFaces;              // number of faces\n\n        struct Face {                 // array of faces, size of array is defined by numFaces property\n\n            ushort v[3]; // array of indices to stored vertices\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n        } faces[];\n    };\n    */\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\n    var onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (submesh.flags & flagsInternalTexcoords) {\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = tmpVertices;\n    var eUVs = tmpExternalUVs;\n    var iUVs = tmpInternalUVs;\n    var v1, v2, v3, vv1, vv2, vv3, sindex;\n\n    if (onlyExternalIndices) {\n        vertices = tmpVertices;\n        externalUVs = tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = tmpInternalUVs;\n    }\n\n    for (i = 0; i < numFaces; i++) {\n        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));\n        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));\n        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));\n\n        if (onlyIndices) {\n            vindex = i * 3;\n\n            if (internalUVs != null) {\n                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n\n                vertices[vv1*3] = vtmp[v1*3];\n                vertices[vv1*3+1] = vtmp[v1*3+1];\n                vertices[vv1*3+2] = vtmp[v1*3+2];\n\n                vertices[vv2*3] = vtmp[v2*3];\n                vertices[vv2*3+1] = vtmp[v2*3+1];\n                vertices[vv2*3+2] = vtmp[v2*3+2];\n\n                vertices[vv3*3] = vtmp[v3*3];\n                vertices[vv3*3+1] = vtmp[v3*3+1];\n                vertices[vv3*3+2] = vtmp[v3*3+2];\n\n                indices[vindex] = vv1;\n                indices[vindex+1] = vv2;\n                indices[vindex+2] = vv3;\n\n                index += 12;\n            } else {\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n\n                index += 6;\n            }\n\n        } else {\n            vindex = i * (3 * 3);\n\n            sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n\n            if (internalUVs != null) {\n                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n                index += 12;\n\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            } else {\n                index += 6;\n            }\n        }\n    }\n\n    submesh.vertices = vertices;\n    submesh.internalUVs = internalUVs;\n    submesh.externalUVs = externalUVs;\n    submesh.indices = indices;\n\n    tmpVertices = null;\n    tmpInternalUVs = null;\n    tmpExternalUVs = null;\n\n    stream.index = index;\n\n    submesh.size = submesh.vertices.byteLength;\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\n    submesh.faces = numFaces;\n};\n\n\nfunction parseWord(data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);\n        res[1] += 2;\n    } else {\n        res[0] = value;\n        res[1] ++;\n    }\n};\n\n\nfunction parseDelta(data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        value = (value & 0x7f) | (data[res[1]+1] << 7);\n\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] += 2;\n        } else {\n            res[0] = (value >> 1); \n            res[1] += 2;\n        }\n    } else {\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] ++;\n        } else {\n            res[0] = (value >> 1); \n            res[1] ++;\n        }\n    }\n};\n\n\nfunction parseVerticesAndFaces2(mesh, submesh, stream) {\n    /*\n    struct VerticesBlock {\n        ushort numVertices;              // number of vertices\n        ushort geomQuantCoef;            // geometry quantization coefficient\n\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n            // vertex coordinates\n            delta x;\n            delta y;\n            delta z;\n        } vertices[];\n    };\n    */\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n\n    var use16bit = globals.config.map16bitMeshes;\n    var onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\n    var tmpVertices, tmpExternalUVs, tmpInternalUVs;\n\n    var numVertices = data.getUint16(index, true); index += 2;\n    var quant = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        submesh.valid = false;\n    }\n\n    var bmin = submesh.bboxMin;\n    var bmax = submesh.bboxMax;\n\n    var center = [(bmin[0] + bmax[0])*0.5, (bmin[1] + bmax[1])*0.5, (bmin[2] + bmax[2])*0.5];\n    var scale = Math.abs(Math.max(bmax[0] - bmin[0], bmax[1] - bmin[1], bmax[2] - bmin[2]));\n\n    var multiplier = 1.0 / quant;\n    var externalUVs = null;\n\n    var vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n    var vindex;\n    \n    var x = 0, y = 0,z = 0;\n    var cx = center[0], cy = center[1], cz = center[2];\n    var mx = bmin[0];\n    var my = bmin[1];\n    var mz = bmin[2];\n    var sx = 1.0 / (bmax[0] - bmin[0]);\n    var sy = 1.0 / (bmax[1] - bmin[1]);\n    var sz = 1.0 / (bmax[2] - bmin[2]);\n    \n    var res = [0, index];\n    var i, li, t;\n\n    if (use16bit) {\n        for (i = 0; i < numVertices; i++) {\n            parseDelta(uint8Data, res);\n            x += res[0];\n            parseDelta(uint8Data, res);\n            y += res[0];\n            parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            t = ((x * multiplier * scale + cx) - mx) * sx;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex] = t * 65535;\n            t = ((y * multiplier * scale + cy) - my) * sy;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+1] = t * 65535;\n            t = ((z * multiplier * scale + cz) - mz) * sz;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+2] = t * 65535;\n        }\n    } else {\n        for (i = 0; i < numVertices; i++) {\n            parseDelta(uint8Data, res);\n            x += res[0];\n            parseDelta(uint8Data, res);\n            y += res[0];\n            parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;\n            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;\n            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;\n        }\n    }\n    \n    index = res[1];\n\n    if (submesh.flags & flagsExternalTexcoords) {\n        quant = data.getUint16(index, true); index += 2;\n        res[1] = index;\n\n        if (onlyOneUVs) {\n\n            for (i = 0; i < numVertices; i++) {\n                parseDelta(uint8Data, res);\n                parseDelta(uint8Data, res);\n            }\n\n        } else {\n            multiplier = (use16bit) ? (65535 / quant) : (1.0 / quant);\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n            x = 0, y = 0;\n\n            if (use16bit) {\n                for (i = 0; i < numVertices; i++) {\n                    parseDelta(uint8Data, res);\n                    x += res[0];\n                    parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    t = x * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex] = t;\n                    t = y * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex+1] = 65535 - t;\n                }\n            } else {\n                for (i = 0; i < numVertices; i++) {\n                    parseDelta(uint8Data, res);\n                    x += res[0];\n                    parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    externalUVs[uvindex] = x * multiplier;\n                    externalUVs[uvindex+1] = 1 - (y * multiplier);\n                }\n            }\n        }\n    }\n\n    index = res[1];\n\n    tmpVertices = vertices;\n    tmpExternalUVs = externalUVs;\n    \n    /*\n    struct TexcoorsBlock {\n        ushort numTexcoords;              // number of texture coordinates\n\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n            // internal texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort u;\n            ushort v;\n        } texcoords[];\n    };\n    */\n\n    if (submesh.flags & flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n        var quantU = data.getUint16(index, true); index += 2;\n        var quantV = data.getUint16(index, true); index += 2;\n        var multiplierU = (use16bit) ? (65536.0 / quantU) : (1.0 / quantU);\n        var multiplierV = (use16bit) ? (65536.0 / quantV) : (1.0 / quantV);\n        x = 0, y = 0;\n    \n        var internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        res[1] = index;7\n\n        if (use16bit) {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                parseDelta(uint8Data, res);\n                x += res[0];\n                parseDelta(uint8Data, res);\n                y += res[0];\n\n                t = x * multiplierU;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i] = t;\n                t = y * multiplierV;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i+1] = 65535 - t;\n            }\n        } else {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                parseDelta(uint8Data, res);\n                x += res[0];\n                parseDelta(uint8Data, res);\n                y += res[0];\n\n                internalUVs[i] = x * multiplierU;\n                internalUVs[i+1] = 1 - (y * multiplierV);\n            }\n        }\n\n        index = res[1];\n    \n        tmpInternalUVs = internalUVs;\n    }\n\n    /*\n    struct FacesBlock {\n        ushort numFaces;              // number of faces\n\n        struct Face {                 // array of faces, size of array is defined by numFaces property\n\n            ushort v[3]; // array of indices to stored vertices\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n        } faces[];\n    };\n    */\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\n    var onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (submesh.flags & flagsInternalTexcoords) {\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = tmpVertices;\n    var eUVs = tmpExternalUVs;\n    var iUVs = tmpInternalUVs;\n    var high = 0;\n    var v1, v2, v3, vv1, vv2, vv3;\n    res[1] = index;\n\n    for (i = 0; i < numFaces; i++) {\n        parseWord(uint8Data, res);\n        v1 = high - res[0];\n        if (!res[0]) { high++; }\n\n        parseWord(uint8Data, res);\n        v2 = high - res[0];\n        if (!res[0]) { high++; }\n\n        parseWord(uint8Data, res);\n        v3 = high - res[0];\n        if (!res[0]) { high++; }\n\n        if (onlyIndices) {\n            vindex = i * 3;\n            indices[vindex] = v1;\n            indices[vindex+1] = v2;\n            indices[vindex+2] = v3;\n        } else {\n            vindex = i * (3 * 3);\n            var sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n        }\n    }\n\n    if (onlyExternalIndices) {\n        vertices = tmpVertices;\n        externalUVs = tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = tmpInternalUVs;\n    }\n\n    high = 0;\n\n    if (internalUVs != null) {\n        for (i = 0; i < numFaces; i++) {\n            parseWord(uint8Data, res);\n            v1 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            parseWord(uint8Data, res);\n            v2 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            parseWord(uint8Data, res);\n            v3 = high - res[0];\n            if (!res[0]) { high++; }\n\n            if (onlyInternalIndices) {\n                vindex = i * 3;\n\n                vv1 = indices[vindex] * 3;\n                vv2 = indices[vindex+1] * 3;\n                vv3 = indices[vindex+2] * 3;\n\n                vertices[v1*3] = vtmp[vv1];\n                vertices[v1*3+1] = vtmp[vv1+1];\n                vertices[v1*3+2] = vtmp[vv1+2];\n\n                vertices[v2*3] = vtmp[vv2];\n                vertices[v2*3+1] = vtmp[vv2+1];\n                vertices[v2*3+2] = vtmp[vv2+2];\n\n                vertices[v3*3] = vtmp[vv3];\n                vertices[v3*3+1] = vtmp[vv3+1];\n                vertices[v3*3+2] = vtmp[vv3+2];\n\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n            } else {\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            }\n        }\n    }\n\n    index = res[1];\n\n    submesh.vertices = vertices;\n    submesh.internalUVs = internalUVs;\n    submesh.externalUVs = externalUVs;\n    submesh.indices = indices;\n\n    //tmpVertices = null;\n    //tmpInternalUVs = null;\n    //tmpExternalUVs = null;\n\n    stream.index = index;\n\n    submesh.size = submesh.vertices.byteLength;\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\n    submesh.faces = numFaces;\n};\n\nexport {parseMesh};\n\n","\nimport {globals as globals_} from './worker-globals.js';\nimport {parseMesh as parseMesh_} from './worker-mesh.js';\n\n//get rid of compiler mess\nvar globals = globals_;\nvar parseMesh = parseMesh_;\n\nvar packedEvents = [];\nvar packedTransferables = [];\n\nfunction postPackedMessage(message, transferables) {\n\n    if (globals.config.mapPackLoaderEvents) {\n\n        packedEvents.push(message);\n\n        if (transferables) {\n            packedTransferables = packedTransferables.concat(transferables);\n        }\n\n    } else {\n\n        if (transferables) {\n            postMessage(message, transferables);\n        } else {\n            postMessage(message);\n        }\n\n    }\n}\n\nfunction loadBinary(path, onLoaded, onError, withCredentials, xhrParams, responseType, kind) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    postPackedMessage({'command' : 'on-error', 'path': path, 'status':xhr.status});\n                }\n                break;\n            }\n    \n            var abuffer = xhr.response;\n                    \n            if (!abuffer) {\n                if (onError) {\n                    postPackedMessage({'command' : 'on-error', 'path': path});\n                }\n                break;\n            }\n    \n            if (onLoaded) {\n                if (kind == 'direct-texture') {\n                    createImageBitmap(abuffer).then((function(bitmap){\n                        postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': bitmap, 'filesize': abuffer.size}, [bitmap]);                        \n                    }).bind(this));\n                } else if (kind == 'direct-mesh') {\n                    //debugger\n                    var data = parseMesh({data:new DataView(abuffer), index:0});\n                    postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': data.mesh}, data.transferables);\n                } else {\n\n                    postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': abuffer}, [abuffer]);\n                }\n            }\n    \n            break;\n    \n        default:\n    \n            if (onError) {\n                postPackedMessage({'command' : 'on-error', 'path': path});\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n    \n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET', path, true);\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nself.onmessage = function (e) {\n    var message = e.data;\n    var command = message['command'];\n    //var data = message['data'];\n\n    //console.log(\"workeronmessage: \" + command);\n\n    switch(command) {\n\n        case 'config':\n            globals.config = message['data'];\n            break;\n\n        case 'tick':\n\n            if (packedEvents.length > 0) {\n                if (packedTransferables.length > 0) {\n                    postMessage({'command': 'packed-events', 'messages':packedEvents}, packedTransferables);\n                } else {\n                    postMessage({'command': 'packed-events', 'messages':packedEvents});\n                }\n            }\n\n            packedEvents = [];\n            packedTransferables = [];\n\n            break;\n\n        case 'load-binary':\n            loadBinary(message['path'], true, true, message['withCredentials'], message['xhrParams'], message['responseType'], message['kind']);\n            break;\n\n    }\n};\n\n"],"sourceRoot":""}