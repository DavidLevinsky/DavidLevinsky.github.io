{"version":3,"sources":["webpack:///webpack/bootstrap 50b786f7ee11086a9385","webpack:///./src/core/map/geodata-processor/worker-globals.js","webpack:///./src/core/map/geodata-processor/worker-message.js","webpack:///./src/core/map/geodata-processor/worker-text.js","webpack:///./src/core/map/geodata-processor/worker-linestring.js","webpack:///./src/core/map/geodata-processor/worker-pointarray.js","webpack:///./src/core/map/geodata-processor/worker-polygon.js","webpack:///./src/core/map/geodata-processor/worker-bidi.js","webpack:///./src/core/map/geodata-processor/worker-font.js","webpack:///./src/core/map/geodata-processor/worker-main.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;AC/DA;AACA,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,wBAAwB;AACxB,4BAA4B;AAC5B,4BAA4B;AAC5B,cAAc;AACd,iBAAiB;AACjB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,iB;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,yBAAyB,QAAQ;AACjC;;AAEA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA,SAAS,iBAAiB;AAC1B;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA,sCAAsC,QAAQ;AAC9C,yCAAyC;AACzC;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C;;AAE3C,0CAA0C,QAAQ;AAClD,6CAA6C;AAC7C;AACA,KAAK;AACL,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C,0CAA0C,QAAQ;AAClD;;AAEA,8CAA8C,QAAQ;AACtD,mDAAmD;AACnD;AACA;AACA,KAAK;AACL,iCAAiC;AACjC;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEQ;;;;;;;;;;;;;AC/TgE;;AAExE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;;AAEA,kCAAkC;AAClC,+BAA+B;AAC/B,+CAA+C;AAC/C,8BAA8B;AAC9B;;AAEA,oCAAoC,QAAQ;AAC5C,iDAAiD;AACjD,4DAA4D;AAC5D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC;AAClC,+BAA+B;AAC/B,iDAAiD;;AAEjD;AACA;;;AAGA;;AAEA,kE;AACA,8C;AACA;AACA;;AAEA,wDAAwD,QAAQ;AAChE;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B,QAAQ;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,+BAA+B,QAAQ;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D,QAAQ;AACnE;AACA;AACA;;AAEA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,qCAA6D;AAC7D;;AAEA;AACA;;AAEA,8DAA8D;AAC9D,mDAAmD;AACnD,kEAAkE;AAClE,mDAAmD;;AAEnD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kDAAkD;;AAEnE;AACA;AACA,C;;;AAGQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpPmD;;AAErC;;;AAGtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA,4BAA4B;;AAE5B;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,oCAAoC,QAAQ;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAIA;;;;;;;;;;;;;;;;;;;ACpjBgC;AAE0B;AAGwD;AAC5D;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,iF;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4BAA4B;;AAE5B;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAmB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iCAAiC,mDAAmD;AACpF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA,2CAA2C,QAAQ;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa;;;AAGb;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA,uCAAuC,QAAQ;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC,6BAA6B;;AAE7B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB;;AAErB;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB;;AAEjB;;AAEA,mCAAmC,iBAAiB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wIAAwI;AACxI;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,2JAA2J;AAC3J,0DAA0D;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,eAAe,kBAAkB;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,2CAA2C,QAAQ;;AAEnD;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,a;AACA;AACA;;AAEA;;AAEA;AACA,+BAA+B;AAC/B;;;AAGQ;;;;;;;;;;;;;;;;;;ACxjCqC;AAC8D;AAGuC;AAC5F;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,0B;AACA;;AAEA,uDAAuD;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;;AAEA;AACA,4DAA4D;AAC5D;;AAEA;;AAEA,mCAAmC,iBAAiB;;;AAGpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4IAA4I;AAC5I,kEAAkE;AAClE,SAAS;AACT;AACA;AACA;AACA;AACA,4IAA4I;AAC5I,kEAAkE;AAClE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAA2E;AAC3E,uDAAgF;AAChF;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,4IAA4I;AAC5I,oHAAoH;AACpH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAA2E;AAC3E,uDAAgF;AAChF;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,oDAAoD;AACnJ;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,0B;AACA;;AAEA,uDAAuD;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA,uFAAuF,qEAAqE;AAC5J,kFAAkF;AAClF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB;AACvB;AACA;;AAEA,+BAA+B;AAC/B;AACA;;AAEA,+BAA+B;AAC/B;AACA;;AAEA,wBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,WAAW;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,KAAK;;AAEL;AACA,+CAA+C,QAAQ;;AAEvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;;AAEA;AACA,2BAA2B;AAC3B,+CAA+C;AAC/C,sDAAsD;AACtD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mCAAmC,QAAQ;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;;AAEQ;;;;;;;;;;;;;;;;;;ACj1BoB;AAC4B;AACF;AACE;AACA;;AAExD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wC;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oIAAoI;AACpI;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,mCAAmC;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEQ;;;;;;;;ACvLR;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;;;;;;;;;;;;ACnbsB;;;AAGtB;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;;AAEA,gBAAgB,aAAa;AAC7B,iDAAiD;AACjD,kDAAkD;AAClD,iDAAiD;AACjD,gDAAgD;AAChD,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,2BAA2B;AAC9D;;AAEA;AACA;AACA,8EAA8E;AAC9E,8EAA8E;AAC9E,8EAA8E;AAC9E,8EAA8E;AAC9E;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mCAAmC,2BAA2B;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B;AAC9B,yDAAyD;AACzD,yDAAyD;AACzD,2BAA2B;AAC3B,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;;AAEA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,K;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D;;AAE3D;AACA,2DAA2D;;AAE3D;AACA,wDAAwD;;AAExD;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,iDAAiD;AACjD,kDAAkD;AAClD,iDAAiD;AACjD,gDAAgD;AAChD;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,uBAAuB;AACvB;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,KAAK;;AAEL;AACA;AACA;AACA,uBAAuB,mBAAmB,mBAAmB;AAC7D;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL,sCAAsC;AACtC;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA,KAAK;;AAEL;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA,KAAK;;AAEL,2CAA2C;AAC3C;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;;;AAGtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C,gBAAgB,SAAS;AACzB;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;;AAEf,6CAA6C;AAC7C,6CAA6C;AAC7C,6CAA6C;;AAE7C,gBAAgB,OAAO;AACvB,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;;AAEA;AACA;AACA,eAAe;AACf,8CAA8C;;AAE9C;AACA,uDAAuD;AACvD,uDAAuD;AACvD,oBAAoB,cAAc;AAClC;AACA;AACA,yDAAyD;AACzD;AACA;;AAEA;AACA,iDAAiD;AACjD,oBAAoB,SAAS;AAC7B,yDAAyD;AACzD,yDAAyD;AACzD,yDAAyD;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D;AAC7D,6DAA6D;AAC7D,6DAA6D;AAC7D,6DAA6D;AAC7D;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA,kE;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C;;AAE7C,gBAAgB,SAAS;AACzB,iDAAiD;AACjD,gDAAgD;AAChD,kBAAkB,uEAAuE;AACzF;AACA;AACA;;AAEA;AACA;;AAEA,qDAAqD,YAAY;AACjE,mDAAmD;;AAEnD;AACA,gBAAgB,eAAe;AAC/B;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,6CAA6C;;AAE7C,gBAAgB,SAAS;AACzB,iDAAiD;AACjD,gDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD;AACrD;;AAEA,oDAAoD;;AAEpD,gBAAgB,gBAAgB;AAChC,iDAAiD;AACjD,sDAAsD;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAmD;AACnD;AACA,kDAAkD;AAClD;;AAEA;;AAEA,oDAAoD;AACpD;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD,iDAAiD;;AAEjD;;AAEA;AACA;;;AAGA,gBAAgB,aAAa;AAC7B,sDAAsD;AACtD,sDAAsD;AACtD,iDAAiD;;AAEjD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C;AACA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C,8CAA8C;AAC9C,gDAAgD;AAChD,kDAAkD;AAClD;AACA,mDAAmD;AACnD,qDAAqD;AACrD,kDAAkD;AAClD,6DAA6D;AAC7D;AACA,6DAA6D;AAC7D;AACA,gBAAgB,YAAY,OAAO,8CAA8C;AACjF,gEAAgE;AAChE;AACA,mCAAmC,oDAAoD;AACvF;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C,8CAA8C;AAC9C,gDAAgD;AAChD,iDAAiD;AACjD,kDAAkD;AAClD;AACA,gBAAgB,cAAc,OAAO,oDAAoD;;AAEzF;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA,wDAAwD,sEAAsE;;;;AAI9H,gDAAgD;AAChD;;AAEA;;AAEA,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA,iDAAiD;;AAEjD,oBAAoB,SAAS;AAC7B,qDAAqD;AACrD;AACA,sDAAsD;AACtD;;AAEA,wBAAwB,WAAW;AACnC,uDAAuD;AACvD;AACA,oCAAoC,gEAAgE,iBAAiB;AACrH,oCAAoC,gEAAgE,iBAAiB;AACrH,0BAA0B,oCAAoC;AAC9D;AACA;AACA;AACA;;AAEA;AACA,qDAAqD;AACrD,qDAAqD;AACrD,uDAAuD;AACvD,uDAAuD;;AAEvD;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA,wBAAwB,eAAe;AACvC;AACA,oCAAoC,gEAAgE,kBAAkB;AACtH,oCAAoC,gEAAgE,kBAAkB;AACtH,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,sEAAsE;;;AAG9H,gDAAgD;AAChD;;AAEA;;AAEA,4CAA4C;AAC5C,+CAA+C;AAC/C,iEAAiE;;AAEjE;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,mDAAmD;AACnD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,oBAAoB,OAAO;AAC3B,oDAAoD;AACpD;AACA;AACA;AACA;AACA,K;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C,gBAAgB,OAAO;AACvB,gDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC,+CAA+C,YAAY;AAC3D,yDAAyD;AACzD;AACA,2CAA2C;AAC3C,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C,gBAAgB,QAAQ;AACxB,gDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,8CAA8C;AAC9C,4CAA4C;AAC5C,gBAAgB,UAAU,OAAO,+CAA+C,YAAY;AAC5F;AACA;;;;AAIA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,mDAAmD;AACnD,wDAAwD;AACxD,iDAAiD;AACjD,6CAA6C;AAC7C,kDAAkD;AAClD,gDAAgD;AAChD,gDAAgD;AAChD,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,gDAAgD;AAChD,qDAAqD;AACrD,wDAAwD;AACxD,wDAAwD;AACxD,wDAAwD;AACxD;AACA;;;AAGA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,gDAAgD;AAChD,gDAAgD;AAChD,8CAA8C;;AAE9C,uDAAuD;AACvD,0DAA0D;AAC1D,0DAA0D;AAC1D,iDAAiD;;AAEjD,qDAAqD;AACrD,qDAAqD;AACrD,qDAAqD;;AAErD;;AAEA,wDAAwD;AACxD,wDAAwD;AACxD;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,gBAAgB,uBAAuB;AACvC,0CAA0C,kCAAkC,cAAc,kCAAkC,YAAY;AACxI;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA,+CAA+C;;AAE/C,eAAe;AACf,gBAAgB,WAAW;AAC3B,kBAAkB;AAClB,mDAAmD;AACnD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C;AAC9C,6CAA6C;;AAE7C,eAAe;AACf,gBAAgB,WAAW;AAC3B,gDAAgD;AAChD,oDAAoD;AACpD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,qDAAqD;AACrD,qDAAqD;AACrD,qDAAqD;AACrD,gBAAgB,UAAU;AAC1B,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD,yBAAyB,uBAAuB,iBAAiB,qBAAqB;AACtF;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC;AACzC,iDAAiD;;AAEjD;AACA;AACA,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE;;AAEA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,uBAAuB,kCAAkC,SAAS,QAAQ,G;AAC9F;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8B;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF,0BAA0B;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA,+BAA+B,QAAQ;AACvC;AACA;AACA;;AAEA;;AAEA,mDAAmD;AACnD;AACA,SAAS,sBAAsB;AAC/B;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA,SAAS,mCAAmC;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,QAAQ;AACxC;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,QAAQ;AACxC;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uE;AACA,SAAS;AACT,uE;AACA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;;AAEA,0BAA0B,gBAAgB;AAC1C;AACA;AACA,2C;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,eAAe;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA,0BAA0B,gBAAgB;AAC1C;AACA;AACA,yC;;AAEA;;AAEA,4BAA4B,eAAe;AAC3C,iEAAiE;AACjE;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;AAEA;AACA;;;AAGQ;;;;;;;;;;;;;;;;;;;;;ACpxCoB;AAC4B;AAGiD;AACQ;AAC+D;AAC9H;AAEqD;;;AAGvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,c;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA,0D;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAA+D,QAAQ;AACvE;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;;AAEA;AACA;;AAEA,kFAAkF,QAAQ;AAC1F;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,iDAAiD;AACjF;AACA;AACA;;AAEA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA,oCAAoC,8EAA8E;AAClH;;AAEA;AACA,gCAAgC,+CAA+C;AAC/E;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,8CAA8C;AAC1E;AACA;AACA,4BAA4B,4CAA4C;AACxE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAA4D,iEAAiE;AAC7H,wBAAwB,yFAAyF;;AAEjH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;;AAE7C;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;;AAEA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;;AAEA;AACA;AACA,qBAAqB,wBAAwB;AAC7C,qBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gC;AACA;AACA;;AAEA;;AAEA,oCAAoC;AACpC;AACA;;AAEA,uBAAuB,2BAA2B;AAClD,qBAAqB,oBAAoB;AACzC;AACA;AACA","file":"50b786f7ee11086a9385.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 50b786f7ee11086a9385","\nvar globals = {\n    stylesheetData : {},\n    stylesheetLayers : {},\n    stylesheetBitmaps : {},\n    stylesheetFonts : {},\n    stylesheetConstants : {},\n    stylesheetVariables : {},\n    fonts : {},\n    fontsMap : {},\n    fontsStorage : {},\n    forceOrigin : false,\n    forceScale : [1,1,1],\n    bboxMin : [0,0,0],\n    bboxMax : [1,1,1],\n    geocent : false,\n    tileX : 0,\n    tileY : 0,\n    tileLod : 0,\n    tileSize : 1,\n    hitState : 0,\n    pixelFactor : 1,\n    alwaysEventInfo : false,\n    metricUnits : true,\n    groupOptimize : true,\n    groupOrigin : [0,0,0],\n    messageBuffer : new Array(65536),\n    messageBufferIndex : 0,\n    messageBufferSize : 65536,\n    messagePackSize : 0,\n    signatureCounter : 0,\n    autoLod : false,\n    featureType : null,\n    groupId : null,\n    disableLog : false,\n    reduceMode : 'scr-count4',\n    reduceParams : null,\n};\n\n\nfunction clamp(value, min, max) {\n    if (value < min) {\n        value = min;\n    }\n\n    if (value > max) {\n        value = max;\n    }\n\n    return value;\n}\n\n\nfunction vec3Normalize(a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return b;\n}\n\n\nfunction vec3Length(a) {\n    var b = a[0],\n        c = a[1];\n    a = a[2];\n    return Math.sqrt(b * b + c * c + a * a);\n}\n\n\nfunction vec3Cross(a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1];\n    a = a[2];\n    var g = b[0],\n        f = b[1];\n    b = b[2];\n    c[0] = e * b - a * f;\n    c[1] = a * g - d * b;\n    c[2] = d * f - e * g;\n    return c;\n}\n\n\nfunction getHash(str) {\n    if (!str || str.length === 0) {\n        return 0;    \n    }\n\n    var hash = 0, c;\n    for (var i = 0, li = str.length; i < li; i++) {\n        c   = str.charCodeAt(i);\n        hash  = ((hash << 5) - hash) + c;\n        hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n}\n\n\nvar simpleFmtCall = (function obj(str, call) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    var i = str.indexOf('{'), li, str2;\n\n    if (i == -1) {\n        return str;\n    } else {\n        str2 = i > 0 ? str.substring(0, i) : '';\n    }\n\n    var counter = 0;\n    var begin = -1;\n\n    for (li = str.length; i < li; i++) {\n        var c = str.charAt(i);\n\n        if (c == '{') {\n            if (counter == 0) {\n                begin = i;\n            }\n\n            counter++;\n        } else if (c == '}') {\n            counter--;\n\n            if (counter == 0) {\n                str2 += call(str.substring(begin+1, i));\n            }\n            \n        } else if (counter == 0) {\n            str2 += c;\n        }\n    }\n\n    return str2;\n});\n\n/*\nfunction copyArrayToBuffer(view, index, array) {\n    for (var i = 0, li = array.length; i < li; i++) {\n        view.setFloat32(index, array[i]); index += 4;\n    }\n\n    return index;\n}\n\nfunction copyDynamicArrayToBuffer(view, index, array) {\n    if (array) {\n        view.setUint8(index, array.length); index += 1;\n\n        for (var i = 0, li = array.length; i < li; i++) {\n            view.setFloat32(index, array[i]); index += 4;\n        }\n    } else {\n        view.setUint8(index, 0); index += 1;\n    }\n\n    return index;\n}\n\nfunction copyDynamicArrayOfArraysToBuffer(view, index, array) {\n    if (array) {\n        view.setUint16(index, array.length); index += 2;\n\n        for (var i = 0, li = array.length; i < li; i++) {\n            var subarray = array[i];\n\n            for (var j = 0, lj = array.length; j < lj; j++) {\n                view.setUint16(index, subarray[j]); index += 2;\n            }\n        }\n    } else {\n        view.setUint16(index, 0); index += 2;\n    }\n\n    return index;\n}\n\nfunction getSizeOfArrayOfArrays(array) {\n    var size = 0;\n\n    for (var i = 0, li = array.length; i < li; i++) {\n        size += array[i].length;\n    }\n\n    return size;\n}\n*/\n\n//var textEncoderUtf8 = null; //(typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\nvar textEncoderUtf8 = (typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\n\nfunction stringToUint8Array(str) {\n    if (textEncoderUtf8) {\n        return textEncoderUtf8.encode(str);\n    } else {\n\n        /*\n        console.log('' + (str.length * 2));\n\n        var buffer = new ArrayBuffer(str.length * 2);\n        var view = new Uint16Array(buffer);\n        for (var i = 0, li = str.length; i < li; i++) {\n            view[i] = str.charCodeAt(i);\n        }\n        return new Uint8Array(buffer);\n        */\n\n\n        // 1. Let S be the DOMString value.\n        var s = String(str);\n\n        // 2. Let n be the length of S.\n        var n = s.length;\n\n        // 3. Initialize i to 0.\n        var i = 0;\n\n        // 4. Initialize U to be an empty sequence of Unicode characters.\n        var u = [];\n\n        // 5. While i < n:\n        while (i < n) {\n\n          // 1. Let c be the code unit in S at index i.\n          var c = s.charCodeAt(i);\n\n          // 2. Depending on the value of c:\n\n          // c < 0xD800 or c > 0xDFFF\n          if (c < 0xD800 || c > 0xDFFF) {\n            // Append to U the Unicode character with code point c.\n            u.push(c);\n          }\n\n          // 0xDC00 ≤ c ≤ 0xDFFF\n          else if (0xDC00 <= c && c <= 0xDFFF) {\n            // Append to U a U+FFFD REPLACEMENT CHARACTER.\n            u.push(0xFFFD);\n          }\n\n          // 0xD800 ≤ c ≤ 0xDBFF\n          else if (0xD800 <= c && c <= 0xDBFF) {\n            // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n            // CHARACTER.\n            if (i === n - 1) {\n              u.push(0xFFFD);\n            }\n            // 2. Otherwise, i < n−1:\n            else {\n              // 1. Let d be the code unit in S at index i+1.\n              var d = s.charCodeAt(i + 1);\n\n              // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n              if (0xDC00 <= d && d <= 0xDFFF) {\n                // 1. Let a be c & 0x3FF.\n                var a = c & 0x3FF;\n\n                // 2. Let b be d & 0x3FF.\n                var b = d & 0x3FF;\n\n                // 3. Append to U the Unicode character with code point\n                // 2^16+2^10*a+b.\n                u.push(0x10000 + (a << 10) + b);\n\n                // 4. Set i to i+1.\n                i += 1;\n              }\n\n              // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n              // U+FFFD REPLACEMENT CHARACTER.\n              else  {\n                u.push(0xFFFD);\n              }\n            }\n          }\n\n          // 3. Set i to i+1.\n          i += 1;\n        }\n\n        // 6. Return U.\n        return new Uint8Array((new Uint32Array(u)).buffer);        \n    }\n}\n\n/*\nvar textDecoderUtf8 = TextEncoder ? (new TextDecoder('utf-8')) : null;\n\nfunction unint8ArrayToString(array) {\n    if (textDecoderUtf8) {\n        return textDecoderUtf8.decode(array);\n    } else {\n        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\n    }\n}\n*/\n\nexport {globals, clamp, vec3Normalize, vec3Length, vec3Cross, simpleFmtCall, getHash, stringToUint8Array};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-globals.js\n// module id = 0\n// module chunks = 0","\nimport {globals as globals_, stringToUint8Array as stringToUint8Array_ } from './worker-globals.js';\n\n//get rid of compiler mess\nvar globals = globals_, stringToUint8Array = stringToUint8Array_;\nvar tmpVertexBuffer = new Uint8Array(65536*4*4*4*4);\nvar tmpVertexBuffer2 = new Uint8Array(65536*4*4*4*4);\n\nfunction postGroupMessageFast(command, type, message, buffers, signature) {\n\n    var message2 = stringToUint8Array(JSON.stringify(message));\n    var messageSize = 1+1+4+message2.byteLength, i, li;\n\n    for (i = 0, li = buffers.length; i < li; i++) {\n        messageSize += 4+buffers[i].byteLength;\n    }\n\n    var buff = new Uint8Array(messageSize);\n    var view = new DataView(buff.buffer), index = 0, index2 = 0;\n\n    view.setUint8(index, command); index += 1;\n    view.setUint8(index, type); index += 1;\n    view.setUint32(index, message2.byteLength); index += 4;\n    buff.set(message2, index); index += message2.byteLength;\n    index2 = index;\n\n    for (i = 0, li = buffers.length; i < li; i++) {\n        view.setUint32(index, buffers[i].length); index += 4;\n        buff.set( new Uint8Array(buffers[i].buffer), index); index += buffers[i].byteLength;\n    }\n\n    postGroupMessageDirect(command, type, buff.buffer, index2, signature, message['hitable'], message['totalPoints'], (type == VTS_WORKER_TYPE_LINE_LABEL) ? message : null);\n}\n\nfunction postGroupMessageLite(command, type, number) {\n    var messageSize = 1+1+4, index = 0;\n\n    var buff = new ArrayBuffer(messageSize);\n    var view = new DataView(buff), index = 0;\n\n    view.setUint8(index, command); index += 1;\n    view.setUint8(index, type); index += 1;\n    view.setUint32(index, (number ? number : 0)); index += 4;\n\n    postGroupMessageDirect(command, type, buff, index, \"\");\n}\n\n\nfunction postGroupMessageDirect(command, type, message, buffersIndex, signature, hitable, totalPoints, job2) {\n\n    if (globals.messageBufferIndex >= globals.messageBufferSize) { \n        var oldBuffer = globals.messageBuffer; \n        globals.messageBufferSize += 65536;\n        globals.messageBuffer = new Array(globals.messageBufferSize);\n        \n        for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\n            globals.messageBuffer[i] = oldBuffer[i];\n        }\n    }\n    \n    globals.messageBuffer[globals.messageBufferIndex] = { command: command, type: type, job : message, buffersIndex: buffersIndex, signature: signature, hitable: hitable, totalPoints: totalPoints, job2: job2 };\n    globals.messageBufferIndex++;\n    globals.messagePackSize += message.byteLength;\n}\n\n\nfunction optimizeGroupMessages() {\n\n    //loop messages\n    var messages = globals.messageBuffer;\n    var j, lk, k, message2, job2, bufferSize, buffer, view, index, length, buff, buff2, index, count, totalVertices;\n\n\n    for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\n        var message = messages[i];\n        var job = message.job;\n        var type = message.type;\n        var signature = message.signature;\n\n        //console.log('command: ' + message.command + ' type:' + message.type);\n        \n        if (!message.hitable && !message.reduced && \n            (type >= VTS_WORKER_TYPE_FLAT_LINE && type <= VTS_WORKER_TYPE_LINE_LABEL)) {\n            \n            switch(type) {\n            case VTS_WORKER_TYPE_FLAT_LINE:\n                count = 0;\n\n                //get message vertices length and copy vertices to buffer\n                length = (new DataView(message.job)).getUint32(message.buffersIndex) * 4;\n\n                tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                bufferSize = length;\n\n                for (j = i + 1; j < li; j++) {\n                    message2 = messages[j];\n\n                    if (message2.signature == signature) {\n                        message2.reduced = true;\n                        count++;\n\n                        //get message2 vertices length\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex) * 4;\n\n                        // copy vertices to buffer\n                        tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n                        bufferSize += length;\n                    }\n                }\n\n                if (count > 0) {\n\n                    //create new message with merged vertices\n                    buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\n                    view = new DataView(buffer.buffer);\n                    buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\n\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\n\n                    globals.messagePackSize -= message.job.byteLength;\n                    globals.messagePackSize += buffer.byteLength;\n                    message.job = buffer.buffer;\n                }\n\n                break;\n                    \n            case VTS_WORKER_TYPE_PIXEL_LINE:\n            case VTS_WORKER_TYPE_LINE_LABEL:\n            case VTS_WORKER_TYPE_FLAT_RLINE:\n\n                count = 0;\n                totalVertices = 0;\n\n                //get message vertices length and copy vertices to buffer\n                length = (new DataView(message.job)).getUint32(message.buffersIndex);\n                //console.log('count: ' + count + ' totalPoints:' + message.totalPoints + ' length: ' + length);\n                length *= 4;\n                totalVertices += length;\n\n\n                tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                tmpVertexBuffer2.set(new Uint8Array(message.job, message.buffersIndex+4+length+4, length), 0);\n                bufferSize = length;\n\n                for (j = i + 1; j < li; j++) {\n                    message2 = messages[j];\n\n                    if (message2.signature == signature) {\n                        message2.reduced = true;\n                        globals.messagePackSize -= message2.job.byteLength;\n                        count++;\n\n                        //get message2 vertices length\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex);\n                        //console.log('count:' + count + ' totalPoints:' + message2.totalPoints + ' length:' + length + ' jobl:' + message2.job.byteLength + ' remaning:' + (message2.job.byteLength - (message2.buffersIndex+4)) + ' bufferSize:' + bufferSize + ' totalVertices:' + totalVertices);\n                        length *= 4;\n                        totalVertices += length;\n\n\n                        // copy vertices to buffer\n                        tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n\n                        // copy normals to buffer\n                        tmpVertexBuffer2.set(new Uint8Array(message2.job, message2.buffersIndex+4+length+4, length), bufferSize);\n                        bufferSize += length;\n\n                        if (type == VTS_WORKER_TYPE_LINE_LABEL) {\n                            var files = message.job2['files'];\n                            var files2 = message2.job2['files'];\n\n                            for (k = 0, lk = files2.length; k < lk; k++) {\n                                if (!files[k]) {\n                                    files[k] = [];\n                                }\n\n                                for (var m = 0, lm = files2[k].length; m < lm; m++) {\n                                    if (files[k].indexOf(files2[k][m]) == -1) {\n                                        files[k].push(files2[k][m]);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (count > 0) {\n\n                    //create new message with merged vertices\n\n                    if (type == VTS_WORKER_TYPE_LINE_LABEL) { //we have to rebuild header\n                        var buffjob = stringToUint8Array(JSON.stringify(message.job2));\n\n                        buffer = new Uint8Array(1+1+4+buffjob.byteLength+2*(4+bufferSize));\n                        view = new DataView(buffer.buffer), index = 0;\n\n                        view.setUint8(index, message.command); index += 1;\n                        view.setUint8(index, type); index += 1;\n                        view.setUint32(index, buffjob.byteLength); index += 4;\n                        buffer.set(buffjob, index); index += buffjob.byteLength;\n\n                        message.buffersIndex = index;\n                    } else {\n                        buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\n                        view = new DataView(buffer.buffer);\n                        buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\n                    }\n\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\n\n                    view.setUint32(message.buffersIndex + 4 + bufferSize, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer2.buffer, 0, bufferSize), message.buffersIndex + 4 + bufferSize + 4 );\n\n                    globals.messagePackSize -= message.job.byteLength;\n                    globals.messagePackSize += buffer.byteLength;\n                    message.job = buffer.buffer;\n\n                }\n\n                break;\n            }\n        \n        }\n    }\n\n    var buffer = new Uint8Array(globals.messagePackSize), index = 0;\n\n    for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\n        var message = globals.messageBuffer[i];\n\n        if (!message.reduced) {\n            buffer.set(new Uint8Array(message.job), index);\n            index += globals.messageBuffer[i].job.byteLength;\n        }\n    }\n\n    //console.log('send:' + buffer.length);\n\n    postMessage({'command' : 'addPackedCommands', 'buffer': buffer}, [buffer.buffer]);\n\n    globals.messageBufferIndex = 0;\n    globals.messagePackSize = 0;\n} \n\n\nexport {optimizeGroupMessages, postGroupMessageFast, postGroupMessageLite};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-message.js\n// module id = 1\n// module chunks = 0","\nimport {globals as globals_, vec3Normalize as vec3Normalize_,\n        vec3Length as vec3Length_, vec3Cross as vec3Cross_} from './worker-globals.js';\n\nimport {Typr as Typr_} from './worker-font.js';\n\n\n//get rid of compiler mess\nvar globals = globals_,\n    vec3Normalize = vec3Normalize_, vec3Length = vec3Length_,\n    vec3Cross = vec3Cross_,\n    Typr = Typr_;\n\n\nvar setFont = function(fontData) {\n    //console.log('setFont ' + fontData['url']);\n    //debugger;\n\n    var font = Typr.parse(fontData['data']);\n\n    globals.fontsStorage[fontData['url']] = font;\n};\n\n\nvar setFontMap = function(fontMap) {\n    var fonts = fontMap['map'];\n    for (var key in fonts) {\n        globals.fonts[key] = globals.fontsStorage[fonts[key]];\n    }\n\n    globals.fontsMap = fonts;\n};\n\n\nvar addChar = function(pos, dir, verticalShift, char, factor, spacing, index, index2, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, fontIndex, singleBuffer) {\n    var n, font = fonts[fontIndex];\n\n    if (globals.geocent && !flat) {\n        n = [0,0,0];\n        var nn = [0,0,0];\n        \n        vec3Normalize(globals.bboxMin, nn);\n        vec3Cross(nn, dir, n);\n    } else {\n        n = [-dir[1],dir[0],0];\n    }\n\n    var p1 = [pos[0], pos[1], pos[2]];\n    var p2 = [p1[0], p1[1], p1[2]];\n\n    //var chars = font.chars;\n    \n    var fc = font.glyphs[char];\n    char = 0; // hack\n\n    if (!fc) {\n        return [pos, index, index2, 0];\n    }\n\n    var l = 0;\n    var nx = textVector[0];\n    var ny = textVector[1];\n    var nz = textVector[2];\n\n    if (char == 9 || char == 32) {  //tab or space\n        fc = chars[32]; //space\n\n        if (fc) {\n            pos[0] += dir[0] * (fc.step) * factor * spacing;\n            pos[1] += dir[1] * (fc.step) * factor * spacing;\n            l = fc.lx * factor;\n        }\n    } else {\n        if (fc.lx == 0) {\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\n            l = fc.lx * factor;\n        } else {\n            var planeShift = fontIndex * 4000;\n            var plane = fc.plane + planeShift;\n\n            if (planes) {\n                if (!planes[fontIndex]) {\n                    planes[fontIndex] = {};\n                }\n                \n                planes[fontIndex][plane] = true;\n            }\n\n            var factorX = fc.lx * factor;\n            var factorY = fc.ly * factor;\n\n            if (singleBuffer) {\n\n                singleBuffer[index] = p1[0] + fc.sx * factor;;\n                singleBuffer[index+1] = p1[1] + (fc.sy - font.size) * factor;\n                singleBuffer[index+2] = singleBuffer[index] + factorX;\n                singleBuffer[index+3] = singleBuffer[index+1] - factorY;\n                singleBuffer[index+4] = fc.u1;\n                singleBuffer[index+5] = fc.v1 + planeShift;\n                singleBuffer[index+6] = fc.u2;\n                singleBuffer[index+7] = fc.v2 + planeShift;\n\n                index += 8;\n \n            } else {\n\n                var n2 = [n[0] * verticalShift, n[1] * verticalShift, n[2] * verticalShift];\n                var n3 = [n2[0] + n[0] * factorY, n2[1] + n[1] * factorY, n2[2] + n[2] * factorY];\n                \n                p1[0] = p1[0] + dir[0] * fc.sx * factor;\n                p1[1] = p1[1] + dir[1] * fc.sx * factor;\n                p1[2] = p1[2] + dir[2] * fc.sx * factor;\n                p1[0] = p1[0] + n[0] * (fc.sy - font.size) * factor;\n                p1[1] = p1[1] + n[1] * (fc.sy - font.size) * factor;\n                p1[2] = p1[2] + n[2] * (fc.sy - font.size) * factor;\n\n                p2[0] = p1[0] + dir[0] * factorX;\n                p2[1] = p1[1] + dir[1] * factorX;\n                p2[2] = p1[2] + dir[2] * factorX;\n\n                //first polygon\n                vertexBuffer[index] = p1[0] - n2[0];\n                vertexBuffer[index+1] = p1[1] - n2[1];\n                vertexBuffer[index+2] = p1[2] - n2[2];\n                vertexBuffer[index+3] = nz;\n\n                texcoordsBuffer[index2] = fc.u1;\n                texcoordsBuffer[index2+1] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+2] = nx;\n                texcoordsBuffer[index2+3] = ny;\n\n                vertexBuffer[index+4] = p1[0] - n3[0];\n                vertexBuffer[index+5] = p1[1] - n3[1];\n                vertexBuffer[index+6] = p1[2] - n3[2];\n                vertexBuffer[index+7] = nz;\n\n                texcoordsBuffer[index2+4] = fc.u1;\n                texcoordsBuffer[index2+5] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+6] = nx;\n                texcoordsBuffer[index2+7] = ny;\n\n                vertexBuffer[index+8] = p2[0] - n2[0];\n                vertexBuffer[index+9] = p2[1] - n2[1];\n                vertexBuffer[index+10] = p2[2] - n2[2];\n                vertexBuffer[index+11] = nz;\n\n                texcoordsBuffer[index2+8] = fc.u2;\n                texcoordsBuffer[index2+9] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+10] = nx;\n                texcoordsBuffer[index2+11] = ny;\n\n\n                //next polygon\n                vertexBuffer[index+12] = p1[0] - n3[0];\n                vertexBuffer[index+13] = p1[1] - n3[1];\n                vertexBuffer[index+14] = p1[2] - n3[2];\n                vertexBuffer[index+15] = nz;\n\n                texcoordsBuffer[index2+12] = fc.u1;\n                texcoordsBuffer[index2+13] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+14] = nx;\n                texcoordsBuffer[index2+15] = ny;\n\n                vertexBuffer[index+16] = p2[0] - n3[0];\n                vertexBuffer[index+17] = p2[1] - n3[1];\n                vertexBuffer[index+18] = p2[2] - n3[2];\n                vertexBuffer[index+19] = nz;\n\n                texcoordsBuffer[index2+16] = fc.u2;\n                texcoordsBuffer[index2+17] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+18] = nx;\n                texcoordsBuffer[index2+19] = ny;\n\n                vertexBuffer[index+20] = p2[0] - n2[0];\n                vertexBuffer[index+21] = p2[1] - n2[1];\n                vertexBuffer[index+22] = p2[2] - n2[2];\n                vertexBuffer[index+23] = nz;\n\n                texcoordsBuffer[index2+20] = fc.u2;\n                texcoordsBuffer[index2+21] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+22] = nx;\n                texcoordsBuffer[index2+23] = ny;\n\n                index += 24;\n                index2 += 24;\n            }\n\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\n            l = fc.lx * factor;\n        }\n    }\n\n    return [pos, index, index2, l * spacing];\n};\n\n\nvar getCharVerticesCount = function(origin) {\n    return (origin ? 3 : 4) * 3 * 2;\n};\n\n\nvar addText = function(pos, dir, text, size, spacing, fonts, vertexBuffer, texcoordsBuffer, flat, index, planes, glyphsRes, singleBuffer) {\n    var textVector = [0,1,0];\n    var p1 = [pos[0], pos[1], pos[2]];\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    var gfonts = res[1];\n\n    for (var i = 0, li = glyphs.length; i < li; i++) {\n        var glyph = glyphs[i];\n        var font = fonts[gfonts[i]];\n\n        if (font) {\n            var factor = getFontFactor(size, font);\n\n            var shift = addChar(p1, dir, 0, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, gfonts[i], singleBuffer);\n\n            //var gid2 = (i<gls.length-1 && gls[i+1]!=-1)  ? gls[i+1] : 0;\n            //x += Typr.U.getPairAdjustment(font, gid, gid2);\n\n            p1 = shift[0];\n            index = shift[1];\n        }\n    }\n\n    return index;\n};\n\n\nvar addTextOnPath = function(points, distance, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes) {\n    if (textVector == null) {\n        textVector = [0,1,0];\n    }\n\n    var p1 = points[0];\n    //var newLineSpace = getLineHeight(size, fonts);\n    //var s = [p1[0], p1[1], p1[2]];\n\n    p1 = [p1[0], p1[1], p1[2]];\n    var l = distance;\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    var gfonts = res[1];\n\n    for (var i = 0, li = glyphs.length; i < li; i++) {\n        /*  \n        var char = text.charCodeAt(i);\n\n        if (char == 10) { //new line\n            s[0] += -dir[1] * newLineSpace;\n            s[1] += dir[0] * newLineSpace;\n            p1 = [s[0], s[1], s[2]];\n            continue;\n        }\n\n        if (char == 9) { //tab\n            char = 32;\n        }\n        */\n\n        var glyph = glyphs[i];\n        var font = fonts[gfonts[i]];\n\n        if (font) {\n            var factor = getFontFactor(size, font);\n\n            var ll = 0.01;\n            var fc = font.glyphs[glyph];\n            if (fc) {\n                ll = fc.step * factor * spacing;\n            }\n\n            var posAndDir = getPathPositionAndDirection(points, l);\n            var posAndDir2 = getPathPositionAndDirection(points, l+ll);\n\n            //average dir\n            var dir = [(posAndDir2[1][0] + posAndDir[1][0])*0.5,\n                (posAndDir2[1][1] + posAndDir[1][1])*0.5,\n                (posAndDir2[1][2] + posAndDir[1][2])*0.5];\n\n            vec3Normalize(dir);\n\n            var shift = addChar(posAndDir[0], dir, -factor*font.size*0.7+verticalOffset, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, null, planes, gfonts[i]);\n\n            p1 = shift[0];\n            index = shift[1];\n            //index2 = shift[2];\n            l += ll;\n        }\n    }\n\n    return index;\n};\n\n\nvar addStreetTextOnPath = function(points, text, size, spacing, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes) {\n    var textLength = getTextLength(text, size, spacing, fonts, glyphsRes);\n    var pathLength = getPathLength(points);\n    var shift = (pathLength -  textLength)*0.5;\n    if (shift < 0) {\n        shift = 0;\n    }\n\n    if (textLength > pathLength) {\n        return;\n    }\n\n    var textVector = getPathTextVector(points, shift, text, size, spacing, fonts, glyphsRes);\n\n    return addTextOnPath(points, shift, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes);\n};\n\n\nvar getFontFactor = function(size, font) {\n    return font ? ((size / font.size) * 1.52) : 1;\n};\n\n\nvar getLineHeight = function(size, lineHeight, fonts) {\n    var factor = getFontFactor(size, fonts[0]);\n    //return font.space * factor;\n    return fonts[0].cly * factor * lineHeight;\n};\n\n\nvar getTextLength = function(text, size, spacing, fonts, glyphsRes) {\n    var l = 0;\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    var gfonts = res[1];\n\n    for (var i = 0, li = glyphs.length; i < li; i++) {\n        var glyph = glyphs[i];\n        var font = fonts[gfonts[i]];\n\n        if (font) {\n            var factor = getFontFactor(size, font) * spacing;\n            var fc = font.glyphs[glyph];\n\n            if (fc) {\n                if (i == (li-1)) {\n                    l += fc.lx * factor;\n                } else {\n                    l += fc.step * factor;\n                }\n            }\n        }\n    }\n\n    return l;\n};\n\n\nvar getSplitIndex = function(text, width, size, spacing, fonts, glyphsRes) {\n    var l = 0;\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    var gfonts = res[1];\n    var codes = res[2];\n\n    for (var i = 0, li = glyphs.length; i < li; i++) {\n        var glyph = glyphs[i];\n        var char = codes[i];//text.charCodeAt(i);\n\n        if (l > width && (char == 10 || char == 9 || char == 32)) {\n            return i;\n        }\n\n        if (char == 10) { //new line\n            continue;\n        }\n\n        var font = fonts[gfonts[i]];\n\n        if (font) {\n            var factor = getFontFactor(size, font) * spacing;\n            var fc = font.glyphs[glyph];\n\n            if (fc) {\n                if (i == (li-1)) {\n                    l += fc.lx * factor;\n                } else {\n                    l += fc.step * factor;\n                }\n            }\n        }\n    }\n\n    return li;\n};\n\n\nvar getPathLength = function(points) {\n    var l = 0;\n\n    for (var i = 0, li = points.length-1; i < li; i++) {\n        var p1 = points[i];\n        var p2 = points[i+1];\n        var dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        l += vec3Length(dir);\n    }\n\n    return l;\n};\n\n\nvar getPathPositionAndDirection = function(points, distance) {\n    var l = 0;\n    var p1 = [0,0,0];\n    var dir = [1,0,0];\n\n    for (var i = 0, li = points.length-1; i < li; i++) {\n        p1 = points[i];\n        var p2 = points[i+1];\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        var ll = vec3Length(dir);\n\n        if ((l + ll) > distance) {\n\n            var factor = (distance - l) / (ll);\n            var p = [p1[0] + dir[0] * factor,\n                p1[1] + dir[1] * factor,\n                p1[2] + dir[2] * factor];\n\n            vec3Normalize(dir);\n\n            return [p, dir];\n        }\n\n        l += ll;\n    }\n\n    return [p1, dir];\n};\n\n\nvar getPathTextVector = function(points, shift, text, size, spacing, fonts, glyphsRes) {\n    var l = 0;\n    var p1 = [0,0,0];\n    var dir = [1,0,0];\n    var textDir = [0,0,0];\n    var textStart = shift;\n    var textEnd = shift + getTextLength(text, size, spacing, fonts, glyphsRes);\n    var bboxMin = globals.bboxMin;\n    var geocent = globals.geocent;\n\n    for (var i = 0, li = points.length-1; i < li; i++) {\n        p1 = points[i];\n        var p2 = points[i+1];\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        l += vec3Length(dir);\n\n        if (l > textStart) {\n            vec3Normalize(dir);\n            textDir[0] += dir[0];\n            textDir[1] += dir[1];\n            textDir[2] += dir[2];\n        }\n\n        if (l > textEnd) {\n            vec3Normalize(textDir);\n\n            if (geocent) {\n                var nn = [0,0,0];\n                vec3Normalize(bboxMin, nn);\n                vec3Cross(nn, textDir, nn);\n                return nn;\n            } else {\n                return [-textDir[1], textDir[0],0];\n            }\n        }\n    }\n\n    return textDir;\n};\n\n\nvar areTextCharactersAvailable = function(text, fonts, glyphsRes) {\n    if (!text || text == '') {\n        return false;\n    }\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    //var gfonts = res[1];\n\n    if (glyphs.indexOf(0) != -1) {\n        return false;\n    }\n\n    return true;\n};\n\n\nvar hasLatin = function(str) {\n    for (var i = 0, li = str.length; i < li; i++) {\n        var c = str.charCodeAt(i);\n        if ((c >= 0x41 && c <= 0x5a) || (c >= 0x61 && c <= 0x7a) ||\n            ((c >= 0xc0 && c <= 0xff) && c!= 0xd7 && c!= 0xf7) || (c >= 0x100 && c <= 0x17f)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\nvar isCJK = function(str) {\n    for (var i = 0, li = str.length; i < li; i++) {\n        var c = str.charCodeAt(i);\n\n        if (!((c >= 0x4E00 && c <= 0x62FF) || (c >= 0x6300 && c <= 0x77FF) ||\n              (c >= 0x7800 && c <= 0x8CFF) || (c >= 0x8D00 && c <= 0x9FFF) || \n              (c >= 0x3400 && c <= 0x4DBF) || (c >= 0x20000 && c <= 0x215FF) || \n              (c >= 0x21600 && c <= 0x230FF) || (c >= 0x23100 && c <= 0x245FF) || \n              (c >= 0x24600 && c <= 0x260FF) || (c >= 0x26100 && c <= 0x275FF) || \n              (c >= 0x27600 && c <= 0x290FF) || (c >= 0x29100 && c <= 0x2A6DF) || \n              (c >= 0x2A700 && c <= 0x2B73F) || (c >= 0x2B740 && c <= 0x2B81F) || \n              (c >= 0x2B820 && c <= 0x2CEAF) || (c >= 0x2CEB0 && c <= 0x2EBEF) || \n              (c >= 0xF900 && c <= 0xFAFF) || (c >= 0x3300 && c <= 0x33FF) || \n              (c >= 0xFE30 && c <= 0xFE4F) || (c >= 0xF900 && c <= 0xFAFF) || \n              (c >= 0x2F800 && c <= 0x2FA1F) || \n              (c >= 0x0 && c <= 0x40) || (c >= 0xa0 && c <= 0xbf)  )) { //neutral\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\nvar getFonts = function(fonts) {\n    var fontsMap = [];\n    for (var i = 0, li = fonts.length; i < li; i++) {\n        fontsMap.push(globals.fonts[fonts[i]]);\n    }\n\n    return fontsMap;\n};\n\n\nvar getFontsStorage = function(fonts) {\n    var fontsMap = [];\n    for (var i = 0, li = fonts.length; i < li; i++) {\n        fontsMap.push(globals.fontsMap[fonts[i]]);\n    }\n\n    return fontsMap;\n};\n\n\nvar getTextGlyphs = function(text, fonts) {\n    return Typr.U.stringToGlyphs(fonts, text);\n};\n\n\nexport {addStreetTextOnPath, getTextLength, getLineHeight, getFontFactor, getSplitIndex, areTextCharactersAvailable,\n        addText, addTextOnPath, setFont, setFontMap, getCharVerticesCount, getFonts, getFontsStorage, hasLatin, isCJK, getTextGlyphs};\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-text.js\n// module id = 3\n// module chunks = 0","\nimport {globals as globals_, vec3Normalize as vec3Normalize_,\n        vec3Cross as vec3Cross_} from './worker-globals.js';\nimport {getLayerPropertyValue as getLayerPropertyValue_,\n        getLayerExpresionValue as getLayerExpresionValue_} from './worker-style.js';\nimport {addStreetTextOnPath as addStreetTextOnPath_, getTextGlyphs as getTextGlyphs_,\n        areTextCharactersAvailable as areTextCharactersAvailable_,\n        getCharVerticesCount as getCharVerticesCount_, getFonts as getFonts_, getFontsStorage as getFontsStorage_} from './worker-text.js';\nimport {postGroupMessageFast as postGroupMessageFast_} from './worker-message.js';\n\n//get rid of compiler mess\nvar globals = globals_, vec3Normalize = vec3Normalize_,\n    vec3Cross = vec3Cross_;\nvar getLayerPropertyValue = getLayerPropertyValue_,\n    getLayerExpresionValue = getLayerExpresionValue_;\nvar addStreetTextOnPath = addStreetTextOnPath_, areTextCharactersAvailable = areTextCharactersAvailable_,\n    getCharVerticesCount = getCharVerticesCount_, getFonts = getFonts_, getFontsStorage = getFontsStorage_;\nvar postGroupMessageFast = postGroupMessageFast_, getTextGlyphs = getTextGlyphs_;\n\n\nvar processLineStringPass = function(lineString, lod, style, featureIndex, zIndex, eventInfo) {\n    var lines = (lineString['lines'] || lineString['d-lines'])  || [];\n\n    if (lines.length == 0) {\n        return;\n    }\n\n    var dlines = (lineString['d-lines']) ? true : false;\n    var line = getLayerPropertyValue(style, 'line', lineString, lod);\n    var lineLabel = getLayerPropertyValue(style, 'line-label', lineString, lod);\n\n    if (!line && !lineLabel) {\n        return;\n    }\n\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\n    var clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\n\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\n\n    var lineFlat = getLayerPropertyValue(style, 'line-flat', lineString, lod);\n    var lineColor = getLayerPropertyValue(style, 'line-color', lineString, lod);\n    var lineWidth = 0.5 * getLayerPropertyValue(style, 'line-width', lineString, lod);\n    var lineWidthUnits = getLayerPropertyValue(style, 'line-width-units', lineString, lod);\n\n    var lineStyle = getLayerPropertyValue(style, 'line-style', lineString, lod);\n    var lineStyleTexture = getLayerPropertyValue(style, 'line-style-texture', lineString, lod);\n    var lineStyleBackground = getLayerPropertyValue(style, 'line-style-background', lineString, lod);\n\n    var lineLabelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\n\n    var texturedLine = (lineStyle != 'solid');\n    var widthByRatio = (lineWidthUnits == 'ratio');\n\n    if (lineWidthUnits == 'points') {\n        lineWidth *= globals.pixelFactor / ((1 / 72) * (96));\n    }\n\n    var index = 0, index2 = 0, index3 = 0;\n    var skipJoins = false;\n\n    if (widthByRatio) {\n        skipJoins = (!lineFlat && ((lineWidth/* *globals.invPixelFactor*/)*1080) < 2.1);\n    } else {\n        skipJoins = (!lineFlat && (lineWidth/* *globals.invPixelFactor*/) < 2.1);        \n    }\n\n    var ii, i, li, p2, v, vv, l, n, nn, p1, p, elementIndex, elemetBase = 1;\n\n    if (!skipJoins) {\n        var circleBuffer = [];\n        var circleBuffer2 = [];\n        var circleSides = 8;//Math.max(8, (14 - lod) * 8);\n    \n        var angle = 0, step = (2.0*Math.PI) / circleSides;\n    \n        for (i = 0; i < circleSides; i++) {\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\n            circleBuffer2[i] = angle;\n            angle += step;\n        }\n    \n        circleBuffer[circleSides] = [0, 1.0];\n        circleBuffer2[circleSides] = 0;\n    }\n\n    var totalPoints = 0;\n\n    for (ii = 0; ii < lines.length; ii++) {\n        if (Array.isArray(lines[ii])) {\n            totalPoints += lines[ii].length;\n        }\n    }\n\n    if (totalPoints <= 1) {\n        return;\n    }\n\n    if (lineFlat) {\n        circleSides = 2;\n    }\n\n    //allocate buffers\n    var lineVertices = ((texturedLine || (widthByRatio)) || !lineFlat ? 4 : 3) * 3 * 2;\n    var joinVertices = skipJoins ? 0 : (circleSides * ((texturedLine || (widthByRatio)) || !lineFlat? 4 : 3) * 3);\n    var vertexBuffer = new Float32Array((totalPoints-1) * lineVertices + totalPoints * joinVertices);\n\n    if (advancedHit) {\n       var elementBuffer = new Float32Array((totalPoints-1) * (3 * 2) + totalPoints * (skipJoins ? 0 : circleSides) * 3);\n    }\n\n    if (!(lineFlat && !texturedLine && !widthByRatio)) {\n        var lineNormals = 3 * 4 * 2;\n        var joinNormals = skipJoins ? 0 : (circleSides * 3 * 4);\n        var normalBuffer = new Float32Array((totalPoints-1) * lineNormals + totalPoints * joinNormals);\n    }\n\n    var center = [0,0,0];\n    var lineLabelStack = [];\n    var forceOrigin = globals.forceOrigin;\n    var bboxMin = globals.bboxMin;\n    var geocent = globals.geocent;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceScale = globals.forceScale;\n    var vstart = [1,0,0], vend = [-1,0,0];\n\n    for (ii = 0; ii < lines.length; ii++) {\n        if (!Array.isArray(lines[ii]) || !lines[ii].length) {\n            continue;\n        }\n        \n        var points = lines[ii];\n\n        if (lineLabel) {\n            var lineLabelPoints = new Array(points.length);\n            var lineLabelPoints2 = new Array(points.length);\n            \n            lineLabelStack.push({points: lineLabelPoints, points2 :lineLabelPoints2});\n        }\n    \n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n    \n        if (forceOrigin) {\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n        }\n    \n        if (forceScale != null) {\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n    \n        var distance = 0.001;\n        var distance2 = 0.001;\n        /*var ln = null;*/\n        var vertexBase = index;\n        var normalBase = index2;\n\n        //add lines\n        for (i = 0, li = points.length - 1; i < li; i++) {\n    \n            if (dlines) {\n                p2 = points[i+1];\n                p2 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\n    \n                if (forceOrigin) {\n                    p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n                }\n    \n                if (forceScale != null) {\n                    p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n                }\n    \n            } else {\n                p1 = points[i];\n                p2 = points[i+1];\n    \n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                    p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n                }\n    \n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                    p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n                }\n            }\n    \n            if (advancedHit) {\n                elementIndex = elemetBase + i;\n\n                elementBuffer[index3] = elementIndex;\n                elementBuffer[index3+1] = elementIndex;\n                elementBuffer[index3+2] = elementIndex;\n    \n                //add polygon\n                elementBuffer[index3+3] = elementIndex;\n                elementBuffer[index3+4] = elementIndex;\n                elementBuffer[index3+5] = elementIndex;\n\n                index3 += 6;\n            }\n\n            if (lineFlat && !texturedLine && !widthByRatio) {\n\n                //normalize vector to line width and rotate 90 degrees\n                if (geocent) {\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n        \n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n                    distance2 += l;\n        \n                    l = (l != 0) ? (1 / l) : 0;\n\n                    vv = [v[0]*l, v[1]*l, v[2]*l];\n                    n = [0,0,0];\n                    nn = [0,0,0];\n                    \n                    vec3Normalize(bboxMin, nn);\n                    vec3Cross(nn, vv, n);\n\n                    if (i == 0) {\n                        vstart = vv;\n                    }\n\n                    if (i == (li - 1)) {\n                        vend = vv;\n                    }\n                    \n                    n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\n                } else {\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n        \n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                    distance2 += l;\n        \n                    l = (l != 0) ? (lineWidth / l) : 0;\n\n                    n = [-v[1]*l, v[0]*l, 0];\n\n                    if (i == 0) {\n                        vstart = [v[0]*l, v[1]*l, 0];\n                    }\n\n                    if (i == (li - 1)) {\n                        vend = [v[0]*l, v[1]*l, 0];\n                    }\n                }\n                        \n                //add polygon\n                vertexBuffer[index] = p1[0] + n[0];\n                vertexBuffer[index+1] = p1[1] + n[1];\n                vertexBuffer[index+2] = p1[2] + n[2];\n    \n                vertexBuffer[index+3] = p1[0] - n[0];\n                vertexBuffer[index+4] = p1[1] - n[1];\n                vertexBuffer[index+5] = p1[2] - n[2];\n    \n                vertexBuffer[index+6] = p2[0] + n[0];\n                vertexBuffer[index+7] = p2[1] + n[1];\n                vertexBuffer[index+8] = p2[2] + n[2];\n    \n                //add polygon\n                vertexBuffer[index+9] = p1[0] - n[0];\n                vertexBuffer[index+10] = p1[1] - n[1];\n                vertexBuffer[index+11] = p1[2] - n[2];\n    \n                vertexBuffer[index+12] = p2[0] - n[0];\n                vertexBuffer[index+13] = p2[1] - n[1];\n                vertexBuffer[index+14] = p2[2] - n[2];\n    \n                vertexBuffer[index+15] = p2[0] + n[0];\n                vertexBuffer[index+16] = p2[1] + n[1];\n                vertexBuffer[index+17] = p2[2] + n[2];\n    \n                index += 18;\n\n            } else {\n    \n   \n                //console.log(\"distance(\"+i+\"): \" + distance + \" \" + distance2);\n    \n                if (lineFlat) {\n                    \n                    /*\n                    //normalize vector to line width and rotate 90 degrees\n                    l = (l != 0) ? (lineWidth / l) : 0;\n                    n = [-v[1]*l, v[0]*l,0];\n    \n                    if (joinParams != null) {\n                        joinParams[i] = (l != 0) ? Math.atan2(v[0], v[1]) + Math.PI *0.5 : 0;\n                    }*/\n    \n                    //normalize vector to line width and rotate 90 degrees\n                    if (geocent) {\n                        //direction vector\n                        v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            \n                        //get line length\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n                        distance2 += l;\n            \n                        l = (l != 0) ? (1 / l) : 0;\n\n                        vv = [v[0]*l, v[1]*l, v[2]*l];\n                        n = [0,0,0];\n                        nn = [0,0,0];\n\n                        if (i == 0) {\n                            vstart = vv;\n                        }\n\n                        if (i == (li - 1)) {\n                            vend = vv;\n                        }\n                        \n                        vec3Normalize(bboxMin, nn);\n                        vec3Cross(nn, vv, n);\n                        \n                        //n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\n                        n = [n[0], n[1], n[2]];\n                    } else {\n                        //direction vector\n                        v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n            \n                        //get line length\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                        distance2 += l;\n            \n                        l = (l != 0) ? (lineWidth / l) : 0;\n\n                        n = [-v[1], v[0], 0];\n\n                        if (i == 0) {\n                            vstart = [v[0]*l, v[1]*l, 0];\n                        }\n\n                        if (i == (li - 1)) {\n                            vend = [v[0]*l, v[1]*l, 0];\n                        }\n                    }\n\n                    //add polygon\n                    vertexBuffer[index] = p1[0];\n                    vertexBuffer[index+1] = p1[1];\n                    vertexBuffer[index+2] = p1[2];\n                    vertexBuffer[index+3] = distance;\n                    normalBuffer[index2] = n[0];\n                    normalBuffer[index2+1] = n[1];\n                    normalBuffer[index2+2] = n[2];\n                    normalBuffer[index2+3] = lineWidth;\n    \n                    vertexBuffer[index+4] = p1[0];\n                    vertexBuffer[index+5] = p1[1];\n                    vertexBuffer[index+6] = p1[2];\n                    vertexBuffer[index+7] = -distance;\n                    normalBuffer[index2+4] = -n[0];\n                    normalBuffer[index2+5] = -n[1];\n                    normalBuffer[index2+6] = -n[2];\n                    normalBuffer[index2+7] = lineWidth;\n    \n                    vertexBuffer[index+8] = p2[0];\n                    vertexBuffer[index+9] = p2[1];\n                    vertexBuffer[index+10] = p2[2];\n                    vertexBuffer[index+11] = distance2;\n                    normalBuffer[index2+8] = n[0];\n                    normalBuffer[index2+9] = n[1];\n                    normalBuffer[index2+10] = n[2];\n                    normalBuffer[index2+11] = lineWidth;\n    \n                    //add polygon\n                    vertexBuffer[index+12] = p1[0];\n                    vertexBuffer[index+13] = p1[1];\n                    vertexBuffer[index+14] = p1[2];\n                    vertexBuffer[index+15] = -distance;\n                    normalBuffer[index2+12] = -n[0];\n                    normalBuffer[index2+13] = -n[1];\n                    normalBuffer[index2+14] = -n[2];\n                    normalBuffer[index2+15] = lineWidth;\n    \n                    vertexBuffer[index+16] = p2[0];\n                    vertexBuffer[index+17] = p2[1];\n                    vertexBuffer[index+18] = p2[2];\n                    vertexBuffer[index+19] = -distance2;\n                    normalBuffer[index2+16] = -n[0];\n                    normalBuffer[index2+17] = -n[1];\n                    normalBuffer[index2+18] = -n[2];\n                    normalBuffer[index2+19] = lineWidth;\n    \n                    vertexBuffer[index+20] = p2[0];\n                    vertexBuffer[index+21] = p2[1];\n                    vertexBuffer[index+22] = p2[2];\n                    vertexBuffer[index+23] = distance2;\n                    normalBuffer[index2+20] = n[0];\n                    normalBuffer[index2+21] = n[1];\n                    normalBuffer[index2+22] = n[2];\n                    normalBuffer[index2+23] = lineWidth;\n    \n                    index += 24;\n                    index2 += 24;\n                    \n                } else {\n\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n        \n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                    distance2 += l;\n    \n                    //add polygon\n                    vertexBuffer[index] = p1[0];\n                    vertexBuffer[index+1] = p1[1];\n                    vertexBuffer[index+2] = p1[2];\n                    vertexBuffer[index+3] = distance;\n                    normalBuffer[index2] = p2[0];\n                    normalBuffer[index2+1] = p2[1];\n                    normalBuffer[index2+2] = p2[2];\n                    normalBuffer[index2+3] = lineWidth;\n    \n                    vertexBuffer[index+4] = p1[0];\n                    vertexBuffer[index+5] = p1[1];\n                    vertexBuffer[index+6] = p1[2];\n                    vertexBuffer[index+7] = -distance;\n                    normalBuffer[index2+4] = p2[0];\n                    normalBuffer[index2+5] = p2[1];\n                    normalBuffer[index2+6] = p2[2];\n                    normalBuffer[index2+7] = -lineWidth;\n    \n                    vertexBuffer[index+8] = p2[0];\n                    vertexBuffer[index+9] = p2[1];\n                    vertexBuffer[index+10] = p2[2];\n                    vertexBuffer[index+11] = -distance2;\n                    normalBuffer[index2+8] = p1[0];\n                    normalBuffer[index2+9] = p1[1];\n                    normalBuffer[index2+10] = p1[2];\n                    normalBuffer[index2+11] = lineWidth;\n    \n                    //add polygon\n                    vertexBuffer[index+12] = p1[0];\n                    vertexBuffer[index+13] = p1[1];\n                    vertexBuffer[index+14] = p1[2];\n                    vertexBuffer[index+15] = distance;\n                    normalBuffer[index2+12] = p2[0];\n                    normalBuffer[index2+13] = p2[1];\n                    normalBuffer[index2+14] = p2[2];\n                    normalBuffer[index2+15] = lineWidth;\n    \n                    vertexBuffer[index+16] = p2[0];\n                    vertexBuffer[index+17] = p2[1];\n                    vertexBuffer[index+18] = p2[2];\n                    vertexBuffer[index+19] = -distance2;\n                    normalBuffer[index2+16] = p1[0];\n                    normalBuffer[index2+17] = p1[1];\n                    normalBuffer[index2+18] = p1[2];\n                    normalBuffer[index2+19] = lineWidth;\n    \n                    vertexBuffer[index+20] = p2[0];\n                    vertexBuffer[index+21] = p2[1];\n                    vertexBuffer[index+22] = p2[2];\n                    vertexBuffer[index+23] = distance2;\n                    normalBuffer[index2+20] = p1[0];\n                    normalBuffer[index2+21] = p1[1];\n                    normalBuffer[index2+22] = p1[2];\n                    normalBuffer[index2+23] = -lineWidth;\n    \n                    index += 24;\n                    index2 += 24;\n                }\n            }\n    \n            distance = distance2;\n            p1 = p2; //only for dlines\n        }\n    \n        p1 = [p[0], p[1], p[2]];\n    \n        //add joins\n        for (i = 0, li = points.length; i < li; i++) {\n    \n            if (forceOrigin) {\n                p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n            }\n    \n            if (forceScale != null) {\n                p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n            }\n    \n            center[0] += p1[0];\n            center[1] += p1[1];\n            center[2] += p1[2];\n            \n            if (!skipJoins) {\n                var angleShift = 0;//(joinParams != null) ? joinParams[i] : 0;\n                /*var dx, dy;*/\n\n                if (lineFlat) {\n\n                    if (advancedHit) {\n                        elementIndex = elemetBase + ((i != (li-1)) ? i : (i -1));\n\n                        elementBuffer[index3] = elementIndex;\n                        elementBuffer[index3+1] = elementIndex;\n                        elementBuffer[index3+2] = elementIndex;\n            \n                        //add polygon\n                        elementBuffer[index3+3] = elementIndex;\n                        elementBuffer[index3+4] = elementIndex;\n                        elementBuffer[index3+5] = elementIndex;\n\n                        index3 += 6;\n                    }\n\n                    var lineIndex, lineIndex2;\n\n                    if (!(texturedLine || widthByRatio)) {\n\n                        if (i != (li-1)) {\n                            lineIndex = vertexBase + i * lineVertices;\n                        } else {\n                            lineIndex = vertexBase + (i - 1) * lineVertices;\n                        }\n\n                        if (i > 0) {\n                            lineIndex2 = vertexBase + (i - 1) * lineVertices;\n                        } else {\n                            lineIndex2 = vertexBase + lineIndex;\n                        }\n\n                        if (i == 0) { //start cap\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\n\n                            vertexBuffer[index+6] = p1[0] - vstart[0] * lineWidth;\n                            vertexBuffer[index+7] = p1[1] - vstart[1] * lineWidth;\n                            vertexBuffer[index+8] = p1[2] - vstart[2] * lineWidth;\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\n\n                            vertexBuffer[index+9+6] = p1[0] - vstart[0] * lineWidth;\n                            vertexBuffer[index+9+7] = p1[1] - vstart[1] * lineWidth;\n                            vertexBuffer[index+9+8] = p1[2] - vstart[2] * lineWidth;\n                        } else if (i == (li - 1)) {  //end cap\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex+15];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+16];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+17];\n\n                            vertexBuffer[index+6] = p1[0] + vend[0] * lineWidth;\n                            vertexBuffer[index+7] = p1[1] + vend[1] * lineWidth;\n                            vertexBuffer[index+8] = p1[2] + vend[2] * lineWidth;\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+12];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+13];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+14];\n\n                            vertexBuffer[index+9+6] = p1[0] + vend[0] * lineWidth;\n                            vertexBuffer[index+9+7] = p1[1] + vend[1] * lineWidth;\n                            vertexBuffer[index+9+8] = p1[2] + vend[2] * lineWidth;\n                        } else {\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\n\n                            vertexBuffer[index+6] = vertexBuffer[lineIndex2 + 15];\n                            vertexBuffer[index+7] = vertexBuffer[lineIndex2 + 16];\n                            vertexBuffer[index+8] = vertexBuffer[lineIndex2 + 17];\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\n\n                            vertexBuffer[index+9+6] = vertexBuffer[lineIndex2 + 12];\n                            vertexBuffer[index+9+7] = vertexBuffer[lineIndex2 + 13];\n                            vertexBuffer[index+9+8] = vertexBuffer[lineIndex2 + 14];\n                        }\n\n                        index += 18;\n\n                    } else {\n\n                        if (i != (li-1)) {\n                            distance = vertexBuffer[i * lineVertices + 3];\n                        } else {\n                            distance = vertexBuffer[(i - 1) * lineVertices + 11];\n                        }\n\n                        if (i != (li-1)) {\n                            lineIndex = normalBase + i * lineVertices;\n                        } else {\n                            lineIndex = normalBase + (i - 1) * lineVertices + 8;\n                        }\n\n                        if (i > 0) {\n                            lineIndex2 = normalBase + (i - 1) * lineVertices + 8;\n                        } else {\n                            lineIndex2 = normalBase + lineIndex;\n                        }\n\n                        //add polygon\n                        vertexBuffer[index] = p1[0];\n                        vertexBuffer[index+1] = p1[1];\n                        vertexBuffer[index+2] = p1[2];\n                        vertexBuffer[index+3] = distance;\n\n                        vertexBuffer[index+4] = p1[0];\n                        vertexBuffer[index+5] = p1[1];\n                        vertexBuffer[index+6] = p1[2];\n                        vertexBuffer[index+7] = distance;\n\n                        vertexBuffer[index+8] = p1[0];\n                        vertexBuffer[index+9] = p1[1];\n                        vertexBuffer[index+10] = p1[2];\n                        vertexBuffer[index+11] = distance;\n\n                        //add polygon\n                        vertexBuffer[index+12] = p1[0];\n                        vertexBuffer[index+1+12] = p1[1];\n                        vertexBuffer[index+2+12] = p1[2];\n                        vertexBuffer[index+3+12] = distance;\n\n                        vertexBuffer[index+4+12] = p1[0];\n                        vertexBuffer[index+5+12] = p1[1];\n                        vertexBuffer[index+6+12] = p1[2];\n                        vertexBuffer[index+7+12] = -distance;\n\n                        vertexBuffer[index+8+12] = p1[0];\n                        vertexBuffer[index+9+12] = p1[1];\n                        vertexBuffer[index+10+12] = p1[2];\n                        vertexBuffer[index+11+12] = -distance;\n\n                        if (i == 0) { //start cap\n                            //first polygon\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n            \n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7] = lineWidth;\n            \n                            normalBuffer[index2+8] = -vstart[0];\n                            normalBuffer[index2+9] = -vstart[1];\n                            normalBuffer[index2+10] = -vstart[2];\n                            normalBuffer[index2+11] = -lineWidth;\n\n                            //second polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n            \n                            normalBuffer[index2+8+12] = -vstart[0];\n                            normalBuffer[index2+9+12] = -vstart[1];\n                            normalBuffer[index2+10+12] = -vstart[2];\n                            normalBuffer[index2+11+12] = -lineWidth;\n                        } else if (i == (li - 1)) {  //end cap\n                            //first polygon\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n            \n                            normalBuffer[index2+4] = normalBuffer[lineIndex2];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+7] = lineWidth;\n            \n                            normalBuffer[index2+8] = vend[0];\n                            normalBuffer[index2+9] = vend[1];\n                            normalBuffer[index2+10] = vend[2];\n                            normalBuffer[index2+11] = -lineWidth;\n\n                            //second polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex2];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n            \n                            normalBuffer[index2+8+12] = vend[0];\n                            normalBuffer[index2+9+12] = vend[1];\n                            normalBuffer[index2+10+12] = vend[2];\n                            normalBuffer[index2+11+12] = -lineWidth;\n                        } else {\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n            \n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7] = lineWidth;\n            \n                            normalBuffer[index2+8] = normalBuffer[lineIndex2];\n                            normalBuffer[index2+9] = normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+10] = normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+11] = lineWidth;\n\n                            //add polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n            \n                            normalBuffer[index2+8+12] = -normalBuffer[lineIndex2];\n                            normalBuffer[index2+9+12] = -normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+10+12] = -normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+11+12] = lineWidth;\n                        }\n\n                        index += 24;\n                        index2 += 24;\n\n                    }\n\n                } else {\n\n                    var segmentIndex = (i != (li-1)) ? i : (i - 1);\n\n                    for (var j = 0; j < circleSides; j++) {\n           \n                        if (advancedHit) {\n                            elementIndex = elemetBase + segmentIndex;\n                            elementBuffer[index3] = elementIndex;\n                            elementBuffer[index3+1] = elementIndex;\n                            elementBuffer[index3+2] = elementIndex;\n                            index3 += 3;\n                        }\n\n                        distance = vertexBuffer[segmentIndex * lineVertices + 3];\n        \n                        //add polygon\n                        vertexBuffer[index] = p1[0];\n                        vertexBuffer[index+1] = p1[1];\n                        vertexBuffer[index+2] = p1[2];\n                        vertexBuffer[index+3] = distance;\n                        normalBuffer[index2] = 0;\n                        normalBuffer[index2+1] = 0;\n                        normalBuffer[index2+2] = 0;\n                        normalBuffer[index2+3] = 0;\n        \n                        vertexBuffer[index+4] = p1[0];\n                        vertexBuffer[index+5] = p1[1];\n                        vertexBuffer[index+6] = p1[2];\n                        vertexBuffer[index+7] = distance;\n                        normalBuffer[index2+4] = circleBuffer[j][0] * lineWidth;\n                        normalBuffer[index2+5] = circleBuffer[j][1] * lineWidth;\n                        normalBuffer[index2+6] = circleBuffer2[j] + angleShift;\n                        normalBuffer[index2+7] = 0;\n        \n                        vertexBuffer[index+8] = p1[0];\n                        vertexBuffer[index+9] = p1[1];\n                        vertexBuffer[index+10] = p1[2];\n                        vertexBuffer[index+11] = distance;\n                        normalBuffer[index2+8] = circleBuffer[j+1][0] * lineWidth;\n                        normalBuffer[index2+9] = circleBuffer[j+1][1] * lineWidth;\n                        normalBuffer[index2+10] = circleBuffer2[j+1] + angleShift;\n                        normalBuffer[index2+11] = 0;\n        \n                        index += 12;\n                        index2 += 12;\n                    }\n                }\n            }\n    \n            if (lineLabel) {\n                p = [p1[0], p1[1], p1[2] + lineLabelSize*0.1];\n                lineLabelPoints[i] = p;\n                lineLabelPoints2[li - i - 1] = p;\n            }\n    \n            if ((i + 1) < li) {\n                if (dlines) {\n                    p2 = points[i+1];\n                    p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\n                } else {\n                    p1 = points[i+1];\n                }\n            }\n        }\n\n        elemetBase += points.length;\n    }\n\n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += globals.groupOrigin[0];\n    center[1] += globals.groupOrigin[1];\n    center[2] += globals.groupOrigin[2];\n\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent, type;\n\n    if (line) {\n        //console.log('totalPoints:' + totalPoints + ' vbuff-l:' + (vertexBuffer ? vertexBuffer.length : '??'));\n\n        var messageData = {\n            'color':lineColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit, 'totalPoints': totalPoints,\n            'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'width-units': lineWidthUnits,\n            'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n            'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, \n            'line-width':lineWidth*2, 'lod':(globals.autoLod ? null : globals.tileLod) };\n    \n        if (lineFlat) {\n            type = texturedLine ? VTS_WORKER_TYPE_FLAT_TLINE : (widthByRatio ? VTS_WORKER_TYPE_FLAT_RLINE : VTS_WORKER_TYPE_FLAT_LINE);\n        } else {\n            type = texturedLine ? VTS_WORKER_TYPE_PIXEL_TLINE : VTS_WORKER_TYPE_PIXEL_LINE;\n        }\n    \n        if (texturedLine) {\n            if (lineStyleTexture != null) {\n                messageData['texture'] = [globals.stylesheetBitmaps[lineStyleTexture[0]], lineStyleTexture[1], lineStyleTexture[2]];\n                messageData['background'] = lineStyleBackground;\n            }\n        }\n\n        var signature = JSON.stringify({\n            type: 'T'+type,\n            color : lineColor,\n            zIndex : zIndex,\n            zOffset : zbufferOffset,\n            state : globals.hitState\n        });\n\n        var buffers = (normalBuffer) ? [vertexBuffer, normalBuffer] : [vertexBuffer];\n\n        if (advancedHit) {\n            buffers.push(elementBuffer);\n        }\n        \n        postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, type, messageData, buffers, signature);\n    }\n\n    if (lineLabel) {\n        for (i = 0, li = lineLabelStack.length; i < li; i++) {\n            processLineLabel(lineLabelStack[i].points, lineLabelStack[i].points2, lineString, center, lod, style, featureIndex, zIndex, eventInfo);\n        }\n    }\n\n};\n\nvar processLineLabel = function(lineLabelPoints, lineLabelPoints2, lineString, center, lod, style, featureIndex, zIndex, eventInfo) {\n    var labelColor = getLayerPropertyValue(style, 'line-label-color', lineString, lod);\n    var labelColor2 = getLayerPropertyValue(style, 'line-label-color2', lineString, lod);\n    var labelOutline = getLayerPropertyValue(style, 'line-label-outline', lineString, lod);\n    var labelSource = getLayerPropertyValue(style, 'line-label-source', lineString, lod);\n    var labelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\n    var labelSpacing = getLayerPropertyValue(style, 'line-label-spacing', lineString, lod);\n    var labelLineHeight = getLayerPropertyValue(style, 'line-label-line-height', lineString, lod);\n    var labelOffset = getLayerPropertyValue(style, 'line-label-offset', lineString, lod);\n\n    if (Math.abs(labelSize) < 0.0001) {\n        return;\n    }\n\n    var labelText = getLayerExpresionValue(style, labelSource, lineString, lod, labelSource);\n    labelText = labelText ? labelText.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n    var fontNames = getLayerPropertyValue(style, 'line-label-font', lineString, lod);\n    var fonts = getFonts(fontNames);\n    var fontsStorage = getFontsStorage(fontNames);\n    var glyphsRes = getTextGlyphs(labelText, fonts);\n\n    if (labelSource == '$name') {\n        if (!areTextCharactersAvailable(labelText, fonts, glyphsRes)) {\n            var labelText2 = getLayerExpresionValue(style, '$name:en', lineString, lod, labelSource);\n            labelText2 = labelText2 ? labelText2.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n            var glyphsRes2 = getTextGlyphs(labelText, fonts);\n            \n            if (areTextCharactersAvailable(labelText2, fonts, glyphsRes2)) {\n                labelText = labelText2;                     \n                glyphsRes = glyphsRes2;\n            }\n        }\n    }\n\n    if (!labelText || labelText == '') {\n        return;\n    }\n\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\n    var clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\n\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\n\n    var bufferSize = getCharVerticesCount() * labelText.length * 2;\n    var vertexBuffer = new Float32Array(bufferSize);\n    var texcoordsBuffer = new Float32Array(bufferSize);\n    var planes = {};\n\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n\n    var index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes);\n    index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, index, null, glyphsRes);\n\n    if (!index) {\n        return;\n    }\n\n    //var fonts = labelData.fonts;\n    var labelFiles = new Array(fonts.length);\n\n    for (var i = 0, li= fonts.length; i < li; i++) {\n        labelFiles[i] = [];\n    }\n\n    for (var key in planes) {\n        var fontIndex = parseInt(key);\n        var planes2 = planes[key];\n\n        var files = [];\n\n        for (var key2 in planes2) {\n            var plane = parseInt(key2) - (fontIndex*4000);\n            var file = Math.round((plane - (plane % 4)) / 4);\n\n            if (files.indexOf(file) == -1) {\n                files.push(file);\n            }\n        }\n\n        labelFiles[fontIndex] = files;\n    }\n\n    var signature = JSON.stringify({\n        type: 'line-label',\n        color : labelColor,\n        color2 : labelColor2,\n        outline : labelOutline,\n        fonts : fontNames,\n        zIndex : zIndex,\n        zOffset : zbufferOffset\n    });\n\n    postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_LINE_LABEL, {\n        'color':labelColor, 'color2':labelColor2, 'outline':labelOutline, \n        'z-index':zIndex, 'center': center, 'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\n        'files': labelFiles, 'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'advancedHit': advancedHit,\n        'fonts': fontsStorage, 'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \n        'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, texcoordsBuffer], signature);\n};\n\nvar processLineStringGeometry = function(lineString) {\n    var lines = (lineString['lines'] || lineString['d-lines'])  || [];\n\n    if (lines.length == 0) {\n        return;\n    }\n\n    //debugger\n\n    var dlines = (lineString['d-lines']) ? true : false;\n    var totalPoints = 0;\n    var indicesBuffer = new Uint32Array(lines.length);\n\n    for (i = 0; i < lines.length; i++) {\n        indicesBuffer[i] = totalPoints;\n\n        if (Array.isArray(lines[i])) {\n            totalPoints += lines[i].length;\n        }\n    }\n\n    var geometryBuffer = new Float64Array(totalPoints * 3);\n\n    /*var forceOrigin = globals.forceOrigin;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;*/\n    var forceScale = globals.forceScale;\n    var index = 0, p1, p2, pp, p;\n\n    for (var i = 0; i < lines.length; i++) {\n        if (!Array.isArray(lines[i]) || !lines[i].length) {\n            continue;\n        }\n        \n        var points = lines[i];\n   \n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n    \n        //add lines\n        for (var j = 0, lj = points.length; j < lj; j++) {\n\n            /*if (forceOrigin) {\n                pp = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n            }*/\n    \n            if (forceScale != null) {\n                pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n            }\n\n            geometryBuffer[index] = pp[0];\n            geometryBuffer[index+1] = pp[1];\n            geometryBuffer[index+2] = pp[2];\n            index += 3;\n\n            if (j == (lj - 1)) {\n                break;\n            }\n    \n            if (dlines) {\n                p2 = points[j+1];\n                p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\n            } else {\n                p1 = points[j+1];\n            }   \n        }\n    }\n\n    globals.signatureCounter++;\n\n    postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_LINE_GEOMETRY, {\n        'id':lineString['id'] }, [geometryBuffer, indicesBuffer], (\"\"+globals.signatureCounter));\n};\n\n\nexport {processLineStringPass, processLineLabel, processLineStringGeometry};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-linestring.js\n// module id = 4\n// module chunks = 0","\nimport {globals as globals_, clamp as clamp_} from './worker-globals.js';\nimport {getLayerPropertyValue as getLayerPropertyValue_, getLayerExpresionValue as getLayerExpresionValue_} from './worker-style.js';\nimport {addText as addText_, getSplitIndex as getSplitIndex_, getTextGlyphs as getTextGlyphs_,\n        getTextLength as getTextLength_, getFonts as getFonts_, getFontsStorage as getFontsStorage_,\n        areTextCharactersAvailable as areTextCharactersAvailable_, getCharVerticesCount as getCharVerticesCount_, getLineHeight as getLineHeight_} from './worker-text.js';\nimport {postGroupMessageFast as postGroupMessageFast_} from './worker-message.js';\n\n//get rid of compiler mess\nvar globals = globals_, clamp = clamp_;\nvar getLayerPropertyValue = getLayerPropertyValue_, getLayerExpresionValue = getLayerExpresionValue_;\nvar addText = addText_, getSplitIndex = getSplitIndex_, getTextGlyphs = getTextGlyphs_,\n    getTextLength = getTextLength_, getFonts = getFonts_, getFontsStorage = getFontsStorage_,\n    areTextCharactersAvailable = areTextCharactersAvailable_, getCharVerticesCount = getCharVerticesCount_, getLineHeight = getLineHeight_;\nvar postGroupMessageFast = postGroupMessageFast_;\n\n\nvar processPointArrayPass = function(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\n    var pointsGroups = []; \n    var i, li, dpoints = false;\n\n    if (pointArray['lines'] || pointArray['d-lines']) {  //use lines as points\n        pointsGroups = pointArray['lines'] || pointArray['d-lines'];\n        dpoints = (pointArray['d-lines']) ? true : false;\n    } else {\n        if (pointArray['points'] || pointArray['d-points']) {\n            pointsGroups = [(pointArray['points'] || pointArray['d-points'])];\n            dpoints = (pointArray['d-points']) ? true : false;\n        }\n    }\n    \n    if (pointsGroups.length == 0) {\n        return;\n    }\n\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) || \n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\n    var culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', pointArray, lod);\n    var clickEvent = getLayerPropertyValue(style, 'click-event', pointArray, lod);\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', pointArray, lod);\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', pointArray, lod);\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', pointArray, lod);\n    var advancedHit = getLayerPropertyValue(style, 'advanced-event', pointArray, lod);\n\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', pointArray, lod);\n\n    var point = getLayerPropertyValue(style, 'point', pointArray, lod);\n    var pointFlat = getLayerPropertyValue(style, 'point-flat', pointArray, lod);\n    var pointColor = getLayerPropertyValue(style, 'point-color', pointArray, lod);\n    var pointRadius = 0.5 * getLayerPropertyValue(style, 'point-radius', pointArray, lod);\n\n    var source, bufferSize, bufferSize2, points, g, gl, totalPoints = 0;\n    //zIndex = (zIndex !== null) ? zIndex : getLayerPropertyValue(style, \"z-index\", pointArray, lod);\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        if (Array.isArray(points) && points.length > 0) {\n            totalPoints += points.length;\n        }\n    }\n\n    var icon = getLayerPropertyValue(style, 'icon', pointArray, lod);\n    if (icon) {\n        source = getLayerPropertyValue(style, 'icon-source', pointArray, lod);\n        \n        if (source) {\n            bufferSize = getCharVerticesCount() * totalPoints;\n            bufferSize2 = getCharVerticesCount(true) * totalPoints;\n    \n            var iconData = {\n                color : getLayerPropertyValue(style, 'icon-color', pointArray, lod),\n                scale : getLayerPropertyValue(style, 'icon-scale', pointArray, lod),\n                offset : getLayerPropertyValue(style, 'icon-offset', pointArray, lod),\n                stick : getLayerPropertyValue(style, 'icon-stick', pointArray, lod),\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\n                origin : getLayerPropertyValue(style, 'icon-origin', pointArray, lod),\n                source : getLayerPropertyValue(style, 'icon-source', pointArray, lod),\n                noOverlap : getLayerPropertyValue(style, 'icon-no-overlap', pointArray, lod),\n                noOverlapMargin : getLayerPropertyValue(style, 'icon-no-overlap-margin', pointArray, lod),\n                noOverlapFactor : getLayerPropertyValue(style, 'icon-no-overlap-factor', pointArray, lod),\n                index : 0,\n                index2 : 0\n            };\n\n            if (totalPoints > 1) {\n                iconData.vertexBuffer = new Float32Array(bufferSize);\n                iconData.originBuffer = new Float32Array(bufferSize2);\n                iconData.texcoordsBuffer = new Float32Array(bufferSize);\n            } else {\n                iconData.singleBuffer = new Float32Array(16);\n            }\n\n        } else {\n            icon = false;\n        }\n    }\n\n    var label = getLayerPropertyValue(style, 'label', pointArray, lod);\n    if (label) {\n        source = getLayerPropertyValue(style, 'label-source', pointArray, lod);\n\n        var text = getLayerExpresionValue(style, source, pointArray, lod, source);\n        text = text ? text.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n        var size = getLayerPropertyValue(style, 'label-size', pointArray, lod);\n        var fontNames = getLayerPropertyValue(style, 'label-font', pointArray, lod);\n        var fonts = getFonts(fontNames);\n        var glyphsRes = getTextGlyphs(text, fonts);\n        \n        if (source == '$name') {\n            if (!areTextCharactersAvailable(text, fonts, glyphsRes)) {\n                var text2 = getLayerExpresionValue(style, '$name:en', pointArray, lod, source);\n                text2 = text2 ? text2.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n                var glyphsRes2 = getTextGlyphs(text2, fonts);\n                \n                if (areTextCharactersAvailable(text2, fonts)) {\n                    text = text2;                     \n                    glyphsRes = glyphsRes2;\n                }\n            }\n        }\n        if (text && text != '' && Math.abs(size) > 0.0001) {\n            bufferSize = getCharVerticesCount() * text.length * totalPoints;\n            bufferSize2 = getCharVerticesCount(true) * text.length * totalPoints;\n\n            var useSingleBuffer = (totalPoints == 1);\n\n            var factor = 1;\n            if (getLayerPropertyValue(style, 'label-size-units', pointArray, lod) == 'points') {\n                factor = globals.pixelFactor / ((1 / 72) * (96));\n            }\n\n            var labelData = {\n                color : getLayerPropertyValue(style, 'label-color', pointArray, lod),\n                color2 : getLayerPropertyValue(style, 'label-color2', pointArray, lod),\n                outline : getLayerPropertyValue(style, 'label-outline', pointArray, lod),\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\n                size : size * factor,\n                spacing: getLayerPropertyValue(style, 'label-spacing', pointArray, lod),\n                lineHeight: getLayerPropertyValue(style, 'label-line-height', pointArray, lod),\n                offset : getLayerPropertyValue(style, 'label-offset', pointArray, lod),\n                stick : getLayerPropertyValue(style, 'label-stick', pointArray, lod),\n                origin : getLayerPropertyValue(style, 'label-origin', pointArray, lod),\n                align : getLayerPropertyValue(style, 'label-align', pointArray, lod),\n                fonts : fonts,\n                fontsStorage : getFontsStorage(fontNames),\n                text : text,\n                hysteresis : getLayerPropertyValue(style, 'hysteresis', pointArray, lod),\n                width : factor * getLayerPropertyValue(style, 'label-width', pointArray, lod),\n                noOverlap : getLayerPropertyValue(style, 'label-no-overlap', pointArray, lod),\n                noOverlapMargin : getLayerPropertyValue(style, 'label-no-overlap-margin', pointArray, lod),\n                noOverlapFactor : getLayerPropertyValue(style, 'label-no-overlap-factor', pointArray, lod),\n                vertexBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\n                originBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize2)),\n                texcoordsBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\n                singleBuffer : (useSingleBuffer) ? (new Float32Array(text.length * 4 * 2)) : null,\n                index : 0,\n                index2 : 0,\n                glyphsRes : glyphsRes\n            };\n\n            if (labelData.stick) {\n                labelData.stick = labelData.stick.slice();\n                labelData.stick[2] *= factor;\n                //labelData.stick[7] *= factor;\n            }\n\n        } else {\n            label = false;\n        }\n    }\n\n    var index = 0;\n    var index2 = 0;\n\n    \n    var center = [0,0,0];\n    var forceOrigin = globals.forceOrigin;\n    var bboxMin = globals.bboxMin;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceScale = globals.forceScale;\n    var labelBBox, iconBBox, p, p1;\n\n    var pointsVertices, vertexBuffer, pointsNormals, normalBuffer;\n\n    if (point) {\n        var circleBuffer = [];\n        var circleSides = clamp(pointRadius * 8 * 0.5, 8, 32);\n\n        var angle = 0, step = (2.0*Math.PI) / circleSides;\n\n        for (i = 0; i < circleSides; i++) {\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\n            angle += step;\n        }\n\n        circleBuffer[circleSides] = [0, 1.0];\n\n        //allocate buffers\n        if (!pointFlat) {\n            pointsVertices = circleSides * 3 * 4;\n            vertexBuffer = new Float32Array(totalPoints * pointsVertices);\n            pointsNormals = circleSides * 3 * 4;\n            normalBuffer = new Float32Array(totalPoints * pointsNormals);\n        } else {\n            pointsVertices = circleSides * 3 * 3;\n            vertexBuffer = new Float32Array(totalPoints * pointsVertices);\n        }\n    }\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        \n        if (Array.isArray(points) && points.length > 0) {\n            p = points[0];\n            p1 = [p[0], p[1], p[2]];\n       \n            //add ponints\n            for (i = 0, li = points.length; i < li; i++) {\n        \n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                }\n        \n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                }\n        \n                center[0] += p1[0];\n                center[1] += p1[1];\n                center[2] += p1[2];\n\n                if (icon) {\n                    iconBBox = processIcon(p1, iconData) ;//, pointArray, lod, style, zIndex);\n                }\n    \n                if (label) {\n                    labelBBox = processLabel(p1, labelData); //, pointArray, lod, style, zIndex);\n                }\n\n                if (point) {\n        \n                    for (var j = 0; j < circleSides; j++) {\n\n       \n                        if (pointFlat) {\n        \n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n        \n                            vertexBuffer[index+3] = p1[0] + circleBuffer[j][0] * pointRadius;\n                            vertexBuffer[index+4] = p1[1] + circleBuffer[j][1] * pointRadius;\n                            vertexBuffer[index+5] = p1[2];\n        \n                            vertexBuffer[index+6] = p1[0] + circleBuffer[j+1][0] * pointRadius;\n                            vertexBuffer[index+7] = p1[1] + circleBuffer[j+1][1] * pointRadius;\n                            vertexBuffer[index+8] = p1[2];\n\n                            index += 9;\n        \n                        } else {\n        \n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n                            vertexBuffer[index+3] = 0;\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = 0;\n        \n                            vertexBuffer[index+4] = p1[0];\n                            vertexBuffer[index+5] = p1[1];\n                            vertexBuffer[index+6] = p1[2];\n                            vertexBuffer[index+7] = 0;\n                            normalBuffer[index2+4] = circleBuffer[j][0] * pointRadius;\n                            normalBuffer[index2+5] = circleBuffer[j][1] * pointRadius;\n                            normalBuffer[index2+6] = 0;\n                            normalBuffer[index2+7] = 0;\n        \n                            vertexBuffer[index+8] = p1[0];\n                            vertexBuffer[index+9] = p1[1];\n                            vertexBuffer[index+10] = p1[2];\n                            vertexBuffer[index+11] = 0;\n                            normalBuffer[index2+8] = circleBuffer[j+1][0] * pointRadius;\n                            normalBuffer[index2+9] = circleBuffer[j+1][1] * pointRadius;\n                            normalBuffer[index2+10] = 0;\n                            normalBuffer[index2+11] = 0;\n        \n                            index += 12;\n                            index2 += 12;\n                        }\n                    }\n                }\n        \n                if ((i + 1) < li) {\n                    if (dpoints) {\n                        var p2 = points[i+1];\n                        p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\n                    } else {\n                        p1 = points[i+1];\n                    }\n                }\n            }\n        }\n    }\n   \n\n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += bboxMin[0];//groupOrigin[0];\n    center[1] += bboxMin[1];//groupOrigin[1];\n    center[2] += bboxMin[2];//groupOrigin[2];\n\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n    var message, messageSize;\n\n    globals.signatureCounter++;\n    var signature = (\"\"+globals.signatureCounter);\n\n    if (visibility && !Array.isArray(visibility)) {\n        visibility = [visibility];\n    }\n\n    if (point) {\n        if (pointFlat) {\n            postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_FLAT_LINE, {\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer], signature);\n        } else {\n            postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_PIXEL_LINE, {\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, normalBuffer], signature);\n        }\n    }\n\n    if (icon) {\n\n        globals.signatureCounter++;\n        signature = (\"\"+globals.signatureCounter);\n\n        if (iconData.noOverlap) {\n            var margin = iconData.noOverlapMargin;\n            var factorType = null, factorValue = null;\n\n            if (iconData.noOverlapFactor !== null) {\n                switch(iconData.noOverlapFactor[0]) {\n                    case 'direct':      factorType = VTS_NO_OVERLAP_DIRECT;      break;\n                    case 'div-by-dist': factorType = VTS_NO_OVERLAP_DIV_BY_DIST; break;\n                }\n\n                factorValue = iconData.noOverlapFactor[1];\n            }\n\n            var noOverlap = [iconBBox[0]-margin[0], iconBBox[1]-margin[1], iconBBox[2]+margin[0], iconBBox[3]+margin[1], factorType, factorValue];\n        }\n\n        if ((iconData.singleBuffer && iconData.singleBuffer.length > 0) || (iconData.vertexBuffer && iconData.vertexBuffer.length > 0)) {\n\n            postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, (labelData.singleBuffer) ? VTS_WORKER_TYPE_ICON : VTS_WORKER_TYPE_ICON2, {\n                'icon':globals.stylesheetBitmaps[iconData.source[0]], 'color':iconData.color, 'z-index':zIndex,\n                'visibility': visibility, 'culling': culling, 'center': center, 'stick': iconData.stick,\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'noOverlap' : (iconData.noOverlap ? noOverlap: null),\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n                'index': featureIndex, 'reduce': iconData.reduce, 'lod':(globals.autoLod ? null : globals.tileLod) },\n                (iconData.singleBuffer) ? [iconData.singleBuffer] : [iconData.vertexBuffer, iconData.originBuffer, iconData.texcoordsBuffer],\n                signature);\n        }\n    }\n\n    if (label) {\n        globals.signatureCounter++;\n        signature = (\"\"+globals.signatureCounter);\n\n        if (labelData.noOverlap) {\n            var margin = labelData.noOverlapMargin;\n            var factorType = null, factorValue = null;\n\n            if (labelData.noOverlapFactor !== null) {\n                switch(labelData.noOverlapFactor[0]) {\n                    case 'direct':      factorType = VTS_NO_OVERLAP_DIRECT;      break;\n                    case 'div-by-dist': factorType = VTS_NO_OVERLAP_DIV_BY_DIST; break;\n                }\n\n                factorValue = labelData.noOverlapFactor[1];\n            }\n\n            var noOverlap = [labelBBox[0]-margin[0], labelBBox[1]-margin[1], labelBBox[2]+margin[0], labelBBox[3]+margin[1], factorType, factorValue];\n        }\n\n        if ((labelData.singleBuffer && labelData.singleBuffer.length > 0) || (labelData.vertexBuffer && labelData.vertexBuffer.length > 0)) {\n\n            postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, (labelData.singleBuffer) ? VTS_WORKER_TYPE_LABEL : VTS_WORKER_TYPE_LABEL2, {\n                'size':labelData.size, 'origin':labelData.pos, 'color':labelData.color,\n                'color2':labelData.color2, 'outline':labelData.outline, 'z-index':zIndex, 'visibility': visibility,\n                'culling': culling, 'center': center, 'stick': labelData.stick, 'noOverlap' : (labelData.noOverlap ? noOverlap: null),\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'files':labelData.files, 'index': featureIndex,\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'fonts': labelData.fontsStorage,\n                'hitable':hitable, 'state':globals.hitState, 'advancedHit': advancedHit, 'reduce': labelData.reduce, 'hysteresis': labelData.hysteresis, \n                'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, 'lod':(globals.autoLod ? null : globals.tileLod) },\n                (labelData.singleBuffer) ? [labelData.singleBuffer] : [labelData.vertexBuffer, labelData.originBuffer, labelData.texcoordsBuffer],\n                signature);\n        }\n    }\n\n};\n\n\nvar processPointArrayVSwitchPass = function(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\n    var pointsGroups = []; \n    var i, li, dpoints = false;\n\n    if (pointArray['lines'] || pointArray['d-lines']) {  //use lines as points\n        pointsGroups = pointArray['lines'] || pointArray['d-lines'];\n        dpoints = (pointArray['d-lines']) ? true : false;\n    } else {\n        if (pointArray['points'] || pointArray['d-points']) {\n            pointsGroups = [(pointArray['points'] || pointArray['d-points'])];\n            dpoints = (pointArray['d-points']) ? true : false;\n        }\n    }\n    \n    if (pointsGroups.length == 0) {\n        return;\n    }\n\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) || \n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\n    var culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\n    var hysteresis = getLayerPropertyValue(style, 'hysteresis', pointArray, lod);\n\n    var points, g, gl, totalPoints = 0;\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        if (Array.isArray(points) && points.length > 0) {\n            totalPoints += points.length;\n        }\n    }\n\n    var center = [0,0,0];\n    var forceOrigin = globals.forceOrigin;\n    var bboxMin = globals.bboxMin;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceScale = globals.forceScale;\n    var p, p1;\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        \n        if (Array.isArray(points) && points.length > 0) {\n            p = points[0];\n            p1 = [p[0], p[1], p[2]];\n       \n            //add ponints\n            for (i = 0, li = points.length; i < li; i++) {\n        \n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                }\n        \n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                }\n        \n                center[0] += p1[0];\n                center[1] += p1[1];\n                center[2] += p1[2];\n       \n                if ((i + 1) < li) {\n                    if (dpoints) {\n                        var p2 = points[i+1];\n                        p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\n                    } else {\n                        p1 = points[i+1];\n                    }\n                }\n            }\n        }\n    }\n   \n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += bboxMin[0];//groupOrigin[0];\n    center[1] += bboxMin[1];//groupOrigin[1];\n    center[2] += bboxMin[2];//groupOrigin[2];\n\n    globals.signatureCounter++;\n    var signature = (\"\"+globals.signatureCounter);\n\n    postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_VSPOINT, {\n        'z-index':zIndex, 'hysteresis' : hysteresis,\n        'visibility': visibility, 'culling': culling, 'center': center, 'eventInfo': {} /*(globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}*/,\n         'index': featureIndex, 'lod':(globals.autoLod ? null : globals.tileLod) }, [], signature);\n};\n\n\nvar getOriginOffset = function(origin, width, height) {\n    switch(origin) {\n    case 'top-left':        return [0, 0];\n    case 'top-right':       return [-width, 0];\n    case 'top-center':      return [-width*0.5, 0];\n    case 'center-left':     return [0, -height*0.5];\n    case 'center-right':    return [-width, -height*0.5];\n    case 'center-center':   return [-width*0.5, -height*0.5];\n    case 'bottom-left':     return [0, -height];\n    case 'bottom-right':    return [-width, -height];\n    case 'bottom-center':   return [-width*0.5, -height];\n    }\n};\n\nvar processIcon = function(point, iconData) {\n    var icon = iconData.source;\n    var index = iconData.index;\n    var index2 = iconData.index2;\n    var lastIndex = index;\n\n    var width = Math.abs(icon[3] * iconData.scale * 0.5);\n    var height = Math.abs(icon[4] * iconData.scale * 0.5);\n\n    //get offset\n    var originOffset = getOriginOffset(iconData.origin, width, height);\n    var offsetX = originOffset[0] + iconData.offset[0];\n    var offsetY = originOffset[1] + iconData.offset[1];\n\n    if (iconData.singleBuffer) {\n        var b = iconData.singleBuffer;\n\n        b[0] = offsetX; b[1] = offsetY;\n        b[2] = icon[1];\n        b[3] = icon[2];\n\n        b[4] = width + offsetX; b[5] = offsetY;\n        b[6] = icon[1]+icon[3];\n        b[7] = icon[2];\n\n        b[8] = width + offsetX; b[9] = height + offsetY;\n        b[10] = icon[1]+icon[3];\n        b[11] = icon[2]+icon[4];\n\n        b[12] = offsetX; b[13] = height + offsetY;\n        b[14] = icon[1];\n        b[15] = icon[2]+icon[4];\n\n        return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\n    }\n\n    var vertexBuffer = iconData.vertexBuffer;\n    var texcoordsBuffer = iconData.texcoordsBuffer;\n    var originBuffer = iconData.originBuffer;\n\n    //add polygon\n    vertexBuffer[index] = 0;\n    vertexBuffer[index+1] = 0;\n    vertexBuffer[index+2] = 0;\n    vertexBuffer[index+3] = 0;\n\n    vertexBuffer[index+4] = width;\n    vertexBuffer[index+5] = 0;\n    vertexBuffer[index+6] = 0;\n    vertexBuffer[index+7] = 0;\n\n    vertexBuffer[index+8] = width;\n    vertexBuffer[index+9] = -height;\n    vertexBuffer[index+10] = 0;\n    vertexBuffer[index+11] = 0;\n\n    texcoordsBuffer[index] = icon[1];\n    texcoordsBuffer[index+1] = icon[2];\n    texcoordsBuffer[index+2] = 0;\n    texcoordsBuffer[index+3] = 0;\n\n    texcoordsBuffer[index+4] = icon[1]+icon[3];\n    texcoordsBuffer[index+5] = icon[2];\n    texcoordsBuffer[index+6] = 0;\n    texcoordsBuffer[index+7] = 0;\n\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\n    texcoordsBuffer[index+10] = 0;\n    texcoordsBuffer[index+11] = 0;\n\n    index += 12;\n\n    //add polygon\n    vertexBuffer[index] = 0;\n    vertexBuffer[index+1] = 0;\n    vertexBuffer[index+2] = 0;\n    vertexBuffer[index+3] = 0;\n\n    vertexBuffer[index+4] = 0;\n    vertexBuffer[index+5] = -height;\n    vertexBuffer[index+6] = 0;\n    vertexBuffer[index+7] = 0;\n\n    vertexBuffer[index+8] = width;\n    vertexBuffer[index+9] = -height;\n    vertexBuffer[index+10] = 0;\n    vertexBuffer[index+11] = 0;\n\n    texcoordsBuffer[index] = icon[1];\n    texcoordsBuffer[index+1] = icon[2];\n    texcoordsBuffer[index+2] = 0;\n    texcoordsBuffer[index+3] = 0;\n\n    texcoordsBuffer[index+4] = icon[1];\n    texcoordsBuffer[index+5] = icon[2]+icon[4];\n    texcoordsBuffer[index+6] = 0;\n    texcoordsBuffer[index+7] = 0;\n\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\n    texcoordsBuffer[index+10] = 0;\n    texcoordsBuffer[index+11] = 0;\n    \n    index += 12;\n\n    var p1 = point[0];\n    var p2 = point[1];\n    var p3 = point[2];\n\n    //set origin buffer and apply offset\n    for (var i = lastIndex; i < index; i+=4) {\n        vertexBuffer[i] += offsetX;\n        vertexBuffer[i+1] -= offsetY;\n\n        originBuffer[index2] = p1;\n        originBuffer[index2 + 1] = p2;\n        originBuffer[index2 + 2] = p3;\n        index2 += 3;\n    }\n\n    iconData.index = index;\n    iconData.index2 = index2;\n\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\n};\n\n\nvar processLabel = function(point, labelData) {\n    var vertexBuffer = labelData.vertexBuffer;\n    var texcoordsBuffer = labelData.texcoordsBuffer;\n    var originBuffer = labelData.originBuffer;\n    var singleBuffer = labelData.singleBuffer;\n    var index = labelData.index;\n    var index2 = labelData.index2;\n    var lastIndex = index;\n    var text = '' + labelData.text;\n    var fonts = labelData.fonts;\n    var planes = {}, i, li;\n    var glyphsRes = labelData.glyphsRes;\n\n    var linesGlyphsRes = [];\n    var linesGlyphsRes2 = [];\n\n    //split text to lines\n    do {\n        var res = glyphsRes[2].indexOf(10); //search /n\n\n        if (res != -1) {\n            linesGlyphsRes.push([glyphsRes[0].slice(0,res), glyphsRes[1].slice(0,res), glyphsRes[2].slice(0,res)]);\n            glyphsRes = [glyphsRes[0].slice(res+1), glyphsRes[1].slice(res+1), glyphsRes[2].slice(res+1)];\n        } else {\n            linesGlyphsRes.push(glyphsRes);\n        }\n\n    } while (res != -1);\n\n    //split lines by width\n    for (var i = 0, li = linesGlyphsRes.length; i < li; i++) {\n\n        var glyphsRes = linesGlyphsRes[i];\n\n        // eslint-disable-next-line\n        do {\n            var splitIndex = getSplitIndex(null, labelData.width, labelData.size, labelData.spacing, fonts, glyphsRes);\n            var codes = glyphsRes[2];\n\n            if (codes.length == splitIndex) {\n                linesGlyphsRes2.push(glyphsRes);\n                break;\n            }\n\n            linesGlyphsRes2.push([glyphsRes[0].slice(0,splitIndex), glyphsRes[1].slice(0,splitIndex), glyphsRes[2].slice(0,splitIndex)]);\n\n            glyphsRes = [glyphsRes[0].slice(splitIndex+1), glyphsRes[1].slice(splitIndex+1), glyphsRes[2].slice(splitIndex+1)];\n\n        } while(true);\n\n    }\n\n    var x = 0, y = 0;\n    var lineHeight = getLineHeight(labelData.size, labelData.lineHeight, fonts);\n    var maxWidth = 0;\n    var lineWidths = [];\n\n    //get max width\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\n        lineWidths[i] = getTextLength(null, labelData.size, labelData.spacing, fonts, linesGlyphsRes2[i]);\n        maxWidth = Math.max(lineWidths[i], maxWidth);\n    }\n\n    //generate text\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\n        var textWidth = lineWidths[i];\n\n        switch(labelData.align) {\n        case 'left': x = 0; break;\n        case 'right': x = maxWidth - textWidth; break;\n        case 'center': x = (maxWidth - textWidth)*0.5; break;\n        }\n\n        index = addText([x,y,0], [1,0,0], null, labelData.size, labelData.spacing, fonts, vertexBuffer, texcoordsBuffer, true, index, planes, linesGlyphsRes2[i], singleBuffer);\n        y -= lineHeight;\n    }\n\n    //get offset\n    var originOffset = getOriginOffset(labelData.origin, maxWidth, -y);\n    var offsetX = originOffset[0] + labelData.offset[0];\n    var offsetY = originOffset[1] + labelData.offset[1];\n    \n    var p1 = point[0];\n    var p2 = point[1];\n    var p3 = point[2];\n\n    //set origin buffer and apply offset\n    if (!singleBuffer) {\n        for (i = lastIndex; i < index; i+=4) {\n            vertexBuffer[i] += offsetX;\n            vertexBuffer[i+1] -= offsetY;\n\n            originBuffer[index2] = p1;\n            originBuffer[index2 + 1] = p2;\n            originBuffer[index2 + 2] = p3;\n            index2 += 3;\n        }\n    } else {\n        for (i = lastIndex; i < index; i+=8) {\n            singleBuffer[i] += offsetX;\n            singleBuffer[i+1] -= offsetY;\n            singleBuffer[i+2] += offsetX;\n            singleBuffer[i+3] -= offsetY;\n        }\n\n        labelData.pos = [p1,p2,p3];\n        singleBuffer = new Float32Array(singleBuffer.buffer, 0, index);\n    }\n    \n    var fonts = labelData.fonts;\n    labelData.files = new Array(fonts.length);\n\n    for (i = 0, li= fonts.length; i < li; i++) {\n        labelData.files[i] = [];\n    }\n\n    for (var key in planes) {\n        var fontIndex = parseInt(key);\n        var planes2 = planes[key];\n\n        var files = [];\n\n        for (var key2 in planes2) {\n            var plane = parseInt(key2) - (fontIndex*4000);\n            var file = Math.round((plane - (plane % 4)) / 4);\n            \n            if (files.indexOf(file) == -1) {\n                files.push(file);\n            }\n        }\n\n        labelData.files[fontIndex] = files;\n    }\n\n    labelData.index = index;\n    labelData.index2 = index2;\n\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + maxWidth) * 0.5 + 1, (offsetY + Math.abs(y)) *0.5];\n};\n\nvar processPointArrayGeometry = function(pointArray) {\n    var i, li, dpoints = false;\n\n    if (pointArray['points'] || pointArray['d-points']) {\n        points = (pointArray['points'] || pointArray['d-points']);\n        dpoints = (pointArray['d-points']) ? true : false;\n\n        if (!(Array.isArray(points) && points.length > 0)) {\n            return;\n        }\n    }\n\n    var index = 0;\n    var forceScale = globals.forceScale;\n\n    var geometryBuffer = new Float64Array(points.length);\n\n    var p = points[0], pp;\n    var p1 = [p[0], p[1], p[2]], p2;\n\n    //add ponints\n    for (i = 0, li = points.length; i < li; i++) {\n\n        if (forceScale != null) {\n            pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n\n        geometryBuffer[index] = pp[0];\n        geometryBuffer[index+1] = pp[1];\n        geometryBuffer[index+2] = pp[2];\n        index += 3;\n\n        if (i >= (li - 1)) {\n            break;\n        }\n\n        if (dpoints) {\n            p2 = points[i+1];\n            p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\n        } else {\n            p1 = points[i+1];\n        }\n    }\n\n    globals.signatureCounter++;\n    postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_POINT_GEOMETRY, {\n        'id':pointArray['id'] }, [geometryBuffer, indicesBuffer], (\"\"+globals.signatureCounter));\n};\n\nexport {processPointArrayPass, processPointArrayGeometry, processPointArrayVSwitchPass};\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-pointarray.js\n// module id = 5\n// module chunks = 0","\nimport {globals as globals_} from './worker-globals.js';\nimport {getLayerPropertyValue as getLayerPropertyValue_} from './worker-style.js';\nimport {postGroupMessageFast as postGroupMessageFast_} from './worker-message.js';\nimport {processLineStringPass as processLineStringPass_} from './worker-linestring.js';\nimport {processPointArrayPass as processPointArrayPass_} from './worker-pointarray.js';\n\n//get rid of compiler mess\nvar globals = globals_;\nvar getLayerPropertyValue = getLayerPropertyValue_;\nvar postGroupMessageFast = postGroupMessageFast_;\nvar processLineStringPass = processLineStringPass_;\nvar processPointArrayPass = processPointArrayPass_;\n\nvar processPolygonPass = function(polygon, lod, style, featureIndex, zIndex, eventInfo) {\n    var vertices = polygon['vertices'] || [];\n    if (vertices.length == 0) {\n        return;\n    }\n    \n    // borders as points\n    if (getLayerPropertyValue(style, 'point', polygon, lod) ||\n        getLayerPropertyValue(style, 'label', polygon, lod)) {\n        processPolygonLines(polygon, vertices, lod, style, zIndex, eventInfo, false);\n    }\n    \n    // borders as lines\n    if (getLayerPropertyValue(style, 'line', polygon, lod) ||\n        getLayerPropertyValue(style, 'line-label', polygon, lod)) {\n        processPolygonLines(polygon, vertices, lod, style, zIndex, eventInfo, true);\n    }\n    \n    var spolygon = getLayerPropertyValue(style, 'polygon', polygon, lod);\n    \n    if (!spolygon) {\n        return;\n    }\n    \n    var surface = polygon['surface'] || [];\n    if (surface.length == 0) {\n        return;\n    }\n    \n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', polygon, lod);\n    var clickEvent = getLayerPropertyValue(style, 'click-event', polygon, lod);\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', polygon, lod);\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', polygon, lod);\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', polygon, lod);\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', polygon, lod);\n\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', polygon, lod);\n    \n    var polygonColor = getLayerPropertyValue(style, 'polygon-color', polygon, lod);\n    \n    var center = [0,0,0];\n   \n    // allocate vertex buffer\n    var trisCount = surface.length / 3;\n    var vertexCount = trisCount * 3;\n    var vertexBuffer = new Array (vertexCount * 3);\n    \n    var surfaceI = 0;\n    var index = 0;\n    var p1;\n    var offs;\n\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceOrigin = globals.forceOrigin;\n    var forceScale = globals.forceScale;    \n    \n    //console.log(\"vertexCount = \" + vertexCount);\n    //add tris\n    for (var i = 0; i < vertexCount; i++) {\n        offs = 3 * surface[surfaceI++];\n        p1 = [vertices[offs++], vertices[offs++], vertices[offs]];\n        \n        if (forceOrigin) {\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n        }\n\n        if (forceScale != null) {\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n        \n        center[0] += p1[0];\n        center[1] += p1[1];\n        center[2] += p1[2];\n\n        //add vertex\n        vertexBuffer[index++] = p1[0];\n        vertexBuffer[index++] = p1[1];\n        vertexBuffer[index++] = p1[2];\n    }\n    \n    //console.log( \"vertexBuffer: \" + vertexBuffer );\n    \n    if (vertexCount > 0) {\n        var k = 1.0 / vertexCount;\n        center[0] *= k;\n        center[1] *= k;\n        center[2] *= k;\n    }\n\n    center[0] += globals.groupOrigin[0];\n    center[1] += globals.groupOrigin[1];\n    center[2] += globals.groupOrigin[2];\n\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n    \n    postGroupMessageFast(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_FLAT_LINE, {\n        'color':polygonColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit,\n        'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\n        'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n        'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n        'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, texcoordsBuffer], signature);\n};\n\nvar createEmptyFeatureFromPolygon = function(polygon) {\n    var feature = {};\n    for(var key in polygon) {\n        if(key != 'surface' && key != 'vertices' && key != 'borders') {\n            feature[key] = polygon[key];\n        }\n    }\n    return feature;\n};\n\nvar processPolygonLines = function(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, processLines) {\n    var borders = polygon['borders'] || [];\n    if (borders.length == 0) {\n        return;\n    }\n    var feature = createEmptyFeatureFromPolygon(polygon);\n    var bordersCount = borders.length;\n    for (var j = 0; j < bordersCount; j++) {\n        var border = borders[j], offset;\n        var pointsCount = border.length;\n        var pointsCount2 = 0;\n        if (pointsCount > 0) {\n            var points, i;\n            if (processLines) {\n                points = new Array(pointsCount + 1);\n            } else {\n                points = new Array(pointsCount);\n            }\n            for (i = 0; i < pointsCount; i++) {\n                if (border[i] >= 0) {\n                    offset = 3 * border[i];\n                    pointsCount2++; // count vertices with positive index\n                } else {\n                    offset = 3 * (-border[i]);\n                }\n                points[i] = [vertices[offset], vertices[offset+1], vertices[offset+2]];\n                if (processLines && i == 0) {\n                    points[pointsCount] = points[0];\n                }\n            }\n\n            var points2 = new Array(pointsCount2);\n            var i2 = 0;\n            //debugger\n\n            //create array of points only for vertices with positive value\n            for (i = 0; i < pointsCount; i++) {\n                if (border[i] >= 0) {\n                    offset = 3 * border[i];\n                    points2[i2] = [vertices[offset], vertices[offset+1], vertices[offset+2]];\n                    i2++;\n                }\n            }\n\n            if(processLines) {\n                feature['lines'] = [points];\n                processLineStringPass(feature, lod, style, featureIndex, zIndex, eventInfo);\n            } else {\n                feature['points'] = points2;\n                processPointArrayPass(feature, lod, style, featureIndex, zIndex, eventInfo);\n            }\n        }\n    }\n};\n \nexport {processPolygonPass};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-polygon.js\n// module id = 6\n// module chunks = 0","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Character types for symbols from 0000 to 00FF.\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\nvar baseTypes = [\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'S', 'B', 'S',\n  'WS', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'B', 'B', 'B', 'S', 'WS', 'ON', 'ON', 'ET',\n  'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'ON', 'ES', 'CS', 'ES', 'CS', 'CS',\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'CS', 'ON',\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'CS', 'ON', 'ET',\n  'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'L', 'ON', 'ON', 'BN', 'ON',\n  'ON', 'ET', 'ET', 'EN', 'EN', 'ON', 'L', 'ON', 'ON', 'ON', 'EN', 'L',\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'\n];\n\n// Character types for symbols from 0600 to 06FF.\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n// Note that 061D does not exist in the Unicode standard (see\n// http://unicode.org/charts/PDF/U0600.pdf), so we replace it with an\n// empty string and issue a warning if we encounter this character. The\n// empty string is required to properly index the items after it.\nvar arabicTypes = [\n  'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ON', 'ON', 'AL', 'ET', 'ET', 'AL',\n  'CS', 'AL', 'ON', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', '', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN',\n  'AN', 'AN', 'AN', 'ET', 'AN', 'AN', 'AL', 'AL', 'AL', 'NSM', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN',\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'NSM', 'NSM',\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'EN', 'EN', 'EN', 'EN',\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL'\n];\n\nfunction isOdd(i) {\n  return (i & 1) !== 0;\n}\n\nfunction isEven(i) {\n  return (i & 1) === 0;\n}\n\nfunction findUnequal(arr, start, value) {\n  for (var j = start, jj = arr.length; j < jj; ++j) {\n    if (arr[j] !== value) {\n      return j;\n    }\n  }\n  return j;\n}\n\nfunction setValues(arr, start, end, value) {\n  for (var j = start; j < end; ++j) {\n    arr[j] = value;\n  }\n}\n\nfunction reverseValues(arr, arr2, start, end) {\n  for (var i = start, j = end - 1; i < j; ++i, --j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    temp = arr2[i];\n    arr2[i] = arr2[j];\n    arr2[j] = temp;\n  }\n}\n\nfunction createBidiText(str, isLTR, vertical) {\n  return {\n    str: str,\n    indices: indices,\n    types : types,\n    dir: (vertical ? 'ttb' : (isLTR ? 'ltr' : 'rtl')),\n  };\n}\n\n// These are used in bidi(), which is called frequently. We re-use them on\n// each call to avoid unnecessary allocations.\nvar chars = [];\nvar types = [];\nvar indices = [];\n\nfunction bidi(str, startLevel, vertical) {\n  var isLTR = true;\n  var strLength = str.length;\n  if (strLength === 0 || vertical) {\n    return createBidiText(str, isLTR, vertical);\n  }\n\n  // Get types and fill arrays\n  chars.length = strLength;\n  types.length = strLength;\n  var numBidi = 0;\n\n  var i, ii;\n  for (i = 0; i < strLength; ++i) {\n    chars[i] = str.charAt(i);\n    indices[i] = i;\n\n    var charCode = str.charCodeAt(i);\n    var charType = 'L';\n    if (charCode <= 0x00ff) {\n      charType = baseTypes[charCode];\n    } else if (0x0590 <= charCode && charCode <= 0x05f4) {\n      charType = 'R';\n    } else if (0x0600 <= charCode && charCode <= 0x06ff) {\n      charType = arabicTypes[charCode & 0xff];\n      if (!charType) {\n        //console.log('Bidi: invalid Unicode character ' + charCode.toString(16));\n      }\n    } else if (0x0700 <= charCode && charCode <= 0x08AC) {\n      charType = 'AL';\n    }\n    if (charType === 'R' || charType === 'AL' || charType === 'AN') {\n      numBidi++;\n    }\n    types[i] = charType;\n  }\n\n  // Detect the bidi method\n  // - If there are no rtl characters then no bidi needed\n  // - If less than 30% chars are rtl then string is primarily ltr\n  // - If more than 30% chars are rtl then string is primarily rtl\n  if (numBidi === 0) {\n    isLTR = true;\n    return createBidiText(str, isLTR);\n  }\n\n  if (startLevel === -1) {\n    if ((numBidi / strLength) < 0.3) {\n      isLTR = true;\n      startLevel = 0;\n    } else {\n      isLTR = false;\n      startLevel = 1;\n    }\n  }\n\n  var levels = [];\n  for (i = 0; i < strLength; ++i) {\n    levels[i] = startLevel;\n  }\n\n  /*\n   X1-X10: skip most of this, since we are NOT doing the embeddings.\n   */\n  var e = (isOdd(startLevel) ? 'R' : 'L');\n  var sor = e;\n  var eor = sor;\n\n  /*\n   W1. Examine each non-spacing mark (NSM) in the level run, and change the\n   type of the NSM to the type of the previous character. If the NSM is at the\n   start of the level run, it will get the type of sor.\n   */\n  var lastType = sor;\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'NSM') {\n      types[i] = lastType;\n    } else {\n      lastType = types[i];\n    }\n  }\n\n  /*\n   W2. Search backwards from each instance of a European number until the\n   first strong type (R, L, AL, or sor) is found.  If an AL is found, change\n   the type of the European number to Arabic number.\n   */\n  lastType = sor;\n  var t;\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'EN') {\n      types[i] = (lastType === 'AL') ? 'AN' : 'EN';\n    } else if (t === 'R' || t === 'L' || t === 'AL') {\n      lastType = t;\n    }\n  }\n\n  /*\n   W3. Change all ALs to R.\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'AL') {\n      types[i] = 'R';\n    }\n  }\n\n  /*\n   W4. A single European separator between two European numbers changes to a\n   European number. A single common separator between two numbers of the same\n   type changes to that type:\n   */\n  for (i = 1; i < strLength - 1; ++i) {\n    if (types[i] === 'ES' && types[i - 1] === 'EN' && types[i + 1] === 'EN') {\n      types[i] = 'EN';\n    }\n    if (types[i] === 'CS' &&\n        (types[i - 1] === 'EN' || types[i - 1] === 'AN') &&\n        types[i + 1] === types[i - 1]) {\n      types[i] = types[i - 1];\n    }\n  }\n\n  /*\n   W5. A sequence of European terminators adjacent to European numbers changes\n   to all European numbers:\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'EN') {\n      // do before\n      var j;\n      for (j = i - 1; j >= 0; --j) {\n        if (types[j] !== 'ET') {\n          break;\n        }\n        types[j] = 'EN';\n      }\n      // do after\n      for (j = i + 1; j < strLength; ++j) {\n        if (types[j] !== 'ET') {\n          break;\n        }\n        types[j] = 'EN';\n      }\n    }\n  }\n\n  /*\n   W6. Otherwise, separators and terminators change to Other Neutral:\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'WS' || t === 'ES' || t === 'ET' || t === 'CS') {\n      types[i] = 'ON';\n    }\n  }\n\n  /*\n   W7. Search backwards from each instance of a European number until the\n   first strong type (R, L, or sor) is found. If an L is found,  then change\n   the type of the European number to L.\n   */\n  lastType = sor;\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'EN') {\n      types[i] = ((lastType === 'L') ? 'L' : 'EN');\n    } else if (t === 'R' || t === 'L') {\n      lastType = t;\n    }\n  }\n\n  /*\n   N1. A sequence of neutrals takes the direction of the surrounding strong\n   text if the text on both sides has the same direction. European and Arabic\n   numbers are treated as though they were R. Start-of-level-run (sor) and\n   end-of-level-run (eor) are used at level run boundaries.\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'ON') {\n      var end = findUnequal(types, i + 1, 'ON');\n      var before = sor;\n      if (i > 0) {\n        before = types[i - 1];\n      }\n\n      var after = eor;\n      if (end + 1 < strLength) {\n        after = types[end + 1];\n      }\n      if (before !== 'L') {\n        before = 'R';\n      }\n      if (after !== 'L') {\n        after = 'R';\n      }\n      if (before === after) {\n        setValues(types, i, end, before);\n      }\n      i = end - 1; // reset to end (-1 so next iteration is ok)\n    }\n  }\n\n  /*\n   N2. Any remaining neutrals take the embedding direction.\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'ON') {\n      types[i] = e;\n    }\n  }\n\n  /*\n   I1. For all characters with an even (left-to-right) embedding direction,\n   those of type R go up one level and those of type AN or EN go up two\n   levels.\n   I2. For all characters with an odd (right-to-left) embedding direction,\n   those of type L, EN or AN go up one level.\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (isEven(levels[i])) {\n      if (t === 'R') {\n        levels[i] += 1;\n      } else if (t === 'AN' || t === 'EN') {\n        levels[i] += 2;\n      }\n    } else { // isOdd\n      if (t === 'L' || t === 'AN' || t === 'EN') {\n        levels[i] += 1;\n      }\n    }\n  }\n\n  /*\n   L1. On each line, reset the embedding level of the following characters to\n   the paragraph embedding level:\n\n   segment separators,\n   paragraph separators,\n   any sequence of whitespace characters preceding a segment separator or\n   paragraph separator, and any sequence of white space characters at the end\n   of the line.\n   */\n\n  // don't bother as text is only single line\n\n  /*\n   L2. From the highest level found in the text to the lowest odd level on\n   each line, reverse any contiguous sequence of characters that are at that\n   level or higher.\n   */\n\n  // find highest level & lowest odd level\n  var highestLevel = -1;\n  var lowestOddLevel = 99;\n  var level;\n  for (i = 0, ii = levels.length; i < ii; ++i) {\n    level = levels[i];\n    if (highestLevel < level) {\n      highestLevel = level;\n    }\n    if (lowestOddLevel > level && isOdd(level)) {\n      lowestOddLevel = level;\n    }\n  }\n\n  // now reverse between those limits\n  for (level = highestLevel; level >= lowestOddLevel; --level) {\n    // find segments to reverse\n    var start = -1;\n    for (i = 0, ii = levels.length; i < ii; ++i) {\n      if (levels[i] < level) {\n        if (start >= 0) {\n          reverseValues(chars, indices, start, i);\n          start = -1;\n        }\n      } else if (start < 0) {\n        start = i;\n      }\n    }\n    if (start >= 0) {\n      reverseValues(chars, indices, start, levels.length);\n    }\n  }\n\n  /*\n   L3. Combining marks applied to a right-to-left base character will at this\n   point precede their base character. If the rendering engine expects them to\n   follow the base characters in the final display process, then the ordering\n   of the marks and the base character must be reversed.\n   */\n\n  // don't bother for now\n\n  /*\n   L4. A character that possesses the mirrored property as specified by\n   Section 4.7, Mirrored, must be depicted by a mirrored glyph if the resolved\n   directionality of that character is R.\n   */\n\n  // don't mirror as characters are already mirrored in the pdf\n\n  // Finally, return string\n  for (i = 0, ii = chars.length; i < ii; ++i) {\n    var ch = chars[i];\n    if (ch === '<' || ch === '>') {\n      chars[i] = '';\n    }\n  }\n  return createBidiText(chars.join(''), isLTR);\n}\n\nexport {\n  bidi\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-bidi.js\n// module id = 7\n// module chunks = 0","\nimport {bidi as bidi_} from './worker-bidi.js';\n\n\n//get rid of compiler mess\nvar bidi = bidi_;\n\n\nvar Typr = {};\n\nTypr.parse = function(buff) {\n    var bin = Typr._bin;\n    var data = new Uint8Array(buff);\n    var offset = 0;\n    \n    var sfnt_version = bin.readFixed(data, offset);\n    offset += 4;\n    var numTables = bin.readUshort(data, offset);\n    offset += 2;\n    var searchRange = bin.readUshort(data, offset);\n    offset += 2;\n    var entrySelector = bin.readUshort(data, offset);\n    offset += 2;\n    var rangeShift = bin.readUshort(data, offset);\n    offset += 2;\n    \n    var tags = [\n        \"cmap\",\n        \"head\",\n        \"hhea\",\n        \"maxp\",\n        \"hmtx\",\n        //\"name\",\n        //\"OS/2\",\n        //\"post\",\n        \n        //\"cvt\",\n        //\"fpgm\",\n        //\"loca\",\n        //\"glyf\",\n        \"kern\",\n        \n        //\"prep\"\n        //\"gasp\"\n        \n        \"GPOS\",\n        \"GSUB\"\n        //\"VORG\",\n        ];\n    \n    var obj = {_data:data};\n    //console.log(sfnt_version, numTables, searchRange, entrySelector, rangeShift);\n    \n    var tabs = {};\n    var tablesOffset = 0;\n    \n    for(var i=0; i<numTables; i++) {\n        var tag = bin.readASCII(data, offset, 4);   offset += 4;\n        var checkSum = bin.readUint(data, offset);  offset += 4;\n        var toffset = bin.readUint(data, offset);   offset += 4;\n        var length = bin.readUint(data, offset);    offset += 4;\n        tabs[tag] = {offset:toffset, length:length};\n        tablesOffset = toffset + length;\n        //if(tags.indexOf(tag)==-1) console.log(\"unknown tag\", tag);\n    }\n    \n    for(var i=0; i< tags.length; i++) {\n        var t = tags[i];\n        //console.log(t);\n        //if(tabs[t]) console.log(t, tabs[t].offset, tabs[t].length);\n        if(tabs[t]) obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj);\n    }\n\n    obj._tabs = tabs;\n\n    Typr._processGlyphs(data, tablesOffset, tabs, obj);\n\n    //get tables\n    var gsub = obj['GSUB'];\n    if (gsub) {\n        var llist = gsub.lookupList, flist = gsub.featureList;\n\n        obj.gsubIsolTable = [];\n        obj.gsubInitTable = [];\n        obj.gsubFinaTable = [];\n        obj.gsubMediTable = [];\n\n        obj.gsubRligLigaTable = [];\n\n        for(var fi = 0; fi < flist.length; fi++) {\n            var tag = flist[fi].tag;\n\n            switch (tag) {\n                case 'isol':\n                case 'init':\n                case 'fina':\n                case 'medi':\n\n                    for(var ti = 0; ti < flist[fi].tab.length; ti++) {\n                        var tab = llist[flist[fi].tab[ti]];\n                        \n                        if(tab.ltype == 1) {\n                            switch (tag) {\n                                case 'isol': obj.gsubIsolTable.push(tab.tabs); break;\n                                case 'init': obj.gsubInitTable.push(tab.tabs); break;\n                                case 'fina': obj.gsubFinaTable.push(tab.tabs); break;\n                                case 'medi': obj.gsubMediTable.push(tab.tabs); break;\n                            }\n                        }\n                    }\n\n                    break;\n\n                case 'rlig':\n                case 'liga':\n\n                    for(var ti = 0; ti < flist[fi].tab.length; ti++) {\n                        var tab = llist[flist[fi].tab[ti]];\n                        \n                        if(tab.ltype == 4) {\n                            obj.gsubRligLigaTable.push(tab.tabs);\n                        }\n                    }\n\n                    break;\n            }\n\n        }\n    }\n   \n    return obj;\n}\n\nTypr._processGlyphs = function(data, index, tabs, obj) {\n    var version = data[index]; index += 1;\n    var textureLX = (data[index] << 8) | (data[index+1]); index += 2;\n    var textureLY = (data[index] << 8) | (data[index+1]); index += 2;\n    var size = data[index]; index += 1;\n    var flags = data[index]; index += 1;\n\n    obj.version = version;\n    obj.textureLX = textureLX;\n    obj.textureLY = textureLY;\n    obj.size = size;\n    obj.cly = size * 1.5;\n    obj.flags = flags;\n\n    var glyphs = new Array(obj.maxp.numGlyphs);\n    var fx = 1.0 / textureLX, fy = 1.0 / textureLY;\n    var step = (textureLX > 256) ? 7 : 6;\n\n    var filesIndicesIndex = index + obj.maxp.numGlyphs * step;\n    var filesIndicesCount = (data[filesIndicesIndex] << 8) | data[filesIndicesIndex+1];\n    var files = new Array(filesIndicesCount);\n\n    filesIndicesIndex += 2;\n\n    for (var i = 0, li = filesIndicesCount; i < li; i++) {\n        files[i] = (data[filesIndicesIndex+i*2] << 8) | data[filesIndicesIndex+i*2+1];\n    }\n\n    var fileIndex = 0;\n\n    for (i = 0, li = obj.maxp.numGlyphs; i < li; i++) {\n        if (i == files[fileIndex]) {\n            fileIndex++;\n        }\n\n        glyphs[i] = Typr._processGlyph(data, index, fx, fy, textureLX, obj, i, fileIndex);\n        index += step;\n    }\n\n    obj.glyphs = glyphs;\n}\n\nTypr._processGlyph = function(data, index, fx, fy, textureLX, font, glyphIndex, fileIndex) {\n    var value = (data[index] << 24) | (data[index+1] << 16) | (data[index+2] << 8) | (data[index+3]);\n\n    // w 6bit | h 6bit | sx sign 1bit | abs sx 6bit | sy sign 1bit | abs sy 6bit | plane 2bit \n    var w = (value >> 22) & 63;\n    var h = (value >> 16) & 63;\n    var sx = ((value >> 9) & 63) * (((value >> 15) & 1) ? -1 : 1);\n    var sy = -((value >> 2) & 63) * (((value >> 8) & 1) ? -1 : 1);\n    var plane = (value & 3) + (fileIndex * 4);\n\n    if (textureLX > 256) {\n        value = (data[index+4] << 16) | (data[index+5] << 8) | (data[index+6]);\n    } else {\n        value = (data[index+4] << 8) | (data[index+5]);\n    }    \n\n    var scale = ((font.size/0.75) / font.head.unitsPerEm) * 0.75;\n    var x, y, step = font.hmtx.aWidth[glyphIndex] * scale;\n\n    //store glyph position\n    switch (textureLX) {\n        case 2048: // x 11bit | y 11bit\n            x = ((value >> 11) & 2047), y = (value & 2047); break;\n                   \n        case 1024: // x 10bit | y 10bit\n            x = ((value >> 10) & 1023), y = (value & 1023); break;\n\n        case 512:  // x 9bit | y 9bit\n            x = ((value >> 9) & 511), y = (value & 511); break;\n\n        default:   // x 8bit | y 8bit\n            x = ((value >> 8) & 255), y = (value & 255); break;\n    }\n\n    return {\n        u1 : (x) * fx,\n        v1 : (y * fy) + plane,\n        u2 : (x + w) * fx,\n        v2 : ((y + h) * fy) + plane,\n        lx : w,\n        ly : h,\n        sx : sx, \n        sy : sy, \n        step : (step), \n        plane: plane\n    };\n}\n\nTypr._tabOffset = function(data, tab) {\n    var bin = Typr._bin;\n    var numTables = bin.readUshort(data, 4);\n    var offset = 12;\n    for(var i=0; i<numTables; i++) {\n        var tag = bin.readASCII(data, offset, 4);   offset += 4;\n        var checkSum = bin.readUint(data, offset);  offset += 4;\n        var toffset = bin.readUint(data, offset);   offset += 4;\n        var length = bin.readUint(data, offset);    offset += 4;\n        if(tag==tab) return toffset;\n    }\n    return 0;\n}\n\n\n\n\nTypr._bin = {\n    readFixed : function(data, o) {\n        return ((data[o]<<8) | data[o+1]) +  (((data[o+2]<<8)|data[o+3])/(256*256+4));\n    },\n\n    readF2dot14 : function(data, o) {\n        var num = Typr._bin.readShort(data, o);\n        return num / 16384;\n        \n        var intg = (num >> 14), frac = ((num & 0x3fff)/(0x3fff+1));\n        return (intg>0) ? (intg+frac) : (intg-frac);\n    },\n\n    readInt : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        var a = Typr._bin.t.uint8;\n        a[0] = buff[p+3];\n        a[1] = buff[p+2];\n        a[2] = buff[p+1];\n        a[3] = buff[p];\n        return Typr._bin.t.int32[0];\n    },\n    \n    readInt8 : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        var a = Typr._bin.t.uint8;\n        a[0] = buff[p];\n        return Typr._bin.t.int8[0];\n    },\n\n    readShort : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        var a = Typr._bin.t.uint8;\n        a[1] = buff[p]; a[0] = buff[p+1];\n        return Typr._bin.t.int16[0];\n    },\n\n    readUshort : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        return (buff[p]<<8) | buff[p+1];\n    },\n\n    readUshorts : function(buff, p, len) {\n        var arr = [];\n        for(var i=0; i<len; i++) arr.push(Typr._bin.readUshort(buff, p+i*2));\n        return arr;\n    },\n\n    readUint : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        var a = Typr._bin.t.uint8;\n        a[3] = buff[p];  a[2] = buff[p+1];  a[1] = buff[p+2];  a[0] = buff[p+3];\n        return Typr._bin.t.uint32[0];\n    },\n\n    readUint64 : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        return (Typr._bin.readUint(buff, p)*(0xffffffff+1)) + Typr._bin.readUint(buff, p+4);\n    },\n\n    readASCII : function(buff, p, l) {   // l : length in Characters (not Bytes)\n        //if(p>=buff.length) throw \"error\";\n        var s = \"\";\n        for(var i = 0; i < l; i++) s += String.fromCharCode(buff[p+i]);\n        return s;\n    },\n\n    readUnicode : function(buff, p, l) {\n        //if(p>=buff.length) throw \"error\";\n        var s = \"\";\n        for(var i = 0; i < l; i++)  \n        {\n            var c = (buff[p++]<<8) | buff[p++];\n            s += String.fromCharCode(c);\n        }\n        return s;\n    },\n\n    readBytes : function(buff, p, l) {\n        //if(p>=buff.length) throw \"error\";\n        var arr = [];\n        for(var i=0; i<l; i++) arr.push(buff[p+i]);\n        return arr;\n    },\n\n    readASCIIArray : function(buff, p, l) {  // l : length in Characters (not Bytes)\n        //if(p>=buff.length) throw \"error\";\n        var s = [];\n        for(var i = 0; i < l; i++)  \n            s.push(String.fromCharCode(buff[p+i]));\n        return s;\n    }\n};\n\nTypr._bin.t = {\n    buff: new ArrayBuffer(8),\n};\nTypr._bin.t.int8   = new Int8Array  (Typr._bin.t.buff);\nTypr._bin.t.uint8  = new Uint8Array (Typr._bin.t.buff);\nTypr._bin.t.int16  = new Int16Array (Typr._bin.t.buff);\nTypr._bin.t.uint16 = new Uint16Array(Typr._bin.t.buff);\nTypr._bin.t.int32  = new Int32Array (Typr._bin.t.buff);\nTypr._bin.t.uint32 = new Uint32Array(Typr._bin.t.buff);\n\n\n\n\n\n// OpenType Layout Common Table Formats\n\nTypr._lctf = {};\n\nTypr._lctf.parse = function(data, offset, length, font, subt) {\n    var bin = Typr._bin;\n    var obj = {};\n    var offset0 = offset;\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\n    \n    var offScriptList  = bin.readUshort(data, offset);  offset += 2;\n    var offFeatureList = bin.readUshort(data, offset);  offset += 2;\n    var offLookupList  = bin.readUshort(data, offset);  offset += 2;\n    \n    \n    obj.scriptList  = Typr._lctf.readScriptList (data, offset0 + offScriptList);\n    obj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);\n    obj.lookupList  = Typr._lctf.readLookupList (data, offset0 + offLookupList, subt);\n    \n    return obj;\n}\n\nTypr._lctf.readLookupList = function(data, offset, subt) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = [];\n    var count = bin.readUshort(data, offset);  offset+=2;\n\n    for(var i=0; i<count; i++) \n    {\n        var noff = bin.readUshort(data, offset);  offset+=2;\n        var lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);\n        obj.push(lut);\n    }\n    return obj;\n}\n\nTypr._lctf.readLookupTable = function(data, offset, subt) {\n    //console.log(\"Parsing lookup table\", offset);\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {tabs:[]};\n    \n    obj.ltype = bin.readUshort(data, offset);  offset+=2;\n    obj.flag  = bin.readUshort(data, offset);  offset+=2;\n    var cnt   = bin.readUshort(data, offset);  offset+=2;\n    \n    for(var i=0; i<cnt; i++) {\n        var noff = bin.readUshort(data, offset);  offset+=2;\n        var tab = subt(data, obj.ltype, offset0 + noff);\n        //console.log(obj.type, tab);\n        obj.tabs.push(tab);\n    }\n    return obj;\n}\n\nTypr._lctf.numOfOnes = function(n) {\n    var num = 0;\n    for(var i=0; i<32; i++) if(((n>>>i)&1) != 0) num++;\n    return num;\n}\n\nTypr._lctf.readClassDef = function(data, offset) {\n    var bin = Typr._bin;\n    var obj = { start:[], end:[], class:[] };\n    var format = bin.readUshort(data, offset);  offset+=2;\n\n    if(format==1) {\n        var startGlyph  = bin.readUshort(data, offset);  offset+=2;\n        var glyphCount  = bin.readUshort(data, offset);  offset+=2;\n        for(var i=0; i<glyphCount; i++) {\n            obj.start.push(startGlyph+i);\n            obj.end  .push(startGlyph+i);\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\n        }\n    }\n\n    if(format==2) {\n        var count = bin.readUshort(data, offset);  offset+=2;\n        for(var i=0; i<count; i++) {\n            obj.start.push(bin.readUshort(data, offset));  offset+=2;\n            obj.end  .push(bin.readUshort(data, offset));  offset+=2;\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\n        }\n    }\n    return obj;\n}\n\nTypr._lctf.readValueRecord = function(data, offset, valFmt) {\n    var bin = Typr._bin;\n    var arr = [];\n    arr.push( (valFmt&1) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&1) ? 2 : 0;\n    arr.push( (valFmt&2) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&2) ? 2 : 0;\n    arr.push( (valFmt&4) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&4) ? 2 : 0;\n    arr.push( (valFmt&8) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&8) ? 2 : 0;\n    return arr;\n}\n\nTypr._lctf.readCoverage = function(data, offset) {\n    var bin = Typr._bin;\n    var cvg = {};\n    cvg.fmt   = bin.readUshort(data, offset);  offset+=2;\n    var count = bin.readUshort(data, offset);  offset+=2;\n    //console.log(\"parsing coverage\", offset-4, format, count);\n    if(cvg.fmt==1) cvg.tab = bin.readUshorts(data, offset, count); \n    if(cvg.fmt==2) cvg.tab = bin.readUshorts(data, offset, count*3);\n\n    //get min,max\n\n    var min = Number.POSITIVE_INFINITY, max = 0;\n    var tab = cvg.tab;\n\n    if(cvg.fmt==1) {\n\n        for(var i=0; i<tab.length; i++) {\n            var v = tab[i];\n            if (v > max) max = v;\n            if (v < min) min = v;\n        }\n    }\n\n    if(cvg.fmt==2) {\n        for(var i=0; i<tab.length; i+=3) {\n            var start = tab[i], end = tab[i+1];\n            if (start > max) max = start;\n            if (start < min) min = start;\n            if (end > max) max = end;\n            if (end < min) min = end;\n        }\n    }\n\n    cvg.min = min;\n    cvg.max = max;\n\n    return cvg;\n}\n\nTypr._lctf.coverageIndex = function(cvg, val) {\n    if (val < cvg.min || val > cvg.max) {\n        return -1;\n    }\n\n    var tab = cvg.tab;\n    if(cvg.fmt==1) return tab.indexOf(val);\n    \n    for(var i=0; i<tab.length; i+=3) {\n        var start = tab[i], end = tab[i+1], index = tab[i+2];\n        if(start<=val && val<=end) return index + (val-start);\n    }\n    return -1;\n}\n\nTypr._lctf.readFeatureList = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = [];\n    \n    var count = bin.readUshort(data, offset);  offset+=2;\n    \n    for(var i=0; i<count; i++) {\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\n        var noff = bin.readUshort(data, offset);  offset+=2;\n        obj.push({tag: tag.trim(), tab:Typr._lctf.readFeatureTable(data, offset0 + noff)});\n    }\n    return obj;\n}\n\nTypr._lctf.readFeatureTable = function(data, offset) {\n    var bin = Typr._bin;\n    \n    var featureParams = bin.readUshort(data, offset);  offset+=2;   // = 0\n    var lookupCount = bin.readUshort(data, offset);  offset+=2;\n    \n    var indices = [];\n    for(var i=0; i<lookupCount; i++) indices.push(bin.readUshort(data, offset+2*i));\n    return indices;\n}\n\n\nTypr._lctf.readScriptList = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    var count = bin.readUshort(data, offset);  offset+=2;\n    \n    for(var i=0; i<count; i++) {\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\n        var noff = bin.readUshort(data, offset);  offset+=2;\n        obj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);\n    }\n    return obj;\n}\n\nTypr._lctf.readScriptTable = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    var defLangSysOff = bin.readUshort(data, offset);  offset+=2;\n    obj.default = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);\n    \n    var langSysCount = bin.readUshort(data, offset);  offset+=2;\n    \n    for(var i=0; i<langSysCount; i++) {\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\n        var langSysOff = bin.readUshort(data, offset);  offset+=2;\n        obj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);\n    }\n    return obj;\n}\n\nTypr._lctf.readLangSysTable = function(data, offset) {\n    var bin = Typr._bin;\n    var obj = {};\n    \n    var lookupOrder = bin.readUshort(data, offset);  offset+=2;\n    //if(lookupOrder!=0)  throw \"lookupOrder not 0\";\n    obj.reqFeature = bin.readUshort(data, offset);  offset+=2;\n    //if(obj.reqFeature != 0xffff) throw \"reqFeatureIndex != 0xffff\";\n    \n    //console.log(lookupOrder, obj.reqFeature);\n    \n    var featureCount = bin.readUshort(data, offset);  offset+=2;\n    obj.features = bin.readUshorts(data, offset, featureCount);\n    return obj;\n}\n\n\nTypr.cmap = {};\nTypr.cmap.parse = function(data, offset, length) {\n    data = new Uint8Array(data.buffer, offset, length);\n    offset = 0;\n\n    var offset0 = offset;\n    var bin = Typr._bin;\n    var obj = {};\n    var version   = bin.readUshort(data, offset);  offset += 2;\n    var numTables = bin.readUshort(data, offset);  offset += 2;\n    \n    //console.log(version, numTables);\n    \n    var offs = [];\n    obj.tables = [];\n    \n    \n    for(var i=0; i<numTables; i++) {\n        var platformID = bin.readUshort(data, offset);  offset += 2;\n        var encodingID = bin.readUshort(data, offset);  offset += 2;\n        var noffset = bin.readUint(data, offset);       offset += 4;\n        \n        var id = \"p\"+platformID+\"e\"+encodingID;\n        \n        //console.log(\"cmap subtable\", platformID, encodingID, noffset);\n                \n        var tind = offs.indexOf(noffset);\n        \n        if(tind==-1) {\n            tind = obj.tables.length;\n            var subt;\n            offs.push(noffset);\n            var format = bin.readUshort(data, noffset);\n            if     (format== 0) subt = Typr.cmap.parse0(data, noffset);\n            else if(format== 4) subt = Typr.cmap.parse4(data, noffset);\n            else if(format== 6) subt = Typr.cmap.parse6(data, noffset);\n            else if(format==12) subt = Typr.cmap.parse12(data,noffset);\n            else console.log(\"unknown format: \"+format, platformID, encodingID, noffset);\n            obj.tables.push(subt);\n        }\n        \n        if(obj[id]!=null) throw \"multiple tables for one platform+encoding\";\n        obj[id] = tind;\n    }\n    return obj;\n}\n\nTypr.cmap.parse0 = function(data, offset) {\n    var bin = Typr._bin;\n    var obj = {};\n    obj.format = bin.readUshort(data, offset);  offset += 2;\n    var len    = bin.readUshort(data, offset);  offset += 2;\n    var lang   = bin.readUshort(data, offset);  offset += 2;\n    obj.map = [];\n    for(var i=0; i<len-6; i++) obj.map.push(data[offset+i]);\n    return obj;\n}\n\nTypr.cmap.parse4 = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    var length = bin.readUshort(data, offset);  offset+=2;\n    var language = bin.readUshort(data, offset);  offset+=2;\n    var segCountX2 = bin.readUshort(data, offset);  offset+=2;\n    var segCount = segCountX2/2;\n    obj.searchRange = bin.readUshort(data, offset);  offset+=2;\n    obj.entrySelector = bin.readUshort(data, offset);  offset+=2;\n    obj.rangeShift = bin.readUshort(data, offset);  offset+=2;\n    obj.endCount   = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    offset+=2;\n    obj.startCount = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    obj.idDelta = [];\n    for(var i=0; i<segCount; i++) {obj.idDelta.push(bin.readShort(data, offset));  offset+=2;}\n    obj.idRangeOffset = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    obj.glyphIdArray = [];\n    while(offset< offset0+length) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n    return obj;\n}\n\nTypr.cmap.parse6 = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    var length = bin.readUshort(data, offset);  offset+=2;\n    var language = bin.readUshort(data, offset);  offset+=2;\n    obj.firstCode = bin.readUshort(data, offset);  offset+=2;\n    var entryCount = bin.readUshort(data, offset);  offset+=2;\n    obj.glyphIdArray = [];\n    for(var i=0; i<entryCount; i++) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n    \n    return obj;\n}\n\nTypr.cmap.parse12 = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    offset += 2;\n    var length = bin.readUint(data, offset);  offset+=4;\n    var lang   = bin.readUint(data, offset);  offset+=4;\n    var nGroups= bin.readUint(data, offset);  offset+=4;\n    obj.groups = [];\n    \n    for(var i=0; i<nGroups; i++) {\n        var off = offset + i * 12;\n        var startCharCode = bin.readUint(data, off+0);\n        var endCharCode   = bin.readUint(data, off+4);\n        var startGlyphID  = bin.readUint(data, off+8);\n        obj.groups.push([  startCharCode, endCharCode, startGlyphID  ]);\n    }\n    return obj;\n}\n\n\n\nTypr.GPOS = {};\nTypr.GPOS.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);  }\n\n\n\nTypr.GPOS.subt = function(data, ltype, offset) { // lookup type\n    if(ltype!=2) return null;\n    \n    var bin = Typr._bin, offset0 = offset, tab = {};\n    \n    tab.format  = bin.readUshort(data, offset);  offset+=2;\n    var covOff  = bin.readUshort(data, offset);  offset+=2;\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);\n    tab.valFmt1 = bin.readUshort(data, offset);  offset+=2;\n    tab.valFmt2 = bin.readUshort(data, offset);  offset+=2;\n    var ones1 = Typr._lctf.numOfOnes(tab.valFmt1);\n    var ones2 = Typr._lctf.numOfOnes(tab.valFmt2);\n\n    if(tab.format==1) {\n        tab.pairsets = [];\n        var count = bin.readUshort(data, offset);  offset+=2;\n        \n        for(var i=0; i<count; i++) {\n            var psoff = bin.readUshort(data, offset);  offset+=2;\n            psoff += offset0;\n            var pvcount = bin.readUshort(data, psoff);  psoff+=2;\n            var arr = [];\n\n            for(var j=0; j<pvcount; j++) {\n                var gid2 = bin.readUshort(data, psoff);  psoff+=2;\n                var value1, value2;\n                if(tab.valFmt1!=0) {  value1 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt1);  psoff+=ones1*2;  }\n                if(tab.valFmt2!=0) {  value2 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt2);  psoff+=ones2*2;  }\n                arr.push({gid2:gid2, val1:value1, val2:value2});\n            }\n            tab.pairsets.push(arr);\n        }\n    }\n\n    if(tab.format==2) {\n        var classDef1 = bin.readUshort(data, offset);  offset+=2;\n        var classDef2 = bin.readUshort(data, offset);  offset+=2;\n        var class1Count = bin.readUshort(data, offset);  offset+=2;\n        var class2Count = bin.readUshort(data, offset);  offset+=2;\n        \n        tab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);\n        tab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);\n        \n        tab.matrix = [];\n        for(var i=0; i<class1Count; i++) {\n            var row = [];\n            for(var j=0; j<class2Count; j++) {\n                var value1 = null, value2 = null;\n                if(tab.valFmt1!=0) { value1 = Typr._lctf.readValueRecord(data, offset, tab.valFmt1);  offset+=ones1*2; }\n                if(tab.valFmt2!=0) { value2 = Typr._lctf.readValueRecord(data, offset, tab.valFmt2);  offset+=ones2*2; }\n                row.push({val1:value1, val2:value2});\n            }\n            tab.matrix.push(row);\n        }\n    }\n    return tab;\n}\n\nTypr.GSUB = {};\nTypr.GSUB.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);  }\n\n\nTypr.GSUB.subt = function(data, ltype, offset) { // lookup type\n    var bin = Typr._bin, offset0 = offset, tab = {};\n    \n    if(ltype!=1 && ltype!=4) return null;\n    \n    tab.fmt  = bin.readUshort(data, offset);  offset+=2;\n    var covOff  = bin.readUshort(data, offset);  offset+=2;\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);   // not always is coverage here\n    \n    if(false) {}\n    else if(ltype==1) {\n        if(tab.fmt==1) {\n            tab.delta = bin.readShort(data, offset);  offset+=2;\n        }\n        else if(tab.fmt==2) {\n            var cnt = bin.readUshort(data, offset);  offset+=2;\n            tab.newg = bin.readUshorts(data, offset, cnt);  offset+=tab.newg.length*2;\n        }\n    }\n    else if(ltype==4) {\n        tab.vals = [];\n        var cnt = bin.readUshort(data, offset);  offset+=2;\n        for(var i=0; i<cnt; i++) {\n            var loff = bin.readUshort(data, offset);  offset+=2;\n            tab.vals.push(Typr.GSUB.readLigatureSet(data, offset0+loff));\n        }\n        //console.log(tab.coverage);\n        //console.log(tab.vals);\n    } \n    \n    return tab;\n}\n\nTypr.GSUB.readChainSubClassSet = function(data, offset) {\n    var bin = Typr._bin, offset0 = offset, lset = [];\n    var cnt = bin.readUshort(data, offset);  offset+=2;\n    for(var i=0; i<cnt; i++) {\n        var loff = bin.readUshort(data, offset);  offset+=2;\n        lset.push(Typr.GSUB.readChainSubClassRule(data, offset0+loff));\n    }\n    return lset;\n}\n\nTypr.GSUB.readChainSubClassRule= function(data, offset) {\n    var bin = Typr._bin, offset0 = offset, rule = {};\n    var pps = [\"backtrack\", \"input\", \"lookahead\"];\n    for(var pi=0; pi<pps.length; pi++) {\n        var cnt = bin.readUshort(data, offset);  offset+=2;  if(pi==1) cnt--;\n        rule[pps[pi]]=bin.readUshorts(data, offset, cnt);  offset+= rule[pps[pi]].length*2;\n    }\n    var cnt = bin.readUshort(data, offset);  offset+=2;\n    rule.subst = bin.readUshorts(data, offset, cnt*2);  offset += rule.subst.length*2;\n    return rule;\n}\n\nTypr.GSUB.readLigatureSet = function(data, offset) {\n    var bin = Typr._bin, offset0 = offset, lset = [];\n    var lcnt = bin.readUshort(data, offset);  offset+=2;\n    for(var j=0; j<lcnt; j++) {\n        var loff = bin.readUshort(data, offset);  offset+=2;\n        lset.push(Typr.GSUB.readLigature(data, offset0+loff));\n    }\n    return lset;\n}\n\nTypr.GSUB.readLigature = function(data, offset) {\n    var bin = Typr._bin, lig = {chain:[]};\n    lig.nglyph = bin.readUshort(data, offset);  offset+=2;\n    var ccnt = bin.readUshort(data, offset);  offset+=2;\n    for(var k=0; k<ccnt-1; k++) {  lig.chain.push(bin.readUshort(data, offset));  offset+=2;  }\n    return lig;\n}\n\n\n\nTypr.head = {};\nTypr.head.parse = function(data, offset, length) {\n    var bin = Typr._bin;\n    var obj = {};\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\n    obj.fontRevision = bin.readFixed(data, offset);  offset += 4;\n    var checkSumAdjustment = bin.readUint(data, offset);  offset += 4;\n    var magicNumber = bin.readUint(data, offset);  offset += 4;\n    obj.flags = bin.readUshort(data, offset);  offset += 2;\n    obj.unitsPerEm = bin.readUshort(data, offset);  offset += 2;\n    obj.created  = bin.readUint64(data, offset);  offset += 8;\n    obj.modified = bin.readUint64(data, offset);  offset += 8;\n    obj.xMin = bin.readShort(data, offset);  offset += 2;\n    obj.yMin = bin.readShort(data, offset);  offset += 2;\n    obj.xMax = bin.readShort(data, offset);  offset += 2;\n    obj.yMax = bin.readShort(data, offset);  offset += 2;\n    obj.macStyle = bin.readUshort(data, offset);  offset += 2;\n    obj.lowestRecPPEM = bin.readUshort(data, offset);  offset += 2;\n    obj.fontDirectionHint = bin.readShort(data, offset);  offset += 2;\n    obj.indexToLocFormat  = bin.readShort(data, offset);  offset += 2;\n    obj.glyphDataFormat   = bin.readShort(data, offset);  offset += 2;\n    return obj;\n}\n\n\nTypr.hhea = {};\nTypr.hhea.parse = function(data, offset, length) {\n    var bin = Typr._bin;\n    var obj = {};\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\n    obj.ascender  = bin.readShort(data, offset);  offset += 2;\n    obj.descender = bin.readShort(data, offset);  offset += 2;\n    obj.lineGap = bin.readShort(data, offset);  offset += 2;\n    \n    obj.advanceWidthMax = bin.readUshort(data, offset);  offset += 2;\n    obj.minLeftSideBearing  = bin.readShort(data, offset);  offset += 2;\n    obj.minRightSideBearing = bin.readShort(data, offset);  offset += 2;\n    obj.xMaxExtent = bin.readShort(data, offset);  offset += 2;\n    \n    obj.caretSlopeRise = bin.readShort(data, offset);  offset += 2;\n    obj.caretSlopeRun  = bin.readShort(data, offset);  offset += 2;\n    obj.caretOffset    = bin.readShort(data, offset);  offset += 2;\n    \n    offset += 4*2;\n    \n    obj.metricDataFormat = bin.readShort (data, offset);  offset += 2;\n    obj.numberOfHMetrics = bin.readUshort(data, offset);  offset += 2;\n    return obj;\n}\n\n\nTypr.hmtx = {};\nTypr.hmtx.parse = function(data, offset, length, font) {\n    var bin = Typr._bin;\n    var obj = {};\n    \n    obj.aWidth = [];\n    obj.lsBearing = [];\n        \n    var aw = 0, lsb = 0;\n    \n    for(var i=0; i<font.maxp.numGlyphs; i++) {\n        if(i<font.hhea.numberOfHMetrics) {  aw=bin.readUshort(data, offset);  offset += 2;  lsb=bin.readShort(data, offset);  offset+=2;  }\n        obj.aWidth.push(aw);\n        obj.lsBearing.push(lsb);\n    }\n    \n    return obj;\n}\n\n\nTypr.kern = {};\nTypr.kern.parse = function(data, offset, length, font) {\n    var bin = Typr._bin;\n    \n    var version = bin.readUshort(data, offset);  offset+=2;\n    if(version==1) return Typr.kern.parseV1(data, offset-2, length, font);\n    var nTables = bin.readUshort(data, offset);  offset+=2;\n    \n    var map = {glyph1: [], rval:[]};\n    for(var i=0; i<nTables; i++) {\n        offset+=2;  // skip version\n        var length  = bin.readUshort(data, offset);  offset+=2;\n        var coverage = bin.readUshort(data, offset);  offset+=2;\n        var format = coverage>>>8;\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\n        else throw \"unknown kern table format: \"+format;\n    }\n    return map;\n}\n\nTypr.kern.parseV1 = function(data, offset, length, font) {\n    var bin = Typr._bin;\n    \n    var version = bin.readFixed(data, offset);  offset+=4;\n    var nTables = bin.readUint(data, offset);  offset+=4;\n    \n    var map = {glyph1: [], rval:[]};\n    for(var i=0; i<nTables; i++) {\n        var length = bin.readUint(data, offset);   offset+=4;\n        var coverage = bin.readUshort(data, offset);  offset+=2;\n        var tupleIndex = bin.readUshort(data, offset);  offset+=2;\n        var format = coverage>>>8;\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\n        else throw \"unknown kern table format: \"+format;\n    }\n    return map;\n}\n\nTypr.kern.readFormat0 = function(data, offset, map) {\n    var bin = Typr._bin;\n    var pleft = -1;\n    var nPairs        = bin.readUshort(data, offset);  offset+=2;\n    var searchRange   = bin.readUshort(data, offset);  offset+=2;\n    var entrySelector = bin.readUshort(data, offset);  offset+=2;\n    var rangeShift    = bin.readUshort(data, offset);  offset+=2;\n    for(var j=0; j<nPairs; j++) {\n        var left  = bin.readUshort(data, offset);  offset+=2;\n        var right = bin.readUshort(data, offset);  offset+=2;\n        var value = bin.readShort (data, offset);  offset+=2;\n        if(left!=pleft) { map.glyph1.push(left);  map.rval.push({ glyph2:[], vals:[] }) }\n        var rval = map.rval[map.rval.length-1];\n        rval.glyph2.push(right);   rval.vals.push(value);\n        pleft = left;\n    }\n    return offset;\n}\n\n\n\nTypr.maxp = {};\nTypr.maxp.parse = function(data, offset, length) {\n    //console.log(data.length, offset, length);\n    \n    var bin = Typr._bin;\n    var obj = {};\n    \n    // both versions 0.5 and 1.0\n    var ver = bin.readUint(data, offset); offset += 4;\n    obj.numGlyphs = bin.readUshort(data, offset);  offset += 2;\n    \n    // only 1.0\n    if(ver == 0x00010000) {\n        obj.maxPoints             = bin.readUshort(data, offset);  offset += 2;\n        obj.maxContours           = bin.readUshort(data, offset);  offset += 2;\n        obj.maxCompositePoints    = bin.readUshort(data, offset);  offset += 2;\n        obj.maxCompositeContours  = bin.readUshort(data, offset);  offset += 2;\n        obj.maxZones              = bin.readUshort(data, offset);  offset += 2;\n        obj.maxTwilightPoints     = bin.readUshort(data, offset);  offset += 2;\n        obj.maxStorage            = bin.readUshort(data, offset);  offset += 2;\n        obj.maxFunctionDefs       = bin.readUshort(data, offset);  offset += 2;\n        obj.maxInstructionDefs    = bin.readUshort(data, offset);  offset += 2;\n        obj.maxStackElements      = bin.readUshort(data, offset);  offset += 2;\n        obj.maxSizeOfInstructions = bin.readUshort(data, offset);  offset += 2;\n        obj.maxComponentElements  = bin.readUshort(data, offset);  offset += 2;\n        obj.maxComponentDepth     = bin.readUshort(data, offset);  offset += 2;\n    }\n    \n    return obj;\n}\n\n\nTypr.U = {};\n\nTypr.U.codeToGlyph = function(font, code) {\n    var cmap = font.cmap;\n    \n    \n    var tind = -1;\n    if(cmap.p0e4!=null) tind = cmap.p0e4;\n    else if(cmap.p3e1!=null) tind = cmap.p3e1;\n    else if(cmap.p1e0!=null) tind = cmap.p1e0;\n    \n    if(tind==-1) throw \"no familiar platform and encoding!\";\n    \n    var tab = cmap.tables[tind];\n    \n    if (tab.format==0) {\n        if(code>=tab.map.length) return 0;\n        return tab.map[code];\n    } else if(tab.format==4) {\n        var sind = -1;\n        for(var i=0; i<tab.endCount.length; i++)   if(code<=tab.endCount[i]){  sind=i;  break;  } \n        if(sind==-1) return 0;\n        if(tab.startCount[sind]>code) return 0;\n        \n        var gli = 0;\n        if(tab.idRangeOffset[sind]!=0) gli = tab.glyphIdArray[(code-tab.startCount[sind]) + (tab.idRangeOffset[sind]>>1) - (tab.idRangeOffset.length-sind)];\n        else                           gli = code + tab.idDelta[sind];\n        return gli & 0xFFFF;\n    } else if(tab.format==12) {\n        if(code>tab.groups[tab.groups.length-1][1]) return 0;\n        for(var i=0; i<tab.groups.length; i++) {\n            var grp = tab.groups[i];\n            if(grp[0]<=code && code<=grp[1]) return grp[2] + (code-grp[0]);\n        }\n        return 0;\n    }\n    else throw \"unknown cmap table format \"+tab.format;\n}\n\n\nTypr.U._getGlyphClass = function(g, cd) {\n    for(var i=0; i<cd.start.length; i++) \n        if(cd.start[i]<=g && cd.end[i]>=g) return cd.class[i];\n    return 0;\n}\n\nTypr.U.getPairAdjustment = function(font, g1, g2) {\n    if(font.GPOS) {\n        var ltab = null;\n        for(var i = 0; i < font.GPOS.featureList.length; i++) {\n            var fl = font.GPOS.featureList[i];\n            if (fl.tag==\"kern\")\n                for(var j=0; j<fl.tab.length; j++) \n                    if(font.GPOS.lookupList[fl.tab[j]].ltype==2) ltab=font.GPOS.lookupList[fl.tab[j]];\n        }\n        if(ltab) {\n            for(var i = 0; i < ltab.tabs.length; i++) {\n                var tab = ltab.tabs[i];\n                var ind = Typr._lctf.coverageIndex(tab.coverage, g1);\n                if (ind==-1) continue;\n                var adj = 0;\n                if (tab.format==1) {\n                    var right = tab.pairsets[ind];\n                    for (var j=0; j<right.length; j++) if (right[j].gid2==g2) adj = right[j];\n                    if (adj==null) continue;\n                } else if (tab.format==2) {\n                    var c1 = Typr.U._getGlyphClass(g1, tab.classDef1);\n                    var c2 = Typr.U._getGlyphClass(g2, tab.classDef2);\n                    adj = tab.matrix[c1][c2];\n                }\n                return adj.val1[2];\n            }\n        }\n    }\n    if(font.kern) {\n        var ind1 = font.kern.glyph1.indexOf(g1);\n        if(ind1!=-1) {\n            var ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);\n            if(ind2!=-1) return font.kern.rval[ind1].vals[ind2];\n        }\n    }\n    \n    return 0;\n}\n\n/*\nTypr.U.isRTL = function(str) {           \n    var weakChars       = '\\u0000-\\u0040\\u005B-\\u0060\\u007B-\\u00BF\\u00D7\\u00F7\\u02B9-\\u02FF\\u2000-\\u2BFF\\u2010-\\u2029\\u202C\\u202F-\\u2BFF',\n        rtlChars        = '\\u0591-\\u07FF\\u200F\\u202B\\u202E\\uFB1D-\\uFDFD\\uFE70-\\uFEFC',\n        rtlDirCheck     = new RegExp('^['+weakChars+']*['+rtlChars+']');\n\n    return rtlDirCheck.test(str);\n};*/\n\n// var wsep = \"\\n\\t\\\" ,.:;!?()  ،\";\n//Typr.U.WSepTable = [9, 10, 32, 33, 34, 40, 41, 44, 46, 58, 59, 63, 1548]\n\n//var L = \"ꡲ્૗\";\n//Typr.U.LTable = [ 2765, 2775, 43122 ]\n\n//var R = \"آأؤإاةدذرزوٱٲٳٵٶٷڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙۀۃۄۅۆۇۈۉۊۋۍۏےۓەۮۯܐܕܖܗܘܙܞܨܪܬܯݍݙݚݛݫݬݱݳݴݸݹࡀࡆࡇࡉࡔࡧࡩࡪࢪࢫࢬࢮࢱࢲࢹૅેૉ૊૎૏ૐ૑૒૝ૡ૤૯஁ஃ஄அஉ஌எஏ஑னப஫஬\";\nTypr.U.RTable = [\n    1570, 1571, 1572, 1573, 1575, 1577, 1583, 1584, 1585, 1586,\n    1608, 1649, 1650, 1651, 1653, 1654, 1655, 1672, 1673, 1674,\n    1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684,\n    1685, 1686, 1687, 1688, 1689, 1728, 1731, 1732, 1733, 1734,\n    1735, 1736, 1737, 1738, 1739, 1741, 1743, 1746, 1747, 1749,\n    1774, 1775, 1808, 1813, 1814, 1815, 1816, 1817, 1822, 1832,\n    1834, 1836, 1839, 1869, 1881, 1882, 1883, 1899, 1900, 1905,\n    1907, 1908, 1912, 1913, 2112, 2118, 2119, 2121, 2132, 2151,\n    2153, 2154, 2218, 2219, 2220, 2222, 2225, 2226, 2233, 2757,\n    2759, 2761, 2762, 2766, 2767, 2768, 2769, 2770, 2781, 2785,\n    2788, 2799, 2945, 2947, 2948, 2949, 2953, 2956, 2958, 2959,\n    2961, 2985, 2986, 2987, 2988 ];\n\n\nTypr.U.stringToGlyphs = function(fonts, str) {\n    var gls = [], g, i, li, j, lj, k, ti, c, c2, gsub, font, llist, flist, t, gsubTable;\n    var gl, gfonts = [], codes = [], scodes = [], scodesType = [], str2 = '';\n\n    var bidiResult = bidi(str, -1, false);\n\n    var rtable = Typr.U.RTable;\n\n   for (i = 0, li = str.length; i < li; i++) {\n        c = str.charCodeAt(i);\n        scodes.push(c);\n        scodesType.push(0);\n\n        //types wsep = 1, L = 2, R = 3\n\n        if (c == 2765 || c == 2775 || c == 43122) { // L\n            scodesType[i] = 2;\n        } else if (c == 1548) { // wsep\n            scodesType[i] = 1;\n        } else if (c <= 63) { // wsep\n            if (c == 9 || c == 10 || c == 32 || c == 33 || c == 34 || c == 40 || c == 41 || c == 44 || c == 46 || c == 58 || c == 59 || c == 63) {\n                scodesType[i] = 1;\n            }\n        } else if (c >= 1570 && c <= 2988) { // R\n            if (rtable.indexOf(c) != -1) {\n                scodesType[i] = 3;\n            }\n        }\n    }\n\n    //basic shaping\n    for (i = 0, li = str.length; i < li; i++) {\n        c = scodes[i];\n\n        if (scodesType[i] != 1) { //not wsep\n            if (i < li - 2) {\n                c2 = scodes[i+1];\n\n                //myanmar \n                if (c2 == 0x103c) { //medial ra - prebase substitution\n                    scodes[i] = c2;\n                    scodes[i+1] = c;\n                    i++;\n                    continue;\n                }\n            }\n        }\n    }\n\n    //get glyphs and fonts for codes\n    for (i = 0, li = str.length; i < li; i++) {\n        c = scodes[i];\n\n        for (j = 0, lj = fonts.length; j < lj; j++) {\n            font = fonts[j];\n            g = Typr.U.codeToGlyph(font, c);\n            if (g) {\n                break;\n            }\n        }\n\n        gls.push(g);\n        gfonts.push(g ? j : 0);\n    }\n\n    codes = scodes;\n    font = null;\n    \n    \n    for(var ci = 0; ci < gls.length; ci++) {\n        gl = gls[ci];\n\n        if (font != gfonts[ci]) {\n            font = fonts[gfonts[ci]];\n            gsub = font['GSUB'];\n        }\n\n        if(!gsub) {\n            continue;\n        }\n\n        var t1 = scodesType[ci-1], t2 = scodesType[ci], t3 = scodesType[ci+1];\n\n        var slft = (ci==0) || (t1 == 1);\n        var srgt = (ci==gls.length-1) || (t3 == 1);\n        \n        if(!slft && (t1 == 3)) slft=true;\n        if(!srgt && (t2 == 3)) srgt=true;\n        \n        if(!srgt && (t3 == 2)) srgt=true;\n        if(!slft && (t2 == 2)) slft=true;\n        \n        gsubTable = null;\n        if (slft) {\n            gsubTable = srgt ? font.gsubIsolTable : font.gsubInitTable;        \n        } else {\n            gsubTable = srgt ? font.gsubFinaTable : font.gsubMediTable;            \n        }\n        \n        if (gsubTable) {\n            for(ti = 0; ti < gsubTable.length; ti++) {\n                var tab = gsubTable[ti];\n\n                for(j = 0; j < tab.length; j++) {\n                    var ttab = tab[j];\n                    var ind = Typr._lctf.coverageIndex(ttab.coverage,gl);\n                    if(ind == -1) continue;  \n\n                    if(ttab.fmt == 0) {\n                        gls[ci] = ind+ttab.delta;\n                    } else {\n                        if (!ttab.newg) {\n                            gls[ci] = gl;\n                            console.log(ci, gl, 'subst-error', ' original:', str);\n                        } else {\n                            gls[ci] = ttab.newg[ind];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    font = null;\n    \n    for(var ci=0; ci<gls.length; ci++) {\n        gl = gls[ci];\n\n        if (font != gfonts[ci]) {\n            font = fonts[gfonts[ci]];\n            gsub = font['GSUB'];\n        }\n\n        if(!gsub) {\n            continue;\n        }\n\n        gsubTable = font.gsubRligLigaTable;\n\n        if (gsubTable) {\n            var rlim = Math.min(3, gls.length-ci-1);\n\n            for(ti = 0; ti < gsubTable.length; ti++) {\n                var tab = gsubTable[ti];\n\n                for(j = 0; j < tab.length; j++) {\n                    var ttab = tab[j];\n                    var ind = Typr._lctf.coverageIndex(ttab.coverage, gl);\n                    if(ind==-1) continue;  \n\n                    var vals = ttab.vals[ind];\n                    \n                    for(k=0; k<vals.length; k++) {\n                        var lig = vals[k], rl = lig.chain.length;  if(rl>rlim) continue;\n                        var good = true;\n                        for(var l=0; l<rl; l++) if(lig.chain[l]!=gls[ci+(1+l)]) good=false;\n                        if(!good) continue;\n                        gls[ci]=lig.nglyph;\n                        for(var l=0; l<rl; l++) gls[ci+l+1]=-1;\n                        //console.log(\"lig\", fl.tag,  gl, lig.chain, lig.nglyph);\n                    }\n                }\n            }\n        }\n    }\n\n    var indices = bidiResult.indices;\n    var gls2 = gls.slice();\n    var codes2 = gls.slice();\n\n    for (i = 0, li = gls.length; i < li; i++) {\n        c = indices[i];\n        gls2[i] = gls[c];\n        codes2[i] = codes[c];\n    }\n\n    return [gls2, gfonts, codes2];\n}\n\n\nexport {Typr};\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-font.js\n// module id = 8\n// module chunks = 0","\nimport {globals as globals_} from './worker-globals.js';\nimport {setFont as setFont_, setFontMap as setFontMap_,} from './worker-text.js';\nimport {getLayer as getLayer_, getLayerPropertyValue as getLayerPropertyValue_,\n        processStylesheet as processStylesheet_, getFilterResult as getFilterResult_,\n        getLayerPropertyValueInner as getLayerPropertyValueInner_, makeFasterFilter as makeFasterFilter_} from './worker-style.js';\nimport {processLineStringPass as processLineStringPass_, processLineStringGeometry as processLineStringGeometry_} from './worker-linestring.js';\nimport {processPointArrayPass as processPointArrayPass_, processPointArrayGeometry as processPointArrayGeometry_, processPointArrayVSwitchPass as processPointArrayVSwitchPass_} from './worker-pointarray.js';\nimport {processPolygonPass as processPolygonPass_} from './worker-polygon.js';\nimport {postGroupMessageFast as postGroupMessageFast_,\n        postGroupMessageLite as postGroupMessageLite_, optimizeGroupMessages as optimizeGroupMessages_} from './worker-message.js';\n\n\n//get rid of compiler mess\nvar globals = globals_;\nvar setFont = setFont_;\nvar setFontMap = setFontMap_, makeFasterFilter = makeFasterFilter_;\nvar getLayer = getLayer_, getLayerPropertyValue = getLayerPropertyValue_,\n    processStylesheet = processStylesheet_, getFilterResult = getFilterResult_;\nvar processLineStringPass = processLineStringPass_;\nvar processPointArrayPass = processPointArrayPass_;\nvar processPointArrayVSwitchPass = processPointArrayVSwitchPass_;\nvar processPolygonPass = processPolygonPass_;\nvar processLineStringGeometry = processLineStringGeometry_;\nvar processPointArrayGeometry = processPointArrayGeometry_;\nvar postGroupMessageFast = postGroupMessageFast_, \n    postGroupMessageLite = postGroupMessageLite_, optimizeGroupMessages = optimizeGroupMessages_;\nvar getLayerPropertyValueInner = getLayerPropertyValueInner_;\n\nvar exportedGeometries = [];\nvar featureCache = new Array(1024), featureCacheIndex = 0, finalFeatureCache = new Array(1024), finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\n\n\nfunction processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo) {\n\n    switch(type) {\n    case 'line-string':\n        if (getLayerPropertyValue(layer, 'point', feature, lod) ||\n            getLayerPropertyValue(layer, 'label', feature, lod)) {\n            processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        }\n\n        processLineStringPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;\n\n    case 'point-array':\n        processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;\n            \n    case 'polygon':\n        processPolygonPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;     \n    }\n\n}\n\nfunction processFeatures(type, features, lod, featureType, group) {\n    var reduceParams = globals.reduceParams;\n\n    //loop layers\n    for (var key in globals.stylesheetLayers) {\n        var layer = globals.stylesheetLayers[key];\n\n        if (type == 'point-array') {\n            var importance = layer['importance-source'];\n\n            if (!importance && features[0] && features[0]['importance']) {\n                importance = '$importance';\n            }\n\n            if (importance) {\n                //importance = '$importance';\n                switch (globals.reduceMode) {\n                    case 'scr-count1': \n                    case 'scr-count2': \n                        layer['reduce'] = ['top',100,importance];\n                        layer['dynamic-reduce'] = ['scr-count2', reduceParams[0], reduceParams[1]];\n                        break;\n                    case 'scr-count4': \n                        layer['dynamic-reduce'] = ['scr-count4',importance];\n                        break;\n                    case 'scr-count5': \n                        layer['dynamic-reduce'] = ['scr-count5',importance];\n                        break;\n                    case 'scr-count6': \n                        layer['dynamic-reduce'] = ['scr-count6',importance];\n                        layer['label-no-overlap-margin'] = [reduceParams[0]*reduceParams[3], reduceParams[0]*reduceParams[3]];\n                        layer['icon-no-overlap-margin'] = [reduceParams[0]*reduceParams[3], reduceParams[0]*reduceParams[3]];\n                        break;\n\n                }\n            }\n        }\n\n        var filter =  layer['filter'];\n        var reduce =  layer['reduce'], i, li, j, lj;\n\n        if (filter) {\n            filter = layer['#filter'];\n            if (!filter) {\n                layer['#filter'] = makeFasterFilter(layer['filter']);\n                filter = layer['#filter'];\n            }\n        }\n\n        featureCacheIndex = 0, finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\n\n        for (i = 0, li = features.length; i < li; i++) {\n            var feature = features[i];\n            feature.properties = feature['properties'] || {};\n\n            if (feature['id']) {\n                feature.properties['#id'] = feature['id']; \n            }\n            \n            if (!filter || getFilterResult(filter, feature, featureType, group, layer, 'filter', lod, 0, true)) {\n                if (reduce) {\n                    featureCache[featureCacheIndex] = feature;\n                    featureCacheIndex++;\n                } else {\n                    processLayerFeature(type, feature, lod, layer, i);\n                }\n            }\n        }\n\n        if (reduce) {\n\n            var count = reduce[1];\n            var property = reduce[2];\n\n            switch (reduce[0]) {\n                case 'top':\n                case 'bottom':\n\n                    if (typeof property === 'string' && property.charAt(0) == '@') {\n                        property = globals.stylesheetConstants[property];\n\n                        if (typeof property === 'undefined') {\n                            break;\n                        }\n                    }\n\n                    if ((typeof property === 'string' && property.charAt(0) == '$') || (typeof property === 'object')) {\n                        var complexProperty = (typeof property === 'object');\n\n                        if (!complexProperty) {\n                            property = property.substr(1);\n                        }\n\n                        if (count > featureCacheIndex) {\n                            count = featureCacheIndex;\n                        }\n\n                        var top = (reduce[0] == 'top'), value;\n                        var currentIndex = 0;\n                        var currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n                        do {\n                            var currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n                            finalFeatureCacheIndex2 = finalFeatureCacheIndex;\n\n                            for (i = 0, li = featureCacheIndex; i < li; i++) {\n                                feature = featureCache[i];\n\n                                if (!currentIndex) {\n                                    if (!complexProperty) {\n                                        value = parseFloat(feature.properties[property]);\n                                    } else {\n                                        value = getLayerPropertyValueInner(layer, null, feature, lod, property, 0);\n                                    }\n                                    feature.tmp = value;\n                                } else {\n                                    value = feature.tmp;\n                                }\n\n                                if (!isNaN(value) && ((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {\n                                    if (currentValue != value) {\n                                        finalFeatureCacheIndex = finalFeatureCacheIndex2;\n                                    }\n\n                                    finalFeatureCache[finalFeatureCacheIndex] = feature;\n                                    finalFeatureCacheIndex++;\n                                    currentValue = value;\n                                }\n                            }\n\n                            currentValue2 = currentValue;\n                            currentIndex++;\n\n                        } while(currentIndex < count);\n                    }\n\n                    break;\n\n                case 'odd':\n                case 'even':\n\n                    for (i = (reduce[0] == 'odd') ? 1 : 0, li = featureCacheIndex; i < li; i+=2) {\n                        feature = featureCache[i];\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\n                        finalFeatureCacheIndex++;\n                    }\n\n                case 'every':\n\n                    if (count > featureCacheIndex) {\n                        count = featureCacheIndex;\n                    }\n\n                    for (i = 0, li = featureCacheIndex; i < li; i += count) {\n                        feature = featureCache[i];\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\n                        finalFeatureCacheIndex++;\n                    }\n\n                    break;\n            }\n\n            //process reduced features\n            for (i = 0, li = finalFeatureCacheIndex; i < li; i++) {\n                feature = finalFeatureCache[i];\n                processLayerFeature(type, finalFeatureCache[i], lod, layer, i);\n            }\n\n        }\n\n    }\n}\n\n\nfunction processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo) {\n    var multiPass = getLayerPropertyValue(layer, 'next-pass', feature, lod);\n\n    var mylayer;\n\n    if (multiPass != null) {\n        for (var i = 0, li = multiPass.length; i < li; i++) {\n            var zIndex = multiPass[i][0];\n            mylayer = getLayer(multiPass[i][1], type, featureIndex);\n            \n            if (!getLayerPropertyValue(mylayer, 'visible', feature, lod)) {\n                continue;\n            }\n\n            var selectedLayerId = getLayerPropertyValue(mylayer, 'selected-layer', feature, lod);\n            var selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\n\n            var selectedHoverLayerId = getLayerPropertyValue(mylayer, 'selected-hover-layer', feature, lod);\n            var selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\n\n            var hoverLayerId = getLayerPropertyValue(mylayer, 'hover-layer', feature, lod);\n            var hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\n\n            var flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\n\n            var lastHitState = globals.hitState;\n\n            if (selectedLayer != null) {\n                globals.hitState = flags | 2;\n                processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\n            }\n\n            if (selectedHoverLayer != null) {\n                globals.hitState = flags | 3;\n                processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\n            }\n\n            if (hoverLayer != null) {\n                globals.hitState = flags | 1;\n                processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\n            }\n                \n            //globals.hitState = flags | 0;\n            processLayerFeaturePass(type, feature, lod, mylayer, featureIndex, zIndex, eventInfo);\n\n            globals.hitState = lastHitState;\n        }\n    }\n}\n\n\nfunction processLayerFeature(type, feature, lod, layer, featureIndex, skipPack) {\n    if (!getLayerPropertyValue(layer, 'visible', feature, lod)) {\n        return;\n    }\n\n    if (type == 'point-array') {\n        if (layer['visibility-switch']) {\n            postGroupMessageLite(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_VSWITCH_BEGIN);\n            //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-begin'});\n            var zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\n            var eventInfo = feature.properties;\n            processPointArrayVSwitchPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n\n            var vswitch = layer['visibility-switch'];\n            for (var i = 0, li = vswitch.length; i <li; i++) {\n                if (vswitch[i][1]) {\n                    var slayer = getLayer(vswitch[i][1], type, featureIndex);\n                    processLayerFeature(type, feature, lod, slayer, featureIndex);\n                }\n                postGroupMessageLite(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_VSWITCH_STORE, vswitch[i][0]);\n                //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-store', 'viewExtent': vswitch[i][0]});\n            }\n\n            postGroupMessageLite(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_VSWITCH_END);\n            //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-end'});\n            return;\n        }\n    }\n\n    if (!skipPack && layer['pack'] == true) {\n        postGroupMessageLite(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_PACK_BEGIN);\n        //postGroupMessage({'command':'addRenderJob', 'type':'pack-begin'});\n        processLayerFeature(type, feature, lod, layer, featureIndex, true);\n        postGroupMessageLite(VTS_WORKERCOMMAND_ADD_RENDER_JOB, VTS_WORKER_TYPE_PACK_END);\n        //postGroupMessage({'command':'addRenderJob', 'type':'pack-end'});\n        return;\n    }\n\n    var zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\n\n    if (getLayerPropertyValue(layer, 'export-geometry', feature, lod) && (typeof feature['id'] !== 'undefined')) {\n        if (!exportedGeometries[feature]) {\n\n            switch(type) {\n            case 'line-string':\n                processLineStringGeometry(feature);\n                break;\n\n            case 'point-array':\n                processPointArrayGeometry(feature);\n                break;\n                    \n            case 'polygon':\n                break;     \n            }\n\n            exportedGeometries[feature] = true;\n        }\n    }\n\n    var eventInfo = feature.properties;\n\n    var selectedLayerId = getLayerPropertyValue(layer, 'selected-layer', feature, lod);\n    var selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\n\n    var selectedHoverLayerId = getLayerPropertyValue(layer, 'selected-hover-layer', feature, lod);\n    var selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\n\n    var hoverLayerId = getLayerPropertyValue(layer, 'hover-layer', feature, lod);\n    var hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\n\n    var flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\n\n    if (selectedLayer != null) {\n        globals.hitState = flags | 2;\n        processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, selectedLayer, featureIndex, eventInfo);\n    }\n\n    if (selectedHoverLayer != null) {\n        globals.hitState = flags | 3;\n        processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, selectedHoverLayer, featureIndex, eventInfo);\n    }\n\n    if (hoverLayer != null) {\n        globals.hitState = flags | 1;\n        processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, hoverLayer, featureIndex, eventInfo);\n    }\n\n    globals.hitState = flags | 0;\n    processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo);\n    processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo);\n}\n\nfunction processGroup(group, lod) {\n    var i, li;\n    var groupId = group['id'] || '';\n    globals.groupId = groupId;\n\n    var bbox = group['bbox'];    \n    if (!bbox) {\n        return;\n    }\n          \n    var bboxMin = bbox[0];\n    var bboxMax = bbox[1];\n    globals.bboxMin = bboxMin;\n    globals.bboxMax = bboxMax;\n\n    var bboxDelta = [bbox[1][0] - bbox[0][0],\n        bbox[1][1] - bbox[0][1],\n        bbox[1][2] - bbox[0][2]];\n    var bboxResolution = group['resolution'] || 4096;\n    \n    globals.groupOrigin = [0,0,0];\n    globals.forceScale = [bboxDelta[0] / bboxResolution,\n        bboxDelta[1] / bboxResolution,\n        bboxDelta[2] / bboxResolution];\n\n    postGroupMessageFast(VTS_WORKERCOMMAND_GROUP_BEGIN, 0, {'id': group['id'], 'bbox': [bboxMin, bboxMax], 'origin': bboxMin}, [], \"\");\n    //postGroupMessage({'command':'beginGroup', 'id': group['id'], 'bbox': [bboxMin, bboxMax], 'origin': bboxMin});\n\n    //process points\n    var points = group['points'] || [];\n    globals.featureType = 'point';\n    processFeatures('point-array', points, lod, 'point', groupId);\n\n    //process lines\n    var lines = group['lines'] || [];\n    globals.featureType = 'line';\n    processFeatures('line-string', lines, lod, 'line', groupId);\n\n    //process polygons\n    var polygons = group['polygons'] || [];\n    globals.featureType = 'polygon';\n    processFeatures('polygon', polygons, lod, 'polygon', groupId);\n\n    postGroupMessageLite(VTS_WORKERCOMMAND_GROUP_END, 0);\n    //postGroupMessage({'command':'endGroup'});\n\n    if (globals.groupOptimize) {\n        optimizeGroupMessages();\n    }\n\n    //optimizeGroupMessagesFast();\n}\n\n\nfunction processGeodata(data, lod) {\n    //console.log(\"processGeodata\");\n\n    //create object from JSON\n    if ((typeof data) == 'string') {\n        try {\n            var geodata = JSON.parse(data);\n        } catch (e) {\n            geodata = null;\n        }\n    } else {\n        geodata = data;\n    }\n\n    if (geodata) {\n\n        var groups = geodata['groups'] || [];\n\n        //process layers\n        for (var i = 0, li = groups.length; i < li; i++) {\n            processGroup(groups[i], lod);\n        }\n    }\n\n    //console.log(\"processGeodata-ready\");\n}\n\n\nself.onmessage = function (e) {\n    var message = e.data;\n    var command = message['command'];\n    var data = message['data'];\n\n    //console.log(\"workeronmessage: \" + command);\n\n    switch(command) {\n\n    case 'setStylesheet':\n        if (data) {\n            globals.geocent = data['geocent'];\n            globals.metricUnits = data['metric'];\n            globals.reduceMode = data['reduceMode'];\n            globals.reduceParams = data['reduceParams'];\n            globals.log = data['log'];\n            processStylesheet(data['data']);\n        }\n        //postMessage({'command' : 'ready'});\n        break;\n\n    case 'setFont':\n        setFont(data);\n        //postMessage({'command' : 'ready'});\n        break;\n\n    case 'setFontMap':\n        setFontMap(data);\n        postMessage({'command' : 'styleDone'});\n        postMessage({'command' : 'ready'});\n        break;\n\n    case 'processGeodata':\n        globals.tileLod = message['lod'] || 0;\n        globals.tileSize = message['tileSize'] || 1;\n        globals.pixelSize = message['pixelSize'] || 1;\n        globals.pixelFactor = message['dpr'] || 1;\n        globals.invPixelFactor = 1.0 / globals.pixelFactor;\n        data = JSON.parse(data);            \n        exportedGeometries = [];\n        processGeodata(data, globals.tileLod);\n\n        postGroupMessageLite(VTS_WORKERCOMMAND_ALL_PROCESSED, 0);\n            \n        if (globals.groupOptimize) {  //we need send all processed message\n            optimizeGroupMessages();\n        }\n            \n        //postMessage({'command' : 'allProcessed'});\n        postMessage({'command' : 'ready'});\n        break;\n    }\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/worker-main.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}