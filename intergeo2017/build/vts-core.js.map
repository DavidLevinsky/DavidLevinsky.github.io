{"version":3,"sources":["webpack:///webpack/bootstrap 599154e64501a632db4d?6bac","webpack:///./~/proj4/lib/constants/values.js?a11c","webpack:///./src/core/utils/matrix.js?665d","webpack:///./~/proj4/lib/common/adjust_lon.js?9bdb","webpack:///./src/core/utils/utils.js?43e6","webpack:///./src/core/utils/math.js?5d1a","webpack:///./src/core/renderer/bbox.js?b4e3","webpack:///./src/core/renderer/gpu/texture.js?3786","webpack:///./~/proj4/lib/common/asinz.js?93d5","webpack:///./~/proj4/lib/common/msfnz.js?94ba","webpack:///./~/proj4/lib/common/adjust_lat.js?3638","webpack:///./~/proj4/lib/common/sign.js?0ba4","webpack:///./src/core/utils/url.js?9490","webpack:///./src/core/core.js?25b3","webpack:///./~/proj4/lib/common/e0fn.js?74c2","webpack:///./~/proj4/lib/common/e1fn.js?3fec","webpack:///./~/proj4/lib/common/e2fn.js?3b00","webpack:///./~/proj4/lib/common/e3fn.js?ffd0","webpack:///./~/proj4/lib/common/mlfn.js?37f2","webpack:///./~/proj4/lib/common/phi2z.js?5fdb","webpack:///./~/proj4/lib/common/tsfnz.js?0d2a","webpack:///./~/proj4/lib/index.js?1d01","webpack:///./src/core/utils/platform.js?3c8f","webpack:///./~/geographiclib/geographiclib.js?72af","webpack:///./~/proj4/lib/Proj.js?bd34","webpack:///./~/proj4/lib/common/gN.js?e5ac","webpack:///./~/proj4/lib/common/imlfn.js?8586","webpack:///./~/proj4/lib/common/pj_mlfn.js?a1f0","webpack:///./~/proj4/lib/common/qsfnz.js?7c70","webpack:///./~/proj4/lib/match.js?6856","webpack:///./src/core/map/credit.js?bd8c","webpack:///./src/core/map/position.js?8470","webpack:///./src/core/renderer/gpu/mesh.js?0f3c","webpack:///./src/core/renderer/gpu/program.js?671c","webpack:///./~/earcut/src/earcut.js?f848","webpack:///./~/mgrs/mgrs.js?467c","webpack:///./~/proj4/lib/common/hypot.js?3972","webpack:///./~/proj4/lib/common/pj_enfn.js?e336","webpack:///./~/proj4/lib/common/pj_inv_mlfn.js?7097","webpack:///./~/proj4/lib/common/sinh.js?05e3","webpack:///./~/proj4/lib/common/toPoint.js?77c3","webpack:///./~/proj4/lib/datumUtils.js?48d4","webpack:///./~/proj4/lib/defs.js?d56b","webpack:///./~/proj4/lib/projString.js?a565","webpack:///./~/proj4/lib/projections/etmerc.js?0b54","webpack:///./~/proj4/lib/transform.js?40ec","webpack:///./~/wkt-parser/index.js?6171","webpack:///./src/core/map/bound-layer.js?243c","webpack:///./src/core/map/geodata-view.js?9a7f","webpack:///./src/core/map/geodata.js?6355","webpack:///./src/core/map/srs.js?e4cc","webpack:///./src/core/map/stylesheet.js?aaa6","webpack:///./src/core/map/subtexture.js?73ef","webpack:///./src/core/map/surface-tree.js?b54c","webpack:///./src/core/map/surface.js?d520","webpack:///./src/core/map/texture.js?6c77","webpack:///./src/core/map/view.js?599e","webpack:///./src/core/renderer/gpu/font.js?d6fb","webpack:///./src/core/renderer/gpu/shaders.js?0c6b","webpack:///./src/core/interface.js?4938","webpack:///./~/proj4/lib/Point.js?1b08","webpack:///./~/proj4/lib/adjust_axis.js?0cd8","webpack:///./~/proj4/lib/common/adjust_zone.js?60ac","webpack:///./~/proj4/lib/common/asinhy.js?95a5","webpack:///./~/proj4/lib/common/clens.js?f835","webpack:///./~/proj4/lib/common/clens_cmplx.js?e1af","webpack:///./~/proj4/lib/common/cosh.js?3c21","webpack:///./~/proj4/lib/common/gatg.js?1507","webpack:///./~/proj4/lib/common/iqsfnz.js?c900","webpack:///./~/proj4/lib/common/log1py.js?bd50","webpack:///./~/proj4/lib/common/srat.js?8734","webpack:///./~/proj4/lib/constants/Datum.js?65a5","webpack:///./~/proj4/lib/constants/Ellipsoid.js?daaa","webpack:///./~/proj4/lib/constants/PrimeMeridian.js?11b9","webpack:///./~/proj4/lib/constants/units.js?804c","webpack:///./~/proj4/lib/core.js?aba3","webpack:///./~/proj4/lib/datum.js?9469","webpack:///./~/proj4/lib/datum_transform.js?8452","webpack:///./~/proj4/lib/deriveConstants.js?a242","webpack:///./~/proj4/lib/extend.js?ea90","webpack:///./~/proj4/lib/global.js?51aa","webpack:///./~/proj4/lib/parseCode.js?0e01","webpack:///./~/proj4/lib/projections.js?e5c1","webpack:///./~/proj4/lib/projections/aea.js?5bd4","webpack:///./~/proj4/lib/projections/aeqd.js?0fc2","webpack:///./~/proj4/lib/projections/cass.js?cb76","webpack:///./~/proj4/lib/projections/cea.js?dd2c","webpack:///./~/proj4/lib/projections/eqc.js?01c9","webpack:///./~/proj4/lib/projections/eqdc.js?9e3d","webpack:///./~/proj4/lib/projections/gauss.js?9af7","webpack:///./~/proj4/lib/projections/geocent.js?2961","webpack:///./~/proj4/lib/projections/gnom.js?1c83","webpack:///./~/proj4/lib/projections/krovak.js?f0c7","webpack:///./~/proj4/lib/projections/laea.js?0974","webpack:///./~/proj4/lib/projections/lcc.js?67d9","webpack:///./~/proj4/lib/projections/longlat.js?aa0c","webpack:///./~/proj4/lib/projections/merc.js?47fe","webpack:///./~/proj4/lib/projections/mill.js?0cdc","webpack:///./~/proj4/lib/projections/moll.js?5a38","webpack:///./~/proj4/lib/projections/nzmg.js?3f6b","webpack:///./~/proj4/lib/projections/omerc.js?2e82","webpack:///./~/proj4/lib/projections/ortho.js?d809","webpack:///./~/proj4/lib/projections/poly.js?2dac","webpack:///./~/proj4/lib/projections/qsc.js?c317","webpack:///./~/proj4/lib/projections/sinu.js?08c1","webpack:///./~/proj4/lib/projections/somerc.js?ee47","webpack:///./~/proj4/lib/projections/stere.js?6df2","webpack:///./~/proj4/lib/projections/sterea.js?f648","webpack:///./~/proj4/lib/projections/tmerc.js?00bd","webpack:///./~/proj4/lib/projections/utm.js?dd3f","webpack:///./~/proj4/lib/projections/vandg.js?51d5","webpack:///./~/proj4/lib/version.js?04b6","webpack:///./~/proj4/package.json?10c0","webpack:///./~/proj4/projs.js?441e","webpack:///./~/wkt-parser/parser.js?baef","webpack:///./~/wkt-parser/process.js?21f7","webpack:///./~/worker-loader/createInlineWorker.js?8418","webpack:///./src/core/map/geodata-processor/worker-main.js?de58","webpack:///./src/core/inspector/graphs.js?7246","webpack:///./src/core/inspector/input.js?c89d","webpack:///./src/core/inspector/inspector.js?0960","webpack:///./src/core/inspector/layers.js?a4cc","webpack:///./src/core/inspector/replay.js?d217","webpack:///./src/core/inspector/stats.js?ae98","webpack:///./src/core/inspector/stylesheets.js?8e24","webpack:///./src/core/map/body.js?3a41","webpack:///./src/core/map/cache.js?bcad","webpack:///./src/core/map/camera.js?15ed","webpack:///./src/core/map/config.js?511f","webpack:///./src/core/map/convert.js?122f","webpack:///./src/core/map/division-node.js?2b1a","webpack:///./src/core/map/draw-tiles.js?da1f","webpack:///./src/core/map/draw.js?59b8","webpack:///./src/core/map/geodata-builder.js?fb5b","webpack:///./src/core/map/geodata-geometry.js?f95e","webpack:///./src/core/map/geodata-import/geojson.js?435d","webpack:///./src/core/map/geodata-import/vts-geodata.js?e956","webpack:///./src/core/map/geodata-processor/processor.js?15f8","webpack:///./src/core/map/interface.js?5e3f","webpack:///./src/core/map/loader.js?18f1","webpack:///./src/core/map/map.js?9e53","webpack:///./src/core/map/measure.js?b5dc","webpack:///./src/core/map/mesh.js?97dc","webpack:///./src/core/map/metanode.js?7eb4","webpack:///./src/core/map/metatile.js?5ef4","webpack:///./src/core/map/refframe.js?689d","webpack:///./src/core/map/render-slots.js?9ab2","webpack:///./src/core/map/resource-node.js?37b9","webpack:///./src/core/map/resource-tree.js?dff8","webpack:///./src/core/map/stats.js?ba1a","webpack:///./src/core/map/submesh.js?2f11","webpack:///./src/core/map/surface-sequence.js?212d","webpack:///./src/core/map/surface-tile.js?2b5e","webpack:///./src/core/map/trajectory.js?fcee","webpack:///./src/core/map/url.js?8ec2","webpack:///./src/core/map/virtual-surface.js?d770","webpack:///./src/core/renderer/camera.js?d8cc","webpack:///./src/core/renderer/draw.js?f144","webpack:///./src/core/renderer/geometry.js?3154","webpack:///./src/core/renderer/gmap.js?e8cb","webpack:///./src/core/renderer/gpu/bbox.js?faa6","webpack:///./src/core/renderer/gpu/device.js?5d54","webpack:///./src/core/renderer/gpu/group.js?94b6","webpack:///./src/core/renderer/gpu/pixel-line3.js?18e8","webpack:///./src/core/renderer/init.js?b427","webpack:///./src/core/renderer/interface.js?0670","webpack:///./src/core/renderer/octree.js?78f9","webpack:///./src/core/renderer/renderer.js?e081","webpack:///./src/core/renderer/rmap.js?7fa5","webpack:///./src/core/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA,kBAAyB;AACzB,oBAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEQ;;;;;;;;;;;;AC9yCY;AACpB;;AAEA;AACA;AACA;;;;;;;;;;;;ACLsB;AACQ;;AAE9B;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,0BAA0B,6BAA6B;AACvD;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA,wCAAwC,cAAc,mCAAmC,E;;AAEzF;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA,0BAA0B,6BAA6B;AACvD;AACA,KAAK;AACL,CAAC;;;AAGD;AACA,8BAA8B,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA,oCAAoC;AACpC,CAAC;;;AAGD;AACA;AACA,CAAC;;;AAGD;AACA;AACA,CAAC,E;;AAED;AACA;AACA,CAAC,E;;AAED;AACA;AACA,iB;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;;;AAGA,kF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGQ;;AAER;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;AC/cqB;;AAEtB;AACA;;;AAGA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGQ;;;;;;;;;ACpLR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,S;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;ACnEwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,cAAc;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;ACpSA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACLA;AACA;AACA;AACA,C;;;;;;;;;ACHgB;AAChB;;AAEA;AACA;AACA;;;;;;;;ACLA;AACA;AACA,C;;;;;;;;;;ACDA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,6B;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;;AAEA,2B;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sD;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,6B;AACA;AACA;;;AAGQ;;;;;;;;;;;;;;;;;;;;;AC5GR;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;AACM;AACA;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,KAAK;;AAEL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA,kC;AACA;AACA,KAAK;;AAEL;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK,aAAa;;AAElB;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,iGAAiG;;AAE1H,yBAAyB,yBAAyB,EAAE;AACpD;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,0CAA0C;AACvF;;AAEA;AACA;;AAEA;AACA,wCAAwC;AACxC,wEAAwE;;AAExE,0CAA0C,yDAAyD;;AAEnG,gCAAgC;;AAEhC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,kH;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,kHAAkH;AAClH,0GAA0G;AAC1G,+GAA+G;AAC/G;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGQ;;;;;;;;ACllBR;AACA;AACA,C;;;;;;;ACFA;AACA;AACA,C;;;;;;;ACFA;AACA;AACA,C;;;;;;;ACFA;AACA;AACA,C;;;;;;;ACFA;AACA;AACA,C;;;;;;;;ACFgB;;AAEhB;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChBgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8EAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnBA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;;AAEL;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEQ;;;;;;;;ACzNR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,2DAA2D;AACjE;AACA,MAAM,sDAAsD;AAC5D,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM,iDAAiD;AACvD;AACA;AACA,MAAM,6DAA6D;AACnE;AACA;AACA;AACA;AACA,MAAM,mDAAmD;AACzD;AACA,MAAM;AACN;AACA,MAAM,+DAA+D;AACrE,MAAM,+DAA+D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA,sBAAsB,cAAc;;AAEpC;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO,iBAAiB;AACvC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO,wCAAwC,QAAQ;AACtE,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO,iCAAiC,OAAO,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE,QAAQ;AAC5E,eAAe;AACf,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO,qCAAqC;AAC1D;AACA,gCAAgC,+BAA+B,QAAQ;AACvE,aAAa,EAAE;AACf,8BAA8B,gBAAgB,GAAG,wBAAwB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,yBAAyB,WAAW;AACpC,yBAAyB,WAAW;AACpC,yBAAyB,WAAW;AACpC,yBAAyB,WAAW,OAAO;AAC3C;AACA,YAAY,WAAW,WAAW;AAClC,YAAY;AACZ;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,2DAA2D;AAC3D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,OAAO,OAAO,OAAO;AAChE,gBAAgB,QAAQ,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,gDAAgD;AAChD,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,QAAQ,+DAA+D;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,sDAAsD;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,uCAAuC;AACvC,6BAA6B;AAC7B;AACA;AACA,6CAA6C;AAC7C,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa,OAAO;AACnC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc,OAAO;AACpC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa,OAAO;AACnC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,OAAO;AACrC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,YAAY,OAAO;AAClC,0BAA0B,QAAQ,OAAO;AACzC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY,OAAO;AAClC,0BAA0B,QAAQ,OAAO;AACzC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY,OAAO;AAClC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY,OAAO;AAClC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,KAAK;AACL,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4CAA4C;AAC5C,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D,KAAK;AACL,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA,uBAAuB;AACvB;AACA;AACA,wCAAwC,iBAAiB;AACzD,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,wCAAwC,iBAAiB;AACzD,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA,+DAA+D;AAC/D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA,uBAAuB;AACvB,KAAK;AACL,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC,gBAAgB,WAAW;;AAE3B;AACA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,yBAAyB,YAAY,kBAAkB;AACvD,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,WAAW;AACX;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;;AAE1B;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B,6BAA6B;;AAE7B,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA,WAAW;AACX,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA,+DAA+D;AAC/D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA,+DAA+D;AAC/D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB,0DAA0D;AAC1D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,OAAO,uDAAuD;AAC3E;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,KAAK;AAClB;AACA,aAAa,OAAO;AACpB,oCAAoC;AACpC,qCAAqC;AACrC,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,oBAAoB;AACpB;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,mBAAmB;AACnB,aAAa,KAAK;AAClB;AACA,eAAe,OAAO;AACtB,QAAQ;AACR,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,sDAAsD;AACvE;AACA,gBAAgB;AAChB;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA,QAAQ,gEAAgE;AACxE;AACA,QAAQ;AACR,2BAA2B;AAC3B,QAAQ;AACR,4BAA4B;AAC5B;AACA,aAAa,OAAO,SAAS;AAC7B,gBAAgB;AAChB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D,KAAK;AACL,uBAAuB,oBAAoB;AAC3C;AACA,yCAAyC,wBAAwB;AACjE;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,sCAAsC;AACtC;AACA,qBAAqB;AACrB,sCAAsC;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ,+CAA+C;AACpE;AACA,eAAe,OAAO;AACtB;AACA,kBAAkB;AAClB,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;;AAErD;AACA;;AAEA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ,+CAA+C;AACpE;AACA,eAAe,OAAO;AACtB;AACA,kBAAkB;AAClB,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ,+CAA+C;AACpE;AACA,eAAe,OAAO;AACtB;AACA,+DAA+D;AAC/D,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,iBAAiB;AACjB;AACA,aAAa,OAAO;AACpB,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO,mDAAmD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,KAAK;AACrB;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,QAAQ,sEAAsE;AAC9E,aAAa,OAAO,SAAS;AAC7B,gBAAgB;AAChB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB;AACA,aAAa,KAAK;AAClB;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB;AACA,aAAa,KAAK;AAClB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB;AACA,aAAa,KAAK;AAClB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAA6C;AACzD;AACA,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE;AACvE,gBAAgB;AAChB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA,6BAA6B;AAC7B;AACA,2CAA2C;AAC3C;AACA,4CAA4C;AAC5C,mDAAmD;AACnD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA,qFAA4C,YAAY,EAAE;AAAA;AAC1D,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;ACpgGD;AACA;AACA;AAC6D;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8FAAqB;AACrB,iGAAwB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACpEA;AACA;AACA;AACA,C;;;;;;;ACHA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;ACfA;AACA;AACA;AACA;AACA,C;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACTA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACfwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;AC5BsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,6D;AACA;;;AAGA;AACA;AACA;;;AAGA;;;;;;;;;ACpLA;AACA;AACA;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA,oCAAoC,kBAAkB;;;AAGtD,oCAAoC,kBAAkB;;;AAGtD,2CAA2C,sBAAsB;;;AAGjE;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,uCAAuC;AAC7G;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE,oBAAoB;AAC1F;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yB;AACA,yB;AACA,mC;AACA,yB;;AAEA,yB;AACA,yB;AACA,mC;AACA,yB;;AAEA;AACA;AACA,qC;AACA;;AAEA,2B;AACA,2B;AACA,qC;AACA,2B;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;AC9NA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0EAA0E;AAC1E;AACA;AACA;;AAEA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS;AAChC,KAAK;AACL,2BAA2B,YAAY;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC;;AAEzC,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,iCAAiC,+BAA+B;;AAEhE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;;AAEA,mBAAmB,iBAAiB;AACpC,uBAAuB,oBAAoB;AAC3C,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChoBA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;;AAEA,WAAW;AACX,WAAW;AACX,WAAW;AACX,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,IAAI;AACf;AACA,YAAY,OAAO;AACnB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzuBA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;ACvBA;AACc;;AAEd;;AAEA;AACA;AACA;AACA,wBAAwB,GAAG,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrBA;AACA;AACA;AACA;AACA,C;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;ACZA;AACwC;AACxC;AACA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH,gBAAgB;AAChB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B,SAAS;AACT,cAAc;AACd,eAAe;AACf,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ;AACR,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA;AACA,SAAS;AACT,YAAY;AACZ,YAAY;AACZ,WAAW;AACX,WAAW;AACX,YAAY;AACZ,WAAW;;AAEX;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;ACjPA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;;;;;;ACtDY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtIA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpKyC;AACzC;AACmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACxFA;AAAA;AACA;AACc;;;;AAId;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5JA;AACwB;AACM;;AAE9B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,U;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iC;AACA;AACA;AACA,SAAS;;AAET,kCAAkC,EAAE;;AAEpC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAqE;AACrE,iDAAsE;AACtE,iDAAqE;AACrE;;AAEA,wJ;;AAEA,iDAAiD;;AAEjD;AACA;;AAEA;AACA,6DAAiF;AACjF,6DAAiF;AACjF,6DAAiF;AACjF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,QAAQ;AACzD;AACA,sE;AACA,SAAS;;AAET;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,kC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,2CAA2C,+BAA+B;AAC1E;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGA;;;;;;;;;;;;;;;;AC9OsB;AACA;AACE;AACxB;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oCAAoC;;AAEpC;AACA;AACA;AACA,+CAA+C;AAC/C,8FAA8F;AAC9F;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;;AAGL,oD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA,iBAAiB,UAAU,UAAU;AACrC,iBAAiB,UAAU,UAAU;AACrC,iBAAiB,UAAU,WAAW;AACtC,wCAAwC,iCAAiC,iCAAiC;AAC1G,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA,mDAAmD,QAAQ;AAC3D,0C;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,2BAA2B;;AAE3B;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC/RA;AACwB;;AAExB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA,KAAK;AACL,kC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;;AAEA,4C;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA,+EAA+E,6DAA6D;AAC5I;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACrKA;AACsB;AACtB;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8D;AACA,4B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE;AACA;;AAEA;AACA,+F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wE;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;;AAEjC,WAAW;AACX,eAAe;AACf,gBAAgB;AAChB,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;ACrbwB;;AAExB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA,SAAS;AACT;AACA;;AAEA,KAAK;AACL,kC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9IwB;AACxB;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,qBAAqB;AACrB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B;;;AAGA;AACA;AACA;;AAEA;AACA,8B;AACA,mC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8B;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;AACA,aAAa;;AAEb,wCAAwC;AACxC;AACA,8CAA8C;AAC9C,0G;AACA;;AAEA;AACA;AACA,gH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8BAA8B;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gE;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,KAAK;AACL,kC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;;AAEA,4C;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0EAA0E;;AAE1E;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC1fsB;AACtB;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qDAAqD,2CAA2C,EAAE;AAClG;;AAEA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;;AAEA,uBAAuB,cAAc;AACrC;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,uBAAuB,cAAc;AACrC;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA,iD;AACA,SAAS;AACT,0C;AACA;;AAEA;AACA,kEAAkE;AAClE,qEAAqE;AACrE,yEAAyE;AACzE;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6C;;AAEA;;AAEA;AACA,8B;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,2EAA2E;AAC3E;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,iC;AACA;;AAEA,yBAAyB;;;AAGzB;AACA,+DAA+D,QAAQ;;AAEvE;AACA,iFAAiF;AACjF;AACA;AACA,+BAA+B;;AAE/B;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gC;AACA,yC;AACA,iD;AACA,gC;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,iDAAiD;;AAEjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,6C;;AAEA;;AAEA;AACA;AACA,8B;AACA;AACA,sB;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,OAAO;;AAExB;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,2EAA2E;;AAE3E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,iC;AACA;;AAEA,yBAAyB;;AAEzB;AACA,+DAA+D,QAAQ;;AAEvE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,gC;AACA,yC;AACA,iD;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB,0BAA0B;;AAE1B;AACA,qBAAqB;AACrB,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,6C;;AAEA;;AAEA;AACA;AACA,8B;AACA;AACA;AACA,sB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA,4C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uI;AACA;;AAEA,qEAAqE;AACrE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;;AAEA,sF;;AAEA;;AAEA,gCAAgC;;AAEhC,mCAAmC,OAAO;AAC1C;AACA;;AAEA,qFAAqF;;AAErF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oC;AACA;;AAEA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,2EAA2E;;AAE3E;AACA;;AAEA,oG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,iC;AACA;;AAEA,yBAAyB;;AAEzB;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,0F;;AAEA;AACA;;AAEA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA,mFAAmF;AACnF,4G;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,mFAAmF;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yB;AACA;;AAEA,iBAAiB,SAAS;;;AAG1B,+BAA+B,OAAO;AACtC;AACA;;AAEA,2EAA2E;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA,qB;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,wC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uE;AACA;;AAEA,iEAAiE;AACjE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,gC;AACA,yC;AACA,iD;;AAEA;AACA;;AAEA;;AAEA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA,yFAAyF;AACzF;AACA;AACA,8F;;AAEA;;AAEA;;AAEA;AACA;AACA,qCAAqC,QAAQ;AAC7C,iD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;;AAET;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;AACA;;AAEA,6C;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,2C;;AAEA,4BAA4B,QAAQ;AACpC;;AAEA;AACA;;AAEA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;;AAEA,gC;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,+F;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0D;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD,6BAA6B;AAC7B;;AAEA,kDAAkD;AAClD,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,S;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,S;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;AC36CA;AACA;AACA;AACA;AACwB;AACM;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iC;AACA;AACA;AACA,SAAS;;AAET,kCAAkC,EAAE;;AAEpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,0BAA0B;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,wJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA,gE;AACA;;AAEA;AACA,K;;;AAGA,8FAA8F,WAAW;AACzG;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,kC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,uC;AACA;;AAEA;;AAEA;AACA;AACA,oD;AACA,K;;AAEA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGA;AACA,8CAA8C,+BAA+B;AAC7E;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;AAEA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGA;AACA,kDAAkD,+BAA+B;AACjF;;;AAGA;AACA,yDAAyD,+BAA+B;AACxF,kDAAkD,+BAA+B;AACjF;;;AAGA;AACA,mDAAmD;AACnD;;;AAGA;;;;;;;;;;;;;ACrYA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,qBAAqB;AACrB,6BAA6B;;AAE7B;AACA,0F;AACA,KAAK;AACL,8E;AACA;;AAEA,4B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8DAAkF;AAClF,+DAAmF;AACnF,8DAAkF;AAClF;AACA,S;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,qC;AACA,0C;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,qC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,0C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,uBAAuB;AAChG;;AAEA,gD;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,4FAA4F,yBAAyB;AACrH;;AAEA,mE;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT,0G;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;;;AAGA;;;;;;;;;;ACxXA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,uB;;AAEA;AACA,wC;AACA,sCAAsC;AACtC,iDAAiD,QAAQ;AACzD;AACA;AACA,SAAS;AACT,qC;AACA;AACA;;AAEA,6DAA6D;AAC7D;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;AC5CA;AACwB;;AAExB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,uBAAuB;;AAE3C;AACA;AACA,uB;AACA,qB;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,oCAAoC,kBAAkB;;;AAGtD;AACA;AACA;;AAEA;AACA;AACA,sB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACvFA;;AAEA;AACA,8BAA8B;AAC9B,uBAAuB;AACvB,iBAAiB;AACjB,mDAAmD;AACnD,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,uBAAuB;AACvB,gCAAgC;AAChC,iBAAiB;AACjB,0CAA0C;AAC1C,4FAA4F;AAC5F,MAAM;;;AAGN,yDAAyD;AACzD,kBAAkB;AAClB,iDAAiD;AACjD,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,uBAAuB;AACvB,iBAAiB;AACjB,mDAAmD;AACnD,MAAM;;;AAGN,yDAAyD;AACzD,yBAAyB;AACzB,kBAAkB;AAClB,+BAA+B;AAC/B,MAAM;;;AAGN;AACA;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,+BAA+B;AAC/B,uBAAuB;AACvB,iBAAiB;AACjB,mDAAmD;AACnD,qCAAqC;AACrC,MAAM;;AAEN,kEAAkE;AAClE;AACA,yBAAyB;AACzB,+BAA+B;AAC/B,wBAAwB;AACxB;AACA,2CAA2C;AAC3C,kEAAkE;AAClE,+CAA+C;AAC/C;AACA,gFAAgF;AAChF,+DAA+D;AAC/D;AACA,MAAM;AACN,kBAAkB;AAClB,mFAAmF;AACnF,MAAM;;AAEN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,uBAAuB;AACvB,4BAA4B;AAC5B,iBAAiB;AACjB,6BAA6B;AAC7B,mDAAmD;AACnD,MAAM;;;AAGN,0DAA0D;AAC1D,yBAAyB;AACzB,4BAA4B;AAC5B,kBAAkB;AAClB,0GAA0G;AAC1G,8BAA8B;AAC9B,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,iBAAiB;AACjB,sDAAsD;AACtD,gCAAgC;AAChC,4GAA4G;AAC5G,UAAU,OAAO;AACjB,uCAAuC;AACvC,wDAAwD;AACxD,uCAAuC;AACvC,2CAA2C;AAC3C,qHAAqH;AACrH,UAAU;AACV,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,8BAA8B;AAC9B,uBAAuB;AACvB,yBAAyB;AACzB,4BAA4B;AAC5B,iBAAiB;AACjB,sDAAsD;AACtD,6BAA6B;AAC7B,gCAAgC;AAChC,4GAA4G;AAC5G,UAAU,OAAO;AACjB,uCAAuC;AACvC,wDAAwD;AACxD,uCAAuC;AACvC,2CAA2C;AAC3C,qHAAqH;AACrH,UAAU;AACV,MAAM;;AAEN;AACA,8BAA8B;AAC9B,uBAAuB;AACvB,yBAAyB;AACzB,8BAA8B;AAC9B,iBAAiB;AACjB,kEAAkE;AAClE,iCAAiC;AACjC,uCAAuC;AACvC,mCAAmC;AACnC,cAAc,OAAO;AACrB,qIAAqI;AACrI,cAAc;AACd,UAAU,OAAO;AACjB,uCAAuC;AACvC,sEAAsE;AACtE,uCAAuC;AACvC,2CAA2C;AAC3C,+HAA+H;AAC/H,UAAU;AACV,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,yCAAyC;AACzC,wDAAwD;AACxD,8BAA8B;AAC9B,sFAAsF;AACtF,UAAU,OAAO;AACjB,sGAAsG;AACtG,UAAU;;AAEV,gCAAgC;AAChC,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,iBAAiB;AACjB,yCAAyC;AACzC,wDAAwD;AACxD,gCAAgC;AAChC,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,8BAA8B;AAC9B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,yCAAyC;AACzC,wDAAwD;AACxD,6BAA6B;AAC7B,gCAAgC;AAChC,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,8BAA8B;AAC9B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,yCAAyC;AACzC,wDAAwD;AACxD,6BAA6B;AAC7B,gCAAgC;AAChC,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,sDAAsD;AACtD,kGAAkG;AAClG,gCAAgC;AAChC,kIAAkI;AAClI,UAAU,OAAO;AACjB,uCAAuC;AACvC,wDAAwD;AACxD,uCAAuC;AACvC,2CAA2C;AAC3C,2IAA2I;AAC3I,UAAU;AACV,MAAM;;AAEN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,8BAA8B;AAC9B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,sDAAsD;AACtD,6BAA6B;AAC7B,gCAAgC;AAChC,kIAAkI;AAClI,UAAU,OAAO;AACjB,uCAAuC;AACvC,wDAAwD;AACxD,uCAAuC;AACvC,2CAA2C;AAC3C,2IAA2I;AAC3I,UAAU;AACV,MAAM;;AAEN,0DAA0D;AAC1D,gCAAgC;AAChC,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,kBAAkB;AAClB,sDAAsD;AACtD,0BAA0B;AAC1B,MAAM;;;AAGN,2DAA2D;AAC3D,gCAAgC;AAChC,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,kBAAkB;AAClB,uDAAuD;AACvD,8BAA8B;AAC9B,oBAAoB,cAAc;AAClC,6BAA6B;AAC7B,8BAA8B;AAC9B,4BAA4B;AAC5B,0BAA0B;AAC1B,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,uBAAuB;AACvB,yBAAyB;AACzB,yBAAyB;AACzB,iBAAiB;AACjB,8EAA8E;AAC9E,6BAA6B;AAC7B,qFAAqF;AACrF,oCAAoC;AACpC,mDAAmD;AACnD,MAAM;;;AAGN,4DAA4D;AAC5D,yBAAyB;AACzB,kBAAkB;AAClB,+BAA+B;AAC/B,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,uBAAuB;AACvB,uBAAuB;AACvB,4BAA4B;AAC5B,iBAAiB;AACjB,kCAAkC;AAClC,gFAAgF;AAChF,2DAA2D;AAC3D,UAAU,KAAK;AACf,2DAA2D;AAC3D,UAAU;AACV,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,uBAAuB;AACvB,uBAAuB;AACvB,yBAAyB;AACzB,4BAA4B;AAC5B,iBAAiB;AACjB,kCAAkC;AAClC,gFAAgF;AAChF,2DAA2D;AAC3D,UAAU,KAAK;AACf,iDAAiD;AACjD,gDAAgD;AAChD,wCAAwC;AACxC,+DAA+D;AAC/D,cAAc,KAAK;AACnB,+DAA+D;AAC/D,cAAc;AACd,UAAU;AACV,MAAM;;AAEN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,4BAA4B;AAC5B,iBAAiB;AACjB,8CAA8C;AAC9C,gDAAgD;AAChD,+GAA+G;AAC/G,MAAM;;AAEN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,4BAA4B;AAC5B,uBAAuB;AACvB,yBAAyB;AACzB,yBAAyB;AACzB,4BAA4B;AAC5B,6BAA6B,uBAAuB,EAAE;AACtD,iBAAiB;AACjB,8CAA8C;AAC9C,6CAA6C;AAC7C,4CAA4C;AAC5C,oCAAoC;AACpC,2DAA2D;AAC3D,UAAU,KAAK;AACf,oDAAoD;AACpD,oEAAoE;AACpE,oEAAoE;AACpE,mHAAmH;AACnH,UAAU;AACV,MAAM;;AAEN;AACA,8BAA8B;AAC9B,uBAAuB;AACvB,yBAAyB;AACzB,0BAA0B;AAC1B,+BAA+B;AAC/B,yBAAyB;AACzB,4BAA4B;AAC5B,iBAAiB;AACjB,sCAAsC;AACtC,kCAAkC;AAClC,qCAAqC;AACrC,gBAAgB;AAChB,uCAAuC;AACvC,mEAAmE;AACnE,mEAAmE;AACnE,mEAAmE;AACnE,mEAAmE;AACnE,kDAAkD;AAClD,oCAAoC;AACpC,qCAAqC;AACrC,oCAAoC;AACpC,oCAAoC;AACpC,2DAA2D;AAC3D,UAAU,KAAK;AACf,wDAAwD;AACxD,mGAAmG;AACnG,UAAU;AACV,MAAM;;;AAGN,yDAAyD;AACzD,gCAAgC;AAChC,yBAAyB;AACzB,4BAA4B;AAC5B,kBAAkB;AAClB,+CAA+C;AAC/C,wBAAwB,SAAS,EAAE;AACnC,iCAAiC;AACjC,MAAM;;AAEN,0DAA0D;AAC1D,gCAAgC;AAChC,yBAAyB;AACzB,0BAA0B;AAC1B,mDAAmD;AACnD,mDAAmD;AACnD,4BAA4B;AAC5B,2BAA2B,uBAAuB,EAAE;;AAEpD,kBAAkB;AAClB,mBAAmB;AACnB,uCAAuC;AACvC,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;;AAEhD,6BAA6B;AAC7B,0BAA0B;AAC1B,yDAAyD;AACzD,mBAAmB;;AAEnB,qCAAqC;AACrC,oCAAoC;AACpC,0FAA0F;;AAE1F,0BAA0B,SAAS,EAAE;AACrC,gDAAgD;AAChD,oCAAoC;AACpC,MAAM;;AAEN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,uBAAuB;AACvB,4BAA4B;AAC5B,iBAAiB;AACjB,mDAAmD;AACnD,+BAA+B;AAC/B,MAAM;;;AAGN,4DAA4D;AAC5D,gCAAgC;AAChC,4BAA4B;AAC5B,sDAAsD;AACtD,kBAAkB;AAClB,0DAA0D;AAC1D,wEAAwE;AACxE,MAAM;;;AAGN,6DAA6D;AAC7D,gCAAgC;AAChC,4BAA4B;AAC5B,kBAAkB;AAClB,uDAAuD;AACvD,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,wBAAwB;AACxB,0BAA0B;AAC1B,4BAA4B;AAC5B,iBAAiB;AACjB,uDAAuD;AACvD,2CAA2C;AAC3C,6CAA6C;AAC7C,+CAA+C;AAC/C,iCAAiC;AACjC,MAAM;;;AAGN,yDAAyD;AACzD,gCAAgC;AAChC,0BAA0B;AAC1B,2BAA2B;AAC3B,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B,0DAA0D;AACtF,6BAA6B,yDAAyD;AACtF,kBAAkB;AAClB,yDAAyD;AACzD,yCAAyC;AACzC,gDAAgD;AAChD,2CAA2C;AAC3C,MAAM;;;AAGN,0DAA0D;AAC1D,gCAAgC;AAChC,4BAA4B;AAC5B,0BAA0B;AAC1B,uBAAuB;AACvB,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B,0DAA0D;AACtF,kBAAkB;AAClB,+CAA+C;AAC/C,0BAA0B;AAC1B,mCAAmC;AACnC,uCAAuC;AACvC,+DAA+D;AAC/D,qBAAqB;AACrB,yCAAyC;AACzC,4BAA4B;;AAE5B,UAAU;AACV,kCAAkC;AAClC,MAAM;;;AAGN;AACA,8BAA8B;AAC9B,gCAAgC;AAChC,6BAA6B;AAC7B,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;;AAE3B,6BAA6B;;AAE7B,iBAAiB;AACjB,4DAA4D;;AAE5D,6EAA6E;AAC7E,gCAAgC;AAChC,yCAAyC;AACzC,4CAA4C;AAC5C,sCAAsC;;AAEtC,8CAA8C;AAC9C,+CAA+C;AAC/C,0CAA0C;;AAE1C;AACA,6DAA6D;AAC7D,0FAA0F;AAC1F,gDAAgD;;AAEhD;AACA,0DAA0D;AAC1D,uFAAuF;;AAEvF;AACA,iCAAiC;AACjC,iEAAiE;;AAEjE;AACA,2HAA2H;AAC3H,uCAAuC;;AAEvC;AACA,iFAAiF;;AAEjF;AACA,2DAA2D;;AAE3D,+BAA+B;;AAE/B,qEAAqE;AACrE,+BAA+B;AAC/B,MAAM;;;AAGN,0DAA0D;AAC1D,6BAA6B;AAC7B,2BAA2B;AAC3B,4BAA4B,2DAA2D;AACvF,6BAA6B,0DAA0D;AACvF,uEAAuE;;AAEvE,kBAAkB;AAClB,gCAAgC;AAChC,6BAA6B,SAAS,EAAE,OAAO;AAC/C,uDAAuD;AACvD,qDAAqD;AACrD,+CAA+C;;AAE/C,iCAAiC,oFAAoF,EAAE;AACvH,UAAU;;AAEV,MAAM;;;AAGN;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,+BAA+B;AAC/B,2BAA2B;AAC3B,0CAA0C;AAC1C,0BAA0B;AAC1B,2CAA2C;AAC3C,0CAA0C;AAC1C,6BAA6B;AAC7B,6BAA6B;AAC7B,8BAA8B;AAC9B,2BAA2B,uBAAuB,EAAE;AACpD,kBAAkB;AAClB,8BAA8B;AAC9B,2FAA2F;AAC3F,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,iDAAiD;AACjD,oDAAoD;AACpD,gCAAgC;AAChC,sDAAsD;AACtD,sDAAsD;AACtD,MAAM;;;AAGN,8DAA8D;AAC9D,gCAAgC;AAChC,8BAA8B;AAC9B,6BAA6B;AAC7B,6BAA6B;AAC7B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB,4GAA4G;AAC5G,8DAA8D;AAC9D,MAAM;;;AAGN;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,+BAA+B;AAC/B,2BAA2B;AAC3B,0CAA0C;AAC1C,0BAA0B;AAC1B,2CAA2C;AAC3C,0CAA0C;AAC1C,6BAA6B;AAC7B,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B,uBAAuB,EAAE;AACpD,kBAAkB;AAClB,8BAA8B;AAC9B,2FAA2F;AAC3F,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,0BAA0B;AAC1B,oDAAoD;AACpD,gCAAgC;AAChC,sDAAsD;AACtD,sDAAsD;AACtD,MAAM;;;AAGN,mEAAmE;AACnE,gCAAgC;AAChC,8BAA8B;AAC9B,6BAA6B;AAC7B,6BAA6B;AAC7B,0BAA0B;AAC1B,kBAAkB;AAClB,yGAAyG;AACzG,MAAM;;AAEN;AACA,gEAAgE;AAChE,2EAA2E;AAC3E,2EAA2E;AAC3E,qDAAqD;AACrD,uDAAuD;AACvD,uDAAuD;AACvD,qHAAqH,EAAE;;;AAGvH;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;AAC3B,gCAAgC;AAChC,4BAA4B;AAC5B,6BAA6B;AAC7B,8BAA8B;AAC9B,kBAAkB;AAClB,kCAAkC;AAClC,4CAA4C;AAC5C,4BAA4B;AAC5B,6CAA6C;AAC7C,iDAAiD;AACjD,oDAAoD;AACpD,sCAAsC;AACtC,sBAAsB;AACtB,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gIAAgI;AAChI,oCAAoC;AACpC,2CAA2C;AAC3C,iDAAiD;AACjD,gDAAgD;AAChD,iBAAiB;AACjB,wDAAwD;AACxD,8DAA8D;AAC9D,wBAAwB;AACxB,MAAM;;;AAGN,0DAA0D;AAC1D,gCAAgC;AAChC,2BAA2B;AAC3B,4BAA4B;AAC5B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB,uGAAuG;AACvG,sDAAsD;AACtD,MAAM;;AAEN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;AAC3B,gCAAgC;AAChC,4BAA4B;AAC5B,6BAA6B;AAC7B,8BAA8B;AAC9B,kBAAkB;AAClB,kCAAkC;AAClC,4CAA4C;AAC5C,4BAA4B;AAC5B,6CAA6C;AAC7C,iDAAiD;AACjD,oDAAoD;AACpD,sCAAsC;AACtC,sBAAsB;AACtB,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gIAAgI;AAChI,oCAAoC;AACpC,2CAA2C;AAC3C,iDAAiD;AACjD,gDAAgD;AAChD,iBAAiB;AACjB,wDAAwD;AACxD,8DAA8D;AAC9D,wBAAwB;AACxB,2BAA2B;AAC3B,MAAM;;;AAGN,2DAA2D;AAC3D,gCAAgC;AAChC,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,6BAA6B;AAC7B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB,+DAA+D,SAAS,EAAE;AAC1E,uGAAuG;AACvG,sDAAsD;AACtD,MAAM;;AAEN;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;AAC3B,gCAAgC;AAChC,0BAA0B;AAC1B,+BAA+B;AAC/B,4BAA4B;AAC5B,6BAA6B;AAC7B,8BAA8B;AAC9B,2CAA2C;AAC3C,yBAAyB;AACzB,yBAAyB;AACzB,iCAAiC;AACjC,sCAAsC;AACtC,6BAA6B;AAC7B,6BAA6B;AAC7B,iFAAiF;AACjF,oFAAoF;AACpF,oCAAoC;AACpC,MAAM;AACN,kBAAkB;AAClB,kCAAkC;AAClC,4CAA4C;AAC5C,sBAAsB;AACtB,4BAA4B;AAC5B,6CAA6C;AAC7C,iDAAiD;AACjD,oDAAoD;AACpD,sCAAsC;AACtC,uBAAuB;AACvB,sBAAsB;AACtB,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gIAAgI;AAChI,0DAA0D;AAC1D,oCAAoC;AACpC,2CAA2C;AAC3C,iDAAiD;AACjD,gDAAgD;AAChD,iBAAiB;AACjB,wDAAwD;AACxD,8DAA8D;AAC9D,wBAAwB;AACxB,MAAM;;AAEN;AACA,oEAAoE;AACpE,gBAAgB;AAChB,yFAAyF;AACzF,yFAAyF;AACzF,yFAAyF;AACzF,yFAAyF;AACzF,gEAAgE;;AAEhE;AACA,qEAAqE;AACrE,gBAAgB;AAChB,yFAAyF;AACzF,yFAAyF;AACzF,yFAAyF;AACzF,yFAAyF;AACzF,gDAAgD;;AAEhD;AACA;AACA,iCAAiC;AACjC,8BAA8B;AAC9B,gCAAgC;AAChC,mCAAmC;AACnC,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;AAC3B,gCAAgC;AAChC,0BAA0B;AAC1B,2BAA2B;AAC3B,6BAA6B;AAC7B,gCAAgC;AAChC,4BAA4B;AAC5B,6BAA6B;AAC7B,+BAA+B;;AAE/B;AACA,2BAA2B;AAC3B;AACA,8BAA8B;AAC9B;;AAEA,8BAA8B;AAC9B,6BAA6B,mFAAmF;;AAEhH,kBAAkB;AAClB,kCAAkC;AAClC,4CAA4C;AAC5C,sBAAsB;AACtB,4BAA4B;AAC5B,6CAA6C;AAC7C,iDAAiD;AACjD,oDAAoD;AACpD,sCAAsC;AACtC,uBAAuB;AACvB,sBAAsB;AACtB,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gIAAgI;AAChI,sCAAsC;AACtC,oGAAoG;;AAEpG,kGAAkG;;AAElG,oCAAoC;AACpC,2CAA2C;AAC3C,iDAAiD;AACjD,gDAAgD;;AAEhD,qCAAqC;AACrC,iDAAiD;AACjD,iDAAiD;AACjD,wBAAwB;;AAExB,wCAAwC;;AAExC;AACA,8FAA8F;AAC9F,yCAAyC,6BAA6B;AACtE,iEAAiE;AACjE;AACA,6FAA6F;AAC7F,oCAAoC;AACpC;;AAEA,MAAM,E;;AAEN,2DAA2D;AAC3D;AACA;AACA,gCAAgC;AAChC,2BAA2B;AAC3B,yBAAyB;AACzB,4BAA4B;AAC5B,8BAA8B;AAC9B,+BAA+B;;AAE/B;AACA,2BAA2B;AAC3B;AACA,8BAA8B;AAC9B;;AAEA,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB,8CAA8C;;AAE9C;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,oDAAoD;AACpD,qFAAqF;AACrF;;AAEA;AACA,mFAAmF;;AAEnF;AACA,kGAAkG;AAClG;AACA,4DAA4D;AAC5D;;AAEA;AACA,uCAAuC;AACvC;;AAEA,iDAAiD;;AAEjD,gCAAgC;AAChC,kDAAkD;AAClD,8EAA8E;AAC9E,iEAAiE;AACjE,4DAA4D;AAC5D,4DAA4D;AAC5D,gDAAgD;;AAEhD;AACA,oDAAoD;AACpD;AACA,0EAA0E;AAC1E;AACA,2DAA2D;AAC3D,gDAAgD;AAChD;;AAEA;AACA,2GAA2G;AAC3G,iCAAiC;AACjC;AACA;;AAEA,yDAAyD;;AAEzD;AACA,4CAA4C;;AAE5C;AACA,gEAAgE;AAChE,+DAA+D;AAC/D,iEAAiE;AACjE,+DAA+D;AAC/D,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE,gEAAgE;AAChE,+DAA+D;AAC/D,iEAAiE;AACjE,kEAAkE;AAClE,kEAAkE;AAClE,kEAAkE;AAClE,kEAAkE;AAClE,kEAAkE;AAClE,gEAAgE;AAChE,kEAAkE;AAClE,kEAAkE;AAClE,iEAAiE;AACjE,gEAAgE;AAChE,gCAAgC;AAChC;;AAEA,oGAAoG;AACpG,+EAA+E;AAC/E,iFAAiF;AACjF,sEAAsE;AACtE,4FAA4F;AAC5F,kFAAkF;AAClF,uEAAuE;AACvE,uEAAuE;AACvE,uEAAuE;AACvE,iFAAiF;AACjF,uEAAuE;AACvE,8CAA8C;AAC9C;;AAEA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA,8BAA8B;AAC9B;AACA,MAAM;;AAEN;AACA;AACA,8BAA8B;;AAE9B;AACA,kCAAkC;AAClC;;AAEA;AACA,uCAAuC;AACvC;AACA,sCAAsC;AACtC;;AAEA,gCAAgC;;AAEhC;AACA;AACA,sCAAsC;;AAEtC,kBAAkB;AAClB,uDAAuD;AACvD,qKAAqK;AACrK,2CAA2C;AAC3C,iDAAiD;AACjD,4DAA4D;AAC5D,iGAAiG;AACjG,6EAA6E;;AAE7E;AACA,oCAAoC;AACpC;AACA,qCAAqC;;AAErC;AACA,mIAAmI;AACnI;AACA,0CAA0C;AAC1C;;AAEA;AACA,MAAM;;AAEN,yDAAyD;;AAEzD;AACA,kCAAkC;AAClC;;AAEA,gCAAgC;AAChC,oCAAoC;;AAEpC;AACA,yCAAyC;AACzC;;AAEA;;AAEA,2BAA2B;AAC3B,kBAAkB;AAClB,iDAAiD;;AAEjD;AACA,2DAA2D;AAC3D;;AAEA;AACA,4DAA4D;AAC5D,yDAAyD;AACzD;AACA,kEAAkE;AAClE,oDAAoD;AACpD;AACA,6CAA6C;AAC7C;;AAEA,mCAAmC;AACnC;AACA,8FAA8F;AAC9F;;AAEA;AACA,MAAM;;;AAGN;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,4BAA4B;AAC5B,6BAA6B;AAC7B,wBAAwB;AACxB,+BAA+B;AAC/B,4BAA4B;AAC5B,4BAA4B;AAC5B,0BAA0B;AAC1B,8BAA8B;AAC9B,kBAAkB;AAClB,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,iDAAiD;AACjD,+BAA+B;AAC/B,iCAAiC;AACjC,mCAAmC;AACnC,MAAM;;;AAGN,gEAAgE;AAChE,gCAAgC;AAChC,4BAA4B;AAC5B,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B;AAC5B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB,+CAA+C;AAC/C,0CAA0C;AAC1C,4BAA4B;AAC5B,8CAA8C;AAC9C,qFAAqF;AACrF,6DAA6D;AAC7D,8EAA8E;AAC9E,sDAAsD;AACtD,+FAA+F,mCAAmC;AAClI,MAAM;;;AAGN,+DAA+D;AAC/D,4BAA4B;AAC5B,4BAA4B;AAC5B,0BAA0B;AAC1B,4BAA4B;AAC5B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,kBAAkB;AAClB,+CAA+C;AAC/C,0CAA0C;AAC1C,4BAA4B;AAC5B,8CAA8C;AAC9C,oFAAoF;AACpF,4DAA4D;AAC5D,8EAA8E;AAC9E,sFAAsF,mCAAmC;AACzH,MAAM;;AAEN;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,iCAAiC;AACjC,6BAA6B;AAC7B,+BAA+B;AAC/B,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B,kBAAkB;AAClB,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,iDAAiD;AACjD,+BAA+B;AAC/B,wCAAwC;AACxC,MAAM;;;AAGN,kEAAkE;AAClE;AACA,gCAAgC;AAChC,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B,kBAAkB;AAClB;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,iDAAiD;AACjD,yFAAyF;AACzF;AACA,kDAAkD;AAClD;AACA,MAAM;;AAEN;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,iCAAiC;AACjC,6BAA6B;AAC7B,+BAA+B;AAC/B,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B,kBAAkB;AAClB,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,iDAAiD;AACjD,+BAA+B;AAC/B,qCAAqC;AACrC,MAAM;;;AAGN,kEAAkE;AAClE;AACA,gCAAgC;AAChC,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,+EAA+E;AAC/E,wBAAwB;AACxB;AACA,2CAA2C;AAC3C,kEAAkE;AAClE,+CAA+C;AAC/C;AACA,gFAAgF;AAChF,+DAA+D;AAC/D;AACA,MAAM;AACN,kBAAkB;AAClB,kIAAkI;AAClI,MAAM;;;AAGN,mEAAmE;AACnE;AACA,gCAAgC;AAChC,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B,4BAA4B,2DAA2D;AACvF,wBAAwB;AACxB;AACA,2CAA2C;AAC3C,kEAAkE;AAClE,+CAA+C;AAC/C;AACA,gFAAgF;AAChF,+DAA+D;AAC/D;AACA,MAAM;AACN,kBAAkB;AAClB,iCAAiC,yCAAyC,EAAE,OAAO,SAAS,EAAE;AAC9F,MAAM;;AAEN;AACA;AACA,8BAA8B;AAC9B,+BAA+B;AAC/B,iCAAiC;AACjC,6BAA6B;AAC7B,+BAA+B;AAC/B,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B,kBAAkB;AAClB,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,iDAAiD;AACjD,gCAAgC;AAChC,qCAAqC;AACrC,MAAM;;AAEN;AACA;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B,0BAA0B;AAC1B,kBAAkB;AAClB,uDAAuD;AACvD,2CAA2C;AAC3C,iDAAiD;AACjD,0BAA0B;AAC1B,MAAM;;;AAGN,8DAA8D;AAC9D,gCAAgC;AAChC,0BAA0B;AAC1B,kBAAkB;AAClB,yGAAyG;AACzG,MAAM;;AAEN;AACA;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,wBAAwB;AACxB,yBAAyB;AACzB,0BAA0B;AAC1B,yBAAyB;AACzB,6BAA6B;AAC7B,qBAAqB;AACrB,gCAAgC;AAChC,qGAAqG;AACrG;;AAEA,0JAA0J;AAC1J,0JAA0J;AAC1J,0JAA0J;AAC1J,0JAA0J;;AAE1J,uBAAuB;AACvB,kBAAkB;AAClB,kBAAkB;AAClB,MAAM;;;AAGN,0DAA0D;AAC1D,yBAAyB;AACzB,6BAA6B;AAC7B,gCAAgC;AAChC,qBAAqB;AACrB,uEAAuE;AACvE,mBAAmB;AACnB,wBAAwB,SAAS,EAAE;AACnC,0BAA0B;AAC1B,MAAM;;;AAGN;;;;;;;;;;;;;;;;;;;AC91CA;AACA;AACsB;AACtB,UAAU,gCAAgC;;AAE1C;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,KAAK;;AAEL;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,KAAK;;AAEL;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,KAAK;;AAEL;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGA;AACA,qBAAqB,aAAa;AAClC;AACA,EAAE;;;AAGF;AACA,qBAAqB,aAAa;AAClC;AACA;;AAEA;AACA,qBAAqB,aAAa;AAClC;AACA;;AAEA;AACA,qBAAqB,aAAa;AAClC;AACA;;;AAGQ;;;;;;;;;ACjGiB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnDA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;ACbA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACdA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;AC/BA;AACA;AACA;AACA;AACA,C;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACdgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/BA;AACA;AACA;;AAEA;AACA;;;;;;;;ACLA;AACA;AACA,C;;;;;;;ACFA;AAAA;AACQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AChGA;AAAA;AACQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AClQA;AAAA;AACQ;;AAER,wBAAwB;AACxB,iCAAiC;AACjC,+BAA+B;AAC/B,kCAAkC;AAClC,iCAAiC;AACjC,+BAA+B;AAC/B,8BAA8B;AAC9B,mCAAmC;AACnC,iCAAiC;AACjC,4BAA4B;AAC5B,oCAAoC;AACpC,4BAA4B;AAC5B,+BAA+B;;;;;;;;ACf/B;AACA,OAAO,iBAAiB;AACxB,YAAY;AACZ;;;;;;;;;;ACHA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gE;;;;;;;;AC1EmE;;AAEnE;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AClC4C;;AAE8D;AAC1G;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtC+B;AACK;AACpC;;AAEA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB;AACtB;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2J;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AChIA;AACuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpHA;AACA;AACwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnDA;AACA;AACA;;AAEA;AACA;AACA;AACQ;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;;;;;;;;ACfA;AACA;AACc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,WAAW;AACX,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxG+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzSA;AACA;AACA;AACA;AACA;AACuB;AACvB;;AAEA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB;AAChB,gBAAgB;AAChB,iBAAiB;AACjB,iBAAiB;AACjB,sBAAsB;AACtB,uBAAuB;;AAEvB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1IA;AACA;AACA;;AAEA;AACA;AACA;AACQ;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACfA;;AAEA;AACA;AACA;AACoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnGA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnDA;AACA;AACc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClFmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjOA;AACA;AACA;AAC+B;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1KA;AACA;AACuB;;AAEvB;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,WAAW;AACX,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,QAAQ;AACR,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACc;;AAEd;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,0JAA0E;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtIA;AAAA;AACA;;AAE4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9WA;AACA;AACA;AACA;AACA;AACA;AACuB;;AAEvB;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClHA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrFuB;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7KA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/DA;AAAA;AACA;;AAEA;AACA;AACA;AACA;;AAEuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5KA;AACA;AACA;AACY;;;AAGZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BA;;AAEuB;;AAEvB;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChI2B;;;;;;;ACA3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,glCAAglC,QAAQ,s/BAAs/B,iIAAiI,2GAA2G,4NAA4N,4UAA4U,sGAAsG,oMAAoM,kHAAkH,qYAAqY,wTAAwT,sDAAsD,ujBAAujB;AACxiJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;yDACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;ACrDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzGA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO,WAAW;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzBA;AACA,0lCAAmpC,+BAA+B,4TAA4T,2FAA2F,mGAAmG,sGAAsG,2DAA2D,gBAAgB,2HAA2H,mFAAmF,iBAAiB,0JAA0J,oFAAoF,iGAAiG,cAAc,gIAAgI,uGAAuG,sJAAsJ,cAAc,GAAG,0IAA0I,0DAA0D,uDAAuD,2HAA2H,EAAE,gBAAgB,eAAe,qJAAqJ,iGAAiG,0BAA0B,EAAE,gDAAgD,eAAe,GAAG,0DAA0D,6BAA6B,eAAe,+HAA+H,+DAA+D,GAAG,2FAA2F,iIAAiI,YAAY,wKAAwK,mBAAmB,+FAA+F,gBAAgB,EAAE,EAAE,+FAA+F,cAAc,EAAE,EAAE,+FAA+F,sBAAsB,EAAE,EAAE,+FAA+F,mBAAmB,EAAE,EAAE,+FAA+F,kBAAkB,EAAE,EAAE,+FAA+F,sBAAsB,EAAE,EAAE,+FAA+F,gBAAgB,EAAE,EAAE,+FAA+F,2BAA2B,EAAE,EAAE,mBAAmB,yBAAyB,4BAA4B,6BAA6B,2BAA2B,+BAA+B,+BAA+B,iBAAiB,oBAAoB,wBAAwB,4oBAA4oB,uCAAuC,wBAAwB,sBAAsB,OAAO,0BAA0B,sBAAsB,OAAO,qBAAqB,GAAG,oCAAoC,mBAAmB,wGAAwG,cAAc,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,WAAW,OAAO,OAAO,mBAAmB,mBAAmB,mBAAmB,mBAAmB,OAAO,gBAAgB,mBAAmB,mBAAmB,mBAAmB,eAAe,GAAG,8BAA8B,sCAAsC,eAAe,8CAA8C,GAAG,mCAAmC,mBAAmB,sCAAsC,eAAe,sCAAsC,eAAe,2BAA2B,2BAA2B,2BAA2B,eAAe,GAAG,6BAA6B,qCAAqC,mBAAmB,WAAW,wBAAwB,sCAAsC,QAAQ,OAAO,kCAAkC,2CAA2C,oBAAoB,mCAAmC,oBAAoB,GAAG,oDAAoD,8BAA8B,oBAAoB,OAAO,8BAA8B,aAAa,sBAAsB,qBAAqB,OAAO,OAAO,kDAAkD,OAAO,wBAAwB,qBAAqB,6BAA6B,QAAQ,OAAO,gCAAgC,uBAAuB,IAAI,iCAAiC,4BAA4B,eAAe,0BAA0B,WAAW,iBAAiB,IAAI,wBAAwB,mCAAmC,0DAA0D,eAAe,yBAAyB,yBAAyB,wBAAwB,WAAW,OAAO,oBAAoB,GAAG,EAAE,wDAAwD,wCAAwC,QAAQ,OAAO,2CAA2C,YAAY,OAAO,qBAAqB,GAAG,2DAA2D,kBAAkB,6CAA6C,YAAY,8CAA8C,QAAQ,OAAO,+CAA+C,YAAY,WAAW,OAAO,OAAO,kCAAkC,YAAY,OAAO,qBAAqB,GAAG,mEAAmE,kBAAkB,8CAA8C,YAAY,8CAA8C,QAAQ,OAAO,sCAAsC,kDAAkD,QAAQ,OAAO,qDAAqD,YAAY,eAAe,WAAW,OAAO,OAAO,mCAAmC,YAAY,OAAO,qBAAqB,GAAG,4CAA4C,mBAAmB,0CAA0C,QAAQ,OAAO,kCAAkC,OAAO,oBAAoB,GAAG,qCAAqC,4EAA4E,iGAAiG,sCAAsC,4BAA4B,6CAA6C,OAAO,OAAO,2DAA2D,yDAAyD,6CAA6C,0CAA0C,QAAQ,OAAO,0CAA0C,WAAW,wCAAwC,2FAA2F,sEAAsE,wDAAwD,kGAAkG,uDAAuD,+FAA+F,oIAAoI,6FAA6F,aAAa,sFAAsF,yFAAyF,aAAa,sFAAsF,gIAAgI,+BAA+B,eAAe,2DAA2D,2GAA2G,sGAAsG,+EAA+E,iFAAiF,gKAAgK,gEAAgE,iBAAiB,iJAAiJ,iCAAiC,iBAAiB,eAAe,aAAa,oDAAoD,WAAW,wFAAwF,eAAe,GAAG,8EAA8E,yCAAyC,4BAA4B,+CAA+C,OAAO,OAAO,+EAA+E,OAAO,GAAG,qBAAqB,gFAAgF,mBAAmB,qGAAqG,+FAA+F,8BAA8B,EAAE,EAAE,+FAA+F,6BAA6B,EAAE,EAAE,+FAA+F,6BAA6B,EAAE,EAAE,+NAA+N,sDAAsD,uDAAuD,+EAA+E,mEAAmE,yDAAyD,wCAAwC,QAAQ,OAAO,iDAAiD,OAAO,+CAA+C,kEAAkE,sCAAsC,YAAY,iCAAiC,YAAY,iDAAiD,YAAY,gCAAgC,8BAA8B,qBAAqB,wCAAwC,QAAQ,OAAO,mDAAmD,YAAY,8DAA8D,gCAAgC,OAAO,yJAAyJ,GAAG,0DAA0D,yCAAyC,gDAAgD,+CAA+C,sCAAsC,YAAY,iCAAiC,YAAY,mDAAmD,YAAY,iEAAiE,GAAG,oHAAoH,sEAAsE,iDAAiD,8CAA8C,uEAAuE,oEAAoE,QAAQ,OAAO,sDAAsD,WAAW,OAAO,iEAAiE,yJAAyJ,mCAAmC,oDAAoD,GAAG,wCAAwC,kEAAkE,sHAAsH,0DAA0D,QAAQ,OAAO,oCAAoC,gCAAgC,kCAAkC,4CAA4C,mFAAmF,0GAA0G,0CAA0C,iDAAiD,wKAAwK,wGAAwG,sCAAsC,mCAAmC,QAAQ,OAAO,6CAA6C,8DAA8D,kDAAkD,kCAAkC,+JAA+J,+KAA+K,+CAA+C,uBAAuB,mBAAmB,oCAAoC,sJAAsJ,yDAAyD,0FAA0F,6EAA6E,kHAAkH,0EAA0E,mEAAmE,kDAAkD,mBAAmB,0BAA0B,oHAAoH,oCAAoC,oKAAoK,kHAAkH,8BAA8B,0CAA0C,0GAA0G,gHAAgH,sCAAsC,mCAAmC,QAAQ,OAAO,6CAA6C,8DAA8D,kDAAkD,6EAA6E,kCAAkC,2JAA2J,uSAAuS,sCAAsC,kDAAkD,iLAAiL,wLAAwL,+CAA+C,6CAA6C,gEAAgE,kEAAkE,+DAA+D,QAAQ,OAAO,kDAAkD,oDAAoD,mCAAmC,0EAA0E,QAAQ,OAAO,iFAAiF,sEAAsE,uCAAuC,mCAAmC,+BAA+B,2BAA2B,uBAAuB,mBAAmB,oCAAoC,0GAA0G,qHAAqH,+FAA+F,wEAAwE,kEAAkE,YAAY,qDAAqD,YAAY,oEAAoE,YAAY,qDAAqD,6BAA6B,yDAAyD,uBAAuB,OAAO,yFAAyF,6DAA6D,8FAA8F,uBAAuB,6EAA6E,kHAAkH,8FAA8F,qIAAqI,0EAA0E,mEAAmE,kDAAkD,qBAAqB,0BAA0B,eAAe,qBAAqB,OAAO,wEAAwE,wDAAwD,QAAQ,OAAO,iDAAiD,mCAAmC,6DAA6D,+DAA+D,WAAW,OAAO,+CAA+C,qBAAqB,kDAAkD,mBAAmB,uCAAuC,kCAAkC,GAAG,sBAAsB,gFAAgF,mBAAmB,qGAAqG,kGAAkG,+FAA+F,wBAAwB,EAAE,EAAE,+FAA+F,0BAA0B,EAAE,EAAE,+FAA+F,iBAAiB,EAAE,EAAE,+FAA+F,8BAA8B,EAAE,EAAE,+FAA+F,+BAA+B,EAAE,EAAE,+FAA+F,mCAAmC,EAAE,EAAE,+FAA+F,yBAAyB,EAAE,EAAE,0HAA0H,kFAAkF,kGAAkG,sFAAsF,+JAA+J,yHAAyH,4DAA4D,yDAAyD,0BAA0B,2EAA2E,oBAAoB,OAAO,OAAO,uBAAuB,OAAO,IAAI,8EAA8E,qBAAqB,8BAA8B,uDAAuD,+EAA+E,6DAA6D,qCAAqC,+DAA+D,wEAAwE,oEAAoE,oEAAoE,qEAAqE,sEAAsE,wEAAwE,wEAAwE,uBAAuB,0CAA0C,0GAA0G,qFAAqF,OAAO,oFAAoF,OAAO,uBAAuB,+DAA+D,mHAAmH,4CAA4C,uBAAuB,4FAA4F,eAAe,2DAA2D,2CAA2C,gDAAgD,6EAA6E,2CAA2C,uEAAuE,gFAAgF,4EAA4E,4EAA4E,6EAA6E,8EAA8E,gFAAgF,gFAAgF,+BAA+B,gIAAgI,2FAA2F,OAAO,0FAA0F,OAAO,+BAA+B,uEAAuE,2HAA2H,oDAAoD,+BAA+B,iHAAiH,oGAAoG,uBAAuB,0CAA0C,WAAW,iCAAiC,4DAA4D,2DAA2D,2BAA2B,WAAW,uHAAuH,0CAA0C,2BAA2B,mEAAmE,uHAAuH,0CAA0C,2BAA2B,OAAO,yGAAyG,2BAA2B,yBAAyB,OAAO,qCAAqC,uBAAuB,qBAAqB,iBAAiB,GAAG,WAAW,kBAAkB,OAAO,yBAAyB,IAAI,sEAAsE,uEAAuE,yEAAyE,IAAI,yFAAyF,yDAAyD,mBAAmB,mDAAmD,uCAAuC,6DAA6D,uBAAuB,OAAO,iCAAiC,WAAW,iCAAiC,wBAAwB,oBAAoB,OAAO,OAAO,4BAA4B,6BAA6B,WAAW,OAAO,8BAA8B,uDAAuD,iCAAiC,sGAAsG,6EAA6E,OAAO,4EAA4E,OAAO,sFAAsF,OAAO,6DAA6D,qCAAqC,+DAA+D,wEAAwE,oEAAoE,oEAAoE,qEAAqE,sEAAsE,wEAAwE,wEAAwE,uBAAuB,4BAA4B,eAAe,qDAAqD,uFAAuF,eAAe,OAAO,oFAAoF,6GAA6G,mBAAmB,eAAe,wDAAwD,kEAAkE,uEAAuE,EAAE,wCAAwC,eAAe,OAAO,sGAAsG,+CAA+C,+DAA+D,mBAAmB,OAAO,qCAAqC,mBAAmB,eAAe,WAAW,yBAAyB,iFAAiF,yBAAyB,2DAA2D,eAAe,OAAO,iCAAiC,eAAe,WAAW,iFAAiF,2CAA2C,4BAA4B,oEAAoE,gGAAgG,mCAAmC,mEAAmE,uBAAuB,OAAO,yCAAyC,uBAAuB,mBAAmB,eAAe,sCAAsC,qDAAqD,sDAAsD,QAAQ,OAAO,8GAA8G,mBAAmB,oCAAoC,eAAe,6BAA6B,WAAW,uEAAuE,yCAAyC,oBAAoB,WAAW,gCAAgC,yBAAyB,2DAA2D,eAAe,OAAO,iCAAiC,eAAe,WAAW,gDAAgD,mCAAmC,6GAA6G,2CAA2C,mBAAmB,OAAO,iIAAiI,yHAAyH,uBAAuB,OAAO,yHAAyH,uBAAuB,gEAAgE,+CAA+C,uBAAuB,OAAO,4CAA4C,uBAAuB,mBAAmB,0BAA0B,4QAA4Q,2CAA2C,mBAAmB,OAAO,+GAA+G,6GAA6G,+EAA+E,+CAA+C,uBAAuB,OAAO,iDAAiD,4DAA4D,4DAA4D,4DAA4D,4DAA4D,qEAAqE,uEAAuE,oEAAoE,2BAA2B,uBAAuB,mBAAmB,0BAA0B,kHAAkH,2CAA2C,mBAAmB,OAAO,+GAA+G,6GAA6G,6GAA6G,yGAAyG,+CAA+C,uBAAuB,OAAO,mDAAmD,uBAAuB,mBAAmB,0BAA0B,6fAA6f,4DAA4D,2CAA2C,mBAAmB,OAAO,6CAA6C,yEAAyE,sEAAsE,sEAAsE,sEAAsE,uEAAuE,uEAAuE,uEAAuE,uEAAuE,sEAAsE,sEAAsE,yEAAyE,yEAAyE,wEAAwE,kFAAkF,kFAAkF,uBAAuB,mBAAmB,0BAA0B,oWAAoW,4DAA4D,2CAA2C,mBAAmB,OAAO,6CAA6C,yEAAyE,8EAA8E,gFAAgF,gFAAgF,wGAAwG,wBAAwB,EAAE,EAAE,8FAA8F,4EAA4E,yEAAyE,wBAAwB,mBAAmB,0BAA0B,4GAA4G,2CAA2C,mBAAmB,OAAO,uHAAuH,kEAAkE,QAAQ,OAAO,uHAAuH,+DAA+D,mDAAmD,oCAAoC,2BAA2B,wDAAwD,0EAA0E,2BAA2B,OAAO,0EAA0E,2BAA2B,uBAAuB,0CAA0C,mBAAmB,0BAA0B,oOAAoO,4CAA4C,0CAA0C,sDAAsD,sDAAsD,4DAA4D,iFAAiF,uBAAuB,yCAAyC,6CAA6C,qBAAqB,8DAA8D,yEAAyE,uCAAuC,gHAAgH,mBAAmB,OAAO,mEAAmE,mBAAmB,8CAA8C,8CAA8C,qDAAqD,2CAA2C,iDAAiD,sDAAsD,SAAS,OAAO,sCAAsC,+CAA+C,gCAAgC,uBAAuB,0DAA0D,oHAAoH,sEAAsE,oCAAoC,2BAA2B,OAAO,uEAAuE,yDAAyD,4DAA4D,+EAA+E,+BAA+B,mDAAmD,+GAA+G,mEAAmE,2IAA2I,6EAA6E,wCAAwC,yLAAyL,wCAAwC,8FAA8F,yEAAyE,QAAQ,OAAO,2JAA2J,mCAAmC,0CAA0C,+BAA+B,sCAAsC,2BAA2B,uBAAuB,8CAA8C,8CAA8C,mBAAmB,iDAAiD,mGAAmG,mBAAmB,oCAAoC,gEAAgE,wBAAwB,WAAW,gCAAgC,yBAAyB,2DAA2D,eAAe,OAAO,iCAAiC,eAAe,WAAW,oEAAoE,OAAO,mBAAmB,mDAAmD,OAAO,OAAO,yBAAyB,OAAO,IAAI,2FAA2F,wBAAwB,2EAA2E,iBAAiB,OAAO,6EAA6E,mHAAmH,yCAAyC,wDAAwD,2GAA2G,eAAe,gGAAgG,mDAAmD,eAAe,WAAW,OAAO,oFAAoF,uDAAuD,WAAW,OAAO,IAAI,iFAAiF,2EAA2E,2EAA2E,OAAO,yIAAyI,sCAAsC,OAAO,4DAA4D,IAAI,8EAA8E,+BAA+B,iBAAiB,OAAO,yCAAyC,wCAAwC,OAAO,2BAA2B,2BAA2B,yKAAyK,gBAAgB,wLAAwL,gBAAgB,mIAAmI,gBAAgB,gJAAgJ,gBAAgB,8IAA8I,gBAAgB,4FAA4F,gBAAgB,0DAA0D,gBAAgB,OAAO,qCAAqC,kEAAkE,sBAAsB,OAAO,IAAI,sFAAsF,gBAAgB,2GAA2G,gEAAgE,mDAAmD,OAAO,6DAA6D,uJAAuJ,oEAAoE,uDAAuD,WAAW,OAAO,iDAAiD,gUAAgU,2BAA2B,WAAW,yHAAyH,+FAA+F,kDAAkD,2DAA2D,wDAAwD,uBAAuB,ieAAie,gFAAgF,mEAAmE,uBAAuB,mBAAmB,4BAA4B,iEAAiE,+IAA+I,oFAAoF,uEAAuE,2BAA2B,uBAAuB,mBAAmB,6CAA6C,iFAAiF,gFAAgF,mEAAmE,uBAAuB,mBAAmB,iBAAiB,OAAO,wEAAwE,2DAA2D,eAAe,WAAW,+FAA+F,yDAAyD,6DAA6D,+BAA+B,QAAQ,OAAO,+CAA+C,qVAAqV,uFAAuF,mEAAmE,uBAAuB,OAAO,2IAA2I,oGAAoG,6FAA6F,2EAA2E,+BAA+B,OAAO,2FAA2F,+BAA+B,2BAA2B,uBAAuB,mBAAmB,iBAAiB,OAAO,wEAAwE,2DAA2D,eAAe,WAAW,kEAAkE,gEAAgE,6EAA6E,2DAA2D,eAAe,OAAO,gDAAgD,QAAQ,OAAO,oFAAoF,qFAAqF,mEAAmE,uBAAuB,mBAAmB,eAAe,6BAA6B,WAAW,6DAA6D,4IAA4I,mEAAmE,8EAA8E,wDAAwD,qFAAqF,mEAAmE,uBAAuB,0EAA0E,wFAAwF,mEAAmE,uBAAuB,8BAA8B,mBAAmB,2CAA2C,QAAQ,OAAO,wDAAwD,qFAAqF,mEAAmE,uBAAuB,mBAAmB,sFAAsF,mCAAmC,mBAAmB,iCAAiC,eAAe,OAAO,wEAAwE,2DAA2D,eAAe,WAAW,yBAAyB,gGAAgG,6BAA6B,sEAAsE,8FAA8F,2DAA2D,eAAe,WAAW,4CAA4C,6BAA6B,sEAAsE,8FAA8F,2DAA2D,eAAe,WAAW,4CAA4C,6BAA6B,6HAA6H,8FAA8F,2DAA2D,eAAe,WAAW,gGAAgG,6BAA6B,yTAAyT,8FAA8F,2DAA2D,eAAe,WAAW,sEAAsE,6BAA6B,gGAAgG,8FAA8F,2DAA2D,eAAe,WAAW,yBAAyB,mEAAmE,oEAAoE,uDAAuD,WAAW,yBAAyB,8CAA8C,OAAO,IAAI,sEAAsE,qBAAqB,oFAAoF,kFAAkF,kFAAkF,uFAAuF,qFAAqF,oHAAoH,oFAAoF,+FAA+F,oFAAoF,gIAAgI,mGAAmG,wFAAwF,qFAAqF,gGAAgG,gGAAgG,qHAAqH,gIAAgI,qHAAqH,yHAAyH,kFAAkF,gFAAgF,+GAA+G,+EAA+E,4FAA4F,sFAAsF,2HAA2H,mHAAmH,2HAA2H,mFAAmF,2HAA2H,8FAA8F,oFAAoF,yFAAyF,iIAAiI,uFAAuF,+FAA+F,+FAA+F,oFAAoF,oHAAoH,oFAAoF,oHAAoH,oHAAoH,4HAA4H,oFAAoF,oFAAoF,4HAA4H,oHAAoH,qFAAqF,0FAA0F,kIAAkI,qFAAqF,6FAA6F,8HAA8H,yGAAyG,0FAA0F,kFAAkF,mFAAmF,kFAAkF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,uFAAuF,qHAAqH,kHAAkH,kHAAkH,oFAAoF,gFAAgF,gGAAgG,8EAA8E,uFAAuF,SAAS,qBAAqB,sBAAsB,wDAAwD,mBAAmB,yCAAyC,2CAA2C,2CAA2C,2CAA2C,8CAA8C,4CAA4C,wCAAwC,+CAA+C,wDAAwD,8CAA8C,gDAAgD,qDAAqD,gDAAgD,qDAAqD,0DAA0D,oDAAoD,4DAA4D,gDAAgD,0CAA0C,0CAA0C,0CAA0C,8CAA8C,0CAA0C,wCAAwC,oCAAoC,0CAA0C,oDAAoD,0CAA0C,uCAAuC,oCAAoC,wCAAwC,kDAAkD,4DAA4D,oDAAoD,4CAA4C,iDAAiD,kDAAkD,+CAA+C,oDAAoD,yDAAyD,mDAAmD,2DAA2D,+CAA+C,0CAA0C,gDAAgD,yCAAyC,yCAAyC,6CAA6C,uDAAuD,gDAAgD,iEAAiE,2CAA2C,4CAA4C,kDAAkD,mDAAmD,mDAAmD,sDAAsD,wCAAwC,4CAA4C,gDAAgD,wCAAwC,2CAA2C,wCAAwC,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,8CAA8C,4CAA4C,4CAA4C,4CAA4C,4CAA4C,4CAA4C,yCAAyC,0CAA0C,sCAAsC,OAAO,IAAI,mGAAmG,wBAAwB,gDAAgD,uBAAuB,OAAO,0BAA0B,uBAAuB,OAAO,2BAA2B,2DAA2D,QAAQ,OAAO,iHAAiH,8BAA8B,+BAA+B,eAAe,WAAW,mCAAmC,qFAAqF,QAAQ,OAAO,0GAA0G,6BAA6B,8BAA8B,eAAe,WAAW,oCAAoC,sFAAsF,QAAQ,OAAO,0GAA0G,6BAA6B,+BAA+B,eAAe,WAAW,mCAAmC,gEAAgE,QAAQ,0BAA0B,gCAAgC,4BAA4B,OAAO,OAAO,2EAA2E,qFAAqF,qCAAqC,OAAO,2BAA2B,sIAAsI,+CAA+C,2BAA2B,WAAW,uCAAuC,uFAAuF,WAAW,kBAAkB,OAAO,2BAA2B,0CAA0C,0CAA0C,0CAA0C,0CAA0C,wCAAwC,wCAAwC,iEAAiE,wDAAwD,8EAA8E,QAAQ,OAAO,uCAAuC,8BAA8B,eAAe,WAAW,wBAAwB,+EAA+E,QAAQ,OAAO,uCAAuC,+BAA+B,eAAe,WAAW,uBAAuB,OAAO,iCAAiC,OAAO,qCAAqC,4BAA4B,sCAAsC,4EAA4E,2CAA2C,6JAA6J,qGAAqG,WAAW,0CAA0C,2BAA2B,kCAAkC,mBAAmB,eAAe,OAAO,8BAA8B,eAAe,sBAAsB,OAAO,qBAAqB,GAAG,yCAAyC,8CAA8C,wBAAwB,OAAO,uDAAuD,2BAA2B,gHAAgH,QAAQ,OAAO,sDAAsD,WAAW,0BAA0B,OAAO,8BAA8B,2CAA2C,2BAA2B,8HAA8H,+CAA+C,gBAAgB,8EAA8E,QAAQ,OAAO,sCAAsC,WAAW,UAAU,sBAAsB,GAAG,2EAA2E,oBAAoB,aAAa,iHAAiH,6EAA6E,+BAA+B,oFAAoF,qCAAqC,8EAA8E,0GAA0G,yIAAyI,2BAA2B,OAAO,8FAA8F,mJAAmJ,2BAA2B,gCAAgC,8GAA8G,gEAAgE,kEAAkE,+BAA+B,wEAAwE,2IAA2I,6BAA6B,OAAO,8FAA8F,mJAAmJ,2BAA2B,gCAAgC,mBAAmB,eAAe,WAAW,iFAAiF,6DAA6D,oDAAoD,QAAQ,OAAO,+CAA+C,wCAAwC,mHAAmH,uCAAuC,uBAAuB,OAAO,iGAAiG,oGAAoG,+CAA+C,+BAA+B,OAAO,2FAA2F,+BAA+B,2BAA2B,mIAAmI,2CAA2C,2BAA2B,uBAAuB,oCAAoC,qFAAqF,uBAAuB,mBAAmB,iBAAiB,OAAO,wEAAwE,2DAA2D,eAAe,WAAW,SAAS,qBAAqB,IAAI,8DAA8D,cAAc,qCAAqC,mCAAmC,4EAA4E,4EAA4E,+EAA+E,+CAA+C,oCAAoC,6BAA6B,8CAA8C,wBAAwB,wCAAwC,WAAW,sCAAsC,0CAA0C,0CAA0C,gDAAgD,eAAe,OAAO,0DAA0D,eAAe,WAAW,OAAO,4CAA4C,WAAW,oDAAoD,OAAO,yCAAyC,8DAA8D,EAAE,+DAA+D,8BAA8B,gCAAgC,+BAA+B,OAAO,yEAAyE,6CAA6C,gCAAgC,4CAA4C,sBAAsB,YAAY,WAAW,oCAAoC,wCAAwC,8CAA8C,eAAe,WAAW,OAAO,0CAA0C,WAAW,gDAAgD,OAAO,uCAAuC,wDAAwD,EAAE,sDAAsD,qBAAqB,QAAQ,0DAA0D,iEAAiE,mDAAmD,oGAAoG,OAAO,IAAI,mBAAmB,gFAAgF,mBAAmB,qGAAqG,kGAAkG,+FAA+F,4BAA4B,EAAE,EAAE,+FAA+F,sBAAsB,EAAE,EAAE,+FAA+F,sBAAsB,EAAE,EAAE,0IAA0I,sBAAsB,EAAE,EAAE,+FAA+F,mCAAmC,EAAE,EAAE,+FAA+F,gBAAgB,EAAE,EAAE,0IAA0I,gBAAgB,EAAE,EAAE,+FAA+F,mBAAmB,EAAE,EAAE,+FAA+F,6BAA6B,EAAE,EAAE,+FAA+F,iBAAiB,EAAE,EAAE,+FAA+F,wBAAwB,EAAE,EAAE,+FAA+F,iBAAiB,EAAE,EAAE,+FAA+F,cAAc,EAAE,EAAE,+FAA+F,sBAAsB,EAAE,EAAE,8dAA8d,wCAAwC,kDAAkD,iBAAiB,gDAAgD,qDAAqD,IAAI,0CAA0C,iCAAiC,8BAA8B,gEAAgE,OAAO,iCAAiC,IAAI,sLAAsL,qCAAqC,uCAAuC,sBAAsB,2BAA2B,uDAAuD,gCAAgC,OAAO,OAAO,iCAAiC,OAAO,0CAA0C,qCAAqC,iCAAiC,uCAAuC,eAAe,0BAA0B,yCAAyC,OAAO,kBAAkB,6BAA6B,6BAA6B,6BAA6B,sCAAsC,yCAAyC,6BAA6B,8DAA8D,8DAA8D,iCAAiC,WAAW,OAAO,OAAO,2BAA2B,oEAAoE,oEAAoE,iCAAiC,WAAW,OAAO,gDAAgD,gDAAgD,6BAA6B,2CAA2C,6CAA6C,mBAAmB,oEAAoE,eAAe,6CAA6C,2CAA2C,mCAAmC,kEAAkE,+EAA+E,wEAAwE,0EAA0E,gDAAgD,6DAA6D,gDAAgD,6DAA6D,+BAA+B,kBAAkB,OAAO,gGAAgG,oGAAoG,4EAA4E,0DAA0D,0DAA0D,sEAAsE,sEAAsE,sEAAsE,qDAAqD,mDAAmD,mDAAmD,yFAAyF,wDAAwD,wDAAwD,6CAA6C,oDAAoD,kEAAkE,iDAAiD,iDAAiD,0DAA0D,wDAAwD,wDAAwD,6CAA6C,sDAAsD,kEAAkE,iDAAiD,iDAAiD,0DAA0D,wDAAwD,yDAAyD,8CAA8C,sDAAsD,kEAAkE,kDAAkD,kDAAkD,6FAA6F,yDAAyD,yDAAyD,8CAA8C,uDAAuD,mEAAmE,kDAAkD,kDAAkD,2DAA2D,yDAAyD,yDAAyD,8CAA8C,uDAAuD,mEAAmE,kDAAkD,kDAAkD,2DAA2D,yDAAyD,yDAAyD,8CAA8C,uDAAuD,mEAAmE,kDAAkD,kDAAkD,gCAAgC,+BAA+B,eAAe,sEAAsE,oEAAoE,iCAAiC,WAAW,OAAO,iDAAiD,IAAI,mDAAmD,sCAAsC,IAAI,iJAAiJ,+BAA+B,wCAAwC,6EAA6E,0BAA0B,0BAA0B,2CAA2C,QAAQ,OAAO,gCAAgC,sCAAsC,uBAAuB,qDAAqD,+KAA+K,8EAA8E,+DAA+D,8BAA8B,+BAA+B,WAAW,OAAO,qBAAqB,IAAI,uKAAuK,+BAA+B,+BAA+B,OAAO,2BAA2B,sDAAsD,sCAAsC,mCAAmC,uBAAuB,6EAA6E,0BAA0B,0BAA0B,2CAA2C,QAAQ,OAAO,sDAAsD,6BAA6B,wDAAwD,4CAA4C,sCAAsC,uBAAuB,WAAW,4BAA4B,8BAA8B,WAAW,8CAA8C,sCAAsC,uBAAuB,qDAAqD,8BAA8B,0CAA0C,uBAAuB,kDAAkD,eAAe,uEAAuE,yEAAyE,sNAAsN,mCAAmC,8MAA8M,8BAA8B,+BAA+B,kCAAkC,sBAAsB,WAAW,OAAO,qBAAqB,IAAI,uJAAuJ,4EAA4E,6CAA6C,iDAAiD,sBAAsB,oBAAoB,OAAO,sCAAsC,iBAAiB,OAAO,iGAAiG,6JAA6J,IAAI,gDAAgD,oDAAoD,IAAI,6DAA6D,iDAAiD,mCAAmC,gDAAgD,IAAI,2EAA2E,gBAAgB,6EAA6E,0BAA0B,0BAA0B,2CAA2C,QAAQ,OAAO,gCAAgC,sCAAsC,uBAAuB,+DAA+D,0CAA0C,yBAAyB,oCAAoC,0CAA0C,mBAAmB,OAAO,4CAA4C,mBAAmB,eAAe,WAAW,OAAO,iBAAiB,IAAI,kFAAkF,gBAAgB,6EAA6E,0BAA0B,0BAA0B,yBAAyB,2CAA2C,QAAQ,OAAO,gCAAgC,8BAA8B,qBAAqB,uEAAuE,uBAAuB,WAAW,6BAA6B,kCAAkC,WAAW,wCAAwC,uBAAuB,+DAA+D,0CAA0C,yBAAyB,oCAAoC,0CAA0C,mBAAmB,OAAO,4CAA4C,mBAAmB,eAAe,WAAW,OAAO,kBAAkB,IAAI,4CAA4C,gBAAgB,6CAA6C,QAAQ,OAAO,6BAA6B,+BAA+B,kEAAkE,iCAAiC,OAAO,iBAAiB,IAAI,oEAAoE,gBAAgB,uBAAuB,wBAAwB,6CAA6C,QAAQ,OAAO,yBAAyB,+BAA+B,8DAA8D,qCAAqC,sCAAsC,mDAAmD,oIAAoI,mCAAmC,gCAAgC,WAAW,oBAAoB,OAAO,yBAAyB,IAAI,8FAA8F,gBAAgB,uBAAuB,wBAAwB,4BAA4B,4BAA4B,iFAAiF,oCAAoC,oCAAoC,6CAA6C,QAAQ,OAAO,yBAAyB,+BAA+B,8DAA8D,iCAAiC,gCAAgC,iCAAiC,mCAAmC,mCAAmC,mCAAmC,WAAW,8BAA8B,qCAAqC,8BAA8B,mCAAmC,6CAA6C,6CAA6C,4BAA4B,eAAe,OAAO,qDAAqD,eAAe,WAAW,OAAO,uBAAuB,IAAI,yEAAyE,gCAAgC,uBAAuB,OAAO,6EAA6E,0BAA0B,4BAA4B,sCAAsC,uBAAuB,OAAO,oBAAoB,IAAI,oCAAoC,sCAAsC,QAAQ,OAAO,oCAAoC,sKAAsK,0BAA0B,WAAW,OAAO,qBAAqB,IAAI,iCAAiC,sCAAsC,QAAQ,OAAO,oCAAoC,k7BAAk7B,qCAAqC,WAAW,OAAO,oBAAoB,IAAI,sCAAsC,wBAAwB,wCAAwC,QAAQ,OAAO,iDAAiD,OAAO,wBAAwB,IAAI,6CAA6C,wBAAwB,wCAAwC,QAAQ,OAAO,oDAAoD,OAAO,wBAAwB,IAAI,iDAAiD,gDAAgD,IAAI,uBAAuB,gFAAgF,mBAAmB,qGAAqG,mGAAmG,kGAAkG,qGAAqG,+FAA+F,8BAA8B,EAAE,EAAE,6IAA6I,kCAAkC,EAAE,EAAE,qTAAqT,kOAAkO,0fAA0f,0MAA0M,qGAAqG,wEAAwE,gCAAgC,iBAAiB,OAAO,4DAA4D,uEAAuE,kFAAkF,kCAAkC,iBAAiB,OAAO,sFAAsF,oFAAoF,kFAAkF,oFAAoF,oFAAoF,sFAAsF,4FAA4F,kFAAkF,kFAAkF,wFAAwF,6FAA6F,oFAAoF,iGAAiG,uGAAuG,6FAA6F,kDAAkD,qDAAqD,yCAAyC,+DAA+D,OAAO,8CAA8C,4BAA4B,2BAA2B,0FAA0F,OAAO,OAAO,mFAAmF,eAAe,gFAAgF,yBAAyB,gCAAgC,iCAAiC,8BAA8B,8BAA8B,kEAAkE,2BAA2B,iBAAiB,OAAO,oEAAoE,uCAAuC,4BAA4B,WAAW,qDAAqD,yCAAyC,OAAO,4BAA4B,oBAAoB,mBAAmB,QAAQ,yCAAyC,8CAA8C,WAAW,OAAO,+BAA+B,iBAAiB,OAAO,uBAAuB,0BAA0B,OAAO,mHAAmH,oHAAoH,uGAAuG,0BAA0B,2HAA2H,OAAO,4DAA4D,sCAAsC,kEAAkE,yGAAyG,OAAO,6BAA6B,8BAA8B,4CAA4C,oCAAoC,oCAAoC,gCAAgC,gCAAgC,0CAA0C,4CAA4C,oBAAoB,mBAAmB,QAAQ,+DAA+D,uBAAuB,WAAW,2CAA2C,4BAA4B,6DAA6D,8DAA8D,iDAAiD,mDAAmD,EAAE,WAAW,8BAA8B,kCAAkC,kCAAkC,yDAAyD,WAAW,yCAAyC,yFAAyF,WAAW,qCAAqC,gCAAgC,0BAA0B,mCAAmC,kCAAkC,oEAAoE,QAAQ,OAAO,iCAAiC,mCAAmC,qEAAqE,0CAA0C,iEAAiE,mBAAmB,iDAAiD,iGAAiG,mBAAmB,qBAAqB,OAAO,iCAAiC,mCAAmC,0CAA0C,iEAAiE,iEAAiE,mBAAmB,iDAAiD,iGAAiG,iGAAiG,mBAAmB,eAAe,sCAAsC,gDAAgD,yDAAyD,yDAAyD,yDAAyD,8FAA8F,yDAAyD,yDAAyD,gCAAgC,eAAe,iEAAiE,0GAA0G,gHAAgH,wHAAwH,qCAAqC,2DAA2D,sDAAsD,kCAAkC,mCAAmC,uEAAuE,2CAA2C,qCAAqC,sCAAsC,uBAAuB,4CAA4C,oCAAoC,uBAAuB,uGAAuG,mBAAmB,OAAO,oGAAoG,4GAA4G,qCAAqC,mEAAmE,iDAAiD,qCAAqC,uDAAuD,uBAAuB,4CAA4C,qDAAqD,uBAAuB,mBAAmB,8GAA8G,uDAAuD,uDAAuD,6DAA6D,uDAAuD,uDAAuD,6DAA6D,uDAAuD,uDAAuD,4FAA4F,wDAAwD,wDAAwD,8DAA8D,wDAAwD,wDAAwD,8DAA8D,wDAAwD,wDAAwD,oCAAoC,iBAAiB,OAAO,mGAAmG,uCAAuC,mLAAmL,8CAA8C,qDAAqD,+FAA+F,uBAAuB,wHAAwH,wHAAwH,oIAAoI,yCAAyC,mEAAmE,0DAA0D,sCAAsC,uCAAuC,yCAAyC,0CAA0C,2BAA2B,gDAAgD,wCAAwC,2BAA2B,+EAA+E,+CAA+C,iHAAiH,iDAAiD,uBAAuB,OAAO,4GAA4G,wHAAwH,yCAAyC,2EAA2E,iDAAiD,yCAAyC,2DAA2D,2BAA2B,gDAAgD,yDAAyD,2BAA2B,uBAAuB,uFAAuF,oDAAoD,oDAAoD,uDAAuD,kDAAkD,oDAAoD,oDAAoD,yDAAyD,0DAA0D,oDAAoD,oDAAoD,wDAAwD,qDAAqD,qDAAqD,qDAAqD,yDAAyD,0DAA0D,oDAAoD,qDAAqD,yDAAyD,oDAAoD,oDAAoD,qDAAqD,0DAA0D,8FAA8F,qDAAqD,qDAAqD,yDAAyD,sDAAsD,sDAAsD,sDAAsD,0DAA0D,2DAA2D,qDAAqD,qDAAqD,0DAA0D,sDAAsD,sDAAsD,sDAAsD,0DAA0D,2DAA2D,qDAAqD,qDAAqD,yDAAyD,qDAAqD,qDAAqD,qDAAqD,0DAA0D,wCAAwC,mCAAmC,yCAAyC,OAAO,sGAAsG,4GAA4G,qCAAqC,2FAA2F,oDAAoD,oDAAoD,uDAAuD,mDAAmD,qDAAqD,qDAAqD,yDAAyD,0DAA0D,oDAAoD,oDAAoD,wDAAwD,qDAAqD,qDAAqD,qDAAqD,0DAA0D,0DAA0D,oDAAoD,qDAAqD,0DAA0D,qDAAqD,qDAAqD,sDAAsD,0DAA0D,8FAA8F,qDAAqD,qDAAqD,wDAAwD,sDAAsD,sDAAsD,sDAAsD,0DAA0D,2DAA2D,qDAAqD,qDAAqD,0DAA0D,sDAAsD,sDAAsD,sDAAsD,0DAA0D,2DAA2D,qDAAqD,qDAAqD,yDAAyD,sDAAsD,sDAAsD,sDAAsD,2DAA2D,wCAAwC,mCAAmC,mBAAmB,eAAe,yCAAyC,sBAAsB,6BAA6B,wCAAwC,oEAAoE,QAAQ,OAAO,sCAAsC,6DAA6D,eAAe,6CAA6C,6FAA6F,eAAe,uCAAuC,iCAAiC,iCAAiC,6CAA6C,qCAAqC,2CAA2C,+BAA+B,qCAAqC,0CAA0C,mFAAmF,iEAAiE,iEAAiE,iEAAiE,sHAAsH,iEAAiE,iEAAiE,wCAAwC,uBAAuB,kDAAkD,8DAA8D,8CAA8C,wEAAwE,2BAA2B,OAAO,8EAA8E,2BAA2B,wCAAwC,+EAA+E,2BAA2B,OAAO,kEAAkE,2BAA2B,yCAAyC,iHAAiH,4DAA4D,4DAA4D,gFAAgF,gFAAgF,gFAAgF,sFAAsF,oFAAoF,oFAAoF,yGAAyG,8DAA8D,8DAA8D,oFAAoF,kFAAkF,kFAAkF,wFAAwF,sFAAsF,sFAAsF,2BAA2B,0BAA0B,gHAAgH,4DAA4D,4DAA4D,mFAAmF,iFAAiF,iFAAiF,oFAAoF,kFAAkF,kFAAkF,yGAAyG,8DAA8D,8DAA8D,qFAAqF,mFAAmF,mFAAmF,sFAAsF,oFAAoF,oFAAoF,2BAA2B,OAAO,qGAAqG,4DAA4D,4DAA4D,gFAAgF,gFAAgF,gFAAgF,sFAAsF,oFAAoF,oFAAoF,yGAAyG,8DAA8D,8DAA8D,oFAAoF,kFAAkF,kFAAkF,wFAAwF,sFAAsF,sFAAsF,2BAA2B,wCAAwC,yBAAyB,OAAO,8CAA8C,4EAA4E,2BAA2B,OAAO,mFAAmF,2BAA2B,8CAA8C,wEAAwE,2BAA2B,OAAO,kFAAkF,2BAA2B,wCAAwC,mFAAmF,2BAA2B,OAAO,kEAAkE,2BAA2B,+FAA+F,wDAAwD,wDAAwD,2DAA2D,0DAA0D,wDAAwD,wDAAwD,2DAA2D,0DAA0D,wDAAwD,yDAAyD,4DAA4D,kGAAkG,2DAA2D,2DAA2D,8DAA8D,6DAA6D,2DAA2D,2DAA2D,+DAA+D,6DAA6D,2DAA2D,4DAA4D,gEAAgE,yCAAyC,gHAAgH,yDAAyD,yDAAyD,kEAAkE,6FAA6F,iFAAiF,iFAAiF,iEAAiE,gFAAgF,kEAAkE,mEAAmE,mEAAmE,0GAA0G,4DAA4D,4DAA4D,qEAAqE,qFAAqF,qFAAqF,qFAAqF,oEAAoE,mFAAmF,qEAAqE,sEAAsE,sEAAsE,2BAA2B,0BAA0B,+GAA+G,yDAAyD,yDAAyD,kEAAkE,8FAA8F,kFAAkF,kFAAkF,iEAAiE,6EAA6E,+DAA+D,gEAAgE,mEAAmE,0GAA0G,4DAA4D,4DAA4D,qEAAqE,sFAAsF,sFAAsF,sFAAsF,oEAAoE,gFAAgF,kEAAkE,mEAAmE,sEAAsE,2BAA2B,OAAO,uDAAuD,yDAAyD,yDAAyD,kEAAkE,6FAA6F,iFAAiF,iFAAiF,iEAAiE,8FAA8F,kFAAkF,mFAAmF,kEAAkE,uGAAuG,4DAA4D,4DAA4D,qEAAqE,qFAAqF,qFAAqF,qFAAqF,oEAAoE,kGAAkG,sFAAsF,uFAAuF,qEAAqE,2BAA2B,wCAAwC,uCAAuC,yBAAyB,qBAAqB,OAAO,uEAAuE,uCAAuC,iBAAiB,OAAO,yDAAyD,uEAAuE,mEAAmE,qEAAqE,qEAAqE,0CAA0C,2BAA2B,qFAAqF,uGAAuG,wDAAwD,wDAAwD,2DAA2D,mDAAmD,qDAAqD,qDAAqD,qDAAqD,kEAAkE,wDAAwD,wDAAwD,2DAA2D,kFAAkF,kFAAkF,iFAAiF,qDAAqD,kEAAkE,wDAAwD,yDAAyD,4DAA4D,oFAAoF,oFAAoF,oFAAoF,sDAAsD,gDAAgD,uCAAuC,uBAAuB,mBAAmB,eAAe,oCAAoC,gEAAgE,yCAAyC,mDAAmD,eAAe,uCAAuC,+BAA+B,uCAAuC,yEAAyE,mBAAmB,OAAO,uCAAuC,mBAAmB,eAAe,WAAW,wCAAwC,OAAO,8BAA8B,mCAAmC,mCAAmC,mCAAmC,OAAO,4CAA4C,0CAA0C,0CAA0C,iFAAiF,mBAAmB,kHAAkH,+BAA+B,8XAA8X,8LAA8L,+BAA+B,+DAA+D,WAAW,OAAO,2CAA2C,WAAW,mCAAmC,6CAA6C,sIAAsI,kEAAkE,eAAe,WAAW,4CAA4C,kLAAkL,EAAE,yFAAyF,8BAA8B,0CAA0C,WAAW,mFAAmF,OAAO,wBAAwB,iDAAiD,QAAQ,OAAO,qJAAqJ,WAAW,OAAO,MAAM,yIAAyI,yFAAyF,2FAA2F,6FAA6F,2FAA2F,uFAAuF,6FAA6F,oGAAoG,2FAA2F,2CAA2C,iBAAiB,OAAO,iGAAiG,4FAA4F,uFAAuF,sCAAsC,oDAAoD,sDAAsD,qCAAqC,yEAAyE,uGAAuG,uGAAuG,+DAA+D,4FAA4F,yCAAyC,8DAA8D,eAAe,WAAW,OAAO,4CAA4C,iBAAiB,OAAO,sFAAsF,oFAAoF,kFAAkF,oFAAoF,oFAAoF,sFAAsF,4FAA4F,uEAAuE,sDAAsD,yDAAyD,sBAAsB,2EAA2E,sKAAsK,mKAAmK,qBAAqB,iBAAiB,OAAO,sCAAsC,+CAA+C,yCAAyC,QAAQ,OAAO,6BAA6B,OAAO,iCAAiC,wCAAwC,oCAAoC,2BAA2B,uCAAuC,4DAA4D,+DAA+D,gDAAgD,mCAAmC,eAAe,WAAW,0CAA0C,OAAO,wCAAwC,wNAAwN,EAAE,qCAAqC,gfAAgf,8DAA8D,8CAA8C,IAAI,0DAA0D,wEAAwE,gCAAgC,iBAAiB,OAAO,8EAA8E,0BAA0B,wDAAwD,mBAAmB,kBAAkB,OAAO,yCAAyC,0CAA0C,6CAA6C,WAAW,OAAO,+DAA+D,gDAAgD,gCAAgC,gCAAgC,4CAA4C,mCAAmC,uBAAuB,kBAAkB,OAAO,6DAA6D,uBAAuB,WAAW,0CAA0C,6BAA6B,kCAAkC,wEAAwE,QAAQ,OAAO,oCAAoC,6DAA6D,eAAe,+CAA+C,6FAA6F,eAAe,8CAA8C,8CAA8C,8CAA8C,yBAAyB,oCAAoC,wBAAwB,eAAe,iCAAiC,mCAAmC,qEAAqE,eAAe,OAAO,mCAAmC,eAAe,cAAc,OAAO,mCAAmC,qCAAqC,iCAAiC,oEAAoE,IAAI,qBAAqB,gFAAgF,mBAAmB,qGAAqG,mGAAmG,kGAAkG,qGAAqG,+FAA+F,8BAA8B,EAAE,EAAE,+FAA+F,kCAAkC,EAAE,EAAE,+FAA+F,qCAAqC,EAAE,EAAE,2MAA2M,6NAA6N,+0BAA+0B,gHAAgH,qGAAqG,4BAA4B,kCAAkC,2DAA2D,6FAA6F,2DAA2D,OAAO,OAAO,+DAA+D,gFAAgF,gEAAgE,WAAW,OAAO,2CAA2C,iBAAiB,OAAO,wQAAwQ,6EAA6E,oFAAoF,oFAAoF,kFAAkF,oFAAoF,oFAAoF,wFAAwF,4FAA4F,2EAA2E,kFAAkF,oFAAoF,4FAA4F,4EAA4E,yGAAyG,6CAA6C,QAAQ,OAAO,mCAAmC,2DAA2D,2CAA2C,WAAW,OAAO,yEAAyE,iBAAiB,gFAAgF,iCAAiC,gEAAgE,qEAAqE,oCAAoC,o+BAAo+B,sCAAsC,uEAAuE,wEAAwE,0EAA0E,eAAe,OAAO,+DAA+D,eAAe,aAAa,OAAO,2BAA2B,WAAW,OAAO,2EAA2E,kBAAkB,iFAAiF,sFAAsF,iFAAiF,iFAAiF,sFAAsF,0CAA0C,qDAAqD,4CAA4C,wEAAwE,iGAAiG,4FAA4F,+DAA+D,mFAAmF,mCAAmC,kEAAkE,mBAAmB,eAAe,WAAW,8DAA8D,8EAA8E,mFAAmF,yDAAyD,+BAA+B,kGAAkG,mEAAmE,eAAe,iCAAiC,ggEAAggE,sCAAsC,4DAA4D,+CAA+C,iDAAiD,eAAe,aAAa,OAAO,4BAA4B,WAAW,OAAO,sBAAsB,qBAAqB,mCAAmC,4CAA4C,oCAAoC,gCAAgC,gCAAgC,0CAA0C,qCAAqC,sEAAsE,oBAAoB,gCAAgC,gEAAgE,8DAA8D,uBAAuB,iBAAiB,OAAO,oEAAoE,4BAA4B,WAAW,iDAAiD,yDAAyD,mDAAmD,4EAA4E,kDAAkD,2EAA2E,WAAW,OAAO,mDAAmD,4EAA4E,WAAW,OAAO,6CAA6C,QAAQ,OAAO,mCAAmC,qEAAqE,4BAA4B,sCAAsC,iFAAiF,QAAQ,OAAO,8CAA8C,iEAAiE,mBAAmB,qDAAqD,iGAAiG,mBAAmB,+CAA+C,qCAAqC,qCAAqC,+BAA+B,4DAA4D,oCAAoC,mBAAmB,oCAAoC,8DAA8D,qCAAqC,mBAAmB,gCAAgC,+CAA+C,iBAAiB,OAAO,qDAAqD,+GAA+G,4DAA4D,4DAA4D,yGAAyG,+FAA+F,4DAA4D,2GAA2G,iGAAiG,4DAA4D,2CAA2C,qCAAqC,OAAO,+GAA+G,4DAA4D,4DAA4D,wDAAwD,uDAAuD,yDAAyD,yDAAyD,yDAAyD,sEAAsE,4DAA4D,4DAA4D,wDAAwD,wFAAwF,wFAAwF,yDAAyD,yDAAyD,sEAAsE,4DAA4D,6DAA6D,yDAAyD,0FAA0F,0FAA0F,0DAA0D,0DAA0D,oDAAoD,2CAA2C,2BAA2B,uBAAuB,mBAAmB,+CAA+C,oCAAoC,+CAA+C,6EAA6E,uBAAuB,OAAO,2CAA2C,uBAAuB,mBAAmB,eAAe,WAAW,OAAO,mCAAmC,mCAAmC,mCAAmC,mCAAmC,OAAO,gCAAgC,iBAAiB,8BAA8B,iBAAiB,8BAA8B,iBAAiB,2EAA2E,+BAA+B,mCAAmC,sDAAsD,uDAAuD,oCAAoC,OAAO,oBAAoB,0BAA0B,0CAA0C,+cAA+c,sEAAsE,6BAA6B,WAAW,OAAO,0CAA0C,mbAAmb,sEAAsE,2CAA2C,WAAW,OAAO,mBAAmB,uCAAuC,sDAAsD,qCAAqC,oDAAoD,wDAAwD,wDAAwD,uDAAuD,yDAAyD,YAAY,yDAAyD,OAAO,mBAAmB,8DAA8D,eAAe,sJAAsJ,WAAW,6IAA6I,2EAA2E,6nBAA6nB,uHAAuH,6KAA6K,WAAW,OAAO,oBAAoB,qCAAqC,sDAAsD,sCAAsC,qDAAqD,wDAAwD,yDAAyD,wDAAwD,yDAAyD,YAAY,yDAAyD,OAAO,mBAAmB,+DAA+D,eAAe,0JAA0J,WAAW,iJAAiJ,2EAA2E,q2BAAq2B,oDAAoD,kLAAkL,WAAW,OAAO,MAAM,4GAA4G,4BAA4B,kCAAkC,2DAA2D,6FAA6F,2DAA2D,OAAO,OAAO,+DAA+D,gFAAgF,gEAAgE,WAAW,OAAO,2CAA2C,iBAAiB,OAAO,wQAAwQ,6EAA6E,mFAAmF,2CAA2C,6CAA6C,QAAQ,OAAO,mCAAmC,2DAA2D,2CAA2C,WAAW,OAAO,6BAA6B,4CAA4C,oCAAoC,gCAAgC,gCAAgC,0CAA0C,gBAAgB,6CAA6C,QAAQ,OAAO,mCAAmC,qEAAqE,4BAA4B,sCAAsC,iFAAiF,QAAQ,OAAO,8CAA8C,iEAAiE,mBAAmB,qDAAqD,iGAAiG,mBAAmB,+CAA+C,qCAAqC,qCAAqC,8CAA8C,oCAAoC,+CAA+C,6EAA6E,uBAAuB,OAAO,2CAA2C,uBAAuB,mBAAmB,eAAe,WAAW,OAAO,iCAAiC,mCAAmC,mCAAmC,mCAAmC,OAAO,gCAAgC,iBAAiB,8BAA8B,iBAAiB,8BAA8B,iBAAiB,mCAAmC,sDAAsD,qCAAqC,+IAA+I,qEAAqE,uFAAuF,iBAAiB,IAAI,6DAA6D,sBAAsB,4CAA4C,iDAAiD,qDAAqD,sDAAsD,2DAA2D,+DAA+D,kDAAkD,uDAAuD,2DAA2D,OAAO,IAAI,iDAAiD,iCAAiC,iCAAiC,mCAAmC,4BAA4B,6DAA6D,4DAA4D,6FAA6F,yDAAyD,yDAAyD,oCAAoC,wCAAwC,2BAA2B,gBAAgB,yBAAyB,yBAAyB,mCAAmC,gBAAgB,iCAAiC,yBAAyB,mCAAmC,yBAAyB,kCAAkC,kCAAkC,4BAA4B,0BAA0B,0BAA0B,kCAAkC,wGAAwG,OAAO,iDAAiD,qDAAqD,+CAA+C,mDAAmD,gCAAgC,gCAAgC,gCAAgC,sCAAsC,gCAAgC,gCAAgC,gCAAgC,sCAAsC,sCAAsC,iCAAiC,iCAAiC,yCAAyC,yCAAyC,mCAAmC,mCAAmC,mDAAmD,yCAAyC,mCAAmC,mCAAmC,mDAAmD,iDAAiD,oCAAoC,oCAAoC,oBAAoB,mDAAmD,gCAAgC,gCAAgC,gCAAgC,kCAAkC,sCAAsC,gCAAgC,gCAAgC,sCAAsC,sCAAsC,iCAAiC,iCAAiC,yCAAyC,yCAAyC,mCAAmC,mCAAmC,2CAA2C,iDAAiD,mCAAmC,mCAAmC,mDAAmD,iDAAiD,oCAAoC,oCAAoC,wBAAwB,0BAA0B,wBAAwB,wBAAwB,yEAAyE,WAAW,QAAQ,qCAAqC,uCAAuC,sCAAsC,wCAAwC,wCAAwC,sBAAsB,OAAO,+BAA+B,+BAA+B,oGAAoG,IAAI,qDAAqD,gDAAgD,sDAAsD,gDAAgD,gDAAgD,kCAAkC,oCAAoC,4BAA4B,qCAAqC,kCAAkC,qBAAqB,QAAQ,0CAA0C,gCAAgC,+BAA+B,uCAAuC,6CAA6C,wCAAwC,qHAAqH,4GAA4G,WAAW,OAAO,6CAA6C,WAAW,SAAS,mBAAmB,+EAA+E,QAAQ,OAAO,8CAA8C,qDAAqD,yHAAyH,uCAAuC,iDAAiD,kDAAkD,wBAAwB,eAAe,6IAA6I,mIAAmI,aAAa,aAAa,SAAS,yBAAyB,kFAAkF,uBAAuB,0BAA0B,qEAAqE,QAAQ,OAAO,4GAA4G,uDAAuD,OAAO,qEAAqE,QAAQ,OAAO,wCAAwC,qCAAqC,6BAA6B,OAAO,iDAAiD,OAAO,wDAAwD,OAAO,WAAW,oLAAoL,0BAA0B,OAAO,6FAA6F,0DAA0D,0DAA0D,8BAA8B,wBAAwB,wBAAwB,sEAAsE,6BAA6B,WAAW,QAAQ,yCAAyC,2CAA2C,0CAA0C,4CAA4C,4CAA4C,0BAA0B,WAAW,OAAO,OAAO,6BAA6B,WAAW,QAAQ,yCAAyC,2CAA2C,2CAA2C,2CAA2C,WAAW,uCAAuC,yEAAyE,OAAO,wCAAwC,gDAAgD,qCAAqC,QAAQ,OAAO,kCAAkC,OAAO,iCAAiC,wCAAwC,oCAAoC,2BAA2B,uCAAuC,4DAA4D,+DAA+D,4DAA4D,mCAAmC,eAAe,WAAW,+CAA+C,OAAO,gCAAgC,gCAAgC,4GAA4G,IAAI,0DAA0D,iCAAiC,6DAA6D,oEAAoE,4DAA4D,gEAAgE,qBAAqB,WAAW,OAAO,sBAAsB,0CAA0C,6DAA6D,8BAA8B,sCAAsC,0DAA0D,QAAQ,OAAO,qCAAqC,yFAAyF,WAAW,0CAA0C,0CAA0C,0CAA0C,qBAAqB,gCAAgC,oBAAoB,WAAW,0BAA0B,+BAA+B,iEAAiE,WAAW,OAAO,+BAA+B,WAAW,OAAO,mCAAmC,kCAAkC,iCAAiC,oEAAoE,IAAI,qBAAqB,gFAAgF,mBAAmB,qGAAqG,mGAAmG,qGAAqG,wGAAwG,wGAAwG,+FAA+F,2BAA2B,EAAE,EAAE,gIAAgI,gHAAgH,gHAAgH,qHAAqH,qHAAqH,6FAA6F,+CAA+C,iCAAiC,iBAAiB,OAAO,gKAAgK,uFAAuF,OAAO,mKAAmK,sFAAsF,OAAO,iFAAiF,4BAA4B,iBAAiB,OAAO,mDAAmD,gCAAgC,iBAAiB,OAAO,uFAAuF,iFAAiF,+EAA+E,iFAAiF,iFAAiF,mFAAmF,yFAAyF,2FAA2F,iCAAiC,6EAA6E,sCAAsC,qDAAqD,6BAA6B,oBAAoB,aAAa,eAAe,kCAAkC,gCAAgC,4CAA4C,0CAA0C,gEAAgE,qCAAqC,iBAAiB,OAAO,yCAAyC,oEAAoE,sCAAsC,yDAAyD,WAAW,qCAAqC,yFAAyF,WAAW,uCAAuC,6BAA6B,6BAA6B,gEAAgE,wCAAwC,wCAAwC,OAAO,+DAA+D,kCAAkC,oCAAoC,yBAAyB,yBAAyB,yBAAyB,OAAO,4CAA4C,0CAA0C,0CAA0C,2EAA2E,wCAAwC,0TAA0T,0JAA0J,8CAA8C,IAAI,2DAA2D,uBAAuB,+BAA+B,yEAAyE,0CAA0C,WAAW,OAAO,qBAAqB,IAAI,sHAAsH,6CAA6C,gCAAgC,iBAAiB,OAAO,2DAA2D,wCAAwC,qBAAqB,kBAAkB,OAAO,0CAA0C,0CAA0C,+BAA+B,gCAAgC,4BAA4B,iCAAiC,sDAAsD,eAAe,OAAO,kDAAkD,eAAe,yBAAyB,iBAAiB,OAAO,uCAAuC,6CAA6C,qCAAqC,yDAAyD,OAAO,gDAAgD,mBAAmB,yFAAyF,+CAA+C,sDAAsD,mBAAmB,eAAe,sDAAsD,yBAAyB,+HAA+H,iBAAiB,OAAO,uCAAuC,6CAA6C,+FAA+F,2BAA2B,mBAAmB,eAAe,kCAAkC,8CAA8C,8FAA8F,eAAe,OAAO,8CAA8C,8FAA8F,eAAe,WAAW,OAAO,IAAI,kBAAkB,gFAAgF,mBAAmB,+FAA+F,aAAa,EAAE,EAAE,gHAAgH,mkEAAmkE,ohEAAohE,uBAAuB,yBAAyB,GAAG,wBAAwB,yBAAyB,GAAG,6CAA6C,wCAAwC,QAAQ,OAAO,6BAA6B,iBAAiB,OAAO,KAAK,aAAa,GAAG,gDAAgD,uBAAuB,SAAS,OAAO,qBAAqB,KAAK,GAAG,mDAAmD,oCAAoC,OAAO,YAAY,wBAAwB,sBAAsB,oBAAoB,qBAAqB,wBAAwB,qBAAqB,KAAK,GAAG,mDAAmD,YAAY,wHAAwH,GAAG,+IAA+I,iBAAiB,mBAAmB,8CAA8C,qBAAqB,+BAA+B,sCAAsC,kDAAkD,KAAK,+DAA+D,6BAA6B,oBAAoB,gBAAgB,eAAe,eAAe,OAAO,+BAA+B,qBAAqB,yCAAyC,yBAAyB,+BAA+B,uCAAuC,OAAO,qDAAqD,uBAAuB,OAAO,qDAAqD,gDAAgD,wBAAwB,oFAAoF,SAAS,OAAO,qDAAqD,wBAAwB,OAAO,uEAAuE,kBAAkB,OAAO,0BAA0B,KAAK,0PAA0P,mBAAmB,wCAAwC,KAAK,8BAA8B,wCAAwC,qBAAqB,uBAAuB,OAAO,OAAO,sBAAsB,uBAAuB,OAAO,KAAK,sBAAsB,eAAe,eAAe,OAAO,6BAA6B,KAAK,iIAAiI,gBAAgB,kBAAkB,4PAA4P,eAAe,eAAe,OAAO,+BAA+B,4BAA4B,OAAO,OAAO,4BAA4B,OAAO,KAAK,iPAAiP,UAAU,eAAe,eAAe,OAAO,mBAAmB,uBAAuB,qDAAqD,OAAO,iDAAiD,qBAAqB,OAAO,KAAK,2DAA2D,eAAe,OAAO,mBAAmB,uBAAuB,uBAAuB,OAAO,KAAK,0NAA0N,mBAAmB,OAAO,gFAAgF,wBAAwB,OAAO,qIAAqI,gCAAgC,OAAO,KAAK,2IAA2I,eAAe,OAAO,8BAA8B,kCAAkC,uBAAuB,QAAQ,OAAO,kCAAkC,kBAAkB,WAAW,0BAA0B,SAAS,0CAA0C,eAAe,OAAO,kCAAkC,kBAAkB,WAAW,0BAA0B,SAAS,OAAO,KAAK,qGAAqG,eAAe,OAAO,mBAAmB,iEAAiE,wBAAwB,OAAO,KAAK,qOAAqO,eAAe,eAAe,OAAO,mBAAmB,uBAAuB,qDAAqD,OAAO,mCAAmC,qBAAqB,OAAO,KAAK,mUAAmU,eAAe,OAAO,8BAA8B,kDAAkD,yBAAyB,oBAAoB,gCAAgC,SAAS,0BAA0B,kCAAkC,iCAAiC,SAAS,6BAA6B,uBAAuB,SAAS,4BAA4B,sBAAsB,SAAS,+BAA+B,2CAA2C,SAAS,oBAAoB,oDAAoD,KAAK,2FAA2F,eAAe,OAAO,8BAA8B,qBAAqB,OAAO,KAAK,2TAA2T,eAAe,OAAO,mBAAmB,8BAA8B,wBAAwB,yBAAyB,SAAS,qCAAqC,yBAAyB,SAAS,OAAO,OAAO,6DAA6D,yBAAyB,SAAS,OAAO,KAAK,upBAAupB,4BAA4B,cAAc,mCAAmC,QAAQ,OAAO,wBAAwB,iCAAiC,6BAA6B,OAAO,mDAAmD,+BAA+B,OAAO,KAAK,uEAAuE,yBAAyB,WAAW,sDAAsD,qCAAqC,QAAQ,OAAO,gCAAgC,2BAA2B,oDAAoD,uBAAuB,WAAW,SAAS,sBAAsB,oBAAoB,SAAS,OAAO,uBAAuB,4DAA4D,OAAO,KAAK,2qBAA2qB,QAAQ,OAAO,wBAAwB,qCAAqC,sBAAsB,OAAO,KAAK,iDAAiD,GAAG,mBAAmB,gFAAgF,mBAAmB,kGAAkG,+FAA+F,aAAa,EAAE,EAAE,iHAAiH,oBAAoB,iCAAiC,0BAA0B,sCAAsC,qBAAqB,2DAA2D,kBAAkB,mDAAmD,kBAAkB,qDAAqD,kBAAkB,uDAAuD,kBAAkB,oDAAoD,kBAAkB,waAAwa,uBAAuB,YAAY,qFAAqF,0BAA0B,2BAA2B,wBAAwB,aAAa,OAAO,mDAAmD,eAAe,oDAAoD,cAAc,mDAAmD,eAAe,kDAAkD,gBAAgB,uBAAuB,+BAA+B,0CAA0C,wEAAwE,OAAO,wBAAwB,gBAAgB,OAAO,0BAA0B,2BAA2B,uEAAuE,sGAAsG,OAAO,yBAAyB,2DAA2D,iDAAiD,iBAAiB,gEAAgE,mCAAmC,iCAAiC,iCAAiC,iCAAiC,uCAAuC,2BAA2B,mBAAmB,QAAQ,sCAAsC,8BAA8B,+JAA+J,2BAA2B,QAAQ,6DAA6D,wEAAwE,4CAA4C,gFAAgF,OAAO,gFAAgF,OAAO,gFAAgF,OAAO,gFAAgF,OAAO,+BAA+B,2BAA2B,uBAAuB,8BAA8B,qGAAqG,2BAA2B,QAAQ,6DAA6D,wEAAwE,mEAAmE,2BAA2B,uBAAuB,8BAA8B,eAAe,aAAa,OAAO,sBAAsB,GAAG,4DAA4D,gCAAgC,YAAY,2DAA2D,YAAY,2DAA2D,YAAY,6BAA6B,YAAY,8BAA8B,YAAY,8BAA8B,gCAAgC,gCAAgC,sBAAsB,2BAA2B,wBAAwB,mDAAmD,qDAAqD,2CAA2C,kEAAkE,yFAAyF,+CAA+C,+BAA+B,+CAA+C,QAAQ,OAAO,wFAAwF,OAAO,0BAA0B,4CAA4C,QAAQ,OAAO,sCAAsC,0BAA0B,WAAW,8FAA8F,wBAAwB,OAAO,4BAA4B,GAAG,gGAAgG,uGAAuG,mIAAmI,iCAAiC,oEAAoE,oEAAoE,gDAAgD,8BAA8B,iFAAiF,OAAO,OAAO,yDAAyD,OAAO,yEAAyE,4DAA4D,wDAAwD,sGAAsG,OAAO,2HAA2H,OAAO,mGAAmG,OAAO,mGAAmG,OAAO,OAAO,gBAAgB,yPAAyP,GAAG,2CAA2C,0BAA0B,8CAA8C,sBAAsB,kBAAkB,aAAa,OAAO,mDAAmD,eAAe,oDAAoD,cAAc,mDAAmD,eAAe,kDAAkD,gBAAgB,sCAAsC,OAAO,eAAe,GAAG,uBAAuB,qCAAqC,wFAAwF,OAAO,0CAA0C,iDAAiD,6BAA6B,+EAA+E,sDAAsD,OAAO,sCAAsC,+CAA+C,oCAAoC,2BAA2B,2BAA2B,2BAA2B,yBAAyB,sCAAsC,OAAO,2CAA2C,+CAA+C,oCAAoC,yBAAyB,qCAAqC,OAAO,wCAAwC,+CAA+C,oCAAoC,yBAAyB,kBAAkB,sCAAsC,OAAO,yCAAyC,+CAA+C,0CAA0C,OAAO,+CAA+C,uBAAuB,sBAAsB,OAAO,kDAAkD,qBAAqB,OAAO,uCAAuC,+CAA+C,oCAAoC,yBAAyB,mBAAmB,mBAAmB,mBAAmB,uCAAuC,OAAO,yCAAyC,+CAA+C,8FAA8F,OAAO,2CAA2C,yFAAyF,uBAAuB,wBAAwB,OAAO,0CAA0C,mBAAmB,OAAO,6CAA6C,+CAA+C,uBAAuB,wBAAwB,OAAO,kBAAkB,iDAAiD,0CAA0C,WAAW,mBAAmB,OAAO,2CAA2C,+CAA+C,uBAAuB,sBAAsB,KAAK,0BAA0B,qBAAqB,OAAO,gDAAgD,wFAAwF,qBAAqB,wBAAwB,OAAO,4DAA4D,mBAAmB,OAAO,IAAI,mBAAmB,mCAAmC,yDAAyD,yDAAyD,yDAAyD,yDAAyD,yDAAyD,yDAAyD,uEAAuE,mEAAmE,0BAA0B,mBAAmB,2BAA2B,qDAAqD,cAAc,8DAA8D,cAAc,wDAAwD,cAAc,wDAAwD,cAAc,8FAA8F,mFAAmF,wFAAwF,uBAAuB,GAAG,8DAA8D,0BAA0B,2BAA2B,mBAAmB,+CAA+C,YAAY,oBAAoB,SAAS,aAAa,kDAAkD,YAAY,2EAA2E,wBAAwB,OAAO,iBAAiB,GAAG,+DAA+D,sDAAsD,0BAA0B,2BAA2B,iBAAiB,SAAS,qDAAqD,YAAY,+CAA+C,YAAY,+CAA+C,YAAY,wBAAwB,OAAO,OAAO,kDAAkD,YAAY,0DAA0D,uCAAuC,6BAA6B,OAAO,iBAAiB,GAAG,wCAAwC,kBAAkB,kBAAkB,MAAM,iCAAiC,iBAAiB,GAAG,sDAAsD,0BAA0B,iBAAiB,8BAA8B,gDAAgD,YAAY,uBAAuB,yDAAyD,YAAY,yDAAyD,YAAY,sBAAsB,cAAc,OAAO,2CAA2C,2CAA2C,2DAA2D,YAAY,WAAW,OAAO,uBAAuB,mDAAmD,YAAY,sBAAsB,SAAS,OAAO,2DAA2D,YAAY,2DAA2D,YAAY,2DAA2D,YAAY,WAAW,OAAO,iBAAiB,GAAG,iEAAiE,0BAA0B,mBAAmB,+DAA+D,+BAA+B,+DAA+D,+BAA+B,+DAA+D,+BAA+B,+DAA+D,+BAA+B,iBAAiB,GAAG,sDAAsD,0BAA0B,mBAAmB,+CAA+C,YAAY,+CAA+C,YAAY,mEAAmE,oEAAoE,uEAAuE,yEAAyE,wBAAwB,wBAAwB,wBAAwB,cAAc,OAAO,6BAA6B,mCAAmC,mCAAmC,WAAW,OAAO,wBAAwB,sBAAsB,cAAc,QAAQ,iDAAiD,2CAA2C,2CAA2C,uCAAuC,uCAAuC,WAAW,OAAO,sBAAsB,oBAAoB,mBAAmB,GAAG,mDAAmD,2CAA2C,oBAAoB,OAAO,0BAA0B,6CAA6C,wBAAwB,cAAc,QAAQ,+DAA+D,gEAAgE,OAAO,gBAAgB,GAAG,yDAAyD,0BAA0B,2BAA2B,mBAAmB,qDAAqD,YAAY,wBAAwB,SAAS,OAAO,mDAAmD,YAAY,kDAAkD,YAAY,oBAAoB,uEAAuE,EAAE,OAAO,iBAAiB,GAAG,0DAA0D,0BAA0B,6DAA6D,YAAY,8DAA8D,YAAY,6BAA6B,kBAAkB,eAAe,qDAAqD,qBAAqB,GAAG,0DAA0D,0BAA0B,2BAA2B,mBAAmB,qDAAqD,YAAY,wBAAwB,SAAS,OAAO,mDAAmD,YAAY,kDAAkD,YAAY,6EAA6E,OAAO,iBAAiB,GAAG,yDAAyD,0BAA0B,2BAA2B,mBAAmB,6DAA6D,YAAY,+EAA+E,4DAA4D,YAAY,wBAAwB,gBAAgB,OAAO,mDAAmD,YAAY,wDAAwD,YAAY,oFAAoF,OAAO,iBAAiB,GAAG,0DAA0D,0BAA0B,mBAAmB,2DAA2D,YAAY,wDAAwD,oDAAoD,YAAY,yEAAyE,uDAAuD,4DAA4D,YAAY,iEAAiE,iBAAiB,GAAG,qBAAqB,oDAAoD,yDAAyD,iBAAiB,6BAA6B,0BAA0B,mBAAmB,mDAAmD,cAAc,mDAAmD,cAAc,8CAA8C,0BAA0B,sBAAsB,8BAA8B,aAAa,OAAO,wDAAwD,cAAc,wDAAwD,cAAc,mDAAmD,mBAAmB,+DAA+D,sFAAsF,6DAA6D,kCAAkC,uCAAuC,uBAAuB,iCAAiC,yDAAyD,yEAAyE,yEAAyE,yEAAyE,yEAAyE,6FAA6F,oCAAoC,WAAW,0FAA0F,yBAAyB,OAAO,iBAAiB,GAAG,+CAA+C,0BAA0B,mBAAmB,gDAAgD,cAAc,gDAAgD,cAAc,gDAAgD,cAAc,mBAAmB,kBAAkB,SAAS,mCAAmC,iBAAiB,GAAG,+CAA+C,0BAA0B,2BAA2B,mBAAmB,sDAAsD,YAAY,gDAAgD,YAAY,kDAAkD,YAAY,oDAAoD,YAAY,kCAAkC,qDAAqD,YAAY,uDAAuD,YAAY,oDAAoD,YAAY,+DAA+D,uBAAuB,gBAAgB,+DAA+D,uBAAuB,uBAAuB,kBAAkB,YAAY,OAAO,8CAA8C,aAAa,kEAAkE,uBAAuB,4BAA4B,qCAAqC,oDAAoD,aAAa,iBAAiB,GAAG,+CAA+C,0BAA0B,2BAA2B,mBAAmB,sDAAsD,YAAY,gDAAgD,YAAY,kDAAkD,YAAY,mDAAmD,YAAY,oDAAoD,YAAY,4BAA4B,kBAAkB,cAAc,OAAO,oDAAoD,aAAa,uBAAuB,GAAG,gDAAgD,0BAA0B,2BAA2B,mBAAmB,sDAAsD,YAAY,kBAAkB,8CAA8C,YAAY,8CAA8C,YAAY,8CAA8C,YAAY,sBAAsB,wBAAwB,WAAW,OAAO,oCAAoC,wDAAwD,wDAAwD,wDAAwD,0EAA0E,OAAO,iBAAiB,GAAG,uBAAuB,0DAA0D,sEAAsE,GAAG,wDAAwD,8CAA8C,4DAA4D,uDAAuD,YAAY,iDAAiD,YAAY,mEAAmE,iDAAiD,YAAY,iDAAiD,YAAY,oDAAoD,oDAAoD,2BAA2B,4BAA4B,mDAAmD,YAAY,gCAAgC,SAAS,OAAO,uDAAuD,YAAY,+BAA+B,wDAAwD,WAAW,2BAA2B,4BAA4B,WAAW,OAAO,yDAAyD,WAAW,qCAAqC,sCAAsC,gEAAgE,iBAAiB,GAAG,sCAAsC,gEAAgE,iBAAiB,GAAG,4BAA4B,oCAAoC,EAAE,eAAe,qCAAqC,WAAW,OAAO,2BAA2B,uDAAuD,YAAY,uDAAuD,YAAY,yDAAyD,YAAY,yDAAyD,YAAY,uFAAuF,6EAA6E,oCAAoC,sBAAsB,eAAe,OAAO,2BAA2B,0BAA0B,eAAe,OAAO,mDAAmD,sCAAsC,gEAAgE,kBAAkB,EAAE,sCAAsC,gEAAgE,kBAAkB,EAAE,4BAA4B,yBAAyB,EAAE,eAAe,mCAAmC,WAAW,OAAO,iBAAiB,GAAG,mBAAmB,0DAA0D,sEAAsE,GAAG,sDAAsD,qEAAqE,iDAAiD,oDAAoD,YAAY,iDAAiD,YAAY,mEAAmE,yDAAyD,yBAAyB,0BAA0B,sDAAsD,YAAY,WAAW,+BAA+B,qDAAqD,YAAY,4DAA4D,4BAA4B,WAAW,OAAO,yBAAyB,wBAAwB,iDAAiD,YAAY,sBAAsB,OAAO,OAAO,sDAAsD,YAAY,2EAA2E,WAAW,sCAAsC,kCAAkC,OAAO,wBAAwB,GAAG,6DAA6D,uDAAuD,6CAA6C,YAAY,kBAAkB,OAAO,OAAO,kDAAkD,YAAY,yEAAyE,OAAO,kBAAkB,GAAG,6DAA6D,uDAAuD,0DAA0D,mBAAmB,eAAe,QAAQ,iDAAiD,YAAY,kBAAkB,2DAA2D,kCAAkC,OAAO,6CAA6C,YAAY,wDAAwD,gCAAgC,kBAAkB,GAAG,wDAAwD,uDAAuD,8CAA8C,YAAY,kBAAkB,QAAQ,OAAO,kDAAkD,YAAY,gEAAgE,OAAO,kBAAkB,GAAG,qDAAqD,kCAAkC,UAAU,gDAAgD,YAAY,8CAA8C,YAAY,kBAAkB,UAAU,OAAO,+CAA+C,YAAY,GAAG,iBAAiB,GAAG,uBAAuB,oDAAoD,0BAA0B,mBAAmB,qDAAqD,cAAc,qDAAqD,cAAc,0DAA0D,cAAc,mDAAmD,cAAc,+CAA+C,cAAc,oDAAoD,cAAc,kDAAkD,cAAc,kDAAkD,cAAc,6CAA6C,cAAc,6CAA6C,cAAc,6CAA6C,cAAc,6CAA6C,cAAc,kDAAkD,cAAc,uDAAuD,cAAc,0DAA0D,cAAc,0DAA0D,cAAc,0DAA0D,cAAc,iBAAiB,GAAG,qBAAqB,oDAAoD,0BAA0B,mBAAmB,qDAAqD,cAAc,kDAAkD,cAAc,kDAAkD,cAAc,gDAAgD,cAAc,+DAA+D,cAAc,4DAA4D,cAAc,4DAA4D,cAAc,mDAAmD,cAAc,6DAA6D,cAAc,uDAAuD,cAAc,uDAAuD,cAAc,0BAA0B,gEAAgE,cAAc,0DAA0D,cAAc,iBAAiB,GAAG,qBAAqB,0DAA0D,0BAA0B,mBAAmB,4BAA4B,yBAAyB,oCAAoC,wBAAwB,uBAAuB,OAAO,4CAA4C,kCAAkC,cAAc,kCAAkC,YAAY,GAAG,8BAA8B,kCAAkC,OAAO,uBAAuB,GAAG,qBAAqB,0DAA0D,0BAA0B,uDAAuD,YAAY,4EAA4E,iDAAiD,YAAY,uBAAuB,qBAAqB,kBAAkB,WAAW,OAAO,oBAAoB,sEAAsE,YAAY,sDAAsD,YAAY,oCAAoC,2EAA2E,0EAA0E,4DAA4D,OAAO,iBAAiB,GAAG,8DAA8D,0BAA0B,sDAAsD,YAAY,+CAA+C,YAAY,uBAAuB,qBAAqB,kBAAkB,WAAW,OAAO,kDAAkD,aAAa,sDAAsD,YAAY,wDAAwD,YAAY,oCAAoC,2EAA2E,0EAA0E,4DAA4D,OAAO,iBAAiB,GAAG,yDAAyD,0BAA0B,qBAAqB,uDAAuD,YAAY,uDAAuD,YAAY,uDAAuD,YAAY,uDAAuD,YAAY,kBAAkB,UAAU,OAAO,mDAAmD,YAAY,mDAAmD,YAAY,mDAAmD,YAAY,2BAA2B,uBAAuB,iBAAiB,qBAAqB,GAAG,iDAAiD,kCAAkC,yBAAyB,uBAAuB,OAAO,oBAAoB,GAAG,uBAAuB,oDAAoD,iDAAiD,gCAAgC,mBAAmB,mFAAmF,aAAa,mDAAmD,cAAc,oDAAoD,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,mEAAmE,cAAc,OAAO,uBAAuB,GAAG,kBAAkB,+CAA+C,2BAA2B,gCAAgC,2CAA2C,gDAAgD,gDAAgD,sEAAsE,wCAAwC,gCAAgC,4CAA4C,+BAA+B,OAAO,yBAAyB,wBAAwB,sBAAsB,uBAAuB,kCAAkC,SAAS,QAAQ,GAAG,iCAAiC,iDAAiD,gCAAgC,8JAA8J,wEAAwE,8BAA8B,OAAO,0BAA0B,+DAA+D,sBAAsB,qBAAqB,OAAO,sCAAsC,6EAA6E,WAAW,mBAAmB,OAAO,2DAA2D,GAAG,+CAA+C,kBAAkB,mBAAmB,sEAAsE,eAAe,GAAG,uDAAuD,qBAAqB,0BAA0B,wBAAwB,kCAAkC,OAAO,gDAAgD,iEAAiE,iBAAiB,8GAA8G,WAAW,oBAAoB,4BAA4B,sBAAsB,OAAO,yCAAyC,uEAAuE,wCAAwC,8BAA8B,sCAAsC,oDAAoD,mCAAmC,gBAAgB,4CAA4C,8CAA8C,mBAAmB,0BAA0B,wEAAwE,wEAAwE,+CAA+C,mBAAmB,qCAAqC,eAAe,WAAW,OAAO,qBAAqB,kDAAkD,wBAAwB,iEAAiE,kEAAkE,WAAW,OAAO,qBAAqB,GAAG,sCAAsC,mVAAmV,qCAAqC,IAAI,qCAAqC,UAAU,kGAAkG,+KAA+K,mwBAAmwB,oDAAoD,0FAA0F,+EAA+E,8CAA8C,mCAAmC,mCAAmC,QAAQ,OAAO,gCAAgC,yBAAyB,6BAA6B,iGAAiG,qCAAqC,WAAW,sBAAsB,wCAAwC,WAAW,oBAAoB,4JAA4J,oCAAoC,eAAe,WAAW,mCAAmC,iDAAiD,oCAAoC,eAAe,WAAW,OAAO,yDAAyD,QAAQ,OAAO,wBAAwB,qCAAqC,0CAA0C,mCAAmC,mEAAmE,wEAAwE,sCAAsC,0BAA0B,+BAA+B,mBAAmB,eAAe,WAAW,OAAO,0EAA0E,QAAQ,OAAO,wBAAwB,0CAA0C,QAAQ,OAAO,8BAA8B,8CAA8C,sBAAsB,wBAAwB,eAAe,WAAW,wBAAwB,iCAAiC,OAAO,uBAAuB,kBAAkB,iCAAiC,iBAAiB,QAAQ,uBAAuB,qCAAqC,uCAAuC,kCAAkC,WAAW,uBAAuB,uBAAuB,WAAW,kFAAkF,4CAA4C,qDAAqD,qDAAqD,2CAA2C,qDAAqD,2CAA2C,qCAAqC,qBAAqB,yEAAyE,mBAAmB,OAAO,yEAAyE,uBAAuB,oCAAoC,yBAAyB,uBAAuB,QAAQ,0CAA0C,8BAA8B,gBAAgB,OAAO,wCAAwC,2EAA2E,6CAA6C,6CAA6C,mDAAmD,uBAAuB,OAAO,2CAA2C,2CAA2C,oFAAoF,2BAA2B,OAAO,uDAAuD,2BAA2B,uBAAuB,mBAAmB,eAAe,WAAW,OAAO,oBAAoB,yBAAyB,eAAe,QAAQ,uBAAuB,qCAAqC,uCAAuC,kCAAkC,WAAW,uBAAuB,uBAAuB,WAAW,+CAA+C,4BAA4B,sDAAsD,2BAA2B,uBAAuB,QAAQ,0CAA0C,8BAA8B,gBAAgB,OAAO,wCAAwC,4EAA4E,2CAA2C,oDAAoD,oDAAoD,eAAe,OAAO,mEAAmE,uBAAuB,0CAA0C,sCAAsC,MAAM,iDAAiD,6CAA6C,6CAA6C,sCAAsC,MAAM,qBAAqB,qFAAqF,uBAAuB,mBAAmB,eAAe,WAAW,OAAO,yCAAyC,6BAA6B,+BAA+B,oCAAoC,QAAQ,OAAO,yBAAyB,2BAA2B,+BAA+B,OAAO,sCAAsC,GAAG,yBAAyB,gFAAgF,mBAAmB,8DAA8D,cAAc,EAAE,qGAAqG,kGAAkG,mGAAmG,wGAAwG,wGAAwG,qGAAqG,qGAAqG,sIAAsI,mFAAmF,0LAA0L,wYAAwY,qHAAqH,qHAAqH,mIAAmI,4GAA4G,6HAA6H,6HAA6H,8UAA8U,0HAA0H,gCAAgC,0JAA0J,oGAAoG,sBAAsB,iKAAiK,0FAA0F,WAAW,wFAAwF,gBAAgB,iHAAiH,gBAAgB,sHAAsH,gBAAgB,YAAY,KAAK,uEAAuE,8CAA8C,sEAAsE,oDAAoD,wCAAwC,0DAA0D,8EAA8E,6CAA6C,eAAe,iCAAiC,+CAA+C,+CAA+C,qJAAqJ,qGAAqG,gCAAgC,uHAAuH,gCAAgC,uHAAuH,gCAAgC,uHAAuH,gIAAgI,+HAA+H,gCAAgC,qBAAqB,eAAe,WAAW,0CAA0C,sDAAsD,yBAAyB,wCAAwC,4BAA4B,uEAAuE,4CAA4C,eAAe,WAAW,2FAA2F,6CAA6C,QAAQ,OAAO,wCAAwC,+DAA+D,oCAAoC,4DAA4D,gBAAgB,iIAAiI,+BAA+B,gEAAgE,0CAA0C,mBAAmB,OAAO,wEAAwE,mBAAmB,eAAe,WAAW,yBAAyB,sCAAsC,uCAAuC,oCAAoC,qJAAqJ,2EAA2E,kEAAkE,oCAAoC,2BAA2B,uBAAuB,4HAA4H,+EAA+E,mDAAmD,4DAA4D,2BAA2B,4DAA4D,wDAAwD,2BAA2B,kEAAkE,+CAA+C,wGAAwG,gCAAgC,2GAA2G,+EAA+E,mEAAmE,QAAQ,OAAO,4DAA4D,wDAAwD,6DAA6D,2FAA2F,uCAAuC,OAAO,qHAAqH,uCAAuC,0DAA0D,mCAAmC,OAAO,0DAA0D,mCAAmC,0KAA0K,kEAAkE,2FAA2F,uCAAuC,4FAA4F,+DAA+D,2DAA2D,mCAAmC,+BAA+B,6DAA6D,6CAA6C,6BAA6B,6BAA6B,uBAAuB,8BAA8B,mJAAmJ,QAAQ,QAAQ,oDAAoD,8EAA8E,mDAAmD,uBAAuB,yFAAyF,oDAAoD,uBAAuB,2DAA2D,QAAQ,cAAc,oDAAoD,8EAA8E,mDAAmD,uBAAuB,8BAA8B,eAAe,gGAAgG,QAAQ,OAAO,iDAAiD,iFAAiF,eAAe,aAAa,SAAS,GAAG,iGAAiG,8EAA8E,oBAAoB,gCAAgC,gDAAgD,QAAQ,OAAO,2CAA2C,sEAAsE,2FAA2F,2BAA2B,eAAe,qGAAqG,iHAAiH,gHAAgH,gIAAgI,+FAA+F,wGAAwG,yJAAyJ,oDAAoD,4CAA4C,+CAA+C,8GAA8G,eAAe,iDAAiD,+CAA+C,mHAAmH,eAAe,yCAAyC,+CAA+C,2GAA2G,eAAe,+DAA+D,oGAAoG,gDAAgD,WAAW,OAAO,GAAG,uFAAuF,mEAAmE,iBAAiB,OAAO,oCAAoC,2CAA2C,0CAA0C,kCAAkC,iDAAiD,EAAE,iFAAiF,iDAAiD,iGAAiG,yDAAyD,kDAAkD,OAAO,OAAO,sCAAsC,+EAA+E,oFAAoF,mBAAmB,6DAA6D,sCAAsC,8EAA8E,EAAE,eAAe,4CAA4C,kCAAkC,+CAA+C,EAAE,qBAAqB,WAAW,OAAO,iDAAiD,sCAAsC,8BAA8B,8CAA8C,EAAE,6EAA6E,sCAAsC,8BAA8B,4CAA4C,EAAE,iBAAiB,OAAO,2EAA2E,sHAAsH,6CAA6C,8BAA8B,sFAAsF,wBAAwB,wFAAwF,wBAAwB,2EAA2E,oBAAoB,mDAAmD,WAAW,OAAO,2CAA2C,2FAA2F,yGAAyG,sGAAsG,wHAAwH,qFAAqF,gGAAgG,iJAAiJ,oCAAoC,uCAAuC,sGAAsG,mGAAmG,OAAO,yCAAyC,uCAAuC,2GAA2G,wGAAwG,OAAO,iCAAiC,uCAAuC,mGAAmG,gGAAgG,OAAO,qCAAqC,0FAA0F,uFAAuF,GAAG,uCAAuC,gBAAgB,sCAAsC,gCAAgC,iCAAiC,sBAAsB,iBAAiB,OAAO,wCAAwC,4BAA4B,gCAAgC,gCAAgC,sHAAsH,uDAAuD,0CAA0C,2IAA2I,oCAAoC,iEAAiE,YAAY,0BAA0B,yFAAyF,EAAE,iEAAiE,oCAAoC,oEAAoE,8DAA8D,mCAAmC,kEAAkE,uEAAuE,sCAAsC,oEAAoE,oCAAoC,0BAA0B,qBAAqB,EAAE,oCAAoC,kCAAkC,OAAO,sCAAsC,GAAG,0CAA0C,wCAAwC,uEAAuE,eAAe,6CAA6C,WAAW,YAAY,6BAA6B,WAAW,OAAO,OAAO,yBAAyB,OAAO,sBAAsB,iDAAiD,yEAAyE,QAAQ,OAAO,2CAA2C,WAAW,OAAO,gDAAgD,GAAG,qCAAqC,2BAA2B,uCAAuC,iCAAiC,uDAAuD,yBAAyB,kDAAkD,gDAAgD,mDAAmD,sDAAsD,0DAA0D,wCAAwC,8CAA8C,WAAW,yBAAyB,oBAAoB,EAAE,gBAAgB,+CAA+C,yBAAyB,oBAAoB,EAAE,gBAAgB,qDAAqD,uBAAuB,wBAAwB,EAAE,uBAAuB,oBAAoB,EAAE,gBAAgB,8EAA8E,sDAAsD,wDAAwD,oDAAoD,6DAA6D,kCAAkC,8CAA8C,gDAAgD,uCAAuC,oDAAoD,4EAA4E,WAAW,uCAAuC,2BAA2B,EAAE,uBAAuB,oBAAoB,EAAE,gBAAgB,OAAO,IAAI,eAAe,eAAe;AACpntQ,E;;;;;;;;ACDA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,yBAAyB;AACzB,wBAAwB;AACxB,0BAA0B;AAC1B,yCAAyC;AACzC,4BAA4B;AAC5B,kCAAkC;AAClC,2EAA2E;AAC3E,6BAA6B;AAC7B,gCAAgC;AAChC,+BAA+B;AAC/B,4BAA4B;AAC5B,YAAY;;AAEZ,+BAA+B;AAC/B,sCAAsC;AACtC,2CAA2C;AAC3C,YAAY;;AAEZ,6BAA6B;AAC7B,gCAAgC;AAChC,+BAA+B;AAC/B,YAAY;;AAEZ,+BAA+B;AAC/B,gCAAgC;AAChC,oCAAoC;AACpC,iCAAiC;AACjC,kCAAkC;AAClC,8BAA8B;AAC9B,YAAY;;AAEZ,qCAAqC;AACrC,2CAA2C;AAC3C,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,iFAAiF,kEAAkE,0EAA0E,4EAA4E,wEAAwE;AACjX;AACA,kFAAkF,kEAAkE,uEAAuE,4EAA4E;AACvS;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,sCAAsC;AACtC;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,+CAA+C;AAC/C,iDAAiD;AACjD,2CAA2C;AAC3C,2CAA2C;AAC3C,4CAA4C;AAC5C;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,eAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC,qEAAqE;AACrE,qEAAqE;AACrE,qEAAqE;AACrE,qEAAqE;AACrE,KAAK;AACL,kCAAkC;AAClC,qEAAqE;AACrE,qEAAqE;AACrE,qEAAqE;AACrE,qEAAqE;AACrE;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,aAAa;AACb,mEAAmE;AACnE,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E,6EAA6E;AAC7E;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE;AACtE,aAAa;AACb,sEAAsE;AACtE;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;AACA;;AAEA;;AAEA,wC;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wC;;AAEA,6CAA6C,QAAQ;AACrD;AACA,sGAAsG;AACtG;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,sEAAsE;AACtE;AACA,8EAA8E;AAC9E;AACA,8EAA8E;AAC9E;AACA;AACA,aAAa;AACb,sEAAsE;AACtE;AACA,8EAA8E;AAC9E;AACA,8EAA8E;AAC9E;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;AC5rBA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;AACA,SAAS,wBAAwB;AACjC;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kCAAkC,kCAAkC,QAAQ,UAAU;;AAEtF;AACA;AACA,kCAAkC,sCAAsC,QAAQ,SAAS;AACzF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,YAAY,OAAO;AAClE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0HAA0H;;AAE1H,0BAA0B;;AAE1B,8DAA8D,QAAQ,UAAU;AAChF,6DAA6D,QAAQ,WAAW;AAChF,gEAAgE,QAAQ,SAAS;;AAEjF;AACA,+GAA+G;AAC/G;;AAEA;AACA;AACA;AACA,wHAAwH;AACxH,+CAA+C;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;;AAE7C,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;;AAEA,0BAA0B;;AAE1B;AACA;AACA,qFAAqF,OAAO;;AAE5F;AACA;AACA,kDAAkD,OAAO;;AAEzD;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,wDAAwD,OAAO;;AAE/D;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,iEAAiE,OAAO;;AAExE;AACA;AACA,8DAA8D,OAAO;;AAErE;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA,+D;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA,uDAAuD,YAAY,OAAO;;AAE1E;AACA;AACA,mDAAmD,YAAY,OAAO;;AAEtE;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,8EAA8E,OAAO;;AAErF;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,mEAAmE,OAAO;;AAE1E;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,a;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD,qCAAqC,6CAA6C,SAAS;;AAE3F;AACA;AACA,iDAAiD;AACjD,sEAAsE,6CAA6C,SAAS;;AAE5H;AACA;AACA,0CAA0C,iCAAiC,SAAS;;AAEpF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,OAAO;;AAExD;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,uDAAuD,OAAO;;AAE9D;AACA;AACA,+DAA+D,OAAO;;AAEtE;AACA;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,uDAAuD,OAAO;;AAE9D;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA;AACA,+EAA+E,OAAO;;AAEtF;AACA;AACA,+EAA+E,OAAO;;AAEtF;AACA;AACA,uFAAuF,OAAO;;AAE9F;AACA;AACA,6DAA6D,OAAO;;AAEpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,6DAA6D;;AAE5F;AACA;AACA;AACA,mCAAmC,+BAA+B,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,+DAA+D;AAC/D,kEAAkE;AAClE,oEAAoE;AACpE,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;AChcsB;AACA;AACE;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6B;AACA,kC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,6FAA6F,6BAA6B;AAC1H,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oB;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,E;;AAET;AACA,sCAAsC,QAAQ;AAC9C,wB;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb;;AAEA;AACA,sCAAsC,QAAQ;AAC9C,wB;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,WAAW;AAClC,2BAA2B,WAAW;AACtC;AACA;;AAEA;AACA,a;AACA;AACA;;;AAGA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,a;AACA;;;AAGA;;AAEA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb;;;AAGA,mBAAmB,WAAW;AAC9B,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,E;AACb;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;AAGA;;;;;;;;;AC7TA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,4BAA4B;AAC5B,2EAA2E;AAC3E,6BAA6B;AAC7B,4BAA4B;AAC5B,+BAA+B;AAC/B,kCAAkC;AAClC,2BAA2B;AAC3B,4BAA4B;AAC5B,+BAA+B;AAC/B,wDAAwD;AACxD,kCAAkC;AAClC,sCAAsC;AACtC,gCAAgC;AAChC,0BAA0B;AAC1B,6BAA6B;AAC7B,YAAY;;AAEZ,qCAAqC;AACrC,+BAA+B;AAC/B,gCAAgC;AAChC,YAAY;;AAEZ,oCAAoC;AACpC,kCAAkC;AAClC,YAAY;;AAEZ,oCAAoC;AACpC,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,oCAAoC;AACpC,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,sCAAsC;AACtC,YAAY;;AAEZ,uCAAuC;AACvC,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,uCAAuC;AACvC,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,0CAA0C;AAC1C,6CAA6C;AAC7C,YAAY;;AAEZ,0CAA0C;AAC1C,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,0CAA0C;AAC1C,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,sCAAsC;AACtC,kCAAkC;AAClC,YAAY;;AAEZ,yCAAyC;AACzC,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,yCAAyC;AACzC,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,sCAAsC;AACtC,YAAY;;AAEZ,4CAA4C;AAC5C,+BAA+B;AAC/B,2BAA2B;AAC3B,YAAY;;AAEZ,4CAA4C;AAC5C,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,sCAAsC;AACtC,kCAAkC;AAClC,YAAY;;AAEZ,mCAAmC;AACnC,+BAA+B;AAC/B,4BAA4B;AAC5B,YAAY;;AAEZ,kCAAkC;AAClC,4BAA4B;AAC5B,4BAA4B;AAC5B,6BAA6B;AAC7B,sCAAsC;AACtC,gCAAgC;AAChC,4BAA4B;AAC5B,YAAY;;AAEZ,mCAAmC;AACnC,4BAA4B;AAC5B,4BAA4B;AAC5B,sCAAsC;AACtC,YAAY;;AAEZ,oCAAoC;AACpC,2BAA2B;AAC3B,kCAAkC;AAClC,YAAY;;AAEZ,6BAA6B;AAC7B,2BAA2B;AAC3B,YAAY;;AAEZ,+CAA+C;AAC/C,2BAA2B;AAC3B,YAAY;;AAEZ,6BAA6B;AAC7B,4BAA4B;AAC5B,qCAAqC;AACrC,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,YAAY;;AAEZ,8BAA8B;AAC9B,4BAA4B;AAC5B,qCAAqC;AACrC,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,YAAY;;AAEZ,4CAA4C;AAC5C,4BAA4B;AAC5B,4BAA4B;AAC5B,YAAY;;AAEZ,8BAA8B;AAC9B,2BAA2B;AAC3B,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,qBAAqB;AACrB,uBAAuB;AACvB;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,yBAAyB;AACzB,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qC;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA,wB;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,S;;AAEA,6C;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA,wB;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,oD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kD;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,yB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,yB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yB;AACA;AACA;AACA;AACA,S;AACA;AACA;;;AAGA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,S;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA,oHAAoH;AACpH,qHAAqH;AACrH;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA;AACA;AACA;AACA,2HAA2H;AAC3H,4HAA4H;AAC5H;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mGAAmG,2B;;AAEnG,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE;AACvE,wEAAwE;AACxE,wEAAwE;AACxE,oDAAoD;AACpD;;AAEA;AACA;;;AAGA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;;AAE1C,2CAA2C,QAAQ;AACnD;;AAEA;AACA,iDAAiD,6DAA6D;AAC9G,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4CAA4C;;AAE5C,2CAA2C,QAAQ;AACnD;;AAEA;AACA,mDAAmD,yEAAyE;AAC5H,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,a;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;AC/4BA;AACsB;AACe;;AAErC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,4BAA4B;AAC5B,6EAA6E;AAC7E,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,+BAA+B;AAC/B,kCAAkC;AAClC,2BAA2B;AAC3B,yBAAyB;AACzB,+BAA+B;AAC/B,wDAAwD;AACxD,kCAAkC;AAClC,sCAAsC;AACtC,gCAAgC;AAChC,0BAA0B;AAC1B,6BAA6B;AAC7B,YAAY;;AAEZ,mCAAmC;AACnC,4BAA4B;AAC5B,4BAA4B;AAC5B,2BAA2B;AAC3B,YAAY;;AAEZ,oCAAoC;AACpC,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,YAAY;;AAEZ,8BAA8B;AAC9B,4BAA4B;AAC5B,kCAAkC;AAClC,sCAAsC;AACtC,kCAAkC;AAClC,YAAY;;AAEZ,6BAA6B;AAC7B,2BAA2B;AAC3B,gCAAgC;AAChC,uCAAuC;AACvC,mCAAmC;AACnC,YAAY;;AAEZ,mCAAmC;AACnC,4BAA4B;AAC5B,YAAY;;AAEZ,iCAAiC;AACjC,2BAA2B;AAC3B,iCAAiC;AACjC,kCAAkC;AAClC,YAAY;;AAEZ,mCAAmC;AACnC,iCAAiC;AACjC,YAAY;;AAEZ,oCAAoC;AACpC,4BAA4B;AAC5B,YAAY;;AAEZ,kCAAkC;AAClC,2BAA2B;AAC3B,iCAAiC;AACjC,kCAAkC;AAClC,YAAY;;AAEZ,oCAAoC;AACpC,iCAAiC;AACjC,YAAY;;AAEZ,0CAA0C;AAC1C,sCAAsC;AACtC,YAAY;;AAEZ,wCAAwC;AACxC,+BAA+B;AAC/B,YAAY;;AAEZ,6BAA6B;AAC7B,4BAA4B;AAC5B,6BAA6B;AAC7B,kCAAkC;AAClC,sCAAsC;AACtC,kCAAkC;AAClC,gCAAgC;AAChC,+BAA+B;AAC/B,qCAAqC;AACrC,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0F;AACA;AACA,8F;AACA;AACA,gG;AACA;AACA,4F;AACA;AACA,gG;AACA;AACA,gG;AACA;AACA,4F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,sD;AACA;;AAEA;AACA;AACA,sD;AACA;;AAEA;AACA,sD;AACA,S;AACA,KAAK;AACL;AACA;AACA;AACA,wD;AACA;;AAEA;AACA;AACA,wD;AACA;;AAEA;AACA,wD;AACA,S;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,kD;AACA,KAAK;AACL,oD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,6CAA6C;AAC9E;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C,uCAAuC,mBAAmB;;AAE1D;AACA;AACA;;AAEA;AACA;AACA,K;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,4CAA4C,uDAAuD;AACnG;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,iC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,y7D;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wC;;AAEA,Y;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA,oDAAoD;AACpD,sDAAsD;AACtD,uDAAuD;AACvD,qDAAqD;AACrD,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;;AAEA,+C;AACA;;AAEA;AACA;AACA;AACA,2C;AACA;;AAEA;AACA;AACA,oE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,QAAQ;AACvB;;AAEA;;AAEA;AACA;AACA,yE;AACA,yE;AACA;AACA,iC;AACA;;AAEA;AACA,6E;AACA,6E;AACA;AACA,mC;AACA;;AAEA;AACA,+E;AACA,+E;AACA;AACA,oC;AACA;;AAEA;AACA,2E;AACA,2E;AACA;AACA,kC;AACA;;AAEA;AACA,+E;AACA,+E;AACA;AACA,oC;AACA;;AAEA;AACA;AACA;;AAEA,qE;AACA,qE;AACA;AACA,8B;;AAEA,yE;AACA,yE;AACA;AACA,gC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,8BAA8B;AACxD,4BAA4B,kCAAkC;AAC9D,6BAA6B,oCAAoC;AACjE,2BAA2B,gCAAgC;AAC3D,6BAA6B,oCAAoC;AACjE,2BAA2B,gCAAgC;AAC3D,6BAA6B,oCAAoC;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uJ;AACA,uH;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,6EAA6E,MAAM;;AAEnF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;AC14BuB;;;AAGvB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,2BAA2B;AAC3B,2EAA2E;AAC3E,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,+BAA+B;AAC/B,kCAAkC;AAClC,2BAA2B;AAC3B,yBAAyB;AACzB,+BAA+B;AAC/B,wDAAwD;AACxD,kCAAkC;AAClC,sCAAsC;AACtC,gCAAgC;AAChC,0BAA0B;AAC1B,6BAA6B;AAC7B,YAAY;;AAEZ,kCAAkC;AAClC,+BAA+B;AAC/B,kCAAkC;AAClC,gCAAgC;AAChC,YAAY;;AAEZ,wCAAwC;AACxC,6BAA6B;AAC7B,gCAAgC;AAChC,+BAA+B;AAC/B,YAAY;;AAEZ,2CAA2C;AAC3C,mCAAmC;AACnC,YAAY;;AAEZ,iCAAiC;AACjC,2BAA2B;AAC3B,YAAY;AACZ;;AAEA;AACA;AACA;AACA,kEAAkE,MAAM,MAAM;AAC9E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;AChLA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,mCAAmC;AACnC,4BAA4B;AAC5B,YAAY;;AAEZ,mCAAmC;AACnC,2EAA2E;AAC3E,6BAA6B;AAC7B,4BAA4B;AAC5B,6BAA6B;AAC7B,6BAA6B;AAC7B,+BAA+B;AAC/B,kCAAkC;AAClC,2BAA2B;AAC3B,4BAA4B;AAC5B,+BAA+B;AAC/B,wDAAwD;AACxD,kCAAkC;AAClC,sCAAsC;AACtC,gCAAgC;AAChC,0BAA0B;AAC1B,6BAA6B;AAC7B,YAAY;;AAEZ,0CAA0C;AAC1C,2BAA2B;AAC3B,4BAA4B;AAC5B,YAAY;;AAEZ,yCAAyC;AACzC,2EAA2E;AAC3E,+BAA+B;AAC/B,yCAAyC;AACzC,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,kCAAkC;AAClC,4CAA4C;AAC5C,yCAAyC;AACzC,YAAY;;AAEZ,gDAAgD;AAChD,2EAA2E;AAC3E,+BAA+B;AAC/B,YAAY;;AAEZ,iDAAiD;AACjD,2EAA2E;AAC3E,+BAA+B;AAC/B,4BAA4B;AAC5B,yCAAyC;AACzC,wCAAwC;AACxC,yCAAyC;AACzC,kCAAkC;AAClC,iCAAiC;AACjC,YAAY;;AAEZ,+CAA+C;AAC/C,2EAA2E;AAC3E,+BAA+B;AAC/B,4BAA4B;AAC5B,yCAAyC;AACzC,wCAAwC;AACxC,yCAAyC;AACzC,kCAAkC;AAClC,YAAY;;AAEZ,wCAAwC;AACxC,sCAAsC;AACtC,yCAAyC;AACzC,wCAAwC;AACxC,2BAA2B;AAC3B,6BAA6B;AAC7B,4BAA4B;AAC5B,gCAAgC;AAChC,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA,K;;AAEA,yCAAyC,QAAQ;AACjD;AACA,mCAAmC;;AAEnC;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD;;AAEhD,kDAAkD,QAAQ;AAC1D;AACA;;AAEA,6BAA6B;AAC7B,aAAa;AACb;AACA;AACA;;AAEA,qBAAqB;AACrB;;AAEA,eAAe;;AAEf;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA,K;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,kE;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mE;;;;;;;;;;AC9MsB;AACA;;AAEtB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4E;;AAEA;;AAEA,sDAAsD;AACtD,gDAAgD;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;;AAEA;;AAEA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA,2CAA2C;AAC3C;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;ACpRsB;AACA;AACtB;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA,8F;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,8C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA,yEAAyE;AACzE;;AAEA;AACA;;AAEA,UAAU,kBAAkB;AAC5B;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;;;;;;;;ACpCA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kFAAkF;;AAElF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6D;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA,aAAa;;AAEb;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gCAAgC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,K;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA,8BAA8B;;AAE9B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,sC;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,QAAQ;AACzD,uE;AACA;;AAEA,SAAS;AACT;;AAEA;AACA,iDAAiD,QAAQ;AACzD,mE;AACA;AACA;;;AAGA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qFAAqF;AACrF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA,qCAAqC,E;;AAErC;AACA,mEAAmE,QAAQ;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF,oG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,E;;AAErC;AACA;AACA;AACA,qCAAqC,E;AACrC,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF,gG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA,6BAA6B;AAC7B;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF,oG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA,iCAAiC;;AAEjC,8DAA8D;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,E;AAC7B;AACA;AACA,qB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,E;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,S;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C;AAC9C;;AAEA;AACA,2EAA2E;AAC3E,kGAAkG;AAClG,mEAAmE,+B;AACnE;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAA+D,gCAAgC;AAC/F;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yFAAyF,gCAAgC;AACzH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,iDAAiD,QAAQ;AACzD,+D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,oD;;AAEA,qDAAqD;AACrD,yBAAyB;AACzB;;AAEA,+CAA+C;AAC/C,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,8B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2EAA2E,uBAAuB;;AAElG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;;AAEA,8CAA8C;AAC9C;AACA;;AAEA,4CAA4C;AAC5C;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iB;;AAEA;AACA;AACA;AACA,iB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAmE,QAAQ;AAC3E;;AAEA;AACA,sC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,+FAA+F,yBAAyB;;AAExH;AACA;AACA;;AAEA,8CAA8C;AAC9C,+D;AACA,qB;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;;AAEA;AACA,qD;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA,yD;AACA;AACA;AACA;;AAEA,6C;AACA;;AAEA;AACA,KAAK,yCAAyC;AAC9C;AACA;AACA;AACA,kC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gHAAgH,yBAAyB;AACzI;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;;AAEA;AACA,kC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gHAAgH,yBAAyB;AACzI;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,+C;AACA,+C;AACA,+C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+B;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;;AAEA;AACA;AACA;AACA,kD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,QAAQ;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;;;;;;;;;;;;;;AClhCsB;AACA;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,8CAA8C,0BAA0B;AACxE,iDAAiD,wBAAwB;AACzE,0CAA0C,yBAAyB;AACnE,0CAA0C,sCAAsC;AAChF,2CAA2C,sCAAsC;;AAEjF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;AACxB,4BAA4B;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD,uBAAuB,wBAAwB;AAClG,oDAAoD,sBAAsB,wBAAwB;AAClG,oDAAoD,uBAAuB,uBAAuB;AAClG,oDAAoD,uBAAuB,wBAAwB;AACnG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gC;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,kD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA,qD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK,OAAO;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,qF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4EAA4E;;AAE5E,iC;AACA,0C;;AAEA;AACA;AACA,8CAA8C,QAAQ;AACtD,uCAAuC;AACvC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,iD;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,QAAQ;AACtD,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wC;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wC;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2C;AACA,sD;;AAEA;AACA;AACA,wC;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;;AAEA;AACA,S;;AAEA,gDAAgD,QAAQ,OAAO;AAC/D,sC;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;AAChC;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;;AAEA,yC;AACA;AACA,sC;AACA;;AAEA,gCAAgC;AAChC,4B;;AAEA,sDAAsD,QAAQ;AAC9D;AACA;AACA;;AAEA,yC;AACA;AACA,sC;AACA;;AAEA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC;AACpC;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;;AAEA,yC;AACA;AACA,0C;AACA;;AAEA,oCAAoC;AACpC,4B;;AAEA,sDAAsD,QAAQ;AAC9D;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA,yC;AACA;AACA,0C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,2CAA2C;AAC3C;AACA,SAAS;;AAET;AACA;AACA,+KAA+K;;AAE/K,+B;AACA;AACA,yD;AACA;;AAEA;AACA,0DAA0D;;AAE1D;AACA;;AAEA;AACA,wCAAwC;;AAExC;;AAEA;;AAEA;AACA;AACA,iKAAiK;;AAEjK;AACA;;AAEA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,8C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;;AAEA,oC;AACA,0E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,kD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kD;AACA;;AAEA;AACA,sC;AACA;AACA;;AAEA;AACA;;AAEA,oC;AACA,0C;;AAEA;AACA;;AAEA;AACA,8B;AACA;;;AAGA;;AAEA;;AAEA,kD;;AAEA;AACA,8B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,kD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,8DAA8D,2BAA2B;AACzF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yFAAyF,2BAA2B;AACpH;;AAEA;AACA;;AAEA,wDAAwD,QAAQ;AAChE;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uC;;AAEA;AACA;;;AAGA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C,4B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,4C;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8B;AACA;;AAEA,yE;AACA;;;AAGA;;;;;;;;;;;;;;ACh3BA;AACA;AACA;AACA;AACsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,SAAS;AACT,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA,SAAS;AACT,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA,aAAa;AACb,gDAAgD,QAAQ;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,gC;AACA,kC;AACA,kC;AACA;AACA,iC;AACA,mC;AACA,mC;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA,oC;AACA,sC;AACA,sC;AACA;AACA,qC;AACA,uC;AACA,uC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iEAAiE;AACjE;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mDAAmD;AACnD;;AAEA,mDAAmD;AACnD;;;AAGA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,gC;AACA,kC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA,iC;AACA,mC;AACA,mC;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA,oC;AACA,sC;AACA,sC;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;;AAGA,qC;AACA,uC;AACA,uC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA,sFAAsF,QAAQ;AAC9F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,E;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA,gC;AACA,kC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iC;AACA,mC;AACA,mC;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA,oC;AACA,sC;AACA,sC;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,qC;AACA,uC;AACA,uC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAe,OAAO;;AAEtB;AACA;;AAEA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC,kCAAkC;;AAElC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sD;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA,qCAAqC,QAAQ,S;AAC7C;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA,oCAAoC,QAAQ,S;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,QAAQ,O;AAChD;AACA;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,wC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,0CAA0C;;AAE1C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH;;;AAGjH;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH;;AAEjH,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH;;AAEjH;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH;;AAEjH,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH;;AAEjH,sD;AACA,yE;AACA;AACA;AACA;AACA;AACA,iHAAiH;;AAEjH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA,SAAS;;AAET;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,6EAA6E,YAAY;AACzF;AACA;;AAEA;AACA;;;;AAIA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0CAA0C,eAAe;AACzD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,gCAAgC,4BAA4B;AAC5D,iCAAiC,6BAA6B;;AAE9D;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,iCAAiC;AACjC;AACA;AACA;;AAEA,+BAA+B;;AAE/B;;AAEA,gCAAgC;AAChC;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA,kCAAkC;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,2EAA2E;;AAEhI,SAAS;;AAET;;AAEA;;AAEA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,QAAQ;;AAEtD;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,wGAAwG;AAC7J,SAAS;;AAET;AACA;AACA,6CAA6C;;AAE7C,qDAAqD,6GAA6G;AAClK;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;;AAEvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;;AAE3D,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;AAC3D;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;;AAEvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD,oCAAoC,mBAAmB;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,QAAQ;AAChD,iC;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C,gC;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA,0CAA0C,QAAQ;AAClD,mC;AACA;;AAEA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,uCAAuC,8BAA8B;AACrE,uCAAuC,8BAA8B;AACrE,uCAAuC,8BAA8B;;AAErE,uCAAuC,8BAA8B;AACrE,uCAAuC,8BAA8B;AACrE,uCAAuC,8BAA8B;;AAErE;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,qB;AACA;;AAEA;;;;;;;;;;;;ACrxDsB;AACtB,UAAU,cAAc,sBAAsB;;AAE9C;AACA;AACA,mBAAmB;;;AAGnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C,2EAA2E;AAC3E;AACA;AACA;AACA,sHAAsH;AACtH;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8C;;AAEA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA;AACA,0BAA0B;;AAE1B;AACA,gCAAgC;AAChC;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2B;;AAEA;AACA,+B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,M;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,kD;;AAEA;AACA;AACA;AACA,kD;;AAEA;AACA;AACA;AACA,kD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AClUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;;AAEA,wDAAwD,QAAQ;AAChE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB;;AAEnB;;AAEA,0B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B,sCAAsC;;AAErE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,2EAA2E;AAC3E,6EAA6E;AAC7E,0EAA0E;AAC1E,iFAAiF;AACjF;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,2EAA2E;;AAE3E;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,kBAAkB;AACtD;;AAEA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE;AACA;;;AAGA;;;;;;;;;;;;;;ACjOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,iC;AACA;;;AAGA;AACA,8C;AACA;;;AAGA;AACA,4C;AACA,EAAE;;;AAGF;AACA;AACA,sC;AACA;;;AAGA;AACA,kC;AACA;;;AAGA;AACA,+C;AACA;;;AAGA;AACA,6C;AACA,EAAE;;AAEF;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,sD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,+CAA+C,yBAAyB;AACxE;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA,S;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;;ACxeA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2C;AACA,KAAK;AACL,yBAAyB,iFAAiF;AAC1G;;AAEA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA;AACA,a;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,oB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7LsB;AACE;AACM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB;AACpB,wBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,0C;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA,0B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8C;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA,KAAK;;AAEL;AACA,0B;AACA,gC;;AAEA;AACA;AACA,8C;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,6C;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa;AAC9C;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA,aAAa;AACb,uB;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA,YAAY;AACZ;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,8FAA8F;AAC9F,yHAAyH,mBAAmB;AAC5I,4HAA4H,mBAAmB;AAC/I,gIAAgI,mBAAmB;AACnJ,oIAAoI;AACpI,gIAAgI;AAChI,wIAAwI;AACxI,0IAA0I;AAC1I,uGAAuG,wBAAwB;AAC/H,+GAA+G;AAC/G,wIAAwI;AACxI,oJAAoJ;AACpJ,gGAAgG,eAAe,8CAA8C,mBAAmB,EAAE;AAClL,sGAAsG,eAAe,kEAAkE,mBAAmB,EAAE;AAC5M,2GAA2G;AAC3G,sGAAsG;AACtG,uGAAuG;AACvG,+GAA+G;AAC/G,2GAA2G;AAC3G,2GAA2G;AAC3G,0GAA0G;AAC1G,2GAA2G;AAC3G,6GAA6G;AAC7G,4GAA4G;AAC5G,0GAA0G,kGAAkG;AAC5M,yGAAyG;AACzG,2GAA2G;AAC3G,8GAA8G;AAC9G,0GAA0G;AAC1G,2GAA2G;AAC3G,kJAAkJ;AAClJ,mJAAmJ;AACnJ,4GAA4G;AAC5G,2GAA2G;AAC3G,gHAAgH;AAChH,oHAAoH;AACpH,4GAA4G;AAC5G,2GAA2G;AAC3G,0GAA0G;AAC1G,+MAA+M;AAC/M,8HAA8H;AAC9H,wGAAwG;AACxG,uGAAuG;AACvG,uIAAuI;AACvI,gIAAgI;AAChI,8HAA8H;AAC9H,kJAAkJ;AAClJ,6IAA6I;AAC7I,8GAA8G;AAC9G,sFAAsF;AACtF,4GAA4G;AAC5G,wGAAwG;AACxG,uGAAuG;AACvG,yGAAyG;AACzG,0GAA0G;AAC1G,4KAA4K;AAC5K,qKAAqK;AACrK,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yC;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,6B;AACA;AACA;;AAEA;;AAEA,gDAAgD;AAChD;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA,sE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK,sBAAsB;AAC3B;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,gFAAgF;AACxI;;AAEA;AACA,qEAAqE,gFAAgF;AACrJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,mCAAmC;AACnC,sCAAsC;;AAEtC;;AAEA;;AAEA,+CAA+C;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,yDAAyD,QAAQ;AACjE;;AAEA;AACA;AACA;AACA,qEAAqE;AACrE,yJAAyJ;AACzJ;;AAEA;AACA;AACA,qEAAqE;AACrE,yJAAyJ;AACzJ;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D,gJAAgJ;AAChJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D,iJAAiJ;AACjJ;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;;;;;;;;;;;;ACj2CqC;AACf;AACtB;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oG;AACA,+E;AACA;AACA;;AAEA;AACA;;AAEA,wDAAwD,QAAQ;AAChE,yDAAyD;AACzD,6G;AACA,wF;;AAEA;AACA;AACA;;AAEA,uG;AACA,aAAa;AACb,8E;;AAEA;AACA;;AAEA,wDAAwD,QAAQ;AAChE,2F;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;;AAEA,+D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA,iD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD,QAAQ;AAC5D;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+I;AACA;AACA;AACA,6N;AACA,aAAa;;AAEb,uE;AACA,SAAS;AACT,wE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,+BAA+B;AAC/B;AACA;;AAEA,oG;;AAEA;AACA;AACA;AACA,kD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA,4G;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,4C;;AAEA;AACA;AACA;AACA,6B;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,mBAAmB,UAAU;AAC7B,mBAAmB,UAAU;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,sC;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA,S;;AAEA;AACA;AACA,S;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC;;AAEA;;AAEA,sEAAsE;AACtE;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA,mB;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uC;;AAEA;AACA;AACA,0C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uC;;AAEA;AACA;AACA,0C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,U;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC,kBAAkB,eAAe;AACjC,qBAAqB,qBAAqB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gF;AACA,iCAAiC;;AAEjC;AACA,uC;;AAEA,KAAK,OAAO;;;AAGZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6EAA6E;AAC7E;;AAEA;;AAEA;AACA;AACA,4E;;AAEA;;AAEA,qCAAqC;AACrC;;AAEA;AACA;AACA,e;AACA;;;AAGA;;;;;;;;;;;;;;;;ACz8BsB;AACE;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,O;;AAEA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4D;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,kC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;;AAEA,4C;AACA;AACA,SAAS;AACT;;AAEA;AACA;;;AAGA;AACA;AACA,qFAAqF,6DAA6D;AAClJ;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB;;AAElB;AACA;AACA,wD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B,kCAAkC;AAClC,gCAAgC;AAChC,SAAS;AACT,oCAAoC;AACpC;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0EAA0E;AAC1E,0EAA0E;;AAE1E;AACA;AACA;;AAEA,4DAA4D;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAoE;AACpE,iEAAiE;;AAEjE;AACA,qB;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA,yC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,0DAA0D;AAC1D,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uFAAuF;;AAEvF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uFAAuF;;AAEvF,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,K;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;AC/hBqC;AACb;AACF;AACtB;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0B;AACA,mC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,qC;AACA;;AAEA;AACA,uC;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;AACA,uBAAuB;AACvB;AACA,+BAA+B;AAC/B,qBAAqB;AACrB,uBAAuB;AACvB,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD;;AAEzD;AACA;AACA,mDAAmD;;AAEnD,yCAAyC,QAAQ;AACjD,sEAAsE;AACtE;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,K;;AAEA;;AAEA;AACA,8DAA8D;AAC9D,8DAA8D;AAC9D,oEAAoE;;AAEpE;AACA,sDAAsD;AACtD;AACA;;;;AAIA,wEAAwE;;AAExE,qFAAqF;AACrF,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6DAA6D;AAC7D,6DAA6D;;AAE7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4EAA4E;AAC5E,SAAS;AACT,2EAA2E;AAC3E;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,O;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,sC;AACA;AACA;AACA;AACA,0C;AACA,4B;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;AACA,+C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kC;AACA,kC;AACA,mB;;AAEA;;AAEA;AACA,0D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mC;AACA;;;AAGA,+FAA+F;AAC/F;AACA;AACA;;AAEA,qB;AACA,qB;AACA,mB;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA,qB;AACA;;AAEA,qB;AACA;;AAEA,qB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mB;AACA;;AAEA;AACA;AACA;;AAEA,4D;AACA,qB;AACA;;AAEA,kCAAkC;AAClC,4C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,0C;AACA,6B;AACA,2B;;AAEA;;AAEA,6B;AACA;;AAEA,6B;AACA,0C;AACA;;AAEA,6B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oD;AACA,8C;;AAEA;;AAEA,oD;AACA;;AAEA,8C;AACA,oD;AACA;;AAEA,oD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC;AAClC;;AAEA,+BAA+B,gBAAgB;AAC/C,+BAA+B,gBAAgB;AAC/C,+BAA+B,gBAAgB;AAC/C,+BAA+B,iBAAiB;;AAEhD,gCAAgC,iBAAiB;AACjD,gCAAgC,iBAAiB;AACjD,gCAAgC,iBAAiB;AACjD,gCAAgC,iBAAiB;AACjD,aAAa;;AAEb,4C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,sCAAsC;AACtC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT,wC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA,+C;AACA,6I;AACA,K;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,UAAU,UAAU;AACrD,iBAAiB,0BAA0B,UAAU;AACrD,iBAAiB,UAAU,2BAA2B;AACtD,6CAA6C,sCAAsC,sCAAsC;AACzH,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA,uB;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA,2C;AACA,+C;AACA,+C;AACA;;AAEA,kC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,mBAAmB,UAAU;AAC7B,mBAAmB,UAAU;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3wBwB;AACxB;;AAEA;AACA;AACA;;;AAGA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA,KAAK;;AAEL,kC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA,gD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sBAAsB;AACtB,wJ;AACA;AACA;AACA,4C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6E;AACA,+BAA+B,wBAAwB,sBAAsB,EAAE,EAAE;AACjF,K;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,0BAA0B,oBAAoB;AAC9C,wD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA,sBAAsB;AACtB,uBAAuB;AACvB,kBAAkB;AAClB,sCAAsC;AACtC,gCAAgC;AAChC,4BAA4B;AAC5B,uBAAuB;AACvB,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;;AAEA;AACA;;AAEA,0EAA0E;AAC1E,0EAA0E;;AAE1E;AACA;AACA;;AAEA,4DAA4D;;AAE5D;AACA;AACA;;AAEA,uDAAuD;;AAEvD,gEAAgE;AAChE,gEAAgE;;AAEhE,4DAA4D;AAC5D,4DAA4D;;AAE5D,0DAA0D;AAC1D,0DAA0D;;AAE1D;;AAEA;AACA,gEAAgE;AAChE,KAAK;AACL,6DAA6D;AAC7D,mEAAmE;AACnE;AACA;;AAEA;AACA;;AAEA,kG;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;;AAEA,2BAA2B,kBAAkB;AAC7C,sEAAsE;AACtE;;AAEA,0C;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA,mEAAmE;AACnE,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,6CAA6C,QAAQ;AACrD,gEAAgE;AAChE;;AAEA,uBAAuB,kBAAkB;AACzC,kEAAkE;AAClE;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;AACA;;;AAGA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,8C;;AAEA,2BAA2B,gBAAgB;AAC3C,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,OAAO;AAC1B;AACA,8C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,gBAAgB;AACnC,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;AAEA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;AC1dA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gD;;AAEA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qC;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,wDAAwD;AACxD,0DAA0D;AAC1D,4DAA4D;AAC5D;;AAEA;AACA,6DAA6D;AAC7D,+DAA+D;AAC/D,iEAAiE;AACjE;;AAEA;AACA;;;AAGA;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY;AACZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,+D;AACA;;;AAGA;AACA;AACA,qB;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,iD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,wCAAwC;AACxC;;AAEA,iDAAiD,QAAQ;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB,cAAc;AACvC;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,6C;AACA;AACA;AACA;AACA,S;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wB;AACA,KAAK;AACL;AACA;AACA;;;AAGA;;;;;;;;;;;;ACpMA;;AAEA;AACA;;;AAGA;AACA;AACA,wD;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,yBAAyB;;AAEzB;;AAEA,uBAAuB,cAAc;AACrC,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,S;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,sBAAsB;AACtB;AACA;AACA;;;AAGA,2BAA2B,eAAe;AAC1C;AACA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,S;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;AACA,uB;AACA,4B;AACA,gC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wBAAwB,kCAAkC,IAAI;AACrF,4B;AACA,kCAAkC;AAClC;AACA,GAAG;;;AAGH;AACA;;AAEA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,2B;AACA;AACA;AACA;AACA,2B;AACA,gC;AACA,oC;;AAEA,sDAAsD,QAAQ;AAC9D;AACA,S;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,gB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACnNA;AAAA;;AAEsB;AACA;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA,2BAA2B;AAC3B,wBAAwB;AACxB,6BAA6B;AAC7B;AACA;;AAEA;;AAEA,yDAAyD;;AAEzD;AACA,wEAAwE;AACxE,KAAK;AACL;AACA;;AAEA,iEAAiE;AACjE,2CAA2C;;AAE3C;AACA;;AAEA,2DAA2D;AAC3D,2DAA2D;AAC3D,2DAA2D;;AAE3D,2DAA2D;AAC3D,2DAA2D;AAC3D,2DAA2D;;AAE3D;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB;;AAEvB,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB,iBAAiB;;AAEjB,oBAAoB;AACpB,oBAAoB;;AAEpB,KAAK;AACL;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,uC;AACA;AACA,SAAS;AACT,kC;AACA;AACA;AACA,KAAK;AACL;AACA,uC;AACA;AACA,SAAS;AACT,kC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;;AAEzB,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,KAAK;AACL,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,qCAAqC;AACrC;AACA;AACA,aAAa;AACb,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA,iCAAiC;AACjC;AACA;AACA,SAAS;AACT,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB,iBAAiB;;AAEjB,oBAAoB;AACpB,oBAAoB;;AAEpB,KAAK;AACL;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA,sBAAsB,QAAQ;;AAE9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,UAAU,UAAU;AACrD,iBAAiB,0BAA0B,UAAU;AACrD,iBAAiB,UAAU,2BAA2B;AACtD,6CAA6C,sCAAsC,sCAAsC;AACzH,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;;ACx0BA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA,sBAAsB,gB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C,mE;AACA,sEAAsE;AACtE;AACA;;;AAGA,6BAA6B;AAC7B,qB;AACA,6BAA6B;;AAE7B;AACA;AACA,sEAAsE;AACtE;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6B;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;;AAEA,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA,gC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;;AAEA,gEAAgE,QAAQ;AACxE;AACA;AACA,8B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iB;AACA;;AAEA,SAAS;;AAET;;AAEA;AACA,qCAAqC,QAAQ;AAC7C,gEAAgE;AAChE,oD;AACA,oD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oDAAoD,QAAQ;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;AC1PsB;AACtB;AACsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA,mCAAmC;;AAEnC,wBAAwB;AACxB;AACA,+BAA+B;AAC/B,mCAAmC;AACnC;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;AAC/D,+EAA+E;AAC/E,gFAAgF;;AAEhF;AACA;;;AAGA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,M;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,0D;AACA;AACA;AACA;AACA,0D;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB,cAAc;AACvC;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,6B;AACA;;AAEA;;AAEA;AACA,4GAA4G;AAC5G;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4EAA4E;AAC5E;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA,gCAAgC,sBAAsB;AACtD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA,e;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,6B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,wD;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iC;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA,iC;;AAEA,2BAA2B,OAAO;AAClC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oB;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qC;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,4BAA4B;AAC5B;AACA;AACA,iBAAiB;AACjB,6D;;AAEA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA,yB;AACA,qBAAqB;;AAErB;AACA;AACA,4F;AACA,4F;AACA,4F;AACA,4F;AACA,4F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;AACxB,4BAA4B;AAC5B,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,0BAA0B;AACnC,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,OAAO;AAChB,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,KAAK,0BAA0B;AAC/B,4BAA4B;AAC5B,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,0BAA0B;AACnC,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,OAAO;AAChB,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,KAAK,OAAO;AACZ,4BAA4B;AAC5B,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,0BAA0B;AACnC,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS,OAAO;AAChB,yBAAyB;AACzB;AACA,aAAa,mBAAmB;AAChC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,K;;AAEA;;AAEA;AACA,8B;AACA;AACA,qB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD,4DAA4D;AAC5D,+EAA+E;;AAE/E,8BAA8B;;AAE9B;AACA,8B;AACA;AACA,qB;AACA,kDAAkD;;AAElD,oBAAoB;AACpB;AACA,yBAAyB;AACzB;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,SAAS;AACT;AACA;;AAEA,KAAK;AACL,oBAAoB;AACpB;AACA,yBAAyB;AACzB;AACA,aAAa,OAAO;AACpB;AACA;AACA,S;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,+B;;AAEA;AACA;AACA,mC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kH;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET,yC;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC;AACtC;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA,sCAAsC;AACtC;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kF;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB;AACnB;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA,0B;AACA;AACA;AACA,KAAK;AACL;AACA,sB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,iD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA,yC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,kC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,QAAQ;AACxD;;AAEA,+BAA+B,OAAO;AACtC;;AAEA;AACA;AACA;AACA;AACA,6B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;;AAEA;AACA;;AAEA;AACA,kEAAkE;AAClE,kFAAkF;AAClF,kEAAkE;;AAElE,kFAAkF;AAClF,kFAAkF;;AAElF,kEAAkE;AAClE,kFAAkF;AAClF,kEAAkE;AAClE;;AAEA;AACA;AACA;;AAEA;AACA,mI;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,S;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wD;AACA,0E;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,4GAA4G,iDAAiD;AAC7J;AACA;;AAEA;;AAEA,uEAAuE;AACvE,+B;AACA,S;AACA;;AAEA;AACA,sC;AACA,mC;AACA;AACA;AACA,KAAK;;AAEL;AACA,uC;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA,SAAS;AACT,sC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,4D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4D;;AAEA;AACA,E;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0B;AACA;AACA;AACA,KAAK;AACL;AACA,sB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA,yC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wD;AACA,0E;AACA;;AAEA,8B;AACA;;AAEA;;AAEA;AACA,sC;AACA,mC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,kDAAkD;AAClD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;;AAEnD,mDAAmD;AACnD,6FAA6F;AAC7F;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,mC;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,oC;;AAEA;AACA,+D;AACA,gD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA,E;;;AAGA;;;;;;;;;;;;ACxxDsB;;AAEtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,K;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,K;;AAEA,kG;AACA,kG;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,K;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kD;AACA;AACA,yC;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mD;AACA;;AAEA;AACA;AACA;AACA,S;AACA,K;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC,uCAAuC;AACvC,yCAAyC;AACzC,2CAA2C;AAC3C,6CAA6C;AAC7C,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C,6CAA6C;AAC7C,+CAA+C;AAC/C,iDAAiD;AACjD,mDAAmD;AACnD,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C,+DAA+D;AAC/D,+CAA+C,YAAY,wBAAwB;AACnF,+DAA+D,YAAY,wCAAwC;AACnH,+CAA+C,YAAY,wBAAwB,YAAY,wBAAwB;AACvH,+DAA+D,YAAY,wCAAwC,YAAY,wCAAwC;AACvK;AACA;AACA;;AAEA;AACA;;AAEA,+C;AACA,+C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,iD;AACA,iD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oC;AACA,aAAa;;AAEb;;AAEA;AACA,wD;AACA;;AAEA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA,kC;AACA,kC;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,+B;AACA,+B;AACA;AACA;;;AAGA;AACA,sC;AACA,sC;AACA;AACA;;;AAGA;AACA,kC;AACA,kC;AACA;AACA;;;AAGA;AACA,kC;AACA,kC;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA,KAAK,yDAAyD;AAC9D;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA,K;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;;AC/ZwB;AACM;;AAE9B;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,kD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,2DAA2D,mDAAmD;;AAE9G;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,uDAAuD,yDAAyD;;AAEhH;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT,oDAAoD,iDAAiD;;AAErG;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT,oDAAoD,iDAAiD;;AAErG;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,SAAS;AACT;AACA;;AAEA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA,wB;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA,kC;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA,qC;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA,mBAAmB,IAAI,EAAE,QAAQ,EAAE,SAAS;AAC5C,mBAAmB,IAAI,EAAE,EAAE,EAAE,EAAE;AAC/B,mBAAmB,cAAc;AACjC,mBAAmB,kBAAkB;AACrC,mBAAmB,IAAI,EAAE,aAAa;AACtC;AACA,oBAAoB,aAAa,kCAAkC,IAAI,EAAE,EAAE,EAAE,EAAE;;AAE/E;AACA;AACA;;AAEA;AACA,mE;AACA;AACA;AACA;AACA,4B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C;AAC/C;AACA,oDAAoD;AACpD;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,kC;AACA;AACA;;;AAGA;;;;;;;;;;;;ACvPwB;AACxB;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA,mB;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,wJ;;AAEA;AACA;;;AAGA;AACA,8C;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;AAEA;AACA,6DAA6D;AAC7D,6DAA6D;;AAE7D;AACA;AACA;;AAEA,4CAA4C;;AAE5C,mBAAmB,WAAW;AAC9B,8CAA8C;AAC9C;;AAEA,uBAAuB,UAAU;AACjC,gDAAgD;AAChD;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA,SAAS,OAAO;AAChB,0DAA0D;AAC1D;AACA;;AAEA,gB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK,mCAAmC;AACxC;AACA,KAAK,kCAAkC;AACvC;AACA,KAAK,OAAO;AACZ,kC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,+CAA+C,+BAA+B;AAC9E;;;AAGA;;;;;;;;;;;;AC7NoD;AAC9B;;AAEtB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,0CAA0C,+DAA+D;AACzG,6CAA6C,wEAAwE;AACrH,wCAAwC,oBAAoB;AAC5D,qCAAqC,iBAAiB;AACtD,sCAAsC,kBAAkB;AACxD,qCAAqC,iBAAiB;AACtD,4CAA4C,wBAAwB;AACpE,uCAAuC,mBAAmB;;;AAG1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iD;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA,6CAA6C;AAC7C;;;AAGA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iC;AACA,iC;AACA,iC;;AAEA,iC;AACA,iC;AACA,iC;AACA,KAAK;AACL,sB;AACA,sB;AACA,sB;;AAEA,sB;AACA,sB;AACA,sB;AACA;;AAEA;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;;AAE9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;AAC9B;AACA,gBAAgB,cAAc,a;;;AAG9B;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;;AAE3C;AACA,8DAA8D,GAAG;AACjE,UAAU,GAAG;AACb;AACA,mCAAmC;AACnC,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACxYoD;AAC9B;AAC6E;;AAEnG;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,oC;;AAEA;AACA,mBAAmB,iBAAiB;AACpC,wC;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,sB;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK,OAAO;;AAEZ;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA,4G;;AAEA;AACA;AACA;AACA;AACA,yE;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+B;AACA;;AAEA,gCAAgC;AAChC;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gC;AACA;;AAEA,iCAAiC;AACjC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,+B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gC;AACA;;AAEA,iCAAiC;AACjC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,+B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;;AAGA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,uBAAuB,QAAQ;;AAE/B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;;AAEA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+C;AACA;AACA,6BAA6B;;AAE7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2G;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;;;AAGA,6CAA6C;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mCAAmC;;AAEnC,8DAA8D;;AAE9D,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAiC;;AAE9C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA,iB;AACA;;AAEA,SAAS,iCAAiC;;AAE1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,a;AACA;;AAEA,KAAK;AACL;AACA;AACA,S;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB,oF;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,qB;AACA,6BAA6B;AAC7B,iBAAiB;AACjB,qE;AACA;;AAEA;AACA;AACA,qB;AACA,6BAA6B;AAC7B;;AAEA,aAAa;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA,iB;AACA,kCAAkC;AAClC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,wDAAwD,QAAQ;AAChE;;AAEA;;AAEA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+B;AACA,+B;AACA,+B;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;;AAEA;AACA;;AAEA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,mFAAmF;AACnF;AACA;AACA,iB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,4BAA4B;AAC5B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,mB;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,SAAS;;AAET;;AAEA,2BAA2B,8BAA8B,6BAA6B,EAAE;AACxF,2BAA2B,8BAA8B,6BAA6B,EAAE;AACxF,2BAA2B,8BAA8B,6BAA6B,EAAE;AACxF,0BAA0B,8BAA8B,6BAA6B;AACrF,kBAAkB,8BAA8B,6BAA6B;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;;AAEA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,e;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,KAAK;AACd;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;;AAEA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACpuEA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD,iDAAiD;;AAEjD;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C,yBAAyB,sBAAsB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,2BAA2B;AAChD,yBAAyB,sBAAsB;;AAE/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL,yBAAyB,qBAAqB;AAC9C,6BAA6B,sBAAsB;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;ACtPA;AACA;AACA;AACA;;AAEA,+DAA+D,MAAM;AACrE,2EAA2E,UAAU;AACrF;AACA;AACA;AACA,sF;AACA;;AAEA;AACA,qCAAqC,MAAM;AAC3C,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;AAC9C,0CAA0C,QAAQ;AAClD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,UAAU;AACpB,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,qEAAqE;AACrE,iEAAiE,UAAU;;AAE3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA,8D;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,iD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;;AAEA;;AAEA,6BAA6B,QAAQ;;AAErC;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qEAAqE;AACrE,iEAAiE,UAAU;;AAE3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA,8D;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,iD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,6BAA6B,QAAQ;;AAErC;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;;AAEA;;AAEA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;;;AAGQ;;;;;;;;;;;AC7hBR;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,qFAAqF,E;AAC/H;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,yCAAyC,sFAAsF,8CAA8C,4CAA4C;AACzN,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,0DAA0D;AAC1D;;;AAGA;AACA,8DAA8D;AAC9D;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uD;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;AACA;;AAEA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA,8BAA8B,qBAAqB;AACnD,gCAAgC,uBAAuB;AACvD,+BAA+B,qBAAqB;AACpD,8BAA8B,oBAAoB;AAClD,+BAA+B,sBAAsB;AACrD,gCAAgC,sBAAsB;;AAEtD;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;;;;;AC3SqC;AACrC;AACsB;AACE;;AAExB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,0CAA0C,QAAQ;AAClD,+B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,0BAAmE;AACnE,0BAAoE;AACpE,0BAAoE;AACpE,0BAAqE;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sGAAuH;AACvH,oDAAqE;AACrE,oDAAqE;AACrE,uGAAyH;AACzH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0DAA2E;AAC3E,0DAA2E;AAC3E,0DAA2E;AAC3E,0DAA4E;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD,4CAA4C;AAC7F,iDAAiD,4CAA4C;AAC7F,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD;;AAEA,0BAA0B;;AAE1B;AACA,oDAAoD;AACpD;AACA;;AAEA,oEAAoE;AACpE;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;AAGA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;;AAEA,uCAAuC;AACvC,sFAAsF;AACtF;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C,yFAAyF;;AAEzF;AACA,+CAA+C;AAC/C,8FAA8F;AAC9F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,yFAAyF;;AAEzF;AACA,+CAA+C;AAC/C,8FAA8F;AAC9F;;AAEA;AACA;;AAEA;;AAEA,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,4FAA4F;AAC5F;AACA;;AAEA;AACA;;AAEA,2CAA2C;AAC3C,yFAAyF;AACzF;AACA;;AAEA;AACA;;AAEA,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C,4FAA4F;AAC5F;AACA;;AAEA;AACA;;AAEA,2CAA2C;AAC3C,2FAA2F;AAC3F,2CAA2C;AAC3C,yFAAyF;AACzF,2CAA2C;AAC3C;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,mBAAmB;AAChD;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,yDAAyD;AACzD,sDAAsD;AACtD,iDAAiD;AACjD,6DAA6D;AAC7D,kDAAkD;AAClD,kDAAkD;AAClD,6CAA6C;AAC7C,0CAA0C;AAC1C,uDAAuD;AACvD,4CAA4C,mBAAmB;AAC/D,kDAAkD;AAClD,6CAA6C;AAC7C;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;;;;;;AC3yBA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,kBAAkB;;;AAG5D,0CAA0C,kBAAkB;;;AAG5D,iDAAiD,sBAAsB;;;AAGvE,wE;;;;;;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG,wGAAwG;AACxG,uGAAuG;;AAEvG;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kGAAkG;AAClG,qGAAqG;AACrG,oGAAoG;AACpG,uGAAuG;AACvG,oGAAoG;AACpG,oGAAoG;AACpG,uGAAuG;AACvG,qGAAqG;AACrG,uGAAuG;AACvG,uGAAuG;AACvG,yGAAyG;AACzG,uGAAuG;AACvG,yGAAyG;AACzG,6HAA6H;;AAE7H;AACA;AACA,qGAAqG;AACrG;AACA,kGAAkG;AAClG,qGAAqG;;AAErG,8HAA8H;AAC9H;AACA;AACA;AACA,8H;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B,uBAAuB,UAAU;;AAEjC;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,eAAe,UAAU;AACzB,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,eAAe,UAAU;AACzB,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,yCAAyC;AAC1F,+CAA+C,uDAAuD;AACtG,2CAA2C,yCAAyC;AACpF,oDAAoD,0CAA0C;AAC9F,kDAAkD,4BAA4B;AAC9E;;;AAGA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;ACvYA;AACA;AACA;AAC+D;;AAE/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gB;AACA;;;AAGA;AACA,gB;AACA;;;AAGA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA,iC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA,a;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gC;AACA,K;AACA;AACA,iC;AACA,K;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gB;AACA;;;AAGA;AACA,gB;AACA;;;AAGA;AACA,gB;AACA;;;AAGA;AACA;AACA,oB;AACA;;AAEA;AACA;;AAEA;AACA,oB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9csB;;AAEtB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;;AAEA,+BAA+B,OAAO;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sB;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sB;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,iBAAiB;AACjB;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;;AAEb;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB,yBAAyB;AACzB,OAAO,OAAO;AACd;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4D;AACA,4D;AACA,4D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEQ;;;;;;;;;;;;;;;;;ACrjB6B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA6C;AAC7C,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;;AAEA;AACA,qBAAqB,UAAU,UAAU;AACzC,aAAa,oBAAoB,UAAU;AAC3C,aAAa,UAAU,WAAW;AAClC,4BAA4B,0BAA0B,WAAW;;AAEjE;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA,uEAAuE;;AAEvE;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,K;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,c;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4FAA4F;;AAE5F;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;;AAE/B;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iC;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA,mCAAmC,eAAe;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;AACA,SAAS,K;AACT,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;AC7mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA,+EAA+E;AAC/E;;AAEA;AACA,gFAAgF;AAChF;;AAEA;AACA;;AAEA,uBAAuB,iBAAiB,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,QAAQ,SAAS,QAAQ;AAC3C,kBAAkB,QAAQ,SAAS,QAAQ;;AAE3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,QAAQ,SAAS,QAAQ;AAC3C,kBAAkB,QAAQ,SAAS,QAAQ;;AAE3C,4BAA4B;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,QAAQ;AACvB,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,QAAQ;AACvB,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5TA;AACA;AACyE;AACjC;AAC0C;AAC1D;AACF;AACQ;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGQ","file":"vts-core.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 203);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 599154e64501a632db4d","export var PJD_3PARAM = 1;\nexport var PJD_7PARAM = 2;\nexport var PJD_WGS84 = 4; // WGS84 or equivalent\nexport var PJD_NODATUM = 5; // WGS84 or equivalent\nexport var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nexport var HALF_PI = Math.PI/2;\n// ellipoid pj_set_ell.c\nexport var SIXTH = 0.1666666666666666667;\n/* 1/6 */\nexport var RA4 = 0.04722222222222222222;\n/* 17/360 */\nexport var RA6 = 0.02215608465608465608;\nexport var EPSLN = (typeof Number.EPSILON === 'undefined') ? 1.0e-10 : Number.EPSILON;\nexport var D2R = 0.01745329251994329577;\nexport var R2D = 57.29577951308232088;\nexport var FORTPI = Math.PI/4;\nexport var TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nexport var SPI = 3.14159265359;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/constants/values.js\n// module id = 0\n// module chunks = 0 1","\n\nvar vec2 = {};\n\n\nvec2.create = function (a) {\n    var b = new Array(2);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n    }\n    return b;\n};\n\n\nvar vec4 = {};\n\n\nvec4.create = function (a) {\n    var b = new Array(4);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n    }\n    return b;\n};\n\n\nvec4.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n};\n\n\nvec4.dot2 = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3];\n};\n\n\nvec4.dot3 = function (a, b, i, x, y, z) {\n    return a[0] * (b[i]-x) + a[1] * (b[i+1]-y) + a[2] * (b[i+2]-z) + a[3];\n};\n\n\nvar vec3 = {};\n\n\nvec3.create = function (a) {\n    var b = new Array(3);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n    }\n    return b;\n};\n\n\nvec3.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    return b;\n};\n\n\nvec3.add = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] += b[0];\n        a[1] += b[1];\n        a[2] += b[2];\n        return a;\n    }\n    c[0] = a[0] + b[0];\n    c[1] = a[1] + b[1];\n    c[2] = a[2] + b[2];\n    return c;\n};\n\n\nvec3.subtract = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] -= b[0];\n        a[1] -= b[1];\n        a[2] -= b[2];\n        return a;\n    }\n    c[0] = a[0] - b[0];\n    c[1] = a[1] - b[1];\n    c[2] = a[2] - b[2];\n    return c;\n};\n\n\nvec3.negate = function (a, b) {\n    b || (b = a);\n    b[0] = -a[0];\n    b[1] = -a[1];\n    b[2] = -a[2];\n    return b;\n};\n\n\nvec3.scale = function (a, b, c) {\n    if (!c || a == c) {\n        a[0] *= b;\n        a[1] *= b;\n        a[2] *= b;\n        return a;\n    }\n    c[0] = a[0] * b;\n    c[1] = a[1] * b;\n    c[2] = a[2] * b;\n    return c;\n};\n\n\nvec3.normalize = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return b;\n};\n\n\nvec3.normalize2 = function (a, i, b) {\n    var c = a[i],\n        d = a[i+1],\n        e = a[i+2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n};\n\n\nvec3.normalize3 = function (a, i, b, j) {\n    var c = a[i],\n        d = a[i+1],\n        e = a[i+2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[j] = c;\n            b[j+1] = d;\n            b[j+2] = e;\n            return b;\n        }\n    } else {\n        b[j] = 0;\n        b[j+1] = 0;\n        b[j+2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[j] = c * g;\n    b[j+1] = d * g;\n    b[j+2] = e * g;\n};\n\n\nvec3.normalize4 = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    var dd = g;\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return dd;\n};\n\n\nvec3.cross = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1];\n    a = a[2];\n    var g = b[0],\n        f = b[1];\n    b = b[2];\n    c[0] = e * b - a * f;\n    c[1] = a * g - d * b;\n    c[2] = d * f - e * g;\n    return c;\n};\n\n\nvec3.length = function (a) {\n    var b = a[0],\n        c = a[1];\n    a = a[2];\n    return Math.sqrt(b * b + c * c + a * a);\n};\n\n\nvec3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\n\nvec3.dot2 = function (a, b, i) {\n    return a[0] * b[i] + a[1] * b[i+1] + a[2] * b[i+2];\n};\n\n\nvec3.dot3 = function (a, i, b, j) {\n    return a[i] * b[j] + a[i+1] * b[j+1] + a[i+2] * b[j+2];\n};\n\n\nvec3.squareDistance = function (a, b) {\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    var dz = b[2] - a[2];\n    return dx*dx + dy*dy + dz*dz;\n};\n\n\nvec3.direction = function (a, b, c) {\n    c || (c = a);\n    var d = a[0] - b[0],\n        e = a[1] - b[1];\n    a = a[2] - b[2];\n    b = Math.sqrt(d * d + e * e + a * a);\n    if (!b) {\n        c[0] = 0;\n        c[1] = 0;\n        c[2] = 0;\n        return c;\n    }\n    b = 1 / b;\n    c[0] = d * b;\n    c[1] = e * b;\n    c[2] = a * b;\n    return c;\n};\n\n\nvec3.lerp = function (a, b, c, d) {\n    d || (d = a);\n    d[0] = a[0] + c * (b[0] - a[0]);\n    d[1] = a[1] + c * (b[1] - a[1]);\n    d[2] = a[2] + c * (b[2] - a[2]);\n    return d;\n};\n\n\nvec3.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ']';\n};\n\n\nvar mat3 = {};\n\n\nmat3.create = function (a) {\n    var b = new Array(9);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n        b[4] = a[4];\n        b[5] = a[5];\n        b[6] = a[6];\n        b[7] = a[7];\n        b[8] = a[8];\n        b[9] = a[9];\n    }\n    return b;\n};\n\n\nmat3.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    return b;\n};\n\n\nmat3.identity = function (a) {\n    a[0] = 1;\n    a[1] = 0;\n    a[2] = 0;\n    a[3] = 0;\n    a[4] = 1;\n    a[5] = 0;\n    a[6] = 0;\n    a[7] = 0;\n    a[8] = 1;\n    return a;\n};\n\n\nmat3.transpose = function (a, b) {\n    if (!b || a == b) {\n        var c = a[1],\n            d = a[2],\n            e = a[5];\n        a[1] = a[3];\n        a[2] = a[6];\n        a[3] = c;\n        a[5] = a[7];\n        a[6] = d;\n        a[7] = e;\n        return a;\n    }\n    b[0] = a[0];\n    b[1] = a[3];\n    b[2] = a[6];\n    b[3] = a[1];\n    b[4] = a[4];\n    b[5] = a[7];\n    b[6] = a[2];\n    b[7] = a[5];\n    b[8] = a[8];\n    return b;\n};\n\n\nmat3.toMat4 = function (a, b) {\n    b || (b = mat4.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = 0;\n    b[4] = a[3];\n    b[5] = a[4];\n    b[6] = a[5];\n    b[7] = 0;\n    b[8] = a[6];\n    b[9] = a[7];\n    b[10] = a[8];\n    b[11] = 0;\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\nmat3.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    c[0] = a[0] * d + a[3] * e + a[6] * b;\n    c[1] = a[1] * d + a[4] * e + a[7] * b;\n    c[2] = a[2] * d + a[5] * e + a[8] * b;\n    return c;\n};\n\n\nmat3.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ']';\n};\n\n\nvar mat4 = {};\n\n\nmat4.create = function (a) {\n    var b = new Array(16);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n        b[4] = a[4];\n        b[5] = a[5];\n        b[6] = a[6];\n        b[7] = a[7];\n        b[8] = a[8];\n        b[9] = a[9];\n        b[10] = a[10];\n        b[11] = a[11];\n        b[12] = a[12];\n        b[13] = a[13];\n        b[14] = a[14];\n        b[15] = a[15];\n    }\n    return b;\n};\n\n\nmat4.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = a[12];\n    b[13] = a[13];\n    b[14] = a[14];\n    b[15] = a[15];\n    return b;\n};\n\n\nmat4.identity = function (a) {\n    a[0] = 1;\n    a[1] = 0;\n    a[2] = 0;\n    a[3] = 0;\n    a[4] = 0;\n    a[5] = 1;\n    a[6] = 0;\n    a[7] = 0;\n    a[8] = 0;\n    a[9] = 0;\n    a[10] = 1;\n    a[11] = 0;\n    a[12] = 0;\n    a[13] = 0;\n    a[14] = 0;\n    a[15] = 1;\n    return a;\n};\n\n\nmat4.transpose = function (a, b) {\n    if (!b || a == b) {\n        var c = a[1],\n            d = a[2],\n            e = a[3],\n            g = a[6],\n            f = a[7],\n            h = a[11];\n        a[1] = a[4];\n        a[2] = a[8];\n        a[3] = a[12];\n        a[4] = c;\n        a[6] = a[9];\n        a[7] = a[13];\n        a[8] = d;\n        a[9] = g;\n        a[11] = a[14];\n        a[12] = e;\n        a[13] = f;\n        a[14] = h;\n        return a;\n    }\n    b[0] = a[0];\n    b[1] = a[4];\n    b[2] = a[8];\n    b[3] = a[12];\n    b[4] = a[1];\n    b[5] = a[5];\n    b[6] = a[9];\n    b[7] = a[13];\n    b[8] = a[2];\n    b[9] = a[6];\n    b[10] = a[10];\n    b[11] = a[14];\n    b[12] = a[3];\n    b[13] = a[7];\n    b[14] = a[11];\n    b[15] = a[15];\n    return b;\n};\n\n\nmat4.determinant = function (a) {\n    var b = a[0],\n        c = a[1],\n        d = a[2],\n        e = a[3],\n        g = a[4],\n        f = a[5],\n        h = a[6],\n        i = a[7],\n        j = a[8],\n        k = a[9],\n        l = a[10],\n        o = a[11],\n        m = a[12],\n        n = a[13],\n        p = a[14];\n    a = a[15];\n    return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;\n};\n\n\nmat4.inverse = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = a[4],\n        h = a[5],\n        i = a[6],\n        j = a[7],\n        k = a[8],\n        l = a[9],\n        o = a[10],\n        m = a[11],\n        n = a[12],\n        p = a[13],\n        r = a[14],\n        s = a[15],\n        A = c * h - d * f,\n        B = c * i - e * f,\n        t = c * j - g * f,\n        u = d * i - e * h,\n        v = d * j - g * h,\n        w = e * j - g * i,\n        x = k * p - l * n,\n        y = k * r - o * n,\n        z = k * s - m * n,\n        C = l * r - o * p,\n        D = l * s - m * p,\n        E = o * s - m * r,\n        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);\n    b[0] = (h * E - i * D + j * C) * q;\n    b[1] = (-d * E + e * D - g * C) * q;\n    b[2] = (p * w - r * v + s * u) * q;\n    b[3] = (-l * w + o * v - m * u) * q;\n    b[4] = (-f * E + i * z - j * y) * q;\n    b[5] = (c * E - e * z + g * y) * q;\n    b[6] = (-n * w + r * t - s * B) * q;\n    b[7] = (k * w - o * t + m * B) * q;\n    b[8] = (f * D - h * z + j * x) * q;\n    b[9] = (-c * D + d * z - g * x) * q;\n    b[10] = (n * v - p * t + s * A) * q;\n    b[11] = (-k * v + l * t - m * A) * q;\n    b[12] = (-f * C + h * y - i * x) * q;\n    b[13] = (c * C - d * y + e * x) * q;\n    b[14] = (-n * u + p * B - r * A) * q;\n    b[15] = (k * u - l * B + o * A) * q;\n    return b;\n};\n\n\nmat4.toRotationMat = function (a, b) {\n    b || (b = mat4.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\n\nmat4.toMat3 = function (a, b) {\n    b || (b = mat3.create());\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[4];\n    b[4] = a[5];\n    b[5] = a[6];\n    b[6] = a[8];\n    b[7] = a[9];\n    b[8] = a[10];\n    return b;\n};\n\n\nmat4.toInverseMat3 = function (a, b) {\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[4],\n        f = a[5],\n        h = a[6],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = k * f - h * j,\n        o = -k * g + h * i,\n        m = j * g - f * i,\n        n = c * l + d * o + e * m;\n    if (!n) return null;\n    n = 1 / n;\n    b || (b = mat3.create());\n    b[0] = l * n;\n    b[1] = (-k * d + e * j) * n;\n    b[2] = (h * d - e * f) * n;\n    b[3] = o * n;\n    b[4] = (k * c - e * i) * n;\n    b[5] = (-h * c + e * g) * n;\n    b[6] = m * n;\n    b[7] = (-j * c + d * i) * n;\n    b[8] = (f * c - d * g) * n;\n    return b;\n};\n\n\nmat4.multiply = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1],\n        g = a[2],\n        f = a[3],\n        h = a[4],\n        i = a[5],\n        j = a[6],\n        k = a[7],\n        l = a[8],\n        o = a[9],\n        m = a[10],\n        n = a[11],\n        p = a[12],\n        r = a[13],\n        s = a[14];\n    a = a[15];\n    var A = b[0],\n        B = b[1],\n        t = b[2],\n        u = b[3],\n        v = b[4],\n        w = b[5],\n        x = b[6],\n        y = b[7],\n        z = b[8],\n        C = b[9],\n        D = b[10],\n        E = b[11],\n        q = b[12],\n        F = b[13],\n        G = b[14];\n    b = b[15];\n    c[0] = A * d + B * h + t * l + u * p;\n    c[1] = A * e + B * i + t * o + u * r;\n    c[2] = A * g + B * j + t * m + u * s;\n    c[3] = A * f + B * k + t * n + u * a;\n    c[4] = v * d + w * h + x * l + y * p;\n    c[5] = v * e + w * i + x * o + y * r;\n    c[6] = v * g + w * j + x * m + y * s;\n    c[7] = v * f + w * k + x * n + y * a;\n    c[8] = z * d + C * h + D * l + E * p;\n    c[9] = z * e + C * i + D * o + E * r;\n    c[10] = z *\n        g + C * j + D * m + E * s;\n    c[11] = z * f + C * k + D * n + E * a;\n    c[12] = q * d + F * h + G * l + b * p;\n    c[13] = q * e + F * i + G * o + b * r;\n    c[14] = q * g + F * j + G * m + b * s;\n    c[15] = q * f + F * k + G * n + b * a;\n    return c;\n};\n\n\nmat4.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];\n    c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];\n    c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];\n    return c;\n};\n\n\nmat4.multiplyVec4 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1],\n        g = b[2];\n    b = b[3];\n    c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;\n    c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;\n    c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;\n    c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;\n    return c;\n};\n\n\nmat4.translate = function (a, b, c) {\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    if (!c || a == c) {\n        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];\n        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];\n        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];\n        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];\n        return a;\n    }\n    var g = a[0],\n        f = a[1],\n        h = a[2],\n        i = a[3],\n        j = a[4],\n        k = a[5],\n        l = a[6],\n        o = a[7],\n        m = a[8],\n        n = a[9],\n        p = a[10],\n        r = a[11];\n    c[0] = g;\n    c[1] = f;\n    c[2] = h;\n    c[3] = i;\n    c[4] = j;\n    c[5] = k;\n    c[6] = l;\n    c[7] = o;\n    c[8] = m;\n    c[9] = n;\n    c[10] = p;\n    c[11] = r;\n    c[12] = g * d + j * e + m * b + a[12];\n    c[13] = f * d + k * e + n * b + a[13];\n    c[14] = h * d + l * e + p * b + a[14];\n    c[15] = i * d + o * e + r * b + a[15];\n    return c;\n};\n\n\nmat4.scale = function (a, b, c) {\n    var d = b[0],\n        e = b[1];\n    b = b[2];\n    if (!c || a == c) {\n        a[0] *= d;\n        a[1] *= d;\n        a[2] *= d;\n        a[3] *= d;\n        a[4] *= e;\n        a[5] *= e;\n        a[6] *= e;\n        a[7] *= e;\n        a[8] *= b;\n        a[9] *= b;\n        a[10] *= b;\n        a[11] *= b;\n        return a;\n    }\n    c[0] = a[0] * d;\n    c[1] = a[1] * d;\n    c[2] = a[2] * d;\n    c[3] = a[3] * d;\n    c[4] = a[4] * e;\n    c[5] = a[5] * e;\n    c[6] = a[6] * e;\n    c[7] = a[7] * e;\n    c[8] = a[8] * b;\n    c[9] = a[9] * b;\n    c[10] = a[10] * b;\n    c[11] = a[11] * b;\n    c[12] = a[12];\n    c[13] = a[13];\n    c[14] = a[14];\n    c[15] = a[15];\n    return c;\n};\n\n\nmat4.rotate = function (a, b, c, d) {\n    var e = c[0],\n        g = c[1];\n    c = c[2];\n    var f = Math.sqrt(e * e + g * g + c * c);\n    if (!f) return null;\n    if (f != 1) {\n        f = 1 / f;\n        e *= f;\n        g *= f;\n        c *= f;\n    }\n    var h = Math.sin(b),\n        i = Math.cos(b),\n        j = 1 - i;\n    b = a[0];\n    f = a[1];\n    var k = a[2],\n        l = a[3],\n        o = a[4],\n        m = a[5],\n        n = a[6],\n        p = a[7],\n        r = a[8],\n        s = a[9],\n        A = a[10],\n        B = a[11],\n        t = e * e * j + i,\n        u = g * e * j + c * h,\n        v = c * e * j - g * h,\n        w = e * g * j - c * h,\n        x = g * g * j + i,\n        y = c * g * j + e * h,\n        z = e * c * j + g * h;\n    e = g * c * j - e * h;\n    g = c * c * j + i;\n    if (d) {\n        if (a != d) {\n            d[12] = a[12];\n            d[13] = a[13];\n            d[14] = a[14];\n            d[15] = a[15];\n        }\n    } else d = a;\n    d[0] = b * t + o * u + r * v;\n    d[1] = f * t + m * u + s * v;\n    d[2] = k * t + n * u + A * v;\n    d[3] = l * t + p * u + B *\n        v;\n    d[4] = b * w + o * x + r * y;\n    d[5] = f * w + m * x + s * y;\n    d[6] = k * w + n * x + A * y;\n    d[7] = l * w + p * x + B * y;\n    d[8] = b * z + o * e + r * g;\n    d[9] = f * z + m * e + s * g;\n    d[10] = k * z + n * e + A * g;\n    d[11] = l * z + p * e + B * g;\n    return d;\n};\n\n\nmat4.rotateX = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[4],\n        g = a[5],\n        f = a[6],\n        h = a[7],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = a[11];\n    if (c) {\n        if (a != c) {\n            c[0] = a[0];\n            c[1] = a[1];\n            c[2] = a[2];\n            c[3] = a[3];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[4] = e * b + i * d;\n    c[5] = g * b + j * d;\n    c[6] = f * b + k * d;\n    c[7] = h * b + l * d;\n    c[8] = e * -d + i * b;\n    c[9] = g * -d + j * b;\n    c[10] = f * -d + k * b;\n    c[11] = h * -d + l * b;\n    return c;\n};\n\n\nmat4.rotateY = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[0],\n        g = a[1],\n        f = a[2],\n        h = a[3],\n        i = a[8],\n        j = a[9],\n        k = a[10],\n        l = a[11];\n    if (c) {\n        if (a != c) {\n            c[4] = a[4];\n            c[5] = a[5];\n            c[6] = a[6];\n            c[7] = a[7];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[0] = e * b + i * -d;\n    c[1] = g * b + j * -d;\n    c[2] = f * b + k * -d;\n    c[3] = h * b + l * -d;\n    c[8] = e * d + i * b;\n    c[9] = g * d + j * b;\n    c[10] = f * d + k * b;\n    c[11] = h * d + l * b;\n    return c;\n};\n\n\nmat4.rotateZ = function (a, b, c) {\n    var d = Math.sin(b);\n    b = Math.cos(b);\n    var e = a[0],\n        g = a[1],\n        f = a[2],\n        h = a[3],\n        i = a[4],\n        j = a[5],\n        k = a[6],\n        l = a[7];\n    if (c) {\n        if (a != c) {\n            c[8] = a[8];\n            c[9] = a[9];\n            c[10] = a[10];\n            c[11] = a[11];\n            c[12] = a[12];\n            c[13] = a[13];\n            c[14] = a[14];\n            c[15] = a[15];\n        }\n    } else c = a;\n    c[0] = e * b + i * d;\n    c[1] = g * b + j * d;\n    c[2] = f * b + k * d;\n    c[3] = h * b + l * d;\n    c[4] = e * -d + i * b;\n    c[5] = g * -d + j * b;\n    c[6] = f * -d + k * b;\n    c[7] = h * -d + l * b;\n    return c;\n};\n\n\nmat4.frustum = function (a, b, c, d, e, g, f) {\n    f || (f = mat4.create());\n    var h = b - a,\n        i = d - c,\n        j = g - e;\n    f[0] = e * 2 / h;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = e * 2 / i;\n    f[6] = 0;\n    f[7] = 0;\n    f[8] = (b + a) / h;\n    f[9] = (d + c) / i;\n    f[10] = -(g + e) / j;\n    f[11] = -1;\n    f[12] = 0;\n    f[13] = 0;\n    f[14] = -(g * e * 2) / j;\n    f[15] = 0;\n    return f;\n};\n\n\nmat4.perspective = function (a, b, c, d, e) {\n    a = c * Math.tan(a * Math.PI / 360);\n    b = a * b;\n    return mat4.frustum(-b, b, -a, a, c, d, e);\n};\n\n\nmat4.ortho = function (a, b, c, d, e, g, f) {\n    f || (f = mat4.create());\n    var h = b - a,\n        i = d - c,\n        j = g - e;\n    f[0] = 2 / h;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = 2 / i;\n    f[6] = 0;\n    f[7] = 0;\n    f[8] = 0;\n    f[9] = 0;\n    f[10] = -2 / j;\n    f[11] = 0;\n    f[12] = -(a + b) / h;\n    f[13] = -(d + c) / i;\n    f[14] = -(g + e) / j;\n    f[15] = 1;\n    return f;\n};\n\n\nmat4.lookAt = function (a, b, c, d) {\n    d || (d = mat4.create());\n    var e = a[0],\n        g = a[1];\n    a = a[2];\n    var f = c[0],\n        h = c[1],\n        i = c[2];\n    c = b[1];\n    var j = b[2];\n    if (e == b[0] && g == c && a == j) return mat4.identity(d);\n    var k, l, o, m;\n    c = e - b[0];\n    j = g - b[1];\n    b = a - b[2];\n    m = 1 / Math.sqrt(c * c + j * j + b * b);\n    c *= m;\n    j *= m;\n    b *= m;\n    k = h * b - i * j;\n    i = i * c - f * b;\n    f = f * j - h * c;\n    m = Math.sqrt(k * k + i * i + f * f);\n    if (m) {\n        m = 1 / m;\n        k *= m;\n        i *= m;\n        f *= m;\n    } else f = i = k = 0;\n    h = j * f - b * i;\n    l = b * k - c * f;\n    o = c * i - j * k;\n    m = Math.sqrt(h * h + l * l + o * o);\n    if (m) {\n        m = 1 / m;\n        h *= m;\n        l *= m;\n        o *= m;\n    } else o = l = h = 0;\n    d[0] = k;\n    d[1] = h;\n    d[2] = c;\n    d[3] = 0;\n    d[4] = i;\n    d[5] = l;\n    d[6] = j;\n    d[7] = 0;\n    d[8] = f;\n    d[9] =\n        o;\n    d[10] = b;\n    d[11] = 0;\n    d[12] = -(k * e + i * g + f * a);\n    d[13] = -(h * e + l * g + o * a);\n    d[14] = -(c * e + j * g + b * a);\n    d[15] = 1;\n    return d;\n};\n\n\nmat4.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ']';\n};\n\n\nvar quat4 = {};\n\n\nquat4.create = function (a) {\n    var b = new Array(4);\n    if (a) {\n        b[0] = a[0];\n        b[1] = a[1];\n        b[2] = a[2];\n        b[3] = a[3];\n    }\n    return b;\n};\n\n\nquat4.set = function (a, b) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    return b;\n};\n\n\nquat4.calculateW = function (a, b) {\n    var c = a[0],\n        d = a[1],\n        e = a[2];\n    if (!b || a == b) {\n        a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n        return a;\n    }\n    b[0] = c;\n    b[1] = d;\n    b[2] = e;\n    b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n    return b;\n};\n\n\nquat4.inverse = function (a, b) {\n    if (!b || a == b) {\n        a[0] *= 1;\n        a[1] *= 1;\n        a[2] *= 1;\n        return a;\n    }\n    b[0] = -a[0];\n    b[1] = -a[1];\n    b[2] = -a[2];\n    b[3] = a[3];\n    return b;\n};\n\n\nquat4.length = function (a) {\n    var b = a[0],\n        c = a[1],\n        d = a[2];\n    a = a[3];\n    return Math.sqrt(b * b + c * c + d * d + a * a);\n};\n\n\nquat4.normalize = function (a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = Math.sqrt(c * c + d * d + e * e + g * g);\n    if (f == 0) {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        b[3] = 0;\n        return b;\n    }\n    f = 1 / f;\n    b[0] = c * f;\n    b[1] = d * f;\n    b[2] = e * f;\n    b[3] = g * f;\n    return b;\n};\n\n\nquat4.multiply = function (a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1],\n        g = a[2];\n    a = a[3];\n    var f = b[0],\n        h = b[1],\n        i = b[2];\n    b = b[3];\n    c[0] = d * b + a * f + e * i - g * h;\n    c[1] = e * b + a * h + g * f - d * i;\n    c[2] = g * b + a * i + d * h - e * f;\n    c[3] = a * b - d * f - e * h - g * i;\n    return c;\n};\n\n\nquat4.multiplyVec3 = function (a, b, c) {\n    c || (c = b);\n    var d = b[0],\n        e = b[1],\n        g = b[2];\n    b = a[0];\n    var f = a[1],\n        h = a[2];\n    a = a[3];\n    var i = a * d + f * g - h * e,\n        j = a * e + h * d - b * g,\n        k = a * g + b * e - f * d;\n    d = -b * d - f * e - h * g;\n    c[0] = i * a + d * -b + j * -h - k * -f;\n    c[1] = j * a + d * -f + k * -b - i * -h;\n    c[2] = k * a + d * -h + i * -f - j * -b;\n    return c;\n};\n\n\nquat4.toMat3 = function (a, b) {\n    b || (b = mat3.create());\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = c + c,\n        h = d + d,\n        i = e + e,\n        j = c * f,\n        k = c * h;\n    c = c * i;\n    var l = d * h;\n    d = d * i;\n    e = e * i;\n    f = g * f;\n    h = g * h;\n    g = g * i;\n    b[0] = 1 - (l + e);\n    b[1] = k - g;\n    b[2] = c + h;\n    b[3] = k + g;\n    b[4] = 1 - (j + e);\n    b[5] = d - f;\n    b[6] = c - h;\n    b[7] = d + f;\n    b[8] = 1 - (j + l);\n    return b;\n};\n\n\nquat4.toMat4 = function (a, b) {\n    b || (b = mat4.create());\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = a[3],\n        f = c + c,\n        h = d + d,\n        i = e + e,\n        j = c * f,\n        k = c * h;\n    c = c * i;\n    var l = d * h;\n    d = d * i;\n    e = e * i;\n    f = g * f;\n    h = g * h;\n    g = g * i;\n    b[0] = 1 - (l + e);\n    b[1] = k - g;\n    b[2] = c + h;\n    b[3] = 0;\n    b[4] = k + g;\n    b[5] = 1 - (j + e);\n    b[6] = d - f;\n    b[7] = 0;\n    b[8] = c - h;\n    b[9] = d + f;\n    b[10] = 1 - (j + l);\n    b[11] = 0;\n    b[12] = 0;\n    b[13] = 0;\n    b[14] = 0;\n    b[15] = 1;\n    return b;\n};\n\n\nquat4.slerp = function (a, b, c, d) {\n    d || (d = a);\n    var e = c;\n    if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;\n    d[0] = 1 - c * a[0] + e * b[0];\n    d[1] = 1 - c * a[1] + e * b[1];\n    d[2] = 1 - c * a[2] + e * b[2];\n    d[3] = 1 - c * a[3] + e * b[3];\n    return d;\n};\n\n\nquat4.str = function (a) {\n    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ']';\n};\n\nexport {vec2, vec3, vec4, mat3, mat4};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/utils/matrix.js\n// module id = 1\n// module chunks = 0 1","\nimport {TWO_PI, SPI} from '../constants/values';\nimport sign from './sign';\n\nexport default function(x) {\n  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/adjust_lon.js\n// module id = 2\n// module chunks = 0 1","\nimport {math as math_} from './math';\nimport {utilsUrl as utilsUrl_} from './url';\n\n//get rid of compiler mess\nvar math = math_;\nvar utilsUrl = utilsUrl_;\n\n\nvar utils = {};\nutils.useCredentials = false;\nutils.instanceCounter = 0;\n\n\nutils.validateBool = function(value, defaultValue) {\n    if (typeof value === 'boolean') {\n        return value;\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.validateNumber = function(value, minValue, maxValue, defaultValue) {\n    if (typeof value === 'number') {\n        return math.clamp(value, minValue, maxValue);\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.validateNumberArray = function(array, arraySize, minValues, maxValues, defaultValues) {\n    if (Array.isArray(array) && array.length == arraySize) {\n        for (var i = 0; i < arraySize; i++) {\n            array[i] = math.clamp(array[i], minValues[i], maxValues[i]);\n        }\n        return array;\n    } else {\n        return defaultValues;\n    }\n};\n\n\nutils.validateString = function(value, defaultValue) {\n    if (typeof value === 'string') {\n        return value;\n    } else {\n        return defaultValue;\n    }\n};\n\n\nutils.padNumber = function(n, width) {\n    var z = '0';\n\n    if (n < 0) {\n        n = (-n) + '';\n        width--;     //7\n        return n.length >= width ? ('-' + n) : '-' + (new Array(width - n.length + 1).join(z) + n);\n    } else {\n        n = n + '';\n        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n    }\n};\n\n\nutils.decodeFloat16 = function(binary) {\n    var exponent = (binary & 0x7C00) >> 10;\n    var fraction = binary & 0x03FF;\n    return (binary >> 15 ? -1 : 1) * (\n        exponent ?\n        (\n            exponent === 0x1F ?\n            fraction ? NaN : Infinity :\n            Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n        ) :\n        6.103515625e-5 * (fraction / 0x400)\n    );\n};\n\n\nutils.simpleFmtObj = (function obj(str, obj) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    return str.replace(/\\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\\}/g, function(s, match) {\n        return (match in obj ? obj[match] : s);\n    });\n});\n\n\nutils.simpleWikiLinks = (function obj(str, plain) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    var str2 = utils.simpleFmtObj(str, {'copy':'&copy;', 'Y': (new Date().getFullYear())}); \n    \n    return str2.replace(/\\[([^\\]]*)\\]/g, function(s, match) {\n        match  = match.trim();\n        var urls = match.split(' ');//, 1);\n        \n        if (urls[0].indexOf('//') != -1) {\n            if (plain) {\n                if (urls.length > 1) {\n                    return '' + match.substring(urls[0].length);\n                } else {\n                    return '' + urls[0];\n                }\n            } else {\n                if (urls.length > 1) {\n                    return '<a href=' + urls[0] + ' target=\"blank\">' + match.substring(urls[0].length)+'</a>';\n                } else {\n                    return '<a href=' + urls[0] + ' target=\"blank\">' + urls[0]+'</a>';\n                }\n            }\n        }\n        \n        return match;\n    });\n});\n\n\nutils.simpleFmtObjOrCall = (function obj(str, obj, call) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    return str.replace(/\\{([$a-zA-Z(-9][$a-zA-Z(-9]*)\\}/g, function(s, match) {\n        return (match in obj ? obj[match] : call(match));\n    });\n});\n\n\nutils.getABGRFromHexaCode = (function(code) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(code);\n\n    return result ?\n    [ parseInt(result[4], 16),\n        parseInt(result[3], 16),\n        parseInt(result[2], 16),\n        parseInt(result[1], 16)]\n    : [0,0,0,255];\n});\n\n\nutils.stringifyFunction = (function(fn) {\n    // Stringify the code\n    return '(' + fn + ').call(self);';\n});\n\n\nutils.isPowerOfTwo = (function(value) {\n    return (value & (value - 1)) === 0 && value !== 0;\n});\n\n\nutils.nearestPowerOfTwo = (function(value) {\n    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));\n});   \n\nutils.fitToPowerOfTwo = (function(value) {\n    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n});   \n\nutils.getHash = function(str) {\n    if (!str || str.length === 0) {\n        return 0;    \n    }\n\n    var hash = 0, c;\n    for (var i = 0, li = str.length; i < li; i++) {\n        c   = str.charCodeAt(i);\n        hash  = ((hash << 5) - hash) + c;\n        hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n};\n\nutils.loadText = function(path, onLoaded, onError, withCredentials, xhrParams) {\n    utils.loadJSON(path, onLoaded, onError, true, withCredentials, xhrParams);\n};\n\nutils.loadXML = function(path, onLoaded, onError, withCredentials, xhrParams) {\n    var onLoaded2 = (function(data){\n        var parser = new DOMParser();\n        data = parser.parseFromString(data, 'text/xml');\n        if (onLoaded) {\n            onLoaded(data);\n        }\n    });\n\n    utils.loadJSON(path, onLoaded2, onError, true, withCredentials, xhrParams);\n};\n\nutils.loadJSON = function(path, onLoaded, onError, skipParse, withCredentials, xhrParams) {\n    var xhr = new XMLHttpRequest();\n\n    //xhr.onload  = (function() {\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    onError(xhr.status);\n                }\n                break;\n            }\n    \n            var data = xhr.response;\n            var parsedData = data;\n                \n            if (!skipParse) {\n                try {\n                        //var parsedData = skipParse ? data : eval(\"(\"+data+\")\");\n                    parsedData = JSON.parse(data);\n                } catch(e) {\n                    // eslint-disable-next-line\n                    console.log('JSON Parse Error ('+path+'): ' + (e['message'] ? e['message'] : ''));\n                        \n                    if (onError ) {\n                        onError(xhr.status);\n                    }\n                \n                    return;\n                }\n            }\n                \n            if (onLoaded) {\n                onLoaded(parsedData);\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n\n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET',  path, true);\n    xhr.withCredentials = withCredentials;\n    \n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    if (xhrParams && xhrParams['charset']) {\n        xhr.overrideMimeType('text/xml; charset=' + xhrParams['charset']);\n        //xhr.setRequestHeader('Content-type', xhrParams['Content-type']);\n    }\n    \n    xhr.send('');\n};\n\n\nutils.loadBinary = function(path, onLoaded, onError, withCredentials, xhrParams, responseType) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    onError(xhr.status);\n                }\n                break;\n            }\n    \n            var abuffer = xhr.response;\n                    \n            if (!abuffer) {\n                if (onError) {\n                    onError();\n                }\n                break;\n            }\n                    \n                    //if (!responseType || responseType == \"arraybuffer\") {\n                        //var data = new DataView(abuffer);\n                    //} else {\n                      //  var data = abuffer;\n                    //}\n    \n            if (onLoaded) {\n                onLoaded(abuffer);\n            }\n    \n            break;\n    \n        default:\n    \n            if (onError) {\n                onError();\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n    \n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET', path, true);\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nutils.headRequest = function(url, onLoaded, onError, withCredentials, xhrParams) { \n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n            if (onLoaded != null) {\n                onLoaded(xhr.getAllResponseHeaders(), xhr.status);\n                    //onLoaded(xhr.getResponseHeader(\"X-VE-Tile-Info\"), xhr.status);\n            }\n            break;\n    \n        default:\n    \n            if (onError != null) {\n                onError();\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n\n    xhr.onerror  = (function() {\n        if (onError != null) {\n            onError();\n        }\n    }).bind(this);\n\n    xhr.open('HEAD', url, true);\n    //xhr.responseType = responseType ? responseType : \"arraybuffer\";\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nutils.loadImage = function(url, onload, onerror, withCredentials, direct) {\n    var image = new Image();\n    image.onerror = onerror;\n    image.onload = onload;\n\n    if (!direct){\n        image.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';\n    }\n\n    image.src = url;\n    return image;\n};\n\n\nutils.getParamsFromUrl = function(url) {\n    return utilsUrl.getParamsFromUrl(url);\n};\n\n\n//var textDecoderUtf8 = null; //(typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\nvar textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\n\nutils.unint8ArrayToString = function(array) {\n    if (textDecoderUtf8) {\n        return textDecoderUtf8.decode(array);\n    } else {\n//        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\n\n        /*\n        var buff = new Uint16Array(array.buffer, array.byteOffset, array.byteLength);\n        var getChar = String.fromCharCode;\n        //var buff2 = new Array(buff.length);\n        var str = '';\n\n        for (var i = 0, li = buff.length; i < li; i++) {\n            //buff2[i] = getChar(buff[i]);\n            str += getChar(buff[i]);\n        }\n\n        return str;\n        //return buff2.join('');\n        */\n\n        var s = '';\n        //var code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        var code_points2 = new Uint8Array(array.byteLength);\n        code_points2.set(array);\n        var code_points = new Uint32Array(code_points2.buffer);\n\n        for (var i = 0, li = code_points.length; i < li; ++i) {\n          var cp = code_points[i];\n          if (cp <= 0xFFFF) {\n            s += String.fromCharCode(cp);\n          } else {\n            cp -= 0x10000;\n            s += String.fromCharCode((cp >> 10) + 0xD800,\n                                     (cp & 0x3FF) + 0xDC00);\n          }\n        }\n        return s;\n\n    }\n}\n\n\nexport {utils};\n\n// only implement if no native implementation is available\n/*\nif (typeof Array.isArray === 'undefined') {\n  Array.isArray = (function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  });\n}*/\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/utils/utils.js\n// module id = 3\n// module chunks = 0 1","\nimport {mat4 as mat4_} from './matrix';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\n\n\nvar math = {};\n\n\nmath.isEqual = function(value, value2, delta) {\n    return (Math.abs(value - value2) < delta);\n};\n\n\nmath.clamp = function(value, min, max) {\n    if (value < min) value = min;\n    else if (value > max) value = max;\n\n    return value;\n};\n\n\nmath.radians = function(degrees) {\n    return degrees * Math.PI / 180;\n};\n\n\nmath.degrees = function(radians) {\n    return (radians / Math.PI) * 180;\n};\n\n\nmath.mix = function(a, b, c) {\n    return a + (b - a) * c;\n};\n\n\nmath.frustumMatrix = function(left, right, bottom, top, near, far) {\n    var w = (right - left);\n    var h = (top - bottom);\n    var d = (far - near);\n\n    var m = mat4.create([2*near/w, 0, (right+left)/w, 0,\n        0, 2*near/h, (top+bottom)/h, 0,\n        0, 0, -(far+near)/d, -2*far*near/d,\n        0, 0, -1, 0]);\n\n    mat4.transpose(m);\n    return m;\n};\n\n\nmath.perspectiveMatrix = function(fovy, aspect, near, far) {\n    var ymax = near * Math.tan(fovy * Math.PI / 180.0);\n    var xmax = ymax * aspect;\n    return math.frustumMatrix(-xmax, xmax, -ymax, ymax, near, far);\n};\n\n\nmath.orthographicMatrix = function(vsize, aspect, near, far) {\n    //vsize *= 0.020;\n    var w = vsize* 0.5 * aspect;\n    var h = vsize * 0.5;\n    var d = (far - near);\n\n    var m = mat4.create([1/w, 0, 0, 0,\n        0, 1/h, 0, 0,\n        0, 0, -2/d, -((far+near)/d),\n        0, 0, 0, 1]);\n\n    mat4.transpose(m);\n    return m;\n};\n\n\nmath.rotationMatrix = function(axis, angle) {\n    var ca = Math.cos(angle), sa = Math.sin(angle);\n\n    /*    var m;\n    switch (axis) {\n    case 0:\n        m = [\n            1,  0,  0, 0,\n            0, ca,-sa, 0,\n            0, sa, ca, 0,\n            0,  0,  0, 1 ];\n        break;\n    case 1:\n        m = [\n            ca, 0,-sa, 0,\n            0, 1,  0,  0,\n            sa, 0, ca, 0,\n            0, 0,  0, 1 ];\n        break;\n    default:\n        m = [\n            ca,-sa, 0, 0,\n            sa, ca, 0, 0,\n            0,  0,  1, 0,\n            0,  0,  0, 1 ];\n        break;\n    }\n    mat4.transpose(m);\n    return m; */\n\n    switch (axis) {\n    case 0:\n        return [\n            1,   0,   0,  0,\n            0,  ca,  sa,  0,\n            0, -sa,  ca,  0,\n            0,   0,   0,  1 ];\n    case 1:\n        return [\n             ca,  0,  sa,  0,\n              0,  1,   0,  0,\n            -sa,  0,  ca,  0,\n              0,  0,   0,  1 ];\n    default:\n        return [\n             ca, sa,  0,  0,\n            -sa, ca,  0,  0,\n              0,  0,  1,  0,\n              0,  0,  0,  1 ];\n    }\n\n};\n\n\nmath.scaleMatrix = function(sx, sy, sz) {\n    /*var m = [\n        sx,  0,  0, 0,\n        0, sy,  0, 0,\n        0,  0, sz, 0,\n        0,  0,  0, 1 ];\n\n    mat4.transpose(m);\n    return m;*/\n    return [\n        sx,   0,   0,   0,\n        0,   sy,   0,   0,\n        0,    0,  sz,   0,\n        0,    0,   0,   1 ];\n};\n\n\nmath.scaleMatrixf = function(s) {\n    return math.scaleMatrix(s, s, s);\n};\n\n\nmath.translationMatrix = function(tx, ty, tz) {\n    /*\n    var m = [\n        1, 0, 0, tx,\n        0, 1, 0, ty,\n        0, 0, 1, tz,\n        0, 0, 0, 1 ];\n\n    mat4.transpose(m);\n    */\n\n    return [\n        1,   0,  0,  0,\n        0,   1,  0,  0,\n        0,   0,  1,  0,\n        tx, ty, tz,  1 ];\n};\n\n\nmath.translationMatrix2f = function(t) {\n    return math.translationMatrix(t[0], t[1], 0);\n};\n\n\nmath.translationMatrix3f = function(t) {\n    return math.translationMatrix(t[0], t[1], t[2]);\n};\n\n\nexport {math};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/utils/math.js\n// module id = 4\n// module chunks = 0 1","\nvar BBox = function(xmin, ymin, zmin, xmax, ymax, zmax) {\n    this.min = [];\n    this.max = [];\n\n    this.min[0] = (xmin != null) ? xmin : Number.POSITIVE_INFINITY;\n    this.min[1] = (ymin != null) ? ymin : Number.POSITIVE_INFINITY;\n    this.min[2] = (zmin != null) ? zmin : Number.POSITIVE_INFINITY;\n\n    this.max[0] = (xmax != null) ? xmax : Number.NEGATIVE_INFINITY;\n    this.max[1] = (ymax != null) ? ymax : Number.NEGATIVE_INFINITY;\n    this.max[2] = (zmax != null) ? zmax : Number.NEGATIVE_INFINITY;\n\n    this.updateMaxSize();\n};\n\n\nBBox.prototype.clone = function() {\n    return new BBox(this.min[0], this.min[1], this.min[2],\n                    this.max[0], this.max[1], this.max[2]);\n};\n\n\nBBox.prototype.side = function(index) {\n    return this.max[index] - this.min[index];\n};\n\n\nBBox.prototype.updateMaxSize = function() {\n    this.maxSize = Math.abs(Math.max(this.max[0] - this.min[0],\n                                     this.max[1] - this.min[1],\n                                     this.max[2] - this.min[2]));\n};\n\n\nBBox.prototype.center = function(vec) {\n    if (vec != null) {\n        vec[0] = (this.min[0] + this.max[0])*0.5;\n        vec[1] = (this.min[1] + this.max[1])*0.5;\n        return vec;\n    } else {\n        if (!this.middle) {\n            this.middle = [(this.min[0] + this.max[0])*0.5, (this.min[1] + this.max[1])*0.5, (this.min[2] + this.max[2])*0.5];\n\n            if (isNaN(this.middle[0])) {\n                this.middle[0] = 0;\n            }\n\n            if (isNaN(this.middle[1])) {\n                this.middle[1] = 0;\n            }\n\n            if (isNaN(this.middle[2])) {\n                this.middle[2] = 0;\n            }\n        } \n\n        return this.middle;\n    }\n};\n\n\nBBox.prototype.translateXY = function(delta) {\n    return new BBox(this.min[0] - delta[0], this.min[1] - delta[1], this.min[2],\n                    this.max[0] - delta[0], this.max[1] - delta[1], this.max[2]);\n};\n\n\nexport default BBox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/bbox.js\n// module id = 5\n// module chunks = 0 1","\nimport {utils as utils_} from '../../utils/utils';\n\n//get rid of compiler mess\nvar utils = utils_;\n\nvar GpuTexture = function(gpu, path, core, fileSize, direct, repeat, filter, keepImage, onLoaded, onError) {\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.texture = null;\n    this.framebuffer = null;\n    this.size = 0;\n    this.fileSize = fileSize; //used for stats\n    this.width = 0;\n    this.height = 0;\n    this.repeat = repeat || false;\n    this.filter = filter || 'linear';\n\n    this.image = null;\n    this.loaded = false;\n    this.trilinear = false;//true;\n    this.core = core;\n\n    if (path != null) {\n        this.load(path, onLoaded, onError, direct, keepImage);\n    }\n};\n\n//destructor\nGpuTexture.prototype.kill = function() {\n    this.gl.deleteTexture(this.texture);\n    \n    this.texture = null;\n};\n\n// Returns GPU RAM used, in bytes.\nGpuTexture.prototype.size = function() {\n    return this.size;\n};\n\nGpuTexture.prototype.createFromData = function(lx, ly, data, filter, repeat) {\n    var gl = this.gl;\n\n    this.texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n    if (repeat){\n        repeat = gl.REPEAT;\n        this.repeat = true;\n    } else {\n        repeat = gl.CLAMP_TO_EDGE;\n    }\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat);\n    var mipmaps = false;\n\n    switch (filter) {\n    case 'linear':\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        break;\n    case 'trilinear':\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        mipmaps = true;\n        break;\n    default:\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        break;\n    }\n\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lx, ly, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n    if (mipmaps) {\n        gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    this.width = lx;\n    this.height = ly;\n    this.size = lx * ly * 4;\n    this.loaded = true;\n};\n\nGpuTexture.prototype.createFromImage = function(image, filter, repeat, aniso) {\n    var gl = this.gl;\n\n    //filter = 'trilinear'; aniso = null; this.gpu.anisoLevel = 0;\n    var width = image.naturalWidth;\n    var height = image.naturalHeight;\n    var data = image;\n\n    this.texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n    if (repeat) {\n        repeat = gl.REPEAT;\n        this.repeat = true;\n    } else {\n        repeat = gl.CLAMP_TO_EDGE;\n    }\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat);\n    var mipmaps = false;\n    this.filter = filter;\n\n    switch (filter) {\n    case 'linear':\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        break;\n    case 'trilinear':\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        mipmaps = true;\n        break;\n    default:\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        break;\n    }\n\n    //resize image to nearest power of two\n    if ((this.repeat || mipmaps) && (!utils.isPowerOfTwo(width) || !utils.isPowerOfTwo(height))) {\n        width = utils.nearestPowerOfTwo(width);\n        height = utils.nearestPowerOfTwo(height);\n        var canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        var context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0, width, height); \n        data = canvas;\n    }\n\n    var gpu = this.gpu;\n\n    if (gpu.anisoLevel) {\n        gl.texParameterf(gl.TEXTURE_2D, gpu.anisoExt.TEXTURE_MAX_ANISOTROPY_EXT, gpu.anisoLevel);\n    }\n\n    if (gpu.noTextures !== true) { //why is it here and not at the beginig of the code?\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n        if (mipmaps) {\n            gl.generateMipmap(gl.TEXTURE_2D);\n        }\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    this.width = width;\n    this.height = height;\n    this.size = width * height * 4;\n    this.loaded = true;\n};\n\nGpuTexture.prototype.load = function(path, onLoaded, onError, direct, keepImage) {\n    this.image = utils.loadImage(path, (function () {\n        if (this.core != null && this.core.killed) {\n            return;\n        }\n\n        this.createFromImage(this.image, this.filter, this.repeat);\n        if (!keepImage) {\n            this.image = null;\n        }\n\n        if (onLoaded) {\n            onLoaded();\n        } else {\n            if (this.core.map && this.core.map.markDirty) {\n                this.core.map.markDirty();\n            }\n        }\n\n    }).bind(this), (function () {\n\n        if (this.core != null && this.core.killed) {\n            return;\n        }\n\n        if (onError) {\n            onError();\n        }\n    }).bind(this),\n     \n     null, direct\n     \n     );\n\n};\n\n\nGpuTexture.prototype.createFramebufferFromData = function(lx, ly, data) {\n    var gl = this.gl;\n\n    var framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    framebuffer.width = lx;\n    framebuffer.height = ly;\n\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lx, ly, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n\n\n    var renderbuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, lx, ly);\n\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n    this.width = lx;\n    this.height = ly;\n    this.size = lx * ly * 4;\n\n    this.texture = texture;\n    this.renderbuffer = renderbuffer;\n    this.framebuffer = framebuffer;\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n};\n\n\nGpuTexture.prototype.createFramebuffer = function(lx, ly) {\n    if (this.texture == null){\n        return;\n    }\n\n    var gl = this.gl;\n\n    var framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    framebuffer.width = lx;\n    framebuffer.height = ly;\n\n    gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n    var renderbuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, lx, ly);\n\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    this.framebuffer = framebuffer;\n    this.renderbuffer = renderbuffer;\n};\n\n\nGpuTexture.prototype.readFramebufferPixels = function(x, y, lx, ly) {\n    if (this.texture == null) {\n        return;\n    }\n\n    this.gpu.bindTexture(this);\n    this.gpu.setFramebuffer(this);\n\n    var gl = this.gl;\n\n    // Read the contents of the framebuffer (data stores the pixel data)\n    var data = new Uint8Array(lx * ly * 4);\n    gl.readPixels(x, y, lx, ly, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n    this.gpu.setFramebuffer(null);\n\n    return data;\n};\n\nexport default GpuTexture;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/texture.js\n// module id = 6\n// module chunks = 0 1","export default function(x) {\n  if (Math.abs(x) > 1) {\n    x = (x > 1) ? 1 : -1;\n  }\n  return Math.asin(x);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/asinz.js\n// module id = 7\n// module chunks = 0 1","export default function(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / (Math.sqrt(1 - con * con));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/msfnz.js\n// module id = 8\n// module chunks = 0 1","import {HALF_PI} from '../constants/values';\nimport sign from './sign';\n\nexport default function(x) {\n  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/adjust_lat.js\n// module id = 9\n// module chunks = 0 1","export default function(x) {\n  return x<0 ? -1 : 1;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/sign.js\n// module id = 10\n// module chunks = 0 1","\nvar utilsUrl = {};\n\n\nutilsUrl.isSameOrigin = function(url) {\n    if (typeof url !== 'string') {\n        return false;\n    }\n    var docHost = document.location.hostname;\n    var parser = utilsUrl.parse(url);\n    return parser['hostname'] === docHost;\n};\n\n\nutilsUrl.parse = function(url) {\n    if (typeof url !== 'string') {\n        return null;\n    }\n\n    var parser = document.createElement('a');\n    parser['href'] = url;\n    return parser;\n};\n\n\nutilsUrl.getParamsFromUrl = function(url) {\n    var parser = utilsUrl.parse(url);\n    var queryString = {};\n    var query = parser['search'].substring(1);\n    var vars = query.split('&');\n    if (!(vars.length == 1 && vars[0] == '')) {\n        for (var i=0; i < vars.length; i++) {\n            var pair = vars[i].split('=');\n            if (typeof queryString[pair[0]] === 'undefined') {\n                queryString[pair[0]] = pair[1];\n            } else if (typeof queryString[pair[0]] === 'string') {\n                var arr = [ queryString[pair[0]], pair[1] ];\n                queryString[pair[0]] = arr;\n            } else {\n                queryString[pair[0]].push(pair[1]);\n            }\n        }\n    }\n    return queryString;\n};\n\n\nutilsUrl.getHost = function(url) {\n    var location = document.createElement('a');\n    location.href = url;\n    return location.hostname; \n};\n\n\nutilsUrl.getSchema = function(url) {\n    //if (window.location.href.indexOf(\"file://\") != -1) {\n    if (url.indexOf('http://') != -1) {\n        return 'http:';\n    } else if (url.indexOf('https://') != -1) {\n        return 'https:';\n    } else {\n        var location = document.createElement('a');\n        location.href = url;\n        return location.protocol;\n    }\n};\n\n\nutilsUrl.getOrigin = function(url) {\n    var location = document.createElement('a');\n    location.href = url;\n\n    if (!location.origin) {  //IE11 hack\n      return location.protocol + \"//\" + location.hostname + (location.port ? ':' + location.port: '');\n    }\n\n    return location.origin; \n};\n\n\nutilsUrl.getBase = function(url) {\n    return url.split('?')[0].split('/').slice(0, -1).join('/')+'/';\n};\n\n\nutilsUrl.getProcessUrl = function(url, originUrl) {\n    if (!url || !originUrl) {\n        return url;\n    }\n\n    url = url.trim();\n    originUrl= originUrl.trim();\n    var baseUrl = utilsUrl.getBase(originUrl);\n    var baseUrlSchema = utilsUrl.getSchema(originUrl);\n    var baseUrlOrigin = utilsUrl.getOrigin(originUrl); \n   \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return baseUrlOrigin + url;\n    } else {  //relative\n        return baseUrl + url; \n    }\n};\n\n\nexport {utilsUrl};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/utils/url.js\n// module id = 12\n// module chunks = 0 1","import Proj4 from 'proj4';\nimport Map_ from './map/map';\nimport Inspector_ from './inspector/inspector';\nimport Renderer_ from './renderer/renderer';\nimport RendererInterface_ from './renderer/interface';\nimport MapPosition_ from './map/position';\nimport MapInterface_ from './map/interface';\nimport {utils as utils_} from './utils/utils';\nimport {utilsUrl as utilsUrl_} from './utils/url';\nimport {platform as platform_} from './utils/platform';\n\n//get rid of compiler mess\nvar Map = Map_;\nvar Inspector = Inspector_;\nvar Renderer = Renderer_;\nvar RendererInterface = RendererInterface_;\nvar MapPosition = MapPosition_;\nvar MapInterface = MapInterface_;\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\nvar platform = platform_;\n\n\nvar Core = function(element, config, coreInterface) {\n    var lang = navigator.languages ? navigator.languages[0] : (navigator.language || navigator.userLanguage);\n    this.killed = false;\n    this.config = {\n        map : null,\n        mapCache : 1100, //old value 900\n        mapGPUCache : 600, //old value 500, 360\n        mapMetatileCache : 60,\n        mapTexelSizeFit : 1.1,\n        mapMaxHiresLodLevels : 2,\n        mapDownloadThreads : 20,\n        mapMaxProcessingTime : 1000*20,\n        mapMaxGeodataProcessingTime : 10,\n        mapMobileMode : false,\n        mapMobileModeAutodect : true,\n        mapMobileDetailDegradation : 1,\n        mapNavSamplesPerViewExtent : 4,\n        mapIgnoreNavtiles : false,\n        mapVirtualSurfaces : true,\n        mapAllowHires : true,\n        mapAllowLowres : true,\n        mapAllowSmartSwitching : true,\n        mapDisableCulling : false,\n        mapPreciseCulling : true,\n        mapHeightLodBlend : true,\n        mapHeightNodeBlend : true,\n        mapBasicTileSequence : false,\n        mapPreciseBBoxTest : false,\n        mapPreciseDistanceTest : false,\n        mapHeightfiledWhenUnloaded : true,\n        mapForceMetatileV3 : false,\n        mapSmartNodeParsing : true,\n        mapLoadErrorRetryTime : 3000,\n        mapLoadErrorMaxRetryCount : 3,\n        mapLoadMode : 'topdown', // \"topdown\", \"downtop\", \"fit\", \"fitonly\"\n        mapGeodataLoadMode : 'fit', //\"fitonly\"\n        mapGridMode : 'linear', //\"flat\"\n        mapGridSurrogatez : false, \n        mapGridUnderSurface: 0,\n        mapGridTextureLevel: -1,\n        mapGridTextureLayer: null, //\"bing\",\n        mapXhrImageLoad : true,\n        mapStoreLoadStats : false,\n        mapRefreshCycles : 3,\n        mapSoftViewSwitch : true,\n\n        mapFeatureStickMode : [1,1],\n\n        map16bitMeshes : true,\n        mapOnlyOneUVs : true,\n        mapIndexBuffers : true,\n        mapAsyncImageDecode : true,\n\n        mapFeatureGridCells : 31,\n        mapFeaturesPerSquareInch : 0.25, //0.6614,\n        mapFeaturesSortByTop : false,\n\n        mapFeaturesReduceMode : 'scr-count1', //have to be 'scr-count1' because of legacy https://rigel.mlwn.se/store/map-config/high-terrain/\n        mapFeaturesReduceParams : null,\n        mapFeaturesReduceFactor : 1,\n\n        mapDegradeHorizon : false,\n        mapDegradeHorizonParams : [1, 1500, 97500, 3500], //[1, 3000, 15000, 7000],\n        mapDefaultFont : '//cdn.melown.com/libs/vtsjs/fonts/noto-basic/1.0.0/noto.fnt',\n        //mapDefaultFont : '../fonts/basic.fnt',\n        mapFog : true,\n        mapNoTextures: false,\n        mapMetricUnits : !(lang == 'en' || lang.indexOf('en-') == 0),\n        mapForceFrameTime: 0,\n        mapForcePipeline: 0,\n        mapLogGeodataStyles: true,\n\n        rendererAnisotropic : 0,\n        rendererAntialiasing : true,\n        rendererAllowScreenshots : false,\n        inspector : true, \n        authorization : null, \n        mario : false\n    };\n\n    this.configStorage = {}; \n    this.element = element;\n    this.coreInterface = coreInterface;\n    //this.options = options;\n    this.ready = false;\n    this.listeners = [];\n    this.listenerCounter = 0;\n    this.tokenCookieHost = null;\n    this.tokenIFrame = null;\n    this.xhrParams = {};\n    this.inspector = (Inspector != null) ? (new Inspector(this)) : null;\n    this.setConfigParams(config);\n\n    this.map = null;\n    this.mapInterface = null;\n    this.renderer = new Renderer(this, this.element, null, this.onResize.bind(this), this.config);\n    this.rendererInterface = new RendererInterface(this.renderer);\n    this.proj4 = Proj4;\n    this.contextLost = false;\n\n    //platform detection\n    platform.init();\n    this.requestAnimFrame = (\n               window.requestAnimationFrame ||\n               window.webkitRequestAnimationFrame ||\n               window.mozRequestAnimationFrame ||\n               window.oRequestAnimationFrame ||\n               window.msRequestAnimationFrame ||\n               function(callback) {\n                   window.setTimeout(callback, 1000/60);\n               });\n\n    window.performance = window.performance || {};\n    performance.now = (function() {\n        return performance.now       ||\n               performance.mozNow    ||\n               performance.msNow     ||\n               performance.oNow      ||\n               performance.webkitNow ||\n               function() { return new Date().getTime(); };\n    })();\n\n    this.loadMap(this.config.map);\n\n    this.requestAnimFrame.call(window, this.onUpdate.bind(this));\n};\n\n\nCore.prototype.onResize = function() {\n    if (this.map != null) {\n        this.map.markDirty();\n    }\n};\n\n\nCore.prototype.loadMap = function(path) {\n    if (this.map != null) {\n        this.destroyMap();\n    }\n\n    if (path == null) {\n        return;\n    }\n    \n    path = utilsUrl.getProcessUrl(path, window.location.href);\n\n    this.tokenCookieLoaded = true;\n    this.mapConfigData = null;\n    this.tokenExpiration = null;\n    this.tokenExpirationCallback = null;\n    this.tokenExpirationLoop = false;\n    this.tokenCanBeSkiped = true;\n    this.mapRunnig = false;\n    \n    var onLoaded = (function() {\n        if (!(this.tokenCookieLoaded || this.tokenCanBeSkiped) || !this.mapConfigData || this.mapRunnig) {\n            return;\n        }\n\n        this.mapRunnig = true;\n        var data = this.mapConfigData; \n    \n        this.callListener('map-mapconfig-loaded', data);\n\n        this.map = new Map(this, data, path, this.config);\n        this.mapInterface = new MapInterface(this.map);\n        this.setConfigParams(this.map.browserOptions, true);\n        this.setConfigParams(this.configStorage);\n\n        if (this.config.position) {\n            this.map.setPosition(this.config.position);\n            this.config.position = null;\n        }\n    \n        if (this.config.view) {\n            this.map.setView(this.config.view);\n            this.config.view = null;\n        }\n    \n    }).bind(this);\n\n    var onMapConfigLoaded = (function(data) {\n        this.mapConfigData = data; \n        onLoaded();\n    }).bind(this);\n\n    var onMapConfigError = (function() {\n    }).bind(this);\n\n    //this.tokenLoaded = true;\n\n    var onAutorizationLoaded = (function(data) {\n        if (!data || (data && data['status'])) {\n            if (this.tokenCanBeSkiped) {\n                onLoadMapconfig(path);\n            }\n            return;\n        }\n\n        this.tokenLoaded = true;\n        this.xhrParams['token'] = data['token'];\n        this.xhrParams['tokenHeader'] = data['header'];\n        this.tokenExpiration = data['expires'] * 1000;\n        this.tokenExpirationCallback = (function(){\n            //this.tokenLoaded = false;\n            //this.tokenCookieLoaded = false;\n            this.tokenExpiration = null;\n            this.tokenExpirationLoop = true;\n            if (typeof this.config.authorization === 'string') {\n                utils.loadJSON(this.config.authorization, onAutorizationLoaded, onAutorizationError, null, utils.useCredentials, this.xhrParams);\n            } else {\n                this.config.authorization(onAutorizationLoaded);\n            }\n        }).bind(this);\n        \n        if (!this.tokenExpirationLoop) {\n            onLoadMapconfig(path);\n        }\n        \n        if (typeof this.config.authorization === 'string') {\n            onLoadImageCookie(data['cookieInjector'], this.config.authorization);\n        } else {\n            onLoadImageCookie(data['cookieInjector'], path);\n        }\n\n    }).bind(this);\n\n    var onAutorizationError = (function() {\n        // eslint-disable-next-line\n        console.log('auth token not loaded');\n        \n        if (this.tokenCanBeSkiped) {\n            onLoadMapconfig(path);\n        }\n    }).bind(this);\n\n    var onImageCookieLoaded = (function() {\n        document.body.removeChild(this.tokenIFrame);\n        this.tokenIFrame = null;   \n        this.tokenCookieLoaded = true;\n        onLoaded();\n    }).bind(this);\n\n    /*var onImageCookieError = (function() {\n        // eslint-disable-next-line\n        console.log('auth cookie not loaded');\n    }).bind(this);*/\n\n    //var baseUrl = path.split('?')[0].split('/').slice(0, -1).join('/')+'/';\n\n    var onLoadMapconfig = (function(path) {\n        utils.loadJSON(path, onMapConfigLoaded, onMapConfigError, null, utils.useCredentials, this.xhrParams);\n    }).bind(this);\n\n    var onLoadImageCookie = (function(url, originUrl) {\n        url = utilsUrl.getProcessUrl(url, originUrl);\n        this.tokenCookieHost = utilsUrl.getHost(url);\n        //utils.loadImage(url, onImageCookieLoaded, onImageCookieError);\n        var iframe = document.createElement('iframe');\n        this.tokenIFrame = iframe;\n        iframe.onload = onImageCookieLoaded;\n        iframe.src = url;\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);   \n    }).bind(this);\n\n    //if (false && this.config.authorization) {\n    if (this.config.authorization) {\n        this.tokenCookieLoaded = false;\n\n        if (typeof this.config.authorization === 'string') {\n            utils.loadJSON(this.config.authorization, onAutorizationLoaded, onAutorizationError, null, utils.useCredentials, this.xhrParams);\n        } else {\n            this.config.authorization(onAutorizationLoaded);\n        }\n    } else {\n        onLoadMapconfig(path);\n    }\n};\n\n\nCore.prototype.destroy = function() {\n    if (this.killed) {\n        return;\n    }\n\n    this.destroyMap();\n    if (this.renderer) {\n        this.renderer.kill();\n    }\n    this.element = null;\n    this.killed = true;\n};\n\n\nCore.prototype.destroyMap = function() {\n    if (this.map) {\n        this.map.kill();\n        this.map = null;\n        this.mapInterface = null;\n        this.callListener('map-unloaded', {});\n    }\n};\n\n\nCore.prototype.getMap = function() {\n    return this.map;\n};\n\n\nCore.prototype.getMapInterface = function() {\n    return this.mapInterface;\n};\n\n\nCore.prototype.getRenderer = function() {\n    return this.renderer;\n};\n\n\nCore.prototype.getRendererInterface = function() {\n    return this.rendererInterface;\n};\n\n\nCore.prototype.getProj4 = function() {\n    return this.proj4;\n};\n\n\nCore.prototype.getOption = function(/*key, value*/) {\n};\n\n\nCore.prototype.setOption = function(/*key, value*/) {\n};\n\n\nCore.prototype.on = function(name, listener, wait, once) {\n    if (this.killed) { // || this.renderer == null) {\n        return;\n    }\n\n    if (listener == null) {\n        return;\n    }\n\n    this.listenerCounter++;\n    this.listeners.push({ name : name, listener : listener, id : this.listenerCounter, once: once, wait: wait ? wait : 0 });\n\n    return (function(id){ this.removeListener(id); }).bind(this, this.listenerCounter);\n};\n\n\nCore.prototype.once = function(name, listener, wait) {\n    this.on(name, listener, wait, true);\n};\n\n\n// private\nCore.prototype.callListener = function(name, event, log) {\n    for (var i = 0; i < this.listeners.length; i++) {\n        if (this.listeners[i].name == name) {\n            var listener = this.listeners[i];\n\n            if (listener.wait > 0) {\n                listener.wait--;\n            } else {\n                listener.listener(event);\n                if (listener.once) {\n                    this.listeners.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    \n    if (log) {\n        // eslint-disable-next-line\n        console.log('event ' + name + ': ' + JSON.stringify(event));\n    }\n};\n\n// private\nCore.prototype.removeListener = function(id) {\n    for (var i = 0; i < this.listeners.length; i++) {\n        if (this.listeners[i].id == id) {\n            //this.listeners[i].splice(i, 1);\n            this.listeners.splice(i, 1);\n            return;\n        }\n    }\n};\n\nCore.prototype.markDirty = function() {\n    if (this.map != null) {\n        this.map.markDirty();\n    }\n};\n\nCore.prototype.onUpdate = function() {\n    if (this.killed || this.contextLost) {\n        return;\n    }\n\n    if (this.map != null) {\n        if (!this.map.srsReady && this.map.isReferenceFrameReady()) {\n            this.map.srsReady = true;\n            this.callListener('map-loaded', { 'browserOptions':this.map.browserOptions});\n        }\n\n        this.map.update();\n    }\n\n    //TODO: detect view change\n    //this.callListener(\"view-update\", {\"position\": position, \"orientaion\":orientation,\n    //                                  \"fov\": renderer.camera.getFov()});\n\n    //this.callListener(\"render-update\", { \"dirty\": true, \"message\": \"DOM element does not exist\" });\n\n    this.callListener('tick', {});\n\n    this.requestAnimFrame.call(window, this.onUpdate.bind(this));\n};\n\n\nCore.prototype.setConfigParams = function(params, solveStorage) {\n    if (typeof params === 'object' && params !== null) {\n        for (var key in params) {\n            this.setConfigParam(key, params[key], solveStorage);\n        }\n    }\n};\n\n\nCore.prototype.setConfigParam = function(key, value, solveStorage) {\n    if (key == 'pos' || key == 'position' || key == 'view') {\n        if (this.getMap()) {\n            if (key == 'view') {\n                this.getMap().setView(value);\n            } else {\n                this.getMap().setPosition(new MapPosition(value));\n            }\n            if (this.configStorage[key]) {\n                delete this.configStorage[key];\n            }\n        } else {\n            this.configStorage[key] = value;\n        }\n    } else if (key == 'map') {\n        this.config.map = utils.validateString(value, null);\n    } else if (key == 'mapVirtualSurfaces') {\n        this.config.mapVirtualSurfaces = utils.validateBool(value, true);\n    } else if (key == 'mapForcePipeline') {\n        this.config.mapForcePipeline = utils.validateNumber(value, -1, Number.MAXINTEGER, 0);\n    } else if (key == 'map16bitMeshes') {\n        this.config.map16bitMeshes = utils.validateBool(value, false);\n    } else if (key == 'inspector') {\n        this.config.inspector = utils.validateBool(value, true);\n    } else if (key == 'authorization') {\n        this.config.authorization = ((typeof value === 'string') || (typeof value === 'function')) ? value : null;   \n    } else {\n        if (key.indexOf('map') == 0 || key == 'mario') {\n           \n            if (!solveStorage || (typeof this.configStorage[key] === 'undefined')) {\n                this.configStorage[key] = value;\n            }\n\n            if (this.getMap() != null) {\n                this.getMap().setConfigParam(key, value);\n            }\n        }\n\n        if (key.indexOf('renderer') == 0) {\n            this.setRendererConfigParam(key, value);\n        }\n\n        if (key.indexOf('debug') == 0) {\n            this.configStorage[key] = value;\n            if (this.getMap() != null) {\n                this.inspector.setParameter(key, value);\n            }\n        }\n    }\n};\n\n\nCore.prototype.getConfigParam = function(key) {\n    if (key == 'map') {\n        return this.config.map;\n    } else if (key == 'inspector') {\n        return this.config.inspector;\n    } else {\n        if (key.indexOf('map') == 0 && this.getMap() != null) {\n            return this.getMap().getConfigParam(key);\n        }\n\n        if (key.indexOf('renderer') == 0) {\n            return this.getRendererConfigParam(key);\n        }\n    }\n};\n\n\nCore.prototype.setRendererConfigParam = function(key, value) {\n    switch (key) {\n    case 'rendererAnisotropic':        this.config.rendererAnisotropic = utils.validateNumber(value, -1, 2048, 0); break;\n    case 'rendererAntialiasing':       this.config.rendererAntialiasing = utils.validateBool(value, true); break;\n    case 'rendererAllowScreenshots':   this.config.rendererAllowScreenshots = utils.validateBool(value, false); break;\n    }\n};\n\n\nCore.prototype.getRendererConfigParam = function(key) {\n    switch (key) {\n    case 'rendererAnisotropic':        return this.config.rendererAnisotropic;\n    case 'rendererAntialiasing':       return this.config.rendererAntialiasing;\n    case 'rendererAllowScreenshots':   return this.config.rendererAllowScreenshots;\n    }\n};\n\n/*\nstring getCoreVersion()\n\n    Returns string with VTS version\n*/\n\nfunction getCoreVersion(full) {\n    return (full ? 'Core: ' : '') + '2.17.7';\n}\n\n\n/*\nbool checkSupport()\n\n    Returns true if the environment is capable of running the WebGL browser, false otherwise.\n*/\n\nfunction checkSupport() {\n    platform.init();\n\n    //is webgl supported\n    var canvas = document.createElement('canvas');\n\n    if (canvas == null) {\n        return false;\n    }\n\n    canvas.width = 1024;\n    canvas.height = 768;\n\n    if (canvas.getContext == null) {\n        return false;\n    }\n\n    var gl = null;\n\n    try {\n        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    } catch(e) {\n        return false;\n    }\n\n    if (!gl) {\n        return false;\n    }\n\n    return true;\n}\n\n\nexport {Core,getCoreVersion,checkSupport};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/core.js\n// module id = 13\n// module chunks = 0 1","export default function(x) {\n  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/e0fn.js\n// module id = 14\n// module chunks = 0 1","export default function(x) {\n  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/e1fn.js\n// module id = 15\n// module chunks = 0 1","export default function(x) {\n  return (0.05859375 * x * x * (1 + 0.75 * x));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/e2fn.js\n// module id = 16\n// module chunks = 0 1","export default function(x) {\n  return (x * x * x * (35 / 3072));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/e3fn.js\n// module id = 17\n// module chunks = 0 1","export default function(e0, e1, e2, e3, phi) {\n  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/mlfn.js\n// module id = 18\n// module chunks = 0 1","import {HALF_PI} from '../constants/values';\n\nexport default function(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = HALF_PI - 2 * Math.atan(ts);\n  for (var i = 0; i <= 15; i++) {\n    con = eccent * Math.sin(phi);\n    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n  //console.log(\"phi2z has NoConvergence\");\n  return -9999;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/phi2z.js\n// module id = 19\n// module chunks = 0 1","import {HALF_PI} from '../constants/values';\n\nexport default function(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow(((1 - con) / (1 + con)), com);\n  return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/tsfnz.js\n// module id = 20\n// module chunks = 0 1","import proj4 from './core';\nimport Proj from \"./Proj\";\nimport Point from \"./Point\";\nimport common from \"./common/toPoint\";\nimport defs from \"./defs\";\nimport transform from \"./transform\";\nimport mgrs from \"mgrs\";\nimport version from \"./version\";\nimport includedProjections from \"../projs\";\n\nproj4.defaultDatum = 'WGS84'; //default datum\nproj4.Proj = Proj;\nproj4.WGS84 = new proj4.Proj('WGS84');\nproj4.Point = Point;\nproj4.toPoint = common;\nproj4.defs = defs;\nproj4.transform = transform;\nproj4.mgrs = mgrs;\nproj4.version = version;\nincludedProjections(proj4);\nexport default proj4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/index.js\n// module id = 21\n// module chunks = 0 1","\nvar platform = {\n\n    initialized : false,\n\n    init: function () {\n\n        var self = platform;\n\n        self.browser = self.searchString(self.dataBrowser) || 'An unknown browser';\n        self.version = self.searchVersion(navigator.userAgent.toLowerCase()) || self.searchVersion(navigator.appVersion) || 'an unknown version';\n        self.OS = self.searchString(self.dataOS) || 'an unknown os: ua: ' + navigator.userAgent + ' pl: ' + navigator.platform;\n\n        self.mobile = (self.OS == 'iphone/ipod' || self.OS == 'android' || self.OS == 'ipad' || self.OS == 'windows ce'  || self.OS == 'windows phone' || self.OS == 'kindle');\n        self.mobileAndroid = (self.OS == 'android');\n        self.initialized = true;\n    },\n\n    getBrowser : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.browser;\n    },\n\n    getBrowserVersion : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.browser;\n    },\n\n    getOS : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.browser;\n    },\n\n    isMobile : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.mobile;\n    },\n    \n    isAndroid : function() {\n        if(!platform.initialized) { platform.init(); }\n        return platform.mobileAndroid;\n    },\n\n    searchString: function (data) {\n        var self = platform;\n        for (var i=0; i<data.length; i++) {\n            var dataString = data[i].string;\n            var dataProp = data[i].prop;\n            self.versionSearchString = data[i].versionSearch || data[i].identity;\n\n            if (dataString) {\n                if (dataString.toLowerCase().indexOf(data[i].subString) != -1) {\n                    if (data[i].version != null) {\n                        self.version = data[i].version;\n                    }\n                    return data[i].identity;\n                }\n            } else if (dataProp) {\n                return data[i].identity;\n            }\n        }\n    },\n\n    searchVersion: function (dataString) {\n        var self = platform;\n        if (self.version != null) {\n            return self.version;\n        }\n        var index = dataString.indexOf(self.versionSearchString);\n        if (index == -1) return;\n        return parseFloat(dataString.substring(index+self.versionSearchString.length+1));\n    },\n\n    dataBrowser: [\n        {\n            string: navigator.userAgent,\n            subString: 'chrome',\n            identity: 'chrome'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'firefox',\n            identity: 'firefox'\n        },\n        {\n            string: navigator.vendor,\n            subString: 'apple',\n            identity: 'safari',\n            versionSearch: 'version'\n        },\n        {\n            prop: window.opera,\n            identity: 'opera',\n            versionSearch: 'version'\n        },\n        {\n            string: navigator.vendor,\n            subString: 'icab',\n            identity: 'icab'\n        },\n        {\n            string: navigator.vendor,\n            subString: 'kde',\n            identity: 'konqueror'\n        },\n        {\n            string: navigator.vendor,\n            subString: 'camino',\n            identity: 'camino'\n        },\n        {       // for newer Netscapes (6+)\n            string: navigator.userAgent,\n            subString: 'netscape',\n            identity: 'netscape'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'msie',\n            identity: 'explorer',\n            versionSearch: 'msie'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'trident/',\n            identity: 'explorer',\n            version: '11'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'edge/',\n            identity: 'explorer',\n            version: '12'\n        },\n        {   string: navigator.userAgent,\n            subString: 'omniweb',\n            versionSearch: 'omniweb/',\n            identity: 'omniweb'\n        },\n        {   string: navigator.userAgent,\n            subString: 'silk',\n            versionSearch: 'silk/',\n            identity: 'silk'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'gecko',\n            identity: 'mozilla',\n            versionSearch: 'rv'\n        },\n        {       // for older Netscapes (4-)\n            string: navigator.userAgent,\n            subString: 'mozilla',\n            identity: 'netscape',\n            versionSearch: 'mozilla'\n        }\n    ],\n\n    dataOS : [\n        {\n            string: navigator.userAgent,\n            subString: 'windows ce',\n            identity: 'windows ce'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'windows phone',\n            identity: 'windows phone'\n        },\n        {\n            string: navigator.platform,\n            subString: 'win',\n            identity: 'windows'\n        },\n        {\n            string: navigator.platform,\n            subString: 'mac',\n            identity: 'mac'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'iphone',\n            identity: 'iphone/ipod'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'ipod',\n            identity: 'iphone/ipod'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'ipad',\n            identity: 'ipad'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'android',\n            identity: 'android'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'silk',\n            identity: 'kindle'\n        },\n        {\n            string: navigator.userAgent,\n            subString: 'blackberry',\n            identity: 'blackberry'\n        },\n        {\n            string: navigator.platform,\n            subString: 'linux',\n            identity: 'linux'\n        }\n    ]\n\n};\n\nexport {platform};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/utils/platform.js\n// module id = 22\n// module chunks = 0 1","/*\n * Geodesic routines from GeographicLib translated to JavaScript.  See\n * https://geographiclib.sourceforge.io/html/js/\n *\n * The algorithms are derived in\n *\n *    Charles F. F. Karney,\n *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013),\n *    https://doi.org/10.1007/s00190-012-0578-z\n *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html\n *\n * This file is the concatenation and compression of the JavaScript files in\n * doc/scripts/GeographicLib in the source tree for GeographicLib.\n *\n * Copyright (c) Charles Karney (2011-2015) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n *\n * Version: 1.48\n * File inventory:\n *   Math.js Geodesic.js GeodesicLine.js PolygonArea.js DMS.js\n */\n\n(function(cb) {\n\n/**************** Math.js ****************/\n/*\n * Math.js\n * Transcription of Math.hpp, Constants.hpp, and Accumulator.hpp into\n * JavaScript.\n *\n * Copyright (c) Charles Karney (2011-2017) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\n/**\n * @namespace GeographicLib\n * @description The parent namespace for the following modules:\n * - {@link module:GeographicLib/Geodesic GeographicLib/Geodesic} The main\n *   engine for solving geodesic problems via the\n *   {@link module:GeographicLib/Geodesic.Geodesic Geodesic} class.\n * - {@link module:GeographicLib/GeodesicLine GeographicLib/GeodesicLine}\n *   computes points along a single geodesic line via the\n *   {@link module:GeographicLib/GeodesicLine.GeodesicLine GeodesicLine}\n *   class.\n * - {@link module:GeographicLib/PolygonArea GeographicLib/PolygonArea}\n *   computes the area of a geodesic polygon via the\n *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea}\n *   class.\n * - {@link module:GeographicLib/DMS GeographicLib/DMS} handles the decoding\n *   and encoding of angles in degree, minutes, and seconds, via static\n *   functions in this module.\n * - {@link module:GeographicLib/Constants GeographicLib/Constants} defines\n *   constants specifying the version numbers and the parameters for the WGS84\n *   ellipsoid.\n *\n * The following modules are used internally by the package:\n * - {@link module:GeographicLib/Math GeographicLib/Math} defines various\n *   mathematical functions.\n * - {@link module:GeographicLib/Accumulator GeographicLib/Accumulator}\n *   interally used by\n *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea} (via the\n *   {@link module:GeographicLib/Accumulator.Accumulator Accumulator} class)\n *   for summing the contributions to the area of a polygon.\n */\n\"use strict\";\nvar GeographicLib = {};\nGeographicLib.Constants = {};\nGeographicLib.Math = {};\nGeographicLib.Accumulator = {};\n\n(function(\n  /**\n   * @exports GeographicLib/Constants\n   * @description Define constants defining the version and WGS84 parameters.\n   */\n  c) {\n\n  /**\n   * @constant\n   * @summary WGS84 parameters.\n   * @property {number} a the equatorial radius (meters).\n   * @property {number} f the flattening.\n   */\n  c.WGS84 = { a: 6378137, f: 1/298.257223563 };\n  /**\n   * @constant\n   * @summary an array of version numbers.\n   * @property {number} major the major version number.\n   * @property {number} minor the minor version number.\n   * @property {number} patch the patch number.\n   */\n  c.version = { major: 1, minor: 48, patch: 0 };\n  /**\n   * @constant\n   * @summary version string\n   */\n  c.version_string = \"1.48\";\n})(GeographicLib.Constants);\n\n(function(\n  /**\n   * @exports GeographicLib/Math\n   * @description Some useful mathematical constants and functions (mainly for\n   *   internal use).\n   */\n  m) {\n\n  /**\n   * @summary The number of digits of precision in floating-point numbers.\n   * @constant {number}\n   */\n  m.digits = 53;\n  /**\n   * @summary The machine epsilon.\n   * @constant {number}\n   */\n  m.epsilon = Math.pow(0.5, m.digits - 1);\n  /**\n   * @summary The factor to convert degrees to radians.\n   * @constant {number}\n   */\n  m.degree = Math.PI/180;\n\n  /**\n   * @summary Square a number.\n   * @param {number} x the number.\n   * @returns {number} the square.\n   */\n  m.sq = function(x) { return x * x; };\n\n  /**\n   * @summary The hypotenuse function.\n   * @param {number} x the first side.\n   * @param {number} y the second side.\n   * @returns {number} the hypotenuse.\n   */\n  m.hypot = function(x, y) {\n    var a, b;\n    x = Math.abs(x);\n    y = Math.abs(y);\n    a = Math.max(x, y); b = Math.min(x, y) / (a ? a : 1);\n    return a * Math.sqrt(1 + b * b);\n  };\n\n  /**\n   * @summary Cube root function.\n   * @param {number} x the argument.\n   * @returns {number} the real cube root.\n   */\n  m.cbrt = function(x) {\n    var y = Math.pow(Math.abs(x), 1/3);\n    return x < 0 ? -y : y;\n  };\n\n  /**\n   * @summary The log1p function.\n   * @param {number} x the argument.\n   * @returns {number} log(1 + x).\n   */\n  m.log1p = function(x) {\n    var y = 1 + x,\n        z = y - 1;\n    // Here's the explanation for this magic: y = 1 + z, exactly, and z\n    // approx x, thus log(y)/z (which is nearly constant near z = 0) returns\n    // a good approximation to the true log(1 + x)/x.  The multiplication x *\n    // (log(y)/z) introduces little additional error.\n    return z === 0 ? x : x * Math.log(y) / z;\n  };\n\n  /**\n   * @summary Inverse hyperbolic tangent.\n   * @param {number} x the argument.\n   * @returns {number} tanh<sup>&minus;1</sup> x.\n   */\n  m.atanh = function(x) {\n    var y = Math.abs(x);          // Enforce odd parity\n    y = m.log1p(2 * y/(1 - y))/2;\n    return x < 0 ? -y : y;\n  };\n\n  /**\n   * @summary Copy the sign.\n   * @param {number} x gives the magitude of the result.\n   * @param {number} y gives the sign of the result.\n   * @returns {number} value with the magnitude of x and with the sign of y.\n   */\n  m.copysign = function(x, y) {\n    return Math.abs(x) * (y < 0 || (y === 0 && 1/y < 0) ? -1 : 1);\n  };\n\n  /**\n   * @summary An error-free sum.\n   * @param {number} u\n   * @param {number} v\n   * @returns {object} sum with sum.s = round(u + v) and sum.t is u + v &minus;\n   *   round(u + v)\n   */\n  m.sum = function(u, v) {\n    var s = u + v,\n        up = s - v,\n        vpp = s - up,\n        t;\n    up -= u;\n    vpp -= v;\n    t = -(up + vpp);\n    // u + v =       s      + t\n    //       = round(u + v) + t\n    return {s: s, t: t};\n  };\n\n  /**\n   * @summary Evaluate a polynomial.\n   * @param {integer} N the order of the polynomial.\n   * @param {array} p the coefficient array (of size N + 1) (leading\n   *   order coefficient first)\n   * @param {number} x the variable.\n   * @returns {number} the value of the polynomial.\n   */\n  m.polyval = function(N, p, s, x) {\n    var y = N < 0 ? 0 : p[s++];\n    while (--N >= 0) y = y * x + p[s++];\n    return y;\n  };\n\n  /**\n   * @summary Coarsen a value close to zero.\n   * @param {number} x\n   * @returns {number} the coarsened value.\n   */\n  m.AngRound = function(x) {\n    // The makes the smallest gap in x = 1/16 - nextafter(1/16, 0) = 1/2^57 for\n    // reals = 0.7 pm on the earth if x is an angle in degrees.  (This is about\n    // 1000 times more resolution than we get with angles around 90 degrees.)\n    // We use this to avoid having to deal with near singular cases when x is\n    // non-zero but tiny (e.g., 1.0e-200).  This converts -0 to +0; however\n    // tiny negative numbers get converted to -0.\n    if (x === 0) return x;\n    var z = 1/16,\n        y = Math.abs(x);\n    // The compiler mustn't \"simplify\" z - (z - y) to y\n    y = y < z ? z - (z - y) : y;\n    return x < 0 ? -y : y;\n  };\n\n  /**\n   * @summary Normalize an angle.\n   * @param {number} x the angle in degrees.\n   * @returns {number} the angle reduced to the range (&minus;180&deg;,\n   *   180&deg;].\n   */\n  m.AngNormalize = function(x) {\n    // Place angle in [-180, 180).\n    x = x % 360;\n    return x <= -180 ? x + 360 : (x <= 180 ? x : x - 360);\n  };\n\n  /**\n   * @summary Normalize a latitude.\n   * @param {number} x the angle in degrees.\n   * @returns {number} x if it is in the range [&minus;90&deg;, 90&deg;],\n   *   otherwise return NaN.\n   */\n  m.LatFix = function(x) {\n    // Replace angle with NaN if outside [-90, 90].\n    return Math.abs(x) > 90 ? Number.NaN : x;\n  };\n\n  /**\n   * @summary The exact difference of two angles reduced to (&minus;180&deg;,\n   *   180&deg;]\n   * @param {number} x the first angle in degrees.\n   * @param {number} y the second angle in degrees.\n   * @return {object} diff the exact difference, y &minus; x.\n   *\n   * This computes z = y &minus; x exactly, reduced to (&minus;180&deg;,\n   * 180&deg;]; and then sets diff.s = d = round(z) and diff.t = e = z &minus;\n   * round(z).  If d = &minus;180, then e &gt; 0; If d = 180, then e &le; 0.\n   */\n  m.AngDiff = function(x, y) {\n    // Compute y - x and reduce to [-180,180] accurately.\n    var r = m.sum(m.AngNormalize(-x), m.AngNormalize(y)),\n        d = m.AngNormalize(r.s),\n        t = r.t;\n    return m.sum(d === 180 && t > 0 ? -180 : d, t);\n  };\n\n  /**\n   * @summary Evaluate the sine and cosine function with the argument in\n   *   degrees\n   * @param {number} x in degrees.\n   * @returns {object} r with r.s = sin(x) and r.c = cos(x).\n   */\n  m.sincosd = function(x) {\n    // In order to minimize round-off errors, this function exactly reduces\n    // the argument to the range [-45, 45] before converting it to radians.\n    var r, q, s, c, sinx, cosx;\n    r = x % 360;\n    q = Math.floor(r / 90 + 0.5);\n    r -= 90 * q;\n    // now abs(r) <= 45\n    r *= this.degree;\n    // Possibly could call the gnu extension sincos\n    s = Math.sin(r); c = Math.cos(r);\n    switch (q & 3) {\n      case 0:  sinx =  s; cosx =  c; break;\n      case 1:  sinx =  c; cosx = -s; break;\n      case 2:  sinx = -s; cosx = -c; break;\n      default: sinx = -c; cosx =  s; break; // case 3\n    }\n    if (x) { sinx += 0; cosx += 0; }\n    return {s: sinx, c: cosx};\n  };\n\n  /**\n   * @summary Evaluate the atan2 function with the result in degrees\n   * @param {number} y\n   * @param {number} x\n   * @returns atan2(y, x) in degrees, in the range (&minus;180&deg;\n   *   180&deg;].\n   */\n  m.atan2d = function(y, x) {\n    // In order to minimize round-off errors, this function rearranges the\n    // arguments so that result of atan2 is in the range [-pi/4, pi/4] before\n    // converting it to degrees and mapping the result to the correct\n    // quadrant.\n    var q = 0, t, ang;\n    if (Math.abs(y) > Math.abs(x)) { t = x; x = y; y = t; q = 2; }\n    if (x < 0) { x = -x; ++q; }\n    // here x >= 0 and x >= abs(y), so angle is in [-pi/4, pi/4]\n    ang = Math.atan2(y, x) / this.degree;\n    switch (q) {\n      // Note that atan2d(-0.0, 1.0) will return -0.  However, we expect that\n      // atan2d will not be called with y = -0.  If need be, include\n      //\n      //   case 0: ang = 0 + ang; break;\n      //\n      // and handle mpfr as in AngRound.\n      case 1: ang = (y >= 0 ? 180 : -180) - ang; break;\n      case 2: ang =  90 - ang; break;\n      case 3: ang = -90 + ang; break;\n    }\n    return ang;\n  };\n})(GeographicLib.Math);\n\n(function(\n  /**\n   * @exports GeographicLib/Accumulator\n   * @description Accurate summation via the\n   *   {@link module:GeographicLib/Accumulator.Accumulator Accumulator} class\n   *   (mainly for internal use).\n   */\n  a, m) {\n\n  /**\n   * @class\n   * @summary Accurate summation of many numbers.\n   * @classdesc This allows many numbers to be added together with twice the\n   *   normal precision.  In the documentation of the member functions, sum\n   *   stands for the value currently held in the accumulator.\n   * @param {number | Accumulator} [y = 0]  set sum = y.\n   */\n  a.Accumulator = function(y) {\n    this.Set(y);\n  };\n\n  /**\n   * @summary Set the accumulator to a number.\n   * @param {number | Accumulator} [y = 0] set sum = y.\n   */\n  a.Accumulator.prototype.Set = function(y) {\n    if (!y) y = 0;\n    if (y.constructor === a.Accumulator) {\n      this._s = y._s;\n      this._t = y._t;\n    } else {\n      this._s = y;\n      this._t = 0;\n    }\n  };\n\n  /**\n   * @summary Add a number to the accumulator.\n   * @param {number} [y = 0] set sum += y.\n   */\n  a.Accumulator.prototype.Add = function(y) {\n    // Here's Shewchuk's solution...\n    // Accumulate starting at least significant end\n    var u = m.sum(y, this._t),\n        v = m.sum(u.s, this._s);\n    u = u.t;\n    this._s = v.s;\n    this._t = v.t;\n    // Start is _s, _t decreasing and non-adjacent.  Sum is now (s + t + u)\n    // exactly with s, t, u non-adjacent and in decreasing order (except\n    // for possible zeros).  The following code tries to normalize the\n    // result.  Ideally, we want _s = round(s+t+u) and _u = round(s+t+u -\n    // _s).  The follow does an approximate job (and maintains the\n    // decreasing non-adjacent property).  Here are two \"failures\" using\n    // 3-bit floats:\n    //\n    // Case 1: _s is not equal to round(s+t+u) -- off by 1 ulp\n    // [12, -1] - 8 -> [4, 0, -1] -> [4, -1] = 3 should be [3, 0] = 3\n    //\n    // Case 2: _s+_t is not as close to s+t+u as it shold be\n    // [64, 5] + 4 -> [64, 8, 1] -> [64,  8] = 72 (off by 1)\n    //                    should be [80, -7] = 73 (exact)\n    //\n    // \"Fixing\" these problems is probably not worth the expense.  The\n    // representation inevitably leads to small errors in the accumulated\n    // values.  The additional errors illustrated here amount to 1 ulp of\n    // the less significant word during each addition to the Accumulator\n    // and an additional possible error of 1 ulp in the reported sum.\n    //\n    // Incidentally, the \"ideal\" representation described above is not\n    // canonical, because _s = round(_s + _t) may not be true.  For\n    // example, with 3-bit floats:\n    //\n    // [128, 16] + 1 -> [160, -16] -- 160 = round(145).\n    // But [160, 0] - 16 -> [128, 16] -- 128 = round(144).\n    //\n    if (this._s === 0)          // This implies t == 0,\n      this._s = u;              // so result is u\n    else\n      this._t += u;             // otherwise just accumulate u to t.\n  };\n\n  /**\n   * @summary Return the result of adding a number to sum (but\n   *   don't change sum).\n   * @param {number} [y = 0] the number to be added to the sum.\n   * @return sum + y.\n   */\n  a.Accumulator.prototype.Sum = function(y) {\n    var b;\n    if (!y)\n      return this._s;\n    else {\n      b = new a.Accumulator(this);\n      b.Add(y);\n      return b._s;\n    }\n  };\n\n  /**\n   * @summary Set sum = &minus;sum.\n   */\n  a.Accumulator.prototype.Negate = function() {\n    this._s *= -1;\n    this._t *= -1;\n  };\n})(GeographicLib.Accumulator, GeographicLib.Math);\n\n/**************** Geodesic.js ****************/\n/*\n * Geodesic.js\n * Transcription of Geodesic.[ch]pp into JavaScript.\n *\n * See the documentation for the C++ class.  The conversion is a literal\n * conversion from C++.\n *\n * The algorithms are derived in\n *\n *    Charles F. F. Karney,\n *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);\n *    https://doi.org/10.1007/s00190-012-0578-z\n *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html\n *\n * Copyright (c) Charles Karney (2011-2017) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\n// Load AFTER Math.js\n\nGeographicLib.Geodesic = {};\nGeographicLib.GeodesicLine = {};\nGeographicLib.PolygonArea = {};\n\n(function(\n  /**\n   * @exports GeographicLib/Geodesic\n   * @description Solve geodesic problems via the\n   *   {@link module:GeographicLib/Geodesic.Geodesic Geodesic} class.\n   */\n  g, l, p, m, c) {\n\n  var GEOGRAPHICLIB_GEODESIC_ORDER = 6,\n      nA1_ = GEOGRAPHICLIB_GEODESIC_ORDER,\n      nA2_ = GEOGRAPHICLIB_GEODESIC_ORDER,\n      nA3_ = GEOGRAPHICLIB_GEODESIC_ORDER,\n      nA3x_ = nA3_,\n      nC3x_, nC4x_,\n      maxit1_ = 20,\n      maxit2_ = maxit1_ + m.digits + 10,\n      tol0_ = m.epsilon,\n      tol1_ = 200 * tol0_,\n      tol2_ = Math.sqrt(tol0_),\n      tolb_ = tol0_ * tol1_,\n      xthresh_ = 1000 * tol2_,\n      CAP_NONE = 0,\n      CAP_ALL  = 0x1F,\n      CAP_MASK = CAP_ALL,\n      OUT_ALL  = 0x7F80,\n      astroid,\n      A1m1f_coeff, C1f_coeff, C1pf_coeff,\n      A2m1f_coeff, C2f_coeff,\n      A3_coeff, C3_coeff, C4_coeff;\n\n  g.tiny_ = Math.sqrt(Number.MIN_VALUE);\n  g.nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  g.nC1p_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  g.nC2_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  g.nC3_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  g.nC4_ = GEOGRAPHICLIB_GEODESIC_ORDER;\n  nC3x_ = (g.nC3_ * (g.nC3_ - 1)) / 2;\n  nC4x_ = (g.nC4_ * (g.nC4_ + 1)) / 2;\n  g.CAP_C1   = 1<<0;\n  g.CAP_C1p  = 1<<1;\n  g.CAP_C2   = 1<<2;\n  g.CAP_C3   = 1<<3;\n  g.CAP_C4   = 1<<4;\n\n  g.NONE          = 0;\n  g.ARC           = 1<<6;\n  g.LATITUDE      = 1<<7  | CAP_NONE;\n  g.LONGITUDE     = 1<<8  | g.CAP_C3;\n  g.AZIMUTH       = 1<<9  | CAP_NONE;\n  g.DISTANCE      = 1<<10 | g.CAP_C1;\n  g.STANDARD      = g.LATITUDE | g.LONGITUDE | g.AZIMUTH | g.DISTANCE;\n  g.DISTANCE_IN   = 1<<11 | g.CAP_C1 | g.CAP_C1p;\n  g.REDUCEDLENGTH = 1<<12 | g.CAP_C1 | g.CAP_C2;\n  g.GEODESICSCALE = 1<<13 | g.CAP_C1 | g.CAP_C2;\n  g.AREA          = 1<<14 | g.CAP_C4;\n  g.ALL           = OUT_ALL| CAP_ALL;\n  g.LONG_UNROLL   = 1<<15;\n  g.OUT_MASK      = OUT_ALL| g.LONG_UNROLL;\n\n  g.SinCosSeries = function(sinp, sinx, cosx, c) {\n    // Evaluate\n    // y = sinp ? sum(c[i] * sin( 2*i    * x), i, 1, n) :\n    //            sum(c[i] * cos((2*i+1) * x), i, 0, n-1)\n    // using Clenshaw summation.  N.B. c[0] is unused for sin series\n    // Approx operation count = (n + 5) mult and (2 * n + 2) add\n    var k = c.length,           // Point to one beyond last element\n        n = k - (sinp ? 1 : 0),\n        ar = 2 * (cosx - sinx) * (cosx + sinx), // 2 * cos(2 * x)\n        y0 = n & 1 ? c[--k] : 0, y1 = 0;        // accumulators for sum\n    // Now n is even\n    n = Math.floor(n/2);\n    while (n--) {\n      // Unroll loop x 2, so accumulators return to their original role\n      y1 = ar * y0 - y1 + c[--k];\n      y0 = ar * y1 - y0 + c[--k];\n    }\n    return (sinp ? 2 * sinx * cosx * y0 : // sin(2 * x) * y0\n            cosx * (y0 - y1));            // cos(x) * (y0 - y1)\n  };\n\n  astroid = function(x, y) {\n    // Solve k^4+2*k^3-(x^2+y^2-1)*k^2-2*y^2*k-y^2 = 0 for positive\n    // root k.  This solution is adapted from Geocentric::Reverse.\n    var k,\n        p = m.sq(x),\n        q = m.sq(y),\n        r = (p + q - 1) / 6,\n        S, r2, r3, disc, u, T3, T, ang, v, uv, w;\n    if ( !(q === 0 && r <= 0) ) {\n      // Avoid possible division by zero when r = 0 by multiplying\n      // equations for s and t by r^3 and r, resp.\n      S = p * q / 4;            // S = r^3 * s\n      r2 = m.sq(r);\n      r3 = r * r2;\n      // The discriminant of the quadratic equation for T3.  This is\n      // zero on the evolute curve p^(1/3)+q^(1/3) = 1\n      disc = S * (S + 2 * r3);\n      u = r;\n      if (disc >= 0) {\n        T3 = S + r3;\n        // Pick the sign on the sqrt to maximize abs(T3).  This\n        // minimizes loss of precision due to cancellation.  The\n        // result is unchanged because of the way the T is used\n        // in definition of u.\n        T3 += T3 < 0 ? -Math.sqrt(disc) : Math.sqrt(disc);    // T3 = (r * t)^3\n        // N.B. cbrt always returns the real root.  cbrt(-8) = -2.\n        T = m.cbrt(T3);     // T = r * t\n        // T can be zero; but then r2 / T -> 0.\n        u += T + (T !== 0 ? r2 / T : 0);\n      } else {\n        // T is complex, but the way u is defined the result is real.\n        ang = Math.atan2(Math.sqrt(-disc), -(S + r3));\n        // There are three possible cube roots.  We choose the\n        // root which avoids cancellation.  Note that disc < 0\n        // implies that r < 0.\n        u += 2 * r * Math.cos(ang / 3);\n      }\n      v = Math.sqrt(m.sq(u) + q);       // guaranteed positive\n      // Avoid loss of accuracy when u < 0.\n      uv = u < 0 ? q / (v - u) : u + v; // u+v, guaranteed positive\n      w = (uv - q) / (2 * v);           // positive?\n      // Rearrange expression for k to avoid loss of accuracy due to\n      // subtraction.  Division by 0 not possible because uv > 0, w >= 0.\n      k = uv / (Math.sqrt(uv + m.sq(w)) + w); // guaranteed positive\n    } else {                                  // q == 0 && r <= 0\n      // y = 0 with |x| <= 1.  Handle this case directly.\n      // for y small, positive root is k = abs(y)/sqrt(1-x^2)\n      k = 0;\n    }\n    return k;\n  };\n\n  A1m1f_coeff = [\n    // (1-eps)*A1-1, polynomial in eps2 of order 3\n      +1, 4, 64, 0, 256\n  ];\n\n  // The scale factor A1-1 = mean value of (d/dsigma)I1 - 1\n  g.A1m1f = function(eps) {\n    var p = Math.floor(nA1_/2),\n        t = m.polyval(p, A1m1f_coeff, 0, m.sq(eps)) / A1m1f_coeff[p + 1];\n    return (t + eps) / (1 - eps);\n  };\n\n  C1f_coeff = [\n    // C1[1]/eps^1, polynomial in eps2 of order 2\n      -1, 6, -16, 32,\n    // C1[2]/eps^2, polynomial in eps2 of order 2\n      -9, 64, -128, 2048,\n    // C1[3]/eps^3, polynomial in eps2 of order 1\n      +9, -16, 768,\n    // C1[4]/eps^4, polynomial in eps2 of order 1\n      +3, -5, 512,\n    // C1[5]/eps^5, polynomial in eps2 of order 0\n      -7, 1280,\n    // C1[6]/eps^6, polynomial in eps2 of order 0\n      -7, 2048\n  ];\n\n  // The coefficients C1[l] in the Fourier expansion of B1\n  g.C1f = function(eps, c) {\n    var eps2 = m.sq(eps),\n        d = eps,\n        o = 0,\n        l, p;\n    for (l = 1; l <= g.nC1_; ++l) {     // l is index of C1p[l]\n      p = Math.floor((g.nC1_ - l) / 2); // order of polynomial in eps^2\n      c[l] = d * m.polyval(p, C1f_coeff, o, eps2) / C1f_coeff[o + p + 1];\n      o += p + 2;\n      d *= eps;\n    }\n  };\n\n  C1pf_coeff = [\n    // C1p[1]/eps^1, polynomial in eps2 of order 2\n      +205, -432, 768, 1536,\n    // C1p[2]/eps^2, polynomial in eps2 of order 2\n      +4005, -4736, 3840, 12288,\n    // C1p[3]/eps^3, polynomial in eps2 of order 1\n      -225, 116, 384,\n    // C1p[4]/eps^4, polynomial in eps2 of order 1\n      -7173, 2695, 7680,\n    // C1p[5]/eps^5, polynomial in eps2 of order 0\n      +3467, 7680,\n    // C1p[6]/eps^6, polynomial in eps2 of order 0\n      +38081, 61440\n  ];\n\n  // The coefficients C1p[l] in the Fourier expansion of B1p\n  g.C1pf = function(eps, c) {\n    var eps2 = m.sq(eps),\n        d = eps,\n        o = 0,\n        l, p;\n    for (l = 1; l <= g.nC1p_; ++l) {     // l is index of C1p[l]\n      p = Math.floor((g.nC1p_ - l) / 2); // order of polynomial in eps^2\n      c[l] = d * m.polyval(p, C1pf_coeff, o, eps2) / C1pf_coeff[o + p + 1];\n      o += p + 2;\n      d *= eps;\n    }\n  };\n\n  A2m1f_coeff = [\n    // (eps+1)*A2-1, polynomial in eps2 of order 3\n      -11, -28, -192, 0, 256\n  ];\n\n  // The scale factor A2-1 = mean value of (d/dsigma)I2 - 1\n  g.A2m1f = function(eps) {\n    var p = Math.floor(nA2_/2),\n        t = m.polyval(p, A2m1f_coeff, 0, m.sq(eps)) / A2m1f_coeff[p + 1];\n    return (t - eps) / (1 + eps);\n  };\n\n  C2f_coeff = [\n    // C2[1]/eps^1, polynomial in eps2 of order 2\n      +1, 2, 16, 32,\n    // C2[2]/eps^2, polynomial in eps2 of order 2\n      +35, 64, 384, 2048,\n    // C2[3]/eps^3, polynomial in eps2 of order 1\n      +15, 80, 768,\n    // C2[4]/eps^4, polynomial in eps2 of order 1\n      +7, 35, 512,\n    // C2[5]/eps^5, polynomial in eps2 of order 0\n      +63, 1280,\n    // C2[6]/eps^6, polynomial in eps2 of order 0\n      +77, 2048\n  ];\n\n  // The coefficients C2[l] in the Fourier expansion of B2\n  g.C2f = function(eps, c) {\n    var eps2 = m.sq(eps),\n        d = eps,\n        o = 0,\n        l, p;\n    for (l = 1; l <= g.nC2_; ++l) {     // l is index of C2[l]\n      p = Math.floor((g.nC2_ - l) / 2); // order of polynomial in eps^2\n      c[l] = d * m.polyval(p, C2f_coeff, o, eps2) / C2f_coeff[o + p + 1];\n      o += p + 2;\n      d *= eps;\n    }\n  };\n\n  /**\n   * @class\n   * @property {number} a the equatorial radius (meters).\n   * @property {number} f the flattening.\n   * @summary Initialize a Geodesic object for a specific ellipsoid.\n   * @classdesc Performs geodesic calculations on an ellipsoid of revolution.\n   *   The routines for solving the direct and inverse problems return an\n   *   object with some of the following fields set: lat1, lon1, azi1, lat2,\n   *   lon2, azi2, s12, a12, m12, M12, M21, S12.  See {@tutorial 2-interface},\n   *   \"The results\".\n   * @example\n   * var GeographicLib = require(\"geographiclib\"),\n   *     geod = GeographicLib.Geodesic.WGS84;\n   * var inv = geod.Inverse(1,2,3,4);\n   * console.log(\"lat1 = \" + inv.lat1 + \", lon1 = \" + inv.lon1 +\n   *             \", lat2 = \" + inv.lat2 + \", lon2 = \" + inv.lon2 +\n   *             \",\\nazi1 = \" + inv.azi1 + \", azi2 = \" + inv.azi2 +\n   *             \", s12 = \" + inv.s12);\n   * @param {number} a the equatorial radius of the ellipsoid (meters).\n   * @param {number} f the flattening of the ellipsoid.  Setting f = 0 gives\n   *   a sphere (on which geodesics are great circles).  Negative f gives a\n   *   prolate ellipsoid.\n   * @throws an error if the parameters are illegal.\n   */\n  g.Geodesic = function(a, f) {\n    this.a = a;\n    this.f = f;\n    this._f1 = 1 - this.f;\n    this._e2 = this.f * (2 - this.f);\n    this._ep2 = this._e2 / m.sq(this._f1); // e2 / (1 - e2)\n    this._n = this.f / ( 2 - this.f);\n    this._b = this.a * this._f1;\n    // authalic radius squared\n    this._c2 = (m.sq(this.a) + m.sq(this._b) *\n                (this._e2 === 0 ? 1 :\n                 (this._e2 > 0 ? m.atanh(Math.sqrt(this._e2)) :\n                  Math.atan(Math.sqrt(-this._e2))) /\n                 Math.sqrt(Math.abs(this._e2))))/2;\n    // The sig12 threshold for \"really short\".  Using the auxiliary sphere\n    // solution with dnm computed at (bet1 + bet2) / 2, the relative error in\n    // the azimuth consistency check is sig12^2 * abs(f) * min(1, 1-f/2) / 2.\n    // (Error measured for 1/100 < b/a < 100 and abs(f) >= 1/1000.  For a given\n    // f and sig12, the max error occurs for lines near the pole.  If the old\n    // rule for computing dnm = (dn1 + dn2)/2 is used, then the error increases\n    // by a factor of 2.)  Setting this equal to epsilon gives sig12 = etol2.\n    // Here 0.1 is a safety factor (error decreased by 100) and max(0.001,\n    // abs(f)) stops etol2 getting too large in the nearly spherical case.\n    this._etol2 = 0.1 * tol2_ /\n      Math.sqrt( Math.max(0.001, Math.abs(this.f)) *\n                 Math.min(1.0, 1 - this.f/2) / 2 );\n    if (!(isFinite(this.a) && this.a > 0))\n      throw new Error(\"Equatorial radius is not positive\");\n    if (!(isFinite(this._b) && this._b > 0))\n      throw new Error(\"Polar semi-axis is not positive\");\n    this._A3x = new Array(nA3x_);\n    this._C3x = new Array(nC3x_);\n    this._C4x = new Array(nC4x_);\n    this.A3coeff();\n    this.C3coeff();\n    this.C4coeff();\n  };\n\n  A3_coeff = [\n    // A3, coeff of eps^5, polynomial in n of order 0\n      -3, 128,\n    // A3, coeff of eps^4, polynomial in n of order 1\n      -2, -3, 64,\n    // A3, coeff of eps^3, polynomial in n of order 2\n      -1, -3, -1, 16,\n    // A3, coeff of eps^2, polynomial in n of order 2\n      +3, -1, -2, 8,\n    // A3, coeff of eps^1, polynomial in n of order 1\n      +1, -1, 2,\n    // A3, coeff of eps^0, polynomial in n of order 0\n      +1, 1\n  ];\n\n  // The scale factor A3 = mean value of (d/dsigma)I3\n  g.Geodesic.prototype.A3coeff = function() {\n    var o = 0, k = 0,\n        j, p;\n    for (j = nA3_ - 1; j >= 0; --j) { // coeff of eps^j\n      p = Math.min(nA3_ - j - 1, j);  // order of polynomial in n\n      this._A3x[k++] = m.polyval(p, A3_coeff, o, this._n) /\n        A3_coeff[o + p + 1];\n      o += p + 2;\n    }\n  };\n\n  C3_coeff = [\n    // C3[1], coeff of eps^5, polynomial in n of order 0\n      +3, 128,\n    // C3[1], coeff of eps^4, polynomial in n of order 1\n      +2, 5, 128,\n    // C3[1], coeff of eps^3, polynomial in n of order 2\n      -1, 3, 3, 64,\n    // C3[1], coeff of eps^2, polynomial in n of order 2\n      -1, 0, 1, 8,\n    // C3[1], coeff of eps^1, polynomial in n of order 1\n      -1, 1, 4,\n    // C3[2], coeff of eps^5, polynomial in n of order 0\n      +5, 256,\n    // C3[2], coeff of eps^4, polynomial in n of order 1\n      +1, 3, 128,\n    // C3[2], coeff of eps^3, polynomial in n of order 2\n      -3, -2, 3, 64,\n    // C3[2], coeff of eps^2, polynomial in n of order 2\n      +1, -3, 2, 32,\n    // C3[3], coeff of eps^5, polynomial in n of order 0\n      +7, 512,\n    // C3[3], coeff of eps^4, polynomial in n of order 1\n      -10, 9, 384,\n    // C3[3], coeff of eps^3, polynomial in n of order 2\n      +5, -9, 5, 192,\n    // C3[4], coeff of eps^5, polynomial in n of order 0\n      +7, 512,\n    // C3[4], coeff of eps^4, polynomial in n of order 1\n      -14, 7, 512,\n    // C3[5], coeff of eps^5, polynomial in n of order 0\n      +21, 2560\n  ];\n\n  // The coefficients C3[l] in the Fourier expansion of B3\n  g.Geodesic.prototype.C3coeff = function() {\n    var o = 0, k = 0,\n        l, j, p;\n    for (l = 1; l < g.nC3_; ++l) {        // l is index of C3[l]\n      for (j = g.nC3_ - 1; j >= l; --j) { // coeff of eps^j\n        p = Math.min(g.nC3_ - j - 1, j);  // order of polynomial in n\n        this._C3x[k++] = m.polyval(p, C3_coeff, o, this._n) /\n          C3_coeff[o + p + 1];\n        o += p + 2;\n      }\n    }\n  };\n\n  C4_coeff = [\n    // C4[0], coeff of eps^5, polynomial in n of order 0\n      +97, 15015,\n    // C4[0], coeff of eps^4, polynomial in n of order 1\n      +1088, 156, 45045,\n    // C4[0], coeff of eps^3, polynomial in n of order 2\n      -224, -4784, 1573, 45045,\n    // C4[0], coeff of eps^2, polynomial in n of order 3\n      -10656, 14144, -4576, -858, 45045,\n    // C4[0], coeff of eps^1, polynomial in n of order 4\n      +64, 624, -4576, 6864, -3003, 15015,\n    // C4[0], coeff of eps^0, polynomial in n of order 5\n      +100, 208, 572, 3432, -12012, 30030, 45045,\n    // C4[1], coeff of eps^5, polynomial in n of order 0\n      +1, 9009,\n    // C4[1], coeff of eps^4, polynomial in n of order 1\n      -2944, 468, 135135,\n    // C4[1], coeff of eps^3, polynomial in n of order 2\n      +5792, 1040, -1287, 135135,\n    // C4[1], coeff of eps^2, polynomial in n of order 3\n      +5952, -11648, 9152, -2574, 135135,\n    // C4[1], coeff of eps^1, polynomial in n of order 4\n      -64, -624, 4576, -6864, 3003, 135135,\n    // C4[2], coeff of eps^5, polynomial in n of order 0\n      +8, 10725,\n    // C4[2], coeff of eps^4, polynomial in n of order 1\n      +1856, -936, 225225,\n    // C4[2], coeff of eps^3, polynomial in n of order 2\n      -8448, 4992, -1144, 225225,\n    // C4[2], coeff of eps^2, polynomial in n of order 3\n      -1440, 4160, -4576, 1716, 225225,\n    // C4[3], coeff of eps^5, polynomial in n of order 0\n      -136, 63063,\n    // C4[3], coeff of eps^4, polynomial in n of order 1\n      +1024, -208, 105105,\n    // C4[3], coeff of eps^3, polynomial in n of order 2\n      +3584, -3328, 1144, 315315,\n    // C4[4], coeff of eps^5, polynomial in n of order 0\n      -128, 135135,\n    // C4[4], coeff of eps^4, polynomial in n of order 1\n      -2560, 832, 405405,\n    // C4[5], coeff of eps^5, polynomial in n of order 0\n      +128, 99099\n  ];\n\n  g.Geodesic.prototype.C4coeff = function() {\n    var o = 0, k = 0,\n        l, j, p;\n    for (l = 0; l < g.nC4_; ++l) {        // l is index of C4[l]\n      for (j = g.nC4_ - 1; j >= l; --j) { // coeff of eps^j\n        p = g.nC4_ - j - 1;               // order of polynomial in n\n        this._C4x[k++] = m.polyval(p, C4_coeff, o, this._n) /\n          C4_coeff[o + p + 1];\n        o += p + 2;\n      }\n    }\n  };\n\n  g.Geodesic.prototype.A3f = function(eps) {\n    // Evaluate A3\n    return m.polyval(nA3x_ - 1, this._A3x, 0, eps);\n  };\n\n  g.Geodesic.prototype.C3f = function(eps, c) {\n    // Evaluate C3 coeffs\n    // Elements c[1] thru c[nC3_ - 1] are set\n    var mult = 1,\n        o = 0,\n        l, p;\n    for (l = 1; l < g.nC3_; ++l) { // l is index of C3[l]\n      p = g.nC3_ - l - 1;          // order of polynomial in eps\n      mult *= eps;\n      c[l] = mult * m.polyval(p, this._C3x, o, eps);\n      o += p + 1;\n    }\n  };\n\n  g.Geodesic.prototype.C4f = function(eps, c) {\n    // Evaluate C4 coeffs\n    // Elements c[0] thru c[g.nC4_ - 1] are set\n    var mult = 1,\n        o = 0,\n        l, p;\n    for (l = 0; l < g.nC4_; ++l) { // l is index of C4[l]\n      p = g.nC4_ - l - 1;          // order of polynomial in eps\n      c[l] = mult * m.polyval(p, this._C4x, o, eps);\n      o += p + 1;\n      mult *= eps;\n    }\n  };\n\n  // return s12b, m12b, m0, M12, M21\n  g.Geodesic.prototype.Lengths = function(eps, sig12,\n                                          ssig1, csig1, dn1, ssig2, csig2, dn2,\n                                          cbet1, cbet2, outmask,\n                                          C1a, C2a) {\n    // Return m12b = (reduced length)/_b; also calculate s12b =\n    // distance/_b, and m0 = coefficient of secular term in\n    // expression for reduced length.\n    outmask &= g.OUT_MASK;\n    var vals = {},\n        m0x = 0, J12 = 0, A1 = 0, A2 = 0,\n        B1, B2, l, csig12, t;\n    if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n      A1 = g.A1m1f(eps);\n      g.C1f(eps, C1a);\n      if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n        A2 = g.A2m1f(eps);\n        g.C2f(eps, C2a);\n        m0x = A1 - A2;\n        A2 = 1 + A2;\n      }\n      A1 = 1 + A1;\n    }\n    if (outmask & g.DISTANCE) {\n      B1 = g.SinCosSeries(true, ssig2, csig2, C1a) -\n        g.SinCosSeries(true, ssig1, csig1, C1a);\n      // Missing a factor of _b\n      vals.s12b = A1 * (sig12 + B1);\n      if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n        B2 = g.SinCosSeries(true, ssig2, csig2, C2a) -\n          g.SinCosSeries(true, ssig1, csig1, C2a);\n        J12 = m0x * sig12 + (A1 * B1 - A2 * B2);\n      }\n    } else if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n      // Assume here that nC1_ >= nC2_\n      for (l = 1; l <= g.nC2_; ++l)\n        C2a[l] = A1 * C1a[l] - A2 * C2a[l];\n      J12 = m0x * sig12 + (g.SinCosSeries(true, ssig2, csig2, C2a) -\n                           g.SinCosSeries(true, ssig1, csig1, C2a));\n    }\n    if (outmask & g.REDUCEDLENGTH) {\n      vals.m0 = m0x;\n      // Missing a factor of _b.\n      // Add parens around (csig1 * ssig2) and (ssig1 * csig2) to ensure\n      // accurate cancellation in the case of coincident points.\n      vals.m12b = dn2 * (csig1 * ssig2) - dn1 * (ssig1 * csig2) -\n        csig1 * csig2 * J12;\n    }\n    if (outmask & g.GEODESICSCALE) {\n      csig12 = csig1 * csig2 + ssig1 * ssig2;\n      t = this._ep2 * (cbet1 - cbet2) * (cbet1 + cbet2) / (dn1 + dn2);\n      vals.M12 = csig12 + (t * ssig2 - csig2 * J12) * ssig1 / dn1;\n      vals.M21 = csig12 - (t * ssig1 - csig1 * J12) * ssig2 / dn2;\n    }\n    return vals;\n  };\n\n  // return sig12, salp1, calp1, salp2, calp2, dnm\n  g.Geodesic.prototype.InverseStart = function(sbet1, cbet1, dn1,\n                                               sbet2, cbet2, dn2,\n                                               lam12, slam12, clam12,\n                                               C1a, C2a) {\n    // Return a starting point for Newton's method in salp1 and calp1\n    // (function value is -1).  If Newton's method doesn't need to be\n    // used, return also salp2 and calp2 and function value is sig12.\n    // salp2, calp2 only updated if return val >= 0.\n    var vals = {},\n        // bet12 = bet2 - bet1 in [0, pi); bet12a = bet2 + bet1 in (-pi, 0]\n        sbet12 = sbet2 * cbet1 - cbet2 * sbet1,\n        cbet12 = cbet2 * cbet1 + sbet2 * sbet1,\n        sbet12a, shortline, omg12, sbetm2, somg12, comg12, t, ssig12, csig12,\n        x, y, lamscale, betscale, k2, eps, cbet12a, bet12a, m12b, m0, nvals,\n        k, omg12a, lam12x;\n    vals.sig12 = -1;        // Return value\n    // Volatile declaration needed to fix inverse cases\n    // 88.202499451857 0 -88.202499451857 179.981022032992859592\n    // 89.262080389218 0 -89.262080389218 179.992207982775375662\n    // 89.333123580033 0 -89.333123580032997687 179.99295812360148422\n    // which otherwise fail with g++ 4.4.4 x86 -O3\n    sbet12a = sbet2 * cbet1;\n    sbet12a += cbet2 * sbet1;\n\n    shortline = cbet12 >= 0 && sbet12 < 0.5 && cbet2 * lam12 < 0.5;\n    if (shortline) {\n      sbetm2 = m.sq(sbet1 + sbet2);\n      // sin((bet1+bet2)/2)^2\n      // =  (sbet1 + sbet2)^2 / ((sbet1 + sbet2)^2 + (cbet1 + cbet2)^2)\n      sbetm2 /= sbetm2 + m.sq(cbet1 + cbet2);\n      vals.dnm = Math.sqrt(1 + this._ep2 * sbetm2);\n      omg12 = lam12 / (this._f1 * vals.dnm);\n      somg12 = Math.sin(omg12); comg12 = Math.cos(omg12);\n    } else {\n      somg12 = slam12; comg12 = clam12;\n    }\n\n    vals.salp1 = cbet2 * somg12;\n    vals.calp1 = comg12 >= 0 ?\n      sbet12 + cbet2 * sbet1 * m.sq(somg12) / (1 + comg12) :\n      sbet12a - cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);\n\n    ssig12 = m.hypot(vals.salp1, vals.calp1);\n    csig12 = sbet1 * sbet2 + cbet1 * cbet2 * comg12;\n    if (shortline && ssig12 < this._etol2) {\n      // really short lines\n      vals.salp2 = cbet1 * somg12;\n      vals.calp2 = sbet12 - cbet1 * sbet2 *\n        (comg12 >= 0 ? m.sq(somg12) / (1 + comg12) : 1 - comg12);\n      // norm(vals.salp2, vals.calp2);\n      t = m.hypot(vals.salp2, vals.calp2); vals.salp2 /= t; vals.calp2 /= t;\n      // Set return value\n      vals.sig12 = Math.atan2(ssig12, csig12);\n    } else if (Math.abs(this._n) > 0.1 || // Skip astroid calc if too eccentric\n               csig12 >= 0 ||\n               ssig12 >= 6 * Math.abs(this._n) * Math.PI * m.sq(cbet1)) {\n      // Nothing to do, zeroth order spherical approximation is OK\n    } else {\n      // Scale lam12 and bet2 to x, y coordinate system where antipodal\n      // point is at origin and singular point is at y = 0, x = -1.\n      lam12x = Math.atan2(-slam12, -clam12); // lam12 - pi\n      if (this.f >= 0) {       // In fact f == 0 does not get here\n        // x = dlong, y = dlat\n        k2 = m.sq(sbet1) * this._ep2;\n        eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);\n        lamscale = this.f * cbet1 * this.A3f(eps) * Math.PI;\n        betscale = lamscale * cbet1;\n\n        x = lam12x / lamscale;\n        y = sbet12a / betscale;\n      } else {                  // f < 0\n        // x = dlat, y = dlong\n        cbet12a = cbet2 * cbet1 - sbet2 * sbet1;\n        bet12a = Math.atan2(sbet12a, cbet12a);\n        // In the case of lon12 = 180, this repeats a calculation made\n        // in Inverse.\n        nvals = this.Lengths(this._n, Math.PI + bet12a,\n                             sbet1, -cbet1, dn1, sbet2, cbet2, dn2,\n                             cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);\n        m12b = nvals.m12b; m0 = nvals.m0;\n        x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);\n        betscale = x < -0.01 ? sbet12a / x :\n          -this.f * m.sq(cbet1) * Math.PI;\n        lamscale = betscale / cbet1;\n        y = lam12 / lamscale;\n      }\n\n      if (y > -tol1_ && x > -1 - xthresh_) {\n        // strip near cut\n        if (this.f >= 0) {\n          vals.salp1 = Math.min(1, -x);\n          vals.calp1 = -Math.sqrt(1 - m.sq(vals.salp1));\n        } else {\n          vals.calp1 = Math.max(x > -tol1_ ? 0 : -1, x);\n          vals.salp1 = Math.sqrt(1 - m.sq(vals.calp1));\n        }\n      } else {\n        // Estimate alp1, by solving the astroid problem.\n        //\n        // Could estimate alpha1 = theta + pi/2, directly, i.e.,\n        //   calp1 = y/k; salp1 = -x/(1+k);  for f >= 0\n        //   calp1 = x/(1+k); salp1 = -y/k;  for f < 0 (need to check)\n        //\n        // However, it's better to estimate omg12 from astroid and use\n        // spherical formula to compute alp1.  This reduces the mean number of\n        // Newton iterations for astroid cases from 2.24 (min 0, max 6) to 2.12\n        // (min 0 max 5).  The changes in the number of iterations are as\n        // follows:\n        //\n        // change percent\n        //    1       5\n        //    0      78\n        //   -1      16\n        //   -2       0.6\n        //   -3       0.04\n        //   -4       0.002\n        //\n        // The histogram of iterations is (m = number of iterations estimating\n        // alp1 directly, n = number of iterations estimating via omg12, total\n        // number of trials = 148605):\n        //\n        //  iter    m      n\n        //    0   148    186\n        //    1 13046  13845\n        //    2 93315 102225\n        //    3 36189  32341\n        //    4  5396      7\n        //    5   455      1\n        //    6    56      0\n        //\n        // Because omg12 is near pi, estimate work with omg12a = pi - omg12\n        k = astroid(x, y);\n        omg12a = lamscale * ( this.f >= 0 ? -x * k/(1 + k) : -y * (1 + k)/k );\n        somg12 = Math.sin(omg12a); comg12 = -Math.cos(omg12a);\n        // Update spherical estimate of alp1 using omg12 instead of\n        // lam12\n        vals.salp1 = cbet2 * somg12;\n        vals.calp1 = sbet12a -\n          cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);\n      }\n    }\n    // Sanity check on starting guess.  Backwards check allows NaN through.\n    if (!(vals.salp1 <= 0.0)) {\n      // norm(vals.salp1, vals.calp1);\n      t = m.hypot(vals.salp1, vals.calp1); vals.salp1 /= t; vals.calp1 /= t;\n    } else {\n      vals.salp1 = 1; vals.calp1 = 0;\n    }\n    return vals;\n  };\n\n  // return lam12, salp2, calp2, sig12, ssig1, csig1, ssig2, csig2, eps,\n  // domg12, dlam12,\n  g.Geodesic.prototype.Lambda12 = function(sbet1, cbet1, dn1, sbet2, cbet2, dn2,\n                                           salp1, calp1, slam120, clam120,\n                                           diffp, C1a, C2a, C3a) {\n    var vals = {},\n        t, salp0, calp0,\n        somg1, comg1, somg2, comg2, somg12, comg12, B312, eta, k2, nvals;\n    if (sbet1 === 0 && calp1 === 0)\n      // Break degeneracy of equatorial line.  This case has already been\n      // handled.\n      calp1 = -g.tiny_;\n\n    // sin(alp1) * cos(bet1) = sin(alp0)\n    salp0 = salp1 * cbet1;\n    calp0 = m.hypot(calp1, salp1 * sbet1); // calp0 > 0\n\n    // tan(bet1) = tan(sig1) * cos(alp1)\n    // tan(omg1) = sin(alp0) * tan(sig1) = tan(omg1)=tan(alp1)*sin(bet1)\n    vals.ssig1 = sbet1; somg1 = salp0 * sbet1;\n    vals.csig1 = comg1 = calp1 * cbet1;\n    // norm(vals.ssig1, vals.csig1);\n    t = m.hypot(vals.ssig1, vals.csig1); vals.ssig1 /= t; vals.csig1 /= t;\n    // norm(somg1, comg1); -- don't need to normalize!\n\n    // Enforce symmetries in the case abs(bet2) = -bet1.  Need to be careful\n    // about this case, since this can yield singularities in the Newton\n    // iteration.\n    // sin(alp2) * cos(bet2) = sin(alp0)\n    vals.salp2 = cbet2 !== cbet1 ? salp0 / cbet2 : salp1;\n    // calp2 = sqrt(1 - sq(salp2))\n    //       = sqrt(sq(calp0) - sq(sbet2)) / cbet2\n    // and subst for calp0 and rearrange to give (choose positive sqrt\n    // to give alp2 in [0, pi/2]).\n    vals.calp2 = cbet2 !== cbet1 || Math.abs(sbet2) !== -sbet1 ?\n      Math.sqrt(m.sq(calp1 * cbet1) + (cbet1 < -sbet1 ?\n                                       (cbet2 - cbet1) * (cbet1 + cbet2) :\n                                       (sbet1 - sbet2) * (sbet1 + sbet2))) /\n      cbet2 : Math.abs(calp1);\n    // tan(bet2) = tan(sig2) * cos(alp2)\n    // tan(omg2) = sin(alp0) * tan(sig2).\n    vals.ssig2 = sbet2; somg2 = salp0 * sbet2;\n    vals.csig2 = comg2 = vals.calp2 * cbet2;\n    // norm(vals.ssig2, vals.csig2);\n    t = m.hypot(vals.ssig2, vals.csig2); vals.ssig2 /= t; vals.csig2 /= t;\n    // norm(somg2, comg2); -- don't need to normalize!\n\n    // sig12 = sig2 - sig1, limit to [0, pi]\n    vals.sig12 = Math.atan2(Math.max(0, vals.csig1 * vals.ssig2 -\n                                        vals.ssig1 * vals.csig2),\n                                        vals.csig1 * vals.csig2 +\n                                        vals.ssig1 * vals.ssig2);\n\n    // omg12 = omg2 - omg1, limit to [0, pi]\n    somg12 = Math.max(0, comg1 * somg2 - somg1 * comg2);\n    comg12 =             comg1 * comg2 + somg1 * somg2;\n    // eta = omg12 - lam120\n    eta = Math.atan2(somg12 * clam120 - comg12 * slam120,\n                     comg12 * clam120 + somg12 * slam120);\n    k2 = m.sq(calp0) * this._ep2;\n    vals.eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);\n    this.C3f(vals.eps, C3a);\n    B312 = (g.SinCosSeries(true, vals.ssig2, vals.csig2, C3a) -\n            g.SinCosSeries(true, vals.ssig1, vals.csig1, C3a));\n    vals.domg12 =  -this.f * this.A3f(vals.eps) * salp0 * (vals.sig12 + B312);\n    vals.lam12 = eta + vals.domg12;\n    if (diffp) {\n      if (vals.calp2 === 0)\n        vals.dlam12 = -2 * this._f1 * dn1 / sbet1;\n      else {\n        nvals = this.Lengths(vals.eps, vals.sig12,\n                             vals.ssig1, vals.csig1, dn1,\n                             vals.ssig2, vals.csig2, dn2,\n                             cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);\n        vals.dlam12 = nvals.m12b;\n        vals.dlam12 *= this._f1 / (vals.calp2 * cbet2);\n      }\n    }\n    return vals;\n  };\n\n  /**\n   * @summary Solve the inverse geodesic problem.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} lat2 the latitude of the second point in degrees.\n   * @param {number} lon2 the longitude of the second point in degrees.\n   * @param {bitmask} [outmask = STANDARD] which results to include.\n   * @returns {object} the requested results\n   * @description The lat1, lon1, lat2, lon2, and a12 fields of the result are\n   *   always set.  For details on the outmask parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  g.Geodesic.prototype.Inverse = function(lat1, lon1, lat2, lon2, outmask) {\n    var r, vals;\n    if (!outmask) outmask = g.STANDARD;\n    if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;\n    outmask &= g.OUT_MASK;\n    r = this.InverseInt(lat1, lon1, lat2, lon2, outmask);\n    vals = r.vals;\n    if (outmask & g.AZIMUTH) {\n      vals.azi1 = m.atan2d(r.salp1, r.calp1);\n      vals.azi2 = m.atan2d(r.salp2, r.calp2);\n    }\n    return vals;\n  };\n\n  g.Geodesic.prototype.InverseInt = function(lat1, lon1, lat2, lon2, outmask) {\n    var vals = {},\n        lon12, lon12s, lonsign, t, swapp, latsign,\n        sbet1, cbet1, sbet2, cbet2, s12x, m12x,\n        dn1, dn2, lam12, slam12, clam12,\n        sig12, calp1, salp1, calp2, salp2, C1a, C2a, C3a, meridian, nvals,\n        ssig1, csig1, ssig2, csig2, eps, omg12, dnm,\n        numit, salp1a, calp1a, salp1b, calp1b,\n        tripn, tripb, v, dv, dalp1, sdalp1, cdalp1, nsalp1,\n        lengthmask, salp0, calp0, alp12, k2, A4, C4a, B41, B42,\n        somg12, comg12, domg12, dbet1, dbet2, salp12, calp12, sdomg12, cdomg12;\n    // Compute longitude difference (AngDiff does this carefully).  Result is\n    // in [-180, 180] but -180 is only for west-going geodesics.  180 is for\n    // east-going and meridional geodesics.\n    vals.lat1 = lat1 = m.LatFix(lat1); vals.lat2 = lat2 = m.LatFix(lat2);\n    // If really close to the equator, treat as on equator.\n    lat1 = m.AngRound(lat1);\n    lat2 = m.AngRound(lat2);\n    lon12 = m.AngDiff(lon1, lon2); lon12s = lon12.t; lon12 = lon12.s;\n    if (outmask & g.LONG_UNROLL) {\n      vals.lon1 = lon1; vals.lon2 = (lon1 + lon12) + lon12s;\n    } else {\n      vals.lon1 = m.AngNormalize(lon1); vals.lon2 = m.AngNormalize(lon2);\n    }\n    // Make longitude difference positive.\n    lonsign = lon12 >= 0 ? 1 : -1;\n    // If very close to being on the same half-meridian, then make it so.\n    lon12 = lonsign * m.AngRound(lon12);\n    lon12s = m.AngRound((180 - lon12) - lonsign * lon12s);\n    lam12 = lon12 * m.degree;\n    t = m.sincosd(lon12 > 90 ? lon12s : lon12);\n    slam12 = t.s; clam12 = (lon12 > 90 ? -1 : 1) * t.c;\n\n    // Swap points so that point with higher (abs) latitude is point 1\n    // If one latitude is a nan, then it becomes lat1.\n    swapp = Math.abs(lat1) < Math.abs(lat2) ? -1 : 1;\n    if (swapp < 0) {\n      lonsign *= -1;\n      t = lat1;\n      lat1 = lat2;\n      lat2 = t;\n      // swap(lat1, lat2);\n    }\n    // Make lat1 <= 0\n    latsign = lat1 < 0 ? 1 : -1;\n    lat1 *= latsign;\n    lat2 *= latsign;\n    // Now we have\n    //\n    //     0 <= lon12 <= 180\n    //     -90 <= lat1 <= 0\n    //     lat1 <= lat2 <= -lat1\n    //\n    // longsign, swapp, latsign register the transformation to bring the\n    // coordinates to this canonical form.  In all cases, 1 means no change was\n    // made.  We make these transformations so that there are few cases to\n    // check, e.g., on verifying quadrants in atan2.  In addition, this\n    // enforces some symmetries in the results returned.\n\n    t = m.sincosd(lat1); sbet1 = this._f1 * t.s; cbet1 = t.c;\n    // norm(sbet1, cbet1);\n    t = m.hypot(sbet1, cbet1); sbet1 /= t; cbet1 /= t;\n    // Ensure cbet1 = +epsilon at poles\n    cbet1 = Math.max(g.tiny_, cbet1);\n\n    t = m.sincosd(lat2); sbet2 = this._f1 * t.s; cbet2 = t.c;\n    // norm(sbet2, cbet2);\n    t = m.hypot(sbet2, cbet2); sbet2 /= t; cbet2 /= t;\n    // Ensure cbet2 = +epsilon at poles\n    cbet2 = Math.max(g.tiny_, cbet2);\n\n    // If cbet1 < -sbet1, then cbet2 - cbet1 is a sensitive measure of the\n    // |bet1| - |bet2|.  Alternatively (cbet1 >= -sbet1), abs(sbet2) + sbet1 is\n    // a better measure.  This logic is used in assigning calp2 in Lambda12.\n    // Sometimes these quantities vanish and in that case we force bet2 = +/-\n    // bet1 exactly.  An example where is is necessary is the inverse problem\n    // 48.522876735459 0 -48.52287673545898293 179.599720456223079643\n    // which failed with Visual Studio 10 (Release and Debug)\n\n    if (cbet1 < -sbet1) {\n      if (cbet2 === cbet1)\n        sbet2 = sbet2 < 0 ? sbet1 : -sbet1;\n    } else {\n      if (Math.abs(sbet2) === -sbet1)\n        cbet2 = cbet1;\n    }\n\n    dn1 = Math.sqrt(1 + this._ep2 * m.sq(sbet1));\n    dn2 = Math.sqrt(1 + this._ep2 * m.sq(sbet2));\n\n    // index zero elements of these arrays are unused\n    C1a = new Array(g.nC1_ + 1);\n    C2a = new Array(g.nC2_ + 1);\n    C3a = new Array(g.nC3_);\n\n    meridian = lat1 === -90 || slam12 === 0;\n    if (meridian) {\n\n      // Endpoints are on a single full meridian, so the geodesic might\n      // lie on a meridian.\n\n      calp1 = clam12; salp1 = slam12; // Head to the target longitude\n      calp2 = 1; salp2 = 0;           // At the target we're heading north\n\n      // tan(bet) = tan(sig) * cos(alp)\n      ssig1 = sbet1; csig1 = calp1 * cbet1;\n      ssig2 = sbet2; csig2 = calp2 * cbet2;\n\n      // sig12 = sig2 - sig1\n      sig12 = Math.atan2(Math.max(0, csig1 * ssig2 - ssig1 * csig2),\n                                     csig1 * csig2 + ssig1 * ssig2);\n      nvals = this.Lengths(this._n, sig12,\n                           ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2,\n                           outmask | g.DISTANCE | g.REDUCEDLENGTH,\n                           C1a, C2a);\n      s12x = nvals.s12b;\n      m12x = nvals.m12b;\n      // Ignore m0\n      if ((outmask & g.GEODESICSCALE) !== 0) {\n        vals.M12 = nvals.M12;\n        vals.M21 = nvals.M21;\n      }\n      // Add the check for sig12 since zero length geodesics might yield\n      // m12 < 0.  Test case was\n      //\n      //    echo 20.001 0 20.001 0 | GeodSolve -i\n      //\n      // In fact, we will have sig12 > pi/2 for meridional geodesic\n      // which is not a shortest path.\n      if (sig12 < 1 || m12x >= 0) {\n        // Need at least 2, to handle 90 0 90 180\n        if (sig12 < 3 * g.tiny_)\n          sig12 = m12x = s12x = 0;\n        m12x *= this._b;\n        s12x *= this._b;\n        vals.a12 = sig12 / m.degree;\n      } else\n        // m12 < 0, i.e., prolate and too close to anti-podal\n        meridian = false;\n    }\n\n    somg12 = 2;\n    if (!meridian &&\n        sbet1 === 0 &&           // and sbet2 == 0\n        (this.f <= 0 || lon12s >= this.f * 180)) {\n\n      // Geodesic runs along equator\n      calp1 = calp2 = 0; salp1 = salp2 = 1;\n      s12x = this.a * lam12;\n      sig12 = omg12 = lam12 / this._f1;\n      m12x = this._b * Math.sin(sig12);\n      if (outmask & g.GEODESICSCALE)\n        vals.M12 = vals.M21 = Math.cos(sig12);\n      vals.a12 = lon12 / this._f1;\n\n    } else if (!meridian) {\n\n      // Now point1 and point2 belong within a hemisphere bounded by a\n      // meridian and geodesic is neither meridional or equatorial.\n\n      // Figure a starting point for Newton's method\n      nvals = this.InverseStart(sbet1, cbet1, dn1, sbet2, cbet2, dn2,\n                                lam12, slam12, clam12, C1a, C2a);\n      sig12 = nvals.sig12;\n      salp1 = nvals.salp1;\n      calp1 = nvals.calp1;\n\n      if (sig12 >= 0) {\n        salp2 = nvals.salp2;\n        calp2 = nvals.calp2;\n        // Short lines (InverseStart sets salp2, calp2, dnm)\n\n        dnm = nvals.dnm;\n        s12x = sig12 * this._b * dnm;\n        m12x = m.sq(dnm) * this._b * Math.sin(sig12 / dnm);\n        if (outmask & g.GEODESICSCALE)\n          vals.M12 = vals.M21 = Math.cos(sig12 / dnm);\n        vals.a12 = sig12 / m.degree;\n        omg12 = lam12 / (this._f1 * dnm);\n      } else {\n\n        // Newton's method.  This is a straightforward solution of f(alp1) =\n        // lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one\n        // root in the interval (0, pi) and its derivative is positive at the\n        // root.  Thus f(alp) is positive for alp > alp1 and negative for alp <\n        // alp1.  During the course of the iteration, a range (alp1a, alp1b) is\n        // maintained which brackets the root and with each evaluation of\n        // f(alp) the range is shrunk if possible.  Newton's method is\n        // restarted whenever the derivative of f is negative (because the new\n        // value of alp1 is then further from the solution) or if the new\n        // estimate of alp1 lies outside (0,pi); in this case, the new starting\n        // guess is taken to be (alp1a + alp1b) / 2.\n        numit = 0;\n        // Bracketing range\n        salp1a = g.tiny_; calp1a = 1; salp1b = g.tiny_; calp1b = -1;\n        for (tripn = false, tripb = false; numit < maxit2_; ++numit) {\n          // the WGS84 test set: mean = 1.47, sd = 1.25, max = 16\n          // WGS84 and random input: mean = 2.85, sd = 0.60\n          nvals = this.Lambda12(sbet1, cbet1, dn1, sbet2, cbet2, dn2,\n                                salp1, calp1, slam12, clam12, numit < maxit1_,\n                                C1a, C2a, C3a);\n          v = nvals.lam12;\n          salp2 = nvals.salp2;\n          calp2 = nvals.calp2;\n          sig12 = nvals.sig12;\n          ssig1 = nvals.ssig1;\n          csig1 = nvals.csig1;\n          ssig2 = nvals.ssig2;\n          csig2 = nvals.csig2;\n          eps = nvals.eps;\n          domg12 = nvals.domg12;\n          dv = nvals.dlam12;\n\n          // 2 * tol0 is approximately 1 ulp for a number in [0, pi].\n          // Reversed test to allow escape with NaNs\n          if (tripb || !(Math.abs(v) >= (tripn ? 8 : 1) * tol0_))\n            break;\n          // Update bracketing values\n          if (v > 0 && (numit < maxit1_ || calp1/salp1 > calp1b/salp1b)) {\n            salp1b = salp1; calp1b = calp1;\n          } else if (v < 0 &&\n                     (numit < maxit1_ || calp1/salp1 < calp1a/salp1a)) {\n            salp1a = salp1; calp1a = calp1;\n          }\n          if (numit < maxit1_ && dv > 0) {\n            dalp1 = -v/dv;\n            sdalp1 = Math.sin(dalp1); cdalp1 = Math.cos(dalp1);\n            nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;\n            if (nsalp1 > 0 && Math.abs(dalp1) < Math.PI) {\n              calp1 = calp1 * cdalp1 - salp1 * sdalp1;\n              salp1 = nsalp1;\n              // norm(salp1, calp1);\n              t = m.hypot(salp1, calp1); salp1 /= t; calp1 /= t;\n              // In some regimes we don't get quadratic convergence because\n              // slope -> 0.  So use convergence conditions based on epsilon\n              // instead of sqrt(epsilon).\n              tripn = Math.abs(v) <= 16 * tol0_;\n              continue;\n            }\n          }\n          // Either dv was not positive or updated value was outside legal\n          // range.  Use the midpoint of the bracket as the next estimate.\n          // This mechanism is not needed for the WGS84 ellipsoid, but it does\n          // catch problems with more eccentric ellipsoids.  Its efficacy is\n          // such for the WGS84 test set with the starting guess set to alp1 =\n          // 90deg:\n          // the WGS84 test set: mean = 5.21, sd = 3.93, max = 24\n          // WGS84 and random input: mean = 4.74, sd = 0.99\n          salp1 = (salp1a + salp1b)/2;\n          calp1 = (calp1a + calp1b)/2;\n          // norm(salp1, calp1);\n          t = m.hypot(salp1, calp1); salp1 /= t; calp1 /= t;\n          tripn = false;\n          tripb = (Math.abs(salp1a - salp1) + (calp1a - calp1) < tolb_ ||\n                   Math.abs(salp1 - salp1b) + (calp1 - calp1b) < tolb_);\n        }\n        lengthmask = outmask |\n            (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE) ?\n             g.DISTANCE : g.NONE);\n        nvals = this.Lengths(eps, sig12,\n                             ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2,\n                             lengthmask, C1a, C2a);\n        s12x = nvals.s12b;\n        m12x = nvals.m12b;\n        // Ignore m0\n        if ((outmask & g.GEODESICSCALE) !== 0) {\n          vals.M12 = nvals.M12;\n          vals.M21 = nvals.M21;\n        }\n        m12x *= this._b;\n        s12x *= this._b;\n        vals.a12 = sig12 / m.degree;\n        if (outmask & g.AREA) {\n          // omg12 = lam12 - domg12\n          sdomg12 = Math.sin(domg12); cdomg12 = Math.cos(domg12);\n          somg12 = slam12 * cdomg12 - clam12 * sdomg12;\n          comg12 = clam12 * cdomg12 + slam12 * sdomg12;\n        }\n      }\n    }\n\n    if (outmask & g.DISTANCE)\n      vals.s12 = 0 + s12x;      // Convert -0 to 0\n\n    if (outmask & g.REDUCEDLENGTH)\n      vals.m12 = 0 + m12x;      // Convert -0 to 0\n\n    if (outmask & g.AREA) {\n      // From Lambda12: sin(alp1) * cos(bet1) = sin(alp0)\n      salp0 = salp1 * cbet1;\n      calp0 = m.hypot(calp1, salp1 * sbet1); // calp0 > 0\n      if (calp0 !== 0 && salp0 !== 0) {\n        // From Lambda12: tan(bet) = tan(sig) * cos(alp)\n        ssig1 = sbet1; csig1 = calp1 * cbet1;\n        ssig2 = sbet2; csig2 = calp2 * cbet2;\n        k2 = m.sq(calp0) * this._ep2;\n        eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);\n        // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).\n        A4 = m.sq(this.a) * calp0 * salp0 * this._e2;\n        // norm(ssig1, csig1);\n        t = m.hypot(ssig1, csig1); ssig1 /= t; csig1 /= t;\n        // norm(ssig2, csig2);\n        t = m.hypot(ssig2, csig2); ssig2 /= t; csig2 /= t;\n        C4a = new Array(g.nC4_);\n        this.C4f(eps, C4a);\n        B41 = g.SinCosSeries(false, ssig1, csig1, C4a);\n        B42 = g.SinCosSeries(false, ssig2, csig2, C4a);\n        vals.S12 = A4 * (B42 - B41);\n      } else\n        // Avoid problems with indeterminate sig1, sig2 on equator\n        vals.S12 = 0;\n      if (!meridian && somg12 > 1) {\n        somg12 = Math.sin(omg12); comg12 = Math.cos(omg12);\n      }\n      if (!meridian &&\n          comg12 > -0.7071 &&      // Long difference not too big\n          sbet2 - sbet1 < 1.75) { // Lat difference not too big\n        // Use tan(Gamma/2) = tan(omg12/2)\n        // * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))\n        // with tan(x/2) = sin(x)/(1+cos(x))\n        domg12 = 1 + comg12; dbet1 = 1 + cbet1; dbet2 = 1 + cbet2;\n        alp12 = 2 * Math.atan2( somg12 * (sbet1*dbet2 + sbet2*dbet1),\n                                domg12 * (sbet1*sbet2 + dbet1*dbet2) );\n      } else {\n        // alp12 = alp2 - alp1, used in atan2 so no need to normalize\n        salp12 = salp2 * calp1 - calp2 * salp1;\n        calp12 = calp2 * calp1 + salp2 * salp1;\n        // The right thing appears to happen if alp1 = +/-180 and alp2 = 0, viz\n        // salp12 = -0 and alp12 = -180.  However this depends on the sign\n        // being attached to 0 correctly.  The following ensures the correct\n        // behavior.\n        if (salp12 === 0 && calp12 < 0) {\n          salp12 = g.tiny_ * calp1;\n          calp12 = -1;\n        }\n        alp12 = Math.atan2(salp12, calp12);\n      }\n      vals.S12 += this._c2 * alp12;\n      vals.S12 *= swapp * lonsign * latsign;\n      // Convert -0 to 0\n      vals.S12 += 0;\n    }\n\n    // Convert calp, salp to azimuth accounting for lonsign, swapp, latsign.\n    if (swapp < 0) {\n      t = salp1;\n      salp1 = salp2;\n      salp2 = t;\n      // swap(salp1, salp2);\n      t = calp1;\n      calp1 = calp2;\n      calp2 = t;\n      // swap(calp1, calp2);\n      if (outmask & g.GEODESICSCALE) {\n        t = vals.M12;\n        vals.M12 = vals.M21;\n        vals.M21 = t;\n        // swap(vals.M12, vals.M21);\n      }\n    }\n\n    salp1 *= swapp * lonsign; calp1 *= swapp * latsign;\n    salp2 *= swapp * lonsign; calp2 *= swapp * latsign;\n\n    return {vals: vals,\n            salp1: salp1, calp1: calp1,\n            salp2: salp2, calp2: calp2};\n  };\n\n  /**\n   * @summary Solve the general direct geodesic problem.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   * @param {bool} arcmode is the next parameter an arc length?\n   * @param {number} s12_a12 the (arcmode ? arc length : distance) from the\n   *   first point to the second in (arcmode ? degrees : meters).\n   * @param {bitmask} [outmask = STANDARD] which results to include.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, and a12 fields of the result are always\n   *   set; s12 is included if arcmode is false.  For details on the outmask\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.GenDirect = function(lat1, lon1, azi1,\n                                            arcmode, s12_a12, outmask) {\n    var line;\n    if (!outmask) outmask = g.STANDARD;\n    else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;\n    // Automatically supply DISTANCE_IN if necessary\n    if (!arcmode) outmask |= g.DISTANCE_IN;\n    line = new l.GeodesicLine(this, lat1, lon1, azi1, outmask);\n    return line.GenPosition(arcmode, s12_a12, outmask);\n  };\n\n  /**\n   * @summary Solve the direct geodesic problem.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   * @param {number} s12 the distance from the first point to the second in\n   *   meters.\n   * @param {bitmask} [outmask = STANDARD] which results to include.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, s12, and a12 fields of the result are\n   *   always set.  For details on the outmask parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  g.Geodesic.prototype.Direct = function(lat1, lon1, azi1, s12, outmask) {\n    return this.GenDirect(lat1, lon1, azi1, false, s12, outmask);\n  };\n\n  /**\n   * @summary Solve the direct geodesic problem with arc length.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   * @param {number} a12 the arc length from the first point to the second in\n   *   degrees.\n   * @param {bitmask} [outmask = STANDARD] which results to include.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, and a12 fields of the result are\n   *   always set.  For details on the outmask parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  g.Geodesic.prototype.ArcDirect = function(lat1, lon1, azi1, a12, outmask) {\n    return this.GenDirect(lat1, lon1, azi1, true, a12, outmask);\n  };\n\n  /**\n   * @summary Create a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   *   degrees.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description For details on the caps parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  g.Geodesic.prototype.Line = function(lat1, lon1, azi1, caps) {\n    return new l.GeodesicLine(this, lat1, lon1, azi1, caps);\n  };\n\n  /**\n   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} in terms of the direct geodesic problem specified in terms\n   *   of distance.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   *   degrees.\n   * @param {number} s12 the distance between point 1 and point 2 (meters); it\n   *   can be negative.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description This function sets point 3 of the GeodesicLine to correspond\n   *   to point 2 of the direct geodesic problem.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.DirectLine = function(lat1, lon1, azi1, s12, caps) {\n    return this.GenDirectLine(lat1, lon1, azi1, false, s12, caps);\n  };\n\n  /**\n   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} in terms of the direct geodesic problem specified in terms\n   *   of arc length.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   *   degrees.\n   * @param {number} a12 the arc length between point 1 and point 2 (degrees);\n   *   it can be negative.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description This function sets point 3 of the GeodesicLine to correspond\n   *   to point 2 of the direct geodesic problem.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.ArcDirectLine = function(lat1, lon1, azi1, a12, caps) {\n    return this.GenDirectLine(lat1, lon1, azi1, true, a12, caps);\n  };\n\n  /**\n   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} in terms of the direct geodesic problem specified in terms\n   *   of either distance or arc length.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   *   degrees.\n   * @param {bool} arcmode boolean flag determining the meaning of the\n   *   s12_a12.\n   * @param {number} s12_a12 if arcmode is false, this is the distance between\n   *   point 1 and point 2 (meters); otherwise it is the arc length between\n   *   point 1 and point 2 (degrees); it can be negative.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description This function sets point 3 of the GeodesicLine to correspond\n   *   to point 2 of the direct geodesic problem.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.GenDirectLine = function(lat1, lon1, azi1,\n                                                arcmode, s12_a12, caps) {\n    var t;\n    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;\n    // Automatically supply DISTANCE_IN if necessary\n    if (!arcmode) caps |= g.DISTANCE_IN;\n    t = new l.GeodesicLine(this, lat1, lon1, azi1, caps);\n    t.GenSetDistance(arcmode, s12_a12);\n    return t;\n  };\n\n  /**\n   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} in terms of the inverse geodesic problem.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} lat2 the latitude of the second point in degrees.\n   * @param {number} lon2 the longitude of the second point in degrees.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include.\n   * @returns {object} the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine\n   *   GeodesicLine} object\n   * @description This function sets point 3 of the GeodesicLine to correspond\n   *   to point 2 of the inverse geodesic problem.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  g.Geodesic.prototype.InverseLine = function(lat1, lon1, lat2, lon2, caps) {\n    var r, t, azi1;\n    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;\n    r = this.InverseInt(lat1, lon1, lat2, lon2, g.ARC);\n    azi1 = m.atan2d(r.salp1, r.calp1);\n    // Ensure that a12 can be converted to a distance\n    if (caps & (g.OUT_MASK & g.DISTANCE_IN)) caps |= g.DISTANCE;\n    t = new l.GeodesicLine(this, lat1, lon1, azi1, caps, r.salp1, r.calp1);\n    t.SetArc(r.vals.a12);\n    return t;\n  };\n\n  /**\n   * @summary Create a {@link module:GeographicLib/PolygonArea.PolygonArea\n   *   PolygonArea} object.\n   * @param {bool} [polyline = false] if true the new PolygonArea object\n   *   describes a polyline instead of a polygon.\n   * @returns {object} the\n   *   {@link module:GeographicLib/PolygonArea.PolygonArea\n   *   PolygonArea} object\n   */\n  g.Geodesic.prototype.Polygon = function(polyline) {\n    return new p.PolygonArea(this, polyline);\n  };\n\n  /**\n   * @summary a {@link module:GeographicLib/Geodesic.Geodesic Geodesic} object\n   *   initialized for the WGS84 ellipsoid.\n   * @constant {object}\n   */\n  g.WGS84 = new g.Geodesic(c.WGS84.a, c.WGS84.f);\n})(GeographicLib.Geodesic, GeographicLib.GeodesicLine,\n   GeographicLib.PolygonArea, GeographicLib.Math, GeographicLib.Constants);\n\n/**************** GeodesicLine.js ****************/\n/*\n * GeodesicLine.js\n * Transcription of GeodesicLine.[ch]pp into JavaScript.\n *\n * See the documentation for the C++ class.  The conversion is a literal\n * conversion from C++.\n *\n * The algorithms are derived in\n *\n *    Charles F. F. Karney,\n *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);\n *    https://doi.org/10.1007/s00190-012-0578-z\n *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html\n *\n * Copyright (c) Charles Karney (2011-2016) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\n// Load AFTER GeographicLib/Math.js, GeographicLib/Geodesic.js\n\n(function(\n  g,\n  /**\n   * @exports GeographicLib/GeodesicLine\n   * @description Solve geodesic problems on a single geodesic line via the\n   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine GeodesicLine}\n   *   class.\n   */\n  l, m) {\n\n  /**\n   * @class\n   * @property {number} a the equatorial radius (meters).\n   * @property {number} f the flattening.\n   * @property {number} lat1 the initial latitude (degrees).\n   * @property {number} lon1 the initial longitude (degrees).\n   * @property {number} azi1 the initial azimuth (degrees).\n   * @property {number} salp1 the sine of the azimuth at the first point.\n   * @property {number} calp1 the cosine the azimuth at the first point.\n   * @property {number} s13 the distance to point 3 (meters).\n   * @property {number} a13 the arc length to point 3 (degrees).\n   * @property {bitmask} caps the capabilities of the object.\n   * @summary Initialize a GeodesicLine object.  For details on the caps\n   *   parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   * @classdesc Performs geodesic calculations along a given geodesic line.\n   *   This object is usually instantiated by\n   *   {@link module:GeographicLib/Geodesic.Geodesic#Line Geodesic.Line}.\n   *   The methods\n   *   {@link module:GeographicLib/Geodesic.Geodesic#DirectLine\n   *   Geodesic.DirectLine} and\n   *   {@link module:GeographicLib/Geodesic.Geodesic#InverseLine\n   *   Geodesic.InverseLine} set in addition the position of a reference point\n   *   3.\n   * @param {object} geod a {@link module:GeographicLib/Geodesic.Geodesic\n   *   Geodesic} object.\n   * @param {number} lat1 the latitude of the first point in degrees.\n   * @param {number} lon1 the longitude of the first point in degrees.\n   * @param {number} azi1 the azimuth at the first point in degrees.\n   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to\n   *   include; LATITUDE | AZIMUTH are always included.\n   */\n  l.GeodesicLine = function(geod, lat1, lon1, azi1, caps, salp1, calp1) {\n    var t, cbet1, sbet1, eps, s, c;\n    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;\n\n    this.a = geod.a;\n    this.f = geod.f;\n    this._b = geod._b;\n    this._c2 = geod._c2;\n    this._f1 = geod._f1;\n    this.caps = caps | g.LATITUDE | g.AZIMUTH | g.LONG_UNROLL;\n\n    this.lat1 = m.LatFix(lat1);\n    this.lon1 = lon1;\n    if (typeof salp1 === 'undefined' || typeof calp1 === 'undefined') {\n      this.azi1 = m.AngNormalize(azi1);\n      t = m.sincosd(m.AngRound(this.azi1)); this.salp1 = t.s; this.calp1 = t.c;\n    } else {\n      this.azi1 = azi1; this.salp1 = salp1; this.calp1 = calp1;\n    }\n    t = m.sincosd(m.AngRound(this.lat1)); sbet1 = this._f1 * t.s; cbet1 = t.c;\n    // norm(sbet1, cbet1);\n    t = m.hypot(sbet1, cbet1); sbet1 /= t; cbet1 /= t;\n    // Ensure cbet1 = +epsilon at poles\n    cbet1 = Math.max(g.tiny_, cbet1);\n    this._dn1 = Math.sqrt(1 + geod._ep2 * m.sq(sbet1));\n\n    // Evaluate alp0 from sin(alp1) * cos(bet1) = sin(alp0),\n    this._salp0 = this.salp1 * cbet1; // alp0 in [0, pi/2 - |bet1|]\n    // Alt: calp0 = hypot(sbet1, calp1 * cbet1).  The following\n    // is slightly better (consider the case salp1 = 0).\n    this._calp0 = m.hypot(this.calp1, this.salp1 * sbet1);\n    // Evaluate sig with tan(bet1) = tan(sig1) * cos(alp1).\n    // sig = 0 is nearest northward crossing of equator.\n    // With bet1 = 0, alp1 = pi/2, we have sig1 = 0 (equatorial line).\n    // With bet1 =  pi/2, alp1 = -pi, sig1 =  pi/2\n    // With bet1 = -pi/2, alp1 =  0 , sig1 = -pi/2\n    // Evaluate omg1 with tan(omg1) = sin(alp0) * tan(sig1).\n    // With alp0 in (0, pi/2], quadrants for sig and omg coincide.\n    // No atan2(0,0) ambiguity at poles since cbet1 = +epsilon.\n    // With alp0 = 0, omg1 = 0 for alp1 = 0, omg1 = pi for alp1 = pi.\n    this._ssig1 = sbet1; this._somg1 = this._salp0 * sbet1;\n    this._csig1 = this._comg1 =\n      sbet1 !== 0 || this.calp1 !== 0 ? cbet1 * this.calp1 : 1;\n    // norm(this._ssig1, this._csig1); // sig1 in (-pi, pi]\n    t = m.hypot(this._ssig1, this._csig1);\n    this._ssig1 /= t; this._csig1 /= t;\n    // norm(this._somg1, this._comg1); -- don't need to normalize!\n\n    this._k2 = m.sq(this._calp0) * geod._ep2;\n    eps = this._k2 / (2 * (1 + Math.sqrt(1 + this._k2)) + this._k2);\n\n    if (this.caps & g.CAP_C1) {\n      this._A1m1 = g.A1m1f(eps);\n      this._C1a = new Array(g.nC1_ + 1);\n      g.C1f(eps, this._C1a);\n      this._B11 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C1a);\n      s = Math.sin(this._B11); c = Math.cos(this._B11);\n      // tau1 = sig1 + B11\n      this._stau1 = this._ssig1 * c + this._csig1 * s;\n      this._ctau1 = this._csig1 * c - this._ssig1 * s;\n      // Not necessary because C1pa reverts C1a\n      //    _B11 = -SinCosSeries(true, _stau1, _ctau1, _C1pa);\n    }\n\n    if (this.caps & g.CAP_C1p) {\n      this._C1pa = new Array(g.nC1p_ + 1);\n      g.C1pf(eps, this._C1pa);\n    }\n\n    if (this.caps & g.CAP_C2) {\n      this._A2m1 = g.A2m1f(eps);\n      this._C2a = new Array(g.nC2_ + 1);\n      g.C2f(eps, this._C2a);\n      this._B21 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C2a);\n    }\n\n    if (this.caps & g.CAP_C3) {\n      this._C3a = new Array(g.nC3_);\n      geod.C3f(eps, this._C3a);\n      this._A3c = -this.f * this._salp0 * geod.A3f(eps);\n      this._B31 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C3a);\n    }\n\n    if (this.caps & g.CAP_C4) {\n      this._C4a = new Array(g.nC4_); // all the elements of _C4a are used\n      geod.C4f(eps, this._C4a);\n      // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0)\n      this._A4 = m.sq(this.a) * this._calp0 * this._salp0 * geod._e2;\n      this._B41 = g.SinCosSeries(false, this._ssig1, this._csig1, this._C4a);\n    }\n\n    this.a13 = this.s13 = Number.NaN;\n  };\n\n  /**\n   * @summary Find the position on the line (general case).\n   * @param {bool} arcmode is the next parameter an arc length?\n   * @param {number} s12_a12 the (arcmode ? arc length : distance) from the\n   *   first point to the second in (arcmode ? degrees : meters).\n   * @param {bitmask} [outmask = STANDARD] which results to include; this is\n   *   subject to the capabilities of the object.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, and a12 fields of the result are\n   *   always set; s12 is included if arcmode is false.  For details on the\n   *   outmask parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  l.GeodesicLine.prototype.GenPosition = function(arcmode, s12_a12,\n                                                  outmask) {\n    var vals = {},\n        sig12, ssig12, csig12, B12, AB1, ssig2, csig2, tau12, s, c, serr,\n        omg12, lam12, lon12, E, sbet2, cbet2, somg2, comg2, salp2, calp2, dn2,\n        B22, AB2, J12, t, B42, salp12, calp12;\n    if (!outmask) outmask = g.STANDARD;\n    else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;\n    outmask &= this.caps & g.OUT_MASK;\n    vals.lat1 = this.lat1; vals.azi1 = this.azi1;\n    vals.lon1 = outmask & g.LONG_UNROLL ?\n      this.lon1 : m.AngNormalize(this.lon1);\n    if (arcmode)\n      vals.a12 = s12_a12;\n    else\n      vals.s12 = s12_a12;\n    if (!( arcmode || (this.caps & g.DISTANCE_IN & g.OUT_MASK) )) {\n      // Uninitialized or impossible distance calculation requested\n      vals.a12 = Number.NaN;\n      return vals;\n    }\n\n    // Avoid warning about uninitialized B12.\n    B12 = 0; AB1 = 0;\n    if (arcmode) {\n      // Interpret s12_a12 as spherical arc length\n      sig12 = s12_a12 * m.degree;\n      t = m.sincosd(s12_a12); ssig12 = t.s; csig12 = t.c;\n    } else {\n      // Interpret s12_a12 as distance\n      tau12 = s12_a12 / (this._b * (1 + this._A1m1));\n      s = Math.sin(tau12);\n      c = Math.cos(tau12);\n      // tau2 = tau1 + tau12\n      B12 = -g.SinCosSeries(true,\n                            this._stau1 * c + this._ctau1 * s,\n                            this._ctau1 * c - this._stau1 * s,\n                            this._C1pa);\n      sig12 = tau12 - (B12 - this._B11);\n      ssig12 = Math.sin(sig12); csig12 = Math.cos(sig12);\n      if (Math.abs(this.f) > 0.01) {\n        // Reverted distance series is inaccurate for |f| > 1/100, so correct\n        // sig12 with 1 Newton iteration.  The following table shows the\n        // approximate maximum error for a = WGS_a() and various f relative to\n        // GeodesicExact.\n        //     erri = the error in the inverse solution (nm)\n        //     errd = the error in the direct solution (series only) (nm)\n        //     errda = the error in the direct solution (series + 1 Newton) (nm)\n        //\n        //       f     erri  errd errda\n        //     -1/5    12e6 1.2e9  69e6\n        //     -1/10  123e3  12e6 765e3\n        //     -1/20   1110 108e3  7155\n        //     -1/50  18.63 200.9 27.12\n        //     -1/100 18.63 23.78 23.37\n        //     -1/150 18.63 21.05 20.26\n        //      1/150 22.35 24.73 25.83\n        //      1/100 22.35 25.03 25.31\n        //      1/50  29.80 231.9 30.44\n        //      1/20   5376 146e3  10e3\n        //      1/10  829e3  22e6 1.5e6\n        //      1/5   157e6 3.8e9 280e6\n        ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;\n        csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;\n        B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);\n        serr = (1 + this._A1m1) * (sig12 + (B12 - this._B11)) -\n          s12_a12 / this._b;\n        sig12 = sig12 - serr / Math.sqrt(1 + this._k2 * m.sq(ssig2));\n        ssig12 = Math.sin(sig12); csig12 = Math.cos(sig12);\n        // Update B12 below\n      }\n    }\n\n    // sig2 = sig1 + sig12\n    ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;\n    csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;\n    dn2 = Math.sqrt(1 + this._k2 * m.sq(ssig2));\n    if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n      if (arcmode || Math.abs(this.f) > 0.01)\n        B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);\n      AB1 = (1 + this._A1m1) * (B12 - this._B11);\n    }\n    // sin(bet2) = cos(alp0) * sin(sig2)\n    sbet2 = this._calp0 * ssig2;\n    // Alt: cbet2 = hypot(csig2, salp0 * ssig2);\n    cbet2 = m.hypot(this._salp0, this._calp0 * csig2);\n    if (cbet2 === 0)\n      // I.e., salp0 = 0, csig2 = 0.  Break the degeneracy in this case\n      cbet2 = csig2 = g.tiny_;\n    // tan(alp0) = cos(sig2)*tan(alp2)\n    salp2 = this._salp0; calp2 = this._calp0 * csig2; // No need to normalize\n\n    if (arcmode && (outmask & g.DISTANCE))\n      vals.s12 = this._b * ((1 + this._A1m1) * sig12 + AB1);\n\n    if (outmask & g.LONGITUDE) {\n      // tan(omg2) = sin(alp0) * tan(sig2)\n      somg2 = this._salp0 * ssig2; comg2 = csig2; // No need to normalize\n      E = m.copysign(1, this._salp0);\n      // omg12 = omg2 - omg1\n      omg12 = outmask & g.LONG_UNROLL ?\n        E * (sig12 -\n             (Math.atan2(ssig2, csig2) -\n              Math.atan2(this._ssig1, this._csig1)) +\n             (Math.atan2(E * somg2, comg2) -\n              Math.atan2(E * this._somg1, this._comg1))) :\n        Math.atan2(somg2 * this._comg1 - comg2 * this._somg1,\n                     comg2 * this._comg1 + somg2 * this._somg1);\n      lam12 = omg12 + this._A3c *\n        ( sig12 + (g.SinCosSeries(true, ssig2, csig2, this._C3a) -\n                   this._B31));\n      lon12 = lam12 / m.degree;\n      vals.lon2 = outmask & g.LONG_UNROLL ? this.lon1 + lon12 :\n        m.AngNormalize(m.AngNormalize(this.lon1) + m.AngNormalize(lon12));\n    }\n\n    if (outmask & g.LATITUDE)\n      vals.lat2 = m.atan2d(sbet2, this._f1 * cbet2);\n\n    if (outmask & g.AZIMUTH)\n      vals.azi2 = m.atan2d(salp2, calp2);\n\n    if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {\n      B22 = g.SinCosSeries(true, ssig2, csig2, this._C2a);\n      AB2 = (1 + this._A2m1) * (B22 - this._B21);\n      J12 = (this._A1m1 - this._A2m1) * sig12 + (AB1 - AB2);\n      if (outmask & g.REDUCEDLENGTH)\n        // Add parens around (_csig1 * ssig2) and (_ssig1 * csig2) to ensure\n        // accurate cancellation in the case of coincident points.\n        vals.m12 = this._b * ((      dn2 * (this._csig1 * ssig2) -\n                               this._dn1 * (this._ssig1 * csig2)) -\n                              this._csig1 * csig2 * J12);\n      if (outmask & g.GEODESICSCALE) {\n        t = this._k2 * (ssig2 - this._ssig1) * (ssig2 + this._ssig1) /\n          (this._dn1 + dn2);\n        vals.M12 = csig12 + (t * ssig2 - csig2 * J12) * this._ssig1 / this._dn1;\n        vals.M21 = csig12 - (t * this._ssig1 - this._csig1 * J12) * ssig2 / dn2;\n      }\n    }\n\n    if (outmask & g.AREA) {\n      B42 = g.SinCosSeries(false, ssig2, csig2, this._C4a);\n      if (this._calp0 === 0 || this._salp0 === 0) {\n        // alp12 = alp2 - alp1, used in atan2 so no need to normalize\n        salp12 = salp2 * this.calp1 - calp2 * this.salp1;\n        calp12 = calp2 * this.calp1 + salp2 * this.salp1;\n      } else {\n        // tan(alp) = tan(alp0) * sec(sig)\n        // tan(alp2-alp1) = (tan(alp2) -tan(alp1)) / (tan(alp2)*tan(alp1)+1)\n        // = calp0 * salp0 * (csig1-csig2) / (salp0^2 + calp0^2 * csig1*csig2)\n        // If csig12 > 0, write\n        //   csig1 - csig2 = ssig12 * (csig1 * ssig12 / (1 + csig12) + ssig1)\n        // else\n        //   csig1 - csig2 = csig1 * (1 - csig12) + ssig12 * ssig1\n        // No need to normalize\n        salp12 = this._calp0 * this._salp0 *\n          (csig12 <= 0 ? this._csig1 * (1 - csig12) + ssig12 * this._ssig1 :\n           ssig12 * (this._csig1 * ssig12 / (1 + csig12) + this._ssig1));\n        calp12 = m.sq(this._salp0) + m.sq(this._calp0) * this._csig1 * csig2;\n      }\n      vals.S12 = this._c2 * Math.atan2(salp12, calp12) +\n        this._A4 * (B42 - this._B41);\n    }\n\n    if (!arcmode)\n      vals.a12 = sig12 / m.degree;\n    return vals;\n  };\n\n  /**\n   * @summary Find the position on the line given s12.\n   * @param {number} s12 the distance from the first point to the second in\n   *   meters.\n   * @param {bitmask} [outmask = STANDARD] which results to include; this is\n   *   subject to the capabilities of the object.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, s12, and a12 fields of the result are\n   *   always set; s12 is included if arcmode is false.  For details on the\n   *   outmask parameter, see {@tutorial 2-interface}, \"The outmask and caps\n   *   parameters\".\n   */\n  l.GeodesicLine.prototype.Position = function(s12, outmask) {\n    return this.GenPosition(false, s12, outmask);\n  };\n\n  /**\n   * @summary Find the position on the line given a12.\n   * @param {number} a12 the arc length from the first point to the second in\n   *   degrees.\n   * @param {bitmask} [outmask = STANDARD] which results to include; this is\n   *   subject to the capabilities of the object.\n   * @returns {object} the requested results.\n   * @description The lat1, lon1, azi1, and a12 fields of the result are\n   *   always set.  For details on the outmask parameter, see {@tutorial\n   *   2-interface}, \"The outmask and caps parameters\".\n   */\n  l.GeodesicLine.prototype.ArcPosition = function(a12, outmask) {\n    return this.GenPosition(true, a12, outmask);\n  };\n\n  /**\n   * @summary Specify position of point 3 in terms of either distance or arc\n   *   length.\n   * @param {bool} arcmode boolean flag determining the meaning of the second\n   *   parameter; if arcmode is false, then the GeodesicLine object must have\n   *   been constructed with caps |= DISTANCE_IN.\n   * @param {number} s13_a13 if arcmode is false, this is the distance from\n   *   point 1 to point 3 (meters); otherwise it is the arc length from\n   *   point 1 to point 3 (degrees); it can be negative.\n   **********************************************************************/\n  l.GeodesicLine.prototype.GenSetDistance = function(arcmode, s13_a13) {\n    if (arcmode)\n      this.SetArc(s13_a13);\n    else\n      this.SetDistance(s13_a13);\n  };\n\n  /**\n   * @summary Specify position of point 3 in terms distance.\n   * @param {number} s13 the distance from point 1 to point 3 (meters); it\n   *   can be negative.\n   **********************************************************************/\n  l.GeodesicLine.prototype.SetDistance = function(s13) {\n    var r;\n    this.s13 = s13;\n    r = this.GenPosition(false, this.s13, g.ARC);\n    this.a13 = 0 + r.a12;       // the 0+ converts undefined into NaN\n  };\n\n  /**\n   * @summary Specify position of point 3 in terms of arc length.\n   * @param {number} a13 the arc length from point 1 to point 3 (degrees);\n   *   it can be negative.\n   **********************************************************************/\n  l.GeodesicLine.prototype.SetArc = function(a13) {\n    var r;\n    this.a13 = a13;\n    r = this.GenPosition(true, this.a13, g.DISTANCE);\n    this.s13 = 0 + r.s12;       // the 0+ converts undefined into NaN\n  };\n\n})(GeographicLib.Geodesic, GeographicLib.GeodesicLine, GeographicLib.Math);\n\n/**************** PolygonArea.js ****************/\n/*\n * PolygonArea.js\n * Transcription of PolygonArea.[ch]pp into JavaScript.\n *\n * See the documentation for the C++ class.  The conversion is a literal\n * conversion from C++.\n *\n * The algorithms are derived in\n *\n *    Charles F. F. Karney,\n *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);\n *    https://doi.org/10.1007/s00190-012-0578-z\n *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html\n *\n * Copyright (c) Charles Karney (2011-2017) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\n// Load AFTER GeographicLib/Math.js and GeographicLib/Geodesic.js\n\n(function(\n  /**\n   * @exports GeographicLib/PolygonArea\n   * @description Compute the area of geodesic polygons via the\n   *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea}\n   *   class.\n   */\n  p, g, m, a) {\n\n  var transit, transitdirect;\n  transit = function(lon1, lon2) {\n    // Return 1 or -1 if crossing prime meridian in east or west direction.\n    // Otherwise return zero.\n    var lon12, cross;\n    // Compute lon12 the same way as Geodesic::Inverse.\n    lon1 = m.AngNormalize(lon1);\n    lon2 = m.AngNormalize(lon2);\n    lon12 = m.AngDiff(lon1, lon2).s;\n    cross = lon1 <= 0 && lon2 > 0 && lon12 > 0 ? 1 :\n      (lon2 <= 0 && lon1 > 0 && lon12 < 0 ? -1 : 0);\n    return cross;\n  };\n\n  // an alternate version of transit to deal with longitudes in the direct\n  // problem.\n  transitdirect = function(lon1, lon2) {\n    // We want to compute exactly\n    //   int(floor(lon2 / 360)) - int(floor(lon1 / 360))\n    // Since we only need the parity of the result we can use std::remquo but\n    // this is buggy with g++ 4.8.3 and requires C++11.  So instead we do\n    lon1 = lon1 % 720.0; lon2 = lon2 % 720.0;\n    return ( ((lon2 >= 0 && lon2 < 360) || lon2 < -360 ? 0 : 1) -\n             ((lon1 >= 0 && lon1 < 360) || lon1 < -360 ? 0 : 1) );\n  };\n\n  /**\n   * @class\n   * @property {number} a the equatorial radius (meters).\n   * @property {number} f the flattening.\n   * @property {bool} polyline whether the PolygonArea object describes a\n   *   polyline or a polygon.\n   * @property {number} num the number of vertices so far.\n   * @property {number} lat the current latitude (degrees).\n   * @property {number} lon the current longitude (degrees).\n   * @summary Initialize a PolygonArea object.\n   * @classdesc Computes the area and perimeter of a geodesic polygon.\n   *   This object is usually instantiated by\n   *   {@link module:GeographicLib/Geodesic.Geodesic#Polygon Geodesic.Polygon}.\n   * @param {object} geod a {@link module:GeographicLib/Geodesic.Geodesic\n   *   Geodesic} object.\n   * @param {bool} [polyline = false] if true the new PolygonArea object\n   *   describes a polyline instead of a polygon.\n   */\n  p.PolygonArea = function(geod, polyline) {\n    this._geod = geod;\n    this.a = this._geod.a;\n    this.f = this._geod.f;\n    this._area0 = 4 * Math.PI * geod._c2;\n    this.polyline = !polyline ? false : polyline;\n    this._mask = g.LATITUDE | g.LONGITUDE | g.DISTANCE |\n          (this.polyline ? g.NONE : g.AREA | g.LONG_UNROLL);\n    if (!this.polyline)\n      this._areasum = new a.Accumulator(0);\n    this._perimetersum = new a.Accumulator(0);\n    this.Clear();\n  };\n\n  /**\n   * @summary Clear the PolygonArea object, setting the number of vertices to\n   *   0.\n   */\n  p.PolygonArea.prototype.Clear = function() {\n    this.num = 0;\n    this._crossings = 0;\n    if (!this.polyline)\n      this._areasum.Set(0);\n    this._perimetersum.Set(0);\n    this._lat0 = this._lon0 = this.lat = this.lon = Number.NaN;\n  };\n\n  /**\n   * @summary Add the next vertex to the polygon.\n   * @param {number} lat the latitude of the point (degrees).\n   * @param {number} lon the longitude of the point (degrees).\n   * @description This adds an edge from the current vertex to the new vertex.\n   */\n  p.PolygonArea.prototype.AddPoint = function(lat, lon) {\n    var t;\n    if (this.num === 0) {\n      this._lat0 = this.lat = lat;\n      this._lon0 = this.lon = lon;\n    } else {\n      t = this._geod.Inverse(this.lat, this.lon, lat, lon, this._mask);\n      this._perimetersum.Add(t.s12);\n      if (!this.polyline) {\n        this._areasum.Add(t.S12);\n        this._crossings += transit(this.lon, lon);\n      }\n      this.lat = lat;\n      this.lon = lon;\n    }\n    ++this.num;\n  };\n\n  /**\n   * @summary Add the next edge to the polygon.\n   * @param {number} azi the azimuth at the current the point (degrees).\n   * @param {number} s the length of the edge (meters).\n   * @description This specifies the new vertex in terms of the edge from the\n   *   current vertex.\n   */\n  p.PolygonArea.prototype.AddEdge = function(azi, s) {\n    var t;\n    if (this.num) {\n      t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);\n      this._perimetersum.Add(s);\n      if (!this.polyline) {\n        this._areasum.Add(t.S12);\n        this._crossings += transitdirect(this.lon, t.lon2);\n      }\n      this.lat = t.lat2;\n      this.lon = t.lon2;\n    }\n    ++this.num;\n  };\n\n  /**\n   * @summary Compute the perimeter and area of the polygon.\n   * @param {bool} reverse if true then clockwise (instead of\n   *   counter-clockwise) traversal counts as a positive area.\n   * @param {bool} sign if true then return a signed result for the area if the\n   *   polygon is traversed in the \"wrong\" direction instead of returning the\n   *   area for the rest of the earth.\n   * @returns {object} r where r.number is the number of vertices, r.perimeter\n   *   is the perimeter (meters), and r.area (only returned if polyline is\n   *   false) is the area (meters<sup>2</sup>).\n   * @description If the object is a polygon (and not a polygon), the perimeter\n   *   includes the length of a final edge connecting the current point to the\n   *   initial point.  If the object is a polyline, then area is nan.  More\n   *   points can be added to the polygon after this call.\n   */\n  p.PolygonArea.prototype.Compute = function(reverse, sign) {\n    var vals = {number: this.num}, t, tempsum, crossings;\n    if (this.num < 2) {\n      vals.perimeter = 0;\n      if (!this.polyline)\n        vals.area = 0;\n      return vals;\n    }\n    if (this.polyline) {\n      vals.perimeter = this._perimetersum.Sum();\n      return vals;\n    }\n    t = this._geod.Inverse(this.lat, this.lon, this._lat0, this._lon0,\n                           this._mask);\n    vals.perimeter = this._perimetersum.Sum(t.s12);\n    tempsum = new a.Accumulator(this._areasum);\n    tempsum.Add(t.S12);\n    crossings = this._crossings + transit(this.lon, this._lon0);\n    if (crossings & 1)\n      tempsum.Add( (tempsum.Sum() < 0 ? 1 : -1) * this._area0/2 );\n    // area is with the clockwise sense.  If !reverse convert to\n    // counter-clockwise convention.\n    if (!reverse)\n      tempsum.Negate();\n    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)\n    if (sign) {\n      if (tempsum.Sum() > this._area0/2)\n        tempsum.Add( -this._area0 );\n      else if (tempsum.Sum() <= -this._area0/2)\n        tempsum.Add( +this._area0 );\n    } else {\n      if (tempsum.Sum() >= this._area0)\n        tempsum.Add( -this._area0 );\n      else if (tempsum < 0)\n        tempsum.Add( -this._area0 );\n    }\n    vals.area = tempsum.Sum();\n    return vals;\n  };\n\n  /**\n   * @summary Compute the perimeter and area of the polygon with a tentative\n   *   new vertex.\n   * @param {number} lat the latitude of the point (degrees).\n   * @param {number} lon the longitude of the point (degrees).\n   * @param {bool} reverse if true then clockwise (instead of\n   *   counter-clockwise) traversal counts as a positive area.\n   * @param {bool} sign if true then return a signed result for the area if the\n   *   polygon is traversed in the \"wrong\" direction instead of returning the\n   * @returns {object} r where r.number is the number of vertices, r.perimeter\n   *   is the perimeter (meters), and r.area (only returned if polyline is\n   *   false) is the area (meters<sup>2</sup>).\n   * @description A new vertex is *not* added to the polygon.\n   */\n  p.PolygonArea.prototype.TestPoint = function(lat, lon, reverse, sign) {\n    var vals = {number: this.num + 1}, t, tempsum, crossings, i;\n    if (this.num === 0) {\n      vals.perimeter = 0;\n      if (!this.polyline)\n        vals.area = 0;\n      return vals;\n    }\n    vals.perimeter = this._perimetersum.Sum();\n    tempsum = this.polyline ? 0 : this._areasum.Sum();\n    crossings = this._crossings;\n    for (i = 0; i < (this.polyline ? 1 : 2); ++i) {\n      t = this._geod.Inverse(\n       i === 0 ? this.lat : lat, i === 0 ? this.lon : lon,\n       i !== 0 ? this._lat0 : lat, i !== 0 ? this._lon0 : lon,\n       this._mask);\n      vals.perimeter += t.s12;\n      if (!this.polyline) {\n        tempsum += t.S12;\n        crossings += transit(i === 0 ? this.lon : lon,\n                               i !== 0 ? this._lon0 : lon);\n      }\n    }\n\n    if (this.polyline)\n      return vals;\n\n    if (crossings & 1)\n      tempsum += (tempsum < 0 ? 1 : -1) * this._area0/2;\n    // area is with the clockwise sense.  If !reverse convert to\n    // counter-clockwise convention.\n    if (!reverse)\n      tempsum *= -1;\n    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)\n    if (sign) {\n      if (tempsum > this._area0/2)\n        tempsum -= this._area0;\n      else if (tempsum <= -this._area0/2)\n        tempsum += this._area0;\n    } else {\n      if (tempsum >= this._area0)\n        tempsum -= this._area0;\n      else if (tempsum < 0)\n        tempsum += this._area0;\n    }\n    vals.area = tempsum;\n    return vals;\n  };\n\n  /**\n   * @summary Compute the perimeter and area of the polygon with a tentative\n   *   new edge.\n   * @param {number} azi the azimuth of the edge (degrees).\n   * @param {number} s the length of the edge (meters).\n   * @param {bool} reverse if true then clockwise (instead of\n   *   counter-clockwise) traversal counts as a positive area.\n   * @param {bool} sign if true then return a signed result for the area if the\n   *   polygon is traversed in the \"wrong\" direction instead of returning the\n   * @returns {object} r where r.number is the number of vertices, r.perimeter\n   *   is the perimeter (meters), and r.area (only returned if polyline is\n   *   false) is the area (meters<sup>2</sup>).\n   * @description A new vertex is *not* added to the polygon.\n   */\n  p.PolygonArea.prototype.TestEdge = function(azi, s, reverse, sign) {\n    var vals = {number: this.num ? this.num + 1 : 0}, t, tempsum, crossings;\n    if (this.num === 0)\n      return vals;\n    vals.perimeter = this._perimetersum.Sum() + s;\n    if (this.polyline)\n      return vals;\n\n    tempsum = this._areasum.Sum();\n    crossings = this._crossings;\n    t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);\n    tempsum += t.S12;\n    crossings += transitdirect(this.lon, t.lon2);\n    t = this._geod.Inverse(t.lat2, t.lon2, this._lat0, this._lon0, this._mask);\n    vals.perimeter += t.s12;\n    tempsum += t.S12;\n    crossings += transit(t.lon2, this._lon0);\n\n    if (crossings & 1)\n      tempsum += (tempsum < 0 ? 1 : -1) * this._area0/2;\n    // area is with the clockwise sense.  If !reverse convert to\n    // counter-clockwise convention.\n    if (!reverse)\n      tempsum *= -1;\n    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)\n    if (sign) {\n      if (tempsum > this._area0/2)\n        tempsum -= this._area0;\n      else if (tempsum <= -this._area0/2)\n        tempsum += this._area0;\n    } else {\n      if (tempsum >= this._area0)\n        tempsum -= this._area0;\n      else if (tempsum < 0)\n        tempsum += this._area0;\n    }\n    vals.area = tempsum;\n    return vals;\n  };\n\n})(GeographicLib.PolygonArea, GeographicLib.Geodesic,\n   GeographicLib.Math, GeographicLib.Accumulator);\n\n/**************** DMS.js ****************/\n/*\n * DMS.js\n * Transcription of DMS.[ch]pp into JavaScript.\n *\n * See the documentation for the C++ class.  The conversion is a literal\n * conversion from C++.\n *\n * Copyright (c) Charles Karney (2011-2015) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n */\n\nGeographicLib.DMS = {};\n\n(function(\n  /**\n   * @exports GeographicLib/DMS\n   * @description Decode/Encode angles expressed as degrees, minutes, and\n   *   seconds.  This module defines several constants:\n   *   - hemisphere indicator (returned by\n   *       {@link module:GeographicLib/DMS.Decode Decode}) and a formatting\n   *       indicator (used by\n   *       {@link module:GeographicLib/DMS.Encode Encode})\n   *     - NONE = 0, no designator and format as plain angle;\n   *     - LATITUDE = 1, a N/S designator and format as latitude;\n   *     - LONGITUDE = 2, an E/W designator and format as longitude;\n   *     - AZIMUTH = 3, format as azimuth;\n   *   - the specification of the trailing component in\n   *       {@link module:GeographicLib/DMS.Encode Encode}\n   *     - DEGREE;\n   *     - MINUTE;\n   *     - SECOND.\n   */\n  d) {\n\n  var lookup, zerofill, internalDecode, numMatch,\n      hemispheres_ = \"SNWE\",\n      signs_ = \"-+\",\n      digits_ = \"0123456789\",\n      dmsindicators_ = \"D'\\\":\",\n      // dmsindicatorsu_ = \"\\u00b0\\u2032\\u2033\"; // Unicode variants\n      dmsindicatorsu_ = \"\\u00b0'\\\"\", // Use degree symbol\n      components_ = [\"degrees\", \"minutes\", \"seconds\"];\n  lookup = function(s, c) {\n    return s.indexOf(c.toUpperCase());\n  };\n  zerofill = function(s, n) {\n    return String(\"0000\").substr(0, Math.max(0, Math.min(4, n-s.length))) +\n      s;\n  };\n  d.NONE = 0;\n  d.LATITUDE = 1;\n  d.LONGITUDE = 2;\n  d.AZIMUTH = 3;\n  d.DEGREE = 0;\n  d.MINUTE = 1;\n  d.SECOND = 2;\n\n  /**\n   * @summary Decode a DMS string.\n   * @description The interpretation of the string is given in the\n   *   documentation of the corresponding function, Decode(string&, flag&)\n   *   in the {@link\n   *   https://geographiclib.sourceforge.io/html/classGeographicLib_1_1DMS.html\n   *   C++ DMS class}\n   * @param {string} dms the string.\n   * @returns {object} r where r.val is the decoded value (degrees) and r.ind\n   *   is a hemisphere designator, one of NONE, LATITUDE, LONGITUDE.\n   * @throws an error if the string is illegal.\n   */\n  d.Decode = function(dms) {\n    var dmsa = dms, end,\n        v = 0, i = 0, mi, pi, vals,\n        ind1 = d.NONE, ind2, p, pa, pb;\n    dmsa = dmsa.replace(/\\u00b0/g, 'd')\n          .replace(/\\u00ba/g, 'd')\n          .replace(/\\u2070/g, 'd')\n          .replace(/\\u02da/g, 'd')\n          .replace(/\\u2032/g, '\\'')\n          .replace(/\\u00b4/g, '\\'')\n          .replace(/\\u2019/g, '\\'')\n          .replace(/\\u2033/g, '\"')\n          .replace(/\\u201d/g, '\"')\n          .replace(/\\u2212/g, '-')\n          .replace(/''/g, '\"')\n          .trim();\n    end = dmsa.length;\n    // p is pointer to the next piece that needs decoding\n    for (p = 0; p < end; p = pb, ++i) {\n      pa = p;\n      // Skip over initial hemisphere letter (for i == 0)\n      if (i === 0 && lookup(hemispheres_, dmsa.charAt(pa)) >= 0)\n        ++pa;\n      // Skip over initial sign (checking for it if i == 0)\n      if (i > 0 || (pa < end && lookup(signs_, dmsa.charAt(pa)) >= 0))\n        ++pa;\n      // Find next sign\n      mi = dmsa.substr(pa, end - pa).indexOf('-');\n      pi = dmsa.substr(pa, end - pa).indexOf('+');\n      if (mi < 0) mi = end; else mi += pa;\n      if (pi < 0) pi = end; else pi += pa;\n      pb = Math.min(mi, pi);\n      vals = internalDecode(dmsa.substr(p, pb - p));\n      v += vals.val; ind2 = vals.ind;\n      if (ind1 == d.NONE)\n        ind1 = ind2;\n      else if (!(ind2 == d.NONE || ind1 == ind2))\n        throw new Error(\"Incompatible hemisphere specifies in \" +\n                        dmsa.substr(0, pb));\n    }\n    if (i === 0)\n      throw new Error(\"Empty or incomplete DMS string \" + dmsa);\n    return {val: v, ind: ind1};\n  };\n\n  internalDecode = function(dmsa) {\n    var vals = {}, errormsg = \"\",\n        sign, beg, end, ind1, k,\n        ipieces, fpieces, npiece,\n        icurrent, fcurrent, ncurrent, p,\n        pointseen,\n        digcount, intcount,\n        x;\n    do {                       // Executed once (provides the ability to break)\n      sign = 1;\n      beg = 0; end = dmsa.length;\n      ind1 = d.NONE;\n      k = -1;\n      if (end > beg && (k = lookup(hemispheres_, dmsa.charAt(beg))) >= 0) {\n        ind1 = (k & 2) ? d.LONGITUDE : d.LATITUDE;\n        sign = (k & 1) ? 1 : -1;\n        ++beg;\n      }\n      if (end > beg &&\n          (k = lookup(hemispheres_, dmsa.charAt(end-1))) >= 0) {\n        if (k >= 0) {\n          if (ind1 !== d.NONE) {\n            if (dmsa.charAt(beg - 1).toUpperCase() ===\n                dmsa.charAt(end - 1).toUpperCase())\n              errormsg = \"Repeated hemisphere indicators \" +\n              dmsa.charAt(beg - 1) + \" in \" +\n              dmsa.substr(beg - 1, end - beg + 1);\n            else\n              errormsg = \"Contradictory hemisphere indicators \" +\n              dmsa.charAt(beg - 1) + \" and \" + dmsa.charAt(end - 1) + \" in \" +\n              dmsa.substr(beg - 1, end - beg + 1);\n            break;\n          }\n          ind1 = (k & 2) ? d.LONGITUDE : d.LATITUDE;\n          sign = (k & 1) ? 1 : -1;\n          --end;\n        }\n      }\n      if (end > beg && (k = lookup(signs_, dmsa.charAt(beg))) >= 0) {\n        if (k >= 0) {\n          sign *= k ? 1 : -1;\n          ++beg;\n        }\n      }\n      if (end === beg) {\n        errormsg = \"Empty or incomplete DMS string \" + dmsa;\n        break;\n      }\n      ipieces = [0, 0, 0];\n      fpieces = [0, 0, 0];\n      npiece = 0;\n      icurrent = 0;\n      fcurrent = 0;\n      ncurrent = 0;\n      p = beg;\n      pointseen = false;\n      digcount = 0;\n      intcount = 0;\n      while (p < end) {\n        x = dmsa.charAt(p++);\n        if ((k = lookup(digits_, x)) >= 0) {\n          ++ncurrent;\n          if (digcount > 0) {\n            ++digcount;         // Count of decimal digits\n          } else {\n            icurrent = 10 * icurrent + k;\n            ++intcount;\n          }\n        } else if (x === '.') {\n          if (pointseen) {\n            errormsg = \"Multiple decimal points in \" +\n              dmsa.substr(beg, end - beg);\n            break;\n          }\n          pointseen = true;\n          digcount = 1;\n        } else if ((k = lookup(dmsindicators_, x)) >= 0) {\n          if (k >= 3) {\n            if (p === end) {\n              errormsg = \"Illegal for colon to appear at the end of \" +\n                dmsa.substr(beg, end - beg);\n              break;\n            }\n            k = npiece;\n          }\n          if (k === npiece - 1) {\n            errormsg = \"Repeated \" + components_[k] +\n              \" component in \" + dmsa.substr(beg, end - beg);\n            break;\n          } else if (k < npiece) {\n            errormsg = components_[k] + \" component follows \" +\n              components_[npiece - 1] + \" component in \" +\n              dmsa.substr(beg, end - beg);\n            break;\n          }\n          if (ncurrent === 0) {\n            errormsg = \"Missing numbers in \" + components_[k] +\n              \" component of \" + dmsa.substr(beg, end - beg);\n            break;\n          }\n          if (digcount > 0) {\n            fcurrent = parseFloat(dmsa.substr(p - intcount - digcount - 1,\n                                              intcount + digcount));\n            icurrent = 0;\n          }\n          ipieces[k] = icurrent;\n          fpieces[k] = icurrent + fcurrent;\n          if (p < end) {\n            npiece = k + 1;\n            icurrent = fcurrent = 0;\n            ncurrent = digcount = intcount = 0;\n          }\n        } else if (lookup(signs_, x) >= 0) {\n          errormsg = \"Internal sign in DMS string \" +\n            dmsa.substr(beg, end - beg);\n          break;\n        } else {\n          errormsg = \"Illegal character \" + x + \" in DMS string \" +\n            dmsa.substr(beg, end - beg);\n          break;\n        }\n      }\n      if (errormsg.length)\n        break;\n      if (lookup(dmsindicators_, dmsa.charAt(p - 1)) < 0) {\n        if (npiece >= 3) {\n          errormsg = \"Extra text following seconds in DMS string \" +\n            dmsa.substr(beg, end - beg);\n          break;\n        }\n        if (ncurrent === 0) {\n          errormsg = \"Missing numbers in trailing component of \" +\n            dmsa.substr(beg, end - beg);\n          break;\n        }\n        if (digcount > 0) {\n          fcurrent = parseFloat(dmsa.substr(p - intcount - digcount,\n                                            intcount + digcount));\n          icurrent = 0;\n        }\n        ipieces[npiece] = icurrent;\n        fpieces[npiece] = icurrent + fcurrent;\n      }\n      if (pointseen && digcount === 0) {\n        errormsg = \"Decimal point in non-terminal component of \" +\n          dmsa.substr(beg, end - beg);\n        break;\n      }\n      // Note that we accept 59.999999... even though it rounds to 60.\n      if (ipieces[1] >= 60 || fpieces[1] > 60) {\n        errormsg = \"Minutes \" + fpieces[1] + \" not in range [0,60)\";\n        break;\n      }\n      if (ipieces[2] >= 60 || fpieces[2] > 60) {\n        errormsg = \"Seconds \" + fpieces[2] + \" not in range [0,60)\";\n        break;\n      }\n      vals.ind = ind1;\n      // Assume check on range of result is made by calling routine (which\n      // might be able to offer a better diagnostic).\n      vals.val = sign *\n        ( fpieces[2] ? (60*(60*fpieces[0] + fpieces[1]) + fpieces[2]) / 3600 :\n          ( fpieces[1] ? (60*fpieces[0] + fpieces[1]) / 60 : fpieces[0] ) );\n      return vals;\n    } while (false);\n    vals.val = numMatch(dmsa);\n    if (vals.val === 0)\n      throw new Error(errormsg);\n    else\n      vals.ind = d.NONE;\n    return vals;\n  };\n\n  numMatch = function(s) {\n    var t, sign, p0, p1;\n    if (s.length < 3)\n      return 0;\n    t = s.toUpperCase().replace(/0+$/, \"\");\n    sign = t.charAt(0) === '-' ? -1 : 1;\n    p0 = t.charAt(0) === '-' || t.charAt(0) === '+' ? 1 : 0;\n    p1 = t.length - 1;\n    if (p1 + 1 < p0 + 3)\n      return 0;\n    // Strip off sign and trailing 0s\n    t = t.substr(p0, p1 + 1 - p0); // Length at least 3\n    if (t === \"NAN\" || t === \"1.#QNAN\" || t === \"1.#SNAN\" || t === \"1.#IND\" ||\n        t === \"1.#R\")\n      return Number.NaN;\n    else if (t === \"INF\" || t === \"1.#INF\")\n      return sign * Number.POSITIVE_INFINITY;\n    return 0;\n  };\n\n  /**\n   * @summary Decode two DMS strings interpreting them as a latitude/longitude\n   *   pair.\n   * @param {string} stra the first string.\n   * @param {string} strb the first string.\n   * @param {bool} [longfirst = false] if true assume then longitude is given\n   *   first (in the absense of any hemisphere indicators).\n   * @returns {object} r where r.lat is the decoded latitude and r.lon is the\n   *   decoded longitude (both in degrees).\n   * @throws an error if the strings are illegal.\n   */\n  d.DecodeLatLon = function(stra, strb, longfirst) {\n    var vals = {},\n        valsa = d.Decode(stra),\n        valsb = d.Decode(strb),\n        a = valsa.val, ia = valsa.ind,\n        b = valsb.val, ib = valsb.ind,\n        lat, lon;\n    if (!longfirst) longfirst = false;\n    if (ia === d.NONE && ib === d.NONE) {\n      // Default to lat, long unless longfirst\n      ia = longfirst ? d.LONGITUDE : d.LATITUDE;\n      ib = longfirst ? d.LATITUDE : d.LONGITUDE;\n    } else if (ia === d.NONE)\n      ia = d.LATITUDE + d.LONGITUDE - ib;\n    else if (ib === d.NONE)\n      ib = d.LATITUDE + d.LONGITUDE - ia;\n    if (ia === ib)\n      throw new Error(\"Both \" + stra + \" and \" + strb + \" interpreted as \" +\n                      (ia === d.LATITUDE ? \"latitudes\" : \"longitudes\"));\n    lat = ia === d.LATITUDE ? a : b;\n    lon = ia === d.LATITUDE ? b : a;\n    if (Math.abs(lat) > 90)\n      throw new Error(\"Latitude \" + lat + \" not in [-90,90]\");\n    vals.lat = lat;\n    vals.lon = lon;\n    return vals;\n  };\n\n  /**\n   * @summary Decode a DMS string interpreting it as an arc length.\n   * @param {string} angstr the string (this must not include a hemisphere\n   *   indicator).\n   * @returns {number} the arc length (degrees).\n   * @throws an error if the string is illegal.\n   */\n  d.DecodeAngle = function(angstr) {\n    var vals = d.Decode(angstr),\n        ang = vals.val, ind = vals.ind;\n    if (ind !== d.NONE)\n      throw new Error(\"Arc angle \" + angstr + \" includes a hemisphere N/E/W/S\");\n    return ang;\n  };\n\n  /**\n   * @summary Decode a DMS string interpreting it as an azimuth.\n   * @param {string} azistr the string (this may include an E/W hemisphere\n   *   indicator).\n   * @returns {number} the azimuth (degrees).\n   * @throws an error if the string is illegal.\n   */\n  d.DecodeAzimuth = function(azistr) {\n    var vals = d.Decode(azistr),\n        azi = vals.val, ind = vals.ind;\n    if (ind === d.LATITUDE)\n      throw new Error(\"Azimuth \" + azistr + \" has a latitude hemisphere N/S\");\n    return azi;\n  };\n\n  /**\n   * @summary Convert angle (in degrees) into a DMS string (using &deg;, ',\n   *  and &quot;).\n   * @param {number} angle input angle (degrees).\n   * @param {number} trailing one of DEGREE, MINUTE, or SECOND to indicate\n   *   the trailing component of the string (this component is given as a\n   *   decimal number if necessary).\n   * @param {number} prec the number of digits after the decimal point for\n   *   the trailing component.\n   * @param {number} [ind = NONE] a formatting indicator, one of NONE,\n   *   LATITUDE, LONGITUDE, AZIMUTH.\n   * @returns {string} the resulting string formatted as follows:\n   *   * NONE, signed result no leading zeros on degrees except in the units\n   *     place, e.g., -8&deg;03'.\n   *   * LATITUDE, trailing N or S hemisphere designator, no sign, pad\n   *     degrees to 2 digits, e.g., 08&deg;03'S.\n   *   * LONGITUDE, trailing E or W hemisphere designator, no sign, pad\n   *     degrees to 3 digits, e.g., 008&deg;03'W.\n   *   * AZIMUTH, convert to the range [0, 360&deg;), no sign, pad degrees to\n   *     3 digits, e.g., 351&deg;57'.\n   */\n  d.Encode = function(angle, trailing, prec, ind) {\n    // Assume check on range of input angle has been made by calling\n    // routine (which might be able to offer a better diagnostic).\n    var scale = 1, i, sign,\n        idegree, fdegree, f, pieces, ip, fp, s;\n    if (!ind) ind = d.NONE;\n    if (!isFinite(angle))\n      return angle < 0 ? String(\"-inf\") :\n      (angle > 0 ? String(\"inf\") : String(\"nan\"));\n\n    // 15 - 2 * trailing = ceiling(log10(2^53/90/60^trailing)).\n    // This suffices to give full real precision for numbers in [-90,90]\n    prec = Math.min(15 - 2 * trailing, prec);\n    for (i = 0; i < trailing; ++i)\n      scale *= 60;\n    for (i = 0; i < prec; ++i)\n      scale *= 10;\n    if (ind === d.AZIMUTH)\n      angle -= Math.floor(angle/360) * 360;\n    sign = angle < 0 ? -1 : 1;\n    angle *= sign;\n\n    // Break off integer part to preserve precision in manipulation of\n    // fractional part.\n    idegree = Math.floor(angle);\n    fdegree = (angle - idegree) * scale + 0.5;\n    f = Math.floor(fdegree);\n    // Implement the \"round ties to even\" rule\n    fdegree = (f == fdegree && (f & 1)) ? f - 1 : f;\n    fdegree /= scale;\n\n    fdegree = Math.floor((angle - idegree) * scale + 0.5) / scale;\n    if (fdegree >= 1) {\n      idegree += 1;\n      fdegree -= 1;\n    }\n    pieces = [fdegree, 0, 0];\n    for (i = 1; i <= trailing; ++i) {\n      ip = Math.floor(pieces[i - 1]);\n      fp = pieces[i - 1] - ip;\n      pieces[i] = fp * 60;\n      pieces[i - 1] = ip;\n    }\n    pieces[0] += idegree;\n    s = \"\";\n    if (ind === d.NONE && sign < 0)\n      s += '-';\n    switch (trailing) {\n    case d.DEGREE:\n      s += zerofill(pieces[0].toFixed(prec),\n                    ind === d.NONE ? 0 :\n                    1 + Math.min(ind, 2) + prec + (prec ? 1 : 0)) +\n        dmsindicatorsu_.charAt(0);\n      break;\n    default:\n      s += zerofill(pieces[0].toFixed(0),\n                    ind === d.NONE ? 0 : 1 + Math.min(ind, 2)) +\n        dmsindicatorsu_.charAt(0);\n      switch (trailing) {\n      case d.MINUTE:\n        s += zerofill(pieces[1].toFixed(prec), 2 + prec + (prec ? 1 : 0)) +\n          dmsindicatorsu_.charAt(1);\n        break;\n      case d.SECOND:\n        s += zerofill(pieces[1].toFixed(0), 2) + dmsindicatorsu_.charAt(1);\n        s += zerofill(pieces[2].toFixed(prec), 2 + prec + (prec ? 1 : 0)) +\n          dmsindicatorsu_.charAt(2);\n        break;\n      default:\n        break;\n      }\n    }\n    if (ind !== d.NONE && ind !== d.AZIMUTH)\n      s += hemispheres_.charAt((ind === d.LATITUDE ? 0 : 2) +\n                               (sign < 0 ? 0 : 1));\n    return s;\n  };\n})(GeographicLib.DMS);\n\ncb(GeographicLib);\n\n})(function(geo) {\n  if (typeof module === 'object' && module.exports) {\n    /******** support loading with node's require ********/\n    module.exports = geo;\n  } else if (typeof define === 'function' && define.amd) {\n    /******** support loading with AMD ********/\n    define('geographiclib', [], function() { return geo; });\n  } else {\n    /******** otherwise just pollute our global namespace ********/\n    window.GeographicLib = geo;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/geographiclib/geographiclib.js\n// module id = 23\n// module chunks = 0 1","import parseCode from './parseCode';\nimport extend from './extend';\nimport projections from './projections';\nimport {sphere as dc_sphere, eccentricity as dc_eccentricity} from './deriveConstants';\nimport Datum from './constants/Datum';\nimport datum from './datum';\nimport match from './match';\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = parseCode(srsCode);\n  if(typeof json !== 'object'){\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection.projections.get(json.projName);\n  if(!ourProj){\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== 'none') {\n    var datumDef = match(Datum, json.datumCode);\n    if (datumDef) {\n      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1.0;\n  json.axis = json.axis || 'enu';\n  json.ellps = json.ellps || 'wgs84';\n  var sphere_ = dc_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = dc_eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\n  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);\n\n  extend(this, json); // transfer everything over from the projection because we don't know what we'll need\n  extend(this, ourProj); // transfer all the methods from the projection\n\n  // copy the 4 things over we calulated in deriveConstants.sphere\n  this.a = sphere_.a;\n  this.b = sphere_.b;\n  this.rf = sphere_.rf;\n  this.sphere = sphere_.sphere;\n\n  // copy the 3 things we calculated in deriveConstants.eccentricity\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n\n  // add in the datum object\n  this.datum = datumObj;\n\n  // init the projection\n  this.init();\n\n  // legecy callback from back in the day when it went to spatialreference.org\n  callback(null, this);\n\n}\nProjection.projections = projections;\nProjection.projections.start();\nexport default Projection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/Proj.js\n// module id = 24\n// module chunks = 0 1","export default function(a, e, sinphi) {\n  var temp = e * sinphi;\n  return a / Math.sqrt(1 - temp * temp);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/gN.js\n// module id = 25\n// module chunks = 0 1","export default function(ml, e0, e1, e2, e3) {\n  var phi;\n  var dphi;\n\n  phi = ml / e0;\n  for (var i = 0; i < 15; i++) {\n    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //..reportError(\"IMLFN-CONV:Latitude failed to converge after 15 iterations\");\n  return NaN;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/imlfn.js\n// module id = 26\n// module chunks = 0 1","export default function(phi, sphi, cphi, en) {\n  cphi *= sphi;\n  sphi *= sphi;\n  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/pj_mlfn.js\n// module id = 27\n// module chunks = 0 1","export default function(eccent, sinphi) {\n  var con;\n  if (eccent > 1.0e-7) {\n    con = eccent * sinphi;\n    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));\n  }\n  else {\n    return (2 * sinphi);\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/qsfnz.js\n// module id = 28\n// module chunks = 0 1","var ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nexport default function match(obj, key) {\n  if (obj[key]) {\n    return obj[key];\n  }\n  var keys = Object.keys(obj);\n  var lkey = key.toLowerCase().replace(ignoredChar, '');\n  var i = -1;\n  var testkey, processedKey;\n  while (++i < keys.length) {\n    testkey = keys[i];\n    processedKey = testkey.toLowerCase().replace(ignoredChar, '');\n    if (processedKey === lkey) {\n      return obj[testkey];\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/match.js\n// module id = 29\n// module chunks = 0 1","\nimport {utils as utils_} from '../utils/utils';\n\n//get rid of compiler mess\nvar utils = utils_;\n\nvar MapCredit = function(map, json) {\n    this.map = map;\n    this.id = json['id'] || null;\n    this.notice = json['notice'] || null;\n    this.copyrighted = json['copyrighted'] || true;\n    this.url = json['url'] || null;\n    this.html = utils.simpleWikiLinks(this.notice);\n    this.plain = utils.simpleWikiLinks(this.notice);\n};\n\n\nMapCredit.prototype.getInfo = function() {\n    return {\n        'id' : this.id,\n        'notice' : this.notice,\n        //\"copyrighted\" : this.copyrighted,\n        //\"url\" : this.url\n        'html' : this.html,\n        'plain' : this.plain\n    };\n};\n\n\nexport default MapCredit;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/credit.js\n// module id = 30\n// module chunks = 0 1","\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar math = math_;\n\nvar MapPosition = function(pos) {\n    if (pos instanceof MapPosition) {\n        this.pos = pos.pos.slice();\n    } else {\n        if (!(pos != null && (pos instanceof Array))) {\n            this.pos = [];\n        } else {\n            this.pos = pos.slice();\n        }\n\n        this.validate();\n    }\n};\n\n\nMapPosition.prototype.clone = function() {\n    return new MapPosition(this.pos);\n};\n\n\nMapPosition.prototype.getCoords = function() {\n    return [this.pos[1], this.pos[2], this.pos[4]];\n};\n\n\nMapPosition.prototype.getCoords2 = function() {\n    return [this.pos[1], this.pos[2]];\n};\n\n\nMapPosition.prototype.setCoords = function(coords) {\n    this.pos[1] = coords[0];\n    this.pos[2] = coords[1];\n    this.pos[4] = coords[2];\n    return this;\n};\n\n\nMapPosition.prototype.setCoords2 = function(coords) {\n    this.pos[1] = coords[0];\n    this.pos[2] = coords[1];\n    return this;\n};\n\n\nMapPosition.prototype.getHeight = function() {\n    return this.pos[4];\n};\n\n\nMapPosition.prototype.setHeight = function(height) {\n    this.pos[4] = height;\n    return this;\n};\n\n\nMapPosition.prototype.getOrientation = function() {\n    return [this.pos[5], this.pos[6], this.pos[7]];\n};\n\n\nMapPosition.prototype.setOrientation = function(orientation) {\n    this.pos[5] = orientation[0];\n    this.pos[6] = orientation[1];\n    this.pos[7] = orientation[2];\n    return this;\n};\n\n\nMapPosition.prototype.getFov = function() {\n    return this.pos[9];\n};\n\n\nMapPosition.prototype.setFov = function(fov) {\n    this.pos[9] = fov;\n    return this;\n};\n\n\nMapPosition.prototype.getViewExtent = function() {\n    return this.pos[8];\n};\n\n\nMapPosition.prototype.setViewExtent = function(extent) {\n    this.pos[8] = extent;\n    return this;\n};\n\n\nMapPosition.prototype.getViewDistance = function() {\n    return (this.getViewExtent()*0.5) / Math.tan(math.radians(this.getFov()*0.5));\n};\n\n\nMapPosition.prototype.getViewMode = function() {\n    return this.pos[0];\n};\n\n\nMapPosition.prototype.getHeightMode = function() {\n    return this.pos[3];\n};\n\n\nMapPosition.prototype.check = function() {\n    //check pich\n    if (this.getViewMode() == 'obj') {\n        this.pos[6] = math.clamp(this.pos[6], -90.0, 90.0);\n    } else {\n        this.pos[6] = math.clamp(this.pos[6], -90.0, 90.0);\n    }\n\n    this.pos[5] = this.pos[5] % 360;\n    this.pos[7] = this.pos[7] % 360;\n};\n\n\nMapPosition.prototype.isSame = function(pos) {\n    pos = pos.pos;\n    return (this.pos[0] == pos[0] &&\n             math.isEqual(this.pos[1], pos[1], 0.0000001) &&\n             math.isEqual(this.pos[2], pos[2], 0.0000001) &&\n             this.pos[3] == pos[3] &&\n             math.isEqual(this.pos[4], pos[4], 0.001) &&\n             math.isEqual(this.pos[5], pos[5], 0.001) &&\n             math.isEqual(this.pos[6], pos[6], 0.001) &&\n             math.isEqual(this.pos[7], pos[7], 0.001) &&\n             math.isEqual(this.pos[8], pos[8], 0.001) &&\n             math.isEqual(this.pos[9], pos[9], 0.001));\n};\n\n\nMapPosition.prototype.validate = function() {\n    var pos = this.pos;\n    if (pos[0] == 'fixed') { //old format\n        pos[0] = 'obj';\n        pos[9] = pos[8];\n        pos[8] = pos[7];\n        pos[7] = pos[6];\n        pos[6] = pos[5];\n        pos[5] = pos[4];\n        pos[4] = pos[3];\n        pos[3] = 'fix';\n    }\n\n    pos[0] = (pos[0] == 'obj' || pos[0] == 'subj') ? pos[0] : 'obj';\n    pos[1] = (pos[1] != null) ? pos[1] : 0;\n    pos[2] = (pos[2] != null) ? pos[2] : 0;\n    pos[3] = (pos[3] == 'fix' || pos[3] == 'fixed' || pos[3] == 'float') ? pos[3] : 'float';\n    pos[4] = (pos[4] != null) ? pos[4] : 0;\n    pos[5] = (pos[5] != null) ? pos[5] : 0;\n    pos[6] = (pos[6] != null) ? pos[6] : -90;\n    pos[7] = (pos[7] != null) ? pos[7] : 0;\n    pos[8] = (pos[8] != null) ? pos[8] : 900;\n    pos[9] = (pos[9] != null) ? pos[9] : 45;\n\n    pos[3] = (pos[3] == 'fixed') ? 'fix' : pos[3];\n};\n\n\nMapPosition.prototype.toString = function() {\n    var p = this.pos;\n    return p[0] + ', ' + p[1].toFixed(0) + ', ' + p[2].toFixed(0) + ', ' + p[3] + ', ' + p[4].toFixed(0)\n           + ', ' + p[5].toFixed(0) + ', ' + p[6].toFixed(0) + ', ' + p[7].toFixed(0) + ', ' \n           + ', ' + p[8].toFixed(0) + ', ' + p[9].toFixed(0); \n};\n\n\nMapPosition.prototype.toArray = function() {\n    return this.pos.slice();\n};\n\n\nexport default MapPosition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/position.js\n// module id = 31\n// module chunks = 0 1","\nvar GpuMesh = function(gpu, meshData, fileSize, core, direct, use16bit, verticesUnnormalized) {\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.bbox = meshData.bbox; //< bbox copy from Mesh\n    this.fileSize = fileSize; //used for stats\n    this.core = core;\n    this.vertexBuffer = null;\n    this.uvBuffer = null;\n    this.uv2Buffer = null;\n    this.use16bit = use16bit ? true : false;\n    this.verticesUnnormalized = verticesUnnormalized ? true : false;\n\n    var vertices = meshData.vertices;\n    var uvs = meshData.uvs;\n    var uvs2 = meshData.uvs2;\n    var indices = meshData.indices;\n    var vertexSize = meshData.vertexSize || 3;\n    var uvSize = meshData.uvSize || 2;\n    var uv2Size = meshData.uv2Size || 2;\n\n    var gl = this.gl;\n\n    if (!vertices || !gl) {\n        return;\n    }\n\n    //create vertex buffer\n    this.vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    //when direct mode is used vertices can be also unit16\n    gl.bufferData(gl.ARRAY_BUFFER, direct ? vertices : (new Float32Array(vertices)), gl.STATIC_DRAW);\n    this.vertexBuffer.itemSize = vertexSize;\n    this.vertexBuffer.numItems = vertices.length / vertexSize;\n\n    if (uvs != null) {\n        //create texture coords buffer\n        this.uvBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n        gl.bufferData(gl.ARRAY_BUFFER, direct ? uvs : (new Float32Array(uvs)), gl.STATIC_DRAW);\n        this.uvBuffer.itemSize = uvSize;\n        this.uvBuffer.numItems = uvs.length / uvSize;\n    }\n\n    if (uvs2 != null) {\n        //create texture coords buffer\n        this.uv2Buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);\n\n        gl.bufferData(gl.ARRAY_BUFFER, direct ? uvs2 : (new Float32Array(uvs2)), gl.STATIC_DRAW);\n        this.uv2Buffer.itemSize = uv2Size;\n        this.uv2Buffer.numItems = uvs2.length / uv2Size;\n    }\n\n    if (indices != null) {\n        //create index buffer\n        this.indexBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, direct ? indices : (new Uint16Array(indices)), gl.STATIC_DRAW);\n        this.indexBuffer.itemSize = 1;\n        this.indexBuffer.numItems = indices.length;\n    }\n\n    var varSize = this.use16bit ? 2 : 4;\n    this.size = this.vertexBuffer.numItems * vertexSize * varSize;\n    this.size += (uvs) ? this.uvBuffer.numItems * uvSize * varSize : 0;\n    this.size += (uvs2) ? this.uv2Buffer.numItems * uv2Size * varSize : 0;\n    this.size += (indices) ? indices.length * 2 : 0;\n    this.polygons = (indices) ? indices.length / 3 : this.vertexBuffer.numItems / 3;\n\n    this.valid = true;\n};\n\n//destructor\nGpuMesh.prototype.kill = function() {\n    if (!this.gl || !this.valid) {\n        return;\n    }\n\n    if (this.vertexBuffer) {\n        this.gl.deleteBuffer(this.vertexBuffer);\n    }\n    \n    if (this.uvBuffer) {\n        this.gl.deleteBuffer(this.uvBuffer);\n    }\n\n    if (this.uv2Buffer) {\n        this.gl.deleteBuffer(this.uv2Buffer);\n    }\n\n    if (this.indexBuffer) {\n        this.gl.deleteBuffer(this.indexBuffer);\n    }\n    \n    this.vertexBuffer = null;\n    this.uvBuffer = null;\n    this.uv2Buffer = null;\n    this.indexBuffer = null;\n};\n\n// Draws the mesh, given the two vertex shader attributes locations.\nGpuMesh.prototype.draw = function(program, attrVertex, attrUV, attrUV2, attrBarycenteric) {\n    var gl = this.gl;\n    if (gl == null || !this.valid) {\n        return;\n    }\n\n    if (this.use16bit) {\n        //bind vetex positions\n        var vertexAttribute = program.getAttribute(attrVertex);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.vertexAttribPointer(vertexAttribute, this.vertexBuffer.itemSize, gl.UNSIGNED_SHORT, !this.verticesUnnormalized, 0, 0);\n\n        //bind texture coords\n        if (this.uvBuffer && attrUV) {\n            var uvAttribute = program.getAttribute(attrUV);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n            gl.vertexAttribPointer(uvAttribute, this.uvBuffer.itemSize, gl.UNSIGNED_SHORT, true, 0, 0);\n        }\n\n        if (this.uv2Buffer && attrUV2) {\n            var uv2Attribute = program.getAttribute(attrUV2);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);\n            gl.vertexAttribPointer(uv2Attribute, this.uv2Buffer.itemSize, gl.UNSIGNED_SHORT, true, 0, 0);\n        }\n    } else {\n        //bind vetex positions\n        var vertexAttribute = program.getAttribute(attrVertex);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.vertexAttribPointer(vertexAttribute, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind texture coords\n        if (this.uvBuffer && attrUV) {\n            var uvAttribute = program.getAttribute(attrUV);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n            gl.vertexAttribPointer(uvAttribute, this.uvBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n\n        if (this.uv2Buffer && attrUV2) {\n            var uv2Attribute = program.getAttribute(attrUV2);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);\n            gl.vertexAttribPointer(uv2Attribute, this.uv2Buffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n    }\n\n    if (attrBarycenteric && attrBarycenteric) {\n        var barycentericAttribute = program.getAttribute(attrBarycenteric);\n        \n        if (barycentericAttribute != -1) {\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.gpu.barycentricBuffer);\n            gl.vertexAttribPointer(barycentericAttribute, this.gpu.barycentricBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n    }\n\n    //draw polygons\n    if (this.indexBuffer) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        gl.drawElements(gl.TRIANGLES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);\n    }  else {\n        gl.drawArrays(gl.TRIANGLES, 0, this.vertexBuffer.numItems);\n    }\n};\n\n\n// Returns GPU RAM used, in bytes.\nGpuMesh.prototype.size = function(){ return this.size; };\n\n\nGpuMesh.prototype.bbox = function(){ return this.bbox; };\n\n\nGpuMesh.prototype.getPolygons = function(){ return this.polygons; };\n\n\nexport default GpuMesh;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/mesh.js\n// module id = 32\n// module chunks = 0 1","\nvar GpuProgram = function(gpu, vertex, fragment) {\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.vertex = vertex;\n    this.fragment = fragment;\n    this.program = null;\n    this.uniformLocationCache = [];\n    this.attributeLocationCache = [];\n    this.m = new Float32Array(16);\n    this.ready = false;\n    this.createProgram(vertex, fragment);\n};\n\n\nGpuProgram.prototype.createShader = function(source, vertexShader) {\n    var gl = this.gl;\n\n    if (!source || !gl) {\n        return null;\n    }\n\n    var shader;\n\n    if (vertexShader !== true) {\n        shader = gl.createShader(gl.FRAGMENT_SHADER);\n    } else {\n        shader = gl.createShader(gl.VERTEX_SHADER);\n    }\n\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        var info = gl.getShaderInfoLog(shader);\n        console.log('An error occurred compiling the ' + ((vertexShader !== true) ? 'fragment' : 'vertex') + ' shaders: ' + info);\n        this.gpu.renderer.core.callListener('renderer-shader-error', { 'where':'compilation', 'info' : info });\n        return null;\n    }\n\n    return shader;\n};\n\n\nGpuProgram.prototype.createProgram = function(vertex, fragment) {\n    var gl = this.gl;\n    if (gl == null) return;\n\n    var vertexShader = this.createShader(vertex, true);\n    var fragmentShader = this.createShader(fragment, false);\n\n    if (!vertexShader ||  !fragmentShader) {\n        return;\n    }\n\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.log('Unable to initialize the shader program.');\n        this.gpu.renderer.core.callListener('renderer-shader-error', { 'where':'linking' });\n    }\n\n    gl.useProgram(program);\n\n    this.program = program;\n    this.ready = true;\n};\n\n\nGpuProgram.prototype.setSampler = function(name, index) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform1i(key, index);\n    }\n};\n\nGpuProgram.prototype.isReady = function(name, index) {\n    return this.ready;\n};\n\nGpuProgram.prototype.setMat4 = function(name, m, zoffset) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        if (zoffset) {\n            zoffset = ((1+zoffset)*2)-1;\n           \n            var m3 = this.m;\n            \n            m3[0] = m[0];  \n            m3[1] = m[1];  \n            m3[2] = m[2] * zoffset;  \n            m3[3] = m[3];  \n\n            m3[4] = m[4];  \n            m3[5] = m[5];  \n            m3[6] = m[6] * zoffset;  \n            m3[7] = m[7];  \n\n            m3[8] = m[8];\n            m3[9] = m[9];\n            m3[10] = m[10] * zoffset;  \n            m3[11] = m[11];\n\n            m3[12] = m[12];  \n            m3[13] = m[13];  \n            m3[14] = m[14] * zoffset;  \n            m3[15] = m[15];  \n\n            gl.uniformMatrix4fv(key, false, m3);\n            \n        } else {\n            gl.uniformMatrix4fv(key, false, m);\n        }\n    }\n};\n\n\nGpuProgram.prototype.setMat3 = function(name, m) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniformMatrix3fv(key, false, m);\n    }\n};\n\n\nGpuProgram.prototype.setVec2 = function(name, m) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform2fv(key, m);\n    }\n};\n\n\nGpuProgram.prototype.setVec3 = function(name, m) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform3fv(key, m);\n    }\n};\n\n\nGpuProgram.prototype.setVec4 = function(name, m) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform4fv(key, m);\n    }\n};\n\n\nGpuProgram.prototype.setFloat = function(name, value) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform1f(key, value);\n    }\n};\n\n\nGpuProgram.prototype.setFloatArray = function(name, array) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var key = this.getUniform(name);\n    if (key != null) {\n        gl.uniform1fv(key, array);\n    }\n};\n\n\nGpuProgram.prototype.getAttribute = function(name) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var location = this.attributeLocationCache[name];\n\n    if (location == null) {\n        location = gl.getAttribLocation(this.program, name);\n        this.attributeLocationCache[name] = location;\n    }\n\n    return location;\n};\n\n\nGpuProgram.prototype.getUniform = function(name) {\n    var gl = this.gl;\n    if (gl == null || this.program == null) return;\n\n    var location = this.uniformLocationCache[name];\n\n    if (location == null) {\n        location = gl.getUniformLocation(this.program, name);\n        this.uniformLocationCache[name] = location;\n    }\n    \n    return location;\n};\n\n\nexport default GpuProgram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/program.js\n// module id = 33\n// module chunks = 0 1","'use strict';\n\nmodule.exports = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, size;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and size are later used to transform coords into integers for z-order calculation\n        size = Math.max(maxX - minX, maxY - minY);\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, size);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) return null;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, size, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && size) indexCurve(ear, minX, minY, size);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, size, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, size);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, size) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, size),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, size);\n\n    // first look for points inside the triangle in increasing z-order\n    var p = ear.nextZ;\n\n    while (p && p.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.nextZ;\n    }\n\n    // then look for points in decreasing z-order\n    p = ear.prevZ;\n\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, size) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, size);\n                earcutLinked(c, triangles, dim, minX, minY, size);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= mx &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, size) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize === 0) {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                } else if (qSize === 0 || !q) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else if (p.z <= q.z) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and size of the data bounding box\nfunction zOrder(x, y, minX, minY, size) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) / size;\n    y = 32767 * (y - minY) / size;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    if ((equals(p1, q1) && equals(p2, q2)) ||\n        (equals(p1, q2) && equals(p2, q1))) return true;\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/earcut/src/earcut.js\n// module id = 34\n// module chunks = 0 1","\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\nexport default {\n  forward: forward,\n  inverse: inverse,\n  toPoint: toPoint\n};\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nexport function forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nexport function inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nexport function toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/mgrs/mgrs.js\n// module id = 35\n// module chunks = 0 1","export default function(x, y) {\n  x = Math.abs(x);\n  y = Math.abs(y);\n  var a = Math.max(x, y);\n  var b = Math.min(x, y) / (a ? a : 1);\n\n  return a * Math.sqrt(1 + Math.pow(b, 2));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/hypot.js\n// module id = 36\n// module chunks = 0 1","var C00 = 1;\nvar C02 = 0.25;\nvar C04 = 0.046875;\nvar C06 = 0.01953125;\nvar C08 = 0.01068115234375;\nvar C22 = 0.75;\nvar C44 = 0.46875;\nvar C46 = 0.01302083333333333333;\nvar C48 = 0.00712076822916666666;\nvar C66 = 0.36458333333333333333;\nvar C68 = 0.00569661458333333333;\nvar C88 = 0.3076171875;\n\nexport default function(es) {\n  var en = [];\n  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));\n  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));\n  var t = es * es;\n  en[2] = t * (C44 - es * (C46 + es * C48));\n  t *= es;\n  en[3] = t * (C66 - es * C68);\n  en[4] = t * es * C88;\n  return en;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/pj_enfn.js\n// module id = 37\n// module chunks = 0 1","import pj_mlfn from \"./pj_mlfn\";\nimport {EPSLN} from '../constants/values';\n\nvar MAX_ITER = 20;\n\nexport default function(arg, es, en) {\n  var k = 1 / (1 - es);\n  var phi = arg;\n  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */\n    var s = Math.sin(phi);\n    var t = 1 - es * s * s;\n    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;\n    //phi -= t * (t * Math.sqrt(t)) * k;\n    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;\n    phi -= t;\n    if (Math.abs(t) < EPSLN) {\n      return phi;\n    }\n  }\n  //..reportError(\"cass:pj_inv_mlfn: Convergence error\");\n  return phi;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/pj_inv_mlfn.js\n// module id = 38\n// module chunks = 0 1","export default function(x) {\n  var r = Math.exp(x);\n  r = (r - 1 / r) / 2;\n  return r;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/sinh.js\n// module id = 39\n// module chunks = 0 1","export default function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/toPoint.js\n// module id = 40\n// module chunks = 0 1","'use strict';\nimport {PJD_3PARAM, PJD_7PARAM, HALF_PI} from './constants/values';\nexport function compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false; // false, datums are not equal\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n    // the tolerance for es is to ensure that GRS80 and WGS84\n    // are considered identical\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n  } else if (source.datum_type === PJD_7PARAM) {\n    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n  } else {\n    return true; // datums are equal\n  }\n} // cs_compare_datums()\n\n/*\n * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n * according to the current ellipsoid parameters.\n *\n *    Latitude  : Geodetic latitude in radians                     (input)\n *    Longitude : Geodetic longitude in radians                    (input)\n *    Height    : Geodetic height, in meters                       (input)\n *    X         : Calculated Geocentric X coordinate, in meters    (output)\n *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n *\n */\nexport function geodeticToGeocentric(p, es, a) {\n  var Longitude = p.x;\n  var Latitude = p.y;\n  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n  var Rn; /*  Earth radius at location  */\n  var Sin_Lat; /*  Math.sin(Latitude)  */\n  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n  /*\n   ** Don't blow up if Latitude is just a little out of the value\n   ** range as it may just be a rounding issue.  Also removed longitude\n   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n   */\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {\n    /* Latitude out of range */\n    //..reportError('geocent:lat out of range:' + Latitude);\n    return null;\n  }\n\n  if (Longitude > Math.PI) {\n    Longitude -= (2 * Math.PI);\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n  };\n} // cs_geodetic_to_geocentric()\n\nexport function geocentricToGeodetic(p, es, a, b) {\n  /* local defintions and variables */\n  /* end-criterium of loop, accuracy of sin(Latitude) */\n  var genau = 1e-12;\n  var genau2 = (genau * genau);\n  var maxiter = 30;\n\n  var P; /* distance between semi-minor axis and location */\n  var RR; /* distance between center and location */\n  var CT; /* sin of geocentric latitude */\n  var ST; /* cos of geocentric latitude */\n  var RX;\n  var RK;\n  var RN; /* Earth radius at location */\n  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n  var CPHI; /* cos of searched geodetic latitude */\n  var SPHI; /* sin of searched geodetic latitude */\n  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n  var X = p.x;\n  var Y = p.y;\n  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n  var Longitude;\n  var Latitude;\n  var Height;\n\n  P = Math.sqrt(X * X + Y * Y);\n  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n  /*      special cases for latitude and longitude */\n  if (P / a < genau) {\n\n    /*  special case, if P=0. (X=0., Y=0.) */\n    Longitude = 0.0;\n\n    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n    if (RR / a < genau) {\n      Latitude = HALF_PI;\n      Height = -b;\n      return {\n        x: p.x,\n        y: p.y,\n        z: p.z\n      };\n    }\n  } else {\n    /*  ellipsoidal (geodetic) longitude\n     *  interval: -PI < Longitude <= +PI */\n    Longitude = Math.atan2(Y, X);\n  }\n\n  /* --------------------------------------------------------------\n   * Following iterative algorithm was developped by\n   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n   * Internet: www.ife.uni-hannover.de\n   * Iterative computation of CPHI,SPHI and Height.\n   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n   * 2*10**-7 arcsec.\n   * --------------------------------------------------------------\n   */\n  CT = Z / RR;\n  ST = P / RR;\n  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n  CPHI0 = ST * (1.0 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n\n  /* loop to find sin(Latitude) resp. Latitude\n   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n  do {\n    iter++;\n    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n    /*  ellipsoidal (geodetic) height */\n    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n    RK = es * RN / (RN + Height);\n    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n    CPHI = ST * (1.0 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  }\n  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n  /*      ellipsoidal (geodetic) latitude */\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n} // cs_geocentric_to_geodetic()\n\n/****************************************************************/\n// pj_geocentic_to_wgs84( p )\n//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nexport function geocentricToWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x + datum_params[0],\n      y: p.y + datum_params[1],\n      z: p.z + datum_params[2],\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    // if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n    };\n  }\n} // cs_geocentric_to_wgs84\n\n/****************************************************************/\n// pj_geocentic_from_wgs84()\n//  coordinate system definition,\n//  point to transform in geocentric coordinates (x,y,z)\nexport function geocentricFromWgs84(p, datum_type, datum_params) {\n\n  if (datum_type === PJD_3PARAM) {\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n    return {\n      x: p.x - datum_params[0],\n      y: p.y - datum_params[1],\n      z: p.z - datum_params[2],\n    };\n\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p.x - Dx_BF) / M_BF;\n    var y_tmp = (p.y - Dy_BF) / M_BF;\n    var z_tmp = (p.z - Dz_BF) / M_BF;\n    //if( x[io] === HUGE_VAL )\n    //    continue;\n\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  } //cs_geocentric_from_wgs84()\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/datumUtils.js\n// module id = 41\n// module chunks = 0 1","import globals from './global';\nimport parseProj from './projString';\nimport wkt from 'wkt-parser';\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === 'string') {\n      if (def.charAt(0) === '+') {\n        defs[name] = parseProj(arguments[1]);\n      }\n      else {\n        defs[name] = wkt(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === 'string') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if ('EPSG' in name) {\n      defs['EPSG:' + name.EPSG] = name;\n    }\n    else if ('ESRI' in name) {\n      defs['ESRI:' + name.ESRI] = name;\n    }\n    else if ('IAU2000' in name) {\n      defs['IAU2000:' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nglobals(defs);\nexport default defs;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/defs.js\n// module id = 42\n// module chunks = 0 1","import {D2R} from './constants/values';\nimport PrimeMeridian from './constants/PrimeMeridian';\nimport units from './constants/units';\nimport match from './match';\n\nexport default function(defData) {\n  var self = {};\n  var paramObj = defData.split('+').map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).reduce(function(p, a) {\n    var split = a.split('=');\n    split.push(true);\n    p[split[0].toLowerCase()] = split[1];\n    return p;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: 'projName',\n    datum: 'datumCode',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * D2R;\n    },\n    lat_1: function(v) {\n      self.lat1 = v * D2R;\n    },\n    lat_2: function(v) {\n      self.lat2 = v * D2R;\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * D2R;\n    },\n    lon_0: function(v) {\n      self.long0 = v * D2R;\n    },\n    lon_1: function(v) {\n      self.long1 = v * D2R;\n    },\n    lon_2: function(v) {\n      self.long2 = v * D2R;\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * D2R;\n    },\n    lonc: function(v) {\n      self.longc = v * D2R;\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(\",\").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      var unit = match(units, v);\n      if (unit) {\n        self.to_meter = unit.to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * D2R;\n    },\n    pm: function(v) {\n      var pm = match(PrimeMeridian, v);\n      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;\n    },\n    nadgrids: function(v) {\n      if (v === '@null') {\n        self.datumCode = 'none';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = \"ewnsud\";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === 'function') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projString.js\n// module id = 43\n// module chunks = 0 1","// Heavily based on this etmerc projection implementation\n// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js\n\nimport sinh from '../common/sinh';\nimport hypot from '../common/hypot';\nimport asinhy from '../common/asinhy';\nimport gatg from '../common/gatg';\nimport clens from '../common/clens';\nimport clens_cmplx from '../common/clens_cmplx';\nimport adjust_lon from '../common/adjust_lon';\n\nexport function init() {\n  if (this.es === undefined || this.es <= 0) {\n    throw new Error('incorrect elliptical usage');\n  }\n\n  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n  this.cgb = [];\n  this.cbg = [];\n  this.utg = [];\n  this.gtu = [];\n\n  var f = this.es / (1 + Math.sqrt(1 - this.es));\n  var n = f / (2 - f);\n  var np = n;\n\n  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));\n  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));\n\n  np = np * n;\n  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));\n  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));\n\n  np = np * n;\n  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));\n  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));\n\n  np = np * n;\n  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));\n  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));\n\n  np = np * n;\n  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));\n  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));\n\n  np = np * n;\n  this.cgb[5] = np * (601676 / 22275);\n  this.cbg[5] = np * (444337 / 155925);\n\n  np = Math.pow(n, 2);\n  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));\n\n  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));\n  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));\n\n  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));\n  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));\n\n  np = np * n;\n  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));\n  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));\n\n  np = np * n;\n  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));\n  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));\n\n  np = np * n;\n  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));\n  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));\n\n  np = np * n;\n  this.utg[5] = np * (-20648693 / 638668800);\n  this.gtu[5] = np * (212378941 / 319334400);\n\n  var Z = gatg(this.cbg, this.lat0);\n  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));\n}\n\nexport function forward(p) {\n  var Ce = adjust_lon(p.x - this.long0);\n  var Cn = p.y;\n\n  Cn = gatg(this.cbg, Cn);\n  var sin_Cn = Math.sin(Cn);\n  var cos_Cn = Math.cos(Cn);\n  var sin_Ce = Math.sin(Ce);\n  var cos_Ce = Math.cos(Ce);\n\n  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);\n  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));\n  Ce = asinhy(Math.tan(Ce));\n\n  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);\n\n  Cn = Cn + tmp[0];\n  Ce = Ce + tmp[1];\n\n  var x;\n  var y;\n\n  if (Math.abs(Ce) <= 2.623395162778) {\n    x = this.a * (this.Qn * Ce) + this.x0;\n    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;\n  }\n  else {\n    x = Infinity;\n    y = Infinity;\n  }\n\n  p.x = x;\n  p.y = y;\n\n  return p;\n}\n\nexport function inverse(p) {\n  var Ce = (p.x - this.x0) * (1 / this.a);\n  var Cn = (p.y - this.y0) * (1 / this.a);\n\n  Cn = (Cn - this.Zb) / this.Qn;\n  Ce = Ce / this.Qn;\n\n  var lon;\n  var lat;\n\n  if (Math.abs(Ce) <= 2.623395162778) {\n    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);\n\n    Cn = Cn + tmp[0];\n    Ce = Ce + tmp[1];\n    Ce = Math.atan(sinh(Ce));\n\n    var sin_Cn = Math.sin(Cn);\n    var cos_Cn = Math.cos(Cn);\n    var sin_Ce = Math.sin(Ce);\n    var cos_Ce = Math.cos(Ce);\n\n    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));\n    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);\n\n    lon = adjust_lon(Ce + this.long0);\n    lat = gatg(this.cgb, Cn);\n  }\n  else {\n    lon = Infinity;\n    lat = Infinity;\n  }\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nexport var names = [\"Extended_Transverse_Mercator\", \"Extended Transverse Mercator\", \"etmerc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/etmerc.js\n// module id = 44\n// module chunks = 0 1","import {D2R, R2D, PJD_3PARAM, PJD_7PARAM} from './constants/values';\nimport datum_transform from './datum_transform';\nimport {geodeticToGeocentric, geocentricToGeodetic} from './datumUtils';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n}\n\nexport default function transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point.x *= D2R;\n    point.y *= D2R;\n  }\n  else {\n    if (source.isGeocent) {\n      if (source.to_meter) {\n        point.x *= source.to_meter;\n        point.y *= source.to_meter;\n        point.z *= source.to_meter;\n      }\n      // originally dest.datum.geocentric_to_geodetic_noniter(point);\n      point = geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n    } else {\n      if (source.to_meter) {\n        point.x *= source.to_meter;\n        point.y *= source.to_meter;\n      }\n      point = source.inverse(point); // Convert Cartesian to longlat\n    }\n  }\n// Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n// Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n\n// Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point.x -= dest.from_greenwich;\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point.x *= R2D;\n    point.y *= R2D;\n  } else { // else project\n    if (dest.isGeocent) {\n      point = geodeticToGeocentric(point, dest.es, dest.a);\n      if (dest.to_meter) {\n        point.x /= dest.to_meter;\n        point.y /= dest.to_meter;\n        point.z /= dest.to_meter;\n      }\n    } else {\n      dest.forward(point);\n      if (dest.to_meter) {\n        point.x /= dest.to_meter;\n        point.y /= dest.to_meter;\n      }\n    }\n  }\n\n// DGR, 2010/11/12\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/transform.js\n// module id = 45\n// module chunks = 0 1","var D2R = 0.01745329251994329577;\nimport parser from './parser';\nimport {sExpr} from './process';\n\n\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  } else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  } else {\n    if (typeof wkt.PROJECTION === 'object') {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    } else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = wkt.UNIT.convert, 10;\n      }\n    }\n  }\n  var geogcs = wkt.GEOGCS;\n  if (wkt.type === 'GEOGCS') {\n    geogcs = wkt;\n  }\n  if (geogcs) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (geogcs.DATUM) {\n      wkt.datumCode = geogcs.DATUM.name.toLowerCase();\n    } else {\n      wkt.datumCode = geogcs.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === 'wgs_1984') {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = 'rnb72';\n    }\n    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = geogcs.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = 'osgb36';\n    }\n    if (~wkt.datumCode.indexOf('osni_1952')) {\n      wkt.datumCode = 'osni52';\n    }\n    if (~wkt.datumCode.indexOf('tm65')\n      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {\n      wkt.datumCode = 'ire65';\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return input * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['false_easting', 'False_Easting'],\n    ['false_northing', 'False_Northing'],\n    ['central_meridian', 'Central_Meridian'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\nexport default function(wkt) {\n  var lisp = parser(wkt);\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj);\n  return obj;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/wkt-parser/index.js\n// module id = 46\n// module chunks = 0 1","\nimport MapCredit_ from './credit';\nimport {utils as utils_} from '../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../utils/url';\n\n//get rid of compiler mess\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\nvar MapCredit = MapCredit_;\n\n\nvar MapBoundLayer = function(map, json, id) {\n    this.map = map;\n    this.id = id;\n    this.currentAlpha = 1.0;\n\n    this.tileSize = [256,256];\n    this.lodRange = [0,100];\n    this.credits = [];\n    this.tileRange = [[0,0],[0,0]];\n    this.jsonUrl = null;\n    this.baseUrl = this.map.url.baseUrl;\n    this.baseUrlSchema = this.map.url.baseUrlSchema;\n    this.baseUrlOrigin = this.map.url.baseUrlOrigin;\n    this.ready = false;\n    this.dataType = VTS_TEXTURETYPE_COLOR;\n\n    //hack\n    if (id == 'esri-world-imagery') {\n        json['availability'] = {\n             // \"type\" : \"negative-type\",\n             // \"mime\": \"image/png\"\n             // \"type\" : \"negative-code\",\n             // \"codes\": [301, 302, 404]\n            'type' : 'negative-size',\n            'size': 2521\n        };  \n    }\n    \n    if (typeof json === 'string') {\n        this.jsonUrl = this.map.url.processUrl(json);\n        this.baseUrl = utilsUrl.getBase(this.jsonUrl);\n        this.baseUrlSchema = utilsUrl.getSchema(this.jsonUrl);\n        this.baseUrlOrigin = utilsUrl.getOrigin(this.jsonUrl);\n        \n        var onLoaded = (function(data){\n            this.parseJson(data);            \n            this.ready = true;\n            this.map.refreshView();\n        }).bind(this);\n        \n        var onError = (function(){ }).bind(this);\n\n        utils.loadJSON(this.jsonUrl, onLoaded, onError, null, (utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n        //utils.loadJSON(this.url, onLoaded, onError, null, utils.useCredentials);\n    } else {\n        this.parseJson(json);\n        this.ready = true;\n    }\n    \n};\n\n\nMapBoundLayer.prototype.parseJson = function(json) {\n    this.numberId = json['id'] || null;\n    this.type = json['type'] || 'raster';\n    this.url = this.processUrl(json['url'], '');\n    this.tileSize = json['tileSize'] || [256,256];\n    this.lodRange = json['lodRange'] || [0,0];\n    this.tileRange = json['tileRange'] || [[0,0],[0,0]];\n    this.metaUrl = this.processUrl(json['metaUrl']);\n    this.maskUrl = this.processUrl(json['maskUrl']);\n    this.isTransparent = json['isTransparent'] || false;\n    this.shaderFilter = json['shaderFilter'] || null;\n    this.credits = json['credits'] || [];\n    this.creditsUrl = null;\n\n    switch(json['dataType']) {\n        default:\n        case 'color':          this.dataType = VTS_TEXTURETYPE_COLOR;  break;\n        case 'height':         this.dataType = VTS_TEXTURETYPE_HEIGHT; break;\n        case 'classification': this.dataType = VTS_TEXTURETYPE_CLASS;  break;\n    }\n\n    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    \n\n    this.availability = json['availability'] ? {} : null;\n\n    if (this.availability) {\n        var p = json['availability'];\n\n        switch(p['type']) {\n            case 'negative-type': this.availability.type = VTS_TEXTURECHECK_TYPE; break;\n            case 'negative-code': this.availability.type = VTS_TEXTURECHECK_CODE; break;\n            case 'negative-size': this.availability.type = VTS_TEXTURECHECK_SIZE; break;\n        }\n\n        this.availability.mime = p['mime'];\n        this.availability.codes = p['codes'];\n        this.availability.size = p['size'];\n        //this.availability.coverageUrl = p[\"coverageUrl\"];\n    }\n\n    if (this.metaUrl && this.maskUrl) {\n        this.availability = {\n            type : VTS_TEXTURECHECK_MEATATILE\n        };\n    }\n\n    switch(typeof this.credits) {\n    case 'string':\n        this.creditsUrl = this.credits;\n        this.credits = [];\n        break;\n\n    case 'object':\n        \n        if (!Array.isArray(this.credits)) {\n            var credits = this.credits;\n            this.credits = [];\n                \n            for (var key in credits){\n                this.map.addCredit(key, new MapCredit(this.map, credits[key]));\n                this.credits.push(key);\n            }\n        }\n\n        /*\n        for (var i = 0, li = this.credits.length; i < li; i++) {\n            var credit = this.map.getCreditById(this.credits[i]);\n                //this.creditsNumbers.push(credit ? credit.id : null); \n        }*/\n        \n        break;\n    }\n};\n\n\nMapBoundLayer.prototype.kill = function() {\n};\n\n\nMapBoundLayer.prototype.setOptions = function() {\n};\n\n\nMapBoundLayer.prototype.getOptions = function() {\n    return this.getInfo();\n};\n\n\nMapBoundLayer.prototype.getInfo = function() {\n    return {\n        'type' : this.type,\n        'url' : this.url,\n        'tileSize' : this.tileSize,\n        'credits' : this.credits,\n        'lodRange' : this.lodRange,\n        'tileRange' : this.tileRange,\n        'mataUrl' : this.metaUrl,\n        'maskUrl' : this.maskUrl,\n        'isTransparent' : this.isTransparent\n    };\n};\n\n\nMapBoundLayer.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n\n    url = url.trim();\n    \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.baseUrlOrigin + url;\n    } else {  //relative\n        return this.baseUrl + url; \n    }\n};\n\n\nMapBoundLayer.prototype.hasTile = function(id) {\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift < 0) {\n        return false;\n    }\n\n    var x = id[1] >> shift;\n    var y = id[2] >> shift;\n\n    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||\n        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n        return false;\n    }\n\n    return true;\n};\n\n\nMapBoundLayer.prototype.hasTileOrInfluence = function(id) {\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift < 0) {\n        return false;\n    }\n\n    var x = id[1] >> shift;\n    var y = id[2] >> shift;\n\n    if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n        return 0;\n    }\n\n    return (id[0] > this.lodRange[1]) ? 1 : 2;\n};\n\n\nMapBoundLayer.prototype.getUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.url, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapBoundLayer.prototype.getMetatileUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapBoundLayer.prototype.getMaskUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.maskUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nexport default MapBoundLayer;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/bound-layer.js\n// module id = 47\n// module chunks = 0 1","\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport {utils as utils_} from '../utils/utils';\nimport GpuGroup_ from '../renderer/gpu/group';\nimport MapGeodataProcessor_ from './geodata-processor/processor';\n\n//get rid of compiler mess\nvar mat4 = mat4_, math = math_, utils = utils_;\nvar GpuGroup = GpuGroup_;\nvar MapGeodataProcessor = MapGeodataProcessor_;\n\n\nvar MapGeodataView = function(map, geodata, extraInfo) {\n    this.map = map;\n    this.stats = map.stats;\n    this.geodata = geodata;\n    this.gpu = this.map.renderer.gpu;\n    this.renderer = this.map.renderer;\n    this.gpuGroups = [];\n    this.currentGpuGroup = null;\n    this.tile = extraInfo.tile;\n    this.surface = extraInfo.surface;\n\n    if (!this.surface.geodataProcessor) {\n        var processor = new MapGeodataProcessor(this, this.onGeodataProcessorMessage.bind(this));\n        processor.setStylesheet(this.surface.stylesheet);\n        this.surface.geodataProcessor = processor;\n        this.map.geodataProcessors.push(processor);\n    } else {\n        if (this.surface.styleChanged) {\n            this.surface.geodataProcessor.setStylesheet(this.surface.stylesheet);\n            this.surface.styleChanged = false;\n        }\n    }\n\n    this.geodataProcessor = this.surface.geodataProcessor;\n    this.processing = false;\n    this.statsCounter = 0;\n    this.size = 0;\n    this.killed = false;\n    this.killedByCache = false;\n    this.ready = false;\n    this.isReady();\n};\n\n\nMapGeodataView.prototype.kill = function() {\n    this.killed = true;\n    this.geodata = null;\n    this.killGeodataView(false);\n};\n\n\nMapGeodataView.prototype.killGeodataView = function(killedByCache) {\n    this.killedByCache = killedByCache;\n\n    for (var i = 0, li = this.gpuGroups.length; i < li; i++) {\n        this.gpuGroups[i].kill();\n    }\n\n    this.gpuGroups = [];\n\n    if (killedByCache !== true && this.gpuCacheItem != null) {\n        this.map.gpuCache.remove(this.gpuCacheItem);\n    }\n\n    this.stats.gpuGeodata -= this.size;\n    this.stats.graphsFluxGeodata[1][0]++;\n    this.stats.graphsFluxGeodata[1][1] += this.size;\n    \n    this.ready = false;\n    this.size = 0;\n    this.gpuCacheItem = null;\n};\n\n\nMapGeodataView.prototype.processPackedCommands = function(buffer, index) {\n\n    var maxIndex = buffer.byteLength;\n    var maxTime = this.map.config.mapMaxGeodataProcessingTime;\n    var t = performance.now(), length, str, data;\n    var view = new DataView(buffer.buffer);\n\n    do {\n\n        var command = buffer[index]; index += 1;\n\n        switch(command) {\n            case VTS_WORKERCOMMAND_GROUP_BEGIN:\n                index += 1;\n                length = view.getUint32(index); index += 4;\n                str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;\n                data = JSON.parse(str);\n\n                this.currentGpuGroup = new GpuGroup(data['id'], data['bbox'], data['origin'], this.gpu, this.renderer);\n                this.gpuGroups.push(this.currentGpuGroup);\n\n                //console.log('VTS_WORKERCOMMAND_GROUP_BEGIN ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n                break;\n\n            case VTS_WORKERCOMMAND_GROUP_END:\n                this.size += this.currentGpuGroup.size; index += 1 + 4;\n                //console.log('VTS_WORKERCOMMAND_GROUP_END ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n                break;\n\n            case VTS_WORKERCOMMAND_ADD_RENDER_JOB:\n                index = this.currentGpuGroup.addRenderJob2(buffer, index, this.tile);\n                break;\n\n            case VTS_WORKERCOMMAND_ALL_PROCESSED:\n                this.map.markDirty();\n                this.gpuCacheItem = this.map.gpuCache.insert(this.killGeodataView.bind(this, true), this.size);\n\n                this.stats.gpuGeodata += this.size;\n                this.stats.graphsFluxGeodata[0][0]++;\n                this.stats.graphsFluxGeodata[0][1] += this.size;\n                this.ready = true;\n                this.processing = false;\n\n                //console.log('VTS_WORKERCOMMAND_ALL_PROCESSED ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n\n                index += 1 + 4;\n                break;\n        }\n\n        if ((performance.now() - t) > maxTime) {\n            if (index < maxIndex) {\n                return index;\n            }\n        }\n\n    } while(index < maxIndex);\n\n\n    this.stats.renderBuild += performance.now() - t; \n\n    return -1;\n};\n\n\nMapGeodataView.prototype.onGeodataProcessorMessage = function(command, message, task) {\n    if (this.killed || this.killedByCache){\n        return;\n    }\n\n    switch (command) {\n\n    case 'addPackedCommands':\n\n        //console.log('pack size:' + message['buffer'].byteLength);\n\n        if (task) {\n            var index = this.processPackedCommands(message['buffer'], message.index);\n\n            if (index < 0) {\n                this.map.markDirty();\n                //console.log('addPackedCommandsB ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n            } else {\n                //console.log('addPackedCommandsC ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n                message.index = index;\n                return -123;\n            }\n\n        } else {\n            message.index = 0;\n            this.map.markDirty();\n            this.map.addProcessingTask2(this.onGeodataProcessorMessage.bind(this, command, message, true));\n\n            //console.log('addPackedCommandsA ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n        }\n\n        break;\n\n    case 'ready':\n\n        if (this.geodataProcessor.processCounter > 0) {\n            this.geodataProcessor.processCounter--;\n\n            if (this.geodataProcessor.processCounter > 0) {\n                this.map.markDirty();\n                //console.log('ready2 ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n\n                break;\n            }\n        }\n\n        this.geodataProcessor.busy = false;\n        this.map.markDirty();\n        //console.log('ready ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n\n            //this.ready = true;\n        break;\n    }\n};\n\n\nMapGeodataView.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {\n    if (this.killed) {\n        return false;\n    }\n\n    //if (!(this.tile.id[0] == 21 && this.tile.id[1] == 566459 && this.tile.id[2] == 355240)) {\n      //  return false;\n    //}\n\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n    \n    //if (!this.ready && !doNotUseGpu && this.geodataProcessor.isReady()) {\n    if (!this.ready && !this.processing && !doNotLoad && this.surface.stylesheet.isReady()) {\n        if (this.geodata.isReady(doNotLoad, priority, doNotCheckGpu) && this.geodataProcessor.isReady()) {\n            this.processing = true;\n            this.killedByCache = false;\n            this.geodataProcessor.setListener(this.onGeodataProcessorMessage.bind(this));\n            this.geodataProcessor.sendCommand('processGeodata', this.geodata.geodata, this.tile, (window.devicePixelRatio || 1));\n            this.geodataProcessor.busy = true;\n            //console.log('processGeodata ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));\n        }\n    }\n\n    if (!doNotLoad && this.gpuCacheItem) {\n        this.map.gpuCache.updateItem(this.gpuCacheItem);\n    }\n\n    return this.ready;\n};\n\n\nMapGeodataView.prototype.getWorldMatrix = function(bbox, geoPos, matrix) {\n    var m = matrix;\n\n    if (m != null) {\n        m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;\n        m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;\n        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;\n        m[12] = bbox.min[0] - geoPos[0]; m[13] = bbox.min[1] - geoPos[1]; m[14] = bbox.min[2] - geoPos[2]; m[15] = 1;\n    } else {\n        m = mat4.create();\n\n        mat4.multiply( math.translationMatrix(bbox.min[0] - geoPos[0], bbox.min[1] - geoPos[1], bbox.min[2] - geoPos[2]),\n                       math.scaleMatrix(1, 1, 1), m);\n    }\n\n    return m;\n};\n\n\nMapGeodataView.prototype.draw = function(cameraPos) {\n    if (this.ready) {\n\n        var renderer = this.renderer;\n        var tiltAngle = this.tile ? Math.abs(this.tile.tiltAngle) : renderer.cameraTiltFator;\n\n        for (var i = 0, li = this.gpuGroups.length; i < li; i++) {\n            var group = this.gpuGroups[i]; \n\n            if (!group.jobs.length) {\n                continue; //TODO: remove empty groups\n            }\n\n            var mvp = group.mvp;\n            var mv = group.mv;\n            var mtmp = mvp; //use it as tmp matrix\n        \n            mat4.multiply(renderer.camera.getModelviewFMatrix(), this.getWorldMatrix(group.bbox, cameraPos, mtmp), mv);\n        \n            var proj = renderer.camera.getProjectionFMatrix();\n            mat4.multiply(proj, mv, mvp);\n            \n            group.draw(mv, mvp, null, tiltAngle, (this.tile ? this.tile.texelSize : 1));\n\n            this.stats.drawnFaces += group.polygons;\n            this.stats.drawCalls += group.jobs.length;\n        }\n        \n        if (this.statsCoutner != this.stats.counter) {\n            this.statsCoutner = this.stats.counter;\n            this.stats.gpuRenderUsed += this.size;\n        }\n    }\n    return this.ready;\n};\n\n//MapGeodataView.prototype.size = function() {\n    //return this.size;\n//};\n\nexport default MapGeodataView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-view.js\n// module id = 48\n// module chunks = 0 1","\nimport BBox_ from '../renderer/bbox';\nimport {utils as utils_} from '../utils/utils';\n\n//get rid of compiler mess\nvar BBox = BBox_;\nvar utils = utils_;\n\n\nvar MapGeodata = function(map, url, extraInfo) {\n    this.map = map;\n    this.stats = map.stats;\n    this.mapLoaderUrl  = url;\n    this.extraInfo = extraInfo;\n\n    this.bbox = new BBox();\n    this.size = 0;\n    this.fileSize = 0;\n    this.geodata = null;\n\n    this.cacheItem = null;\n\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n\n    this.map.markDirty();\n};\n\n\nMapGeodata.prototype.kill = function() {\n    this.bbox = null;\n    this.killGeodata();\n};\n\n\nMapGeodata.prototype.killGeodata = function(killedByCache) {\n    if (this.geodata) {\n        this.geodata = null;\n    }\n    \n    if (killedByCache !== true && this.cacheItem != null) {\n        this.map.resourcesCache.remove(this.cacheItem);\n    }\n\n    //if (this.gpuSubmeshes.length == 0) {\n    this.loadState = 0;\n    //}\n\n    this.size = 0;\n    this.fileSize = 0;\n    this.cacheItem = null;\n};\n\n\nMapGeodata.prototype.isReady = function(doNotLoad, priority) {\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n\n    if (this.loadState == 2) { //loaded\n        this.map.resourcesCache.updateItem(this.cacheItem);\n        return true;\n    } else {\n        if (this.loadState == 0) { \n            if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                  //  this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            } else {\n                //not loaded\n                //add to loading queue or top position in queue\n\n\n                if (typeof this.mapLoaderUrl === 'object') { //use geodata directly\n                    this.geodata = JSON.stringify(this.mapLoaderUrl);\n                    this.loadState = 2;\n                    this.cacheItem = this.map.resourcesCache.insert(this.killGeodata.bind(this, true), this.geodata.length);\n                    this.map.resourcesCache.updateItem(this.cacheItem);\n                    return true;\n                } else {\n                    this.scheduleLoad(priority);\n                }\n            }\n        } else if (this.loadState == 3) { //loadError\n            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n\n                this.scheduleLoad(priority);                    \n            }\n        }  //else load in progress\n    }\n\n    return false;\n};\n\n\nMapGeodata.prototype.scheduleLoad = function(priority) {\n    //if (this.mapLoaderUrl == null) {\n        //this.mapLoaderUrl = this.map.url.makeUrl(this.tile.surface.meshUrl, {lod:this.tile.id[0], ix:this.tile.id[1], iy:this.tile.id[2] });\n    //}\n\n    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.extraInfo.tile, 'geodata');\n};\n\n\nMapGeodata.prototype.onLoad = function(url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    //MapGeodataProcessor = function(surface, listener)\n\n    this.loadState = 1;\n    \n    utils.loadJSON(url, this.onLoaded.bind(this), this.onLoadError.bind(this), true, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n    return;\n};\n\n\nMapGeodata.prototype.onLoadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    this.loadState = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n\n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n\n    this.mapLoaderCallError();\n};\n\n\nMapGeodata.prototype.onLoaded = function(data) {\n    if (this.map.killed){\n        return;\n    }\n\n    var size = data.length;\n    this.size = size;\n    this.fileSize = size;\n\n    this.geodata = data;\n\n    this.cacheItem = this.map.resourcesCache.insert(this.killGeodata.bind(this, true), size);\n\n    this.map.markDirty();\n    this.loadState = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.mapLoaderCallLoaded();\n};\n\n// Returns RAM usage in bytes.\n//MapGeodata.prototype.size = function () {\n  //  return this.size;\n//};\n\n//MapGeodata.prototype.fileSize = function () {\n  //  return this.fileSize;\n//};\n\nexport default MapGeodata;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata.js\n// module id = 49\n// module chunks = 0 1","\nimport MapTexture_ from './texture';\nimport {math as math_} from '../utils/math';\nimport GeographicLib_ from 'geographiclib';\n\n//get rid of compiler mess\nvar MapTexture = MapTexture_;\nvar math = math_;\nvar GeographicLib = GeographicLib_;\n\n\nvar MapSrs = function(map, id, json) {\n    this.map = map;\n    this.id = id;\n    this.proj4 = map.proj4;\n    this.comment = json['comment'] || null;\n    this.srsDef = json['srsDef'] || null;\n    this.srsModifiers = json['srsModifiers'] || [];\n    this.type = json['type'] || 'projected';\n    this.vdatum = json['vdatum'] || 'orthometric';\n    //this.srsDefEllps = json[\"srsDefEllps\"] || \"\";\n    this.srsDef = json['srsDefEllps'] || this.srsDef;\n    this.periodicity = this.parsePeriodicity(json['periodicity']);\n    this.srsInfo = this.proj4(this.srsDef).info();\n    this.geoidGrid = null;\n    this.geoidGridMap = null;\n    this.srsProj4 = this.proj4(this.srsDef, null, null, true); \n    this.latlonProj4 = null; \n    this.proj4Cache = {};\n\n    if (json['geoidGrid']) {\n        var geoidGridData = json['geoidGrid'];\n\n        this.geoidGrid = {\n            definition : geoidGridData['definition'] || null,\n            srsDefEllps : geoidGridData['srsDefEllps'] || null,\n            valueRange : geoidGridData['valueRange'] || [0,1]\n        };\n\n        if (geoidGridData['extents']) {\n            this.geoidGrid.extents = {\n                ll : geoidGridData['extents']['ll'],\n                ur : geoidGridData['extents']['ur']\n            };\n        } else {\n            this.geoidGrid.extents = {\n                ll : [0,0],\n                ur : [1,1]\n            };\n        }\n\n        if (this.geoidGrid.definition) {\n            var url = this.map.url.makeUrl(this.geoidGrid.definition, {}, null);\n            this.geoidGridMap = new MapTexture(this.map, url, true);\n        }\n        \n        if (this.geoidGrid.srsDefEllps) {\n            this.geoidGrid.srsProj4 = this.proj4(this.geoidGrid.srsDefEllps, null, null, true);        \n        }\n    }\n\n    if (this.type == 'geographic') {\n        this.spheroid = json['spheroid'] || null;\n\n        if (this.spheroid == null) {\n            //TODO: return error\n        }\n    }\n};\n\n\nMapSrs.prototype.parsePeriodicity = function(periodicityData) {\n    if (periodicityData == null) {\n        return null;\n    }\n\n    var periodicity = {\n        'type' : periodicityData['type'] || '',\n        'period' : periodicityData['period'] || 0\n    };\n\n    return periodicity;\n};\n\n\nMapSrs.prototype.getInfo = function() {\n    return {\n        'comment' : this.comment,\n        'srsDef' : this.srsDef,\n        'srsModifiers' : this.srsModifiers,\n        'type' : this.type,\n        'vdatum' : this.vdatum,\n        'srsDefEllps' : this.srsDef,\n        'a' : this.srsInfo['a'],\n        'b' : this.srsInfo['b']\n    };\n};\n\n\nMapSrs.prototype.getSrsInfo = function() {\n    return this.srsInfo;\n};\n\n\nMapSrs.prototype.isReady = function() {\n    return this.isGeoidGridReady();\n};\n\n\nMapSrs.prototype.isGeoidGridReady = function() {\n    return (this.geoidGrid == null ||\n           (this.geoidGridMap != null && this.geoidGridMap.isReady()));\n};\n\n\nMapSrs.prototype.isProjected = function() {\n    return (this.type == 'projected');\n};\n\n\nMapSrs.prototype.getOriginalHeight = function(coords) {\n    var height = coords[2] || 0;\n    height /= this.getVerticalAdjustmentFactor(coords);\n    height += this.getGeoidGridDelta(coords);\n    return height;\n};\n\n\nMapSrs.prototype.getFinalHeight = function(coords) {\n    var height = coords[2] || 0;\n    height -= this.getGeoidGridDelta(coords);\n    height *= this.getVerticalAdjustmentFactor(coords);\n    return height;\n};\n\n\nMapSrs.prototype.getGeoidGridDelta = function(coords) {\n    if (this.geoidGridMap != null && this.isGeoidGridReady()) {\n        //get cooords in geoidGrid space\n        var mapCoords = this.proj4(this.srsProj4, this.geoidGrid.srsProj4, [coords[0], coords[1]]);\n\n        //get image coords\n        var px = mapCoords[0] - this.geoidGrid.extents.ll[0];\n        var py = this.geoidGrid.extents.ur[1] - mapCoords[1];\n\n        var imageExtens = this.geoidGridMap.getImageExtents();\n\n        px *= imageExtens[0] / (this.geoidGrid.extents.ur[0] - this.geoidGrid.extents.ll[0]);\n        py *= imageExtens[1] / (this.geoidGrid.extents.ur[1] - this.geoidGrid.extents.ll[1]);\n\n        px = math.clamp(px, 0, imageExtens[0] - 2);\n        py = math.clamp(py, 0, imageExtens[1] - 2);\n\n        //get bilineary interpolated value from image\n        var ix = Math.floor(px);\n        var iy = Math.floor(py);\n        var fx = px - ix;\n        var fy = py - iy;\n\n        var data = this.geoidGridMap.getImageData();\n        var index = iy * imageExtens[0];\n        var index2 = index + imageExtens[0];\n        var h00 = data[(index + ix)*4];\n        var h01 = data[(index + ix + 1)*4];\n        var h10 = data[(index2 + ix)*4];\n        var h11 = data[(index2 + ix + 1)*4];\n        var w0 = (h00 + (h01 - h00)*fx);\n        var w1 = (h10 + (h11 - h10)*fx);\n        var delta = (w0 + (w1 - w0)*fy);\n\n        //strech deta into value range\n        delta = this.geoidGrid.valueRange[0] + (delta * ((this.geoidGrid.valueRange[1] - this.geoidGrid.valueRange[0]) / 255));\n\n        return delta;\n    }\n\n    return 0;\n};\n\n\nMapSrs.prototype.getVerticalAdjustmentFactor = function(coords) {\n    if (this.srsModifiers.indexOf('adjustVertical') != -1) {\n        var info = this.getSrsInfo();\n\n        //convert coords to latlon\n        var latlonProj = '+proj=longlat ' +\n                          ' +alpha=0' +\n                          ' +gamma=0 +a=' + info['a'] +\n                          ' +b=' + info['b'] +\n                          ' +x0=0 +y0=0';\n\n        if (!this.latlonProj4) {\n            this.latlonProj4 = this.proj4(latlonProj, null, null, true); \n        }\n\n        var coords2 = this.proj4(this.srsProj4, this.latlonProj4, [coords[0], coords[1]]);\n\n        //move coors 1000m\n        var geod = new GeographicLib.Geodesic.Geodesic(info['a'],\n                                                       (info['a'] / info['b']) - 1.0);\n\n\n        var r = geod.Direct(coords2[1], coords2[0], 90, 1000);\n        coords2 = [r.lon2, r.lat2];\n\n        //convet coords from latlon back to projected\n        coords2 = this.proj4(this.latlonProj4, this.srsProj4, coords2);\n\n        //get distance between coords\n        var dx = coords2[0] - coords[0];\n        var dy = coords2[1] - coords[1];\n\n        var distance = Math.sqrt(dx * dx + dy* dy);\n\n        //get factor\n        var factor = distance / 1000;\n\n        return factor;\n    }\n\n    return 1.0;\n};\n\n\nMapSrs.prototype.convertCoordsTo = function(coords, srs, skipVerticalAdjust) {\n    this.isReady();\n    if (typeof srs !== 'string') {\n        if (srs.id == this.id) {\n            return coords.slice();\n        }\n\n        srs.isReady();\n    }\n\n    coords = coords.slice();\n\n    var stringSrs = (typeof srs === 'string');\n\n    //if (!skipVerticalAdjust && stringSrs) {\n    coords[2] = this.getOriginalHeight(coords);\n    //}\n\n    var srsDef = (stringSrs) ? srs : srs.srsProj4;\n\n    /*\n    if (srsDef.isGeocent && this.srsProj4.projName == \"merc\") {\n        var coords3 = coords.slice();\n        this.convertMercToWGS(coords3);\n        this.convertWGSToGeocent(coords3, srsDef);\n        return coords3;\n    }*/\n\n\n    var srsDef2 = (stringSrs) ? srs : srs.srsDef;\n    //var coords2 = this.proj4(this.srsProj4, srsDef, coords);\n\n    var proj = this.proj4Cache[srsDef2];\n    \n    if (!proj) {\n        proj = this.proj4(this.srsProj4, srsDef);\n        this.proj4Cache[srsDef2] = proj;\n    }\n\n    var coords2 = proj.forward(coords);\n\n    if (!skipVerticalAdjust && !stringSrs) {\n        coords2[2] = srs.getFinalHeight(coords2);\n    }\n\n    return coords2;\n};\n\n\nMapSrs.prototype.convertCoordsToFast = function(coords, srs, skipVerticalAdjust, coords2, index, index2) {\n\n    //if (!skipVerticalAdjust && stringSrs) {\n        //coords[2] = this.getOriginalHeight(coords);\n    //}\n\n    var srsDef = srs.srsProj4;\n    \n    /*\n    if (srsDef.isGeocent && this.srsProj4.projName == \"merc\") {\n        this.convertMercToWGS(coords, coords2, index, index2);\n        this.convertWGSToGeocent(coords2, srsDef, coords2, index2, index2);\n        return;\n    }*/\n\n    var srsDef2 = srs.srsDef;\n\n    var proj = this.proj4Cache[srsDef2];\n    \n    if (!proj) {\n        proj = this.proj4(this.srsProj4, srsDef);\n        this.proj4Cache[srsDef2] = proj;\n    }\n\n    var coords3 = proj.forward(coords);\n    \n    coords2[index2] = coords3[0];\n    coords2[index2+1] = coords3[1];\n    coords2[index2+2] = coords3[2];\n    \n\n    //if (!skipVerticalAdjust && stringSrs) {\n        //coords2[2] = srs.getFinalHeight(coords2);\n    //}\n    \n    if (srs.geoidGrid) {\n        coords2[index2+2] -= srs.getGeoidGridDelta(coords);\n    }\n};\n\n\nMapSrs.prototype.convertCoordsFrom = function(coords, srs) {\n    this.isReady();\n    if (typeof srs !== 'string') {\n        if (srs.id == this.id) {\n            return coords.slice();\n        }\n\n        srs.isReady();\n    }\n\n    coords = coords.slice();\n\n    if (typeof srs !== 'string') {\n        coords[2] = srs.getOriginalHeight(coords);\n    }\n\n    var srsDef = (typeof srs === 'string') ? srs : srs.srsProj4;\n    var srsDef2 = (typeof srs === 'string') ? srs : srs.srsDef;\n\n    //var coords2 = this.proj4(srsDef, this.srsProj4, coords);\n\n    var proj = this.proj4Cache[srsDef2];\n    \n    if (!proj) {\n        proj = this.proj4(this.srsProj4, srsDef);\n        this.proj4Cache[srsDef2] = proj;\n    }\n\n    var coords2 = proj.inverse(coords);\n\n    coords2[2] = this.getFinalHeight(coords2);\n\n    return coords2;\n};\n\n\nMapSrs.prototype.phi2z = function(eccent, ts) {\n    var HALFPI = Math.PI*0.5;\n    var eccnth = 0.5 * eccent;\n    var con, dphi;\n    var phi = HALFPI - 2 * Math.atan(ts);\n    for (var i = 0; i <= 15; i++) {\n        con = eccent * Math.sin(phi);\n        dphi = HALFPI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n        phi += dphi;\n        if (Math.abs(dphi) <= 0.0000000001) {\n            return phi;\n        }\n    }\n  //console.log(\"phi2z has NoConvergence\");\n    return -9999;\n};\n\n\nMapSrs.prototype.convertMercToWGS = function(coords, coords2, index, index2) {\n    var TWOPI = Math.PI * 2;\n    var HALFPI = Math.PI*0.5;\n    var proj = this.srsProj4;\n    var x = coords[index] - proj.x0;\n    var y = coords[index+1] - proj.y0;\n\n    if (proj.sphere) {\n        coords2[index2+1] = HALFPI - 2 * Math.atan(Math.exp(-y / (proj.a * proj.k0)));\n    } else {\n        var ts = Math.exp(-y / (proj.a * proj.k0));\n        var yy = this.phi2z(proj.e, ts);\n        coords2[index2+1] = yy;\n        if (yy === -9999) {\n            return;\n        }\n    }\n    \n    //coords[0] = adjustlon(proj.long0 + x / (proj.a * proj.k0));\n    x = proj.long0 + x / (proj.a * proj.k0);\n    var SPI = 3.14159265359;\n    coords2[index2] = (Math.abs(x) <= SPI) ? x : (x - ((x < 0) ? -1 : 1) * TWOPI);\n    coords2[index2+2] = coords[index+2];\n};\n\n\nMapSrs.prototype.convertWGSToGeocent = function(coords, srs, coords2, index, index2) {\n    var datum = srs.datum;\n\n    var HALFPI = Math.PI*0.5;\n    var Longitude = coords[index];\n    var Latitude = coords[index+1];\n    var Height = coords[index+2]; //Z value not always supplied\n\n    var Rn; /*  Earth radius at location  */\n    var SinLat; /*  Math.sin(Latitude)  */\n    var Sin2Lat; /*  Square of Math.sin(Latitude)  */\n    var CosLat; /*  Math.cos(Latitude)  */\n\n    /*\n     ** Don't blow up if Latitude is just a little out of the value\n     ** range as it may just be a rounding issue.  Also removed longitude\n     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n     */\n    if (Latitude < -HALFPI && Latitude > -1.001 * HALFPI) {\n        Latitude = -HALFPI;\n    }\n    else if (Latitude > HALFPI && Latitude < 1.001 * HALFPI) {\n        Latitude = HALFPI;\n    }\n    else if ((Latitude < -HALFPI) || (Latitude > HALFPI)) {\n      /* Latitude out of range */\n      //..reportError('geocent:lat out of range:' + Latitude);\n        return null;\n    }\n\n    if (Longitude > Math.PI) {\n        Longitude -= (2 * Math.PI);\n    }\n\n    SinLat = Math.sin(Latitude);\n    CosLat = Math.cos(Latitude);\n    Sin2Lat = SinLat * SinLat;\n    Rn = datum.a / (Math.sqrt(1.0e0 - datum.es * Sin2Lat));\n    coords2[index2] = (Rn + Height) * CosLat * Math.cos(Longitude);\n    coords2[index2+1] = (Rn + Height) * CosLat * Math.sin(Longitude);\n    coords2[index2+2] = ((Rn * (1 - datum.es)) + Height) * SinLat;\n};\n\n\nexport default MapSrs;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/srs.js\n// module id = 50\n// module chunks = 0 1","\nimport {utils as utils_} from '../utils/utils';\n\n//get rid of compiler mess\nvar utils = utils_;\n\n\nvar MapStylesheet = function(map, id, url, freeLayer) {\n    this.generateLines = true;\n    this.map = map;\n    this.renderer = this.map.renderer;\n    this.stats = map.stats;\n    this.id  = id;\n    this.url  = null;\n    this.data = null;\n    this.loadState = 0;\n    this.size = 0;\n    this.fileSize = 0;\n    this.freeLayer = freeLayer;\n    this.fonts = {};\n    this.fontsReady = false;\n    \n    if (typeof url === 'object') {\n        this.data = url;\n        this.setFonts(this.data);\n        this.loadState = 2;\n        this.map.markDirty();\n    } else {\n        if (this.freeLayer) {\n            this.url = this.freeLayer.processUrl(url, '');\n        } else {\n            this.url = this.map.url.processUrl(url);\n        }\n\n        //load style directly\n        utils.loadJSON(this.url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, (utils.useCredentials ? (this.url.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n        this.loadState = 1;\n    }\n};\n\n\nMapStylesheet.prototype.kill = function() {\n};\n\n\nMapStylesheet.prototype.setData = function(data) {\n    this.data = data;\n    this.setFonts(data);\n    this.loadState = 2;\n    this.checkFonts();\n};\n\nMapStylesheet.prototype.checkFonts = function() {\n    var ready = true;\n    for (var key in this.fonts) {\n        ready = (ready && this.renderer.getFont(this.fonts[key]).isReady());\n    }\n\n    this.fontsReady = ready;\n\n    return ready;\n};\n\nMapStylesheet.prototype.isReady = function(doNotLoad, priority) {\n    if (this.loadState == 2) { //loaded\n        if (this.fontsReady) {\n            return true;\n        } else {\n            return this.checkFonts();\n        }\n\n    } else {\n        if (this.loadState == 0) { \n            if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                  //  this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            } else {\n                //not loaded\n                //add to loading queue or top position in queue\n                this.scheduleLoad(priority);\n            }\n        } //else load in progress\n    }\n\n    return false;\n};\n\n\nMapStylesheet.prototype.scheduleLoad = function(priority) {\n    this.map.loader.load(this.url, this.onLoad.bind(this), priority);\n};\n\n\nMapStylesheet.prototype.onLoad = function() {\n    //this.mapLoaderCallLoaded = onLoaded;\n    //this.mapLoaderCallError = onError;\n\n    this.loadState = 1;\n};\n\n\nMapStylesheet.prototype.onLoadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    //this.mapLoaderCallError();\n    //this.loadState = 2;\n};\n\nMapStylesheet.prototype.setFonts = function(data) {\n    this.fonts = data['fonts'] || {};\n    \n    if (!this.fonts['#default']) {\n        this.fonts['#default'] = this.map.core.config.mapDefaultFont;\n    }\n};\n\nMapStylesheet.prototype.onLoaded = function(data) {\n    if (this.map.killed){\n        return;\n    }\n    \n    this.data = data;\n    this.setFonts(data);\n\n    //this.mapLoaderCallLoaded();\n    this.loadState = 2;\n    this.map.markDirty();\n};\n\n\n// Returns RAM usage in bytes.\n//MapStylesheet.prototype.size = function () {\n  //  return this.size;\n//};\n\n//MapStylesheet.prototype.fileSize = function () {\n  //  return this.fileSize;\n//};\n\nexport default MapStylesheet;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/stylesheet.js\n// module id = 51\n// module chunks = 0 1","\nimport {utils as utils_} from '../utils/utils';\nimport GpuTexture_ from '../renderer/gpu/texture';\n\n//get rid of compiler mess\nvar utils = utils_;\nvar GpuTexture = GpuTexture_;\n\n\nvar MapSubtexture = function(map, path, type, tile, internal) {\n    this.map = map;\n    this.stats = map.stats;\n    this.tile = tile; // used only for stats\n    this.internal = internal; // used only for stats\n    this.image = null;\n    this.imageData = null;\n    this.imageExtents = null;\n    this.gpuTexture = null;\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.neverReady = false;\n    this.mapLoaderUrl = path;\n    this.type = type || false;\n    this.statsCounter = 0;\n    this.checkStatus = 0;\n    this.checkType = null;\n    this.checkValue = null;\n    this.fastHeaderCheck = false;\n    this.gpuSize = 0;\n    this.fileSize = 0;\n    this.cacheItem = null; //store killImage\n    this.gpuCacheItem = null; //store killGpuTexture\n};\n\n\nMapSubtexture.prototype.kill = function() {\n    this.killImage();\n    this.killGpuTexture();\n    \n    if (this.mask) {\n        this.mask.killImage(); \n        this.mask.killGpuTexture(); \n    }\n    \n    //this.tile.validate();\n};\n\n\nMapSubtexture.prototype.killImage = function(killedByCache) {\n    this.image = null;\n    this.imageData = null;\n\n    if (killedByCache !== true && this.cacheItem) {\n        this.map.resourcesCache.remove(this.cacheItem);\n        //this.tile.validate();\n    }\n\n    if (this.mask) {\n        this.mask.killImage(); \n    }\n\n    if (!this.gpuTexture) {\n        this.loadState = 0;\n    } //else {\n        //this.loadState = this.loadState;\n    //}\n\n    this.cacheItem = null;\n};\n\n\nMapSubtexture.prototype.killGpuTexture = function(killedByCache) {\n/*\n    //debug only    \n    if (!this.map.lastRemoved) {\n        this.map.lastRemoved = [];\n    }\n\n    //debug only    \n    if (this.map.lastRemoved.indexOf(this.mapLoaderUrl) != -1) {\n        console.log(\"tex: \" + this.mapLoaderUrl);\n    }\n\n    //debug only    \n    this.map.lastRemoved.unshift(this.mapLoaderUrl);\n    this.map.lastRemoved = this.map.lastRemoved.slice(0,20);\n*/\n\n    if (this.gpuTexture != null) {\n        this.stats.gpuTextures -= this.gpuTexture.size;\n        this.gpuTexture.kill();\n\n        this.stats.graphsFluxTexture[1][0]++;\n        this.stats.graphsFluxTexture[1][1] += this.gpuTexture.size;\n\n        if (this.mask) {\n            this.mask.killGpuTexture(); \n        }\n    }\n\n    this.gpuTexture = null;\n\n    if (killedByCache !== true && this.gpuCacheItem) {\n        this.map.gpuCache.remove(this.gpuCacheItem);\n        //this.tile.validate();\n    }\n\n    if (!this.image && !this.imageData) {\n        this.loadState = 0;\n    }\n\n    this.gpuCacheItem = null;\n};\n\n\nMapSubtexture.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu, texture) {\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n    \n    if (this.neverReady) {\n        return false;\n    }\n\n    switch (texture.checkType) {\n    case VTS_TEXTURECHECK_TYPE:\n    case VTS_TEXTURECHECK_CODE:\n    case VTS_TEXTURECHECK_SIZE:\n        \n        if (this.checkStatus != 2) {\n            this.checkType = texture.checkType;\n            this.checkValue = texture.checkValue;\n\n            if (this.checkStatus == 0) {\n                this.scheduleHeadRequest(priority, (this.checkType == VTS_TEXTURECHECK_SIZE));\n            } else if (this.checkStatus == 3) { //loadError\n                if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                        performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n                    this.scheduleHeadRequest(priority, (this.checkType == VTS_TEXTURECHECK_SIZE));\n                }\n            } else if (this.checkStatus == -1) {\n            \n                if (texture.extraInfo) { //find at least texture with lower resolution\n                    if (!texture.extraBound) {\n                        texture.extraBound = { tile: texture.extraInfo.tile, layer: texture.extraInfo.layer};\n                        texture.setBoundTexture(texture.extraBound.tile.parent, texture.extraBound.layer);        \n                    }\n        \n                    while (texture.extraBound.texture.extraBound || texture.extraBound.texture.checkStatus == -1) {\n                        //while (texture.extraBound.texture.checkStatus == -1) {\n                        texture.setBoundTexture(texture.extraBound.sourceTile.parent, texture.extraBound.layer);        \n                    }\n                }\n            }\n    \n            return false;\n        }\n            \n        break;\n    }\n\n    if (this.loadState == 2) { //loaded\n        var t;\n\n        if (!doNotLoad && this.cacheItem) {\n            this.map.resourcesCache.updateItem(this.cacheItem);\n        }\n\n        if (((this.type == VTS_TEXTURETYPE_HEIGHT && !this.imageData) || (this.type != VTS_TEXTURETYPE_HEIGHT && !this.gpuTexture)) &&\n              this.stats.renderBuild > this.map.config.mapMaxProcessingTime) {\n            //console.log(\"testure resource build overflow\");\n            this.map.markDirty();\n            return false;\n        }\n\n        if (doNotCheckGpu) {\n            if (this.type == VTS_TEXTURETYPE_HEIGHT) {\n                if (!this.imageData) {\n                    t = performance.now();\n                    this.buildHeightMap();\n                    this.stats.renderBuild += performance.now() - t; \n                }\n            }\n\n            return true;\n        }\n\n        if (this.type == VTS_TEXTURETYPE_HEIGHT) {\n            if (!this.imageData) {\n                t = performance.now();\n                this.buildHeightMap();\n                this.stats.renderBuild += performance.now() - t; \n            }\n        } else {\n            if (!this.gpuTexture) {\n                if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {\n                    return false;\n                }\n                \n                if (doNotUseGpu) {\n                    return false;\n                }\n\n                //if (this.stats.graphsFluxTexture [0][0] > 2) {\n                   // return false;\n                //}\n\n                t = performance.now();\n                this.buildGpuTexture();\n                this.stats.renderBuild += performance.now() - t; \n            }\n\n            if (!doNotLoad && this.gpuCacheItem) {\n                this.map.gpuCache.updateItem(this.gpuCacheItem);\n            }\n        }\n        \n        \n        return true;\n    } else {\n        if (this.loadState == 0) { \n            if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                    //this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            } else {\n                //not loaded\n                //add to loading queue or top position in queue\n                this.scheduleLoad(priority);\n            }\n        } else if (this.loadState == 3) { //loadError\n            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n\n                this.scheduleLoad(priority);                    \n            }\n        } //else load in progress\n    }\n\n    return false;\n};\n\n\nMapSubtexture.prototype.scheduleLoad = function(priority, header) {\n    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this, header), priority, this.tile, this.internal ? 'texture-in' : 'texture-ex');\n};\n\n\nMapSubtexture.prototype.onLoad = function(header, url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    var onerror = this.onLoadError.bind(this);\n    var onload = this.onLoaded.bind(this);\n\n    if (header) {\n        this.checkStatus = 1;\n    } else {\n        this.loadState = 1;\n    }\n\n    if (this.map.config.mapXhrImageLoad) {\n        utils.loadBinary(url, this.onBinaryLoaded.bind(this), onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');\n    } else {\n        this.image = utils.loadImage(url, onload, onerror, (this.map.core.tokenCookieHost ? (url.indexOf(this.map.core.tokenCookieHost) != -1) : false));\n    }\n    //mapXhrImageLoad\n};\n\n\nMapSubtexture.prototype.onLoadError = function(killBlob) {\n    if (this.map.killed){\n        return;\n    }\n\n    if (killBlob) {\n        window.URL.revokeObjectURL(this.image.src);\n    }\n\n    this.loadState = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n    \n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n    \n    this.mapLoaderCallError();\n};\n\n\nMapSubtexture.prototype.onBinaryLoaded = function(data) {\n    if (this.fastHeaderCheck && this.checkType && this.checkType != VTS_TEXTURECHECK_MEATATILE) {\n        this.onHeadLoaded(null, data, null /*status*/);\n        \n        if (this.checkStatus == -1) {\n            this.mapLoaderCallLoaded();\n            return;\n        }\n    }\n\n    this.fileSize = data.size;\n\n    if (this.map.config.mapAsyncImageDecode) {\n        createImageBitmap(data).then(this.onLoaded.bind(this, false));\n    } else {\n        var image = new Image();\n        image.onerror = this.onLoadError.bind(this, true, null);\n        image.onload = this.onLoaded.bind(this, true, null);\n        this.image = image;\n        image.src = window.URL.createObjectURL(data);\n    }\n};\n\n\nMapSubtexture.prototype.onLoaded = function(killBlob, bitmap) {\n    if (this.map.killed){\n        return;\n    }\n\n    if (killBlob) {\n        window.URL.revokeObjectURL(this.image.src);\n    }\n\n    if (bitmap) {\n        this.image = bitmap;\n        this.image.naturalWidth = bitmap.width;\n        this.image.naturalHeight = bitmap.height;\n    }\n\n    var size = this.image.naturalWidth * this.image.naturalHeight * (this.heightMap ? 3 : 3);\n    this.gpuSize = this.image.naturalWidth * this.image.naturalHeight * 4;  //aproximate size \n\n    //if (!this.image.complete) {\n       // size = size;\n    //}\n    \n    //console.log(size);\n\n    this.cacheItem = this.map.resourcesCache.insert(this.killImage.bind(this, true), size);\n\n    this.map.markDirty();\n    this.loadState = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.mapLoaderCallLoaded();\n};\n\n\nMapSubtexture.prototype.scheduleHeadRequest = function(priority, downloadAll) {\n    if (this.map.config.mapXhrImageLoad && this.fastHeaderCheck) {\n        this.scheduleLoad(priority, true);\n    } else {\n        this.map.loader.load(this.mapLoaderUrl, this.onLoadHead.bind(this, downloadAll), priority, this.tile, this.internal, this.internal ? 'texture-in' : 'texture-ex');\n    }\n};\n\n\nMapSubtexture.prototype.onLoadHead = function(downloadAll, url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    var onerror = this.onLoadHeadError.bind(this, downloadAll);\n    var onload = this.onHeadLoaded.bind(this, downloadAll);\n\n    this.checkStatus = 1;\n\n    if (downloadAll) {\n        utils.loadBinary(url, onload, onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');\n    } else {\n        utils.headRequest(url, onload, onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');\n    }\n};\n\n\nMapSubtexture.prototype.onLoadHeadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    this.checkStatus = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n    \n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n    \n    this.mapLoaderCallError();\n};\n\n\nMapSubtexture.prototype.onHeadLoaded = function(downloadAll, data, status) {\n    if (this.map.killed){\n        return;\n    }\n\n    this.checkStatus = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n\n    if (this.map.config.mapXhrImageLoad && this.fastHeaderCheck) {\n\n        switch (this.checkType) {\n        case VTS_TEXTURECHECK_SIZE:\n            if (data) {\n                if (data.size == this.checkValue) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n                \n        case VTS_TEXTURECHECK_TYPE:\n            if (data) {\n                if (data.type == this.checkValue) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n                \n        case VTS_TEXTURECHECK_CODE:\n            if (status) {\n                if (this.checkValue.indexOf(status) != -1) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n        }\n\n    } else {\n\n        switch (this.checkType) {\n        case VTS_TEXTURECHECK_SIZE:\n            if (data) {\n                if (data.byteLength == this.checkValue) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n                \n        case VTS_TEXTURECHECK_TYPE:\n            if (data) {\n                //if (!data.indexOf) {\n                  //  data = data;\n                //}\n                    \n                if (data.indexOf(this.checkValue) != -1) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n                \n        case VTS_TEXTURECHECK_CODE:\n            if (status) {\n                if (this.checkValue.indexOf(status) != -1) {\n                    this.checkStatus = -1;\n                }\n            }\n            break;\n        }\n        \n        this.mapLoaderCallLoaded();\n    }\n};\n\n\nMapSubtexture.prototype.buildGpuTexture = function () {\n    this.gpuTexture = new GpuTexture(this.map.renderer.gpu, null, this.map.core);\n    this.gpuTexture.createFromImage(this.image, (this.type == VTS_TEXTURETYPE_CLASS) ? 'nearest' : 'linear', false);\n    this.stats.gpuTextures += this.gpuTexture.size;\n\n    this.stats.graphsFluxTexture[0][0]++;\n    this.stats.graphsFluxTexture[0][1] += this.gpuTexture.size;\n\n    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuTexture.bind(this, true), this.gpuTexture.size);\n    this.gpuSize = this.gpuTexture.size;\n};\n\n\nMapSubtexture.prototype.buildHeightMap = function () {\n    var canvas = document.createElement('canvas');\n    canvas.width = this.image.naturalWidth;\n    canvas.height = this.image.naturalHeight;\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(this.image, 0, 0);\n    this.imageData = ctx.getImageData(0, 0, this.image.naturalWidth, this.image.naturalHeight).data;\n    this.imageExtents = [this.image.naturalWidth, this.image.naturalHeight];\n    this.image = null;\n};\n\n\nMapSubtexture.prototype.getGpuTexture = function() {\n    return this.gpuTexture;\n};\n\n\nMapSubtexture.prototype.getHeightMapValue = function(x, y) {\n    if (this.imageData) {\n        return this.imageData[(y * this.imageExtents[0] + x)*4];\n    }\n    \n    return 0;\n};\n\nexport default MapSubtexture;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/subtexture.js\n// module id = 52\n// module chunks = 0 1","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport MapSurfaceTile_ from './surface-tile';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar MapSurfaceTile = MapSurfaceTile_;\n\n\nvar MapSurfaceTree = function(map, freeLayer, freeLayerSurface) {\n    this.map = map;\n    this.camera = map.camera;\n    this.rootId = [0,0,0];\n    this.freeLayer = freeLayer;\n    this.freeLayerSurface = freeLayerSurface;\n    this.metaBinaryOrder = this.map.referenceFrame.params.metaBinaryOrder;\n    //this.initialized = false;\n    //this.geocent = !this.map.getNavigationSrs().isProjected();\n\n    this.surfaceTree = new MapSurfaceTile(this.map, null, this.rootId);\n\n    //if (freeLayer !== true) {\n        //this.heightTracer = new MapMetanodeTracer(this, null, this.traceTileHeight.bind(this), this.traceHeightChild.bind(this));\n        //this.heightTracerNodeOnly = new MapMetanodeTracer(this, null, this.traceTileHeightNodeOnly.bind(this), this.traceHeightChild.bind(this));\n    //}\n\n    this.surfaceSequence = [];\n    this.surfaceOnlySequence = [];\n\n    this.config = this.map.config;\n    this.cameraPos = [0,0,0];\n    this.worldPos = [0,0,0];\n    this.ndcToScreenPixel = 1.0;\n    this.counter = 0;\n};\n\n\nMapSurfaceTree.prototype.kill = function() {\n    this.surfaceTree = null;\n    this.metastorageTree = null;\n    this.surfaceTracer = null;\n    this.heightTracer = null;\n};\n\n\n/*MapSurfaceTree.prototype.init = function() {\n    var url = this.map.url.makeUrl(surface.metaUrl, {lod:result[0], ix:result[1], iy:result[2] });  //result???\n    map.loader.load(url, metatile.load.bind(metatile, url));\n\n    this.metatileTree.load();\n    this.surfaceTree.metatile = 1;\n\n    this.initialized = true;\n};*/\n\n\nMapSurfaceTree.prototype.findSurfaceTile = function(id) {\n    var tile = this.surfaceTree;\n\n//    for (var lod = 1; lod <= id[0]; lod++) {\n//        var mask = 1 << (lod-1);\n//        var index = 0;\n\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n        \n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        tile = tile.children[index];\n\n        if (!tile) {\n            return null;\n        }\n    }\n    \n    return tile;\n};\n\n\nMapSurfaceTree.prototype.findNavTile = function(id) {\n    var tile = this.surfaceTree;\n    \n    if (id[0] == 0) {\n        if (tile.metanode && tile.metanode.hasNavtile()) {\n            return tile;\n        } else {\n            return null;\n        }\n    }\n    \n    var navtile = null;\n\n//    for (var lod = 1; lod <= id[0]; lod++) {\n//        var mask = 1 << (id[0] - lod);\n//        var index = 0;\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        tile = tile.children[index];\n\n        if (!tile) {\n            return navtile;\n        } else {\n            if (tile.metanode && tile.metanode.hasNavtile()) {\n                navtile = tile;\n            }\n        }\n    }\n    \n    return navtile;\n};\n\n\nMapSurfaceTree.prototype.draw = function(storeTilesOnly) {\n    this.cameraPos = [0,0,0];\n    this.worldPos = [0,0,0];\n\n    var map = this.map;\n    var draw = map.draw;\n    this.ndcToScreenPixel = draw.ndcToScreenPixel;\n    \n    var srs = map.getPhysicalSrs();\n\n    //var divisionNode = this.divisionNode;\n    var periodicity = srs.periodicity;\n\n    //if (this.map.config.mapBasicTileSequence) {\n        //this.surfaceTracer = this.surfaceTracerBasic;\n    //}\n    \n    if (this.freeLayerSurface && this.freeLayerSurface.geodata && draw.drawChannel != 0) {\n        return;\n    }\n\n    if (periodicity != null) {\n        this.drawSurface([0,0,0]);\n\n        if (periodicity.type == 'X') {\n            this.drawSurface([periodicity.period,0,0], storeTilesOnly);\n            this.drawSurface([-periodicity.period,0,0], storeTilesOnly);\n        }\n\n    } else {\n        var mode;\n\n        if (this.freeLayerSurface && this.freeLayerSurface.geodata) {\n            mode = map.config.mapGeodataLoadMode; \n        } else {\n            mode = map.config.mapLoadMode; \n        }\n\n        switch(mode) {\n        case 'topdown': this.drawSurface([0,0,0], storeTilesOnly); break;\n        case 'fit':     this.drawSurfaceFit([0,0,0], storeTilesOnly); break;\n        case 'fitonly': this.drawSurfaceFitOnly([0,0,0], storeTilesOnly); break;\n        }\n    }\n};\n\n\nMapSurfaceTree.prototype.updateNodeHeightExtents = function(tile, node) {\n    \n    if (!node.heightReady && node.metatile.useVersion < 4) {\n        var parent = tile.parent;\n\n        //if (node.hasNavtile()) {\n          //  node = node;\n        //}\n        \n        while (parent) {\n            var parentNode = parent.metanode;  \n            if (parentNode.hasNavtile()) {\n\n                //if (node.hasNavtile()) {\n                  //  node = node;\n                //}\n\n                node.minHeight = parentNode.minHeight;\n                node.maxHeight = parentNode.maxHeight;\n                node.minZ = parentNode.minZ;\n                node.maxZ = parentNode.maxZ;\n                node.generateCullingHelpers();\n                break;\n            }\n            \n            parent = parent.parent;\n        }\n\n        node.heightReady = true;\n    }\n};\n\n\nMapSurfaceTree.prototype.logTileInfo = function(tile, node, cameraPos) {\n    if (!tile || !node) {\n        return;\n    }\n    \n    var visible = tile.bboxVisible(tile.id, node.bbox, cameraPos, node);\n    tile.updateTexelSize();\n    \n    // eslint-disable-next-line\n    console.log('tile: ' + JSON.stringify(tile.id) + ' visible: ' + visible + ' texelsize: ' +  tile.texelSize + ' center: '  + JSON.stringify(node.diskPos) + ' vec: ' + node.diskNormal + 'ang: ' + node.diskAngle + ' dist: ' + node.diskDistance);\n};\n\n\n//loadmode = topdown\nMapSurfaceTree.prototype.drawSurface = function(shift, storeTilesOnly) {\n    this.counter++;\n\n    var tile = this.surfaceTree;\n    \n    if (!tile.isMetanodeReady(this, 0)) {\n        return;\n    }\n    \n    var map = this.map;\n    var node = tile.metanode;\n    var cameraPos = map.camera.position;\n\n    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n        return;\n    }\n\n    tile.updateTexelSize();\n    \n    var typeFactor = this.freeLayerSurface ? 1 : 1;\n\n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var drawBuffer = draw.drawBuffer;\n    var processBuffer = draw.processBuffer;\n    var newProcessBuffer = draw.processBuffer2;\n    var drawBufferIndex = 0;\n    var processBufferIndex = 0;\n    var newProcessBufferIndex = 0;\n    var gpuNeeded = 0;\n    var gpuNeededForRender = 0;\n    var size = 0;\n    \n    processBuffer[0] = tile;\n    processBufferIndex = 1;\n   \n    var texelSizeFit = draw.texelSizeFit;\n\n    var best2 = 0;\n    var replay = draw.replay;\n    var storeNodes = replay.storeNodes || replay.storeFreeNodes;\n    var storeNodesBuffer = replay.nodeBuffer; \n   \n    draw.drawCounter++;\n    \n    var pocessedNodes = 1;\n    var pocessedMetatiles = 1;  \n    var usedNodes = 1;\n    var drawCounter = draw.drawCounter, i, j, lj;\n\n\n    do {\n        var best = 0;\n        newProcessBufferIndex = 0;\n        \n        for (i = processBufferIndex - 1; i >= 0; i--) {\n            tile = processBuffer[i];\n            node = tile.metanode;\n\n            if (node) {\n                pocessedNodes++;\n                if (node.metatile.drawCounter != drawCounter) {\n                    node.metatile.drawCounter = drawCounter;\n                    pocessedMetatiles++;\n                }\n            }\n            \n            //if (this.map.drawIndices) {\n              //  this.logTileInfo(tile, node, cameraPos);\n            //}\n\n            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n\n                usedNodes++;\n\n                if (tile.texelSize != Number.POSITIVE_INFINITY){\n                    if (tile.texelSize > best) {\n                        best = tile.texelSize;\n                    }\n                }\n                \n                if (storeNodes) { //used only for inspector\n                    storeNodesBuffer.push(tile);\n                }\n              \n                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit /*|| gpuNeeded > gpuMax*/) {\n                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);\n\n                    gpuNeeded += size;\n                    gpuNeededForRender += size;\n\n                    tile.drawCounter = draw.drawCounter;\n                    drawBuffer[drawBufferIndex] = tile;\n                    drawBufferIndex++;\n                    \n                } else { //go deeper\n                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);\n                    gpuNeeded += size;\n\n                    var childrenCount = 0;\n                    var readyCount = 0;\n                    var childrenBuffer = [];\n                    \n                    var more3 = 0;\n        \n                    for (j = 0; j < 4; j++) {\n                        var child = tile.children[j];\n                        if (child) {\n                            childrenCount++;\n       \n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                var factor = 1;\n\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize(factor);\n                                \n                                var priority = child.id[0] * typeFactor * child.distance;\n                                \n                                if (!tile.surface || !child.metanode.hasGeometry()) {\n\n                                    readyCount++;\n                                    //child.updateTexelSize();\n                                    childrenBuffer.push(child);\n                                    \n                                } else {\n\n                                    //are draw buffers ready? preventRender=true, preventLoad=false, doNotCheckGpu=true\n                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, true)) {\n                                        readyCount++;\n                                        //child.updateTexelSize();\n                                        childrenBuffer.push(child);\n                                    }\n                                    \n                                }\n                            }\n                        }\n                    }\n        \n                    if (/*!(gpuNeeded > gpuMax) &&*/ childrenCount > 0 && childrenCount == readyCount && childrenCount != more3) {\n                        //sort children by distance\n    \n                        do {\n                            var sorted = true;\n                            \n                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {\n                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {\n                                    var t = childrenBuffer[j];\n                                    childrenBuffer[j] = childrenBuffer[j+1];\n                                    childrenBuffer[j+1] = t;\n                                    sorted = false;\n                                } \n                            }\n                            \n                        } while(!sorted);\n    \n    \n                        //add children to new process buffer \n                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {\n                            \n                            /*var n = childrenBuffer[j].metanode.divisionNode;\n                            if ((n.id[0] == 1 && n.id[1] == 1 && n.id[2] == 0)) {*/\n                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];\n                            newProcessBufferIndex++;\n                            /*}*/\n                            \n                        }\n                    } else {\n                        gpuNeededForRender += size;\n\n                        tile.drawCounter = draw.drawCounter;\n                        drawBuffer[drawBufferIndex] = tile;\n                        drawBufferIndex++;\n                    }\n                    \n                }\n            }\n        }\n\n        var tmp = processBuffer;\n        processBuffer = newProcessBuffer;\n        newProcessBuffer = tmp;\n        processBufferIndex = newProcessBufferIndex;\n\n    } while(processBufferIndex > 0);\n\n    if (storeTilesOnly) {\n        this.storeDrawBufferGeometry(drawBufferIndex);\n        return;\n    }\n    \n    if (best2 > draw.bestMeshTexelSize) {\n        draw.bestMeshTexelSize = best2;\n    }\n\n    var stats = map.stats;\n\n    stats.usedNodes = usedNodes;    \n    stats.processedNodes = pocessedNodes;    \n    stats.processedMetatiles = pocessedMetatiles;    \n    stats.gpuNeeded = gpuNeeded;    \n    \n    //console.log(\"texel: \"+ this.map.bestMeshTexelSize);\n    //console.log(\"more: \"+ more + \"more2: \" + more2);\n\n    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);\n};\n\n\n//loadmode = fitonly\nMapSurfaceTree.prototype.drawSurfaceFitOnly = function(shift, storeTilesOnly) {\n    this.counter++;\n//    this.surfaceTracer.trace(this.surfaceTree);//this.rootId);\n\n    var tile = this.surfaceTree;\n    \n    if (!tile.isMetanodeReady(this, 0)) {\n        return;\n    }\n    \n    var map = this.map;\n    var node = tile.metanode;\n    var cameraPos = map.camera.position;\n\n    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n        return;\n    }\n\n    tile.updateTexelSize();\n    \n    //var typeFactor = this.freeLayerSurface ? 1 : 1;\n    \n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var drawBuffer = draw.drawBuffer;\n    var processBuffer = draw.processBuffer;\n    var newProcessBuffer = draw.processBuffer2;\n    var drawBufferIndex = 0;\n    var processBufferIndex = 0;\n    var newProcessBufferIndex = 0;\n    \n    processBuffer[0] = tile;\n    processBufferIndex = 1;\n\n    var texelSizeFit = draw.texelSizeFit;\n\n    var replay = map.draw.replay;\n    var storeNodes = replay.storeNodes || replay.storeFreeNodes;\n    var storeNodesBuffer = replay.nodeBuffer; \n\n    draw.drawCounter++;\n    \n    var usedNodes = 1;\n    var pocessedNodes = 1;\n    var pocessedMetatiles = 1;  \n    var drawCounter = map.drawCounter, i, j, lj;\n    var grids = false; \n    \n    do {\n        var best = 0;\n        newProcessBufferIndex = 0;\n       \n        for (i = processBufferIndex - 1; i >= 0; i--) {\n            tile = processBuffer[i];\n            node = tile.metanode;\n\n            if (node) {\n                pocessedNodes++;\n                if (node.metatile.drawCounter != drawCounter) {\n                    node.metatile.drawCounter = drawCounter;\n                    pocessedMetatiles++;\n                }\n            }\n\n            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n\n                usedNodes++;\n\n                if (storeNodes) { //used only for inspaector\n                    storeNodesBuffer.push(tile);\n                }\n\n                if (tile.texelSize  != Number.POSITIVE_INFINITY){\n                    if (tile.texelSize > best) {\n                        best = tile.texelSize;\n                    }\n                }\n                \n                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit) {\n                   \n                    tile.drawCounter = draw.drawCounter;\n                    drawBuffer[drawBufferIndex] = tile;\n                    drawBufferIndex++;\n                    \n                } else { //go deeper\n\n                    var childrenCount = 0;\n                    var childrenBuffer = [];\n        \n                    for (j = 0; j < 4; j++) {\n                        var child = tile.children[j];\n                        if (child) {\n                            childrenCount++;\n       \n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize();\n\n                                childrenBuffer.push(child);\n                            }\n                        }\n                    }\n        \n                    if (childrenCount > 0/* && childrenCount == readyCount*/) {\n                        //sort children by distance\n    \n                        do {\n                            var sorted = true;\n                            \n                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {\n                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {\n                                    var t = childrenBuffer[j];\n                                    childrenBuffer[j] = childrenBuffer[j+1];\n                                    childrenBuffer[j+1] = t;\n                                    sorted = false;\n                                } \n                            }\n                            \n                        } while(!sorted);\n    \n                        //add childrn to new process buffer \n                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {\n\n                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];\n                            newProcessBufferIndex++;\n                        }\n                    } else {\n                        tile.drawCounter = draw.drawCounter;\n                        drawBuffer[drawBufferIndex] = tile;\n                        drawBufferIndex++;\n                    }\n                    \n                }\n            }\n        }\n        \n        var tmp = processBuffer;\n        processBuffer = newProcessBuffer;\n        newProcessBuffer = tmp;\n        processBufferIndex = newProcessBufferIndex;\n        \n    } while(processBufferIndex > 0);\n\n    if (storeTilesOnly) {\n        this.storeDrawBufferGeometry(drawBufferIndex);\n        return;\n    }\n\n    var stats = map.stats;\n\n    stats.usedNodes = usedNodes;    \n    stats.processedNodes = pocessedNodes;    \n    stats.processedMetatiles = pocessedMetatiles;    \n\n    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);\n};\n\n\n//loadmode = fit\nMapSurfaceTree.prototype.drawSurfaceFit = function(shift, storeTilesOnly) {\n    this.counter++;\n\n    var tile = this.surfaceTree;\n    \n    if (!tile.isMetanodeReady(this, 0)) {\n        return;\n    }\n    \n    var map = this.map;\n    var node = tile.metanode;\n    var cameraPos = map.camera.position;\n\n    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n        return;\n    }\n\n    tile.updateTexelSize();\n\n    var geodata = tile.surface ? tile.surface.geodata : null;\n    var free = tile.surface ? tile.surface.free : null;\n    var drawGrid = (!geodata && !free && map.config.mapHeightfiledWhenUnloaded);\n    var checkGpu = true;\n    \n    var lodShift = 4;//this.freeLayerSurface ? 1 : 1;\n    var typeFactor = 2000;//this.freeLayerSurface ? 1 : 1;\n\n    if (this.freeLayerSurface) {\n        lodShift = 0;//this.freeLayerSurface ? 1 : 1;\n        typeFactor = 0.1;//this.freeLayerSurface ? 1 : 1;\n    }\n    \n    var draw = map.draw;\n    var drawTiles = draw.drawTiles;\n    var replay = draw.replay;\n    var drawBuffer = draw.drawBuffer;\n    var processBuffer = draw.processBuffer;\n    var newProcessBuffer = draw.processBuffer2;\n    var drawBufferIndex = 0;\n    var processBufferIndex = 0;\n    var newProcessBufferIndex = 0;\n    \n    processBuffer[0] = [tile, 0];\n    processBufferIndex = 1;\n\n    var texelSizeFit = draw.texelSizeFit;\n\n    var storeNodes = replay.storeNodes || replay.storeFreeNodes;\n    var storeNodesBuffer = replay.nodeBuffer; \n\n    draw.drawCounter++;\n    \n    var usedNodes = 1;\n    var pocessedNodes = 1;\n    var pocessedMetatiles = 1;  \n    var drawCounter = draw.drawCounter;\n    var maxHiresLodLevels = map.config.mapMaxHiresLodLevels, i, j, lj, child, priority, parent, parent2, children2;\n    var grids = false; \n    \n    do {\n        var best = 0;\n        newProcessBufferIndex = 0;\n\n        /*if (this.map.drawIndices) {\n            console.log(\"processed begin==============================================\");\n        }*/            \n       \n        for (i = processBufferIndex - 1; i >= 0; i--) {\n            var pack = processBuffer[i];\n            tile = pack[0];\n            var depth = pack[1];\n\n            tile.childrenReadyCount = 0;\n            \n            /*if (this.map.drawIndices) {\n                console.log(JSON.stringify(tile.id));\n            }*/\n            \n            if (depth >= maxHiresLodLevels) {\n                if (drawGrid) {\n                    parent = tile;\n\n                    //make sure that we draw grid with lowest possible detail \n                    parent2 = parent.parent;                    \n\n                    if (parent.id[0] > 3 && depth !=0 && parent2 && parent2.childrenReadyCount == 0) {\n                        children2 = parent2.children;\n\n                        if (!(depth >= 1 && parent.parent && ((children2[0] && children2[0].childrenReadyCount != 0) || \n                             (children2[1] && children2[1].childrenReadyCount != 0) ||\n                             (children2[2] && children2[2].childrenReadyCount != 0) ||\n                             (children2[3] && children2[3].childrenReadyCount != 0)))) {\n                            parent = parent.parent;\n                        }\n                    }\n\n                    //make sure that grid tile is rendered only one time\n                    if (parent.drawCounter != draw.drawCounter && (!parent.parent || parent.parent.drawCounter != draw.drawCounter )) { \n                        parent.drawCounter = draw.drawCounter;\n                        \n                        drawBuffer[drawBufferIndex] = [parent, true]; //draw grid\n                        drawBufferIndex++;\n                        grids = true;\n                    }\n                }\n\n                continue;\n            }\n            \n            node = tile.metanode;\n\n            if (node) {\n                pocessedNodes++;\n                if (node.metatile.drawCounter != drawCounter) {\n                    node.metatile.drawCounter = drawCounter;\n                    pocessedMetatiles++;\n                }\n            }\n\n\n            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {\n\n                usedNodes++;\n\n                if (tile.texelSize  != Number.POSITIVE_INFINITY){\n                    if (tile.texelSize > best) {\n                        best = tile.texelSize;\n                    }\n                }\n\n                if (storeNodes) { //used only for inspaector\n                    storeNodesBuffer.push(tile);\n                }\n                \n                var lastProcessBufferIndex = newProcessBufferIndex;\n                var lastDrawBufferIndex = drawBufferIndex;\n\n                if (!node.hasChildren() || tile.texelSize <= texelSizeFit) {\n\n                    priority = ((tile.id[0] + lodShift) * typeFactor) * tile.distance; \n            \n                    if (node.hasChildren() && !drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, (depth > 0), checkGpu)) {\n\n                        depth++; //we dont have tile ready, so we try to draw more detailed tiles\n\n                        for (j = 0; j < 4; j++) {\n                            child = tile.children[j];\n                            if (child) {\n           \n                                if (child.isMetanodeReady(this, child.id[0], true)) { //lod is used as priority\n\n                                    this.updateNodeHeightExtents(child, child.metanode);\n                                    child.updateTexelSize();\n                                    \n                                    //are draw buffers ready? preventRender=true, preventLoad=false\n                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, (depth > 0), checkGpu)) {\n                                        tile.childrenReadyCount++;\n                                        child.drawCounter = draw.drawCounter;\n                                        \n                                        drawBuffer[drawBufferIndex] = [child, false];\n                                        drawBufferIndex++;\n                                    } else {\n                                        newProcessBuffer[newProcessBufferIndex] = [child, depth];\n                                        newProcessBufferIndex++;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (lastProcessBufferIndex == newProcessBufferIndex && lastDrawBufferIndex == drawBufferIndex) {\n                            depth--; \n                        }\n\n                    } else {\n                        tile.drawCounter = draw.drawCounter;\n\n                        drawBuffer[drawBufferIndex] = [tile, false];\n                        drawBufferIndex++;\n                    }\n                    \n                } else if (depth == 0 && node.hasGeometry() && tile.texelSize <= (texelSizeFit * 2)) {\n                    \n                    //are all children ready? if not then draw carser lod\n                    var childrenCount = 0;\n                    var readyCount = 0;\n                    var childrenBuffer = [];\n        \n                    for (j = 0; j < 4; j++) {\n                        child = tile.children[j];\n                        if (child) {\n                            childrenCount++;\n       \n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize();\n                                \n                                priority = ((child.id[0] + lodShift) * typeFactor) * child.distance; \n                               \n                                //are draw buffers ready? preventRender=true, preventLoad=true\n                                if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, true, checkGpu)) {\n                                    readyCount++;\n                                    childrenBuffer.push(child);\n                                }\n                            }\n                        }\n                    }\n        \n                    if (childrenCount > 0 && childrenCount == readyCount) {\n                        //sort children by distance\n    \n                        do {\n                            var sorted = true;\n                            \n                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {\n                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {\n                                    var t = childrenBuffer[j];\n                                    childrenBuffer[j] = childrenBuffer[j+1];\n                                    childrenBuffer[j+1] = t;\n                                    sorted = false;\n                                } \n                            }\n                            \n                        } while(!sorted);\n    \n                        //add children to new process buffer \n                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {\n                            newProcessBuffer[newProcessBufferIndex] = [childrenBuffer[j], depth];\n                            newProcessBufferIndex++;\n                        }\n                    } else {\n                        \n                        //can i use coarser lod\n                        priority = ((tile.id[0] + lodShift) * typeFactor) * tile.distance; \n\n                        if (drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, true, checkGpu)) {\n                            tile.drawCounter = draw.drawCounter;\n\n                            drawBuffer[drawBufferIndex] = [tile, false];\n                            drawBufferIndex++;\n\n                            for (j = 0; j < 4; j++) {\n                                child = tile.children[j];\n                                if (child) {\n                                    if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                        priority = ((child.id[0] + lodShift) * typeFactor) * child.distance; \n                                        drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, checkGpu);\n                                    }\n                                }\n                            }\n\n                        } else {\n\n                            //add children to new process buffer \n                            for (j = 0; j < 4; j++) {\n                                child = tile.children[j];\n                                if (child) {\n                                    if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                        this.updateNodeHeightExtents(child, child.metanode);\n                                        child.updateTexelSize();\n\n                                        newProcessBuffer[newProcessBufferIndex] = [child, depth];\n                                        newProcessBufferIndex++;\n                                    }\n                                }\n                            }\n\n                        } \n                    }\n\n                }  else  {  //go deeper\n                    \n                    \n                    for (j = 0; j < 4; j++) {\n                        child = tile.children[j];\n                        if (child) {\n\n                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority\n                                this.updateNodeHeightExtents(child, child.metanode);\n                                child.updateTexelSize();\n                                \n                                newProcessBuffer[newProcessBufferIndex] = [child, depth];\n                                newProcessBufferIndex++;\n                            }\n                        }\n                    }                    \n                }\n            }\n\n\n            if (drawGrid && lastProcessBufferIndex == newProcessBufferIndex && lastDrawBufferIndex == drawBufferIndex) {\n                parent = tile;\n\n                //make sure that we draw grid with lowest possible detail \n                parent2 = parent.parent;                    \n\n                if (parent.id[0] > 3 && depth !=0 && parent2 && parent2.childrenReadyCount == 0) {\n                    children2 = parent2.children;\n\n                    if (!(depth >= 1 && parent.parent && ((children2[0] && children2[0].childrenReadyCount != 0) || \n                         (children2[1] && children2[1].childrenReadyCount != 0) ||\n                         (children2[2] && children2[2].childrenReadyCount != 0) ||\n                         (children2[3] && children2[3].childrenReadyCount != 0)))) {\n                        parent = parent.parent;\n                    }\n                }\n\n                //make sure that grid tile is rendered only one time\n                if (parent && parent.drawCounter != draw.drawCounter) { \n                    parent.drawCounter = draw.drawCounter;\n\n                    drawBuffer[drawBufferIndex] = [parent, true]; //draw grid\n                    drawBufferIndex++;\n                    grids = true;\n                }\n            }\n\n        }\n\n        /*if (this.map.drawIndices) {\n            console.log(\"processed end==============================================\");\n        }*/\n        \n        var tmp = processBuffer;\n        processBuffer = newProcessBuffer;\n        newProcessBuffer = tmp;\n        processBufferIndex = newProcessBufferIndex;\n        \n    } while(processBufferIndex > 0);\n\n    if (storeTilesOnly) {\n        this.storeDrawBufferGeometry(drawBufferIndex);\n        return;\n    }\n\n    var stats = map.stats;\n\n    stats.usedNodes = usedNodes;    \n    stats.processedNodes = pocessedNodes;    \n    stats.processedMetatiles = pocessedMetatiles;    \n\n    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex);\n};\n\nMapSurfaceTree.prototype.processDrawBuffer = function(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex, noGrid) {\n\n    if (replay.storeTiles || replay.storeFreeTiles) { //used only in inspectors\n        if (!draw.tileBuffer[0]) {\n            draw.tileBuffer[0] = [];\n        }\n        \n        var tiles = draw.tileBuffer[0];\n        for (i = drawBufferIndex - 1; i >= 0; i--) {\n            tiles.push(drawBuffer[i]);\n        }\n    }\n\n    var scanExtents = (!this.freeLayerSurface && map.config.mapFeatureStickMode[0] == 2); // && this.freeLayerSurface.geodata && draw.drawChannel == 0);\n    var hmax = -999999, hmin = 999999;\n    var renderer = map.renderer;\n    var mvp = this.camera.getMvpMatrix(), p1, p2, camVec, length, tilt, factor, i, tile, node; \n\n    map.gpuCache.skipCostCheck = true;\n\n    var underSurfaceGrid = (drawGrid && map.config.mapGridUnderSurface > 0 && grids);\n    \n    if (underSurfaceGrid) {\n        //draw only grid\n        for (i = drawBufferIndex - 1; i >= 0; i--) {\n            drawBuffer[i][0].drawGrid(cameraPos); \n        }\n\n        //clear zbuffer\n        map.renderer.gpu.clear(true, false);\n    }\n\n    //draw surface\n    for (i = drawBufferIndex - 1; i >= 0; i--) {\n        var item = drawBuffer[i];\n        tile = (noGrid) ? item : item[0];\n        node = tile.metanode;\n\n        if (scanExtents && node) {\n            // TODO noramlize by distance and tilt\n\n            p2 = node.diskPos;\n            p1 = renderer.cameraPosition;\n            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            length = vec3.normalize4(camVec);\n            tilt = -vec3.dot(camVec, node.diskNormal);\n\n            if (tilt < 0) {\n                tilt = 0;\n            }\n\n            tilt = 1 - tilt;\n\n            factor = (renderer.camera.fovDist / length) * tilt;\n            //renderer.camera.scaleFactor2(d) * screenPixelSize\n            //pp = this.renderer.project2(tile.diskPos, mvp);                \n\n            if (node.minZ * factor < hmin) {\n                hmin = node.minZ * factor;\n            }\n\n            if (node.maxZ * factor > hmax) {\n                hmax = node.maxZ * factor;\n            }\n        }\n\n\n        if (noGrid)  {\n\n            if (stats.gpuRenderUsed >= draw.maxGpuUsed)  {\n                break;\n            }\n\n            //draw tile,  preventRender=false, preventLoad=false\n            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false);\n\n        } else {\n\n            if (underSurfaceGrid) {\n\n                if (!item[1] && !(stats.gpuRenderUsed >= draw.maxGpuUsed))  {\n                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false /*, checkGpu*/);\n                } else {\n                    if (drawTiles.debug.drawBBoxes) {\n                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);\n                    }\n                }\n\n            } else {\n\n                if ((drawGrid && item[1]) || stats.gpuRenderUsed >= draw.maxGpuUsed)  {\n\n                    if (drawTiles.debug.drawBBoxes) {\n                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);\n                    }\n\n                    tile.drawGrid(cameraPos); \n                } else if (!item[1]) {\n                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false /*, checkGpu*/);\n                }\n            }\n\n        }\n    }\n\n    if (scanExtents) {\n        renderer.gridHmax = hmax;\n        renderer.gridHmin = hmin;\n    }\n\n    map.gpuCache.skipCostCheck = false;\n    map.gpuCache.checkCost();\n\n};\n\nMapSurfaceTree.prototype.storeDrawBufferGeometry = function(drawBufferIndex) {\n    var map = this.map;\n    var drawBuffer = map.draw.drawBuffer;\n\n    this.storeGeometry(drawBuffer, drawBufferIndex);\n};\n\n\nMapSurfaceTree.prototype.storeGeometry = function(array, length) {\n    var map = this.map;\n    var drawBuffer = array;\n    map.storedTilesRes = new Array(length);        \n\n    for (var i = length - 1; i >= 0; i--) {\n        var tile = drawBuffer[i];\n\n        if (tile.metanode && tile.surface && tile.metanode.hasGeometry() &&\n            tile.surfaceMesh && tile.surfaceMesh.isReady(true, 0, true)) {\n\n            var mesh = tile.surfaceMesh;\n            var submeshes = [];\n\n            for (var j = 0, lj = mesh.submeshes.length; j < lj; j++) {\n                var submesh = mesh.submeshes[j],\n                    vertices = submesh.vertices.slice(),\n                    min = submesh.bbox.min,\n                    max = submesh.bbox.max,\n                    delta = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n\n                for (var k = 0, lk = vertices.length; k < lk; k+=3) {\n                    vertices[k] = vertices[k]*delta[0] + min[0];\n                    vertices[k+1] = vertices[k+1]*delta[1] + min[1];\n                    vertices[k+2] = vertices[k+2]*delta[2] + min[2];\n                }\n\n                submeshes.push({ \n                    \"bbox\": [min.slice(), max.slice()],\n                    \"vertices\" : vertices });\n            }\n\n            map.storedTilesRes[i] = {\n                \"id\": tile.id.slice(),\n                \"type\": \"mesh\",\n                \"submeshes\": submeshes\n            };\n        }\n    }\n};\n\nMapSurfaceTree.prototype.traceHeight = function(tile, params, nodeOnly) {\n    if (!tile) {\n        return;\n    }\n\n    this.params = params;\n\n    var heightFunction = nodeOnly ? this.traceHeightTileByNodeOnly : this.traceHeightTileByMap;  \n\n    if (tile.id[0] == 1) { //update root, get height in VTS2015 starts in division node which has lod 1\n        this.traceHeightTile(tile.parent, 0, true);\n        if (!tile.parent.metanode) {\n            return;\n        }\n    }\n    \n    this.traceHeightTile(tile, 0, false, heightFunction);\n};\n\n\nMapSurfaceTree.prototype.traceHeightTile = function(tile, priority, nodeReadyOnly, heightFunction) {\n    if (tile == null) {\n        return;\n    }\n\n    if (!tile.isMetanodeReady(this, 0) || nodeReadyOnly) {\n        this.params.waitingForNode = true;\n        return;\n    }\n\n    tile.metanode.metatile.used();\n\n    if (tile.lastSurface && tile.lastSurface == tile.surface) {\n        tile.lastSurface = null;\n        tile.restoreLastState();\n        //return;\n    }\n    \n    //process tile e.g. draw or get height\n    var res = heightFunction(tile, this.params, priority); \n    \n    if (res) { //we need to go deeper\n        var childIndex = this.traceHeightChild(tile, this.params);\n        var child = tile.children[childIndex];\n        \n        if (!child) {\n            this.params.finalNode = true;\n        }\n\n        this.traceHeightTile(child, 0, false, heightFunction);\n    }\n};\n\n\nMapSurfaceTree.prototype.traceHeightChild = function(tile, params) {\n    var coords = params.coords;\n    var extents = params.extents;\n    var center = [(extents.ll[0] + extents.ur[0]) *0.5,\n        (extents.ll[1] + extents.ur[1]) *0.5];\n\n    //ul,ur,ll,lr\n    //deside in which quadrant are provided coodinates\n    var right = (coords[0] >= center[0]);\n    var bottom = (coords[1] >= center[1]);\n\n    if (right) {\n        extents.ll[0] = center[0];\n        if (bottom) {\n            extents.ll[1] = center[1];\n        } else {\n            extents.ur[1] = center[1];\n        }\n    } else {\n        extents.ur[0] = center[0];\n        if (bottom) {\n            extents.ll[1] = center[1];\n        } else {\n            extents.ur[1] = center[1];\n        }\n    }\n\n    /*\n    if (extents.ll[0] > extents.ur[0]) {\n        right = !right;\n    }\n\n    if (extents.ll[1] < extents.ur[1]) {\n        bottom = !bottom;\n    }*/\n\n    //trace only resulting quadrant \n    if (right) {\n        return bottom ? 1 : 3;\n    } else {\n        return bottom ? 0 : 2;\n    }\n};\n\n\nMapSurfaceTree.prototype.traceHeightTileByMap = function(tile, params) {\n    if (!tile || (tile.id[0] > params.desiredLod && params.heightMap)) {\n        return false;\n    }\n\n    var node = tile.metanode;\n\n    if (!node) {\n        return false;\n    }\n\n    if (node.hasNavtile()) {\n        params.bestHeightMap = tile.id[0];\n\n        if (!tile.heightMap) {\n            //if (!preventLoad) {\n                //if (!tile.surface || tile.surface.virtual) {\n            if (!tile.surface || !tile.resourceSurface) { //surface.virtual) {\n                return false; //is it best way how to do it?\n            }\n                \n            if (!tile.resourceSurface.getNavUrl) { //virtual surface is as resource surface. Is it bug??!!\n                return false; //is it best way how to do it?\n            }\n                \n            var path = tile.resourceSurface.getNavUrl(tile.id);\n            tile.heightMap = tile.resources.getTexture(path, true);\n            //}\n        } else {\n            if (tile.heightMap.isReady(null, null, true)) {\n                params.parent = {\n                    metanode : params.metanode,\n                    heightMap : params.heightMap,\n                    heightMapExtents : params.heightMapExtents\n                };\n                \n                params.metanode =  node;\n                params.heightMap = tile.heightMap;\n                params.heightMapExtents = {\n                    ll : params.extents.ll.slice(),\n                    ur : params.extents.ur.slice()\n                };\n                return (tile.id[0] != params.desiredLod);\n            }\n        }\n    } else {\n        if (!params.heightMap) {\n            params.metanode =  node;\n        }\n        \n        return true;\n    }\n\n    return false;\n};\n\n\nMapSurfaceTree.prototype.traceHeightTileByNodeOnly = function(tile, params) {\n    if (!tile || tile.id[0] > params.desiredLod) {\n        return false;\n    }\n\n    var node = tile.metanode;\n\n    if (!node) {\n        return false;\n    }\n\n    params.parent = {\n        metanode : params.metanode\n    };\n\n    params.metanode =  node;\n    return (tile.id[0] != params.desiredLod);\n};\n\n\nMapSurfaceTree.prototype.getNodeById = function(id, preventLoad) {\n    var tile = this.surfaceTree;\n\n    if (tile == null) {\n        return;\n    }\n\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        if (!tile.children[index]) {\n\n            if (!tile.isMetanodeReady(this, 0, preventLoad)) {\n                return null;\n            }\n\n            if (!tile.metanode.hasChild(index)) {\n                return null;\n            }\n\n            tile.addChild(index);\n        } \n\n        tile = tile.children[index];\n    }\n\n    if (!tile) {\n        return;\n    }\n\n    if (!tile.isMetanodeReady(this, 0, preventLoad)) {\n        return;\n    }\n\t\n    var node = tile.metanode;\n    tile.metanode.metatile.used();\n\n    return node;\n\n\t/*\n    if (tile.lastSurface && tile.lastSurface == tile.surface) {\n        tile.lastSurface = null;\n        tile.restoreLastState();\n        //return;\n    }*/\n};\n\nMapSurfaceTree.prototype.getRenderedNodeById = function(id, drawCounter) {\n    var tile = this.surfaceTree;\n\n    if (tile == null) {\n        return;\n    }\n\n    if (tile.drawCounter == drawCounter) {\n        if (!tile.isMetanodeReady(this, 0)) {\n            return;\n        }\n\n        return tile.metanode;\n    }\n\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        if (!tile.children[index]) {\n\n            if (!tile.isMetanodeReady(this, 0)) {\n                return;\n            }\n\n            if (!tile.metanode.hasChild(index)) {\n                return;\n            }\n        } \n\n        tile = tile.children[index];\n\n        if (tile.drawCounter == drawCounter) {\n            if (!tile.isMetanodeReady(this, 0)) {\n                return;\n            }\n\n            return tile.metanode;\n        } else {\n            if (lod == 1) { //rendered lod is probably from more detailed lod so we take one which is from same lod\n                return tile.metanode;\n            }\n        }\n    }\n\n    return;\n};\n\n\nMapSurfaceTree.prototype.chekTileMesh = function(tile) {\n    if (this.params.loadMeshes || this.params.loadTextures) {\n\n        var tmp = this.config.mapNoTextures;\n        this.config.mapNoTextures = !this.params.loadTextures;\n\n        //are resources ready? priority=0, preventRender=true, preventLoad=false, doNotCheckGpu=true\n        if (!this.map.draw.drawTiles.drawSurfaceTile(tile, tile.metanode, this.map.renderer.cameraPosition, tile.texelSize, 0, true, false, true)) {\n            this.params.loaded = false;\n        }\n\n        this.config.mapNoTextures = tmp;\n    }\n};\n\n\nMapSurfaceTree.prototype.traceAreaTiles = function(tile, priority, nodeReadyOnly) {\n    if (tile == null) {\n        return;\n    }\n\n    if (!tile.isMetanodeReady(this, 0) || nodeReadyOnly) {\n        this.params.loaded = false;\n        //console.log('(L)' + JSON.stringify(tile.id));\n        tile.isMetanodeReady(this, 0);\n        return;\n    }\n\n    tile.metanode.metatile.used();\n\n    if (tile.lastSurface && tile.lastSurface == tile.surface) {\n        tile.lastSurface = null;\n        tile.restoreLastState();\n        //return;\n    }\n\n    if (!tile.insideCone(this.params.coneVec, this.params.coneAngle, tile.metanode)) {\n        return;\n    }\n\n    var fit = (this.params.mode == 'lod') ? (tile.id[0] >= this.params.limit) : (tile.metanode.pixelSize <= this.params.limit);\n\n    if (fit) {\n        //console.log('(A)' + JSON.stringify(tile.id));\n        this.chekTileMesh(tile);\n        this.params.areaTiles.push(tile);\n        return;\n    }\n\n    if (!tile.metanode.hasChildren()) {\n        //console.log('(A)' + JSON.stringify(tile.id));\n        this.chekTileMesh(tile);\n        this.params.areaTiles.push(tile);\n    } else {\n        for (var i = 0; i < 4; i++) {\n            this.traceAreaTiles(tile.children[i], priority, nodeReadyOnly);\n        }\n    }\n};\n\n\n\nexport default MapSurfaceTree;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/surface-tree.js\n// module id = 53\n// module chunks = 0 1","import MapCredit_ from './credit';\nimport MapStylesheet_ from './stylesheet';\nimport MapSurfaceTree_ from './surface-tree';\nimport BBox_ from '../renderer/bbox';\nimport {utils as utils_} from '../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../utils/url';\n\n//get rid of compiler mess\nvar MapCredit = MapCredit_;\nvar MapStylesheet = MapStylesheet_;\nvar MapSurfaceTree = MapSurfaceTree_;\nvar BBox = BBox_;\nvar utils = utils_;\nvar utilsUrl = utilsUrl_;\n\n\nvar MapSurface = function(map, json, type) {\n    this.map = map;\n    this.id = null;\n    this.type = 'basic';\n    this.metaBinaryOrder = 1;\n    this.metaUrl = '';\n    this.navUrl = '';\n    this.navDelta = 1;\n    this.meshUrl = '';\n    this.textureUrl = '';\n    this.baseUrl = this.map.url.baseUrl;\n    this.baseUrlSchema = this.map.url.baseUrlSchema;\n    this.baseUrlOrigin = this.map.url.baseUrlOrigin;\n    this.lodRange = [0,0];\n    this.tileRange = [[0,0],[0,0]];\n    this.textureLayer = null;\n    this.boundLayerSequence = [];\n    this.glue = (type == 'glue');\n    this.free = (type == 'free');\n    this.virtual = false;\n    this.zFactor = 0;\n    this.ready = false;\n    this.geodataProcessor = null;\n    this.geodataCounter = 0;\n    this.geodataNavtileInfo = false;\n    this.monoGeodata = null;\n    this.monoGeodataView = null;\n    this.monoGeodataCounter = -1;\n    this.creditsNumbers = [];\n    \n    this.style = null;\n    this.stylesheet = null;\n    this.originalStyle = null;\n    this.originalStylesheet = null;\n    this.styleChanged = true;\n    \n    if (this.free) { //each free layer has its own data tree\n        this.tree = new MapSurfaceTree(this.map, true, this);\n    } else {\n        this.tree = null;\n    }\n    \n    if (typeof json === 'string') {\n        this.jsonUrl = this.map.url.processUrl(json);\n        this.baseUrl = utilsUrl.getBase(this.jsonUrl);\n        this.baseUrlSchema = utilsUrl.getSchema(this.jsonUrl);\n        this.baseUrlOrigin = utilsUrl.getOrigin(this.jsonUrl);\n        \n        var onLoaded = (function(data){\n            this.parseJson(data);            \n            this.ready = true;\n            this.map.refreshView();\n        }).bind(this);\n        \n        var onError = (function(){ }).bind(this);\n\n        utils.loadJSON(this.jsonUrl, onLoaded, onError, null,(utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n        //utils.loadJSON(this.url, onLoaded, onError, null, utils.useCredentials);\n    } else {\n        this.parseJson(json);\n        this.ready = true;\n    }\n};\n\n\nMapSurface.prototype.parseJson = function(json) {\n    this.id = json['id'] || null;\n    this.type = json['type'] || 'basic';\n    this.metaBinaryOrder = json['metaBinaryOrder'] || 1;\n    this.metaUrl = this.processUrl(json['metaUrl'], '');\n    this.navUrl = this.processUrl(json['navUrl'], '');\n    this.hmapUrl = this.processUrl(json['hmapUrl'], json['navUrl'] + '00');\n    //this.cmapUrl = this.processUrl(json['cmapUrl'], '');\n    this.pipeline = this.map.config.mapForcePipeline ? this.map.config.mapForcePipeline : (json['pipeline']); // || VTS_PIPELINE_HMAP);//VTS_PIPELINE_BASIC);\n    //this.pipeline = json['pipeline'] || VTS_PIPELINE_BASIC;\n    this.navDelta = json['navDelta'] || 1;\n    this.meshUrl = this.processUrl(json['meshUrl'], '');\n    this.textureUrl = this.processUrl(json['textureUrl'], '');\n    this.geodataUrl = this.processUrl(json['geodataUrl'] || json['geodata'], '');\n    this.lodRange = json['lodRange'] || [0,0];\n    this.tileRange = json['tileRange'] || [[0,0],[0,0]];\n    this.textureLayer = json['textureLayer'] || null;\n    this.geodata = (this.type == 'geodata' || this.type == 'geodata-tiles');\n    this.credits = json['credits'] || [];\n    this.creditsUrl = null;\n    this.displaySize = json['displaySize'] || 256;\n\n    var i, li;\n    \n    if (json['extents']) {\n        var ll = json['extents']['ll'];\n        var ur = json['extents']['ur'];\n        this.extents = new BBox(ll[0], ll[1], ll[2], ur[0], ur[1], ur[2]);\n    } else {\n        this.extents = new BBox(0,0,0,1,1,1);\n    }\n\n    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    \n    \n    switch(typeof this.credits) {\n    case 'string':\n        this.creditsUrl = this.credits;\n        this.credits = [];\n        break;\n\n    case 'object':\n        \n        if (!Array.isArray(this.credits)) {\n            var credits = this.credits;\n            this.credits = [];\n                \n            for (var key in credits){\n                this.map.addCredit(key, new MapCredit(this.map, credits[key]));\n                this.credits.push(key);\n            }\n        }\n\n        for (i = 0, li = this.credits.length; i < li; i++) {\n            var credit = this.map.getCreditById(this.credits[i]);\n            this.creditsNumbers.push(credit ? credit.id : null); \n        }\n        \n        break;\n    }    \n\n\n    if (this.geodataUrl && (typeof this.geodataUrl === 'string') && this.geodataUrl.indexOf('{geonavtile}') != -1) {\n        //this.geodataNavtileInfo = true;\n        this.geodataNavtileInfo = false;\n    }\n\n    //load stylesheet\n    if (this.geodata) {\n        var style = json['style'];\n        this.originalStyle = style;\n        \n        if (style) {\n            this.setStyle(style);\n            this.originalStylesheet = this.stylesheet;\n        }\n    }\n\n    this.surfaceReference = [];\n    if (this.glue) {\n        for (i = 0, li = this.id.length; i < li; i++) {\n            this.surfaceReference.push(this.map.getSurface(this.id[i]));\n        }\n    }\n};\n\n\nMapSurface.prototype.kill = function() {\n    if (this.geodataProcessor) {\n        this.geodataProcessor.kill();\n        this.geodataProcessor = null;\n    }\n\n    this.geodataUrl = null;\n    this.style = null;\n    this.stylesheet = null;\n    this.originalStyle = null;\n    this.originalStylesheet = null;\n};\n\n\nMapSurface.prototype.setOptions = function() {\n};\n\n\nMapSurface.prototype.getOptions = function() {\n    return this.getInfo();\n};\n\n\nMapSurface.prototype.getInfo = function() {\n    if (this.geodata) {\n        return {\n            'type' : this.type,\n            'metaUrl' : this.metaUrl,\n            'geodataUrl' : this.geodataUrl,\n            'lodRange' : this.lodRange,\n            'tileRange' : this.tileRange,\n            'style' : this.originalStyle\n        };\n    } else {\n        return {\n            'type' : this.type,\n            'metaUrl' : this.metaUrl,\n            'navUrl' : this.navUrl,\n            'meshUrl' : this.meshUrl,\n            'textureUrl' : this.textureUrl,\n            'lodRange' : this.lodRange,\n            'tileRange' : this.tileRange,\n            'textureLayer' : this.textureLayer\n        };\n    }\n};\n\n\nMapSurface.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n\n    if (typeof url !== 'string') {\n        return url;\n    }\n\n    url = url.trim();\n    \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.baseUrlOrigin + url;\n    } else {  //relative\n        return this.baseUrl + url; \n    }\n};\n\n\nMapSurface.prototype.hasTile = function(id) {\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift < 0) {\n        return false;\n    }\n\n    var x = id[1] >> shift;\n    var y = id[2] >> shift;\n\n    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||\n        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n        return false;\n    }\n\n    return true;\n};\n\n\nMapSurface.prototype.hasTile2 = function(id) {\n    var shift = id[0] - this.lodRange[0];\n    var above = (shift < 0);\n\n    if (id[0] < this.lodRange[0]) {\n        shift = -shift;\n        var x1 = this.tileRange[0][0] >> shift;\n        var y1 = this.tileRange[0][1] >> shift;\n        var x2 = this.tileRange[1][0] >> shift;\n        var y2 = this.tileRange[1][1] >> shift;\n    \n        if (id[0] > this.lodRange[1] ||\n            id[1] < x1 || id[1] > x2 ||\n            id[2] < y1 || id[2] > y2 ) {\n            return [false , false];\n        }\n    } else {\n        var x = id[1] >> shift;\n        var y = id[2] >> shift;\n    \n        if (id[0] > this.lodRange[1] ||\n            x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n            return [false , false];\n        }\n    }\n\n    return [true, above];\n};\n\n\nMapSurface.prototype.hasMetatile = function(id) {\n    if (id[0] > this.lodRange[1]) {\n        return false;\n    }\n\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift >= 0) {\n        var x = id[1] >> shift;\n        var y = id[2] >> shift;\n\n        if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n            return false;\n        }\n    } else {\n        shift = -shift;\n\n        if (id[1] < (this.tileRange[0][0]>>shift) || id[1] > (this.tileRange[1][0]>>shift) ||\n            id[2] < (this.tileRange[0][1]>>shift) || id[2] > (this.tileRange[1][1]>>shift) ) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\nMapSurface.prototype.setStyle = function(style) {\n    if (this.style == style) {\n        return;\n    }\n\n    var id = style;\n\n    if (typeof id !== 'object') {\n        id = this.processUrl(id, '');\n    } else {\n        id = JSON.stringify(id);\n        id = utils.getHash(id);\n        id = \"#obj#\" + id.toString(16); \n    }\n    \n    this.stylesheet = this.map.getStylesheet(id);\n    \n    if (!this.stylesheet) {\n        this.stylesheet = new MapStylesheet(this.map, id, style, this);\n        this.map.addStylesheet(id, this.stylesheet); \n    } \n\n    this.style = style;\n    this.styleChanged = true;\n    this.geodataCounter++;\n\n    //this.map.setStylesheetData(id); //force update\n    \n    this.map.markDirty();\n};\n\n\n//used only for glues\nMapSurface.prototype.getSurfaceReference = function(index) {\n    return this.surfaceReference[index - 1];\n};\n\n\nMapSurface.prototype.getMetaUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getNavUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.navUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getHMapUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.hmapUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\nMapSurface.prototype.getMeshUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.meshUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getTextureUrl = function(id, subId, skipBaseUrl) {\n    return this.map.url.makeUrl(this.textureUrl, {lod:id[0], ix:id[1], iy:id[2] }, subId, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getGeodataUrl = function(id, navtileStr, skipBaseUrl) {\n//    return this.map.makeUrl(this.geodataUrl + \"&v=1\", {lod:id[0], ix:id[1], iy:id[2] }, navtileStr, skipBaseUrl);\n    return this.map.url.makeUrl(this.geodataUrl, {lod:id[0], ix:id[1], iy:id[2] }, navtileStr, skipBaseUrl);\n};\n\n\nMapSurface.prototype.getMonoGeodataUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.geodataUrl, {}, null, skipBaseUrl);\n};\n\n\nexport default MapSurface;\n\n\n\n  \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/surface.js\n// module id = 54\n// module chunks = 0 1","\nimport MapSubtexture_ from './subtexture';\n\n//get rid of compiler mess\nvar MapSubtexture = MapSubtexture_;\n\n\nvar MapTexture = function(map, path, type, extraBound, extraInfo, tile, internal) {\n    this.map = map;\n    this.stats = map.stats;\n    this.tile = tile; // used only for stats\n    this.internal = internal; // used only for stats\n    \n    if (tile) {\n        this.mainTexture = tile.resources.getSubtexture(this, path, type, tile, internal); \n    } else {\n        this.mainTexture = new MapSubtexture(map, path, type, tile, internal); \n    }\n\n    this.maskTexture = null; \n\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.neverReady = false;\n    this.maskTexture = null;\n    this.mapLoaderUrl = path;\n    this.type = type || VTS_TEXTURETYPE_COLOR;\n    this.extraBound = extraBound;\n    this.extraInfo = extraInfo;\n    this.statsCounter = 0;\n    this.checkStatus = 0;\n    this.checkType = null;\n    this.checkValue = null;\n    this.fastHeaderCheck = false;\n    this.fileSize = 0;\n\n    if (extraInfo && extraInfo.layer) {\n        var layer = extraInfo.layer;\n        \n        if (layer.availability) {\n            this.checkType = layer.availability.type;\n            switch (this.checkType) {\n            case VTS_TEXTURECHECK_TYPE: this.checkValue = layer.availability.mime; break;\n            case VTS_TEXTURECHECK_CODE: this.checkValue = layer.availability.codes; break;\n            case VTS_TEXTURECHECK_SIZE: this.checkValue = layer.availability.size; break;\n            }\n        }       \n    }\n};\n\n\nMapTexture.prototype.kill = function() {\n    this.mainTexture.killImage();\n    this.mainTexture.killGpuTexture();\n    this.mainTexture = null;\n    \n    if (this.maskTexture) {\n        this.maskTexture.killImage(); \n        this.maskTexture.killGpuTexture(); \n    }\n};\n\n\nMapTexture.prototype.killImage = function() {\n    this.mainTexture.killImage();\n\n    if (this.maskTexture) {\n        this.maskTexture.killImage(); \n    }\n};\n\n\nMapTexture.prototype.killGpuTexture = function() {\n    this.mainTexture.killGpuTexture();\n\n    if (this.maskTexture) {\n        this.maskTexture.killGpuTexture(); \n    }\n};\n\n\nMapTexture.prototype.setBoundTexture = function(tile, layer, hmap) {\n    if (tile) {\n        if (hmap) {\n            this.extraBound.sourceTile = tile;\n            this.extraBound.hmap = hmap;\n\n            if (!tile.hmap) {\n                var path = tile.resourceSurface.getHMapUrl(tile.id, true);\n                tile.hmap = tile.resources.getTexture(path, null, null, {tile: tile, hmap: hmap}, this.tile, this.internal);\n            }\n\n            this.extraBound.texture = tile.hmap; \n\n        } else if (layer) {\n            this.extraBound.sourceTile = tile;\n            this.extraBound.layer = layer;\n            \n            if (!tile.boundTextures[layer.id]) {\n                tile.boundLayers[layer.id] = layer;\n                var path = layer.getUrl(tile.id);\n                tile.boundTextures[layer.id] = tile.resources.getTexture(path, null, null, {tile: tile, layer: layer}, this.tile, this.internal);\n            }\n\n            this.extraBound.texture = tile.boundTextures[layer.id]; \n        }\n        \n        this.extraBound.transform = this.map.draw.drawTiles.getTileTextureTransform(tile, this.extraBound.tile);\n        this.map.markDirty();\n    }\n};\n\n\nMapTexture.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n/*   \n   if (this.mapLoaderUrl == \"https://ecn.t3.tiles.virtualearth.net/tiles/a1202310323212333.jpeg?g=5549\") {\n       this.mapLoaderUrl = this.mapLoaderUrl;\n   }\n*/\n    if (this.neverReady) {\n        return false;\n    }\n\n    var parent;\n   \n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            while (this.extraBound.texture.extraBound || this.extraBound.texture.checkStatus == -1) {\n//            while (this.extraBound.texture.checkStatus == -1) {\n                parent = this.extraBound.sourceTile.parent;\n\n                if (this.extraBound.hmap) {\n                    if (!parent || parent.id[0] < 1) {\n                        this.neverReady = true;\n                        this.extraBound.tile.resetDrawCommands = true;\n                        this.map.markDirty();\n                        return false;\n                    }\n                } else if (this.extraBound.layer) {\n                    if (parent.id[0] < this.extraBound.layer.lodRange[0]) {\n                        this.neverReady = true;\n                        this.extraBound.tile.resetDrawCommands = true;\n                        this.map.markDirty();\n                        return false;\n                    }\n                }\n \n                this.setBoundTexture(parent, this.extraBound.layer);\n            }\n            \n            var ready = this.extraBound.texture.isReady(doNotLoad, priority, doNotCheckGpu);\n            \n            if (ready && this.checkMask) {\n                this.extraBound.tile.resetDrawCommands = (this.extraBound.texture.getMaskTexture() != null);\n                this.checkMask = false;\n            }\n\n            return ready;\n            \n        } else {\n            this.setBoundTexture(this.extraBound.sourceTile, this.extraBound.layer, this.extraBound.hmap);        \n            return this.isReady(doNotLoad, priority, doNotCheckGpu);\n        }\n        \n        return false;\n    }\n\n    /*\n    if (!this.extraBound && this.extraInfo && !this.maskTexture) {\n        var layer = this.extraInfo.layer;\n        \n        if (layer && layer.maskUrl && this.checkType != \"metatile\") {\n            var path = layer.getMaskUrl(this.tile.id);\n            this.maskTexture = this.tile.resources.getTexture(path, null, null, null, this.tile, this.internal);\n        }\n    }*/\n\n    switch (this.checkType) {\n    case VTS_TEXTURECHECK_MEATATILE:\n\n        if (this.checkStatus != 2) {\n            if (this.checkStatus == 0) {\n                if (this.extraInfo && this.extraInfo.tile) {\n                    var metaresources = this.extraInfo.tile.boundmetaresources;\n                    if (!metaresources) {\n                        metaresources = this.map.resourcesTree.findAgregatedNode(this.extraInfo.tile.id, 8);\n                        this.extraInfo.tile.boundmetaresources = metaresources;\n                    }\n                        \n                    var layer = this.extraInfo.layer;\n                    var path = this.extraInfo.metaPath;\n\t\t\t\t\t\t\n                    if(!this.extraInfo.metaPath) {\n                        path = layer.getMetatileUrl(metaresources.id);\t\n                        this.extraInfo.metaPath = path;\n                    }\n\t\t\t\t\t\t\n                    var texture = metaresources.getTexture(path, true, null, null, this.tile, this.internal);\n                        \n                    if (this.maskTexture) {\n                        if (this.maskTexture.isReady(doNotLoad, priority, doNotCheckGpu, this)) {\n                            this.checkStatus = 2;\n                        }\n                    } else {\n                        if (texture.isReady(doNotLoad, priority, doNotCheckGpu)) {\n                            var tile = this.extraInfo.tile;\n                            var value = texture.getHeightMapValue(tile.id[1] & 255, tile.id[2] & 255);\n                            this.checkStatus = (value & 128) ? 2 : -1;\n                                \n                            if (this.checkStatus == 2) {\n                                if (!(value & 64)) { //load mask\n                                    path = layer.getMaskUrl(tile.id);\n                                    this.maskTexture = tile.resources.getTexture(path, null, null, null, this.tile, this.internal);\n                                    this.checkStatus = 0;\n                                }\n                            }\n\n                            tile.resetDrawCommands = true;\n                            this.map.markDirty();\n                        }\n                    }\n                }\n            }\n                \n            if (this.checkStatus == -1) {\n                if (!this.extraBound) {\n                    parent = this.extraInfo.tile.parent;\n                    if (parent.id[0] < this.extraInfo.layer.lodRange[0]) {\n                        this.neverReady = true;\n                        this.extraInfo.tile.resetDrawCommands = true;\n                        this.map.markDirty();\n                        return false;\n                    }\n\n                    this.extraBound = { tile: this.extraInfo.tile, layer: this.extraInfo.layer};\n                    this.setBoundTexture(this.extraBound.tile.parent, this.extraBound.layer);\n                    this.checkMask = true;\n                }\n\n                while (this.extraBound.texture.extraBound || this.extraBound.texture.checkStatus == -1) {\n                    //while (this.extraBound.texture.checkStatus == -1) {\n                    parent = this.extraBound.sourceTile.parent;\n                    if (parent.id[0] < this.extraBound.layer.lodRange[0]) {\n                        this.neverReady = true;\n                        this.extraBound.tile.resetDrawCommands = true;\n                        this.map.markDirty();\n                        return false;\n                    }\n                        \n                    this.setBoundTexture(parent, this.extraBound.layer);        \n                }\n            }\n\n            return false;\n        }\n        \n        break;\n    }\n\n    var maskState = true;\n\n    if (this.maskTexture) {\n        maskState = this.maskTexture.isReady(doNotLoad, priority, doNotCheckGpu, this);\n    }\n    \n\n    return this.mainTexture.isReady(doNotLoad, priority, doNotCheckGpu, this) && maskState;\n};\n\nMapTexture.prototype.isMaskPosible = function() {\n    var texture = this;\n\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            texture = this.extraBound.texture;\n        }\n    }\n\n    if (texture.checkType == VTS_TEXTURECHECK_MEATATILE) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nMapTexture.prototype.isMaskInfoReady = function() {\n    var texture = this;\n\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            texture = this.extraBound.texture;\n        }\n    }\n\n    if (texture.checkType == VTS_TEXTURECHECK_MEATATILE) {\n        if (this.maskTexture || texture.checkStatus == 2 || texture.checkStatus ==  -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    return true;\n}\n\nMapTexture.prototype.getGpuTexture = function() {\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            return this.extraBound.texture.getGpuTexture();\n        }\n        return null;\n    } \n\n    return this.mainTexture.getGpuTexture();\n};\n\n\nMapTexture.prototype.getMaskTexture = function() {\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            return this.extraBound.texture.getMaskTexture();\n        }\n    } \n\n    return this.maskTexture;\n};\n\n\nMapTexture.prototype.getGpuMaskTexture = function() {\n    if (this.extraBound) {\n        if (this.extraBound.texture && this.extraBound.texture.maskTexture) {\n            return this.extraBound.texture.getGpuMaskTexture();\n        }\n        return null;\n    } \n\n    if (this.maskTexture) {\n        return this.maskTexture.getGpuTexture();\n    }\n    \n    return null;\n};\n\nMapTexture.prototype.getGpuSize = function() {\n    return (this.mainTexture ? (this.mainTexture.gpuSize ? this.mainTexture.gpuSize : 0) : 0) + (this.maskTexture ? (this.maskTexture.gpuSize ? this.maskTexture.gpuSize : 0) : 0);\n};\n\nMapTexture.prototype.getImageData = function() {\n    return this.mainTexture.imageData;\n};\n\n\nMapTexture.prototype.getImageExtents = function() {\n    return this.mainTexture.imageExtents;\n};\n\n\nMapTexture.prototype.getHeightMapValue = function(x, y) {\n    return this.mainTexture.getHeightMapValue(x, y);\n};\n\n\nMapTexture.prototype.getTransform = function() {\n    if (this.extraBound) {\n        if (this.extraBound.texture) {\n            return this.extraBound.transform;\n        }\n        return null;\n    } \n\n    return [1,1,0,0];\n};\n\n\nexport default MapTexture;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/texture.js\n// module id = 55\n// module chunks = 0 1","\nvar MapView = function(map, json) {\n    //this.map = map;\n    //this.id = json[\"id\"] || null;\n    this.parse(json);\n};\n\n\nMapView.prototype.parse = function(json) {\n    this.description = json['description'] || '';\n    //this.boundLayers = json[\"boundLayers\"] || [];\n    this.freeLayers = json['freeLayers'] || {};\n    this.surfaces = {};    \n\n    if (json['surfaces']) {\n        var surfaces = json['surfaces']; \n        if (Array.isArray(surfaces)) { //convert from old version\n            for (var i = 0, li = surfaces.length; i < li; i++) {\n                this.surfaces[surfaces[i]] = [];\n            }\n        } else {\n            this.surfaces = surfaces;            \n        }\n    }\n\n    if (!this.freeLayers || Array.isArray(this.freeLayers)) { //convert from old version\n        this.freeLayers = {};\n    } else {\n        this.freeLayers = JSON.parse(JSON.stringify(this.freeLayers));\n    }\n    \n    this.surfaces = JSON.parse(JSON.stringify(this.surfaces));\n};\n\n\nMapView.prototype.getInfo = function() {\n    return {\n        'description' : JSON.parse(JSON.stringify(this.description)),\n        'surfaces' : JSON.parse(JSON.stringify(this.surfaces)),\n        //\"boundLayers\" : JSON.parse(JSON.stringify(this.boundLayers)),\n        'freeLayers' : JSON.parse(JSON.stringify(this.freeLayers))\n    };\n};\n\n\nexport default MapView;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/view.js\n// module id = 56\n// module chunks = 0 1","\nimport GpuTexture_ from './texture';\nimport {utils as utils_} from '../../utils/utils';\n\n//get rid of compiler mess\nvar GpuTexture = GpuTexture_;\nvar utils = utils_;\n\n\nvar GpuFont = function(gpu, core, font, size, path) {\n    this.bbox = null;\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.core = core;\n\n    this.data = null;\n    this.path = path;\n\n    this.texture = {width:256, height:256}; //hack\n\n    this.textures = [];\n    this.images = [];\n    this.ready = false;    \n    this.version = 1;    \n\n    this.load(path);\n};\n\n\n//destructor\nGpuFont.prototype.kill = function() {\n};\n\n// Returns GPU RAM used, in bytes.\nGpuFont.prototype.size = function(){ return this.size; };\n\n\nGpuFont.prototype.load = function(path) {\n    utils.loadBinary(path, this.onLoaded.bind(this), this.onError.bind(this));\n};\n\nGpuFont.prototype.onLoaded = function(data) {\n    this.data = data;\n    this.ready = true;    \n    this.core.markDirty();\n};\n\nGpuFont.prototype.isReady = function() {\n    return this.ready;\n};\n\nGpuFont.prototype.onError = function() {\n\n};\n\nGpuFont.prototype.onFileLoaded = function(index, data) {\n    this.core.markDirty();\n    this.textures[index].createFromData(256, 256, new Uint8Array(data), 'linear');\n};\n\nGpuFont.prototype.onFileLoadError = function() {\n};\n\nGpuFont.prototype.areTexturesReady = function(files) {\n    var ready = true;\n    for (var i = 0, li = files.length; i < li; i++) {\n        var index = files[i];//Math.round( (planes[i] - (planes[i] % 3)) );\n\n        if (!this.textures[index]) {\n            utils.loadBinary(this.path + (index+2), this.onFileLoaded.bind(this, index), this.onFileLoadError.bind(this));\n            this.textures[index] = new GpuTexture(this.gpu, null, this.core);\n            ready = false;\n        } else {\n            ready = (ready && this.textures[index].loaded);\n        }\n    }\n\n    return ready;\n};\n\nGpuFont.prototype.getTexture = function(file) {\n    //if (!this.textures[file]) {\n        //debugger;\n    //}\n\n    return this.textures[file];\n};\n\nexport default GpuFont;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/font.js\n// module id = 57\n// module chunks = 0 1","\nvar GpuShaders = {};\n\nGpuShaders.bboxVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'void main(){ \\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n    '}';\n\n\nGpuShaders.bbox2VertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform float uPoints[8*3];\\n'+\n    'void main(){ \\n'+\n        'int index = int(aPosition.z) * 3; \\n'+\n        'gl_Position = uMVP * vec4(uPoints[index], uPoints[index+1], uPoints[index+2], 1.0);\\n'+\n    '}';\n\n\nGpuShaders.bboxFragmentShader = 'precision mediump float;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\\n'+\n    '}';\n\n\nGpuShaders.lineVertexShader = //line\n    'attribute vec3 aPosition;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'void main(){ \\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n    '}';\n\n\nGpuShaders.lineFragmentShader = 'precision mediump float;\\n'+ //line\n    'uniform vec4 uColor;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = uColor;\\n'+\n    '}';\n\n\n//line with wireframe for debugging\nGpuShaders.lineWireframeVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec3 aBarycentric;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'void main(){ \\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n        'vBarycentric = aBarycentric;\\n'+\n    '}';\n\nGpuShaders.lineWireframeFragmentShader = 'precision mediump float;\\n'+ \n    '#extension GL_OES_standard_derivatives : enable\\n'+\n    'uniform vec4 uColor;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n    'float edgeFactor(){\\n'+\n        '#ifdef GL_OES_standard_derivatives\\n'+\n            'vec3 d = fwidth(vBarycentric);\\n'+\n            'vec3 a3 = smoothstep(vec3(0.0), d*1.0, vBarycentric);\\n'+\n            'return min(min(a3.x, a3.y), a3.z);\\n'+\n        '#else\\n'+\n            'float a = min(min(vBarycentric.x, vBarycentric.y), vBarycentric.z);\\n'+\n            'return a > 0.1 ? 1.0 : smoothstep(0.0,1.0,a*10.0);\\n'+\n        '#endif\\n'+\n    '}\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = vec4( mix(vec3(0.0), uColor.rgb, edgeFactor()) , uColor.a);\\n'+\n    '}';\n\nGpuShaders.elineVertexShader = //line elements\n    'attribute vec3 aPosition;\\n'+\n    'attribute float aElement;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'varying float vElement;\\n'+\n    'void main(){ \\n'+\n        'vElement = aElement;\\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n    '}';\n\n\nGpuShaders.elineFragmentShader = 'precision mediump float;\\n'+ //line elements\n    'uniform vec4 uColor;\\n'+\n    'varying float vElement;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor.xyz = fract(vec3(1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vElement) + (-0.5/255.0);\\n'+\n        'gl_FragColor.w = 1.0;\\n'+\n    '}';\n\n\nGpuShaders.line3VertexShader = //pixel line\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'void main(){ \\n'+\n        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\\n'+\n        'if (aNormal.w == 0.0) {\\n'+\n            'gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\\n'+\n        '} else {\\n'+\n            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\\n'+\n            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n            'vec2 n = normalize(pp2 - pp1);\\n'+\n            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\\n'+\n        '}\\n'+\n    '}';\n\nGpuShaders.eline3VertexShader = //pixel line elements\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'attribute float aElement;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'varying float vElement;\\n'+\n    'void main(){ \\n'+\n        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\\n'+\n        'vElement = aElement;\\n'+\n        'if (aNormal.w == 0.0) {\\n'+\n            'gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\\n'+\n        '} else {\\n'+\n            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\\n'+\n            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n            'vec2 n = normalize(pp2 - pp1);\\n'+\n            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\\n'+\n        '}\\n'+\n    '}';\n\nGpuShaders.line4VertexShader = //direct linestring pixel line\n    'attribute vec3 aPosition;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec3 uScale;\\n'+\n    'uniform vec3 uPoints[32];\\n'+\n    'void main(){ \\n'+\n        'vec4 pp0 = (uMVP * vec4(uPoints[int(aPosition.x)], 1.0));\\n'+\n        'if (aPosition.y < 0.0) {\\n'+\n            'if (aPosition.y == -1.0) {\\n'+\n                'gl_Position = pp0;\\n'+\n            '} else {\\n'+\n                'gl_Position = pp0 + vec4((vec3(-sin(aPosition.z)*uScale.x*uScale.z, cos(aPosition.z)*uScale.y*uScale.z, 0.0)), 0.0);\\n'+\n            '}\\n'+\n        '} else {\\n'+\n            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n            'vec4 pp3 = (uMVP * vec4(uPoints[int(aPosition.y)], 1.0));\\n'+\n            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n            'vec2 n = normalize(pp2 - pp1);\\n'+\n            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aPosition.z*uScale.z, n.x*uScale.y*aPosition.z*uScale.z, 0.0)), 0.0);\\n'+\n        '}\\n'+\n    '}';\n\nGpuShaders.tlineVertexShader = // textured line\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'vec4 p=vec4(aPosition.xyz, 1.0);\\n'+\n        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\\n'+\n        'if (aNormal.w < 0.0){\\n'+\n            'vTexCoord=vec2(abs(aPosition.w)*uParams[0], (uParams[1]+uParams[2])*0.5);\\n'+\n        '} else {\\n'+\n            'vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\\n'+\n        '}\\n'+\n\n        'gl_Position = uMVP * p;\\n'+\n    '}';\n\nGpuShaders.rlineVertexShader =  // dynamic width line\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'void main(){ \\n'+\n        'vec4 p=vec4(aPosition.xyz, 1.0);\\n'+\n        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\\n'+\n        'gl_Position = uMVP * p;\\n'+\n    '}';\n\nGpuShaders.erlineVertexShader = // dynamic width line elements\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'attribute float aElement;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying float vElement;\\n'+\n    'void main(){ \\n'+\n        'vec4 p=vec4(aPosition.xyz, 1.0);\\n'+\n        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\\n'+\n        'vElement = aElement;\\n'+\n        'gl_Position = uMVP * p;\\n'+\n    '}';\n\nGpuShaders.etlineVertexShader = // textured line elements\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'attribute float aElement;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying float vElement;\\n'+\n    'void main(){ \\n'+\n        'vec4 p=vec4(aPosition.xyz, 1.0);\\n'+\n        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\\n'+\n        'vElement = aElement;\\n'+\n        'gl_Position = uMVP * p;\\n'+\n    '}';\n\nGpuShaders.tplineVertexShader = // textured pixel line\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\\n'+\n        'vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\\n'+\n        'if (aNormal.w == 0.0) {\\n'+\n            'gl_Position = pp0 + vec4((vec3(aNormal.x*uParams[3]*uScale.x*pp0.w, aNormal.y*uParams[3]*uScale.y*pp0.w, 0.0)), 0.0);\\n'+\n        '} else {\\n'+\n            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\\n'+\n            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n            'vec2 n = normalize(pp2 - pp1);\\n'+\n            'gl_Position = pp0 + vec4((vec3(-n.y*uParams[3]*uScale.x*aNormal.w*pp0.w, n.x*uParams[3]*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\\n'+\n        '}\\n'+\n    '}';\n\nGpuShaders.etplineVertexShader = // textured pixel line elements\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aNormal;\\n'+\n    'attribute float aElement;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec2 uScale;\\n'+\n    'uniform vec4 uParams;\\n'+\n    'varying float vElement;\\n'+\n    'void main(){ \\n'+\n        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\\n'+\n        'vElement = aElement;\\n'+\n        'if (aNormal.w == 0.0) {\\n'+\n            'gl_Position = pp0 + vec4((vec3(aNormal.x*uParams[3]*uScale.x*pp0.w, aNormal.y*uParams[3]*uScale.y*pp0.w, 0.0)), 0.0);\\n'+\n        '} else {\\n'+\n            'vec2 pp1 = pp0.xy / pp0.w;\\n'+\n            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\\n'+\n            'vec2 pp2 = pp3.xy / pp3.w;\\n'+\n            'vec2 n = normalize(pp2 - pp1);\\n'+\n            'gl_Position = pp0 + vec4((vec3(-n.y*uParams[3]*uScale.x*aNormal.w*pp0.w, n.x*uParams[3]*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\\n'+\n        '}\\n'+\n    '}';\n\nGpuShaders.tlineFragmentShader = 'precision mediump float;\\n'+ // textured line\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'uniform vec4 uColor2;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main() {\\n'+\n        'vec4 c=texture2D(uSampler, vTexCoord)*uColor;\\n'+\n        'gl_FragColor = c;\\n'+\n    '}';\n\n\nGpuShaders.tblineFragmentShader = 'precision mediump float;\\n'+  // textured line with background color\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'uniform vec4 uColor2;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main() {\\n'+\n        'vec4 c1=texture2D(uSampler, vTexCoord)*uColor;\\n'+\n        'vec4 c2=uColor2,c=c1;\\n'+\n        'c.xyz*=c.w; c2.xyz*=c2.w;\\n'+\n        'c=mix(c,c2,1.0-c.w);\\n'+\n        'c.xyz/=(c.w+0.00001);\\n'+\n        'c.w=max(c1.w,c2.w);\\n'+\n        'gl_FragColor = c;\\n'+\n    '}';\n\n\nGpuShaders.polygonVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec3 aNormal;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform mat4 uRot;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'varying vec4 vColor;\\n'+\n    'void main(){ \\n'+\n        'float l = dot((uRot*vec4(aNormal,1.0)).xyz, vec3(0.0,0.0,1.0)) * 0.5;\\n'+\n        'vec3 c = uColor.xyz;\\n'+\n        'c = (l > 0.0) ? mix(c,vec3(1.0,1.0,1.0),l) : mix(vec3(0.0,0.0,0.0),c,1.0+l);\\n'+\n        'vColor = vec4(c, uColor.w);\\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n    '}';\n\n\nGpuShaders.polygonFragmentShader = 'precision mediump float;\\n'+\n    'varying vec4 vColor;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = vColor;\\n'+\n    '}';\n\n\nGpuShaders.textVertexShader =\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aTexCoord;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec4 uVec;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'vTexCoord = aTexCoord.xy;\\n'+\n        'if (dot(uVec.xyz, vec3(aTexCoord.z, aTexCoord.w, aPosition.w)) < 0.0) {\\n'+\n            'gl_Position = uMVP * vec4(2.0, 0.0, 0.0, 1.0);\\n'+\n        '}else{\\n'+\n            'gl_Position = uMVP * vec4(aPosition.xyz, 1.0);\\n'+\n        '}\\n'+\n    '}';\n\n\nGpuShaders.text2VertexShader =\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aTexCoord;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec4 uVec;\\n'+\n    'uniform float uFile;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'vTexCoord = aTexCoord.xy;\\n'+\n        'if (dot(uVec.xyz, vec3(aTexCoord.z, aTexCoord.w, aPosition.w)) < 0.0) {\\n'+\n            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n        '}else{\\n'+\n            'float file = floor(aTexCoord.y/4.0);\\n'+\n            'vTexCoord.y = mod(aTexCoord.y,4.0);\\n'+\n            'if (file != floor(uFile)) {\\n'+\n                'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n            '}else{\\n'+\n                'gl_Position = uMVP * vec4(aPosition.xyz, 1.0);\\n'+\n            '}\\n'+\n        '}\\n'+\n    '}';\n\nGpuShaders.iconVertexShader =\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aTexCoord;\\n'+\n    'attribute vec3 aOrigin;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec4 uScale;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'vTexCoord = aTexCoord.xy * uScale[2];\\n'+\n        'vec4 pos = (uMVP * vec4(aOrigin, 1.0));\\n'+\n        'gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, (aPosition.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\\n'+\n    '}';\n\nGpuShaders.icon2VertexShader =\n    'attribute vec4 aPosition;\\n'+\n    'attribute vec4 aTexCoord;\\n'+\n    'attribute vec3 aOrigin;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec4 uScale;\\n'+\n    'uniform float uFile;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    //'float round(float x) { return floor(x + 0.5); }\\n'+\n    'void main(){ \\n'+\n        'vTexCoord = aTexCoord.xy * uScale[2];\\n'+\n        'float file = floor(aTexCoord.y/4.0);\\n'+\n        'vTexCoord.y = mod(aTexCoord.y,4.0);\\n'+\n        'if (file != floor(uFile)) {\\n'+\n            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n        '}else{\\n'+\n            'vec4 pos = (uMVP * vec4(aOrigin, 1.0));\\n'+\n            //'pos.x = (floor((pos.x/pos.w)*800.0+0.5)/800.0)*pos.w;\\n'+\n            //'pos.y = (floor((pos.y/pos.w)*410.0+0.5)/410.0)*pos.w;\\n'+\n            'gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, (aPosition.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\\n'+\n        '}'+\n    '}';\n\nGpuShaders.icon3VertexShader =\n    'attribute vec2 aPosition;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'uniform vec4 uScale;\\n'+\n    'uniform vec3 uOrigin;\\n'+\n    'uniform vec4 uData[DSIZE];\\n'+\n    'uniform float uFile;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'int index = int(aPosition.x);\\n'+\n        'vec4 data = uData[index];\\n'+\n        'vec4 data2 = uData[index+1];\\n'+\n        'vec4 v;\\n'+\n        'int corner = int(aPosition.y);\\n'+\n        'if (corner==0) v = vec4(data.x, data.y, data2.x, data2.y);\\n'+\n        'if (corner==1) v = vec4(data.z, data.y, data2.z, data2.y);\\n'+\n        'if (corner==2) v = vec4(data.z, data.w, data2.z, data2.w);\\n'+\n        'if (corner==3) v = vec4(data.x, data.w, data2.x, data2.w);\\n'+\n//        'vTexCoord = vec2(v.z, v.w) * uScale[2];\\n'+\n        'vTexCoord = vec2(v.z, v.w);\\n'+\n        'float file = floor(v.w/4.0);\\n'+\n        'vTexCoord.y = mod(v.w,4.0);\\n'+\n        'if (file != floor(uFile)) {\\n'+\n            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\\n'+\n        '}else{\\n'+\n            'vec4 pos = (uMVP * vec4(uOrigin.xyz, 1.0));\\n'+\n            'gl_Position = pos + vec4(v.x*uScale.x*pos.w, (v.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\\n'+\n        '}'+\n    '}';\n\n\nGpuShaders.textFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main() {\\n'+\n        'vec4 c=texture2D(uSampler, vTexCoord);\\n'+\n        'if(c.w < 0.01){ discard; }\\n'+\n        'gl_FragColor = c*uColor;\\n'+\n    '}';\n\nGpuShaders.text2FragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'uniform vec2 uParams;\\n'+\n    'const vec4 uColor1 = vec4(1.0, 1.0, 1.0, 1.0);\\n'+\n    'const vec4 uColor2 = vec4(0.0, 0.0, 0.0, 1.0);\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'float round(float x) { return floor(x + 0.5); }\\n'+\n\n    'void main() {\\n'+\n        'vec4 mask;\\n'+\n        'int i=int(floor(vTexCoord.y));\\n'+\n        'if (i == 0) mask=vec4(1.0,0.0,0.0,0.0);else\\n'+\n        'if (i == 1) mask=vec4(0.0,1.0,0.0,0.0);else\\n'+\n        'if (i == 2) mask=vec4(0.0,0.0,1.0,0.0);\\n'+\n        'if (i == 3) mask=vec4(0.0,0.0,0.0,1.0);\\n'+\n        \n        'vec2 uv=(vTexCoord);\\n'+\n        'uv.y=fract(uv.y);\\n'+\n        'vec4 c=vec4(dot(mask, texture2D(uSampler, uv)));\\n'+\n        //'c.w=1.0;\\n'+\n        \n        'float u_buffer = uParams[0];\\n'+\n        'float u_gamma = uParams[1];\\n'+\n        'float alpha = uColor.a * smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, c.r);\\n'+\n\n        'if(alpha < 0.01){ discard; }\\n'+\n        'gl_FragColor = vec4(uColor.rgb, alpha);\\n'+\n        //'gl_FragColor = vec4(1.0);\\n'+\n    '}';\n\nGpuShaders.skydomeVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMVP;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main(){ \\n'+\n        'gl_Position = uMVP * vec4(aPosition, 1.0);\\n'+\n        'vTexCoord = aTexCoord;\\n'+\n    '}';\n\n\nGpuShaders.skydomeFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'const vec4 gray = vec4(0.125, 0.125, 0.125, 1.0);\\n'+\n    'void main() {\\n'+\n        'float fade = smoothstep(0.51, 0.55, vTexCoord.t);\\n'+\n        'gl_FragColor = mix(texture2D(uSampler, vTexCoord), gray, fade);\\n'+\n    '}';\n\n\nGpuShaders.stardomeFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = texture2D(uSampler, vTexCoord);\\n'+\n    '}';\n\n\nGpuShaders.atmoVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform mat3 uNorm;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'varying vec4 vPosition;\\n'+\n    'void main(){ \\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'vec4 c = uMV * vec4(aPosition, 1.0);\\n'+\n        'vNormal = (aPosition.xyz - vec3(0.5));\\n'+\n        'vPosition = camSpacePos;\\n'+\n    '}';\n\n\nGpuShaders.atmoFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uParams;\\n'+       //[radius, atmoSize, 0 ,0]\n    'uniform vec4 uParams2;\\n'+       //[radius, atmoSize, 0 ,0]\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'uniform vec4 uFogColor;\\n'+ //= vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'uniform vec4 uFogColor2;\\n'+ //= vec4(72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'float l = dot(normalize(vNormal),-uParams2.xyz);\\n'+\n        'l = (1.0-pow(abs(l),uParams.x));\\n'+\n        'vec4 c = mix(uFogColor2, uFogColor, l);\\n'+\n        'gl_FragColor = vec4(c.xyz, c.w*l);\\n'+\n    '}';\n\n\nGpuShaders.atmoFragmentShader2 = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform float uNFactor;\\n'+\n    'uniform vec2 uRadius;\\n'+\n    'uniform vec3 uPos;\\n'+\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'uniform vec4 uFogColor;\\n'+ //= vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec3 ldir = normalize(-vPosition.xyz);\\n'+\n        'vec3 diff = uPos;\\n'+\n        'float a = dot(ldir, ldir);\\n'+\n        'float b = 2 * dot(ldir, diff);\\n'+\n        'float c = dot(diff, diff) - (uRadius[0] * uRadius[0]);\\n'+\n        'float i = 0;\\n'+\n        'float discr = b * b - 4 * a * c;\\n'+\n        'if (discr > 0.0) {}\\n'+\n\n        '}\\n'+\n        'gl_FragColor = uFogColor;\\n'+\n    '}';\n\n\nGpuShaders.atmoVertexShader3 =\n    'attribute vec3 aPosition;\\n'+\n    //'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    //\"uniform mat3 uNorm;\\n\"+\n    'uniform vec4 uParams;\\n'+       //[surfaceRadius, surfaceRadius, strech ,safetyfactor]\n    'uniform vec4 uParams2;\\n'+       //[cameraPos, 1]\n\n    'varying vec2 vTexcoords;\\n'+\n\n    'void main(){ \\n'+\n        'gl_Position = uProj * (uMV * vec4(aPosition, 1.0));\\n'+\n\n        'vec3 position = (aPosition.xyz - vec3(0.5)) * vec3(uParams.w * 2.0);\\n'+\n        'vec4 camPos = uParams2;\\n'+\n        'float SurfaceRadius = uParams.x;\\n'+ \n        'float AtmosphereRadius = uParams.y;\\n'+ \n        'float StretchAmt = uParams.z;\\n'+ \n     \n        'float camHeight = length(camPos.xyz);\\n'+\n        'vec3 camToPos = position - camPos.xyz;\\n'+\n        'float farDist = length(camToPos);\\n'+\n    \n        // get distance to surface horizon\n        'float altitude = max(0.0,camHeight - SurfaceRadius);\\n'+\n        'float horizonDist = sqrt((altitude*altitude) + (2.0 * SurfaceRadius * altitude));\\n'+\n        'float maxDot = horizonDist / camHeight;\\n'+\n     \n        // get distance to atmosphere horizon - use max(0,...) because we can go into the atmosphere\n        'altitude = max(0.0,camHeight - AtmosphereRadius);\\n'+\n        'horizonDist = sqrt((altitude*altitude) + (2.0 * AtmosphereRadius * altitude));\\n'+\n     \n        // without this, the shift between inside and outside atmosphere is  jarring\n        'float tweakAmount = 0.1;\\n'+\n        'float minDot = max(tweakAmount,horizonDist / camHeight);\\n'+\n     \n        // scale minDot from 0 to -1 as we enter the atmosphere\n        'float minDot2 = ((camHeight - SurfaceRadius) * (1.0 / (AtmosphereRadius  - SurfaceRadius))) - (1.0 - tweakAmount);\\n'+\n        'minDot = min(minDot, minDot2);\\n'+\n      \n        // get dot product of the vertex we're looking out\n        'float posDot = dot(camToPos / farDist,-camPos.xyz / camHeight) - minDot;\\n'+\n     \n        // calculate the height from surface in range 0..1\n        'float height = posDot * (1.0 / (maxDot - minDot));\\n'+\n    \n        'vTexcoords.y = height;\\n'+ \n     \n        'height -= min(0.0,minDot2 + ((1.0 + StretchAmt) * minDot2));\\n'+\n        'vTexcoords.x = height;\\n'+\n    '}';\n\n\nGpuShaders.atmoFragmentShader3 = 'precision mediump float;\\n'+\n    'varying vec2 vTexcoords;\\n'+\n    'uniform vec4 uParams3;\\n'+       //[treshold, mutiplier, 0,0]\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'uniform vec4 uFogColor2;\\n'+ // = vec4(72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0);\\n'+\n    'const vec4 fogColor3 = vec4(0.0/255.0, 0.0/255.0, 0.0/255.0, 1.0);\\n'+\n\n    'void main() {\\n'+\n        'float l = vTexcoords.y;\\n'+\n        'if (l > uParams3.z){ discard; } else {\\n'+\n            'float l2 = clamp((l*l)*0.9+0.1, 0.0, 1.5);\\n'+\n            'vec4 c = mix(uFogColor2, uFogColor, l2);\\n'+\n            'gl_FragColor = vec4(c.xyz, c.w*l);\\n'+\n        \n            'if (l > uParams3.x){ gl_FragColor.xyz = mix(gl_FragColor.xyz, fogColor3.xyz, (l-uParams3.x)*uParams3.y); }\\n'+\n        '}'+\n\n    '}';\n\n\n//heightmap tile\nGpuShaders.heightmapVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'uniform mat4 uGridMat;\\n'+\n    'uniform float uGridStep1, uGridStep2;\\n'+\n    'const int HMSize = 5;\\n'+\n    'const float HMSize1 = float(HMSize-1);\\n'+\n    'uniform float uHeight[HMSize*HMSize];\\n'+\n    'varying vec2 vTexCoord1;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+\n    'float round(float x) { return floor(x + 0.5); }\\n'+\n    'void main() {\\n'+\n        'vec3 pos = aPosition;\\n'+\n        'float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\\n'+\n        'vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uFogDensity * camDist);\\n'+\n        'vec4 gridCoord = uGridMat * vec4(pos, 1.0);\\n'+\n        'vTexCoord1 = aTexCoord;\\n'+\n        'vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\\n'+\n        'vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\\n'+\n    '}';\n\n\nGpuShaders.heightmapFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform float uGridBlend;\\n'+\n    'varying vec2 vTexCoord1;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec4 gridColor = mix(texture2D(uSampler, vTexCoord1), texture2D(uSampler, vTexCoord2), uGridBlend);\\n'+\n        'gl_FragColor = mix(uFogColor, gridColor, vFogFactor);\\n'+\n    '}';\n\n\n//depth encoded heightmap tile\nGpuShaders.heightmapDepthVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'uniform mat4 uGridMat;\\n'+\n    'uniform float uGridStep1, uGridStep2;\\n'+\n    'const int HMSize = 5;\\n'+\n    'const float HMSize1 = float(HMSize-1);\\n'+\n    'uniform float uHeight[HMSize*HMSize];\\n'+\n    'varying vec2 vTexCoord1;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vDepth;\\n'+\n    'float round(float x) { return floor(x + 0.5); }\\n'+\n    'void main() {\\n'+\n        'vec3 pos = aPosition;\\n'+\n        'float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\\n'+\n        'vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vDepth = camDist;\\n'+\n        'vec4 gridCoord = uGridMat * vec4(pos, 1.0);\\n'+\n        'vTexCoord1 = aTexCoord;\\n'+\n        'vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\\n'+\n        'vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\\n'+\n    '}';\n\n\nGpuShaders.heightmapDepthFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform float uGridBlend;\\n'+\n    'varying vec2 vTexCoord1;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vDepth;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\\n'+\n    '}';\n\nGpuShaders.quadPoint = \n    'vec3 quadPoint(int i1, int i2, int i3, float t, float t2) {\\n'+\n        'float p1x = uPoints[i1], p1y = uPoints[i1+1], p1z = uPoints[i1+2];\\n'+\n        'float p3x = uPoints[i3], p3y = uPoints[i3+1], p3z = uPoints[i3+2];\\n'+\n        'float p2x = 2.0*uPoints[i2]-p1x*0.5-p3x*0.5;\\n'+\n        'float p2y = 2.0*uPoints[i2+1]-p1y*0.5-p3y*0.5;\\n'+\n        'float p2z = 2.0*uPoints[i2+2]-p1z*0.5-p3z*0.5;\\n'+\n        'return vec3(t2*t2*p1x+2.0*t2*t*p2x+t*t*p3x, t2*t2*p1y+2.0*t2*t*p2y+t*t*p3y, t2*t2*p1z+2.0*t2*t*p2z+t*t*p3z); }\\n';\n\n   \nGpuShaders.planeVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform vec4 uParams;\\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]\n    'uniform vec4 uParams3;\\n'+    //[px, py, sx, sy]\n    'uniform float uPoints[9*3];\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+ GpuShaders.quadPoint +\n    'void main() {\\n'+\n        'vec3 indices = aPosition;\\n'+\n        'float t = aPosition.y * uParams[2];\\n'+  //vertical index\n        'float t2 = (1.0-t);\\n'+\n        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\\n'+\n        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\\n'+\n        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\\n'+\n        't = aPosition.x * uParams[2];\\n'+  //horizontal index\n        't2 = (1.0-t);\\n'+\n        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\\n'+\n        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\\n'+\n        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\\n'+\n        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\\n'+\n        'vec4 camSpacePos = uMV * p;\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uParams[1] * camDist);\\n'+\n        'vec2 uv;\\n'+\n        'uv.x = aTexCoord.y * uParams3[2] + uParams3[0];\\n'+\n        'uv.y = 1.0-(aTexCoord.x * uParams3[3] + uParams3[1]);\\n'+\n        'vTexCoord = uv;\\n'+\n    '}';\n\n\nGpuShaders.planeFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uParams2;\\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]\n    'varying vec2 vTexCoord;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\\n'+\n        'gl_FragColor = mix(uFogColor, c, vFogFactor);\\n'+\n    '}';\n\nGpuShaders.planeVertex2Shader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform vec4 uParams;\\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]\n    'uniform vec4 uParams3;\\n'+    //[px, py, sx, sy]\n    'uniform float uPoints[9*3];\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+ GpuShaders.quadPoint +\n    'void main() {\\n'+\n        'vec3 indices = aPosition;\\n'+\n        'float t = aPosition.y * uParams[2];\\n'+  //vertical index\n        'float t2 = (1.0-t);\\n'+\n        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\\n'+\n        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\\n'+\n        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\\n'+\n        't = aPosition.x * uParams[2];\\n'+  //horizontal index\n        't2 = (1.0-t);\\n'+\n        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\\n'+\n        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\\n'+\n        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\\n'+\n        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\\n'+\n        'vec4 camSpacePos = uMV * p;\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uParams[1] * camDist);\\n'+\n        'vec2 uv;\\n'+\n        'uv.x = aTexCoord.y * uParams3[2] + uParams3[0];\\n'+\n        'uv.y = 1.0-(aTexCoord.x * uParams3[3] + uParams3[1]);\\n'+\n        'vTexCoord = uv;\\n'+\n        'vTexCoord2 = p.xy;\\n'+\n    '}';\n\n\nGpuShaders.planeFragment2Shader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uParams2;\\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]\n    'uniform vec4 uParams4;\\n'+    //[pole-x, pole-y, pole-radius, 0]\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'if (length(uParams4.xy - vTexCoord2.xy) > uParams4.z){ discard; }'+ \n        'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\\n'+\n        'gl_FragColor = mix(uFogColor, c, vFogFactor);\\n'+\n    '}';\n\nGpuShaders.planeVertex3Shader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform vec4 uParams;\\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]\n    'uniform vec4 uParams3;\\n'+    //[px, py, sx, sy]\n    'uniform float uPoints[9*3];\\n'+\n    'uniform vec3 uVector;\\n'+  \n    'uniform float uHeights[9];\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying float vFogFactor;\\n'+ GpuShaders.quadPoint + \n    'float linearHeight(float x, float y) {\\n'+\n        'int ix = int(x);\\n'+\n        'int iy = int(y);\\n'+\n        'int index = (2-iy)*3+ix;\\n'+\n        'int index2 = (2-(iy+1))*3+ix;\\n'+\n        'float fx = fract(x);\\n'+\n        'float fy = fract(y);\\n'+\n        'float w0 = (uHeights[index] + (uHeights[index+1] - uHeights[index])*fx);\\n'+\n        'float w1 = (uHeights[index2] + (uHeights[index2+1] - uHeights[index2])*fx);\\n'+\n        'return (w0 + (w1 - w0)*fy);\\n'+\n    '}\\n'+\n    'void main() {\\n'+\n        'vec3 indices = aPosition;\\n'+\n        'float t = aPosition.y * uParams[2];\\n'+  //vertical index\n        'float tt = t;\\n'+\n        'float t2 = (1.0-t);\\n'+\n        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\\n'+\n        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\\n'+\n        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\\n'+\n        't = aPosition.x * uParams[2];\\n'+  //horizontal index\n        'float tt2 = t;\\n'+\n        't2 = (1.0-t);\\n'+\n        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\\n'+\n        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\\n'+\n        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\\n'+\n        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\\n'+\n        'p.xyz += uVector * linearHeight(tt*2.0, tt2*2.0);\\n'+\n        'vec4 camSpacePos = uMV * p;\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uParams[1] * camDist);\\n'+\n        'vec2 uv;\\n'+\n        'uv.x = aTexCoord.y * uParams3[2] + uParams3[0];\\n'+\n        'uv.y = (1.0-aTexCoord.x) * uParams3[3] + uParams3[1];\\n'+\n        'vTexCoord = uv;\\n'+\n    '}';\n\nGpuShaders.getHFNormal =\n    'vec3 getHFNormal(vec2 uv, float texelSize, float heightDelta) {\\n'+\n        'vec4 h;\\n'+\n        'h[0] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0,-1.0))).r * heightDelta;\\n'+\n        'h[1] = texture2D(uSampler2, uv + (texelSize * vec2(-1.0, 0.0))).r * heightDelta;\\n'+\n        'h[2] = texture2D(uSampler2, uv + (texelSize * vec2( 1.0, 0.0))).r * heightDelta;\\n'+\n        'h[3] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0, 1.0))).r * heightDelta;\\n'+\n        'return normalize(vec3(h[1] - h[2], h[3] - h[0], 2.0));}\\n';\n\nGpuShaders.getHFNormal2 =\n    'vec2 getHFNormal2(vec2 uv, float texelSize, float heightDelta) {\\n'+\n        'vec4 h;\\n'+\n        'h[0] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0,-1.0))).r * heightDelta;\\n'+\n        'h[1] = texture2D(uSampler2, uv + (texelSize * vec2(-1.0, 0.0))).r * heightDelta;\\n'+\n        'h[2] = texture2D(uSampler2, uv + (texelSize * vec2( 1.0, 0.0))).r * heightDelta;\\n'+\n        'h[3] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0, 1.0))).r * heightDelta;\\n'+\n        'return vec2(h[1] - h[2], h[3] - h[0]);}\\n';\n\nGpuShaders.planeVertex4Shader =\n    '#define newspace\\n'+\n    'uniform sampler2D uSampler2;\\n'+\n    'attribute vec3 aPosition;\\n'+\n    //'attribute vec2 aTexCoord;\\n'+\n    //'attribute vec3 aBarycentric;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform vec4 uParams;\\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]\n    'uniform vec4 uParams3;\\n'+    //[px, py, sx, sy]\n    'uniform float uPoints[9*3];\\n'+\n    'uniform vec3 uVector;\\n'+  \n    'uniform vec3 uHeights;\\n'+   //[hmin, hmax]\n    'uniform vec4 uTransform;\\n'+\n    //'uniform vec4 uTransform2;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec2 vTexCoord2;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n\n    '#ifdef newspace\\n'+\n        'varying mat3 vTBN;\\n'+\n    '#else\\n'+\n        'varying vec3 vNormal;\\n'+\n    '#endif\\n'+\n\n    'varying float vFogFactor;\\n'+ GpuShaders.quadPoint +  GpuShaders.getHFNormal + GpuShaders.getHFNormal2 +\n    //'float random(vec2 p) { return fract(cos(dot(p,vec2( 23.14069263277926, 2.665144142690225)))*12345.6789);}\\n'+\n\n    'void main() {\\n'+\n        'vec3 indices = aPosition;\\n'+\n        'float t = aPosition.y * uParams[2];\\n'+  //vertical index\n        'float tt = t;\\n'+\n        'float t2 = (1.0-t);\\n'+\n        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\\n'+\n        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\\n'+\n        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\\n'+\n        't = aPosition.x * uParams[2];\\n'+  //horizontal index\n        'float tt2 = t;\\n'+\n        't2 = (1.0-t);\\n'+\n        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\\n'+\n        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\\n'+\n        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\\n'+\n        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\\n'+\n        'vec2 uv2 = vec2(tt, 1.0-tt2);\\n'+\n        'uv2 = vec2(uTransform[0] * uv2[0] + uTransform[2], uTransform[1] * uv2[1] + uTransform[3]);\\n'+\n\n        'p.xyz += uVector * (uHeights[0] + (uHeights[1]-uHeights[0])*texture2D(uSampler2, uv2).x);\\n'+\n\n        'vec4 camSpacePos = uMV * p;\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uParams[1] * camDist);\\n'+\n\n        'vec2 uv = vec2(tt, 1.0-tt2);\\n'+\n        'uv.x = uv.x * uParams3[0] + uParams3[2];\\n'+\n        'uv.y = uv.y * uParams3[1] + uParams3[3];\\n'+\n        'vTexCoord = uv;\\n'+\n\n        'vBarycentric = camSpacePos.xyz;\\n'+\n\n        '#ifdef newspace\\n'+\n            'vec2 d = getHFNormal2(uv2, 1.0/(128.0), (uHeights[1]-uHeights[0]) * uHeights[2]);\\n'+\n            'vec3 T = vec3(2.0,0.0,-d.x); vec3 B = vec3(0.0,2.0,-d.y);\\n'+\n            'vTBN = mat3(normalize(T), normalize(B), cross(T,B));\\n'+\n        '#else\\n'+\n            'vec3 n = getHFNormal(uv2, 1.0/(128.0), (uHeights[1]-uHeights[0]) * uHeights[2]);\\n'+\n            'vNormal = normalize(n);\\n'+\n        '#endif\\n'+\n\n    '}';    \n\nGpuShaders.planeFragmentShader2 = 'precision mediump float;\\n'+\n    '#extension GL_OES_standard_derivatives : enable\\n'+\n    '#define newspace\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'uniform vec4 uParams2;\\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]\n    'uniform mat3 uSpace;\\n'+  \n    'varying vec2 vTexCoord;\\n'+\n    'varying float vFogFactor;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n\n    '#ifdef newspace\\n'+\n        'varying mat3 vTBN;\\n'+\n    '#else\\n'+\n        'varying vec3 vNormal;\\n'+\n    '#endif\\n'+\n\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec3 ldir = normalize(-vBarycentric);\\n'+\n        \n        '#ifdef flat\\n'+\n            'vec3 nx = dFdx(vBarycentric);\\n'+\n            'vec3 ny = dFdy(vBarycentric);\\n'+\n            'vec3 normal2 = normalize(cross(nx,ny));\\n'+\n            'vec4 c2 = vec4(vec3(max(0.0,normal2.z*(204.0/255.0))+(32.0/255.0)),1.0);\\n'+\n        '#else\\n'+\n\n            '#ifdef newspace\\n'+\n                //'vec3 normal = cross(normalize(vTangent), normalize(vBitangent));\\n'+\n\n                '#ifdef nmix\\n'+\n                    'vec3 normal = vTBN * normalize((texture2D(uSampler, vTexCoord).xyz-0.5)*2.0);\\n'+\n                '#else\\n'+\n                    'vec3 normal = vTBN * vec3(0.0,0.0,1.0);\\n'+\n                '#endif\\n'+\n\n            '#else\\n'+\n                'vec3 normal = vNormal;\\n'+\n            '#endif\\n'+\n\n            'normal = normalize(uSpace * normal);\\n'+\n\n            'vec3 eyeDir = ldir;\\n'+\n            'vec3 refDir = reflect(-ldir, normal);\\n'+\n            'float specW = min(1.0, pow(max(dot(refDir, eyeDir), 0.0), 90.0));\\n'+\n            'float diffW = min(1.0, max(dot(normal, ldir), 0.0));\\n'+\n            'float lcolor = (dot(normal, ldir) + 1.0) * 0.5;\\n'+\n            //'float lcolor = 0.25+(0.5*diffW)+(0.25*specW);\\n'+\n            //'float lcolor = 0.25+(0.75*diffW);\\n'+\n\n            '#ifdef normals\\n'+\n                'vec4 c2 = vec4(normal*0.5+0.5,1.0);\\n'+        \n            '#else\\n'+\n                'vec4 c2 = vec4(vec3(dot(vec3(0.0,0.0,1.0), normal)),1.0);\\n'+        \n            '#endif\\n'+\n            //'vec4 c2 = vec4(normalize(ldir)*0.5+0.5,1.0);\\n'+\n            //'vec4 c2 = vec4(vec3(lcolor),1.0);\\n'+\n        '#endif\\n'+\n\n        '#ifdef grid\\n'+\n            'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\\n'+\n            'c = mix(c, c2, 0.5);\\n'+\n        '#else\\n'+\n            '#ifdef exmap\\n'+\n\n                'vec4 c = texture2D(uSampler, vTexCoord);\\n'+\n\n                '#ifdef classmap\\n'+\n                    'int i = int(c.x*255.0);\\n'+\n\n                    /*\n                    'if (i == 0) c = vec4(0.3, 0.44, 0.64, 1.0);\\n'+\n                    'if (i == 1) c = vec4(0.0, 0.24, 0.0, 1.0);\\n'+\n                    'if (i == 2) c = vec4(0.58, 0.61, 0.44, 1.0);\\n'+\n                    'if (i == 3) c = vec4(0.0, 0.39, 0.0, 1.0);\\n'+\n                    'if (i == 4) c = vec4(0.12, 0.67, 0.02, 1.0);\\n'+\n                    'if (i == 5) c = vec4(0.08, 0.55, 0.24, 1.0);\\n'+\n                    'if (i == 6) c = vec4(0.36, 0.46, 0.17, 1.0);\\n'+\n                    'if (i == 7) c = vec4(0.7, 0.62, 0.18, 1.0);\\n'+\n                    'if (i == 8) c = vec4(0.7, 0.54, 0.2, 1.0);\\n'+\n                    'if (i == 9) c = vec4(0.91, 0.86, 0.37, 1.0);\\n'+\n                    'if (i == 10) c = vec4(0.88, 0.81, 0.54, 1.0);\\n'+\n                    'if (i == 11) c = vec4(0.61, 0.46, 0.33, 1.0);\\n'+\n                    'if (i == 12) c = vec4(0.73, 0.83, 0.56, 1.0);\\n'+\n                    'if (i == 13) c = vec4(0.25, 0.54, 0.45, 1.0);\\n'+\n                    'if (i == 14) c = vec4(0.42, 0.64, 0.54, 1.0);\\n'+\n                    'if (i == 15) c = vec4(0.9, 0.68, 0.4, 1.0);\\n'+\n                    'if (i == 16) c = vec4(0.66, 0.67, 0.68, 1.0);\\n'+\n                    'if (i == 17) c = vec4(0.86, 0.13, 0.15, 1.0);\\n'+\n                    'if (i == 18) c = vec4(0.3, 0.44, 0.64, 1.0);\\n'+\n                    'if (i == 19) c = vec4(1.0, 0.98, 1.0, 1.0);\\n'+\n                    'c = c * c2;\\n'+\n                    */\n\n                    'if (i == 1 || i == 2 || i == 5 || i == 6) c = vec4(146.0, 178.0, 144.0, 255.0);\\n'+\n                    'if (i == 3 || i == 4) c = vec4(94.0, 169.0, 133.0, 255.0);\\n'+\n                    'if (i == 8 || i == 11) c = vec4(238.0, 221.0, 185.0, 255.0);\\n'+\n                    'if (i == 7) c = vec4(226.0, 192.0, 154.0, 255.0);\\n'+\n                    'if (i == 9 || i == 10 || i == 12) c = vec4(250.0, 246.0, 167.0, 255.0);\\n'+\n                    'if (i == 13 || i == 16) c = vec4(245.0, 236.0, 211.0, 255.0);\\n'+\n                    'if (i == 14) c = vec4(139.0, 185.0, 166.0, 255.0);\\n'+\n                    'if (i == 15) c = vec4(199.0, 219.0, 155.0, 255.0);\\n'+\n                    'if (i == 17) c = vec4(149.0, 132.0, 162.0, 255.0);\\n'+\n                    'if (i == 18 || i == 0) c = vec4(188.0, 221.0, 255.0, 255.0);\\n'+\n                    'if (i == 19) c = vec4(255.0, 255.0, 255.0, 255.0);\\n'+\n                    'c = (c*(1.0/255.0)) * c2;\\n'+\n                '#endif\\n'+\n\n            '#else\\n'+\n                'vec4 c = c2;\\n'+\n            '#endif\\n'+\n        '#endif\\n'+\n\n        '#ifdef fog\\n'+\n            'gl_FragColor = mix(uFogColor, c, vFogFactor);\\n'+\n        '#else\\n'+\n            'gl_FragColor = c;\\n'+\n        '#endif\\n'+\n    '}';\n\n//textured tile mesh\nGpuShaders.tileVertexShader =\n    'attribute vec3 aPosition;\\n'+\n\n    '#ifdef onlyFog\\n'+\n        'varying float vFogFactor;\\n'+\n    '#else\\n'+\n\n        '#ifdef externalTex\\n'+\n            'attribute vec2 aTexCoord2;\\n'+\n        '#else\\n'+\n            'attribute vec2 aTexCoord;\\n'+\n        '#endif\\n'+\n    \n        'varying vec3 vTexCoord;\\n'+  //u,v,fogFactor\n\n    '#endif\\n'+\n                                             //0-3                            4-7          8-11            12-15 \n    'uniform mat4 uMV, uProj, uParams;\\n'+  //[zfactor, fogDensity, scale.xy][camVec.xyzw][transform.xyzw][scale.z, trans.xyz]\n\n    'void main() {\\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'vec3 worldPos = vec3(aPosition.x * uParams[0][2] + uParams[3][1], aPosition.y * uParams[0][3] + uParams[3][2], aPosition.z * uParams[3][0] + uParams[3][3]);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'float fogFactor = 1.0-exp(uParams[0][1] * camDist);\\n'+\n        'float l = dot(normalize(worldPos.xyz), vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\\n'+\n        'fogFactor = clamp((1.0-abs(l))*uParams[1][3] + fogFactor, 0.0, 1.0);\\n'+\n\n        '#ifdef onlyFog\\n'+\n            'vFogFactor = fogFactor;\\n'+\n        '#else\\n'+\n            'vTexCoord.z = fogFactor;\\n'+\n\n            '#ifdef externalTex\\n'+\n                'vTexCoord.xy = vec2(uParams[2][0] * aTexCoord2[0] + uParams[2][2], uParams[2][1] * aTexCoord2[1] + uParams[2][3]);\\n'+\n            '#else\\n'+\n                'vTexCoord.xy = aTexCoord;\\n'+\n            '#endif\\n'+\n\n        '#endif\\n'+\n    '}';\n\nGpuShaders.tileFragmentShader = 'precision mediump float;\\n'+\n\n    '#ifdef onlyFog\\n'+\n        'varying float vFogFactor;\\n'+\n    '#else\\n'+\n\n        'varying vec3 vTexCoord;\\n'+\n        'uniform sampler2D uSampler;\\n'+\n\n        '#ifdef mask\\n'+\n            'uniform sampler2D uSampler2;\\n'+\n        '#endif\\n'+\n\n    '#endif\\n'+\n\n    'uniform vec4 uParams2;\\n'+        \n    'void main() {\\n'+\n        'vec4 fogColor = vec4(uParams2.xyz, 1.0);\\n'+\n\n        '#ifdef onlyFog\\n'+\n            'gl_FragColor = vec4(fogColor.xyz, vFogFactor);\\n'+\n        '#else\\n'+\n\n            '#ifdef externalTex\\n'+\n                'vec4 c = texture2D(uSampler, vTexCoord.xy);\\n'+'__FILTER__' +\n                'vec4 cc = mix(c, fogColor, vTexCoord.z);\\n'+\n                '#ifdef mask\\n'+\n                    'vec4 c2 = texture2D(uSampler2, vTexCoord.xy);\\n'+\n                    'cc.w = c.w * uParams2.z * c2.x;\\n'+\n                '#else\\n'+\n                    'cc.w = c.w * uParams2.z;\\n'+\n                '#endif\\n'+\n\n                'gl_FragColor = cc;\\n'+\n            '#else\\n'+\n                'gl_FragColor = mix(texture2D(uSampler, vTexCoord.xy), fogColor, vTexCoord.z);\\n'+\n            '#endif\\n'+\n\n        '#endif\\n'+\n    '}';\n\n\n//textured shaded tile mesh\nGpuShaders.tileTShadedVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'attribute vec3 aNormal;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform mat3 uNorm;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'varying float vFogFactor;\\n'+\n    'void main() {\\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uFogDensity * camDist);\\n'+\n        'vTexCoord = aTexCoord;\\n'+\n        'vPosition = camSpacePos;\\n'+\n        'vNormal = aNormal * uNorm;\\n'+\n    '}';\n\n\nGpuShaders.tileTShadedFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'uniform mat4 uMaterial;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec3 ldir = normalize(-vPosition.xyz);\\n'+\n        'vec3 normal = normalize(vNormal);\\n'+\n        'vec3 eyeDir = ldir;\\n'+\n        'vec3 refDir = reflect(-ldir, normal);\\n'+\n        'float specW = min(1.0, pow(max(dot(refDir, eyeDir), 0.0), uMaterial[3][0]));\\n'+\n        'float diffW = min(1.0, max(dot(normal, ldir), 0.0));\\n'+\n        'vec4 lcolor = uMaterial[0]+(uMaterial[1]*diffW)+(uMaterial[2]*specW);\\n'+\n        'vec4 tcolor = texture2D(uSampler, vTexCoord);\\n'+\n        'gl_FragColor = mix(uFogColor, vec4(lcolor.xyz*(1.0/255.0), 1.0) * tcolor, vFogFactor); gl_FragColor.w *= uMaterial[3][1];\\n'+\n    '}';\n\n\nGpuShaders.tileShadedFragmentShader = 'precision mediump float;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec4 vPosition;\\n'+\n    'varying vec3 vNormal;\\n'+\n    'uniform mat4 uMaterial;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'void main() {\\n'+\n        'vec3 ldir = normalize(-vPosition.xyz);\\n'+\n        'vec3 normal = normalize(vNormal);\\n'+\n        'vec3 eyeDir = ldir;\\n'+\n        'vec3 refDir = reflect(-ldir, normal);\\n'+\n        'float specW = min(1.0,pow(max(dot(refDir, eyeDir), 0.0), uMaterial[3][0]));\\n'+\n        'float diffW = min(1.0,max(dot(normal, ldir), 0.0));\\n'+\n        'vec4 lcolor = uMaterial[0]+(uMaterial[1]*diffW)+(uMaterial[2]*specW);\\n'+\n        'gl_FragColor = mix(uFogColor, vec4(lcolor.xyz*(1.0/255.0), 1.0), vFogFactor);  gl_FragColor.w = uMaterial[3][1];\\n'+\n    '}';\n\n//flat shade tile mesh\nGpuShaders.tileFlatShadeVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'attribute vec3 aBarycentric;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n    'varying float vFogFactor;\\n'+\n    'void main() {\\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uFogDensity * camDist);\\n'+\n        'vTexCoord = aTexCoord;\\n'+\n        'vBarycentric = camSpacePos.xyz;\\n'+\n    '}';\n\n\nGpuShaders.tileFlatShadeFragmentShader = 'precision mediump float;\\n'+\n    '#extension GL_OES_standard_derivatives : enable\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n    'varying float vFogFactor;\\n'+\n    'void main() {\\n'+\n        '#ifdef GL_OES_standard_derivatives\\n'+\n            'vec3 nx = dFdx(vBarycentric);\\n'+\n            'vec3 ny = dFdy(vBarycentric);\\n'+\n            'vec3 normal=normalize(cross(nx,ny));\\n'+\n            'gl_FragColor = vec4(vec3(max(0.0,normal.z*(204.0/255.0))+(32.0/255.0)),1.0);\\n'+\n        '#else\\n'+\n            'gl_FragColor = vec4(1.0,1.0,1.0,1.0);\\n'+\n        '#endif\\n'+\n    '}';\n\n//textured wire frame tile mesh\nGpuShaders.tileWireframeVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord;\\n'+\n    'attribute vec3 aBarycentric;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n    'varying float vFogFactor;\\n'+\n    'void main() {\\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uFogDensity * camDist);\\n'+\n        'vTexCoord = aTexCoord;\\n'+\n        'vBarycentric = aBarycentric;\\n'+\n    '}';\n\n\nGpuShaders.tileWireframeFragmentShader = 'precision mediump float;\\n'+\n    '#extension GL_OES_standard_derivatives : enable\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    //'const vec4 uFogColor = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'float edgeFactor(){\\n'+\n        '#ifdef GL_OES_standard_derivatives\\n'+\n            'vec3 d = fwidth(vBarycentric);\\n'+\n            'vec3 a3 = smoothstep(vec3(0.0), d*1.0, vBarycentric);\\n'+\n            'return min(min(a3.x, a3.y), a3.z);\\n'+\n        '#else\\n'+\n            'float a = min(min(vBarycentric.x, vBarycentric.y), vBarycentric.z);\\n'+\n            'return a > 0.1 ? 1.0 : smoothstep(0.0,1.0,a*10.0);\\n'+\n        '#endif\\n'+\n    '}\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = mix(uFogColor, vec4( mix(vec3(0.0), texture2D(uSampler, vTexCoord).rgb, edgeFactor()) , 1.0), vFogFactor);\\n'+\n    '}';\n\n\nGpuShaders.tileWireframe2FragmentShader = 'precision mediump float;\\n'+\n    '#extension GL_OES_standard_derivatives : enable\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n    'varying float vFogFactor;\\n'+\n    'uniform vec4 uFogColor;\\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\\n'+\n    'float edgeFactor(){\\n'+\n        '#ifdef GL_OES_standard_derivatives\\n'+\n            'vec3 d = fwidth(vBarycentric);\\n'+\n            'vec3 a3 = smoothstep(vec3(0.0), d*1.0, vBarycentric);\\n'+\n            'return min(min(a3.x, a3.y), a3.z);\\n'+\n        '#else\\n'+\n            'float a = min(min(vBarycentric.x, vBarycentric.y), vBarycentric.z);\\n'+\n            'return a > 0.1 ? 1.0 : smoothstep(0.0,1.0,a*10.0);\\n'+\n        '#endif\\n'+\n    '}\\n'+\n    'void main() {\\n'+\n        'if (edgeFactor() < 0.5){ gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); } else { discard; }'+ \n    '}';\n\n//textured wire frame tile mesh\nGpuShaders.tileWireframe3VertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'attribute vec2 aTexCoord2;\\n'+\n    'attribute vec3 aBarycentric;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'uniform float uFogDensity;\\n'+\n    'varying vec2 vTexCoord;\\n'+\n    'varying vec3 vBarycentric;\\n'+\n    'varying float vFogFactor;\\n'+\n    'void main() {\\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vFogFactor = exp(uFogDensity * camDist);\\n'+\n        'vTexCoord = aTexCoord2;\\n'+\n        'vBarycentric = aBarycentric;\\n'+\n    '}';\n\n//depth encoded tile mesh\nGpuShaders.tileDepthVertexShader =\n    'attribute vec3 aPosition;\\n'+\n    'uniform mat4 uMV, uProj;\\n'+\n    'varying float vDepth;\\n'+\n    'void main() {\\n'+\n        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\\n'+\n        'gl_Position = uProj * camSpacePos;\\n'+\n        'float camDist = length(camSpacePos.xyz);\\n'+\n        'vDepth = camDist;\\n'+\n    '}';\n\n\nGpuShaders.tileDepthFragmentShader = 'precision mediump float;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'varying float vDepth;\\n'+\n    'void main() {\\n'+\n        'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\\n'+\n    '}';\n\n//used for 2d images\nGpuShaders.imageVertexShader = '\\n'+\n    'attribute vec4 aPosition;\\n'+\n    'uniform mat4 uProjectionMatrix;\\n'+\n    'uniform mat4 uData;\\n'+\n    'uniform vec4 uColor;\\n'+\n    'uniform float uDepth;\\n'+\n    'varying vec4 vColor;\\n'+\n    'varying vec2 vTexcoords;\\n'+\n    'void main(void){\\n'+\n        'int i=int(aPosition.x);\\n'+\n        //\"gl_Position=uProjectionMatrix*vec4(floor(uData[i][0]+0.1),floor(uData[i][1]+0.1),0.0,1.0);\\n\"+\n        //IE11 :(\n\n        'if(i==0) gl_Position=uProjectionMatrix*vec4(floor(uData[0][0]+0.1),floor(uData[0][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[0][2], uData[0][3]);\\n'+\n        'if(i==1) gl_Position=uProjectionMatrix*vec4(floor(uData[1][0]+0.1),floor(uData[1][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[1][2], uData[1][3]);\\n'+\n        'if(i==2) gl_Position=uProjectionMatrix*vec4(floor(uData[2][0]+0.1),floor(uData[2][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[2][2], uData[2][3]);\\n'+\n        'if(i==3) gl_Position=uProjectionMatrix*vec4(floor(uData[3][0]+0.1),floor(uData[3][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[3][2], uData[3][3]);\\n'+\n\n        'vec4 c=uColor;\\n'+\n        'c.w*=1.0;\\n'+\n        'vColor=c;\\n'+\n    '}';\n\n\nGpuShaders.imageFragmentShader = 'precision mediump float;\\n'+\n    'varying vec4 vColor;\\n'+\n    'varying vec2 vTexcoords;\\n'+\n    'uniform sampler2D uSampler;\\n'+\n    'void main(void){\\n'+\n        'vec4 c=texture2D(uSampler, vec2(vTexcoords.x, vTexcoords.y) );\\n'+\n        'c*=vColor;\\n'+\n        'if(c.w < 0.01){ discard; }\\n'+\n        'gl_FragColor = c;\\n'+\n    '}';\n    \n\nexport default GpuShaders;\n\n\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/shaders.js\n// module id = 58\n// module chunks = 0 1","\nimport Proj4 from 'proj4';\nimport earcut from 'earcut';\nimport {Core as Core_} from './core';\n//import {CoreInterface as CoreInterface_} from './interface';\n\n//get rid of compiler mess\n//var CoreInterface = CoreInterface_;\nvar Core = Core_;\nvar proj4 = Proj4;\n\n\nvar CoreInterface = function(element, config) {\n    this.core = new Core(element, config, this);\n\n    Object.defineProperty(this, 'map', {\n        get: function() {\n            if (!this.core) { return null; }\n            return this.core.getMapInterface();\n        }\n    });\n\n    Object.defineProperty(this, 'renderer', {\n        get: function() {\n            if (!this.core) { return null; }\n            return this.core.getRendererInterface();\n        }\n    });\n\n    Object.defineProperty(this, 'proj4', {\n        get: function() {\n            if (!this.core) { return null; }\n            return proj4;\n        }\n    });\n\n    Object.defineProperty(this, 'earcut', {\n        get: function() {\n            if (!this.core) { return null; }\n            return earcut;\n        }\n    });\n};\n\n\nCoreInterface.prototype.destroy = function() {\n    this.core.destroy();\n    this.core = null;\n};\n\n\nCoreInterface.prototype.loadMap = function(path) {\n    if (!this.core) { return null; }\n    return this.core.loadMap(path);\n};\n\n\nCoreInterface.prototype.destroyMap = function() {\n    if (!this.core) { return null; }\n    return this.core.destroyMap();\n};\n\n\n/*CoreInterface.prototype.getMap = function() {\n    if (!this.core) { return null; }\n    return this.core.getMapInterface();\n};\n\n\nCoreInterface.prototype.getRenderer = function() {\n    if (!this.core) { return null; }\n    return this.core.getRendererInterface();\n};\n\n\nCoreInterface.prototype.getProj4 = function() {\n    if (!this.core) { return null; }\n    return this.core.getProj4();\n};*/\n\n\nCoreInterface.prototype.on = function(eventName, call) {\n    if (!this.core) { return null; }\n    return this.core.on(eventName, call);\n};\n\nCoreInterface.prototype.once = function(eventName, call, wait) {\n    if (!this.core) { return null; }\n    return this.core.once(eventName, call, wait);\n};\n\nCoreInterface.prototype.callListener = function(name, event) {\n    if (!this.core) { return null; }\n    this.core.callListener(name, event);\n};\n\n\nexport {CoreInterface};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/interface.js\n// module id = 59\n// module chunks = 0 1","import {toPoint, forward} from 'mgrs';\n\nfunction Point(x, y, z) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y, z);\n  }\n  if (Array.isArray(x)) {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2] || 0.0;\n  } else if(typeof x === 'object') {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z || 0.0;\n  } else if (typeof x === 'string' && typeof y === 'undefined') {\n    var coords = x.split(',');\n    this.x = parseFloat(coords[0], 10);\n    this.y = parseFloat(coords[1], 10);\n    this.z = parseFloat(coords[2], 10) || 0.0;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z || 0.0;\n  }\n  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');\n}\n\nPoint.fromMGRS = function(mgrsStr) {\n  return new Point(toPoint(mgrsStr));\n};\nPoint.prototype.toMGRS = function(accuracy) {\n  return forward([this.x, this.y], accuracy);\n};\nexport default Point;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/Point.js\n// module id = 60\n// module chunks = 0 1","export default function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  var out = {};\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      t = 'x';\n    }\n    else if (i === 1) {\n      v = yin;\n      t = 'y';\n    }\n    else {\n      v = zin;\n      t = 'z';\n    }\n    switch (crs.axis[i]) {\n    case 'e':\n      out[t] = v;\n      break;\n    case 'w':\n      out[t] = -v;\n      break;\n    case 'n':\n      out[t] = v;\n      break;\n    case 's':\n      out[t] = -v;\n      break;\n    case 'u':\n      if (point[t] !== undefined) {\n        out.z = v;\n      }\n      break;\n    case 'd':\n      if (point[t] !== undefined) {\n        out.z = -v;\n      }\n      break;\n    default:\n      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n      return null;\n    }\n  }\n  return out;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/adjust_axis.js\n// module id = 61\n// module chunks = 0 1","import adjust_lon from './adjust_lon';\n\nexport default function(zone, lon) {\n  if (zone === undefined) {\n    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;\n\n    if (zone < 0) {\n      return 0;\n    } else if (zone > 60) {\n      return 60;\n    }\n  }\n  return zone;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/adjust_zone.js\n// module id = 62\n// module chunks = 0 1","import hypot from './hypot';\nimport log1py from './log1py';\n\nexport default function(x) {\n  var y = Math.abs(x);\n  y = log1py(y * (1 + y / (hypot(1, y) + 1)));\n\n  return x < 0 ? -y : y;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/asinhy.js\n// module id = 63\n// module chunks = 0 1","export default function(pp, arg_r) {\n  var r = 2 * Math.cos(arg_r);\n  var i = pp.length - 1;\n  var hr1 = pp[i];\n  var hr2 = 0;\n  var hr;\n\n  while (--i >= 0) {\n    hr = -hr2 + r * hr1 + pp[i];\n    hr2 = hr1;\n    hr1 = hr;\n  }\n\n  return Math.sin(arg_r) * hr;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/clens.js\n// module id = 64\n// module chunks = 0 1","import sinh from './sinh';\nimport cosh from './cosh';\n\nexport default function(pp, arg_r, arg_i) {\n  var sin_arg_r = Math.sin(arg_r);\n  var cos_arg_r = Math.cos(arg_r);\n  var sinh_arg_i = sinh(arg_i);\n  var cosh_arg_i = cosh(arg_i);\n  var r = 2 * cos_arg_r * cosh_arg_i;\n  var i = -2 * sin_arg_r * sinh_arg_i;\n  var j = pp.length - 1;\n  var hr = pp[j];\n  var hi1 = 0;\n  var hr1 = 0;\n  var hi = 0;\n  var hr2;\n  var hi2;\n\n  while (--j >= 0) {\n    hr2 = hr1;\n    hi2 = hi1;\n    hr1 = hr;\n    hi1 = hi;\n    hr = -hr2 + r * hr1 - i * hi1 + pp[j];\n    hi = -hi2 + i * hr1 + r * hi1;\n  }\n\n  r = sin_arg_r * cosh_arg_i;\n  i = cos_arg_r * sinh_arg_i;\n\n  return [r * hr - i * hi, r * hi + i * hr];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/clens_cmplx.js\n// module id = 65\n// module chunks = 0 1","export default function(x) {\n  var r = Math.exp(x);\n  r = (r + 1 / r) / 2;\n  return r;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/cosh.js\n// module id = 66\n// module chunks = 0 1","export default function(pp, B) {\n  var cos_2B = 2 * Math.cos(2 * B);\n  var i = pp.length - 1;\n  var h1 = pp[i];\n  var h2 = 0;\n  var h;\n\n  while (--i >= 0) {\n    h = -h2 + cos_2B * h1 + pp[i];\n    h2 = h1;\n    h1 = h;\n  }\n\n  return (B + h * Math.sin(2 * B));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/gatg.js\n// module id = 67\n// module chunks = 0 1","import {HALF_PI} from '../constants/values';\n\nexport default function(eccent, q) {\n  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));\n  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {\n    if (q < 0) {\n      return (-1 * HALF_PI);\n    }\n    else {\n      return HALF_PI;\n    }\n  }\n  //var phi = 0.5* q/(1-eccent*eccent);\n  var phi = Math.asin(0.5 * q);\n  var dphi;\n  var sin_phi;\n  var cos_phi;\n  var con;\n  for (var i = 0; i < 30; i++) {\n    sin_phi = Math.sin(phi);\n    cos_phi = Math.cos(phi);\n    con = eccent * sin_phi;\n    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //console.log(\"IQSFN-CONV:Latitude failed to converge after 30 iterations\");\n  return NaN;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/iqsfnz.js\n// module id = 68\n// module chunks = 0 1","export default function(x) {\n  var y = 1 + x;\n  var z = y - 1;\n\n  return z === 0 ? x : x * Math.log(y) / z;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/log1py.js\n// module id = 69\n// module chunks = 0 1","export default function(esinp, exp) {\n  return (Math.pow((1 - esinp) / (1 + esinp), exp));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/common/srat.js\n// module id = 70\n// module chunks = 0 1","var exports = {};\nexport {exports as default};\nexports.wgs84 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"WGS84\",\n  datumName: \"WGS84\"\n};\n\nexports.ch1903 = {\n  towgs84: \"674.374,15.056,405.346\",\n  ellipse: \"bessel\",\n  datumName: \"swiss\"\n};\n\nexports.ggrs87 = {\n  towgs84: \"-199.87,74.79,246.62\",\n  ellipse: \"GRS80\",\n  datumName: \"Greek_Geodetic_Reference_System_1987\"\n};\n\nexports.nad83 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"GRS80\",\n  datumName: \"North_American_Datum_1983\"\n};\n\nexports.nad27 = {\n  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n  ellipse: \"clrk66\",\n  datumName: \"North_American_Datum_1927\"\n};\n\nexports.potsdam = {\n  towgs84: \"606.0,23.0,413.0\",\n  ellipse: \"bessel\",\n  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n};\n\nexports.carthage = {\n  towgs84: \"-263.0,6.0,431.0\",\n  ellipse: \"clark80\",\n  datumName: \"Carthage 1934 Tunisia\"\n};\n\nexports.hermannskogel = {\n  towgs84: \"653.0,-212.0,449.0\",\n  ellipse: \"bessel\",\n  datumName: \"Hermannskogel\"\n};\n\nexports.ire65 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"mod_airy\",\n  datumName: \"Ireland 1965\"\n};\n\nexports.rassadiran = {\n  towgs84: \"-133.63,-157.5,-158.62\",\n  ellipse: \"intl\",\n  datumName: \"Rassadiran\"\n};\n\nexports.nzgd49 = {\n  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n  ellipse: \"intl\",\n  datumName: \"New Zealand Geodetic Datum 1949\"\n};\n\nexports.osgb36 = {\n  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n  ellipse: \"airy\",\n  datumName: \"Airy 1830\"\n};\n\nexports.s_jtsk = {\n  towgs84: \"589,76,480\",\n  ellipse: 'bessel',\n  datumName: 'S-JTSK (Ferro)'\n};\n\nexports.beduaram = {\n  towgs84: '-106,-87,188',\n  ellipse: 'clrk80',\n  datumName: 'Beduaram'\n};\n\nexports.gunung_segara = {\n  towgs84: '-403,684,41',\n  ellipse: 'bessel',\n  datumName: 'Gunung Segara Jakarta'\n};\n\nexports.rnb72 = {\n  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n  ellipse: \"intl\",\n  datumName: \"Reseau National Belge 1972\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/constants/Datum.js\n// module id = 71\n// module chunks = 0 1","var exports = {};\nexport {exports as default};\nexports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: \"MERIT 1983\"\n};\n\nexports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: \"Soviet Geodetic System 85\"\n};\n\nexports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: \"GRS 1980(IUGG, 1980)\"\n};\n\nexports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: \"IAU 1976\"\n};\n\nexports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: \"Airy 1830\"\n};\n\nexports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: \"Appl. Physics. 1965\"\n};\n\nexports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"Naval Weapons Lab., 1965\"\n};\n\nexports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: \"Modified Airy\"\n};\n\nexports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n};\n\nexports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: \"Australian Natl & S. Amer. 1969\"\n};\n\nexports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: \"GRS 67(IUGG 1967)\"\n};\n\nexports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841\"\n};\n\nexports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841 (Namibia)\"\n};\n\nexports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: \"Clarke 1866\"\n};\n\nexports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: \"Clarke 1880 mod.\"\n};\n\nexports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: \"Clarke 1858\"\n};\n\nexports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: \"Comm. des Poids et Mesures 1799\"\n};\n\nexports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: \"Delambre 1810 (Belgium)\"\n};\n\nexports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: \"Engelis 1985\"\n};\n\nexports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: \"Everest 1830\"\n};\n\nexports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: \"Everest 1948\"\n};\n\nexports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: \"Everest 1956\"\n};\n\nexports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: \"Everest 1969\"\n};\n\nexports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: \"Everest (Sabah & Sarawak)\"\n};\n\nexports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: \"Fischer (Mercury Datum) 1960\"\n};\n\nexports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1960\"\n};\n\nexports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: \"Fischer 1968\"\n};\n\nexports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: \"Helmert 1906\"\n};\n\nexports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: \"Hough\"\n};\n\nexports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: \"International 1909 (Hayford)\"\n};\n\nexports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: \"Kaula 1961\"\n};\n\nexports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: \"Lerch 1979\"\n};\n\nexports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: \"Maupertius 1738\"\n};\n\nexports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: \"New International 1967\"\n};\n\nexports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: \"Plessis 1817 (France)\"\n};\n\nexports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: \"Krassovsky, 1942\"\n};\n\nexports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: \"Southeast Asia\"\n};\n\nexports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: \"Walbeck\"\n};\n\nexports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: \"WGS 60\"\n};\n\nexports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: \"WGS 66\"\n};\n\nexports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: \"WGS 72\"\n};\n\nexport var WGS84 = exports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: \"WGS 84\"\n};\n\nexports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: \"Normal Sphere (r=6370997)\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/constants/Ellipsoid.js\n// module id = 72\n// module chunks = 0 1","var exports = {};\nexport {exports as default};\n\nexports.greenwich = 0.0; //\"0dE\",\nexports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\nexports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\nexports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\nexports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\nexports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\nexports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\nexports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\nexports.ferro = -17.666666666667; //\"17d40'W\",\nexports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\nexports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\nexports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\nexports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/constants/PrimeMeridian.js\n// module id = 73\n// module chunks = 0 1","export default {\n  ft: {to_meter: 0.3048},\n  'us-ft': {to_meter: 1200 / 3937}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/constants/units.js\n// module id = 74\n// module chunks = 0 1","import proj from './Proj';\nimport transform from './transform';\nvar wgs84 = proj('WGS84');\n\nfunction transformer(from, to, coords) {\n  var transformedArray;\n  if (Array.isArray(coords)) {\n    transformedArray = transform(from, to, coords);\n    if (coords.length === 3) {\n      return [transformedArray.x, transformedArray.y, transformedArray.z];\n    }\n    else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  }\n  else {\n    return transform(from, to, coords);\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof proj) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return proj(item);\n}\nfunction proj4(fromProj, toProj, coord, retProj) {\n  if(retProj) {\n    return fromProj;\n  }\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === 'undefined') {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  }\n  else {\n    obj = {\n      forward: function (coords) {\n        return transformer(fromProj, toProj, coords);\n      },\n      inverse: function (coords) {\n        return transformer(toProj, fromProj, coords);\n      },\n      info: function () {\n        return {\n          \"a\": toProj.a,\n          \"b\": toProj.b,\n          \"ra\": toProj.R_A,\n          \"proj-name\": toProj.projName\n        };\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\nexport default proj4;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/core.js\n// module id = 75\n// module chunks = 0 1","import {PJD_3PARAM, PJD_7PARAM, PJD_WGS84, PJD_NODATUM, SEC_TO_RAD} from './constants/values';\n\nfunction datum(datumCode, datum_params, a, b, es, ep2) {\n  var out = {};\n\n  if (datumCode === undefined || datumCode === 'none') {\n    out.datum_type = PJD_NODATUM;\n  } else {\n    out.datum_type = PJD_WGS84;\n  }\n\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = PJD_3PARAM;\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = PJD_7PARAM;\n        out.datum_params[3] *= SEC_TO_RAD;\n        out.datum_params[4] *= SEC_TO_RAD;\n        out.datum_params[5] *= SEC_TO_RAD;\n        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n  out.a = a; //datum object also uses these values\n  out.b = b;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\n\nexport default datum;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/datum.js\n// module id = 76\n// module chunks = 0 1","import {PJD_3PARAM, PJD_7PARAM, PJD_NODATUM} from './constants/values';\n\nimport {geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums} from './datumUtils';\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n  // Do we need to go through geocentric coordinates?\n  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source.es, source.a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/datum_transform.js\n// module id = 77\n// module chunks = 0 1","import {SIXTH, RA4, RA6, EPSLN} from './constants/values';\nimport {default as Ellipsoid, WGS84} from './constants/Ellipsoid';\nimport match from './match';\n\nexport function eccentricity(a, b, rf, R_A) {\n  var a2 = a * a; // used in geocentric\n  var b2 = b * b; // used in geocentric\n  var es = (a2 - b2) / a2; // e ^ 2\n  var e = 0;\n  if (R_A) {\n    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n    a2 = a * a;\n    es = 0;\n  } else {\n    e = Math.sqrt(es); // eccentricity\n  }\n  var ep2 = (a2 - b2) / b2; // used in geocentric\n  return {\n    es: es,\n    e: e,\n    ep2: ep2\n  };\n}\nexport function sphere(a, b, rf, ellps, sphere) {\n  if (!a) { // do we have an ellipsoid?\n    var ellipse = match(Ellipsoid, ellps);\n    if (!ellipse) {\n      ellipse = WGS84;\n    }\n    a = ellipse.a;\n    b = ellipse.b;\n    rf = ellipse.rf;\n  }\n\n  if (rf && !b) {\n    b = (1.0 - 1.0 / rf) * a;\n  }\n  if (rf === 0 || Math.abs(a - b) < EPSLN) {\n    sphere = true;\n    b = a;\n  }\n  return {\n    a: a,\n    b: b,\n    rf: rf,\n    sphere: sphere\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/deriveConstants.js\n// module id = 78\n// module chunks = 0 1","export default function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/extend.js\n// module id = 79\n// module chunks = 0 1","export default function(defs) {\n  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n  defs.WGS84 = defs['EPSG:4326'];\n  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n  defs.GOOGLE = defs['EPSG:3857'];\n  defs['EPSG:900913'] = defs['EPSG:3857'];\n  defs['EPSG:102113'] = defs['EPSG:3857'];\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/global.js\n// module id = 80\n// module chunks = 0 1","import defs from './defs';\nimport wkt from 'wkt-parser';\nimport projStr from './projString';\nfunction testObj(code){\n  return typeof code === 'string';\n}\nfunction testDef(code){\n  return code in defs;\n}\n var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS']; \nfunction testWKT(code){\n  return codeWords.some(function (word) {\n    return code.indexOf(word) > -1;\n  });\n}\nfunction testProj(code){\n  return code[0] === '+';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return defs[code];\n    }\n    if (testWKT(code)) {\n      return wkt(code);\n    }\n    if (testProj(code)) {\n      return projStr(code);\n    }\n  }else{\n    return code;\n  }\n}\n\nexport default parse;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/parseCode.js\n// module id = 81\n// module chunks = 0 1","import merc from \"./projections/merc\";\nimport longlat from \"./projections/longlat\";\nvar projs = [merc, longlat];\nvar names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\nexport {add};\n\nexport function get(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n    return projStore[names[n]];\n  }\n}\n\nexport function start() {\n  projs.forEach(add);\n}\nexport default {\n  start: start,\n  add: add,\n  get: get\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections.js\n// module id = 82\n// module chunks = 0 1","import msfnz from '../common/msfnz';\nimport qsfnz from '../common/qsfnz';\nimport adjust_lon from '../common/adjust_lon';\nimport asinz from '../common/asinz';\nimport {EPSLN} from '../constants/values';\n\nexport function init() {\n\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e3 = Math.sqrt(this.es);\n\n  this.sin_po = Math.sin(this.lat1);\n  this.cos_po = Math.cos(this.lat1);\n  this.t1 = this.sin_po;\n  this.con = this.sin_po;\n  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat2);\n  this.cos_po = Math.cos(this.lat2);\n  this.t2 = this.sin_po;\n  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat0);\n  this.cos_po = Math.cos(this.lat0);\n  this.t3 = this.sin_po;\n  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);\n  }\n  else {\n    this.ns0 = this.con;\n  }\n  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;\n  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;\n}\n\n/* Albers Conical Equal Area forward equations--mapping lat,long to x,y\n  -------------------------------------------------------------------*/\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  this.sin_phi = Math.sin(lat);\n  this.cos_phi = Math.cos(lat);\n\n  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);\n  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;\n  var theta = this.ns0 * adjust_lon(lon - this.long0);\n  var x = rh1 * Math.sin(theta) + this.x0;\n  var y = this.rh - rh1 * Math.cos(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var rh1, qs, con, theta, lon, lat;\n\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  if (this.ns0 >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n  con = rh1 * this.ns0 / this.a;\n  if (this.sphere) {\n    lat = Math.asin((this.c - con * con) / (2 * this.ns0));\n  }\n  else {\n    qs = (this.c - con * con) / this.ns0;\n    lat = this.phi1z(this.e3, qs);\n  }\n\n  lon = adjust_lon(theta / this.ns0 + this.long0);\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\n/* Function to compute phi1, the latitude for the inverse of the\n   Albers Conical Equal-Area projection.\n-------------------------------------------*/\nexport function phi1z(eccent, qs) {\n  var sinphi, cosphi, con, com, dphi;\n  var phi = asinz(0.5 * qs);\n  if (eccent < EPSLN) {\n    return phi;\n  }\n\n  var eccnts = eccent * eccent;\n  for (var i = 1; i <= 25; i++) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    con = eccent * sinphi;\n    com = 1 - con * con;\n    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi = phi + dphi;\n    if (Math.abs(dphi) <= 1e-7) {\n      return phi;\n    }\n  }\n  return null;\n}\n\nexport var names = [\"Albers_Conic_Equal_Area\", \"Albers\", \"aea\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  phi1z: phi1z\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/aea.js\n// module id = 83\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\nimport {HALF_PI, EPSLN} from '../constants/values';\n\nimport mlfn from '../common/mlfn';\nimport e0fn from '../common/e0fn';\nimport e1fn from '../common/e1fn';\nimport e2fn from '../common/e2fn';\nimport e3fn from '../common/e3fn';\nimport gN from '../common/gN';\nimport asinz from '../common/asinz';\nimport imlfn from '../common/imlfn';\n\n\n\nexport function init() {\n  this.sin_p12 = Math.sin(this.lat0);\n  this.cos_p12 = Math.cos(this.lat0);\n}\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinphi = Math.sin(p.y);\n  var cosphi = Math.cos(p.y);\n  var dlon = adjust_lon(lon - this.long0);\n  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;\n  if (this.sphere) {\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North Pole case\n      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);\n      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South Pole case\n      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);\n      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //default case\n      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);\n      c = Math.acos(cos_c);\n      kp = c / Math.sin(c);\n      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);\n      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));\n      return p;\n    }\n  }\n  else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North Pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);\n      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South Pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);\n      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //Default case\n      tanphi = sinphi / cosphi;\n      Nl1 = gN(this.a, this.e, this.sin_p12);\n      Nl = gN(this.a, this.e, sinphi);\n      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));\n      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));\n      if (Az === 0) {\n        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {\n        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else {\n        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));\n      }\n      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);\n      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);\n      GH = G * H;\n      Hs = H * H;\n      s2 = s * s;\n      s3 = s2 * s;\n      s4 = s3 * s;\n      s5 = s4 * s;\n      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);\n      p.x = this.x0 + c * Math.sin(Az);\n      p.y = this.y0 + c * Math.cos(Az);\n      return p;\n    }\n  }\n\n\n}\n\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;\n  if (this.sphere) {\n    rh = Math.sqrt(p.x * p.x + p.y * p.y);\n    if (rh > (2 * HALF_PI * this.a)) {\n      return;\n    }\n    z = rh / this.a;\n\n    sinz = Math.sin(z);\n    cosz = Math.cos(z);\n\n    lon = this.long0;\n    if (Math.abs(rh) <= EPSLN) {\n      lat = this.lat0;\n    }\n    else {\n      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);\n      con = Math.abs(this.lat0) - HALF_PI;\n      if (Math.abs(con) <= EPSLN) {\n        if (this.lat0 >= 0) {\n          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n        }\n        else {\n          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n        }\n      }\n      else {\n        /*con = cosz - this.sin_p12 * Math.sin(lat);\n        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {\n          //no-op, just keep the lon value as is\n        } else {\n          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));\n          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));\n        }*/\n        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));\n      }\n    }\n\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = Mlp - rh;\n      lat = imlfn(M / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = rh - Mlp;\n\n      lat = imlfn(M / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else {\n      //default case\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      Az = Math.atan2(p.x, p.y);\n      N1 = gN(this.a, this.e, this.sin_p12);\n      cosAz = Math.cos(Az);\n      tmp = this.e * this.cos_p12 * cosAz;\n      A = -tmp * tmp / (1 - this.es);\n      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);\n      D = rh / N1;\n      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;\n      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;\n      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);\n      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));\n      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n  }\n\n}\n\nexport var names = [\"Azimuthal_Equidistant\", \"aeqd\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/aeqd.js\n// module id = 84\n// module chunks = 0 1","import mlfn from '../common/mlfn';\nimport e0fn from '../common/e0fn';\nimport e1fn from '../common/e1fn';\nimport e2fn from '../common/e2fn';\nimport e3fn from '../common/e3fn';\nimport gN from '../common/gN';\nimport adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport imlfn from '../common/imlfn';\nimport {HALF_PI, EPSLN} from '../constants/values';\n\nexport function init() {\n  if (!this.sphere) {\n    this.e0 = e0fn(this.es);\n    this.e1 = e1fn(this.es);\n    this.e2 = e2fn(this.es);\n    this.e3 = e3fn(this.es);\n    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  }\n}\n\n/* Cassini forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y;\n  var lam = p.x;\n  var phi = p.y;\n  lam = adjust_lon(lam - this.long0);\n\n  if (this.sphere) {\n    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));\n    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);\n  }\n  else {\n    //ellipsoid\n    var sinphi = Math.sin(phi);\n    var cosphi = Math.cos(phi);\n    var nl = gN(this.a, this.e, sinphi);\n    var tl = Math.tan(phi) * Math.tan(phi);\n    var al = lam * Math.cos(phi);\n    var asq = al * al;\n    var cl = this.es * cosphi * cosphi / (1 - this.es);\n    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n\n    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));\n    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);\n\n\n  }\n\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var phi, lam;\n\n  if (this.sphere) {\n    var dd = y + this.lat0;\n    phi = Math.asin(Math.sin(dd) * Math.cos(x));\n    lam = Math.atan2(Math.tan(x), Math.cos(dd));\n  }\n  else {\n    /* ellipsoid */\n    var ml1 = this.ml0 / this.a + y;\n    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);\n    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {\n      p.x = this.long0;\n      p.y = HALF_PI;\n      if (y < 0) {\n        p.y *= -1;\n      }\n      return p;\n    }\n    var nl1 = gN(this.a, this.e, Math.sin(phi1));\n\n    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);\n    var tl1 = Math.pow(Math.tan(phi1), 2);\n    var dl = x * this.a / nl1;\n    var dsq = dl * dl;\n    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);\n    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);\n\n  }\n\n  p.x = adjust_lon(lam + this.long0);\n  p.y = adjust_lat(phi);\n  return p;\n\n}\n\nexport var names = [\"Cassini\", \"Cassini_Soldner\", \"cass\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/cass.js\n// module id = 85\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\nimport qsfnz from '../common/qsfnz';\nimport msfnz from '../common/msfnz';\nimport iqsfnz from '../common/iqsfnz';\n\n/*\n  reference:\n    \"Cartographic Projection Procedures for the UNIX Environment-\n    A User's Manual\" by Gerald I. Evenden,\n    USGS Open File Report 90-284and Release 4 Interim Reports (2003)\n*/\nexport function init() {\n  //no-op\n  if (!this.sphere) {\n    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n  }\n}\n\n/* Cylindrical Equal Area forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y;\n  /* Forward equations\n      -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  if (this.sphere) {\n    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);\n    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);\n  }\n  else {\n    var qs = qsfnz(this.e, Math.sin(lat));\n    x = this.x0 + this.a * this.k0 * dlon;\n    y = this.y0 + this.a * qs * 0.5 / this.k0;\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));\n    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));\n  }\n  else {\n    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);\n    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"cea\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/cea.js\n// module id = 86\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\n\nexport function init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Equidistant Cylindrical (Plate Carre)\";\n\n  this.rc = Math.cos(this.lat_ts);\n}\n\n// forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  var dlon = adjust_lon(lon - this.long0);\n  var dlat = adjust_lat(lat - this.lat0);\n  p.x = this.x0 + (this.a * dlon * this.rc);\n  p.y = this.y0 + (this.a * dlat);\n  return p;\n}\n\n// inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n\n  var x = p.x;\n  var y = p.y;\n\n  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));\n  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));\n  return p;\n}\n\nexport var names = [\"Equirectangular\", \"Equidistant_Cylindrical\", \"eqc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/eqc.js\n// module id = 87\n// module chunks = 0 1","import e0fn from '../common/e0fn';\nimport e1fn from '../common/e1fn';\nimport e2fn from '../common/e2fn';\nimport e3fn from '../common/e3fn';\nimport msfnz from '../common/msfnz';\nimport mlfn from '../common/mlfn';\nimport adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport imlfn from '../common/imlfn';\nimport {EPSLN} from '../constants/values';\n\nexport function init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.lat2 = this.lat2 || this.lat1;\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n\n  this.sinphi = Math.sin(this.lat1);\n  this.cosphi = Math.cos(this.lat1);\n\n  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);\n  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);\n\n  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {\n    this.ns = this.sinphi;\n  }\n  else {\n    this.sinphi = Math.sin(this.lat2);\n    this.cosphi = Math.cos(this.lat2);\n    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);\n    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);\n    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);\n  }\n  this.g = this.ml1 + this.ms1 / this.ns;\n  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  this.rh = this.a * (this.g - this.ml0);\n}\n\n/* Equidistant Conic forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var rh1;\n\n  /* Forward equations\n      -----------------*/\n  if (this.sphere) {\n    rh1 = this.a * (this.g - lat);\n  }\n  else {\n    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n    rh1 = this.a * (this.g - ml);\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  var x = this.x0 + rh1 * Math.sin(theta);\n  var y = this.y0 + this.rh - rh1 * Math.cos(theta);\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  var con, rh1, lat, lon;\n  if (this.ns >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    lat = adjust_lat(this.g - rh1 / this.a);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    var ml = this.g - rh1 / this.a;\n    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n\n}\n\nexport var names = [\"Equidistant_Conic\", \"eqdc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/eqdc.js\n// module id = 88\n// module chunks = 0 1","import srat from '../common/srat';\nvar MAX_ITER = 20;\nimport {HALF_PI, FORTPI} from '../constants/values';\n\nexport function init() {\n  var sphi = Math.sin(this.lat0);\n  var cphi = Math.cos(this.lat0);\n  cphi *= cphi;\n  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);\n  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));\n  this.phic0 = Math.asin(sphi / this.C);\n  this.ratexp = 0.5 * this.C * this.e;\n  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));\n}\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;\n  p.x = this.C * lon;\n  return p;\n}\n\nexport function inverse(p) {\n  var DEL_TOL = 1e-14;\n  var lon = p.x / this.C;\n  var lat = p.y;\n  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);\n  for (var i = MAX_ITER; i > 0; --i) {\n    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;\n    if (Math.abs(lat - p.y) < DEL_TOL) {\n      break;\n    }\n    p.y = lat;\n  }\n  /* convergence failed */\n  if (!i) {\n    return null;\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"gauss\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/gauss.js\n// module id = 89\n// module chunks = 0 1","export function init() {\n  this.isGeocent = true;\n}\n\nfunction identity(pt) {\n  return pt;\n}\nexport {identity as forward};\nexport {identity as inverse};\nexport var names = [\"geocent\"];\nexport default {\n  init: init,\n  forward: identity,\n  inverse: identity,\n  names: names\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/geocent.js\n// module id = 90\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\nimport asinz from '../common/asinz';\nimport {EPSLN} from '../constants/values';\n\n/*\n  reference:\n    Wolfram Mathworld \"Gnomonic Projection\"\n    http://mathworld.wolfram.com/GnomonicProjection.html\n    Accessed: 12th November 2009\n  */\nexport function init() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n  // Approximation for projecting points to the horizon (infinity)\n  this.infinity_dist = 1000 * this.a;\n  this.rc = 1;\n}\n\n/* Gnomonic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexport function forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g;\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = adjust_lon(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n  }\n  else {\n\n    // Point is in the opposing hemisphere and is unprojectable\n    // We still need to return a reasonable point, so we project\n    // to infinity, on a bearing\n    // equivalent to the northern hemisphere equivalent\n    // This is a reasonable approximation for short shapes and lines that\n    // straddle the horizon.\n\n    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var rh; /* Rho */\n  var sinc, cosc;\n  var c;\n  var lon, lat;\n\n  /* Inverse equations\n      -----------------*/\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n\n  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    c = Math.atan2(rh, this.rc);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n\n    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);\n    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n    lon = adjust_lon(this.long0 + lon);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"gnom\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/gnom.js\n// module id = 91\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\n\nexport function init() {\n  this.a = 6377397.155;\n  this.es = 0.006674372230614;\n  this.e = Math.sqrt(this.es);\n  if (!this.lat0) {\n    this.lat0 = 0.863937979737193;\n  }\n  if (!this.long0) {\n    this.long0 = 0.7417649320975901 - 0.308341501185665;\n  }\n  /* if scale not set default to 0.9999 */\n  if (!this.k0) {\n    this.k0 = 0.9999;\n  }\n  this.s45 = 0.785398163397448; /* 45 */\n  this.s90 = 2 * this.s45;\n  this.fi0 = this.lat0;\n  this.e2 = this.es;\n  this.e = Math.sqrt(this.e2);\n  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));\n  this.uq = 1.04216856380474;\n  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);\n  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);\n  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;\n  this.k1 = this.k0;\n  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));\n  this.s0 = 1.37008346281555;\n  this.n = Math.sin(this.s0);\n  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);\n  this.ad = this.s90 - this.uq;\n}\n\n/* ellipsoid */\n/* calculate xy from lat/lon */\n/* Constants, identical to inverse transform function */\nexport function forward(p) {\n  var gfi, u, deltav, s, d, eps, ro;\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  /* Transformation */\n  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));\n  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);\n  deltav = -delta_lon * this.alfa;\n  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));\n  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));\n  eps = this.n * d;\n  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);\n  p.y = ro * Math.cos(eps) / 1;\n  p.x = ro * Math.sin(eps) / 1;\n\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  return (p);\n}\n\n/* calculate lat/lon from xy */\nexport function inverse(p) {\n  var u, deltav, s, d, eps, ro, fi1;\n  var ok;\n\n  /* Transformation */\n  /* revert y, x*/\n  var tmp = p.x;\n  p.x = p.y;\n  p.y = tmp;\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  ro = Math.sqrt(p.x * p.x + p.y * p.y);\n  eps = Math.atan2(p.y, p.x);\n  d = eps / Math.sin(this.s0);\n  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);\n  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));\n  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));\n  p.x = this.long0 - deltav / this.alfa;\n  fi1 = u;\n  ok = 0;\n  var iter = 0;\n  do {\n    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);\n    if (Math.abs(fi1 - p.y) < 0.0000000001) {\n      ok = 1;\n    }\n    fi1 = p.y;\n    iter += 1;\n  } while (ok === 0 && iter < 15);\n  if (iter >= 15) {\n    return null;\n  }\n\n  return (p);\n}\n\nexport var names = [\"Krovak\", \"krovak\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/krovak.js\n// module id = 92\n// module chunks = 0 1","\nimport {HALF_PI, EPSLN, FORTPI} from '../constants/values';\n\nimport qsfnz from '../common/qsfnz';\nimport adjust_lon from '../common/adjust_lon';\n\n/*\n  reference\n    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\nexport var S_POLE = 1;\n\nexport var N_POLE = 2;\nexport var EQUIT = 3;\nexport var OBLIQ = 4;\n\n/* Initialize the Lambert Azimuthal Equal Area projection\n  ------------------------------------------------------*/\nexport function init() {\n  var t = Math.abs(this.lat0);\n  if (Math.abs(t - HALF_PI) < EPSLN) {\n    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n  }\n  else if (Math.abs(t) < EPSLN) {\n    this.mode = this.EQUIT;\n  }\n  else {\n    this.mode = this.OBLIQ;\n  }\n  if (this.es > 0) {\n    var sinphi;\n\n    this.qp = qsfnz(this.e, 1);\n    this.mmf = 0.5 / (1 - this.es);\n    this.apa = authset(this.es);\n    switch (this.mode) {\n    case this.N_POLE:\n      this.dd = 1;\n      break;\n    case this.S_POLE:\n      this.dd = 1;\n      break;\n    case this.EQUIT:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      this.dd = 1 / this.rq;\n      this.xmf = 1;\n      this.ymf = 0.5 * this.qp;\n      break;\n    case this.OBLIQ:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      sinphi = Math.sin(this.lat0);\n      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n      this.ymf = (this.xmf = this.rq) / this.dd;\n      this.xmf *= this.dd;\n      break;\n    }\n  }\n  else {\n    if (this.mode === this.OBLIQ) {\n      this.sinph0 = Math.sin(this.lat0);\n      this.cosph0 = Math.cos(this.lat0);\n    }\n  }\n}\n\n/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n  var lam = p.x;\n  var phi = p.y;\n\n  lam = adjust_lon(lam - this.long0);\n  if (this.sphere) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    coslam = Math.cos(lam);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      if (y <= EPSLN) {\n        return null;\n      }\n      y = Math.sqrt(2 / y);\n      x = y * cosphi * Math.sin(lam);\n      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        coslam = -coslam;\n      }\n      if (Math.abs(phi + this.phi0) < EPSLN) {\n        return null;\n      }\n      y = FORTPI - phi * 0.5;\n      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));\n      x = y * Math.sin(lam);\n      y *= coslam;\n    }\n  }\n  else {\n    sinb = 0;\n    cosb = 0;\n    b = 0;\n    coslam = Math.cos(lam);\n    sinlam = Math.sin(lam);\n    sinphi = Math.sin(phi);\n    q = qsfnz(this.e, sinphi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinb = q / this.qp;\n      cosb = Math.sqrt(1 - sinb * sinb);\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n      break;\n    case this.EQUIT:\n      b = 1 + cosb * coslam;\n      break;\n    case this.N_POLE:\n      b = HALF_PI + phi;\n      q = this.qp - q;\n      break;\n    case this.S_POLE:\n      b = phi - HALF_PI;\n      q = this.qp + q;\n      break;\n    }\n    if (Math.abs(b) < EPSLN) {\n      return null;\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n    case this.EQUIT:\n      b = Math.sqrt(2 / b);\n      if (this.mode === this.OBLIQ) {\n        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n      }\n      else {\n        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n      }\n      x = this.xmf * b * cosb * sinlam;\n      break;\n    case this.N_POLE:\n    case this.S_POLE:\n      if (q >= 0) {\n        x = (b = Math.sqrt(q)) * sinlam;\n        y = coslam * ((this.mode === this.S_POLE) ? b : -b);\n      }\n      else {\n        x = y = 0;\n      }\n      break;\n    }\n  }\n\n  p.x = this.a * x + this.x0;\n  p.y = this.a * y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var lam, phi, cCe, sCe, q, rho, ab;\n  if (this.sphere) {\n    var cosz = 0,\n      rh, sinz = 0;\n\n    rh = Math.sqrt(x * x + y * y);\n    phi = rh * 0.5;\n    if (phi > 1) {\n      return null;\n    }\n    phi = 2 * Math.asin(phi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinz = Math.sin(phi);\n      cosz = Math.cos(phi);\n    }\n    switch (this.mode) {\n    case this.EQUIT:\n      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);\n      x *= sinz;\n      y = cosz * rh;\n      break;\n    case this.OBLIQ:\n      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n      x *= sinz * this.cosph0;\n      y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n      break;\n    case this.N_POLE:\n      y = -y;\n      phi = HALF_PI - phi;\n      break;\n    case this.S_POLE:\n      phi -= HALF_PI;\n      break;\n    }\n    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);\n  }\n  else {\n    ab = 0;\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      x /= this.dd;\n      y *= this.dd;\n      rho = Math.sqrt(x * x + y * y);\n      if (rho < EPSLN) {\n        p.x = 0;\n        p.y = this.phi0;\n        return p;\n      }\n      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n      cCe = Math.cos(sCe);\n      x *= (sCe = Math.sin(sCe));\n      if (this.mode === this.OBLIQ) {\n        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n        q = this.qp * ab;\n        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n      }\n      else {\n        ab = y * sCe / rho;\n        q = this.qp * ab;\n        y = rho * cCe;\n      }\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        y = -y;\n      }\n      q = (x * x + y * y);\n      if (!q) {\n        p.x = 0;\n        p.y = this.phi0;\n        return p;\n      }\n      ab = 1 - q / this.qp;\n      if (this.mode === this.S_POLE) {\n        ab = -ab;\n      }\n    }\n    lam = Math.atan2(x, y);\n    phi = authlat(Math.asin(ab), this.apa);\n  }\n\n  p.x = adjust_lon(this.long0 + lam);\n  p.y = phi;\n  return p;\n}\n\n/* determine latitude from authalic latitude */\nvar P00 = 0.33333333333333333333;\n\nvar P01 = 0.17222222222222222222;\nvar P02 = 0.10257936507936507936;\nvar P10 = 0.06388888888888888888;\nvar P11 = 0.06640211640211640211;\nvar P20 = 0.01641501294219154443;\n\nfunction authset(es) {\n  var t;\n  var APA = [];\n  APA[0] = es * P00;\n  t = es * es;\n  APA[0] += t * P01;\n  APA[1] = t * P10;\n  t *= es;\n  APA[0] += t * P02;\n  APA[1] += t * P11;\n  APA[2] = t * P20;\n  return APA;\n}\n\nfunction authlat(beta, APA) {\n  var t = beta + beta;\n  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));\n}\n\nexport var names = [\"Lambert Azimuthal Equal Area\", \"Lambert_Azimuthal_Equal_Area\", \"laea\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  S_POLE: S_POLE,\n  N_POLE: N_POLE,\n  EQUIT: EQUIT,\n  OBLIQ: OBLIQ\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/laea.js\n// module id = 93\n// module chunks = 0 1","import msfnz from '../common/msfnz';\nimport tsfnz from '../common/tsfnz';\nimport sign from '../common/sign';\nimport adjust_lon from '../common/adjust_lon';\nimport phi2z from '../common/phi2z';\nimport {HALF_PI, EPSLN} from '../constants/values';\nexport function init() {\n\n  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north\n  //double c_lat;                   /* center latitude                      */\n  //double c_lon;                   /* center longitude                     */\n  //double lat1;                    /* first standard parallel              */\n  //double lat2;                    /* second standard parallel             */\n  //double r_maj;                   /* major axis                           */\n  //double r_min;                   /* minor axis                           */\n  //double false_east;              /* x offset in meters                   */\n  //double false_north;             /* y offset in meters                   */\n\n  if (!this.lat2) {\n    this.lat2 = this.lat1;\n  } //if lat2 is not defined\n  if (!this.k0) {\n    this.k0 = 1;\n  }\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n\n  var temp = this.b / this.a;\n  this.e = Math.sqrt(1 - temp * temp);\n\n  var sin1 = Math.sin(this.lat1);\n  var cos1 = Math.cos(this.lat1);\n  var ms1 = msfnz(this.e, sin1, cos1);\n  var ts1 = tsfnz(this.e, this.lat1, sin1);\n\n  var sin2 = Math.sin(this.lat2);\n  var cos2 = Math.cos(this.lat2);\n  var ms2 = msfnz(this.e, sin2, cos2);\n  var ts2 = tsfnz(this.e, this.lat2, sin2);\n\n  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n  }\n  else {\n    this.ns = sin1;\n  }\n  if (isNaN(this.ns)) {\n    this.ns = sin1;\n  }\n  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n  if (!this.title) {\n    this.title = \"Lambert Conformal Conic\";\n  }\n}\n\n// Lambert Conformal conic forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  // singular cases :\n  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n    lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n  }\n\n  var con = Math.abs(Math.abs(lat) - HALF_PI);\n  var ts, rh1;\n  if (con > EPSLN) {\n    ts = tsfnz(this.e, lat, Math.sin(lat));\n    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n  }\n  else {\n    con = lat * this.ns;\n    if (con <= 0) {\n      return null;\n    }\n    rh1 = 0;\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n\n  return p;\n}\n\n// Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n\n  var rh1, con, ts;\n  var lat, lon;\n  var x = (p.x - this.x0) / this.k0;\n  var y = (this.rh - (p.y - this.y0) / this.k0);\n  if (this.ns > 0) {\n    rh1 = Math.sqrt(x * x + y * y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(x * x + y * y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2((con * x), (con * y));\n  }\n  if ((rh1 !== 0) || (this.ns > 0)) {\n    con = 1 / this.ns;\n    ts = Math.pow((rh1 / (this.a * this.f0)), con);\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  else {\n    lat = -HALF_PI;\n  }\n  lon = adjust_lon(theta / this.ns + this.long0);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Lambert Tangential Conformal Conic Projection\", \"Lambert_Conformal_Conic\", \"Lambert_Conformal_Conic_2SP\", \"lcc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/lcc.js\n// module id = 94\n// module chunks = 0 1","export function init() {\n  //no-op for longlat\n}\n\nfunction identity(pt) {\n  return pt;\n}\nexport {identity as forward};\nexport {identity as inverse};\nexport var names = [\"longlat\", \"identity\"];\nexport default {\n  init: init,\n  forward: identity,\n  inverse: identity,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/longlat.js\n// module id = 95\n// module chunks = 0 1","import msfnz from '../common/msfnz';\n\nimport adjust_lon from '../common/adjust_lon';\nimport tsfnz from '../common/tsfnz';\nimport phi2z from '../common/phi2z';\nimport {FORTPI, R2D, EPSLN, HALF_PI} from '../constants/values';\nexport function init() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!('x0' in this)){\n    this.x0 = 0;\n  }\n  if(!('y0' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n}\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n}\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nexport function inverse(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/merc.js\n// module id = 96\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\n\n/*\n  reference\n    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\n\n/* Initialize the Miller Cylindrical projection\n  -------------------------------------------*/\nexport function init() {\n  //no-op\n}\n\n/* Miller Cylindrical forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  var x = this.x0 + this.a * dlon;\n  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Miller Cylindrical inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n\n  var lon = adjust_lon(this.long0 + p.x / this.a);\n  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Miller_Cylindrical\", \"mill\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/mill.js\n// module id = 97\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\nexport function init() {}\nimport {EPSLN} from '../constants/values';\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  for (var i = 0; true; i++) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n  if (lon < (-Math.PI)) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mollweide\", \"moll\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/moll.js\n// module id = 98\n// module chunks = 0 1","import {SEC_TO_RAD} from '../constants/values';\n\n/*\n  reference\n    Department of Land and Survey Technical Circular 1973/32\n      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n    OSG Technical Report 4.1\n      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n  */\n\n/**\n * iterations: Number of iterations to refine inverse transform.\n *     0 -> km accuracy\n *     1 -> m accuracy -- suitable for most mapping applications\n *     2 -> mm accuracy\n */\nexport var iterations = 1;\n\nexport function init() {\n  this.A = [];\n  this.A[1] = 0.6399175073;\n  this.A[2] = -0.1358797613;\n  this.A[3] = 0.063294409;\n  this.A[4] = -0.02526853;\n  this.A[5] = 0.0117879;\n  this.A[6] = -0.0055161;\n  this.A[7] = 0.0026906;\n  this.A[8] = -0.001333;\n  this.A[9] = 0.00067;\n  this.A[10] = -0.00034;\n\n  this.B_re = [];\n  this.B_im = [];\n  this.B_re[1] = 0.7557853228;\n  this.B_im[1] = 0;\n  this.B_re[2] = 0.249204646;\n  this.B_im[2] = 0.003371507;\n  this.B_re[3] = -0.001541739;\n  this.B_im[3] = 0.041058560;\n  this.B_re[4] = -0.10162907;\n  this.B_im[4] = 0.01727609;\n  this.B_re[5] = -0.26623489;\n  this.B_im[5] = -0.36249218;\n  this.B_re[6] = -0.6870983;\n  this.B_im[6] = -1.1651967;\n\n  this.C_re = [];\n  this.C_im = [];\n  this.C_re[1] = 1.3231270439;\n  this.C_im[1] = 0;\n  this.C_re[2] = -0.577245789;\n  this.C_im[2] = -0.007809598;\n  this.C_re[3] = 0.508307513;\n  this.C_im[3] = -0.112208952;\n  this.C_re[4] = -0.15094762;\n  this.C_im[4] = 0.18200602;\n  this.C_re[5] = 1.01418179;\n  this.C_im[5] = 1.64497696;\n  this.C_re[6] = 1.9660549;\n  this.C_im[6] = 2.5127645;\n\n  this.D = [];\n  this.D[1] = 1.5627014243;\n  this.D[2] = 0.5185406398;\n  this.D[3] = -0.03333098;\n  this.D[4] = -0.1052906;\n  this.D[5] = -0.0368594;\n  this.D[6] = 0.007317;\n  this.D[7] = 0.01220;\n  this.D[8] = 0.00394;\n  this.D[9] = -0.0013;\n}\n\n/**\n    New Zealand Map Grid Forward  - long/lat to x/y\n    long/lat in radians\n  */\nexport function forward(p) {\n  var n;\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lat = lat - this.lat0;\n  var delta_lon = lon - this.long0;\n\n  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;\n  var d_lambda = delta_lon;\n  var d_phi_n = 1; // d_phi^0\n\n  var d_psi = 0;\n  for (n = 1; n <= 10; n++) {\n    d_phi_n = d_phi_n * d_phi;\n    d_psi = d_psi + this.A[n] * d_phi_n;\n  }\n\n  // 2. Calculate theta\n  var th_re = d_psi;\n  var th_im = d_lambda;\n\n  // 3. Calculate z\n  var th_n_re = 1;\n  var th_n_im = 0; // theta^0\n  var th_n_re1;\n  var th_n_im1;\n\n  var z_re = 0;\n  var z_im = 0;\n  for (n = 1; n <= 6; n++) {\n    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n    th_n_re = th_n_re1;\n    th_n_im = th_n_im1;\n    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n  }\n\n  // 4. Calculate easting and northing\n  p.x = (z_im * this.a) + this.x0;\n  p.y = (z_re * this.a) + this.y0;\n\n  return p;\n}\n\n/**\n    New Zealand Map Grid Inverse  -  x/y to long/lat\n  */\nexport function inverse(p) {\n  var n;\n  var x = p.x;\n  var y = p.y;\n\n  var delta_x = x - this.x0;\n  var delta_y = y - this.y0;\n\n  // 1. Calculate z\n  var z_re = delta_y / this.a;\n  var z_im = delta_x / this.a;\n\n  // 2a. Calculate theta - first approximation gives km accuracy\n  var z_n_re = 1;\n  var z_n_im = 0; // z^0\n  var z_n_re1;\n  var z_n_im1;\n\n  var th_re = 0;\n  var th_im = 0;\n  for (n = 1; n <= 6; n++) {\n    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n    z_n_re = z_n_re1;\n    z_n_im = z_n_im1;\n    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n  }\n\n  // 2b. Iterate to refine the accuracy of the calculation\n  //        0 iterations gives km accuracy\n  //        1 iteration gives m accuracy -- good enough for most mapping applications\n  //        2 iterations bives mm accuracy\n  for (var i = 0; i < this.iterations; i++) {\n    var th_n_re = th_re;\n    var th_n_im = th_im;\n    var th_n_re1;\n    var th_n_im1;\n\n    var num_re = z_re;\n    var num_im = z_im;\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    th_n_re = 1;\n    th_n_im = 0;\n    var den_re = this.B_re[1];\n    var den_im = this.B_im[1];\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    // Complex division\n    var den2 = den_re * den_re + den_im * den_im;\n    th_re = (num_re * den_re + num_im * den_im) / den2;\n    th_im = (num_im * den_re - num_re * den_im) / den2;\n  }\n\n  // 3. Calculate d_phi              ...                                    // and d_lambda\n  var d_psi = th_re;\n  var d_lambda = th_im;\n  var d_psi_n = 1; // d_psi^0\n\n  var d_phi = 0;\n  for (n = 1; n <= 9; n++) {\n    d_psi_n = d_psi_n * d_psi;\n    d_phi = d_phi + this.D[n] * d_psi_n;\n  }\n\n  // 4. Calculate latitude and longitude\n  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);\n  var lon = this.long0 + d_lambda;\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nexport var names = [\"New_Zealand_Map_Grid\", \"nzmg\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/nzmg.js\n// module id = 99\n// module chunks = 0 1","import tsfnz from '../common/tsfnz';\nimport adjust_lon from '../common/adjust_lon';\nimport phi2z from '../common/phi2z';\nimport {EPSLN, HALF_PI, FORTPI} from '../constants/values';\n\n/* Initialize the Oblique Mercator  projection\n    ------------------------------------------*/\nexport function init() {\n  this.no_off = this.no_off || false;\n  this.no_rot = this.no_rot || false;\n\n  if (isNaN(this.k0)) {\n    this.k0 = 1;\n  }\n  var sinlat = Math.sin(this.lat0);\n  var coslat = Math.cos(this.lat0);\n  var con = this.e * sinlat;\n\n  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));\n  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);\n  var t0 = tsfnz(this.e, this.lat0, sinlat);\n  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));\n  if (dl * dl < 1) {\n    dl = 1;\n  }\n  var fl;\n  var gl;\n  if (!isNaN(this.longc)) {\n    //Central point and azimuth method\n\n    if (this.lat0 >= 0) {\n      fl = dl + Math.sqrt(dl * dl - 1);\n    }\n    else {\n      fl = dl - Math.sqrt(dl * dl - 1);\n    }\n    this.el = fl * Math.pow(t0, this.bl);\n    gl = 0.5 * (fl - 1 / fl);\n    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);\n    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;\n\n  }\n  else {\n    //2 points method\n    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));\n    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));\n    if (this.lat0 >= 0) {\n      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n    }\n    else {\n      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n    }\n    var hl = Math.pow(t1, this.bl);\n    var ll = Math.pow(t2, this.bl);\n    fl = this.el / hl;\n    gl = 0.5 * (fl - 1 / fl);\n    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);\n    var pl = (ll - hl) / (ll + hl);\n    var dlon12 = adjust_lon(this.long1 - this.long2);\n    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;\n    this.long0 = adjust_lon(this.long0);\n    var dlon10 = adjust_lon(this.long1 - this.long0);\n    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);\n    this.alpha = Math.asin(dl * Math.sin(this.gamma0));\n  }\n\n  if (this.no_off) {\n    this.uc = 0;\n  }\n  else {\n    if (this.lat0 >= 0) {\n      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n    }\n    else {\n      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n    }\n  }\n\n}\n\n/* Oblique Mercator forward equations--mapping lat,long to x,y\n    ----------------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var dlon = adjust_lon(lon - this.long0);\n  var us, vs;\n  var con;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    if (lat > 0) {\n      con = -1;\n    }\n    else {\n      con = 1;\n    }\n    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));\n    us = -1 * con * HALF_PI * this.al / this.bl;\n  }\n  else {\n    var t = tsfnz(this.e, lat, Math.sin(lat));\n    var ql = this.el / Math.pow(t, this.bl);\n    var sl = 0.5 * (ql - 1 / ql);\n    var tl = 0.5 * (ql + 1 / ql);\n    var vl = Math.sin(this.bl * (dlon));\n    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;\n    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {\n      vs = Number.POSITIVE_INFINITY;\n    }\n    else {\n      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;\n    }\n    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {\n      us = this.al * this.bl * (dlon);\n    }\n    else {\n      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;\n    }\n  }\n\n  if (this.no_rot) {\n    p.x = this.x0 + us;\n    p.y = this.y0 + vs;\n  }\n  else {\n\n    us -= this.uc;\n    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);\n    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);\n  }\n  return p;\n}\n\nexport function inverse(p) {\n  var us, vs;\n  if (this.no_rot) {\n    vs = p.y - this.y0;\n    us = p.x - this.x0;\n  }\n  else {\n    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);\n    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);\n    us += this.uc;\n  }\n  var qp = Math.exp(-1 * this.bl * vs / this.al);\n  var sp = 0.5 * (qp - 1 / qp);\n  var tp = 0.5 * (qp + 1 / qp);\n  var vp = Math.sin(this.bl * us / this.al);\n  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;\n  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);\n  if (Math.abs(up - 1) < EPSLN) {\n    p.x = this.long0;\n    p.y = HALF_PI;\n  }\n  else if (Math.abs(up + 1) < EPSLN) {\n    p.x = this.long0;\n    p.y = -1 * HALF_PI;\n  }\n  else {\n    p.y = phi2z(this.e, ts);\n    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);\n  }\n  return p;\n}\n\nexport var names = [\"Hotine_Oblique_Mercator\", \"Hotine Oblique Mercator\", \"Hotine_Oblique_Mercator_Azimuth_Natural_Origin\", \"Hotine_Oblique_Mercator_Azimuth_Center\", \"omerc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/omerc.js\n// module id = 100\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\nimport asinz from '../common/asinz';\nimport {EPSLN, HALF_PI} from '../constants/values';\n\nexport function init() {\n  //double temp;      /* temporary variable    */\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n}\n\n/* Orthographic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexport function forward(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g, x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = adjust_lon(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n    x = this.a * ksp * cosphi * Math.sin(dlon);\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var rh; /* height above ellipsoid      */\n  var z; /* angle          */\n  var sinz, cosz; /* sin of z and cos of z      */\n  var con;\n  var lon, lat;\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  z = asinz(rh / this.a);\n\n  sinz = Math.sin(z);\n  cosz = Math.cos(z);\n\n  lon = this.long0;\n  if (Math.abs(rh) <= EPSLN) {\n    lat = this.lat0;\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);\n  con = Math.abs(this.lat0) - HALF_PI;\n  if (Math.abs(con) <= EPSLN) {\n    if (this.lat0 >= 0) {\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n    }\n    else {\n      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"ortho\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/ortho.js\n// module id = 101\n// module chunks = 0 1","import e0fn from '../common/e0fn';\nimport e1fn from '../common/e1fn';\nimport e2fn from '../common/e2fn';\nimport e3fn from '../common/e3fn';\nimport adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport mlfn from '../common/mlfn';\nimport {EPSLN} from '../constants/values';\n\nimport gN from '../common/gN';\nvar MAX_ITER = 20;\n\nexport function init() {\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas\n}\n\n/* Polyconic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y, el;\n  var dlon = adjust_lon(lon - this.long0);\n  el = dlon * Math.sin(lat);\n  if (this.sphere) {\n    if (Math.abs(lat) <= EPSLN) {\n      x = this.a * dlon;\n      y = -1 * this.a * this.lat0;\n    }\n    else {\n      x = this.a * Math.sin(el) / Math.tan(lat);\n      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));\n    }\n  }\n  else {\n    if (Math.abs(lat) <= EPSLN) {\n      x = this.a * dlon;\n      y = -1 * this.ml0;\n    }\n    else {\n      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);\n      x = nl * Math.sin(el);\n      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));\n    }\n\n  }\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n}\n\n/* Inverse equations\n  -----------------*/\nexport function inverse(p) {\n  var lon, lat, x, y, i;\n  var al, bl;\n  var phi, dphi;\n  x = p.x - this.x0;\n  y = p.y - this.y0;\n\n  if (this.sphere) {\n    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {\n      lon = adjust_lon(x / this.a + this.long0);\n      lat = 0;\n    }\n    else {\n      al = this.lat0 + y / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var tanphi;\n      for (i = MAX_ITER; i; --i) {\n        tanphi = Math.tan(phi);\n        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);\n        phi += dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));\n    }\n  }\n  else {\n    if (Math.abs(y + this.ml0) <= EPSLN) {\n      lat = 0;\n      lon = adjust_lon(this.long0 + x / this.a);\n    }\n    else {\n\n      al = (this.ml0 + y) / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var cl, mln, mlnp, ma;\n      var con;\n      for (i = MAX_ITER; i; --i) {\n        con = this.e * Math.sin(phi);\n        cl = Math.sqrt(1 - con * con) * Math.tan(phi);\n        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);\n        ma = mln / this.a;\n        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);\n        phi -= dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n\n      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);\n      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);\n      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Polyconic\", \"poly\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/poly.js\n// module id = 102\n// module chunks = 0 1","// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\nimport {EPSLN, TWO_PI, SPI, HALF_PI, FORTPI} from '../constants/values';\n\n/* constants */\nvar FACE_ENUM = {\n    FRONT: 1,\n    RIGHT: 2,\n    BACK: 3,\n    LEFT: 4,\n    TOP: 5,\n    BOTTOM: 6\n};\n\nvar AREA_ENUM = {\n    AREA_0: 1,\n    AREA_1: 2,\n    AREA_2: 3,\n    AREA_3: 4\n};\n\nexport function init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n\n  /* Determine the cube face from the center of projection. */\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\n\n// QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n  var xy = {x: 0, y: 0};\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n  var area = {value: 0};\n\n  // move lon according to projection's lon\n  p.x -= this.long0;\n\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n  if (this.es !== 0) {//if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n  lon = p.x; //lon = lp.lam;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = (lon > 0.0 ? lon - SPI : lon + SPI);\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n  /* Apply the result to the real area. */\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n\n  /* Now compute x, y from mu and nu */\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n}\n\n// QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n  var lp = {lam: 0, phi: 0};\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {value: 0};\n\n  /* de-offset */\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = (mu < 0.0 ? mu + SPI : mu - SPI);\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n  t = (SPI / 12) * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = theta;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);\n    }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n    t += s * s;\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = (lp.phi < 0 ? 1 : 0);\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n  return theta;\n}\n\n/* Helper function: shift the longitude. */\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n  return slon;\n}\n\nexport var names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/qsc.js\n// module id = 103\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\nimport adjust_lat from '../common/adjust_lat';\nimport pj_enfn from '../common/pj_enfn';\nvar MAX_ITER = 20;\nimport pj_mlfn from '../common/pj_mlfn';\nimport pj_inv_mlfn from '../common/pj_inv_mlfn';\nimport {EPSLN, HALF_PI} from '../constants/values';\n\nimport asinz from '../common/asinz';\n\n\nexport function init() {\n  /* Place parameters in static storage for common use\n    -------------------------------------------------*/\n\n\n  if (!this.sphere) {\n    this.en = pj_enfn(this.es);\n  }\n  else {\n    this.n = 1;\n    this.m = 0;\n    this.es = 0;\n    this.C_y = Math.sqrt((this.m + 1) / this.n);\n    this.C_x = this.C_y / (this.m + 1);\n  }\n\n}\n\n/* Sinusoidal forward equations--mapping lat,long to x,y\n  -----------------------------------------------------*/\nexport function forward(p) {\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n    -----------------*/\n  lon = adjust_lon(lon - this.long0);\n\n  if (this.sphere) {\n    if (!this.m) {\n      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n    }\n    else {\n      var k = this.n * Math.sin(lat);\n      for (var i = MAX_ITER; i; --i) {\n        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n        lat -= V;\n        if (Math.abs(V) < EPSLN) {\n          break;\n        }\n      }\n    }\n    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n    y = this.a * this.C_y * lat;\n\n  }\n  else {\n\n    var s = Math.sin(lat);\n    var c = Math.cos(lat);\n    y = this.a * pj_mlfn(lat, s, c, this.en);\n    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var lat, temp, lon, s;\n\n  p.x -= this.x0;\n  lon = p.x / this.a;\n  p.y -= this.y0;\n  lat = p.y / this.a;\n\n  if (this.sphere) {\n    lat /= this.C_y;\n    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n    if (this.m) {\n      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n    }\n    else if (this.n !== 1) {\n      lat = asinz(Math.sin(lat) / this.n);\n    }\n    lon = adjust_lon(lon + this.long0);\n    lat = adjust_lat(lat);\n  }\n  else {\n    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);\n    s = Math.abs(lat);\n    if (s < HALF_PI) {\n      s = Math.sin(lat);\n      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));\n      //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n      lon = adjust_lon(temp);\n    }\n    else if ((s - EPSLN) < HALF_PI) {\n      lon = this.long0;\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Sinusoidal\", \"sinu\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/sinu.js\n// module id = 104\n// module chunks = 0 1","/*\n  references:\n    Formules et constantes pour le Calcul pour la\n    projection cylindrique conforme à axe oblique et pour la transformation entre\n    des systèmes de référence.\n    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf\n  */\n\nexport function init() {\n  var phy0 = this.lat0;\n  this.lambda0 = this.long0;\n  var sinPhy0 = Math.sin(phy0);\n  var semiMajorAxis = this.a;\n  var invF = this.rf;\n  var flattening = 1 / invF;\n  var e2 = 2 * flattening - Math.pow(flattening, 2);\n  var e = this.e = Math.sqrt(e2);\n  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));\n  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));\n  this.b0 = Math.asin(sinPhy0 / this.alpha);\n  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));\n  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));\n  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));\n  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;\n}\n\nexport function forward(p) {\n  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));\n  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));\n  var S = -this.alpha * (Sa1 + Sa2) + this.K;\n\n  // spheric latitude\n  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);\n\n  // spheric longitude\n  var I = this.alpha * (p.x - this.lambda0);\n\n  // psoeudo equatorial rotation\n  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));\n\n  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));\n\n  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;\n  p.x = this.R * rotI + this.x0;\n  return p;\n}\n\nexport function inverse(p) {\n  var Y = p.x - this.x0;\n  var X = p.y - this.y0;\n\n  var rotI = Y / this.R;\n  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);\n\n  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));\n  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));\n\n  var lambda = this.lambda0 + I / this.alpha;\n\n  var S = 0;\n  var phy = b;\n  var prevPhy = -1000;\n  var iteration = 0;\n  while (Math.abs(phy - prevPhy) > 0.0000001) {\n    if (++iteration > 20) {\n      //...reportError(\"omercFwdInfinity\");\n      return;\n    }\n    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));\n    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));\n    prevPhy = phy;\n    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;\n  }\n\n  p.x = lambda;\n  p.y = phy;\n  return p;\n}\n\nexport var names = [\"somerc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/somerc.js\n// module id = 105\n// module chunks = 0 1","import {EPSLN, HALF_PI} from '../constants/values';\n\nimport sign from '../common/sign';\nimport msfnz from '../common/msfnz';\nimport tsfnz from '../common/tsfnz';\nimport phi2z from '../common/phi2z';\nimport adjust_lon from '../common/adjust_lon';\n\nexport function ssfn_(phit, sinphi, eccen) {\n  sinphi *= eccen;\n  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));\n}\n\nexport function init() {\n  this.coslat0 = Math.cos(this.lat0);\n  this.sinlat0 = Math.sin(this.lat0);\n  if (this.sphere) {\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));\n    }\n  }\n  else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (this.lat0 > 0) {\n        //North pole\n        //trace('stere:north pole');\n        this.con = 1;\n      }\n      else {\n        //South pole\n        //trace('stere:south pole');\n        this.con = -1;\n      }\n    }\n    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));\n    }\n    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);\n    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;\n    this.cosX0 = Math.cos(this.X0);\n    this.sinX0 = Math.sin(this.X0);\n  }\n}\n\n// Stereographic forward equations--mapping lat,long to x,y\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinlat = Math.sin(lat);\n  var coslat = Math.cos(lat);\n  var A, X, sinX, cosX, ts, rh;\n  var dlon = adjust_lon(lon - this.long0);\n\n  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {\n    //case of the origine point\n    //trace('stere:this is the origin point');\n    p.x = NaN;\n    p.y = NaN;\n    return p;\n  }\n  if (this.sphere) {\n    //trace('stere:sphere case');\n    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));\n    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;\n    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;\n    return p;\n  }\n  else {\n    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;\n    cosX = Math.cos(X);\n    sinX = Math.sin(X);\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);\n      rh = 2 * this.a * this.k0 * ts / this.cons;\n      p.x = this.x0 + rh * Math.sin(lon - this.long0);\n      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);\n      //trace(p.toString());\n      return p;\n    }\n    else if (Math.abs(this.sinlat0) < EPSLN) {\n      //Eq\n      //trace('stere:equateur');\n      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));\n      p.y = A * sinX;\n    }\n    else {\n      //other case\n      //trace('stere:normal case');\n      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));\n      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;\n    }\n    p.x = A * cosX * Math.sin(dlon) + this.x0;\n  }\n  //trace(p.toString());\n  return p;\n}\n\n//* Stereographic inverse equations--mapping x,y to lat/long\nexport function inverse(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat, ts, ce, Chi;\n  var rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  if (this.sphere) {\n    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));\n    lon = this.long0;\n    lat = this.lat0;\n    if (rh <= EPSLN) {\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);\n    if (Math.abs(this.coslat0) < EPSLN) {\n      if (this.lat0 > 0) {\n        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      }\n      else {\n        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n      }\n    }\n    else {\n      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (rh <= EPSLN) {\n        lat = this.lat0;\n        lon = this.long0;\n        p.x = lon;\n        p.y = lat;\n        //trace(p.toString());\n        return p;\n      }\n      p.x *= this.con;\n      p.y *= this.con;\n      ts = rh * this.cons / (2 * this.a * this.k0);\n      lat = this.con * phi2z(this.e, ts);\n      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));\n    }\n    else {\n      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));\n      lon = this.long0;\n      if (rh <= EPSLN) {\n        Chi = this.X0;\n      }\n      else {\n        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);\n        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));\n      }\n      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n\n  //trace(p.toString());\n  return p;\n\n}\n\nexport var names = [\"stere\", \"Stereographic_South_Pole\", \"Polar Stereographic (variant B)\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names,\n  ssfn_: ssfn_\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/stere.js\n// module id = 106\n// module chunks = 0 1","import gauss from './gauss';\nimport adjust_lon from '../common/adjust_lon';\n\nexport function init() {\n  gauss.init.apply(this);\n  if (!this.rc) {\n    return;\n  }\n  this.sinc0 = Math.sin(this.phic0);\n  this.cosc0 = Math.cos(this.phic0);\n  this.R2 = 2 * this.rc;\n  if (!this.title) {\n    this.title = \"Oblique Stereographic Alternative\";\n  }\n}\n\nexport function forward(p) {\n  var sinc, cosc, cosl, k;\n  p.x = adjust_lon(p.x - this.long0);\n  gauss.forward.apply(this, [p]);\n  sinc = Math.sin(p.y);\n  cosc = Math.cos(p.y);\n  cosl = Math.cos(p.x);\n  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);\n  p.x = k * cosc * Math.sin(p.x);\n  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);\n  p.x = this.a * p.x + this.x0;\n  p.y = this.a * p.y + this.y0;\n  return p;\n}\n\nexport function inverse(p) {\n  var sinc, cosc, lon, lat, rho;\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    var c = 2 * Math.atan2(rho, this.R2);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);\n    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  gauss.inverse.apply(this, [p]);\n  p.x = adjust_lon(p.x + this.long0);\n  return p;\n}\n\nexport var names = [\"Stereographic_North_Pole\", \"Oblique_Stereographic\", \"Polar_Stereographic\", \"sterea\",\"Oblique Stereographic Alternative\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/sterea.js\n// module id = 107\n// module chunks = 0 1","// Heavily based on this tmerc projection implementation\n// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js\n\nimport pj_enfn from '../common/pj_enfn';\nimport pj_mlfn from '../common/pj_mlfn';\nimport pj_inv_mlfn from '../common/pj_inv_mlfn';\nimport adjust_lon from '../common/adjust_lon';\n\nimport {EPSLN, HALF_PI} from '../constants/values';\nimport sign from '../common/sign';\n\nexport function init() {\n  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n  if (this.es) {\n    this.en = pj_enfn(this.es);\n    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);\n  }\n}\n\n/**\n    Transverse Mercator Forward  - long/lat to x/y\n    long/lat in radians\n  */\nexport function forward(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var con;\n  var x, y;\n  var sin_phi = Math.sin(lat);\n  var cos_phi = Math.cos(lat);\n\n  if (!this.es) {\n    var b = cos_phi * Math.sin(delta_lon);\n\n    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {\n      return (93);\n    }\n    else {\n      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;\n      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));\n      b = Math.abs(y);\n\n      if (b >= 1) {\n        if ((b - 1) > EPSLN) {\n          return (93);\n        }\n        else {\n          y = 0;\n        }\n      }\n      else {\n        y = Math.acos(y);\n      }\n\n      if (lat < 0) {\n        y = -y;\n      }\n\n      y = this.a * this.k0 * (y - this.lat0) + this.y0;\n    }\n  }\n  else {\n    var al = cos_phi * delta_lon;\n    var als = Math.pow(al, 2);\n    var c = this.ep2 * Math.pow(cos_phi, 2);\n    var cs = Math.pow(c, 2);\n    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;\n    var t = Math.pow(tq, 2);\n    var ts = Math.pow(t, 2);\n    con = 1 - this.es * Math.pow(sin_phi, 2);\n    al = al / Math.sqrt(con);\n    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);\n\n    x = this.a * (this.k0 * al * (1 +\n      als / 6 * (1 - t + c +\n      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +\n      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +\n      this.x0;\n\n    y = this.a * (this.k0 * (ml - this.ml0 +\n      sin_phi * delta_lon * al / 2 * (1 +\n      als / 12 * (5 - t + 9 * c + 4 * cs +\n      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +\n      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +\n      this.y0;\n  }\n\n  p.x = x;\n  p.y = y;\n\n  return p;\n}\n\n/**\n    Transverse Mercator Inverse  -  x/y to long/lat\n  */\nexport function inverse(p) {\n  var con, phi;\n  var lat, lon;\n  var x = (p.x - this.x0) * (1 / this.a);\n  var y = (p.y - this.y0) * (1 / this.a);\n\n  if (!this.es) {\n    var f = Math.exp(x / this.k0);\n    var g = 0.5 * (f - 1 / f);\n    var temp = this.lat0 + y / this.k0;\n    var h = Math.cos(temp);\n    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));\n    lat = Math.asin(con);\n\n    if (y < 0) {\n      lat = -lat;\n    }\n\n    if ((g === 0) && (h === 0)) {\n      lon = 0;\n    }\n    else {\n      lon = adjust_lon(Math.atan2(g, h) + this.long0);\n    }\n  }\n  else { // ellipsoidal form\n    con = this.ml0 + y / this.k0;\n    phi = pj_inv_mlfn(con, this.es, this.en);\n\n    if (Math.abs(phi) < HALF_PI) {\n      var sin_phi = Math.sin(phi);\n      var cos_phi = Math.cos(phi);\n      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;\n      var c = this.ep2 * Math.pow(cos_phi, 2);\n      var cs = Math.pow(c, 2);\n      var t = Math.pow(tan_phi, 2);\n      var ts = Math.pow(t, 2);\n      con = 1 - this.es * Math.pow(sin_phi, 2);\n      var d = x * Math.sqrt(con) / this.k0;\n      var ds = Math.pow(d, 2);\n      con = con * tan_phi;\n\n      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -\n        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -\n        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -\n        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));\n\n      lon = adjust_lon(this.long0 + (d * (1 -\n        ds / 6 * (1 + 2 * t + c -\n        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -\n        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));\n    }\n    else {\n      lat = HALF_PI * sign(y);\n      lon = 0;\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n}\n\nexport var names = [\"Transverse_Mercator\", \"Transverse Mercator\", \"tmerc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/tmerc.js\n// module id = 108\n// module chunks = 0 1","import adjust_zone from '../common/adjust_zone';\nimport etmerc from './etmerc';\nexport var dependsOn = 'etmerc';\nimport {D2R} from '../constants/values';\n\n\nexport function init() {\n  var zone = adjust_zone(this.zone, this.long0);\n  if (zone === undefined) {\n    throw new Error('unknown utm zone');\n  }\n  this.lat0 = 0;\n  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;\n  this.x0 = 500000;\n  this.y0 = this.utmSouth ? 10000000 : 0;\n  this.k0 = 0.9996;\n\n  etmerc.init.apply(this);\n  this.forward = etmerc.forward;\n  this.inverse = etmerc.inverse;\n}\n\nexport var names = [\"Universal Transverse Mercator System\", \"utm\"];\nexport default {\n  init: init,\n  names: names,\n  dependsOn: dependsOn\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/utm.js\n// module id = 109\n// module chunks = 0 1","import adjust_lon from '../common/adjust_lon';\n\nimport {HALF_PI, EPSLN} from '../constants/values';\n\nimport asinz from '../common/asinz';\n\n/* Initialize the Van Der Grinten projection\n  ----------------------------------------*/\nexport function init() {\n  //this.R = 6370997; //Radius of earth\n  this.R = this.a;\n}\n\nexport function forward(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  /* Forward equations\n    -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  var x, y;\n\n  if (Math.abs(lat) <= EPSLN) {\n    x = this.x0 + this.R * dlon;\n    y = this.y0;\n  }\n  var theta = asinz(2 * Math.abs(lat / Math.PI));\n  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {\n    x = this.x0;\n    if (lat >= 0) {\n      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);\n    }\n    else {\n      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);\n    }\n    //  return(OK);\n  }\n  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));\n  var asq = al * al;\n  var sinth = Math.sin(theta);\n  var costh = Math.cos(theta);\n\n  var g = costh / (sinth + costh - 1);\n  var gsq = g * g;\n  var m = g * (2 / sinth - 1);\n  var msq = m * m;\n  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);\n  if (dlon < 0) {\n    con = -con;\n  }\n  x = this.x0 + con;\n  //con = Math.abs(con / (Math.PI * this.R));\n  var q = asq + g;\n  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);\n  if (lat >= 0) {\n    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 + con;\n  }\n  else {\n    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 - con;\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\n/* Van Der Grinten inverse equations--mapping x,y to lat/long\n  ---------------------------------------------------------*/\nexport function inverse(p) {\n  var lon, lat;\n  var xx, yy, xys, c1, c2, c3;\n  var a1;\n  var m1;\n  var con;\n  var th1;\n  var d;\n\n  /* inverse equations\n    -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  con = Math.PI * this.R;\n  xx = p.x / con;\n  yy = p.y / con;\n  xys = xx * xx + yy * yy;\n  c1 = -Math.abs(yy) * (1 + xys);\n  c2 = c1 - 2 * yy * yy + xx * xx;\n  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;\n  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;\n  a1 = (c1 - c2 * c2 / 3 / c3) / c3;\n  m1 = 2 * Math.sqrt(-a1 / 3);\n  con = ((3 * d) / a1) / m1;\n  if (Math.abs(con) > 1) {\n    if (con >= 0) {\n      con = 1;\n    }\n    else {\n      con = -1;\n    }\n  }\n  th1 = Math.acos(con) / 3;\n  if (p.y >= 0) {\n    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n  else {\n    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n\n  if (Math.abs(xx) < EPSLN) {\n    lon = this.long0;\n  }\n  else {\n    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Van_der_Grinten_I\", \"VanDerGrinten\", \"vandg\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/projections/vandg.js\n// module id = 110\n// module chunks = 0 1","export {version as default} from '../package.json';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/lib/version.js\n// module id = 111\n// module chunks = 0 1","module.exports = {\n\t\"_args\": [\n\t\t[\n\t\t\t{\n\t\t\t\t\"raw\": \"C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\t\t\t\"scope\": null,\n\t\t\t\t\"escapedName\": null,\n\t\t\t\t\"name\": null,\n\t\t\t\t\"rawSpec\": \"C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\t\t\t\"spec\": \"C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\t\t\t\"type\": \"directory\"\n\t\t\t},\n\t\t\t\"g:\\\\code\\\\melown\"\n\t\t]\n\t],\n\t\"_from\": \"C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\"_id\": \"proj4@2.4.4-alpha\",\n\t\"_inCache\": true,\n\t\"_location\": \"/proj4\",\n\t\"_phantomChildren\": {},\n\t\"_requested\": {\n\t\t\"raw\": \"C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\t\"scope\": null,\n\t\t\"escapedName\": null,\n\t\t\"name\": null,\n\t\t\"rawSpec\": \"C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\t\"spec\": \"C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\t\"type\": \"directory\"\n\t},\n\t\"_requiredBy\": [\n\t\t\"#USER\"\n\t],\n\t\"_resolved\": \"file:C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\"_shasum\": \"762f64abdcff3ac4aaa425107b49b02cb4386ec6\",\n\t\"_shrinkwrap\": null,\n\t\"_spec\": \"C:\\\\Users\\\\David\\\\AppData\\\\Local\\\\Temp\\\\npm-git-117725-13600-x0yd79.599i93haor\",\n\t\"_where\": \"g:\\\\code\\\\melown\",\n\t\"author\": \"\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/proj4js/proj4js/issues\"\n\t},\n\t\"contributors\": [\n\t\t{\n\t\t\t\"name\": \"Mike Adair\",\n\t\t\t\"email\": \"madair@dmsolutions.ca\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"Richard Greenwood\",\n\t\t\t\"email\": \"rich@greenwoodmap.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"Calvin Metcalf\",\n\t\t\t\"email\": \"calvin.metcalf@gmail.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"Richard Marsden\",\n\t\t\t\"url\": \"http://www.winwaed.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"T. Mittan\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"D. Steinwand\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"S. Nelson\"\n\t\t}\n\t],\n\t\"dependencies\": {\n\t\t\"mgrs\": \"1.0.0\",\n\t\t\"wkt-parser\": \"^1.1.3\"\n\t},\n\t\"description\": \"Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.\",\n\t\"devDependencies\": {\n\t\t\"chai\": \"~1.8.1\",\n\t\t\"curl\": \"git://github.com/cujojs/curl.git\",\n\t\t\"grunt\": \"~0.4.2\",\n\t\t\"grunt-cli\": \"~0.1.13\",\n\t\t\"grunt-contrib-connect\": \"~0.6.0\",\n\t\t\"grunt-contrib-jshint\": \"~1.1.0\",\n\t\t\"grunt-contrib-uglify\": \"~0.11.1\",\n\t\t\"grunt-mocha-phantomjs\": \"~0.4.0\",\n\t\t\"grunt-rollup\": \"^1.0.1\",\n\t\t\"istanbul\": \"~0.2.4\",\n\t\t\"mocha\": \"~1.17.1\",\n\t\t\"rollup\": \"^0.41.4\",\n\t\t\"rollup-plugin-json\": \"^2.0.1\",\n\t\t\"rollup-plugin-node-resolve\": \"^2.0.0\",\n\t\t\"tin\": \"~0.4.0\"\n\t},\n\t\"directories\": {\n\t\t\"test\": \"test\",\n\t\t\"doc\": \"docs\"\n\t},\n\t\"gitHead\": \"3494d52f2c543b2ee7bea04292924a771dbd3eb8\",\n\t\"homepage\": \"https://github.com/proj4js/proj4js#readme\",\n\t\"license\": \"MIT\",\n\t\"main\": \"dist/proj4-src.js\",\n\t\"module\": \"lib/index.js\",\n\t\"name\": \"proj4\",\n\t\"optionalDependencies\": {},\n\t\"readme\": \"# PROJ4JS [![Build Status](https://travis-ci.org/proj4js/proj4js.svg)](https://travis-ci.org/proj4js/proj4js)\\n\\nProj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.\\nOriginally a port of [PROJ.4](http://trac.osgeo.org/proj/) and [GCTCP C](http://edcftp.cr.usgs.gov/pub//software/gctpc) it is\\na part of the [MetaCRS](http://wiki.osgeo.org/wiki/MetaCRS) group of projects.\\n\\n## Installing\\n\\nDepending on your preferences\\n\\n```bash\\nnpm install proj4\\nbower install proj4\\ncomponent install proj4js/proj4js\\n```\\n\\nor just manually grab the file `proj4.js` from the [latest release](https://github.com/proj4js/proj4js/releases)'s `dist/` folder.\\n\\nif you do not want to download anything, Proj4js is also hosted on [cdnjs](http://www.cdnjs.com/libraries/proj4js) for direct use in your browser applications.\\n\\n## Using\\n\\nthe basic signature is:\\n\\n```javascript\\nproj4(fromProjection[, toProjection, coordinates])\\n```\\n\\nProjections can be proj or wkt strings.\\n\\nCoordinates may an object of the form `{x:x,y:y}` or an array of the form `[x,y]`.\\n\\nWhen all 3 arguments  are given, the result is that the coordinates are transformed from projection1 to projection 2. And returned in the same format that they were given in.\\n\\n```javascript\\nvar firstProjection = 'PROJCS[\\\"NAD83 / Massachusetts Mainland\\\",GEOGCS[\\\"NAD83\\\",DATUM[\\\"North_American_Datum_1983\\\",SPHEROID[\\\"GRS 1980\\\",6378137,298.257222101,AUTHORITY[\\\"EPSG\\\",\\\"7019\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6269\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.01745329251994328,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4269\\\"]],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],PROJECTION[\\\"Lambert_Conformal_Conic_2SP\\\"],PARAMETER[\\\"standard_parallel_1\\\",42.68333333333333],PARAMETER[\\\"standard_parallel_2\\\",41.71666666666667],PARAMETER[\\\"latitude_of_origin\\\",41],PARAMETER[\\\"central_meridian\\\",-71.5],PARAMETER[\\\"false_easting\\\",200000],PARAMETER[\\\"false_northing\\\",750000],AUTHORITY[\\\"EPSG\\\",\\\"26986\\\"],AXIS[\\\"X\\\",EAST],AXIS[\\\"Y\\\",NORTH]]';\\nvar secondProjection = \\\"+proj=gnom +lat_0=90 +lon_0=0 +x_0=6300000 +y_0=6300000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs\\\";\\n//I'm not going to redefine those two in latter examples.\\nproj4(firstProjection,secondProjection,[2,5]);\\n// [-2690666.2977344505, 3662659.885459918]\\n```\\n\\nIf only 1 projection is given then it is assumed that it is being projected *from* WGS84 (fromProjection is WGS84).\\n\\n```javascript\\nproj4(firstProjection,[-71,41]);\\n// [242075.00535055372, 750123.32090043]\\n```\\n\\nIf no coordinates are given an object with two methods is returned, its methods are `forward` which projects from the first projection to the second and `inverse` which projects from the second to the first.\\n\\n```javascript\\nproj4(firstProjection,secondProjection).forward([2,5]);\\n// [-2690666.2977344505, 3662659.885459918]\\nproj4(secondProjection,firstProjection).inverse([2,5]);\\n// [-2690666.2977344505, 3662659.885459918]\\n```\\n\\nand as above if only one projection is given, it's assumed to be coming from wgs84\\n\\n```javascript\\nproj4(firstProjection).forward([-71,41]);\\n// [242075.00535055372, 750123.32090043]\\nproj4(firstProjection).inverse([242075.00535055372, 750123.32090043]);\\n//[-71, 40.99999999999986]\\n//the floating points to answer your question\\n```\\n\\n## Named Projections\\n\\nIf you prefer to define a projection as a string and reference it that way, you may use the proj4.defs method which can be called 2 ways, with a name and projection:\\n\\n```js\\nproj4.defs('WGS84', \\\"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\\\");\\n```\\n\\nor with an array\\n\\n```js\\nproj4.defs([\\n  [\\n    'EPSG:4326',\\n    '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees'],\\n  [\\n    'EPSG:4269',\\n    '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees'\\n  ]\\n]);\\n```\\n\\nyou can then do\\n\\n```js\\nproj4('EPSG:4326');\\n```\\n\\ninstead of writing out the whole proj definition, by default proj4 has the following projections predefined:\\n\\n- 'EPSG:4326', which has the following alias\\n    - 'WGS84'\\n- 'EPSG:4269'\\n- 'EPSG:3857', which has the following aliases\\n    - 'EPSG:3785'\\n    - 'GOOGLE'\\n    - 'EPSG:900913'\\n    - 'EPSG:102113'\\n\\ndefined projections can also be accessed through the proj4.defs function (`proj4.defs('EPSG:4326')`).\\n\\nproj4.defs can also be used to define a named alias:\\n\\n```javascript\\nproj4.defs('urn:x-ogc:def:crs:EPSG:4326', proj4.defs('EPSG:4326'));\\n```\\n\\n## TypeScript\\n\\nTypeScript implementation was added to the [DefinitelyTyped repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\\n\\n```bash\\n$ npm install --save @types/proj4\\n```\\n\\n## Developing\\nto set up build tools make sure you have node and grunt-cli installed and then run `npm install`\\n\\nto do the complete build and browser tests run\\n\\n```bash\\nnode_modules/.bin/grunt\\n```\\n\\nto run node tests run\\n\\n```bash\\nnpm test\\n```\\n\\nto run node tests with coverage run\\n\\n```bash\\nnpm test --coverage\\n```\\n\\nto create a build with only default projections (latlon and Mercator) run\\n\\n```bash\\nnode_modules/.bin/grunt build\\n```\\n\\nto create a build with only custom projections include a comma separated list of projections codes (the file name in 'lib/projections' without the '.js') after a colon, e.g.\\n\\n```bash\\nnode_modules/.bin/grunt build:tmerc\\n#includes transverse Mercator\\nnode_modules/.bin/grunt build:lcc\\n#includes lambert conformal conic\\nnode_modules/.bin/grunt build:omerc,moll\\n#includes oblique Mercator and Mollweide\\n```\\n\",\n\t\"readmeFilename\": \"README.md\",\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git://github.com/proj4js/proj4js.git\"\n\t},\n\t\"scripts\": {\n\t\t\"build\": \"grunt\",\n\t\t\"build:tmerc\": \"grunt build:tmerc\",\n\t\t\"test\": \"npm run build && istanbul test _mocha test/test.js\"\n\t},\n\t\"version\": \"2.4.4-alpha\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/package.json\n// module id = 112\n// module chunks = 0 1","import tmerc from './lib/projections/tmerc';\nimport etmerc from './lib/projections/etmerc';\nimport utm from './lib/projections/utm';\nimport sterea from './lib/projections/sterea';\nimport stere from './lib/projections/stere';\nimport somerc from './lib/projections/somerc';\nimport omerc from './lib/projections/omerc';\nimport lcc from './lib/projections/lcc';\nimport krovak from './lib/projections/krovak';\nimport cass from './lib/projections/cass';\nimport laea from './lib/projections/laea';\nimport aea from './lib/projections/aea';\nimport gnom from './lib/projections/gnom';\nimport cea from './lib/projections/cea';\nimport eqc from './lib/projections/eqc';\nimport poly from './lib/projections/poly';\nimport nzmg from './lib/projections/nzmg';\nimport mill from './lib/projections/mill';\nimport sinu from './lib/projections/sinu';\nimport moll from './lib/projections/moll';\nimport eqdc from './lib/projections/eqdc';\nimport vandg from './lib/projections/vandg';\nimport aeqd from './lib/projections/aeqd';\nimport ortho from './lib/projections/ortho';\nimport geocent from './lib/projections/geocent';\nimport qsc from './lib/projections/qsc';\nexport default function(proj4){\n  proj4.Proj.projections.add(tmerc);\n  proj4.Proj.projections.add(etmerc);\n  proj4.Proj.projections.add(utm);\n  proj4.Proj.projections.add(sterea);\n  proj4.Proj.projections.add(stere);\n  proj4.Proj.projections.add(somerc);\n  proj4.Proj.projections.add(omerc);\n  proj4.Proj.projections.add(lcc);\n  proj4.Proj.projections.add(krovak);\n  proj4.Proj.projections.add(cass);\n  proj4.Proj.projections.add(laea);\n  proj4.Proj.projections.add(aea);\n  proj4.Proj.projections.add(gnom);\n  proj4.Proj.projections.add(cea);\n  proj4.Proj.projections.add(eqc);\n  proj4.Proj.projections.add(poly);\n  proj4.Proj.projections.add(nzmg);\n  proj4.Proj.projections.add(mill);\n  proj4.Proj.projections.add(sinu);\n  proj4.Proj.projections.add(moll);\n  proj4.Proj.projections.add(eqdc);\n  proj4.Proj.projections.add(vandg);\n  proj4.Proj.projections.add(aeqd);\n  proj4.Proj.projections.add(ortho);\n  proj4.Proj.projections.add(geocent);\n  proj4.Proj.projections.add(qsc);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/proj4/projs.js\n// module id = 113\n// module chunks = 0 1","export default parseString;\n\nvar NEUTRAL = 1;\nvar KEYWORD = 2;\nvar NUMBER = 3;\nvar QUOTED = 4;\nvar AFTERQUOTE = 5;\nvar ENDED = -1;\nvar whitespace = /\\s/;\nvar latin = /[A-Za-z]/;\nvar keyword = /[A-Za-z84]/;\nvar endThings = /[,\\]]/;\nvar digets = /[\\d\\.E\\-\\+]/;\n// const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction Parser(text) {\n  if (typeof text !== 'string') {\n    throw new Error('not a string');\n  }\n  this.text = text.trim();\n  this.level = 0;\n  this.place = 0;\n  this.root = null;\n  this.stack = [];\n  this.currentObject = null;\n  this.state = NEUTRAL;\n}\nParser.prototype.readCharicter = function() {\n  var char = this.text[this.place++];\n  if (this.state !== QUOTED) {\n    while (whitespace.test(char)) {\n      if (this.place >= this.text.length) {\n        return;\n      }\n      char = this.text[this.place++];\n    }\n  }\n  switch (this.state) {\n    case NEUTRAL:\n      return this.neutral(char);\n    case KEYWORD:\n      return this.keyword(char)\n    case QUOTED:\n      return this.quoted(char);\n    case AFTERQUOTE:\n      return this.afterquote(char);\n    case NUMBER:\n      return this.number(char);\n    case ENDED:\n      return;\n  }\n};\nParser.prototype.afterquote = function(char) {\n  if (char === '\"') {\n    this.word += '\"';\n    this.state = QUOTED;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = this.word.trim();\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in afterquote yet, index ' + this.place);\n};\nParser.prototype.afterItem = function(char) {\n  if (char === ',') {\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n    }\n    this.word = null;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (char === ']') {\n    this.level--;\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n      this.word = null;\n    }\n    this.state = NEUTRAL;\n    this.currentObject = this.stack.pop();\n    if (!this.currentObject) {\n      this.state = ENDED;\n    }\n\n    return;\n  }\n};\nParser.prototype.number = function(char) {\n  if (digets.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = parseFloat(this.word);\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in number yet, index ' + this.place);\n};\nParser.prototype.quoted = function(char) {\n  if (char === '\"') {\n    this.state = AFTERQUOTE;\n    return;\n  }\n  this.word += char;\n  return;\n};\nParser.prototype.keyword = function(char) {\n  if (keyword.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (char === '[') {\n    var newObjects = [];\n    newObjects.push(this.word);\n    this.level++;\n    if (this.root === null) {\n      this.root = newObjects;\n    } else {\n      this.currentObject.push(newObjects);\n    }\n    this.stack.push(this.currentObject);\n    this.currentObject = newObjects;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in keyword yet, index ' + this.place);\n};\nParser.prototype.neutral = function(char) {\n  if (latin.test(char)) {\n    this.word = char;\n    this.state = KEYWORD;\n    return;\n  }\n  if (char === '\"') {\n    this.word = '';\n    this.state = QUOTED;\n    return;\n  }\n  if (digets.test(char)) {\n    this.word = char;\n    this.state = NUMBER;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in neutral yet, index ' + this.place);\n};\nParser.prototype.output = function() {\n  while (this.place < this.text.length) {\n    this.readCharicter();\n  }\n  if (this.state === ENDED) {\n    return this.root;\n  }\n  throw new Error('unable to parse string \"' +this.text + '\". State is ' + this.state);\n};\n\nfunction parseString(txt) {\n  var parser = new Parser(txt);\n  return parser.output();\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/wkt-parser/parser.js\n// module id = 114\n// module chunks = 0 1","\n\nfunction mapit(obj, key, value) {\n  if (Array.isArray(key)) {\n    value.unshift(key);\n    key = null;\n  }\n  var thing = key ? {} : obj;\n\n  var out = value.reduce(function(newObj, item) {\n    sExpr(item, newObj);\n    return newObj\n  }, thing);\n  if (key) {\n    obj[key] = out;\n  }\n}\n\nexport function sExpr(v, obj) {\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  var key = v.shift();\n  if (key === 'PARAMETER') {\n    key = v.shift();\n  }\n  if (v.length === 1) {\n    if (Array.isArray(v[0])) {\n      obj[key] = {};\n      sExpr(v[0], obj[key]);\n      return;\n    }\n    obj[key] = v[0];\n    return;\n  }\n  if (!v.length) {\n    obj[key] = true;\n    return;\n  }\n  if (key === 'TOWGS84') {\n    obj[key] = v;\n    return;\n  }\n  if (!Array.isArray(key)) {\n    obj[key] = {};\n  }\n\n  var i;\n  switch (key) {\n    case 'UNIT':\n    case 'PRIMEM':\n    case 'VERT_DATUM':\n      obj[key] = {\n        name: v[0].toLowerCase(),\n        convert: v[1]\n      };\n      if (v.length === 3) {\n        sExpr(v[2], obj[key]);\n      }\n      return;\n    case 'SPHEROID':\n    case 'ELLIPSOID':\n      obj[key] = {\n        name: v[0],\n        a: v[1],\n        rf: v[2]\n      };\n      if (v.length === 4) {\n        sExpr(v[3], obj[key]);\n      }\n      return;\n    case 'PROJECTEDCRS':\n    case 'PROJCRS':\n    case 'GEOGCS':\n    case 'GEOCCS':\n    case 'PROJCS':\n    case 'LOCAL_CS':\n    case 'GEODCRS':\n    case 'GEODETICCRS':\n    case 'GEODETICDATUM':\n    case 'EDATUM':\n    case 'ENGINEERINGDATUM':\n    case 'VERT_CS':\n    case 'VERTCRS':\n    case 'VERTICALCRS':\n    case 'COMPD_CS':\n    case 'COMPOUNDCRS':\n    case 'ENGINEERINGCRS':\n    case 'ENGCRS':\n    case 'FITTED_CS':\n    case 'LOCAL_DATUM':\n    case 'DATUM':\n      v[0] = ['name', v[0]];\n      mapit(obj, key, v);\n      return;\n    default:\n      i = -1;\n      while (++i < v.length) {\n        if (!Array.isArray(v[i])) {\n          return sExpr(v, obj[key]);\n        }\n      }\n      return mapit(obj, key, v);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/wkt-parser/process.js\n// module id = 115\n// module chunks = 0 1","// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\r\n\r\nvar URL = window.URL || window.webkitURL;\r\nmodule.exports = function(content, url) {\r\n  try {\r\n    try {\r\n      var blob;\r\n      try { // BlobBuilder = Deprecated, but widely implemented\r\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\r\n        blob = new BlobBuilder();\r\n        blob.append(content);\r\n        blob = blob.getBlob();\r\n      } catch(e) { // The proposed API\r\n        blob = new Blob([content]);\r\n      }\r\n      return new Worker(URL.createObjectURL(blob));\r\n    } catch(e) {\r\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\r\n    }\r\n  } catch(e) {\r\n    if (!url) {\r\n      throw Error('Inline worker is not supported');\r\n    }\r\n    return new Worker(url);\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/worker-loader/createInlineWorker.js\n// module id = 116\n// module chunks = 0 1","module.exports = function() {\n\treturn require(\"!!g:\\\\code\\\\melown\\\\node_modules\\\\worker-loader\\\\createInlineWorker.js\")(\"/*!\\n * Copyright (c) 2017 Melown Technologies SE\\n * \\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n * \\n * *  Redistributions of source code must retain the above copyright notice,\\n *    this list of conditions and the following disclaimer.\\n * \\n * *  Redistributions in binary form must reproduce the above copyright\\n *    notice, this list of conditions and the following disclaimer in the\\n *    documentation and/or other materials provided with the distribution.\\n * \\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\\n * POSSIBILITY OF SUCH DAMAGE.\\n * \\n */\\n/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// identity function for calling harmony imports with the correct context\\n/******/ \\t__webpack_require__.i = function(value) { return value; };\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, {\\n/******/ \\t\\t\\t\\tconfigurable: false,\\n/******/ \\t\\t\\t\\tenumerable: true,\\n/******/ \\t\\t\\t\\tget: getter\\n/******/ \\t\\t\\t});\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = 9);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return globals; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return clamp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"e\\\", function() { return vec3Normalize; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"f\\\", function() { return vec3Length; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"g\\\", function() { return vec3Cross; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return simpleFmtCall; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"d\\\", function() { return getHash; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"h\\\", function() { return stringToUint8Array; });\\n\\nvar globals = {\\n    stylesheetData : {},\\n    stylesheetLayers : {},\\n    stylesheetBitmaps : {},\\n    stylesheetFonts : {},\\n    stylesheetConstants : {},\\n    stylesheetVariables : {},\\n    fonts : {},\\n    fontsMap : {},\\n    fontsStorage : {},\\n    forceOrigin : false,\\n    forceScale : [1,1,1],\\n    bboxMin : [0,0,0],\\n    bboxMax : [1,1,1],\\n    geocent : false,\\n    tileX : 0,\\n    tileY : 0,\\n    tileLod : 0,\\n    tileSize : 1,\\n    hitState : 0,\\n    pixelFactor : 1,\\n    alwaysEventInfo : false,\\n    metricUnits : true,\\n    groupOptimize : true,\\n    groupOrigin : [0,0,0],\\n    messageBuffer : new Array(65536),\\n    messageBufferIndex : 0,\\n    messageBufferSize : 65536,\\n    messagePackSize : 0,\\n    signatureCounter : 0,\\n    autoLod : false,\\n    featureType : null,\\n    groupId : null,\\n    disableLog : false,\\n    reduceMode : 'scr-count4',\\n    reduceParams : null,\\n};\\n\\n\\nfunction clamp(value, min, max) {\\n    if (value < min) {\\n        value = min;\\n    }\\n\\n    if (value > max) {\\n        value = max;\\n    }\\n\\n    return value;\\n}\\n\\n\\nfunction vec3Normalize(a, b) {\\n    b || (b = a);\\n    var c = a[0],\\n        d = a[1],\\n        e = a[2],\\n        g = Math.sqrt(c * c + d * d + e * e);\\n    if (g) {\\n        if (g == 1) {\\n            b[0] = c;\\n            b[1] = d;\\n            b[2] = e;\\n            return b;\\n        }\\n    } else {\\n        b[0] = 0;\\n        b[1] = 0;\\n        b[2] = 0;\\n        return b;\\n    }\\n    g = 1 / g;\\n    b[0] = c * g;\\n    b[1] = d * g;\\n    b[2] = e * g;\\n    return b;\\n}\\n\\n\\nfunction vec3Length(a) {\\n    var b = a[0],\\n        c = a[1];\\n    a = a[2];\\n    return Math.sqrt(b * b + c * c + a * a);\\n}\\n\\n\\nfunction vec3Cross(a, b, c) {\\n    c || (c = a);\\n    var d = a[0],\\n        e = a[1];\\n    a = a[2];\\n    var g = b[0],\\n        f = b[1];\\n    b = b[2];\\n    c[0] = e * b - a * f;\\n    c[1] = a * g - d * b;\\n    c[2] = d * f - e * g;\\n    return c;\\n}\\n\\n\\nfunction getHash(str) {\\n    if (!str || str.length === 0) {\\n        return 0;    \\n    }\\n\\n    var hash = 0, c;\\n    for (var i = 0, li = str.length; i < li; i++) {\\n        c   = str.charCodeAt(i);\\n        hash  = ((hash << 5) - hash) + c;\\n        hash |= 0; // Convert to 32bit integer\\n    }\\n\\n    return hash;\\n}\\n\\n\\nvar simpleFmtCall = (function obj(str, call) {\\n    if (!str || str == '') {\\n        return '';\\n    }\\n\\n    var i = str.indexOf('{'), li, str2;\\n\\n    if (i == -1) {\\n        return str;\\n    } else {\\n        str2 = i > 0 ? str.substring(0, i) : '';\\n    }\\n\\n    var counter = 0;\\n    var begin = -1;\\n\\n    for (li = str.length; i < li; i++) {\\n        var c = str.charAt(i);\\n\\n        if (c == '{') {\\n            if (counter == 0) {\\n                begin = i;\\n            }\\n\\n            counter++;\\n        } else if (c == '}') {\\n            counter--;\\n\\n            if (counter == 0) {\\n                str2 += call(str.substring(begin+1, i));\\n            }\\n            \\n        } else if (counter == 0) {\\n            str2 += c;\\n        }\\n    }\\n\\n    return str2;\\n});\\n\\n/*\\nfunction copyArrayToBuffer(view, index, array) {\\n    for (var i = 0, li = array.length; i < li; i++) {\\n        view.setFloat32(index, array[i]); index += 4;\\n    }\\n\\n    return index;\\n}\\n\\nfunction copyDynamicArrayToBuffer(view, index, array) {\\n    if (array) {\\n        view.setUint8(index, array.length); index += 1;\\n\\n        for (var i = 0, li = array.length; i < li; i++) {\\n            view.setFloat32(index, array[i]); index += 4;\\n        }\\n    } else {\\n        view.setUint8(index, 0); index += 1;\\n    }\\n\\n    return index;\\n}\\n\\nfunction copyDynamicArrayOfArraysToBuffer(view, index, array) {\\n    if (array) {\\n        view.setUint16(index, array.length); index += 2;\\n\\n        for (var i = 0, li = array.length; i < li; i++) {\\n            var subarray = array[i];\\n\\n            for (var j = 0, lj = array.length; j < lj; j++) {\\n                view.setUint16(index, subarray[j]); index += 2;\\n            }\\n        }\\n    } else {\\n        view.setUint16(index, 0); index += 2;\\n    }\\n\\n    return index;\\n}\\n\\nfunction getSizeOfArrayOfArrays(array) {\\n    var size = 0;\\n\\n    for (var i = 0, li = array.length; i < li; i++) {\\n        size += array[i].length;\\n    }\\n\\n    return size;\\n}\\n*/\\n\\n//var textEncoderUtf8 = null; //(typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\\nvar textEncoderUtf8 = (typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\\n\\nfunction stringToUint8Array(str) {\\n    if (textEncoderUtf8) {\\n        return textEncoderUtf8.encode(str);\\n    } else {\\n\\n        /*\\n        console.log('' + (str.length * 2));\\n\\n        var buffer = new ArrayBuffer(str.length * 2);\\n        var view = new Uint16Array(buffer);\\n        for (var i = 0, li = str.length; i < li; i++) {\\n            view[i] = str.charCodeAt(i);\\n        }\\n        return new Uint8Array(buffer);\\n        */\\n\\n\\n        // 1. Let S be the DOMString value.\\n        var s = String(str);\\n\\n        // 2. Let n be the length of S.\\n        var n = s.length;\\n\\n        // 3. Initialize i to 0.\\n        var i = 0;\\n\\n        // 4. Initialize U to be an empty sequence of Unicode characters.\\n        var u = [];\\n\\n        // 5. While i < n:\\n        while (i < n) {\\n\\n          // 1. Let c be the code unit in S at index i.\\n          var c = s.charCodeAt(i);\\n\\n          // 2. Depending on the value of c:\\n\\n          // c < 0xD800 or c > 0xDFFF\\n          if (c < 0xD800 || c > 0xDFFF) {\\n            // Append to U the Unicode character with code point c.\\n            u.push(c);\\n          }\\n\\n          // 0xDC00 ≤ c ≤ 0xDFFF\\n          else if (0xDC00 <= c && c <= 0xDFFF) {\\n            // Append to U a U+FFFD REPLACEMENT CHARACTER.\\n            u.push(0xFFFD);\\n          }\\n\\n          // 0xD800 ≤ c ≤ 0xDBFF\\n          else if (0xD800 <= c && c <= 0xDBFF) {\\n            // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\\n            // CHARACTER.\\n            if (i === n - 1) {\\n              u.push(0xFFFD);\\n            }\\n            // 2. Otherwise, i < n−1:\\n            else {\\n              // 1. Let d be the code unit in S at index i+1.\\n              var d = s.charCodeAt(i + 1);\\n\\n              // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\\n              if (0xDC00 <= d && d <= 0xDFFF) {\\n                // 1. Let a be c & 0x3FF.\\n                var a = c & 0x3FF;\\n\\n                // 2. Let b be d & 0x3FF.\\n                var b = d & 0x3FF;\\n\\n                // 3. Append to U the Unicode character with code point\\n                // 2^16+2^10*a+b.\\n                u.push(0x10000 + (a << 10) + b);\\n\\n                // 4. Set i to i+1.\\n                i += 1;\\n              }\\n\\n              // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\\n              // U+FFFD REPLACEMENT CHARACTER.\\n              else  {\\n                u.push(0xFFFD);\\n              }\\n            }\\n          }\\n\\n          // 3. Set i to i+1.\\n          i += 1;\\n        }\\n\\n        // 6. Return U.\\n        return new Uint8Array((new Uint32Array(u)).buffer);        \\n    }\\n}\\n\\n/*\\nvar textDecoderUtf8 = TextEncoder ? (new TextDecoder('utf-8')) : null;\\n\\nfunction unint8ArrayToString(array) {\\n    if (textDecoderUtf8) {\\n        return textDecoderUtf8.decode(array);\\n    } else {\\n        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\\n    }\\n}\\n*/\\n\\n\\n\\n\\n/***/ }),\\n/* 1 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return optimizeGroupMessages; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return postGroupMessageFast; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return postGroupMessageLite; });\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"a\\\" /* globals */], stringToUint8Array = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"h\\\" /* stringToUint8Array */];\\nvar tmpVertexBuffer = new Uint8Array(65536*4*4*4*4);\\nvar tmpVertexBuffer2 = new Uint8Array(65536*4*4*4*4);\\n\\nfunction postGroupMessageFast(command, type, message, buffers, signature) {\\n\\n    var message2 = stringToUint8Array(JSON.stringify(message));\\n    var messageSize = 1+1+4+message2.byteLength, i, li;\\n\\n    for (i = 0, li = buffers.length; i < li; i++) {\\n        messageSize += 4+buffers[i].byteLength;\\n    }\\n\\n    var buff = new Uint8Array(messageSize);\\n    var view = new DataView(buff.buffer), index = 0, index2 = 0;\\n\\n    view.setUint8(index, command); index += 1;\\n    view.setUint8(index, type); index += 1;\\n    view.setUint32(index, message2.byteLength); index += 4;\\n    buff.set(message2, index); index += message2.byteLength;\\n    index2 = index;\\n\\n    for (i = 0, li = buffers.length; i < li; i++) {\\n        view.setUint32(index, buffers[i].length); index += 4;\\n        buff.set( new Uint8Array(buffers[i].buffer), index); index += buffers[i].byteLength;\\n    }\\n\\n    postGroupMessageDirect(command, type, buff.buffer, index2, signature, message['hitable'], message['totalPoints'], (type == 11) ? message : null);\\n}\\n\\nfunction postGroupMessageLite(command, type, number) {\\n    var messageSize = 1+1+4, index = 0;\\n\\n    var buff = new ArrayBuffer(messageSize);\\n    var view = new DataView(buff), index = 0;\\n\\n    view.setUint8(index, command); index += 1;\\n    view.setUint8(index, type); index += 1;\\n    view.setUint32(index, (number ? number : 0)); index += 4;\\n\\n    postGroupMessageDirect(command, type, buff, index, \\\"\\\");\\n}\\n\\n\\nfunction postGroupMessageDirect(command, type, message, buffersIndex, signature, hitable, totalPoints, job2) {\\n\\n    if (globals.messageBufferIndex >= globals.messageBufferSize) { \\n        var oldBuffer = globals.messageBuffer; \\n        globals.messageBufferSize += 65536;\\n        globals.messageBuffer = new Array(globals.messageBufferSize);\\n        \\n        for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\\n            globals.messageBuffer[i] = oldBuffer[i];\\n        }\\n    }\\n    \\n    globals.messageBuffer[globals.messageBufferIndex] = { command: command, type: type, job : message, buffersIndex: buffersIndex, signature: signature, hitable: hitable, totalPoints: totalPoints, job2: job2 };\\n    globals.messageBufferIndex++;\\n    globals.messagePackSize += message.byteLength;\\n}\\n\\n\\nfunction optimizeGroupMessages() {\\n\\n    //loop messages\\n    var messages = globals.messageBuffer;\\n    var j, lk, k, message2, job2, bufferSize, buffer, view, index, length, buff, buff2, index, count, totalVertices;\\n\\n\\n    for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\\n        var message = messages[i];\\n        var job = message.job;\\n        var type = message.type;\\n        var signature = message.signature;\\n\\n        //console.log('command: ' + message.command + ' type:' + message.type);\\n        \\n        if (!message.hitable && !message.reduced && \\n            (type >= 6 && type <= 11)) {\\n            \\n            switch(type) {\\n            case 6:\\n                count = 0;\\n\\n                //get message vertices length and copy vertices to buffer\\n                length = (new DataView(message.job)).getUint32(message.buffersIndex) * 4;\\n\\n                tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\\n                bufferSize = length;\\n\\n                for (j = i + 1; j < li; j++) {\\n                    message2 = messages[j];\\n\\n                    if (message2.signature == signature) {\\n                        message2.reduced = true;\\n                        count++;\\n\\n                        //get message2 vertices length\\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex) * 4;\\n\\n                        // copy vertices to buffer\\n                        tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\\n                        bufferSize += length;\\n                    }\\n                }\\n\\n                if (count > 0) {\\n\\n                    //create new message with merged vertices\\n                    buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\\n                    view = new DataView(buffer.buffer);\\n                    buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\\n\\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\\n\\n                    globals.messagePackSize -= message.job.byteLength;\\n                    globals.messagePackSize += buffer.byteLength;\\n                    message.job = buffer.buffer;\\n                }\\n\\n                break;\\n                    \\n            case 9:\\n            case 11:\\n            case 7:\\n\\n                count = 0;\\n                totalVertices = 0;\\n\\n                //get message vertices length and copy vertices to buffer\\n                length = (new DataView(message.job)).getUint32(message.buffersIndex);\\n                //console.log('count: ' + count + ' totalPoints:' + message.totalPoints + ' length: ' + length);\\n                length *= 4;\\n                totalVertices += length;\\n\\n\\n                tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\\n                tmpVertexBuffer2.set(new Uint8Array(message.job, message.buffersIndex+4+length+4, length), 0);\\n                bufferSize = length;\\n\\n                for (j = i + 1; j < li; j++) {\\n                    message2 = messages[j];\\n\\n                    if (message2.signature == signature) {\\n                        message2.reduced = true;\\n                        globals.messagePackSize -= message2.job.byteLength;\\n                        count++;\\n\\n                        //get message2 vertices length\\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex);\\n                        //console.log('count:' + count + ' totalPoints:' + message2.totalPoints + ' length:' + length + ' jobl:' + message2.job.byteLength + ' remaning:' + (message2.job.byteLength - (message2.buffersIndex+4)) + ' bufferSize:' + bufferSize + ' totalVertices:' + totalVertices);\\n                        length *= 4;\\n                        totalVertices += length;\\n\\n\\n                        // copy vertices to buffer\\n                        tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\\n\\n                        // copy normals to buffer\\n                        tmpVertexBuffer2.set(new Uint8Array(message2.job, message2.buffersIndex+4+length+4, length), bufferSize);\\n                        bufferSize += length;\\n\\n                        if (type == 11) {\\n                            var files = message.job2['files'];\\n                            var files2 = message2.job2['files'];\\n\\n                            for (k = 0, lk = files2.length; k < lk; k++) {\\n                                if (!files[k]) {\\n                                    files[k] = [];\\n                                }\\n\\n                                for (var m = 0, lm = files2[k].length; m < lm; m++) {\\n                                    if (files[k].indexOf(files2[k][m]) == -1) {\\n                                        files[k].push(files2[k][m]);\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (count > 0) {\\n\\n                    //create new message with merged vertices\\n\\n                    if (type == 11) { //we have to rebuild header\\n                        var buffjob = stringToUint8Array(JSON.stringify(message.job2));\\n\\n                        buffer = new Uint8Array(1+1+4+buffjob.byteLength+2*(4+bufferSize));\\n                        view = new DataView(buffer.buffer), index = 0;\\n\\n                        view.setUint8(index, message.command); index += 1;\\n                        view.setUint8(index, type); index += 1;\\n                        view.setUint32(index, buffjob.byteLength); index += 4;\\n                        buffer.set(buffjob, index); index += buffjob.byteLength;\\n\\n                        message.buffersIndex = index;\\n                    } else {\\n                        buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\\n                        view = new DataView(buffer.buffer);\\n                        buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\\n                    }\\n\\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\\n\\n                    view.setUint32(message.buffersIndex + 4 + bufferSize, bufferSize / 4);\\n                    buffer.set(new Uint8Array(tmpVertexBuffer2.buffer, 0, bufferSize), message.buffersIndex + 4 + bufferSize + 4 );\\n\\n                    globals.messagePackSize -= message.job.byteLength;\\n                    globals.messagePackSize += buffer.byteLength;\\n                    message.job = buffer.buffer;\\n\\n                }\\n\\n                break;\\n            }\\n        \\n        }\\n    }\\n\\n    var buffer = new Uint8Array(globals.messagePackSize), index = 0;\\n\\n    for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\\n        var message = globals.messageBuffer[i];\\n\\n        if (!message.reduced) {\\n            buffer.set(new Uint8Array(message.job), index);\\n            index += globals.messageBuffer[i].job.byteLength;\\n        }\\n    }\\n\\n    //console.log('send:' + buffer.length);\\n\\n    postMessage({'command' : 'addPackedCommands', 'buffer': buffer}, [buffer.buffer]);\\n\\n    globals.messageBufferIndex = 0;\\n    globals.messagePackSize = 0;\\n} \\n\\n\\n\\n\\n\\n\\n/***/ }),\\n/* 2 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_text_js__ = __webpack_require__(3);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"e\\\", function() { return getFilterResult; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"d\\\", function() { return processStylesheet; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return getLayer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return getLayerPropertyValue; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"g\\\", function() { return getLayerExpresionValue; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"f\\\", function() { return getLayerPropertyValueInner; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return makeFasterFilter; });\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"a\\\" /* globals */];\\nvar clamp = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"b\\\" /* clamp */];\\nvar simpleFmtCall = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"c\\\" /* simpleFmtCall */];\\nvar getHash = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"d\\\" /* getHash */];\\nvar hasLatin = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\\\"c\\\" /* hasLatin */], isCJK = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\\\"d\\\" /* isCJK */];\\nvar areTextCharactersAvailable = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\\\"e\\\" /* areTextCharactersAvailable */];\\n\\n\\nvar getLayer = function(layerId, featureType, index) {\\n    var layer = globals.stylesheetData.layers[layerId];\\n    if (layer == null) {\\n        logError('wrong-Layer', layerId, null, null, index, featureType);\\n        return {};\\n    } else {\\n        return layer;\\n    }\\n};\\n\\n\\nvar getLayerExpresionValue = function(layer, value, feature, lod, key) {\\n    var finalValue;\\n\\n    switch(typeof value) {\\n    case 'string':\\n\\n        if (value.length > 0) {\\n            //is it feature property?\\n            switch (value.charAt(0)) {\\n                case '#': \\n                    //debugger;\\n                    switch(value) {\\n                        case '#id':        return feature.id;\\n                        case '#type':      return globals.featureType;\\n                        case '#group':     return globals.groupId;\\n                        case '#lod':       return globals.tileLod;\\n                        case '#tileSize':  return globals.tileSize;\\n                        case '#pixelSize': return globals.pixelSize;\\n                        case '#metric':    return globals.metricUnits;\\n                        case '#dpr':       return globals.pixelFactor;\\n                    }\\n\\n                    return finalValue;\\n\\n                case '$':\\n                case '@':\\n\\n                    switch (value.charAt(0)) {\\n                        case '$': finalValue = feature.properties[value.substr(1)]; break;\\n                        case '@': finalValue = globals.stylesheetConstants[value]; break;\\n                    }\\n\\n                    if (typeof finalValue == 'undefined') {\\n                        logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\\n                        return finalValue;\\n                    }\\n\\n                    return getLayerExpresionValue(layer, finalValue, feature, lod, key);\\n            }\\n\\n            return simpleFmtCall(value, (function(str){  \\n\\n                if (str.length > 0) {\\n\\n                    switch (str.charAt(0)) {\\n                        case '#': \\n                            //debugger;\\n                            switch(str) {\\n                                case '#id':        return feature.id;\\n                                case '#type':      return globals.featureType;\\n                                case '#group':     return globals.groupId;\\n                                case '#lod':       return globals.tileLod;\\n                                case '#tileSize':  return globals.tileSize;\\n                                case '#pixelSize': return globals.pixelSize;\\n                                case '#metric':    return globals.metricUnits;\\n                                case '#dpr':       return globals.pixelFactor;\\n                            }\\n\\n                        case '$':\\n                        case '@':\\n\\n                            switch (str.charAt(0)) {\\n                                case '$': finalValue = feature.properties[str.substr(1)]; break;\\n                                case '@': finalValue = globals.stylesheetConstants[str]; break;\\n                            }\\n\\n                            if (typeof finalValue == 'undefined') {\\n                                logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\\n                                return finalValue;\\n                            }\\n\\n                            finalValue = getLayerPropertyValueInner(layer, key, feature, lod, finalValue, 0);\\n\\n                            return getLayerExpresionValue(layer, finalValue, feature, lod, key);\\n                    }\\n\\n                    if (str.indexOf('{') != -1) {\\n\\n                        try {\\n                            str = str.replace(/'/g, '\\\"');\\n                            finalValue = JSON.parse(str);\\n                        } catch(e) {\\n                            logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\\n                            return \\\"\\\";\\n                        }\\n\\n                        if (typeof finalValue == 'undefined') {\\n                            logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\\n                            return \\\"\\\";\\n                        } else {\\n                            return getLayerPropertyValueInner(layer, key, feature, lod, finalValue, 0);\\n                        }\\n\\n                    } else {\\n                        return str;\\n                    }\\n\\n                }\\n\\n            }));\\n        }\\n\\n        break;\\n    }\\n    \\n    return value;\\n};\\n\\n\\nvar getLayerPropertyValue = function(layer, key, feature, lod) {\\n    var value = getLayerPropertyValueInner(layer, key, feature, lod);\\n    return validateLayerPropertyValue(layer['$$layer-id'], key, value);\\n};\\n\\n\\nvar getLayerPropertyValueInner = function(layer, key, feature, lod, value, depth) {\\n    var index = 0, i, li, finalValue, root, v1, v2, v3;\\n    var tmpValue;\\n\\n    \\n    if ((typeof value) === 'undefined') {\\n        /*\\n        if (layer[key]) {\\n            value = JSON.parse(JSON.stringify(layer[key])); //make copy\\n        } else {\\n            value = layer[key];\\n        }*/\\n\\n        value = layer[key];\\n\\n        root = true;\\n        depth = 0;\\n    } else {\\n        if (depth > 100) {\\n            return void(0);\\n        }\\n    }\\n\\n    switch(typeof value) {\\n    case 'string':\\n\\n        if (value.length > 0) {\\n            finalValue = value;\\n\\n            //is it feature property, variable or constant?\\n            switch(value.charAt(0)) {\\n                case '$': finalValue = feature.properties[value.substr(1)]; break;\\n                case '@': finalValue = globals.stylesheetConstants[value]; break;\\n                case '&': finalValue = globals.stylesheetVariables[value.substr(1)]; break;\\n                case '#': \\n                    //debugger;\\n                    switch(value) {\\n                        case '#id':        return feature.id;\\n                        case '#type':      return globals.featureType;\\n                        case '#group':     return globals.groupId;\\n                        case '#lod':       return globals.tileLod;\\n                        case '#tileSize':  return globals.tileSize;\\n                        case '#pixelSize': return globals.pixelSize;\\n                        case '#metric':    return globals.metricUnits;\\n                        case '#dpr':       return globals.pixelFactor;\\n                    }\\n                    break;\\n            }\\n\\n            if (typeof finalValue === 'string') {\\n                finalValue = getLayerExpresionValue(layer, value, feature, lod, key);\\n            } else {\\n                if (typeof finalValue !== 'undefined' && value.charAt(0) == '@') {\\n                    finalValue = getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth+1);\\n                }\\n            }\\n\\n            if (typeof finalValue !== 'undefined') {\\n\\n                //simpleFmtCall(finalValue, (function(svalue){ getLayerPropertyValueInner(layer, key, feature, lod, svalue, depth+1); }))\\n\\n                return finalValue;\\n            } else {\\n                logError('wrong-object', layer['$$layer-id'], key, value, null, 'feature-property');\\n                \\n                if (root) {\\n                    return getDefaultLayerPropertyValue(key);\\n                } else {\\n                    return void(0);\\n                }\\n            }\\n        }\\n\\n        return value;\\n\\n    case 'object':\\n\\n            //is it null?\\n        if (value == null) {\\n            if (root) {\\n                return getDefaultLayerPropertyValue(key);\\n            } else {\\n                return void(0);\\n            }\\n        }\\n\\n        //is it array (rgb, rgba, vec2)?\\n        if (Array.isArray(value)) {\\n\\n            if (key == 'icon-source') {\\n                //index++;\\n                if (globals.stylesheetBitmaps[value[0]] == null) {\\n                    logError('wrong-object', layer['$$layer-id'], key, value, null, 'bitmap');\\n\\n                    if (root) {\\n                        return getDefaultLayerPropertyValue(key);\\n                    } else {\\n                        return void(0);\\n                    }\\n                }\\n            }\\n\\n            if (key != 'filter') {\\n                tmpValue = new Array(value.length);\\n\\n                for (i = index, li = value.length; i < li; i++) {\\n                    tmpValue[i] = getLayerPropertyValueInner(layer, key, feature, lod, value[i], depth + 1);\\n                }\\n\\n                return tmpValue;\\n            }\\n\\n            return value;\\n        }\\n\\n        var functionName, functionValue, functionError, finalValue;\\n\\n        for (functionName in value) {\\n            break;\\n        }\\n\\n        if (!functionName) {\\n            if (root) {\\n                return getDefaultLayerPropertyValue(key);\\n            } else {\\n                return void(0);\\n            }\\n        }\\n\\n        functionValue = value[functionName];\\n\\n        switch (functionName) {\\n            case 'if':\\n\\n                if (!Array.isArray(functionValue) || functionValue.length != 3) {\\n                    functionError = true;\\n                } else {\\n                    if (getFilterResult(functionValue[0], feature, globals.featureType, globals.groupId, layer, key, lod, 0)) {\\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\\n                    } else {\\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\\n                    }\\n\\n                    if (typeof finalValue === 'undefined') {\\n                        functionError = true;\\n                    } else {\\n                        return finalValue;\\n                    }\\n                }\\n\\n                break;\\n\\n            case 'add':\\n            case 'sub':\\n            case 'mul':\\n            case 'div':\\n            case 'pow':\\n            case 'tofixed':\\n            case 'atan2':\\n\\n                if (!Array.isArray(functionValue) || functionValue.length != 2) {\\n                    functionError = true;\\n                } else {\\n\\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\\n\\n                    if (typeof v1 !== 'number' || typeof v2 !== 'number') {\\n                        functionError = true;\\n                    } else {\\n                        switch (functionName) {\\n                            case 'add':    return v1 + v2;\\n                            case 'sub':    return v1 - v2;\\n                            case 'mul':    return v1 * v2;\\n                            case 'div':    return v1 / v2;\\n                            case 'pow':    return Math.pow(v1, v2);\\n                            case 'atan2':  return Math.atan2(v1, v2);\\n                            case 'tofixed': return v1.tofixed(v2);\\n                        }\\n                    }\\n                }\\n\\n                break;\\n\\n            case 'clamp':\\n\\n                if (!Array.isArray(functionValue) || functionValue.length != 3) {\\n                    functionError = true;\\n                } else {\\n\\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\\n                    v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\\n\\n                    if (typeof v1 !== 'number' || typeof v2 !== 'number' || typeof v3 !== 'number') {\\n                        functionError = true;\\n                    } else {\\n                        return clamp(v1, v2, v3);\\n                    }\\n                }\\n\\n                break;\\n\\n            case 'sgn':\\n            case 'sin':\\n            case 'cos':\\n            case 'tan':\\n            case 'asin':\\n            case 'acos':\\n            case 'atan':\\n            case 'sqrt':\\n            case 'abs':\\n            case 'log':\\n            case 'round':\\n            case 'floor':\\n            case 'ceil':\\n            case 'deg2rad':\\n            case 'rad2deg':\\n\\n                functionValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue, depth + 1);\\n\\n                if (typeof functionValue !== 'number') {\\n                    functionError = true;\\n                } else {\\n                    switch (functionName) {\\n                        case 'sgn':  return functionValue < 0 ? -1 : 1;\\n                        case 'sin':  return Math.sin(functionValue);\\n                        case 'cos':  return Math.cos(functionValue);\\n                        case 'tan':  return Math.tan(functionValue);\\n                        case 'asin': return Math.asin(functionValue);\\n                        case 'acos': return Math.acos(functionValue);\\n                        case 'atan': return Math.atan(functionValue);\\n                        case 'sqrt': return Math.sqrt(functionValue);\\n                        case 'abs':  return Math.abs(functionValue);\\n                        case 'log':  return Math.log(functionValue);\\n                        case 'round': return Math.round(functionValue);\\n                        case 'floor': return Math.floor(functionValue);\\n                        case 'ceil':  return Math.ceil(functionValue);\\n                        case 'deg2rad':  return (functionValue / 180) * Math.PI;\\n                        case 'rad2deg':  return (functionValue / Math.PI) * 180;\\n                    }\\n                }\\n\\n                break;\\n\\n            case 'strlen':\\n            case 'str2num':\\n            case 'lowercase':\\n            case 'uppercase':\\n            case 'capitalize':\\n            case 'has-fonts':\\n            case 'has-latin':\\n            case 'is-cjk':\\n                functionValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue, depth + 1);\\n\\n                if (typeof functionValue !== 'string') {\\n                    functionError = true;\\n                } else {\\n                    switch (functionName) {\\n                        case 'strlen':     return functionValue.length;\\n                        case 'str2num':    return parseFloat(functionValue);\\n                        case 'lowercase':  return functionValue.toLowerCase();\\n                        case 'uppercase':  return functionValue.toUpperCase();\\n                        case 'capitalize': return functionValue.replace(/(?:^|\\\\s)\\\\S/g, function(a) { return a.toUpperCase(); });\\n                        case 'has-fonts':  return areTextCharactersAvailable(functionValue);\\n                        case 'has-latin':  return hasLatin(functionValue);\\n                        case 'is-cjk':     return isCJK(functionValue); \\n                    }\\n                }\\n\\n                break;\\n\\n            case 'min':\\n            case 'max':\\n\\n                if (!Array.isArray(functionValue)) {\\n                    functionError = true;\\n                } else {\\n\\n                    finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\\n\\n                    for (i = index, li = functionValue.length; i < li; i++) {\\n                        tmpValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[i], depth + 1);\\n\\n                        if (typeof tmpValue !== 'number') {\\n                            functionError = true;\\n                            break;\\n                        }\\n\\n                        if (functionName == 'max') {\\n                            finalValue = Math.max(finalValue, tmpValue);\\n                        } else {\\n                            finalValue = Math.min(finalValue, tmpValue);\\n                        }\\n                    }\\n\\n                    return finalValue;\\n                }\\n\\n                break;\\n\\n            case 'linear':\\n            case 'linear2':\\n            case 'discrete':\\n            case 'discrete2':\\n            case 'lod-scaled':\\n\\n                //LOD based functions\\n                var stops = null;\\n                var lodScaledArray = null;\\n                var functionValue = lod;\\n\\n                if (value['lod-scaled'] != null) {\\n                    var array = value['lod-scaled'];\\n\\n                    if ((typeof array[1]) == 'number') {\\n                        return array[1] * Math.pow(2*array[2], array[0] - lod);\\n                    }\\n\\n                    stops = array[1];\\n                    lodScaledArray = array;\\n\\n                } if (value['discrete2'] != null || value['linear2'] != null) {\\n                    var array = value['discrete2'] || value['linear2'];\\n                    stops = array[1];\\n                    functionValue = getLayerPropertyValueInner(layer, key, feature, lod, array[0], depth + 1);\\n                } else {\\n                    stops = value['discrete'] || value['linear'];\\n                }\\n\\n                var lastLod = stops[0][0];\\n                var lastValue = stops[0][1];\\n                var valueType = (typeof lastValue);\\n                var newValue = lastValue;\\n\\n                var currentLod, currentValue;\\n\\n                for (var i = 0, li = stops.length; i <= li; i++) {\\n\\n                    if (i == li) {\\n                        newValue = lastValue;\\n                        break;\\n                    }\\n\\n                    if (stops[i][0] > functionValue) {\\n\\n                        if (value['discrete'] != null || value['discrete2'] != null || lodScaledArray != null) { //no interpolation\\n                            newValue = lastValue;\\n                            break;\\n                        } else { //interpolate\\n\\n                            currentLod = stops[i][0];\\n                            currentValue = stops[i][1];\\n\\n                            if (currentLod == lastLod) { //end of array no interpolation needed\\n                                break;\\n                            }\\n\\n                            switch(valueType) {\\n\\n                            case 'boolean':\\n                                lastValue = lastValue ? 1 : 0;\\n                                currentValue = lastValue ? 1 : 0;\\n                                newValue = lastValue + (currentValue - lastValue) * ((functionValue - lastLod) / (currentLod - lastLod));\\n\\n                                newValue = newValue > 0.5 ? true : false;\\n                                break;\\n\\n                            case 'number':\\n                                newValue = lastValue + (currentValue - lastValue) * ((functionValue - lastLod) / (currentLod - lastLod));\\n                                break;\\n\\n                            case 'object':\\n                                newValue = [];\\n\\n                                for (var j = 0, lj= lastValue.length; j < lj; j++) {\\n                                    newValue[j] = lastValue[j] + (currentValue[j] - lastValue[j]) * ((functionValue - lastLod) / (currentLod - lastLod));\\n                                }\\n\\n                                break;\\n                            }\\n\\n                            break;\\n                        }\\n                    }\\n\\n                    lastLod = stops[i][0];\\n                    lastValue = stops[i][1];\\n                }\\n\\n                if (lodScaledArray != null) {\\n                    newValue *= Math.pow(2*lodScaledArray[2], lodScaledArray[0] - functionValue);\\n                }\\n\\n                return newValue;\\n\\n            default: \\n                functionError = true;\\n                break;\\n        }\\n\\n        if (functionError) {\\n            if (root) {\\n                return getDefaultLayerPropertyValue(key);\\n            } else {\\n                return void(0);\\n            }\\n        }\\n\\n\\n    case 'number':\\n    case 'boolean':\\n        return value;\\n    }\\n\\n    if (root) {\\n        return getDefaultLayerPropertyValue(key);\\n    } else {\\n        return void(0);\\n    }\\n};\\n\\n\\nvar inheritLayer = function(layerId, layer, layerData, stylesheetLayersData, depth) {\\n    if (depth > 100) {\\n        logError('custom', 'infinite inherit loop in Layer: ' + layerId);\\n        return;\\n    }\\n\\n    //do we need inherite Layer?\\n    if (layerData['inherit'] != null) {\\n        //get inherited Layer\\n        var LayerToInherit = stylesheetLayersData['layers'][layerData['inherit']];\\n\\n        if (LayerToInherit != null) {\\n\\n            if (LayerToInherit['inherit'] != null) {\\n                inheritLayer(layerData['inherit'], layer, LayerToInherit, stylesheetLayersData, depth++);\\n            }\\n\\n            //copy inherited Layer properties\\n            for (var key in LayerToInherit) {\\n                layer[key] = LayerToInherit[key];\\n            }\\n        } else {\\n            logError('wrong-object', layerId, 'inherit', LayerToInherit, 'Layer');\\n            return getDefaultLayerPropertyValue(key);\\n        }\\n    }\\n};\\n\\n\\nvar copyLayer = function(layerId, layer, layerData, stylesheetLayersData) {\\n    //do we need inherite Layer?\\n    if (layerData['inherit'] != null) {\\n        inheritLayer(layerId, layer, layerData, stylesheetLayersData, 0);\\n    }\\n\\n    //copy Layer properties\\n    //if inherited properties are present then they will be overwriten\\n    for (var key in layerData) {\\n        layer[key] = layerData[key];\\n    }\\n\\n    //store layer id\\n    layer['$$layer-id'] = layerId;\\n};\\n\\n\\nvar logError = function(errorType, layerId, key, value, index, subkey) {\\n    if (globals.disableLog) {\\n        return;\\n    }\\n\\n    if ((typeof value) == 'object') {\\n        value = JSON.stringify(value);\\n    }\\n    \\n    var str = null;\\n\\n    switch(errorType) {\\n    case 'wrong-property-value':\\n        str = 'Error: wrong layer property ' + (subkey ? ('\\\\'' + subkey + '\\\\'') : '') + ': ' + layerId + '.' + key + ' = ' + value;\\n        break;\\n\\n    case 'wrong-property-value[]':\\n        str = 'Error: wrong layer property ' + (subkey ? ('\\\\'' + subkey + '\\\\'') : '') + '['+index+']: ' + layerId + '.' + key + ' = ' + value;\\n        break;\\n\\n    case 'wrong-object':\\n        str = 'Error: reffered '+ subkey + ' does not exist: ' + layerId + '.' + key + ' = ' + value;\\n        break;\\n\\n    case 'wrong-object[]':\\n        str = 'Error: reffered '+ subkey + ' does not exist: ' + layerId + '.' + key + '['+index+'] = ' + value;\\n        break;\\n\\n    case 'wrong-Layer':\\n        str = 'Error: reffered '+ subkey + ' Layer does not exist: ' + subkey + '['+index+'].Layer = ' + layerId;\\n        break;\\n\\n    case 'wrong-bitmap':\\n        str = 'Error: wrong definition of bitmap: ' + layerId;\\n        break;\\n\\n    case 'custom':\\n        str = 'Error: ' + layerId;\\n        break;\\n    }\\n    \\n    if (str && globals.log) {\\n         // eslint-disable-next-line \\n        console.log(str);\\n        //throw str;\\n    }\\n};\\n\\n\\nvar validateValue = function(layerId, key, value, type, arrayLength, min, max) {\\n    var i, li;\\n\\n    //check for object\\n    if (value != null && (typeof value) == 'object' && !Array.isArray(value)) {\\n        logError('wrong-property-value', layerId, key, value);\\n        return getDefaultLayerPropertyValue(key);\\n    }\\n\\n    //check value type\\n    if ((typeof value) != type) {\\n        //check for exceptions\\n        if (!(value === null && (key == 'icon-source' || key == 'visibility' || key == 'label-no-overlap-factor'))) {\\n            logError('wrong-property-value', layerId, key, value);\\n            return getDefaultLayerPropertyValue(key);\\n        }\\n    }\\n\\n    //check value\\n    switch(typeof value) {\\n\\n    case 'object':\\n\\n        //accepted cases for null value\\n        if (value === null && (key == 'line-style-texture' || key == 'icon-source' || 'dynamic-reduce' || 'reduce' ||\\n            key == 'hysteresis' || key == 'visibility' || key == 'visibility-abs' || key == 'visibility-rel' || key == 'next-pass')) {\\n            return value;\\n        }\\n\\n        //check reduce\\n        if (key == 'reduce' || key == 'dynamic-reduce' || key == 'label-no-overlap-factor') {\\n            if (Array.isArray(value) && value.length > 0 && (typeof value[0] === 'string')) {\\n\\n                if (key == 'dynamic-reduce') {\\n                    if (value[0] == 'by-extenal-param') {\\n                        value[0] = globals.reduceMode;\\n                    }\\n\\n                    if (!((value[0] == 'tilt' || value[0] == 'tilt-cos' || value[0] == 'tilt-cos2' || value[0] == 'scr-count' || value[0] == 'scr-count2' ||\\n                           value[0] == 'scr-count3' || value[0] == 'scr-count4' || value[0] == 'scr-count5' || value[0] == 'scr-count6') &&\\n                        (typeof value[1] === 'number') && ((typeof value[2] === 'number') || value[0] == 'scr-count4' || value[0] == 'scr-count5' || value[0] == 'scr-count6'))) {\\n                        logError('wrong-property-value', layerId, key, value);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n                } else if (key == 'reduce') {\\n                    if (value[0] != 'odd' && value != 'even') {\\n                        if ((typeof value[1] !== 'number') || ((value[0] != 'top' || value != 'bottom') && (typeof value[2] !== 'string'))) {\\n                            logError('wrong-property-value', layerId, key, value);\\n                            return getDefaultLayerPropertyValue(key);\\n                        }\\n                    }\\n                } else if (key == 'label-no-overlap-factor') {\\n                    if (!(value[0] == 'direct' || value[0] == 'div-by-dist')) {\\n                        logError('wrong-property-value', layerId, key, value);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n                }\\n\\n            } else {\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        //check multipasss\\n        if (key == 'next-pass' || key == 'visibility-switch') {\\n            var vswitch = (key == 'visibility-switch');\\n            if (Array.isArray(value) && value.length > 0) {\\n\\n                for (i = 0; i < li; i++) {\\n                    var valueItem = value[i];\\n\\n                    if (!(typeof valueItem == 'object' &&\\n                            Array.isArray(valueItem) &&\\n                            valueItem.length == 2 &&\\n                            typeof valueItem[0] == 'number' &&\\n                            (typeof valueItem[1] == 'string' || (vswitch && valueItem[1] === null)))) {\\n\\n                        logError('wrong-property-value[]', layerId, key, value, i);\\n                        return getDefaultLayerPropertyValue(key);\\n                    } else {\\n                        //fast constant \\n                        if (typeof valueItem[1] == 'string' && valueItem[1].charAt(0) == '@') {\\n                            if (typeof globals.stylesheetConstants[valueItem[1]] == 'undefined') {\\n                                logError('wrong-property-value[]', layerId, key, value, i);\\n                                return getDefaultLayerPropertyValue(key);\\n                            } else {\\n                                valueItem[1] = globals.stylesheetConstants[valueItem[1]];\\n                            }\\n                        }\\n                    }\\n                }\\n\\n            } else {\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        if (key == 'label-font' || key == 'line-label-font') {\\n\\n            if (!Array.isArray(value) || value.length < 1) {\\n                logError('wrong-property-value[]', layerId, key, value, 0);\\n                return getDefaultLayerPropertyValue(key);\\n            } else {\\n                for (i = 0, li = value.length; i < li; i++) {\\n                    if (typeof value[i] != 'string' || !globals.fonts[value[i]]) {\\n                        logError('wrong-property-value[]', layerId, key, value, 0);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n                }\\n            }\\n\\n            return value;\\n        }\\n\\n        //check array\\n        if (arrayLength != null) {\\n            if (Array.isArray(value) && (value.length == arrayLength || ((key == 'icon-stick' || 'label-stick') && value.length >= 7) )) {\\n\\n                //validate array values\\n                i = 0;\\n\\n                if (key == 'icon-source' || key == 'line-style-texture') {\\n                    if (typeof value[0] != 'string') {\\n                        logError('wrong-property-value[]', layerId, key, value, 0);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n\\n                    if (globals.stylesheetBitmaps[value[0]] == null) {\\n                        logError('wrong-object', layerId, key, value, null, 'bitmap');\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n\\n                    i = 1;\\n                }\\n\\n                for (li = value.length; i < li; i++) {\\n                    if (typeof value[i] != 'number') {\\n                        logError('wrong-property-value[]', layerId, key, value, i);\\n                        return getDefaultLayerPropertyValue(key);\\n                    }\\n                }\\n\\n                if ((key == 'icon-stick' || 'label-stick') && value.length == 7) {\\n                    value[7] = 0;\\n                }\\n\\n                return value;\\n            } else {\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        return value;\\n\\n    case 'string':\\n\\n        //validate line Layer enum\\n        if (key == 'line-style') {\\n            switch(value) {\\n            case 'solid':\\n            case 'texture': return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        if (key == 'label-size-units') {\\n            switch(value) {\\n            case 'pixels':\\n            case 'points': return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        if (key == 'line-width-units') {\\n            switch(value) {\\n            case 'pixels':\\n            case 'points':\\n            case 'meters':\\n            case 'ratio': return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        //validate origin enum\\n        if (key == 'label-origin' || key == 'icon-origin') {\\n            switch(value) {\\n            case 'top-left':\\n            case 'top-right':\\n            case 'top-center':\\n            case 'center-left':\\n            case 'center-right':\\n            case 'center-center':\\n            case 'bottom-left':\\n            case 'bottom-right':\\n            case 'bottom-center':   return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        //validate align enum\\n        if (key == 'label-align') {\\n            switch(value) {\\n            case 'left':\\n            case 'right':\\n            case 'center':  return value;\\n            default:\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n        return value;\\n\\n    case 'number':\\n\\n        if (value > max || value < min) {\\n            logError('wrong-property-value', layerId, key, value);\\n            return getDefaultLayerPropertyValue(key);\\n        }\\n\\n        return value;\\n\\n    case 'boolean':\\n        return value;\\n    }\\n};\\n\\n\\nvar validateLayerPropertyValue = function(layerId, key, value) {\\n\\n    switch(key) {\\n\\n    case 'inherit' :        return validateValue(layerId, key, value, 'string');\\n    case 'reduce':          return validateValue(layerId, key, value, 'object');\\n    case 'dynamic-reduce':  return validateValue(layerId, key, value, 'object');\\n\\n    case 'line':              return validateValue(layerId, key, value, 'boolean');\\n    case 'line-flat':         return validateValue(layerId, key, value, 'boolean');\\n    case 'line-width':        return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'line-width-units':  return validateValue(layerId, key, value, 'string');\\n    case 'line-color':        return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'line-style':        return validateValue(layerId, key, value, 'string');\\n    case 'line-style-texture':    return validateValue(layerId, key, value, 'object', 3, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'line-style-background': return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n\\n    case 'line-label':         return validateValue(layerId, key, value, 'boolean');\\n    case 'line-label-source':  return validateValue(layerId, key, value, 'string');\\n    case 'line-label-color':   return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'line-label-color2':  return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'line-label-size':    return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'line-label-offset':  return validateValue(layerId, key, value, 'number', null, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'line-label-spacing': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'line-label-line-height': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n\\n    case 'point':        return validateValue(layerId, key, value, 'boolean');\\n    case 'point-flat':   return validateValue(layerId, key, value, 'boolean');\\n    case 'point-radius': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'point-Layer':  return validateValue(layerId, key, value, 'string');\\n\\n    case 'point-color':  return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n\\n    case 'icon':             return validateValue(layerId, key, value, 'boolean');\\n    case 'icon-source':      return validateValue(layerId, key, value, 'object', 5, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'icon-scale':       return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'icon-offset':      return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'icon-origin':      return validateValue(layerId, key, value, 'string');\\n    case 'icon-stick':       return validateValue(layerId, key, value, 'object', 8, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'icon-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'icon-no-overlap':  return validateValue(layerId, key, value, 'boolean');\\n    case 'icon-no-overlap-factor': return validateValue(layerId, key, value, 'object');\\n    case 'icon-no-overlap-margin': return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\\n\\n    case 'label':             return validateValue(layerId, key, value, 'boolean');\\n    case 'label-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'label-color2':      return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n    case 'label-source':      return validateValue(layerId, key, value, 'string');\\n    case 'label-size':        return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'label-size-units':  return validateValue(layerId, key, value, 'string');\\n    case 'label-spacing':     return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'label-line-height': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'label-offset':      return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'label-origin':      return validateValue(layerId, key, value, 'string');\\n    case 'label-align':       return validateValue(layerId, key, value, 'string');\\n    case 'label-stick':       return validateValue(layerId, key, value, 'object', 8, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'label-width':       return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\\n    case 'label-no-overlap':  return validateValue(layerId, key, value, 'boolean');\\n    case 'label-no-overlap-factor': return validateValue(layerId, key, value, 'object');\\n    case 'label-no-overlap-margin': return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\\n\\n    case 'polygon':         return validateValue(layerId, key, value, 'boolean');\\n    case 'polygon-color':   return validateValue(layerId, key, value, 'object', 4, 0, 255);\\n\\n    case 'z-index':        return validateValue(layerId, key, value, 'number', null, -Number.MAX_VALUE, Number.MAX_VALUE);\\n    case 'zbuffer-offset': return validateValue(layerId, key, value, 'object', 3, 0, Number.MAX_VALUE);\\n\\n    case 'selected-hover-layer':  return validateValue(layerId, key, value, 'string');\\n    case 'selected-layer':  return validateValue(layerId, key, value, 'string');\\n    case 'hover-event':     return validateValue(layerId, key, value, 'boolean');\\n    case 'hover-layer':     return validateValue(layerId, key, value, 'string');\\n    case 'enter-event':     return validateValue(layerId, key, value, 'boolean');\\n    case 'leave-event':     return validateValue(layerId, key, value, 'boolean');\\n    case 'click-event':     return validateValue(layerId, key, value, 'boolean');\\n    case 'draw-event':      return validateValue(layerId, key, value, 'boolean');\\n    case 'advanced-hit':    return validateValue(layerId, key, value, 'boolean');\\n    case 'export-geometry': return validateValue(layerId, key, value, 'boolean');\\n    case 'pack':            return validateValue(layerId, key, value, 'boolean');\\n\\n    case 'visible':           return validateValue(layerId, key, value, 'boolean');\\n    case 'visibility':        return validateValue(layerId, key, value, 'number', null, 0.00001, Number.MAX_VALUE);\\n    case 'visibility-abs':    return validateValue(layerId, key, value, 'object', 2, 0.00001, Number.MAX_VALUE);\\n    case 'visibility-rel':    return validateValue(layerId, key, value, 'object', 4, 0.00001, Number.MAX_VALUE);\\n    case 'visibility-switch': return validateValue(layerId, key, value, 'object');\\n\\n    case 'hysteresis':  return validateValue(layerId, key, value, 'object');\\n    case 'culling':     return validateValue(layerId, key, value, 'number', 180, 0.0001, 180);\\n    case 'next-pass':   return validateValue(layerId, key, value, 'object');\\n\\n    case 'importance-source':  return validateValue(layerId, key, value, 'string');\\n\\n    }\\n\\n    return value; //custom property\\n};\\n\\n\\nvar getDefaultLayerPropertyValue = function(key) {\\n    switch(key) {\\n    case 'inherit':          return '';\\n    case 'filter':           return null;\\n    case 'reduce':           return null;\\n    case 'dynamic-reduce':   return null;\\n\\n    case 'line':             return false;\\n    case 'line-flat':        return false;\\n    case 'line-width':       return 1;\\n    case 'line-width-units': return 'meters';\\n    case 'line-color':       return [255,255,255,255];\\n    case 'line-style':       return 'solid';\\n    case 'line-style-texture':    return null;\\n    case 'line-style-background': return [0,0,0,0];\\n\\n    case 'line-label':         return false;\\n    case 'line-label-font':    return ['#default'];\\n    case 'line-label-color':   return [255,255,255,255];\\n    case 'line-label-color2':  return [0,0,0,255];\\n    case 'line-label-outline': return [0.27,0.75,2.2,2.2];\\n    case 'line-label-source':  return '$name';\\n    case 'line-label-size':    return 1;\\n    case 'line-label-offset':  return 0;\\n    case 'line-label-spacing': return 1;\\n    case 'line-label-line-height': return 1;\\n\\n    case 'point':        return false;\\n    case 'point-flat':   return false;\\n    case 'point-radius': return 1;\\n    case 'point-Layer':  return 'solid';\\n    case 'point-color':  return [255,255,255,255];\\n\\n    case 'icon':         return false;\\n    case 'icon-source':  return null;\\n    case 'icon-scale':   return 1;\\n    case 'icon-offset':  return [0,0];\\n    case 'icon-origin':  return 'bottom-center';\\n    case 'icon-stick':   return [0,0,0,255,255,255,255,0];\\n    case 'icon-color':   return [255,255,255,255];\\n    case 'icon-no-overlap':  return false;\\n    case 'icon-no-overlap-factor': return null;\\n    case 'icon-no-overlap-margin': return [5,5];\\n\\n    case 'label':             return false;\\n    case 'label-font':        return ['#default'];\\n    case 'label-color':       return [255,255,255,255];\\n    case 'label-color2':      return [0,0,0,255];\\n    case 'label-outline':     return [0.27,0.75,2.2,2.2];\\n    case 'label-source':      return '$name';\\n    case 'label-size':        return 10;\\n    case 'label-size-units':  return 'pixels';\\n    case 'label-spacing':     return 1;\\n    case 'label-line-height': return 1;\\n    case 'label-offset':      return [0,0];\\n    case 'label-origin':      return 'bottom-center';\\n    case 'label-align':       return 'center';\\n    case 'label-stick':       return [0,0,0,255,255,255,255,0];\\n    case 'label-width':       return 200;\\n    case 'label-no-overlap':  return true;\\n    case 'label-no-overlap-factor': return null;\\n    case 'label-no-overlap-margin': return [5,5];\\n       \\n    case 'polygon':        return false;\\n    case 'polygon-color':  return [255,255,255,255];\\n\\n    case 'z-index':        return 0;\\n    case 'zbuffer-offset': return [0,0,0];\\n\\n    case 'selected-hover-layer':  return '';\\n    case 'selected-layer':  return '';\\n    case 'hover-event':     return false;\\n    case 'hover-layer':     return '';\\n    case 'enter-event':     return false;\\n    case 'leave-event':     return false;\\n    case 'click-event':     return false;\\n    case 'draw-event':      return false;\\n    case 'advanced-hit':    return false;\\n    case 'export-geometry': return false;\\n    case 'pack':            return false;\\n\\n    case 'visible':           return true;\\n    case 'visibility':        return null;\\n    case 'visibility-abs':    return null;\\n    case 'visibility-rel':    return null;\\n    case 'visibility-switch': return null;\\n\\n    case 'hysteresis':      return null;\\n    case 'culling':         return 180;\\n    case 'next-pass':       return null;\\n\\n    case 'importance-source':  '';\\n    }\\n};\\n\\n\\nfunction getFilterResult(filter, feature, featureType, group, layer, key, lod, depth, fast) {\\n    var result, i, li;\\n\\n    if (!filter || !Array.isArray(filter)) {\\n        return false;\\n    }\\n\\n    if (depth > 100) {\\n        return false;\\n    }\\n\\n    switch(filter[0]) {\\n    case 'all': \\n        for (i = 1, li = filter.length; i < li; i++) {\\n            result = getFilterResult(filter[i], feature, featureType, group, layer, key, lod, depth + 1, fast);\\n\\n            if (!result) {\\n                return false;\\n            }\\n        }\\n           \\n        return true;                         \\n\\n    case 'any':\\n        for (i = 1, li = filter.length; i < li; i++) {\\n            result = getFilterResult(filter[i], feature, featureType, group, key, lod, depth + 1, fast);\\n\\n            if (result) {\\n                return true;\\n            }\\n        }\\n           \\n        return false;                         \\n\\n    case 'none':\\n        for (i = 1, li = filter.length; i < li; i++) {\\n            result = getFilterResult(filter[i], feature, featureType, group, key, lod, depth + 1, fast);\\n\\n            if (result) {\\n                return false;\\n            }\\n        }\\n           \\n        return true;\\n                              \\n    case 'skip': return false; \\n    }\\n\\n    var value, value2;\\n\\n    if (fast && filter[2]) {\\n        value = filter[1];\\n    } else {\\n        globals.disableLog = (filter[0] == 'has' || filter[0] == '!has');\\n        value = getLayerPropertyValueInner(layer, key, feature, lod, filter[1], 0);\\n        globals.disableLog = false;\\n    }\\n\\n    switch(filter[0]) {\\n    case '==':\\n    case '!=':\\n    case '>=':\\n    case '<=':\\n    case '>':\\n    case '<':\\n        value2 = filter[fast ? 3 : 2];\\n\\n        if (typeof value2 == 'undefined') {\\n            return false;\\n        }\\n\\n        if (!(fast && filter[4])) {\\n            value2 = getLayerPropertyValueInner(layer, key, feature, lod, value2, 0);\\n        }\\n\\n        break;\\n    }\\n\\n    switch(filter[0]) {\\n    case '==': return (value == value2);\\n    case '!=': return (value != value2);\\n    case '>=': return (value >= value2);\\n    case '<=': return (value <= value2);\\n    case '>': return (value > value2);\\n    case '<': return (value < value2);\\n        \\n    case 'has': return (typeof value != 'undefined');\\n    case '!has': return (typeof value == 'undefined');\\n        \\n    case 'in':\\n        for (i = fast ? 3 : 2, li = filter.length; i < li; i++) {\\n            if (filter[i] == value) {\\n                return true;\\n            }\\n        } \\n        return false;\\n        \\n    case '!in':\\n        for (i = fast ? 3 : 2, li = filter.length; i < li; i++) {\\n            if (filter[i] == value) {\\n                return false;\\n            }\\n        } \\n        return true;\\n    }            \\n\\n    return false;    \\n}\\n\\n\\nfunction isSimpleValue(value) {\\n    switch(typeof value) {\\n        case 'number':  return true;\\n        case 'string': \\n            \\n            if (value.length > 0) {\\n                switch(value.charAt(0)) {\\n                    case '#': \\n                    case '$':\\n                    case '@':\\n                    case '&':\\n                        break;\\n                    \\n                    default: \\n\\n                        if (value.indexOf('{') == -1) {\\n                            return true;\\n                        }\\n\\n                        break;\\n                }\\n            } else {\\n                return true;\\n            }\\n\\n            break;\\n    }\\n\\n    return false;\\n}\\n\\n\\nfunction makeFasterFilter(filter) {\\n    if (!filter || !Array.isArray(filter)) {\\n        return filter;\\n    }\\n\\n    var i, li, value, simple, result = [filter[0]];\\n\\n    switch(filter[0]) {\\n    case 'all': \\n    case 'any':\\n    case 'none':\\n    case 'skip':\\n        for (i = 1, li = filter.length; i < li; i++) {\\n            result[i] = makeFasterFilter(filter[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    result[1] = filter[1];\\n    result[2] = isSimpleValue(filter[1]);\\n\\n    switch(filter[0]) {\\n    case '==':\\n    case '!=':\\n    case '>=':\\n    case '<=':\\n    case '>':\\n    case '<':\\n        result[3] = filter[2];\\n        result[4] = isSimpleValue(filter[2]);\\n        break;\\n\\n    case 'in':\\n    case '!in':\\n\\n        for (i = 2, li = filter.length; i < li; i++) {\\n            result[i+1] = filter[i];\\n        } \\n\\n    }\\n\\n    return result;\\n}\\n\\nvar processLayer = function(layerId, layerData, stylesheetLayersData) {\\n    var layer = {}, key, value;\\n\\n    //copy Layer and inherit Layer if needed\\n    copyLayer(layerId, layer, layerData, stylesheetLayersData);\\n\\n    //replace constants and validate properties\\n    for (key in layer) {\\n\\n        value = layer[key];\\n\\n        //replace constant with value\\n        if ((typeof value) == 'string') {\\n            if (value.length > 0) {\\n                //is it constant?\\n                switch(value.charAt(0)) {\\n                    case '@':\\n                        if (globals.stylesheetConstants[value] != null) {\\n                            //replace constant with value\\n                            layer[key] = globals.stylesheetConstants[value];\\n                        } else {\\n                            logError('wrong-object', layerId, key, value, null, 'constant');\\n\\n                            //replace constant with deafault value\\n                            layer[key] = getDefaultLayerPropertyValue(key);\\n                        }\\n                        break;\\n\\n                    case '&':\\n\\n                        if (globals.stylesheetVariables[value] != null) {\\n                            if (!layer['$$layer-variables']) {\\n                                layer['$$layer-variables'] = {};\\n                            }\\n\\n                            layer['$$layer-variables'][key] = value;\\n\\n                            //replace variable with value\\n                            layer[key] = globals.stylesheetVariables[value];\\n\\n                        } else {\\n                            logError('wrong-object', layerId, key, value, null, 'variable');\\n\\n                            //replace constant with deafault value\\n                            layer[key] = getDefaultLayerPropertyValue(key);\\n                        }\\n                        break;\\n                }\\n            }\\n        }\\n\\n        //copy constats to vswitch\\n        if (key == 'visibility-switch') {\\n            if (Array.isArray(value) && value.length > 0) {\\n                for (var i = 0, li = value.length; i < li; i++) {\\n                    var valueItem = value[i];\\n                    var wrong = false;\\n\\n                    if (!(typeof valueItem == 'object' && Array.isArray(valueItem) && valueItem.length == 2)) {\\n                        wrong = true;\\n                    } else {\\n                        if (typeof valueItem[0] == 'string' && valueItem[0].charAt(0) == '@') {\\n                            if (typeof globals.stylesheetConstants[valueItem[0]] == 'undefined') {\\n                                wrong = true;\\n                            } else {\\n                                valueItem[0] = globals.stylesheetConstants[valueItem[0]];\\n                            }\\n                        }\\n\\n                        if (!(typeof valueItem[0] == 'number' && (typeof valueItem[1] == 'string' || valueItem[1] === null))) {\\n                            wrong = true;\\n                        }\\n                    }\\n\\n                    if (wrong) {\\n                        logError('wrong-property-value[]', layerId, key, value, i);\\n                    }\\n                }\\n\\n            } else {\\n                logError('wrong-property-value', layerId, key, value);\\n                return getDefaultLayerPropertyValue(key);\\n            }\\n        }\\n\\n    }\\n\\n    return layer;\\n};\\n\\n\\nvar processStylesheet = function(stylesheetLayersData) {\\n    var key;\\n    globals.stylesheetBitmaps = {};\\n    globals.stylesheetFonts = {};\\n    globals.stylesheetConstants = stylesheetLayersData['constants'] || {};\\n    globals.stylesheetVariables = stylesheetLayersData['variables'] || {};\\n\\n    //get bitmaps\\n    var bitmaps = stylesheetLayersData['bitmaps'] || {};\\n\\n    //build map\\n    for (key in bitmaps) {\\n        var bitmap = bitmaps[key];\\n        //var skip = false;\\n\\n        if ((typeof bitmap) == 'string') {\\n            bitmap = {'url':bitmap, 'hash': getHash(bitmap) };\\n        } else if((typeof bitmap) == 'object'){\\n            if (bitmap['url'] == null) {\\n                bitmap['hash'] = 'null';\\n                logError('wrong-bitmap', key);\\n            } else {\\n                bitmap['hash'] = getHash(bitmap['url']);\\n            }\\n        } else {\\n            logError('wrong-bitmap', key);\\n        }\\n\\n        globals.stylesheetBitmaps[key] = bitmap;\\n    }\\n\\n    //load bitmaps\\n    postMessage({'command':'loadBitmaps', 'bitmaps': globals.stylesheetBitmaps});\\n\\n    //remove urls\\n    bitmaps = globals.stylesheetBitmaps;\\n\\n    for (key in bitmaps) {\\n        bitmap = bitmaps[key];\\n        bitmap['url'] = null;\\n    }\\n\\n    //get fonts\\n    var fonts = stylesheetLayersData['fonts'] || {};\\n\\n    //build map\\n    for (key in fonts) {\\n        var font = fonts[key];\\n\\n        if ((typeof font) == 'string') {\\n            font = {'url':font};\\n        } else if((typeof font) == 'object'){\\n            if (font['url'] == null) {\\n                logError('wrong-font', key);\\n            }\\n        } else {\\n            logError('wrong-font', key);\\n        }\\n\\n        globals.stylesheetFonts[key] = font;\\n    }\\n\\n    //load fonts\\n    postMessage({'command':'loadFonts', 'fonts': globals.stylesheetFonts});\\n\\n\\n    //get layers\\n    globals.stylesheetData = {\\n        layers : {}\\n    };\\n\\n    var layers = stylesheetLayersData['layers'] || {};\\n\\n    globals.stylesheetLayers = globals.stylesheetData.layers;\\n\\n    //process layers\\n    for (key in layers) {\\n        globals.stylesheetData.layers[key] = processLayer(key, layers[key], stylesheetLayersData);\\n    }\\n};\\n\\n\\n\\n\\n\\n/***/ }),\\n/* 3 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_font_js__ = __webpack_require__(8);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"n\\\", function() { return addStreetTextOnPath; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"i\\\", function() { return getTextLength; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"m\\\", function() { return getLineHeight; });\\n/* unused harmony export getFontFactor */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"g\\\", function() { return getSplitIndex; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"e\\\", function() { return areTextCharactersAvailable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"f\\\", function() { return addText; });\\n/* unused harmony export addTextOnPath */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return setFont; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return setFontMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"l\\\", function() { return getCharVerticesCount; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"j\\\", function() { return getFonts; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"k\\\", function() { return getFontsStorage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return hasLatin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"d\\\", function() { return isCJK; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"h\\\", function() { return getTextGlyphs; });\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"a\\\" /* globals */],\\n    vec3Normalize = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"e\\\" /* vec3Normalize */], vec3Length = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"f\\\" /* vec3Length */],\\n    vec3Cross = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"g\\\" /* vec3Cross */],\\n    Typr = __WEBPACK_IMPORTED_MODULE_1__worker_font_js__[\\\"a\\\" /* Typr */];\\n\\n\\nvar setFont = function(fontData) {\\n    //console.log('setFont ' + fontData['url']);\\n    //debugger;\\n\\n    var font = Typr.parse(fontData['data']);\\n\\n    globals.fontsStorage[fontData['url']] = font;\\n};\\n\\n\\nvar setFontMap = function(fontMap) {\\n    var fonts = fontMap['map'];\\n    for (var key in fonts) {\\n        globals.fonts[key] = globals.fontsStorage[fonts[key]];\\n    }\\n\\n    globals.fontsMap = fonts;\\n};\\n\\n\\nvar addChar = function(pos, dir, verticalShift, char, factor, spacing, index, index2, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, fontIndex, singleBuffer) {\\n    var n, font = fonts[fontIndex];\\n\\n    if (globals.geocent && !flat) {\\n        n = [0,0,0];\\n        var nn = [0,0,0];\\n        \\n        vec3Normalize(globals.bboxMin, nn);\\n        vec3Cross(nn, dir, n);\\n    } else {\\n        n = [-dir[1],dir[0],0];\\n    }\\n\\n    var p1 = [pos[0], pos[1], pos[2]];\\n    var p2 = [p1[0], p1[1], p1[2]];\\n\\n    //var chars = font.chars;\\n    \\n    var fc = font.glyphs[char];\\n    char = 0; // hack\\n\\n    if (!fc) {\\n        return [pos, index, index2, 0];\\n    }\\n\\n    var l = 0;\\n    var nx = textVector[0];\\n    var ny = textVector[1];\\n    var nz = textVector[2];\\n\\n    if (char == 9 || char == 32) {  //tab or space\\n        fc = chars[32]; //space\\n\\n        if (fc) {\\n            pos[0] += dir[0] * (fc.step) * factor * spacing;\\n            pos[1] += dir[1] * (fc.step) * factor * spacing;\\n            l = fc.lx * factor;\\n        }\\n    } else {\\n        if (fc.lx == 0) {\\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\\n            l = fc.lx * factor;\\n        } else {\\n            var planeShift = fontIndex * 4000;\\n            var plane = fc.plane + planeShift;\\n\\n            if (planes) {\\n                if (!planes[fontIndex]) {\\n                    planes[fontIndex] = {};\\n                }\\n                \\n                planes[fontIndex][plane] = true;\\n            }\\n\\n            var factorX = fc.lx * factor;\\n            var factorY = fc.ly * factor;\\n\\n            if (singleBuffer) {\\n\\n                singleBuffer[index] = p1[0] + fc.sx * factor;;\\n                singleBuffer[index+1] = p1[1] + (fc.sy - font.size) * factor;\\n                singleBuffer[index+2] = singleBuffer[index] + factorX;\\n                singleBuffer[index+3] = singleBuffer[index+1] - factorY;\\n                singleBuffer[index+4] = fc.u1;\\n                singleBuffer[index+5] = fc.v1 + planeShift;\\n                singleBuffer[index+6] = fc.u2;\\n                singleBuffer[index+7] = fc.v2 + planeShift;\\n\\n                index += 8;\\n \\n            } else {\\n\\n                var n2 = [n[0] * verticalShift, n[1] * verticalShift, n[2] * verticalShift];\\n                var n3 = [n2[0] + n[0] * factorY, n2[1] + n[1] * factorY, n2[2] + n[2] * factorY];\\n                \\n                p1[0] = p1[0] + dir[0] * fc.sx * factor;\\n                p1[1] = p1[1] + dir[1] * fc.sx * factor;\\n                p1[2] = p1[2] + dir[2] * fc.sx * factor;\\n                p1[0] = p1[0] + n[0] * (fc.sy - font.size) * factor;\\n                p1[1] = p1[1] + n[1] * (fc.sy - font.size) * factor;\\n                p1[2] = p1[2] + n[2] * (fc.sy - font.size) * factor;\\n\\n                p2[0] = p1[0] + dir[0] * factorX;\\n                p2[1] = p1[1] + dir[1] * factorX;\\n                p2[2] = p1[2] + dir[2] * factorX;\\n\\n                //first polygon\\n                vertexBuffer[index] = p1[0] - n2[0];\\n                vertexBuffer[index+1] = p1[1] - n2[1];\\n                vertexBuffer[index+2] = p1[2] - n2[2];\\n                vertexBuffer[index+3] = nz;\\n\\n                texcoordsBuffer[index2] = fc.u1;\\n                texcoordsBuffer[index2+1] = fc.v1 +  planeShift;\\n                texcoordsBuffer[index2+2] = nx;\\n                texcoordsBuffer[index2+3] = ny;\\n\\n                vertexBuffer[index+4] = p1[0] - n3[0];\\n                vertexBuffer[index+5] = p1[1] - n3[1];\\n                vertexBuffer[index+6] = p1[2] - n3[2];\\n                vertexBuffer[index+7] = nz;\\n\\n                texcoordsBuffer[index2+4] = fc.u1;\\n                texcoordsBuffer[index2+5] = fc.v2 +  planeShift;\\n                texcoordsBuffer[index2+6] = nx;\\n                texcoordsBuffer[index2+7] = ny;\\n\\n                vertexBuffer[index+8] = p2[0] - n2[0];\\n                vertexBuffer[index+9] = p2[1] - n2[1];\\n                vertexBuffer[index+10] = p2[2] - n2[2];\\n                vertexBuffer[index+11] = nz;\\n\\n                texcoordsBuffer[index2+8] = fc.u2;\\n                texcoordsBuffer[index2+9] = fc.v1 +  planeShift;\\n                texcoordsBuffer[index2+10] = nx;\\n                texcoordsBuffer[index2+11] = ny;\\n\\n\\n                //next polygon\\n                vertexBuffer[index+12] = p1[0] - n3[0];\\n                vertexBuffer[index+13] = p1[1] - n3[1];\\n                vertexBuffer[index+14] = p1[2] - n3[2];\\n                vertexBuffer[index+15] = nz;\\n\\n                texcoordsBuffer[index2+12] = fc.u1;\\n                texcoordsBuffer[index2+13] = fc.v2 +  planeShift;\\n                texcoordsBuffer[index2+14] = nx;\\n                texcoordsBuffer[index2+15] = ny;\\n\\n                vertexBuffer[index+16] = p2[0] - n3[0];\\n                vertexBuffer[index+17] = p2[1] - n3[1];\\n                vertexBuffer[index+18] = p2[2] - n3[2];\\n                vertexBuffer[index+19] = nz;\\n\\n                texcoordsBuffer[index2+16] = fc.u2;\\n                texcoordsBuffer[index2+17] = fc.v2 +  planeShift;\\n                texcoordsBuffer[index2+18] = nx;\\n                texcoordsBuffer[index2+19] = ny;\\n\\n                vertexBuffer[index+20] = p2[0] - n2[0];\\n                vertexBuffer[index+21] = p2[1] - n2[1];\\n                vertexBuffer[index+22] = p2[2] - n2[2];\\n                vertexBuffer[index+23] = nz;\\n\\n                texcoordsBuffer[index2+20] = fc.u2;\\n                texcoordsBuffer[index2+21] = fc.v1 +  planeShift;\\n                texcoordsBuffer[index2+22] = nx;\\n                texcoordsBuffer[index2+23] = ny;\\n\\n                index += 24;\\n                index2 += 24;\\n            }\\n\\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\\n            l = fc.lx * factor;\\n        }\\n    }\\n\\n    return [pos, index, index2, l * spacing];\\n};\\n\\n\\nvar getCharVerticesCount = function(origin) {\\n    return (origin ? 3 : 4) * 3 * 2;\\n};\\n\\n\\nvar addText = function(pos, dir, text, size, spacing, fonts, vertexBuffer, texcoordsBuffer, flat, index, planes, glyphsRes, singleBuffer) {\\n    var textVector = [0,1,0];\\n    var p1 = [pos[0], pos[1], pos[2]];\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    var gfonts = res[1];\\n\\n    for (var i = 0, li = glyphs.length; i < li; i++) {\\n        var glyph = glyphs[i];\\n        var font = fonts[gfonts[i]];\\n\\n        if (font) {\\n            var factor = getFontFactor(size, font);\\n\\n            var shift = addChar(p1, dir, 0, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, gfonts[i], singleBuffer);\\n\\n            //var gid2 = (i<gls.length-1 && gls[i+1]!=-1)  ? gls[i+1] : 0;\\n            //x += Typr.U.getPairAdjustment(font, gid, gid2);\\n\\n            p1 = shift[0];\\n            index = shift[1];\\n        }\\n    }\\n\\n    return index;\\n};\\n\\n\\nvar addTextOnPath = function(points, distance, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes) {\\n    if (textVector == null) {\\n        textVector = [0,1,0];\\n    }\\n\\n    var p1 = points[0];\\n    //var newLineSpace = getLineHeight(size, fonts);\\n    //var s = [p1[0], p1[1], p1[2]];\\n\\n    p1 = [p1[0], p1[1], p1[2]];\\n    var l = distance;\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    var gfonts = res[1];\\n\\n    for (var i = 0, li = glyphs.length; i < li; i++) {\\n        /*  \\n        var char = text.charCodeAt(i);\\n\\n        if (char == 10) { //new line\\n            s[0] += -dir[1] * newLineSpace;\\n            s[1] += dir[0] * newLineSpace;\\n            p1 = [s[0], s[1], s[2]];\\n            continue;\\n        }\\n\\n        if (char == 9) { //tab\\n            char = 32;\\n        }\\n        */\\n\\n        var glyph = glyphs[i];\\n        var font = fonts[gfonts[i]];\\n\\n        if (font) {\\n            var factor = getFontFactor(size, font);\\n\\n            var ll = 0.01;\\n            var fc = font.glyphs[glyph];\\n            if (fc) {\\n                ll = fc.step * factor * spacing;\\n            }\\n\\n            var posAndDir = getPathPositionAndDirection(points, l);\\n            var posAndDir2 = getPathPositionAndDirection(points, l+ll);\\n\\n            //average dir\\n            var dir = [(posAndDir2[1][0] + posAndDir[1][0])*0.5,\\n                (posAndDir2[1][1] + posAndDir[1][1])*0.5,\\n                (posAndDir2[1][2] + posAndDir[1][2])*0.5];\\n\\n            vec3Normalize(dir);\\n\\n            var shift = addChar(posAndDir[0], dir, -factor*font.size*0.7+verticalOffset, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, null, planes, gfonts[i]);\\n\\n            p1 = shift[0];\\n            index = shift[1];\\n            //index2 = shift[2];\\n            l += ll;\\n        }\\n    }\\n\\n    return index;\\n};\\n\\n\\nvar addStreetTextOnPath = function(points, text, size, spacing, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes) {\\n    var textLength = getTextLength(text, size, spacing, fonts, glyphsRes);\\n    var pathLength = getPathLength(points);\\n    var shift = (pathLength -  textLength)*0.5;\\n    if (shift < 0) {\\n        shift = 0;\\n    }\\n\\n    if (textLength > pathLength) {\\n        return;\\n    }\\n\\n    var textVector = getPathTextVector(points, shift, text, size, spacing, fonts, glyphsRes);\\n\\n    return addTextOnPath(points, shift, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes);\\n};\\n\\n\\nvar getFontFactor = function(size, font) {\\n    return font ? ((size / font.size) * 1.52) : 1;\\n};\\n\\n\\nvar getLineHeight = function(size, lineHeight, fonts) {\\n    var factor = getFontFactor(size, fonts[0]);\\n    //return font.space * factor;\\n    return fonts[0].cly * factor * lineHeight;\\n};\\n\\n\\nvar getTextLength = function(text, size, spacing, fonts, glyphsRes) {\\n    var l = 0;\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    var gfonts = res[1];\\n\\n    for (var i = 0, li = glyphs.length; i < li; i++) {\\n        var glyph = glyphs[i];\\n        var font = fonts[gfonts[i]];\\n\\n        if (font) {\\n            var factor = getFontFactor(size, font) * spacing;\\n            var fc = font.glyphs[glyph];\\n\\n            if (fc) {\\n                if (i == (li-1)) {\\n                    l += fc.lx * factor;\\n                } else {\\n                    l += fc.step * factor;\\n                }\\n            }\\n        }\\n    }\\n\\n    return l;\\n};\\n\\n\\nvar getSplitIndex = function(text, width, size, spacing, fonts, glyphsRes) {\\n    var l = 0;\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    var gfonts = res[1];\\n    var codes = res[2];\\n\\n    for (var i = 0, li = glyphs.length; i < li; i++) {\\n        var glyph = glyphs[i];\\n        var char = codes[i];//text.charCodeAt(i);\\n\\n        if (l > width && (char == 10 || char == 9 || char == 32)) {\\n            return i;\\n        }\\n\\n        if (char == 10) { //new line\\n            continue;\\n        }\\n\\n        var font = fonts[gfonts[i]];\\n\\n        if (font) {\\n            var factor = getFontFactor(size, font) * spacing;\\n            var fc = font.glyphs[glyph];\\n\\n            if (fc) {\\n                if (i == (li-1)) {\\n                    l += fc.lx * factor;\\n                } else {\\n                    l += fc.step * factor;\\n                }\\n            }\\n        }\\n    }\\n\\n    return li;\\n};\\n\\n\\nvar getPathLength = function(points) {\\n    var l = 0;\\n\\n    for (var i = 0, li = points.length-1; i < li; i++) {\\n        var p1 = points[i];\\n        var p2 = points[i+1];\\n        var dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n\\n        l += vec3Length(dir);\\n    }\\n\\n    return l;\\n};\\n\\n\\nvar getPathPositionAndDirection = function(points, distance) {\\n    var l = 0;\\n    var p1 = [0,0,0];\\n    var dir = [1,0,0];\\n\\n    for (var i = 0, li = points.length-1; i < li; i++) {\\n        p1 = points[i];\\n        var p2 = points[i+1];\\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n\\n        var ll = vec3Length(dir);\\n\\n        if ((l + ll) > distance) {\\n\\n            var factor = (distance - l) / (ll);\\n            var p = [p1[0] + dir[0] * factor,\\n                p1[1] + dir[1] * factor,\\n                p1[2] + dir[2] * factor];\\n\\n            vec3Normalize(dir);\\n\\n            return [p, dir];\\n        }\\n\\n        l += ll;\\n    }\\n\\n    return [p1, dir];\\n};\\n\\n\\nvar getPathTextVector = function(points, shift, text, size, spacing, fonts, glyphsRes) {\\n    var l = 0;\\n    var p1 = [0,0,0];\\n    var dir = [1,0,0];\\n    var textDir = [0,0,0];\\n    var textStart = shift;\\n    var textEnd = shift + getTextLength(text, size, spacing, fonts, glyphsRes);\\n    var bboxMin = globals.bboxMin;\\n    var geocent = globals.geocent;\\n\\n    for (var i = 0, li = points.length-1; i < li; i++) {\\n        p1 = points[i];\\n        var p2 = points[i+1];\\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n\\n        l += vec3Length(dir);\\n\\n        if (l > textStart) {\\n            vec3Normalize(dir);\\n            textDir[0] += dir[0];\\n            textDir[1] += dir[1];\\n            textDir[2] += dir[2];\\n        }\\n\\n        if (l > textEnd) {\\n            vec3Normalize(textDir);\\n\\n            if (geocent) {\\n                var nn = [0,0,0];\\n                vec3Normalize(bboxMin, nn);\\n                vec3Cross(nn, textDir, nn);\\n                return nn;\\n            } else {\\n                return [-textDir[1], textDir[0],0];\\n            }\\n        }\\n    }\\n\\n    return textDir;\\n};\\n\\n\\nvar areTextCharactersAvailable = function(text, fonts, glyphsRes) {\\n    if (!text || text == '') {\\n        return false;\\n    }\\n\\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\\n    var glyphs = res[0];\\n    //var gfonts = res[1];\\n\\n    if (glyphs.indexOf(0) != -1) {\\n        return false;\\n    }\\n\\n    return true;\\n};\\n\\n\\nvar hasLatin = function(str) {\\n    for (var i = 0, li = str.length; i < li; i++) {\\n        var c = str.charCodeAt(i);\\n        if ((c >= 0x41 && c <= 0x5a) || (c >= 0x61 && c <= 0x7a) ||\\n            ((c >= 0xc0 && c <= 0xff) && c!= 0xd7 && c!= 0xf7) || (c >= 0x100 && c <= 0x17f)) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n\\n\\nvar isCJK = function(str) {\\n    for (var i = 0, li = str.length; i < li; i++) {\\n        var c = str.charCodeAt(i);\\n\\n        if (!((c >= 0x4E00 && c <= 0x62FF) || (c >= 0x6300 && c <= 0x77FF) ||\\n              (c >= 0x7800 && c <= 0x8CFF) || (c >= 0x8D00 && c <= 0x9FFF) || \\n              (c >= 0x3400 && c <= 0x4DBF) || (c >= 0x20000 && c <= 0x215FF) || \\n              (c >= 0x21600 && c <= 0x230FF) || (c >= 0x23100 && c <= 0x245FF) || \\n              (c >= 0x24600 && c <= 0x260FF) || (c >= 0x26100 && c <= 0x275FF) || \\n              (c >= 0x27600 && c <= 0x290FF) || (c >= 0x29100 && c <= 0x2A6DF) || \\n              (c >= 0x2A700 && c <= 0x2B73F) || (c >= 0x2B740 && c <= 0x2B81F) || \\n              (c >= 0x2B820 && c <= 0x2CEAF) || (c >= 0x2CEB0 && c <= 0x2EBEF) || \\n              (c >= 0xF900 && c <= 0xFAFF) || (c >= 0x3300 && c <= 0x33FF) || \\n              (c >= 0xFE30 && c <= 0xFE4F) || (c >= 0xF900 && c <= 0xFAFF) || \\n              (c >= 0x2F800 && c <= 0x2FA1F) || \\n              (c >= 0x0 && c <= 0x40) || (c >= 0xa0 && c <= 0xbf)  )) { //neutral\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n\\n\\nvar getFonts = function(fonts) {\\n    var fontsMap = [];\\n    for (var i = 0, li = fonts.length; i < li; i++) {\\n        fontsMap.push(globals.fonts[fonts[i]]);\\n    }\\n\\n    return fontsMap;\\n};\\n\\n\\nvar getFontsStorage = function(fonts) {\\n    var fontsMap = [];\\n    for (var i = 0, li = fonts.length; i < li; i++) {\\n        fontsMap.push(globals.fontsMap[fonts[i]]);\\n    }\\n\\n    return fontsMap;\\n};\\n\\n\\nvar getTextGlyphs = function(text, fonts) {\\n    return Typr.U.stringToGlyphs(fonts, text);\\n};\\n\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n/* 4 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_style_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__worker_text_js__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__worker_message_js__ = __webpack_require__(1);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return processLineStringPass; });\\n/* unused harmony export processLineLabel */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return processLineStringGeometry; });\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"a\\\" /* globals */], vec3Normalize = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"e\\\" /* vec3Normalize */],\\n    vec3Cross = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"g\\\" /* vec3Cross */];\\nvar getLayerPropertyValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\\\"c\\\" /* getLayerPropertyValue */],\\n    getLayerExpresionValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\\\"g\\\" /* getLayerExpresionValue */];\\nvar addStreetTextOnPath = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"n\\\" /* addStreetTextOnPath */], areTextCharactersAvailable = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"e\\\" /* areTextCharactersAvailable */],\\n    getCharVerticesCount = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"l\\\" /* getCharVerticesCount */], getFonts = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"j\\\" /* getFonts */], getFontsStorage = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"k\\\" /* getFontsStorage */];\\nvar postGroupMessageFast = __WEBPACK_IMPORTED_MODULE_3__worker_message_js__[\\\"a\\\" /* postGroupMessageFast */], getTextGlyphs = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"h\\\" /* getTextGlyphs */];\\n\\n\\nvar processLineStringPass = function(lineString, lod, style, featureIndex, zIndex, eventInfo) {\\n    var lines = (lineString['lines'] || lineString['d-lines'])  || [];\\n\\n    if (lines.length == 0) {\\n        return;\\n    }\\n\\n    var dlines = (lineString['d-lines']) ? true : false;\\n    var line = getLayerPropertyValue(style, 'line', lineString, lod);\\n    var lineLabel = getLayerPropertyValue(style, 'line-label', lineString, lod);\\n\\n    if (!line && !lineLabel) {\\n        return;\\n    }\\n\\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\\n    var clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\\n\\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\\n\\n    var lineFlat = getLayerPropertyValue(style, 'line-flat', lineString, lod);\\n    var lineColor = getLayerPropertyValue(style, 'line-color', lineString, lod);\\n    var lineWidth = 0.5 * getLayerPropertyValue(style, 'line-width', lineString, lod);\\n    var lineWidthUnits = getLayerPropertyValue(style, 'line-width-units', lineString, lod);\\n\\n    var lineStyle = getLayerPropertyValue(style, 'line-style', lineString, lod);\\n    var lineStyleTexture = getLayerPropertyValue(style, 'line-style-texture', lineString, lod);\\n    var lineStyleBackground = getLayerPropertyValue(style, 'line-style-background', lineString, lod);\\n\\n    var lineLabelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\\n\\n    var texturedLine = (lineStyle != 'solid');\\n    var widthByRatio = (lineWidthUnits == 'ratio');\\n\\n    if (lineWidthUnits == 'points') {\\n        lineWidth *= globals.pixelFactor / ((1 / 72) * (96));\\n    }\\n\\n    var index = 0, index2 = 0, index3 = 0;\\n    var skipJoins = false;\\n\\n    if (widthByRatio) {\\n        skipJoins = (!lineFlat && ((lineWidth/* *globals.invPixelFactor*/)*1080) < 2.1);\\n    } else {\\n        skipJoins = (!lineFlat && (lineWidth/* *globals.invPixelFactor*/) < 2.1);        \\n    }\\n\\n    var ii, i, li, p2, v, vv, l, n, nn, p1, p, elementIndex, elemetBase = 1;\\n\\n    if (!skipJoins) {\\n        var circleBuffer = [];\\n        var circleBuffer2 = [];\\n        var circleSides = 8;//Math.max(8, (14 - lod) * 8);\\n    \\n        var angle = 0, step = (2.0*Math.PI) / circleSides;\\n    \\n        for (i = 0; i < circleSides; i++) {\\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\\n            circleBuffer2[i] = angle;\\n            angle += step;\\n        }\\n    \\n        circleBuffer[circleSides] = [0, 1.0];\\n        circleBuffer2[circleSides] = 0;\\n    }\\n\\n    var totalPoints = 0;\\n\\n    for (ii = 0; ii < lines.length; ii++) {\\n        if (Array.isArray(lines[ii])) {\\n            totalPoints += lines[ii].length;\\n        }\\n    }\\n\\n    if (totalPoints <= 1) {\\n        return;\\n    }\\n\\n    if (lineFlat) {\\n        circleSides = 2;\\n    }\\n\\n    //allocate buffers\\n    var lineVertices = ((texturedLine || (widthByRatio)) || !lineFlat ? 4 : 3) * 3 * 2;\\n    var joinVertices = skipJoins ? 0 : (circleSides * ((texturedLine || (widthByRatio)) || !lineFlat? 4 : 3) * 3);\\n    var vertexBuffer = new Float32Array((totalPoints-1) * lineVertices + totalPoints * joinVertices);\\n\\n    if (advancedHit) {\\n       var elementBuffer = new Float32Array((totalPoints-1) * (3 * 2) + totalPoints * (skipJoins ? 0 : circleSides) * 3);\\n    }\\n\\n    if (!(lineFlat && !texturedLine && !widthByRatio)) {\\n        var lineNormals = 3 * 4 * 2;\\n        var joinNormals = skipJoins ? 0 : (circleSides * 3 * 4);\\n        var normalBuffer = new Float32Array((totalPoints-1) * lineNormals + totalPoints * joinNormals);\\n    }\\n\\n    var center = [0,0,0];\\n    var lineLabelStack = [];\\n    var forceOrigin = globals.forceOrigin;\\n    var bboxMin = globals.bboxMin;\\n    var geocent = globals.geocent;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceScale = globals.forceScale;\\n    var vstart = [1,0,0], vend = [-1,0,0];\\n\\n    for (ii = 0; ii < lines.length; ii++) {\\n        if (!Array.isArray(lines[ii]) || !lines[ii].length) {\\n            continue;\\n        }\\n        \\n        var points = lines[ii];\\n\\n        if (lineLabel) {\\n            var lineLabelPoints = new Array(points.length);\\n            var lineLabelPoints2 = new Array(points.length);\\n            \\n            lineLabelStack.push({points: lineLabelPoints, points2 :lineLabelPoints2});\\n        }\\n    \\n        p = points[0];\\n        p1 = [p[0], p[1], p[2]];\\n    \\n        if (forceOrigin) {\\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n        }\\n    \\n        if (forceScale != null) {\\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n        }\\n    \\n        var distance = 0.001;\\n        var distance2 = 0.001;\\n        /*var ln = null;*/\\n        var vertexBase = index;\\n        var normalBase = index2;\\n\\n        //add lines\\n        for (i = 0, li = points.length - 1; i < li; i++) {\\n    \\n            if (dlines) {\\n                p2 = points[i+1];\\n                p2 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\\n    \\n                if (forceOrigin) {\\n                    p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\\n                }\\n    \\n                if (forceScale != null) {\\n                    p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\\n                }\\n    \\n            } else {\\n                p1 = points[i];\\n                p2 = points[i+1];\\n    \\n                if (forceOrigin) {\\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n                    p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\\n                }\\n    \\n                if (forceScale != null) {\\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n                    p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\\n                }\\n            }\\n    \\n            if (advancedHit) {\\n                elementIndex = elemetBase + i;\\n\\n                elementBuffer[index3] = elementIndex;\\n                elementBuffer[index3+1] = elementIndex;\\n                elementBuffer[index3+2] = elementIndex;\\n    \\n                //add polygon\\n                elementBuffer[index3+3] = elementIndex;\\n                elementBuffer[index3+4] = elementIndex;\\n                elementBuffer[index3+5] = elementIndex;\\n\\n                index3 += 6;\\n            }\\n\\n            if (lineFlat && !texturedLine && !widthByRatio) {\\n\\n                //normalize vector to line width and rotate 90 degrees\\n                if (geocent) {\\n                    //direction vector\\n                    v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n        \\n                    //get line length\\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\\n                    distance2 += l;\\n        \\n                    l = (l != 0) ? (1 / l) : 0;\\n\\n                    vv = [v[0]*l, v[1]*l, v[2]*l];\\n                    n = [0,0,0];\\n                    nn = [0,0,0];\\n                    \\n                    vec3Normalize(bboxMin, nn);\\n                    vec3Cross(nn, vv, n);\\n\\n                    if (i == 0) {\\n                        vstart = vv;\\n                    }\\n\\n                    if (i == (li - 1)) {\\n                        vend = vv;\\n                    }\\n                    \\n                    n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\\n                } else {\\n                    //direction vector\\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\\n        \\n                    //get line length\\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\\n                    distance2 += l;\\n        \\n                    l = (l != 0) ? (lineWidth / l) : 0;\\n\\n                    n = [-v[1]*l, v[0]*l, 0];\\n\\n                    if (i == 0) {\\n                        vstart = [v[0]*l, v[1]*l, 0];\\n                    }\\n\\n                    if (i == (li - 1)) {\\n                        vend = [v[0]*l, v[1]*l, 0];\\n                    }\\n                }\\n                        \\n                //add polygon\\n                vertexBuffer[index] = p1[0] + n[0];\\n                vertexBuffer[index+1] = p1[1] + n[1];\\n                vertexBuffer[index+2] = p1[2] + n[2];\\n    \\n                vertexBuffer[index+3] = p1[0] - n[0];\\n                vertexBuffer[index+4] = p1[1] - n[1];\\n                vertexBuffer[index+5] = p1[2] - n[2];\\n    \\n                vertexBuffer[index+6] = p2[0] + n[0];\\n                vertexBuffer[index+7] = p2[1] + n[1];\\n                vertexBuffer[index+8] = p2[2] + n[2];\\n    \\n                //add polygon\\n                vertexBuffer[index+9] = p1[0] - n[0];\\n                vertexBuffer[index+10] = p1[1] - n[1];\\n                vertexBuffer[index+11] = p1[2] - n[2];\\n    \\n                vertexBuffer[index+12] = p2[0] - n[0];\\n                vertexBuffer[index+13] = p2[1] - n[1];\\n                vertexBuffer[index+14] = p2[2] - n[2];\\n    \\n                vertexBuffer[index+15] = p2[0] + n[0];\\n                vertexBuffer[index+16] = p2[1] + n[1];\\n                vertexBuffer[index+17] = p2[2] + n[2];\\n    \\n                index += 18;\\n\\n            } else {\\n    \\n   \\n                //console.log(\\\"distance(\\\"+i+\\\"): \\\" + distance + \\\" \\\" + distance2);\\n    \\n                if (lineFlat) {\\n                    \\n                    /*\\n                    //normalize vector to line width and rotate 90 degrees\\n                    l = (l != 0) ? (lineWidth / l) : 0;\\n                    n = [-v[1]*l, v[0]*l,0];\\n    \\n                    if (joinParams != null) {\\n                        joinParams[i] = (l != 0) ? Math.atan2(v[0], v[1]) + Math.PI *0.5 : 0;\\n                    }*/\\n    \\n                    //normalize vector to line width and rotate 90 degrees\\n                    if (geocent) {\\n                        //direction vector\\n                        v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\\n            \\n                        //get line length\\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\\n                        distance2 += l;\\n            \\n                        l = (l != 0) ? (1 / l) : 0;\\n\\n                        vv = [v[0]*l, v[1]*l, v[2]*l];\\n                        n = [0,0,0];\\n                        nn = [0,0,0];\\n\\n                        if (i == 0) {\\n                            vstart = vv;\\n                        }\\n\\n                        if (i == (li - 1)) {\\n                            vend = vv;\\n                        }\\n                        \\n                        vec3Normalize(bboxMin, nn);\\n                        vec3Cross(nn, vv, n);\\n                        \\n                        //n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\\n                        n = [n[0], n[1], n[2]];\\n                    } else {\\n                        //direction vector\\n                        v = [p2[0] - p1[0], p2[1] - p1[1], 0];\\n            \\n                        //get line length\\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\\n                        distance2 += l;\\n            \\n                        l = (l != 0) ? (lineWidth / l) : 0;\\n\\n                        n = [-v[1], v[0], 0];\\n\\n                        if (i == 0) {\\n                            vstart = [v[0]*l, v[1]*l, 0];\\n                        }\\n\\n                        if (i == (li - 1)) {\\n                            vend = [v[0]*l, v[1]*l, 0];\\n                        }\\n                    }\\n\\n                    //add polygon\\n                    vertexBuffer[index] = p1[0];\\n                    vertexBuffer[index+1] = p1[1];\\n                    vertexBuffer[index+2] = p1[2];\\n                    vertexBuffer[index+3] = distance;\\n                    normalBuffer[index2] = n[0];\\n                    normalBuffer[index2+1] = n[1];\\n                    normalBuffer[index2+2] = n[2];\\n                    normalBuffer[index2+3] = lineWidth;\\n    \\n                    vertexBuffer[index+4] = p1[0];\\n                    vertexBuffer[index+5] = p1[1];\\n                    vertexBuffer[index+6] = p1[2];\\n                    vertexBuffer[index+7] = -distance;\\n                    normalBuffer[index2+4] = -n[0];\\n                    normalBuffer[index2+5] = -n[1];\\n                    normalBuffer[index2+6] = -n[2];\\n                    normalBuffer[index2+7] = lineWidth;\\n    \\n                    vertexBuffer[index+8] = p2[0];\\n                    vertexBuffer[index+9] = p2[1];\\n                    vertexBuffer[index+10] = p2[2];\\n                    vertexBuffer[index+11] = distance2;\\n                    normalBuffer[index2+8] = n[0];\\n                    normalBuffer[index2+9] = n[1];\\n                    normalBuffer[index2+10] = n[2];\\n                    normalBuffer[index2+11] = lineWidth;\\n    \\n                    //add polygon\\n                    vertexBuffer[index+12] = p1[0];\\n                    vertexBuffer[index+13] = p1[1];\\n                    vertexBuffer[index+14] = p1[2];\\n                    vertexBuffer[index+15] = -distance;\\n                    normalBuffer[index2+12] = -n[0];\\n                    normalBuffer[index2+13] = -n[1];\\n                    normalBuffer[index2+14] = -n[2];\\n                    normalBuffer[index2+15] = lineWidth;\\n    \\n                    vertexBuffer[index+16] = p2[0];\\n                    vertexBuffer[index+17] = p2[1];\\n                    vertexBuffer[index+18] = p2[2];\\n                    vertexBuffer[index+19] = -distance2;\\n                    normalBuffer[index2+16] = -n[0];\\n                    normalBuffer[index2+17] = -n[1];\\n                    normalBuffer[index2+18] = -n[2];\\n                    normalBuffer[index2+19] = lineWidth;\\n    \\n                    vertexBuffer[index+20] = p2[0];\\n                    vertexBuffer[index+21] = p2[1];\\n                    vertexBuffer[index+22] = p2[2];\\n                    vertexBuffer[index+23] = distance2;\\n                    normalBuffer[index2+20] = n[0];\\n                    normalBuffer[index2+21] = n[1];\\n                    normalBuffer[index2+22] = n[2];\\n                    normalBuffer[index2+23] = lineWidth;\\n    \\n                    index += 24;\\n                    index2 += 24;\\n                    \\n                } else {\\n\\n                    //direction vector\\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\\n        \\n                    //get line length\\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\\n                    distance2 += l;\\n    \\n                    //add polygon\\n                    vertexBuffer[index] = p1[0];\\n                    vertexBuffer[index+1] = p1[1];\\n                    vertexBuffer[index+2] = p1[2];\\n                    vertexBuffer[index+3] = distance;\\n                    normalBuffer[index2] = p2[0];\\n                    normalBuffer[index2+1] = p2[1];\\n                    normalBuffer[index2+2] = p2[2];\\n                    normalBuffer[index2+3] = lineWidth;\\n    \\n                    vertexBuffer[index+4] = p1[0];\\n                    vertexBuffer[index+5] = p1[1];\\n                    vertexBuffer[index+6] = p1[2];\\n                    vertexBuffer[index+7] = -distance;\\n                    normalBuffer[index2+4] = p2[0];\\n                    normalBuffer[index2+5] = p2[1];\\n                    normalBuffer[index2+6] = p2[2];\\n                    normalBuffer[index2+7] = -lineWidth;\\n    \\n                    vertexBuffer[index+8] = p2[0];\\n                    vertexBuffer[index+9] = p2[1];\\n                    vertexBuffer[index+10] = p2[2];\\n                    vertexBuffer[index+11] = -distance2;\\n                    normalBuffer[index2+8] = p1[0];\\n                    normalBuffer[index2+9] = p1[1];\\n                    normalBuffer[index2+10] = p1[2];\\n                    normalBuffer[index2+11] = lineWidth;\\n    \\n                    //add polygon\\n                    vertexBuffer[index+12] = p1[0];\\n                    vertexBuffer[index+13] = p1[1];\\n                    vertexBuffer[index+14] = p1[2];\\n                    vertexBuffer[index+15] = distance;\\n                    normalBuffer[index2+12] = p2[0];\\n                    normalBuffer[index2+13] = p2[1];\\n                    normalBuffer[index2+14] = p2[2];\\n                    normalBuffer[index2+15] = lineWidth;\\n    \\n                    vertexBuffer[index+16] = p2[0];\\n                    vertexBuffer[index+17] = p2[1];\\n                    vertexBuffer[index+18] = p2[2];\\n                    vertexBuffer[index+19] = -distance2;\\n                    normalBuffer[index2+16] = p1[0];\\n                    normalBuffer[index2+17] = p1[1];\\n                    normalBuffer[index2+18] = p1[2];\\n                    normalBuffer[index2+19] = lineWidth;\\n    \\n                    vertexBuffer[index+20] = p2[0];\\n                    vertexBuffer[index+21] = p2[1];\\n                    vertexBuffer[index+22] = p2[2];\\n                    vertexBuffer[index+23] = distance2;\\n                    normalBuffer[index2+20] = p1[0];\\n                    normalBuffer[index2+21] = p1[1];\\n                    normalBuffer[index2+22] = p1[2];\\n                    normalBuffer[index2+23] = -lineWidth;\\n    \\n                    index += 24;\\n                    index2 += 24;\\n                }\\n            }\\n    \\n            distance = distance2;\\n            p1 = p2; //only for dlines\\n        }\\n    \\n        p1 = [p[0], p[1], p[2]];\\n    \\n        //add joins\\n        for (i = 0, li = points.length; i < li; i++) {\\n    \\n            if (forceOrigin) {\\n                p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n            }\\n    \\n            if (forceScale != null) {\\n                p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n            }\\n    \\n            center[0] += p1[0];\\n            center[1] += p1[1];\\n            center[2] += p1[2];\\n            \\n            if (!skipJoins) {\\n                var angleShift = 0;//(joinParams != null) ? joinParams[i] : 0;\\n                /*var dx, dy;*/\\n\\n                if (lineFlat) {\\n\\n                    if (advancedHit) {\\n                        elementIndex = elemetBase + ((i != (li-1)) ? i : (i -1));\\n\\n                        elementBuffer[index3] = elementIndex;\\n                        elementBuffer[index3+1] = elementIndex;\\n                        elementBuffer[index3+2] = elementIndex;\\n            \\n                        //add polygon\\n                        elementBuffer[index3+3] = elementIndex;\\n                        elementBuffer[index3+4] = elementIndex;\\n                        elementBuffer[index3+5] = elementIndex;\\n\\n                        index3 += 6;\\n                    }\\n\\n                    var lineIndex, lineIndex2;\\n\\n                    if (!(texturedLine || widthByRatio)) {\\n\\n                        if (i != (li-1)) {\\n                            lineIndex = vertexBase + i * lineVertices;\\n                        } else {\\n                            lineIndex = vertexBase + (i - 1) * lineVertices;\\n                        }\\n\\n                        if (i > 0) {\\n                            lineIndex2 = vertexBase + (i - 1) * lineVertices;\\n                        } else {\\n                            lineIndex2 = vertexBase + lineIndex;\\n                        }\\n\\n                        if (i == 0) { //start cap\\n                            //add polygon\\n                            vertexBuffer[index] = p1[0];\\n                            vertexBuffer[index+1] = p1[1];\\n                            vertexBuffer[index+2] = p1[2];\\n\\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\\n\\n                            vertexBuffer[index+6] = p1[0] - vstart[0] * lineWidth;\\n                            vertexBuffer[index+7] = p1[1] - vstart[1] * lineWidth;\\n                            vertexBuffer[index+8] = p1[2] - vstart[2] * lineWidth;\\n\\n                            //add polygon\\n                            vertexBuffer[index+9] = p1[0];\\n                            vertexBuffer[index+9+1] = p1[1];\\n                            vertexBuffer[index+9+2] = p1[2];\\n\\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\\n\\n                            vertexBuffer[index+9+6] = p1[0] - vstart[0] * lineWidth;\\n                            vertexBuffer[index+9+7] = p1[1] - vstart[1] * lineWidth;\\n                            vertexBuffer[index+9+8] = p1[2] - vstart[2] * lineWidth;\\n                        } else if (i == (li - 1)) {  //end cap\\n                            //add polygon\\n                            vertexBuffer[index] = p1[0];\\n                            vertexBuffer[index+1] = p1[1];\\n                            vertexBuffer[index+2] = p1[2];\\n\\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex+15];\\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+16];\\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+17];\\n\\n                            vertexBuffer[index+6] = p1[0] + vend[0] * lineWidth;\\n                            vertexBuffer[index+7] = p1[1] + vend[1] * lineWidth;\\n                            vertexBuffer[index+8] = p1[2] + vend[2] * lineWidth;\\n\\n                            //add polygon\\n                            vertexBuffer[index+9] = p1[0];\\n                            vertexBuffer[index+9+1] = p1[1];\\n                            vertexBuffer[index+9+2] = p1[2];\\n\\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+12];\\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+13];\\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+14];\\n\\n                            vertexBuffer[index+9+6] = p1[0] + vend[0] * lineWidth;\\n                            vertexBuffer[index+9+7] = p1[1] + vend[1] * lineWidth;\\n                            vertexBuffer[index+9+8] = p1[2] + vend[2] * lineWidth;\\n                        } else {\\n                            //add polygon\\n                            vertexBuffer[index] = p1[0];\\n                            vertexBuffer[index+1] = p1[1];\\n                            vertexBuffer[index+2] = p1[2];\\n\\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\\n\\n                            vertexBuffer[index+6] = vertexBuffer[lineIndex2 + 15];\\n                            vertexBuffer[index+7] = vertexBuffer[lineIndex2 + 16];\\n                            vertexBuffer[index+8] = vertexBuffer[lineIndex2 + 17];\\n\\n                            //add polygon\\n                            vertexBuffer[index+9] = p1[0];\\n                            vertexBuffer[index+9+1] = p1[1];\\n                            vertexBuffer[index+9+2] = p1[2];\\n\\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\\n\\n                            vertexBuffer[index+9+6] = vertexBuffer[lineIndex2 + 12];\\n                            vertexBuffer[index+9+7] = vertexBuffer[lineIndex2 + 13];\\n                            vertexBuffer[index+9+8] = vertexBuffer[lineIndex2 + 14];\\n                        }\\n\\n                        index += 18;\\n\\n                    } else {\\n\\n                        if (i != (li-1)) {\\n                            distance = vertexBuffer[i * lineVertices + 3];\\n                        } else {\\n                            distance = vertexBuffer[(i - 1) * lineVertices + 11];\\n                        }\\n\\n                        if (i != (li-1)) {\\n                            lineIndex = normalBase + i * lineVertices;\\n                        } else {\\n                            lineIndex = normalBase + (i - 1) * lineVertices + 8;\\n                        }\\n\\n                        if (i > 0) {\\n                            lineIndex2 = normalBase + (i - 1) * lineVertices + 8;\\n                        } else {\\n                            lineIndex2 = normalBase + lineIndex;\\n                        }\\n\\n                        //add polygon\\n                        vertexBuffer[index] = p1[0];\\n                        vertexBuffer[index+1] = p1[1];\\n                        vertexBuffer[index+2] = p1[2];\\n                        vertexBuffer[index+3] = distance;\\n\\n                        vertexBuffer[index+4] = p1[0];\\n                        vertexBuffer[index+5] = p1[1];\\n                        vertexBuffer[index+6] = p1[2];\\n                        vertexBuffer[index+7] = distance;\\n\\n                        vertexBuffer[index+8] = p1[0];\\n                        vertexBuffer[index+9] = p1[1];\\n                        vertexBuffer[index+10] = p1[2];\\n                        vertexBuffer[index+11] = distance;\\n\\n                        //add polygon\\n                        vertexBuffer[index+12] = p1[0];\\n                        vertexBuffer[index+1+12] = p1[1];\\n                        vertexBuffer[index+2+12] = p1[2];\\n                        vertexBuffer[index+3+12] = distance;\\n\\n                        vertexBuffer[index+4+12] = p1[0];\\n                        vertexBuffer[index+5+12] = p1[1];\\n                        vertexBuffer[index+6+12] = p1[2];\\n                        vertexBuffer[index+7+12] = -distance;\\n\\n                        vertexBuffer[index+8+12] = p1[0];\\n                        vertexBuffer[index+9+12] = p1[1];\\n                        vertexBuffer[index+10+12] = p1[2];\\n                        vertexBuffer[index+11+12] = -distance;\\n\\n                        if (i == 0) { //start cap\\n                            //first polygon\\n                            normalBuffer[index2] = 0;\\n                            normalBuffer[index2+1] = 0;\\n                            normalBuffer[index2+2] = 0;\\n                            normalBuffer[index2+3] = -lineWidth;\\n            \\n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\\n                            normalBuffer[index2+7] = lineWidth;\\n            \\n                            normalBuffer[index2+8] = -vstart[0];\\n                            normalBuffer[index2+9] = -vstart[1];\\n                            normalBuffer[index2+10] = -vstart[2];\\n                            normalBuffer[index2+11] = -lineWidth;\\n\\n                            //second polygon\\n                            normalBuffer[index2+12] = 0;\\n                            normalBuffer[index2+1+12] = 0;\\n                            normalBuffer[index2+2+12] = 0;\\n                            normalBuffer[index2+3+12] = -lineWidth;\\n\\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\\n                            normalBuffer[index2+7+12] = lineWidth;\\n            \\n                            normalBuffer[index2+8+12] = -vstart[0];\\n                            normalBuffer[index2+9+12] = -vstart[1];\\n                            normalBuffer[index2+10+12] = -vstart[2];\\n                            normalBuffer[index2+11+12] = -lineWidth;\\n                        } else if (i == (li - 1)) {  //end cap\\n                            //first polygon\\n                            normalBuffer[index2] = 0;\\n                            normalBuffer[index2+1] = 0;\\n                            normalBuffer[index2+2] = 0;\\n                            normalBuffer[index2+3] = -lineWidth;\\n            \\n                            normalBuffer[index2+4] = normalBuffer[lineIndex2];\\n                            normalBuffer[index2+5] = normalBuffer[lineIndex2+1];\\n                            normalBuffer[index2+6] = normalBuffer[lineIndex2+2];\\n                            normalBuffer[index2+7] = lineWidth;\\n            \\n                            normalBuffer[index2+8] = vend[0];\\n                            normalBuffer[index2+9] = vend[1];\\n                            normalBuffer[index2+10] = vend[2];\\n                            normalBuffer[index2+11] = -lineWidth;\\n\\n                            //second polygon\\n                            normalBuffer[index2+12] = 0;\\n                            normalBuffer[index2+1+12] = 0;\\n                            normalBuffer[index2+2+12] = 0;\\n                            normalBuffer[index2+3+12] = -lineWidth;\\n\\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex2];\\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex2+1];\\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex2+2];\\n                            normalBuffer[index2+7+12] = lineWidth;\\n            \\n                            normalBuffer[index2+8+12] = vend[0];\\n                            normalBuffer[index2+9+12] = vend[1];\\n                            normalBuffer[index2+10+12] = vend[2];\\n                            normalBuffer[index2+11+12] = -lineWidth;\\n                        } else {\\n                            normalBuffer[index2] = 0;\\n                            normalBuffer[index2+1] = 0;\\n                            normalBuffer[index2+2] = 0;\\n                            normalBuffer[index2+3] = -lineWidth;\\n            \\n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\\n                            normalBuffer[index2+7] = lineWidth;\\n            \\n                            normalBuffer[index2+8] = normalBuffer[lineIndex2];\\n                            normalBuffer[index2+9] = normalBuffer[lineIndex2+1];\\n                            normalBuffer[index2+10] = normalBuffer[lineIndex2+2];\\n                            normalBuffer[index2+11] = lineWidth;\\n\\n                            //add polygon\\n                            normalBuffer[index2+12] = 0;\\n                            normalBuffer[index2+1+12] = 0;\\n                            normalBuffer[index2+2+12] = 0;\\n                            normalBuffer[index2+3+12] = -lineWidth;\\n\\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\\n                            normalBuffer[index2+7+12] = lineWidth;\\n            \\n                            normalBuffer[index2+8+12] = -normalBuffer[lineIndex2];\\n                            normalBuffer[index2+9+12] = -normalBuffer[lineIndex2+1];\\n                            normalBuffer[index2+10+12] = -normalBuffer[lineIndex2+2];\\n                            normalBuffer[index2+11+12] = lineWidth;\\n                        }\\n\\n                        index += 24;\\n                        index2 += 24;\\n\\n                    }\\n\\n                } else {\\n\\n                    var segmentIndex = (i != (li-1)) ? i : (i - 1);\\n\\n                    for (var j = 0; j < circleSides; j++) {\\n           \\n                        if (advancedHit) {\\n                            elementIndex = elemetBase + segmentIndex;\\n                            elementBuffer[index3] = elementIndex;\\n                            elementBuffer[index3+1] = elementIndex;\\n                            elementBuffer[index3+2] = elementIndex;\\n                            index3 += 3;\\n                        }\\n\\n                        distance = vertexBuffer[segmentIndex * lineVertices + 3];\\n        \\n                        //add polygon\\n                        vertexBuffer[index] = p1[0];\\n                        vertexBuffer[index+1] = p1[1];\\n                        vertexBuffer[index+2] = p1[2];\\n                        vertexBuffer[index+3] = distance;\\n                        normalBuffer[index2] = 0;\\n                        normalBuffer[index2+1] = 0;\\n                        normalBuffer[index2+2] = 0;\\n                        normalBuffer[index2+3] = 0;\\n        \\n                        vertexBuffer[index+4] = p1[0];\\n                        vertexBuffer[index+5] = p1[1];\\n                        vertexBuffer[index+6] = p1[2];\\n                        vertexBuffer[index+7] = distance;\\n                        normalBuffer[index2+4] = circleBuffer[j][0] * lineWidth;\\n                        normalBuffer[index2+5] = circleBuffer[j][1] * lineWidth;\\n                        normalBuffer[index2+6] = circleBuffer2[j] + angleShift;\\n                        normalBuffer[index2+7] = 0;\\n        \\n                        vertexBuffer[index+8] = p1[0];\\n                        vertexBuffer[index+9] = p1[1];\\n                        vertexBuffer[index+10] = p1[2];\\n                        vertexBuffer[index+11] = distance;\\n                        normalBuffer[index2+8] = circleBuffer[j+1][0] * lineWidth;\\n                        normalBuffer[index2+9] = circleBuffer[j+1][1] * lineWidth;\\n                        normalBuffer[index2+10] = circleBuffer2[j+1] + angleShift;\\n                        normalBuffer[index2+11] = 0;\\n        \\n                        index += 12;\\n                        index2 += 12;\\n                    }\\n                }\\n            }\\n    \\n            if (lineLabel) {\\n                p = [p1[0], p1[1], p1[2] + lineLabelSize*0.1];\\n                lineLabelPoints[i] = p;\\n                lineLabelPoints2[li - i - 1] = p;\\n            }\\n    \\n            if ((i + 1) < li) {\\n                if (dlines) {\\n                    p2 = points[i+1];\\n                    p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\\n                } else {\\n                    p1 = points[i+1];\\n                }\\n            }\\n        }\\n\\n        elemetBase += points.length;\\n    }\\n\\n    if (totalPoints > 0) {\\n        center[0] /= totalPoints;\\n        center[1] /= totalPoints;\\n        center[2] /= totalPoints;\\n    }\\n\\n    center[0] += globals.groupOrigin[0];\\n    center[1] += globals.groupOrigin[1];\\n    center[2] += globals.groupOrigin[2];\\n\\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent, type;\\n\\n    if (line) {\\n        //console.log('totalPoints:' + totalPoints + ' vbuff-l:' + (vertexBuffer ? vertexBuffer.length : '??'));\\n\\n        var messageData = {\\n            'color':lineColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit, 'totalPoints': totalPoints,\\n            'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'width-units': lineWidthUnits,\\n            'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\\n            'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, \\n            'line-width':lineWidth*2, 'lod':(globals.autoLod ? null : globals.tileLod) };\\n    \\n        if (lineFlat) {\\n            type = texturedLine ? 8 : (widthByRatio ? 7 : 6);\\n        } else {\\n            type = texturedLine ? 10 : 9;\\n        }\\n    \\n        if (texturedLine) {\\n            if (lineStyleTexture != null) {\\n                messageData['texture'] = [globals.stylesheetBitmaps[lineStyleTexture[0]], lineStyleTexture[1], lineStyleTexture[2]];\\n                messageData['background'] = lineStyleBackground;\\n            }\\n        }\\n\\n        var signature = JSON.stringify({\\n            type: 'T'+type,\\n            color : lineColor,\\n            zIndex : zIndex,\\n            zOffset : zbufferOffset,\\n            state : globals.hitState\\n        });\\n\\n        var buffers = (normalBuffer) ? [vertexBuffer, normalBuffer] : [vertexBuffer];\\n\\n        if (advancedHit) {\\n            buffers.push(elementBuffer);\\n        }\\n        \\n        postGroupMessageFast(5, type, messageData, buffers, signature);\\n    }\\n\\n    if (lineLabel) {\\n        for (i = 0, li = lineLabelStack.length; i < li; i++) {\\n            processLineLabel(lineLabelStack[i].points, lineLabelStack[i].points2, lineString, center, lod, style, featureIndex, zIndex, eventInfo);\\n        }\\n    }\\n\\n};\\n\\nvar processLineLabel = function(lineLabelPoints, lineLabelPoints2, lineString, center, lod, style, featureIndex, zIndex, eventInfo) {\\n    var labelColor = getLayerPropertyValue(style, 'line-label-color', lineString, lod);\\n    var labelColor2 = getLayerPropertyValue(style, 'line-label-color2', lineString, lod);\\n    var labelOutline = getLayerPropertyValue(style, 'line-label-outline', lineString, lod);\\n    var labelSource = getLayerPropertyValue(style, 'line-label-source', lineString, lod);\\n    var labelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\\n    var labelSpacing = getLayerPropertyValue(style, 'line-label-spacing', lineString, lod);\\n    var labelLineHeight = getLayerPropertyValue(style, 'line-label-line-height', lineString, lod);\\n    var labelOffset = getLayerPropertyValue(style, 'line-label-offset', lineString, lod);\\n\\n    if (Math.abs(labelSize) < 0.0001) {\\n        return;\\n    }\\n\\n    var labelText = getLayerExpresionValue(style, labelSource, lineString, lod, labelSource);\\n    labelText = labelText ? labelText.replace('\\\\r\\\\n', '\\\\n').replace('\\\\r', '\\\\n') : '';\\n    var fontNames = getLayerPropertyValue(style, 'line-label-font', lineString, lod);\\n    var fonts = getFonts(fontNames);\\n    var fontsStorage = getFontsStorage(fontNames);\\n    var glyphsRes = getTextGlyphs(labelText, fonts);\\n\\n    if (labelSource == '$name') {\\n        if (!areTextCharactersAvailable(labelText, fonts, glyphsRes)) {\\n            var labelText2 = getLayerExpresionValue(style, '$name:en', lineString, lod, labelSource);\\n            labelText2 = labelText2 ? labelText2.replace('\\\\r\\\\n', '\\\\n').replace('\\\\r', '\\\\n') : '';\\n            var glyphsRes2 = getTextGlyphs(labelText, fonts);\\n            \\n            if (areTextCharactersAvailable(labelText2, fonts, glyphsRes2)) {\\n                labelText = labelText2;                     \\n                glyphsRes = glyphsRes2;\\n            }\\n        }\\n    }\\n\\n    if (!labelText || labelText == '') {\\n        return;\\n    }\\n\\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\\n    var clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\\n\\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\\n\\n    var bufferSize = getCharVerticesCount() * labelText.length * 2;\\n    var vertexBuffer = new Float32Array(bufferSize);\\n    var texcoordsBuffer = new Float32Array(bufferSize);\\n    var planes = {};\\n\\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\\n\\n    var index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes);\\n    index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, index, null, glyphsRes);\\n\\n    if (!index) {\\n        return;\\n    }\\n\\n    //var fonts = labelData.fonts;\\n    var labelFiles = new Array(fonts.length);\\n\\n    for (var i = 0, li= fonts.length; i < li; i++) {\\n        labelFiles[i] = [];\\n    }\\n\\n    for (var key in planes) {\\n        var fontIndex = parseInt(key);\\n        var planes2 = planes[key];\\n\\n        var files = [];\\n\\n        for (var key2 in planes2) {\\n            var plane = parseInt(key2) - (fontIndex*4000);\\n            var file = Math.round((plane - (plane % 4)) / 4);\\n\\n            if (files.indexOf(file) == -1) {\\n                files.push(file);\\n            }\\n        }\\n\\n        labelFiles[fontIndex] = files;\\n    }\\n\\n    var signature = JSON.stringify({\\n        type: 'line-label',\\n        color : labelColor,\\n        color2 : labelColor2,\\n        outline : labelOutline,\\n        fonts : fontNames,\\n        zIndex : zIndex,\\n        zOffset : zbufferOffset\\n    });\\n\\n    postGroupMessageFast(5, 11, {\\n        'color':labelColor, 'color2':labelColor2, 'outline':labelOutline, \\n        'z-index':zIndex, 'center': center, 'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\\n        'files': labelFiles, 'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'advancedHit': advancedHit,\\n        'fonts': fontsStorage, 'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \\n        'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, texcoordsBuffer], signature);\\n};\\n\\nvar processLineStringGeometry = function(lineString) {\\n    var lines = (lineString['lines'] || lineString['d-lines'])  || [];\\n\\n    if (lines.length == 0) {\\n        return;\\n    }\\n\\n    //debugger\\n\\n    var dlines = (lineString['d-lines']) ? true : false;\\n    var totalPoints = 0;\\n    var indicesBuffer = new Uint32Array(lines.length);\\n\\n    for (i = 0; i < lines.length; i++) {\\n        indicesBuffer[i] = totalPoints;\\n\\n        if (Array.isArray(lines[i])) {\\n            totalPoints += lines[i].length;\\n        }\\n    }\\n\\n    var geometryBuffer = new Float64Array(totalPoints * 3);\\n\\n    /*var forceOrigin = globals.forceOrigin;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;*/\\n    var forceScale = globals.forceScale;\\n    var index = 0, p1, p2, pp, p;\\n\\n    for (var i = 0; i < lines.length; i++) {\\n        if (!Array.isArray(lines[i]) || !lines[i].length) {\\n            continue;\\n        }\\n        \\n        var points = lines[i];\\n   \\n        p = points[0];\\n        p1 = [p[0], p[1], p[2]];\\n    \\n        //add lines\\n        for (var j = 0, lj = points.length; j < lj; j++) {\\n\\n            /*if (forceOrigin) {\\n                pp = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n            }*/\\n    \\n            if (forceScale != null) {\\n                pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n            }\\n\\n            geometryBuffer[index] = pp[0];\\n            geometryBuffer[index+1] = pp[1];\\n            geometryBuffer[index+2] = pp[2];\\n            index += 3;\\n\\n            if (j == (lj - 1)) {\\n                break;\\n            }\\n    \\n            if (dlines) {\\n                p2 = points[j+1];\\n                p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\\n            } else {\\n                p1 = points[j+1];\\n            }   \\n        }\\n    }\\n\\n    globals.signatureCounter++;\\n\\n    postGroupMessageFast(5, 12, {\\n        'id':lineString['id'] }, [geometryBuffer, indicesBuffer], (\\\"\\\"+globals.signatureCounter));\\n};\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n/* 5 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_style_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__worker_text_js__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__worker_message_js__ = __webpack_require__(1);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return processPointArrayPass; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return processPointArrayGeometry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return processPointArrayVSwitchPass; });\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"a\\\" /* globals */], clamp = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"b\\\" /* clamp */];\\nvar getLayerPropertyValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\\\"c\\\" /* getLayerPropertyValue */], getLayerExpresionValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\\\"g\\\" /* getLayerExpresionValue */];\\nvar addText = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"f\\\" /* addText */], getSplitIndex = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"g\\\" /* getSplitIndex */], getTextGlyphs = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"h\\\" /* getTextGlyphs */],\\n    getTextLength = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"i\\\" /* getTextLength */], getFonts = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"j\\\" /* getFonts */], getFontsStorage = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"k\\\" /* getFontsStorage */],\\n    areTextCharactersAvailable = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"e\\\" /* areTextCharactersAvailable */], getCharVerticesCount = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"l\\\" /* getCharVerticesCount */], getLineHeight = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\\\"m\\\" /* getLineHeight */];\\nvar postGroupMessageFast = __WEBPACK_IMPORTED_MODULE_3__worker_message_js__[\\\"a\\\" /* postGroupMessageFast */];\\n\\n\\nvar processPointArrayPass = function(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\\n    var pointsGroups = []; \\n    var i, li, dpoints = false;\\n\\n    if (pointArray['lines'] || pointArray['d-lines']) {  //use lines as points\\n        pointsGroups = pointArray['lines'] || pointArray['d-lines'];\\n        dpoints = (pointArray['d-lines']) ? true : false;\\n    } else {\\n        if (pointArray['points'] || pointArray['d-points']) {\\n            pointsGroups = [(pointArray['points'] || pointArray['d-points'])];\\n            dpoints = (pointArray['d-points']) ? true : false;\\n        }\\n    }\\n    \\n    if (pointsGroups.length == 0) {\\n        return;\\n    }\\n\\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) || \\n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\\n    var culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', pointArray, lod);\\n    var clickEvent = getLayerPropertyValue(style, 'click-event', pointArray, lod);\\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', pointArray, lod);\\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', pointArray, lod);\\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', pointArray, lod);\\n    var advancedHit = getLayerPropertyValue(style, 'advanced-event', pointArray, lod);\\n\\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', pointArray, lod);\\n\\n    var point = getLayerPropertyValue(style, 'point', pointArray, lod);\\n    var pointFlat = getLayerPropertyValue(style, 'point-flat', pointArray, lod);\\n    var pointColor = getLayerPropertyValue(style, 'point-color', pointArray, lod);\\n    var pointRadius = 0.5 * getLayerPropertyValue(style, 'point-radius', pointArray, lod);\\n\\n    var source, bufferSize, bufferSize2, points, g, gl, totalPoints = 0;\\n    //zIndex = (zIndex !== null) ? zIndex : getLayerPropertyValue(style, \\\"z-index\\\", pointArray, lod);\\n\\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\\n        points = pointsGroups[g];\\n        if (Array.isArray(points) && points.length > 0) {\\n            totalPoints += points.length;\\n        }\\n    }\\n\\n    var icon = getLayerPropertyValue(style, 'icon', pointArray, lod);\\n    if (icon) {\\n        source = getLayerPropertyValue(style, 'icon-source', pointArray, lod);\\n        \\n        if (source) {\\n            bufferSize = getCharVerticesCount() * totalPoints;\\n            bufferSize2 = getCharVerticesCount(true) * totalPoints;\\n    \\n            var iconData = {\\n                color : getLayerPropertyValue(style, 'icon-color', pointArray, lod),\\n                scale : getLayerPropertyValue(style, 'icon-scale', pointArray, lod),\\n                offset : getLayerPropertyValue(style, 'icon-offset', pointArray, lod),\\n                stick : getLayerPropertyValue(style, 'icon-stick', pointArray, lod),\\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\\n                origin : getLayerPropertyValue(style, 'icon-origin', pointArray, lod),\\n                source : getLayerPropertyValue(style, 'icon-source', pointArray, lod),\\n                noOverlap : getLayerPropertyValue(style, 'icon-no-overlap', pointArray, lod),\\n                noOverlapMargin : getLayerPropertyValue(style, 'icon-no-overlap-margin', pointArray, lod),\\n                noOverlapFactor : getLayerPropertyValue(style, 'icon-no-overlap-factor', pointArray, lod),\\n                index : 0,\\n                index2 : 0\\n            };\\n\\n            if (totalPoints > 1) {\\n                iconData.vertexBuffer = new Float32Array(bufferSize);\\n                iconData.originBuffer = new Float32Array(bufferSize2);\\n                iconData.texcoordsBuffer = new Float32Array(bufferSize);\\n            } else {\\n                iconData.singleBuffer = new Float32Array(16);\\n            }\\n\\n        } else {\\n            icon = false;\\n        }\\n    }\\n\\n    var label = getLayerPropertyValue(style, 'label', pointArray, lod);\\n    if (label) {\\n        source = getLayerPropertyValue(style, 'label-source', pointArray, lod);\\n\\n        var text = getLayerExpresionValue(style, source, pointArray, lod, source);\\n        text = text ? text.replace('\\\\r\\\\n', '\\\\n').replace('\\\\r', '\\\\n') : '';\\n        var size = getLayerPropertyValue(style, 'label-size', pointArray, lod);\\n        var fontNames = getLayerPropertyValue(style, 'label-font', pointArray, lod);\\n        var fonts = getFonts(fontNames);\\n        var glyphsRes = getTextGlyphs(text, fonts);\\n        \\n        if (source == '$name') {\\n            if (!areTextCharactersAvailable(text, fonts, glyphsRes)) {\\n                var text2 = getLayerExpresionValue(style, '$name:en', pointArray, lod, source);\\n                text2 = text2 ? text2.replace('\\\\r\\\\n', '\\\\n').replace('\\\\r', '\\\\n') : '';\\n                var glyphsRes2 = getTextGlyphs(text2, fonts);\\n                \\n                if (areTextCharactersAvailable(text2, fonts)) {\\n                    text = text2;                     \\n                    glyphsRes = glyphsRes2;\\n                }\\n            }\\n        }\\n        if (text && text != '' && Math.abs(size) > 0.0001) {\\n            bufferSize = getCharVerticesCount() * text.length * totalPoints;\\n            bufferSize2 = getCharVerticesCount(true) * text.length * totalPoints;\\n\\n            var useSingleBuffer = (totalPoints == 1);\\n\\n            var factor = 1;\\n            if (getLayerPropertyValue(style, 'label-size-units', pointArray, lod) == 'points') {\\n                factor = globals.pixelFactor / ((1 / 72) * (96));\\n            }\\n\\n            var labelData = {\\n                color : getLayerPropertyValue(style, 'label-color', pointArray, lod),\\n                color2 : getLayerPropertyValue(style, 'label-color2', pointArray, lod),\\n                outline : getLayerPropertyValue(style, 'label-outline', pointArray, lod),\\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\\n                size : size * factor,\\n                spacing: getLayerPropertyValue(style, 'label-spacing', pointArray, lod),\\n                lineHeight: getLayerPropertyValue(style, 'label-line-height', pointArray, lod),\\n                offset : getLayerPropertyValue(style, 'label-offset', pointArray, lod),\\n                stick : getLayerPropertyValue(style, 'label-stick', pointArray, lod),\\n                origin : getLayerPropertyValue(style, 'label-origin', pointArray, lod),\\n                align : getLayerPropertyValue(style, 'label-align', pointArray, lod),\\n                fonts : fonts,\\n                fontsStorage : getFontsStorage(fontNames),\\n                text : text,\\n                hysteresis : getLayerPropertyValue(style, 'hysteresis', pointArray, lod),\\n                width : factor * getLayerPropertyValue(style, 'label-width', pointArray, lod),\\n                noOverlap : getLayerPropertyValue(style, 'label-no-overlap', pointArray, lod),\\n                noOverlapMargin : getLayerPropertyValue(style, 'label-no-overlap-margin', pointArray, lod),\\n                noOverlapFactor : getLayerPropertyValue(style, 'label-no-overlap-factor', pointArray, lod),\\n                vertexBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\\n                originBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize2)),\\n                texcoordsBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\\n                singleBuffer : (useSingleBuffer) ? (new Float32Array(text.length * 4 * 2)) : null,\\n                index : 0,\\n                index2 : 0,\\n                glyphsRes : glyphsRes\\n            };\\n\\n            if (labelData.stick) {\\n                labelData.stick = labelData.stick.slice();\\n                labelData.stick[2] *= factor;\\n                //labelData.stick[7] *= factor;\\n            }\\n\\n        } else {\\n            label = false;\\n        }\\n    }\\n\\n    var index = 0;\\n    var index2 = 0;\\n\\n    \\n    var center = [0,0,0];\\n    var forceOrigin = globals.forceOrigin;\\n    var bboxMin = globals.bboxMin;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceScale = globals.forceScale;\\n    var labelBBox, iconBBox, p, p1;\\n\\n    var pointsVertices, vertexBuffer, pointsNormals, normalBuffer;\\n\\n    if (point) {\\n        var circleBuffer = [];\\n        var circleSides = clamp(pointRadius * 8 * 0.5, 8, 32);\\n\\n        var angle = 0, step = (2.0*Math.PI) / circleSides;\\n\\n        for (i = 0; i < circleSides; i++) {\\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\\n            angle += step;\\n        }\\n\\n        circleBuffer[circleSides] = [0, 1.0];\\n\\n        //allocate buffers\\n        if (!pointFlat) {\\n            pointsVertices = circleSides * 3 * 4;\\n            vertexBuffer = new Float32Array(totalPoints * pointsVertices);\\n            pointsNormals = circleSides * 3 * 4;\\n            normalBuffer = new Float32Array(totalPoints * pointsNormals);\\n        } else {\\n            pointsVertices = circleSides * 3 * 3;\\n            vertexBuffer = new Float32Array(totalPoints * pointsVertices);\\n        }\\n    }\\n\\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\\n        points = pointsGroups[g];\\n        \\n        if (Array.isArray(points) && points.length > 0) {\\n            p = points[0];\\n            p1 = [p[0], p[1], p[2]];\\n       \\n            //add ponints\\n            for (i = 0, li = points.length; i < li; i++) {\\n        \\n                if (forceOrigin) {\\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n                }\\n        \\n                if (forceScale != null) {\\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n                }\\n        \\n                center[0] += p1[0];\\n                center[1] += p1[1];\\n                center[2] += p1[2];\\n\\n                if (icon) {\\n                    iconBBox = processIcon(p1, iconData) ;//, pointArray, lod, style, zIndex);\\n                }\\n    \\n                if (label) {\\n                    labelBBox = processLabel(p1, labelData); //, pointArray, lod, style, zIndex);\\n                }\\n\\n                if (point) {\\n        \\n                    for (var j = 0; j < circleSides; j++) {\\n\\n       \\n                        if (pointFlat) {\\n        \\n                            //add polygon\\n                            vertexBuffer[index] = p1[0];\\n                            vertexBuffer[index+1] = p1[1];\\n                            vertexBuffer[index+2] = p1[2];\\n        \\n                            vertexBuffer[index+3] = p1[0] + circleBuffer[j][0] * pointRadius;\\n                            vertexBuffer[index+4] = p1[1] + circleBuffer[j][1] * pointRadius;\\n                            vertexBuffer[index+5] = p1[2];\\n        \\n                            vertexBuffer[index+6] = p1[0] + circleBuffer[j+1][0] * pointRadius;\\n                            vertexBuffer[index+7] = p1[1] + circleBuffer[j+1][1] * pointRadius;\\n                            vertexBuffer[index+8] = p1[2];\\n\\n                            index += 9;\\n        \\n                        } else {\\n        \\n                            //add polygon\\n                            vertexBuffer[index] = p1[0];\\n                            vertexBuffer[index+1] = p1[1];\\n                            vertexBuffer[index+2] = p1[2];\\n                            vertexBuffer[index+3] = 0;\\n                            normalBuffer[index2] = 0;\\n                            normalBuffer[index2+1] = 0;\\n                            normalBuffer[index2+2] = 0;\\n                            normalBuffer[index2+3] = 0;\\n        \\n                            vertexBuffer[index+4] = p1[0];\\n                            vertexBuffer[index+5] = p1[1];\\n                            vertexBuffer[index+6] = p1[2];\\n                            vertexBuffer[index+7] = 0;\\n                            normalBuffer[index2+4] = circleBuffer[j][0] * pointRadius;\\n                            normalBuffer[index2+5] = circleBuffer[j][1] * pointRadius;\\n                            normalBuffer[index2+6] = 0;\\n                            normalBuffer[index2+7] = 0;\\n        \\n                            vertexBuffer[index+8] = p1[0];\\n                            vertexBuffer[index+9] = p1[1];\\n                            vertexBuffer[index+10] = p1[2];\\n                            vertexBuffer[index+11] = 0;\\n                            normalBuffer[index2+8] = circleBuffer[j+1][0] * pointRadius;\\n                            normalBuffer[index2+9] = circleBuffer[j+1][1] * pointRadius;\\n                            normalBuffer[index2+10] = 0;\\n                            normalBuffer[index2+11] = 0;\\n        \\n                            index += 12;\\n                            index2 += 12;\\n                        }\\n                    }\\n                }\\n        \\n                if ((i + 1) < li) {\\n                    if (dpoints) {\\n                        var p2 = points[i+1];\\n                        p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\\n                    } else {\\n                        p1 = points[i+1];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n   \\n\\n    if (totalPoints > 0) {\\n        center[0] /= totalPoints;\\n        center[1] /= totalPoints;\\n        center[2] /= totalPoints;\\n    }\\n\\n    center[0] += bboxMin[0];//groupOrigin[0];\\n    center[1] += bboxMin[1];//groupOrigin[1];\\n    center[2] += bboxMin[2];//groupOrigin[2];\\n\\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\\n    var message, messageSize;\\n\\n    globals.signatureCounter++;\\n    var signature = (\\\"\\\"+globals.signatureCounter);\\n\\n    if (visibility && !Array.isArray(visibility)) {\\n        visibility = [visibility];\\n    }\\n\\n    if (point) {\\n        if (pointFlat) {\\n            postGroupMessageFast(5, 6, {\\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \\n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer], signature);\\n        } else {\\n            postGroupMessageFast(5, 9, {\\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \\n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, normalBuffer], signature);\\n        }\\n    }\\n\\n    if (icon) {\\n\\n        globals.signatureCounter++;\\n        signature = (\\\"\\\"+globals.signatureCounter);\\n\\n        if (iconData.noOverlap) {\\n            var margin = iconData.noOverlapMargin;\\n            var factorType = null, factorValue = null;\\n\\n            if (iconData.noOverlapFactor !== null) {\\n                switch(iconData.noOverlapFactor[0]) {\\n                    case 'direct':      factorType = 0;      break;\\n                    case 'div-by-dist': factorType = 1; break;\\n                }\\n\\n                factorValue = iconData.noOverlapFactor[1];\\n            }\\n\\n            var noOverlap = [iconBBox[0]-margin[0], iconBBox[1]-margin[1], iconBBox[2]+margin[0], iconBBox[3]+margin[1], factorType, factorValue];\\n        }\\n\\n        if ((iconData.singleBuffer && iconData.singleBuffer.length > 0) || (iconData.vertexBuffer && iconData.vertexBuffer.length > 0)) {\\n\\n            postGroupMessageFast(5, (labelData.singleBuffer) ? 3 : 4, {\\n                'icon':globals.stylesheetBitmaps[iconData.source[0]], 'color':iconData.color, 'z-index':zIndex,\\n                'visibility': visibility, 'culling': culling, 'center': center, 'stick': iconData.stick,\\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'noOverlap' : (iconData.noOverlap ? noOverlap: null),\\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\\n                'index': featureIndex, 'reduce': iconData.reduce, 'lod':(globals.autoLod ? null : globals.tileLod) },\\n                (iconData.singleBuffer) ? [iconData.singleBuffer] : [iconData.vertexBuffer, iconData.originBuffer, iconData.texcoordsBuffer],\\n                signature);\\n        }\\n    }\\n\\n    if (label) {\\n        globals.signatureCounter++;\\n        signature = (\\\"\\\"+globals.signatureCounter);\\n\\n        if (labelData.noOverlap) {\\n            var margin = labelData.noOverlapMargin;\\n            var factorType = null, factorValue = null;\\n\\n            if (labelData.noOverlapFactor !== null) {\\n                switch(labelData.noOverlapFactor[0]) {\\n                    case 'direct':      factorType = 0;      break;\\n                    case 'div-by-dist': factorType = 1; break;\\n                }\\n\\n                factorValue = labelData.noOverlapFactor[1];\\n            }\\n\\n            var noOverlap = [labelBBox[0]-margin[0], labelBBox[1]-margin[1], labelBBox[2]+margin[0], labelBBox[3]+margin[1], factorType, factorValue];\\n        }\\n\\n        if ((labelData.singleBuffer && labelData.singleBuffer.length > 0) || (labelData.vertexBuffer && labelData.vertexBuffer.length > 0)) {\\n\\n            postGroupMessageFast(5, (labelData.singleBuffer) ? 1 : 2, {\\n                'size':labelData.size, 'origin':labelData.pos, 'color':labelData.color,\\n                'color2':labelData.color2, 'outline':labelData.outline, 'z-index':zIndex, 'visibility': visibility,\\n                'culling': culling, 'center': center, 'stick': labelData.stick, 'noOverlap' : (labelData.noOverlap ? noOverlap: null),\\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'files':labelData.files, 'index': featureIndex,\\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'fonts': labelData.fontsStorage,\\n                'hitable':hitable, 'state':globals.hitState, 'advancedHit': advancedHit, 'reduce': labelData.reduce, 'hysteresis': labelData.hysteresis, \\n                'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, 'lod':(globals.autoLod ? null : globals.tileLod) },\\n                (labelData.singleBuffer) ? [labelData.singleBuffer] : [labelData.vertexBuffer, labelData.originBuffer, labelData.texcoordsBuffer],\\n                signature);\\n        }\\n    }\\n\\n};\\n\\n\\nvar processPointArrayVSwitchPass = function(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\\n    var pointsGroups = []; \\n    var i, li, dpoints = false;\\n\\n    if (pointArray['lines'] || pointArray['d-lines']) {  //use lines as points\\n        pointsGroups = pointArray['lines'] || pointArray['d-lines'];\\n        dpoints = (pointArray['d-lines']) ? true : false;\\n    } else {\\n        if (pointArray['points'] || pointArray['d-points']) {\\n            pointsGroups = [(pointArray['points'] || pointArray['d-points'])];\\n            dpoints = (pointArray['d-points']) ? true : false;\\n        }\\n    }\\n    \\n    if (pointsGroups.length == 0) {\\n        return;\\n    }\\n\\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) || \\n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\\n    var culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\\n    var hysteresis = getLayerPropertyValue(style, 'hysteresis', pointArray, lod);\\n\\n    var points, g, gl, totalPoints = 0;\\n\\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\\n        points = pointsGroups[g];\\n        if (Array.isArray(points) && points.length > 0) {\\n            totalPoints += points.length;\\n        }\\n    }\\n\\n    var center = [0,0,0];\\n    var forceOrigin = globals.forceOrigin;\\n    var bboxMin = globals.bboxMin;\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceScale = globals.forceScale;\\n    var p, p1;\\n\\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\\n        points = pointsGroups[g];\\n        \\n        if (Array.isArray(points) && points.length > 0) {\\n            p = points[0];\\n            p1 = [p[0], p[1], p[2]];\\n       \\n            //add ponints\\n            for (i = 0, li = points.length; i < li; i++) {\\n        \\n                if (forceOrigin) {\\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n                }\\n        \\n                if (forceScale != null) {\\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n                }\\n        \\n                center[0] += p1[0];\\n                center[1] += p1[1];\\n                center[2] += p1[2];\\n       \\n                if ((i + 1) < li) {\\n                    if (dpoints) {\\n                        var p2 = points[i+1];\\n                        p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\\n                    } else {\\n                        p1 = points[i+1];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n   \\n    if (totalPoints > 0) {\\n        center[0] /= totalPoints;\\n        center[1] /= totalPoints;\\n        center[2] /= totalPoints;\\n    }\\n\\n    center[0] += bboxMin[0];//groupOrigin[0];\\n    center[1] += bboxMin[1];//groupOrigin[1];\\n    center[2] += bboxMin[2];//groupOrigin[2];\\n\\n    globals.signatureCounter++;\\n    var signature = (\\\"\\\"+globals.signatureCounter);\\n\\n    postGroupMessageFast(5, 18, {\\n        'z-index':zIndex, 'hysteresis' : hysteresis,\\n        'visibility': visibility, 'culling': culling, 'center': center, 'eventInfo': {} /*(globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}*/,\\n         'index': featureIndex, 'lod':(globals.autoLod ? null : globals.tileLod) }, [], signature);\\n};\\n\\n\\nvar getOriginOffset = function(origin, width, height) {\\n    switch(origin) {\\n    case 'top-left':        return [0, 0];\\n    case 'top-right':       return [-width, 0];\\n    case 'top-center':      return [-width*0.5, 0];\\n    case 'center-left':     return [0, -height*0.5];\\n    case 'center-right':    return [-width, -height*0.5];\\n    case 'center-center':   return [-width*0.5, -height*0.5];\\n    case 'bottom-left':     return [0, -height];\\n    case 'bottom-right':    return [-width, -height];\\n    case 'bottom-center':   return [-width*0.5, -height];\\n    }\\n};\\n\\nvar processIcon = function(point, iconData) {\\n    var icon = iconData.source;\\n    var index = iconData.index;\\n    var index2 = iconData.index2;\\n    var lastIndex = index;\\n\\n    var width = Math.abs(icon[3] * iconData.scale * 0.5);\\n    var height = Math.abs(icon[4] * iconData.scale * 0.5);\\n\\n    //get offset\\n    var originOffset = getOriginOffset(iconData.origin, width, height);\\n    var offsetX = originOffset[0] + iconData.offset[0];\\n    var offsetY = originOffset[1] + iconData.offset[1];\\n\\n    if (iconData.singleBuffer) {\\n        var b = iconData.singleBuffer;\\n\\n        b[0] = offsetX; b[1] = offsetY;\\n        b[2] = icon[1];\\n        b[3] = icon[2];\\n\\n        b[4] = width + offsetX; b[5] = offsetY;\\n        b[6] = icon[1]+icon[3];\\n        b[7] = icon[2];\\n\\n        b[8] = width + offsetX; b[9] = height + offsetY;\\n        b[10] = icon[1]+icon[3];\\n        b[11] = icon[2]+icon[4];\\n\\n        b[12] = offsetX; b[13] = height + offsetY;\\n        b[14] = icon[1];\\n        b[15] = icon[2]+icon[4];\\n\\n        return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\\n    }\\n\\n    var vertexBuffer = iconData.vertexBuffer;\\n    var texcoordsBuffer = iconData.texcoordsBuffer;\\n    var originBuffer = iconData.originBuffer;\\n\\n    //add polygon\\n    vertexBuffer[index] = 0;\\n    vertexBuffer[index+1] = 0;\\n    vertexBuffer[index+2] = 0;\\n    vertexBuffer[index+3] = 0;\\n\\n    vertexBuffer[index+4] = width;\\n    vertexBuffer[index+5] = 0;\\n    vertexBuffer[index+6] = 0;\\n    vertexBuffer[index+7] = 0;\\n\\n    vertexBuffer[index+8] = width;\\n    vertexBuffer[index+9] = -height;\\n    vertexBuffer[index+10] = 0;\\n    vertexBuffer[index+11] = 0;\\n\\n    texcoordsBuffer[index] = icon[1];\\n    texcoordsBuffer[index+1] = icon[2];\\n    texcoordsBuffer[index+2] = 0;\\n    texcoordsBuffer[index+3] = 0;\\n\\n    texcoordsBuffer[index+4] = icon[1]+icon[3];\\n    texcoordsBuffer[index+5] = icon[2];\\n    texcoordsBuffer[index+6] = 0;\\n    texcoordsBuffer[index+7] = 0;\\n\\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\\n    texcoordsBuffer[index+10] = 0;\\n    texcoordsBuffer[index+11] = 0;\\n\\n    index += 12;\\n\\n    //add polygon\\n    vertexBuffer[index] = 0;\\n    vertexBuffer[index+1] = 0;\\n    vertexBuffer[index+2] = 0;\\n    vertexBuffer[index+3] = 0;\\n\\n    vertexBuffer[index+4] = 0;\\n    vertexBuffer[index+5] = -height;\\n    vertexBuffer[index+6] = 0;\\n    vertexBuffer[index+7] = 0;\\n\\n    vertexBuffer[index+8] = width;\\n    vertexBuffer[index+9] = -height;\\n    vertexBuffer[index+10] = 0;\\n    vertexBuffer[index+11] = 0;\\n\\n    texcoordsBuffer[index] = icon[1];\\n    texcoordsBuffer[index+1] = icon[2];\\n    texcoordsBuffer[index+2] = 0;\\n    texcoordsBuffer[index+3] = 0;\\n\\n    texcoordsBuffer[index+4] = icon[1];\\n    texcoordsBuffer[index+5] = icon[2]+icon[4];\\n    texcoordsBuffer[index+6] = 0;\\n    texcoordsBuffer[index+7] = 0;\\n\\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\\n    texcoordsBuffer[index+10] = 0;\\n    texcoordsBuffer[index+11] = 0;\\n    \\n    index += 12;\\n\\n    var p1 = point[0];\\n    var p2 = point[1];\\n    var p3 = point[2];\\n\\n    //set origin buffer and apply offset\\n    for (var i = lastIndex; i < index; i+=4) {\\n        vertexBuffer[i] += offsetX;\\n        vertexBuffer[i+1] -= offsetY;\\n\\n        originBuffer[index2] = p1;\\n        originBuffer[index2 + 1] = p2;\\n        originBuffer[index2 + 2] = p3;\\n        index2 += 3;\\n    }\\n\\n    iconData.index = index;\\n    iconData.index2 = index2;\\n\\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\\n};\\n\\n\\nvar processLabel = function(point, labelData) {\\n    var vertexBuffer = labelData.vertexBuffer;\\n    var texcoordsBuffer = labelData.texcoordsBuffer;\\n    var originBuffer = labelData.originBuffer;\\n    var singleBuffer = labelData.singleBuffer;\\n    var index = labelData.index;\\n    var index2 = labelData.index2;\\n    var lastIndex = index;\\n    var text = '' + labelData.text;\\n    var fonts = labelData.fonts;\\n    var planes = {}, i, li;\\n    var glyphsRes = labelData.glyphsRes;\\n\\n    var linesGlyphsRes = [];\\n    var linesGlyphsRes2 = [];\\n\\n    //split text to lines\\n    do {\\n        var res = glyphsRes[2].indexOf(10); //search /n\\n\\n        if (res != -1) {\\n            linesGlyphsRes.push([glyphsRes[0].slice(0,res), glyphsRes[1].slice(0,res), glyphsRes[2].slice(0,res)]);\\n            glyphsRes = [glyphsRes[0].slice(res+1), glyphsRes[1].slice(res+1), glyphsRes[2].slice(res+1)];\\n        } else {\\n            linesGlyphsRes.push(glyphsRes);\\n        }\\n\\n    } while (res != -1);\\n\\n    //split lines by width\\n    for (var i = 0, li = linesGlyphsRes.length; i < li; i++) {\\n\\n        var glyphsRes = linesGlyphsRes[i];\\n\\n        // eslint-disable-next-line\\n        do {\\n            var splitIndex = getSplitIndex(null, labelData.width, labelData.size, labelData.spacing, fonts, glyphsRes);\\n            var codes = glyphsRes[2];\\n\\n            if (codes.length == splitIndex) {\\n                linesGlyphsRes2.push(glyphsRes);\\n                break;\\n            }\\n\\n            linesGlyphsRes2.push([glyphsRes[0].slice(0,splitIndex), glyphsRes[1].slice(0,splitIndex), glyphsRes[2].slice(0,splitIndex)]);\\n\\n            glyphsRes = [glyphsRes[0].slice(splitIndex+1), glyphsRes[1].slice(splitIndex+1), glyphsRes[2].slice(splitIndex+1)];\\n\\n        } while(true);\\n\\n    }\\n\\n    var x = 0, y = 0;\\n    var lineHeight = getLineHeight(labelData.size, labelData.lineHeight, fonts);\\n    var maxWidth = 0;\\n    var lineWidths = [];\\n\\n    //get max width\\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\\n        lineWidths[i] = getTextLength(null, labelData.size, labelData.spacing, fonts, linesGlyphsRes2[i]);\\n        maxWidth = Math.max(lineWidths[i], maxWidth);\\n    }\\n\\n    //generate text\\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\\n        var textWidth = lineWidths[i];\\n\\n        switch(labelData.align) {\\n        case 'left': x = 0; break;\\n        case 'right': x = maxWidth - textWidth; break;\\n        case 'center': x = (maxWidth - textWidth)*0.5; break;\\n        }\\n\\n        index = addText([x,y,0], [1,0,0], null, labelData.size, labelData.spacing, fonts, vertexBuffer, texcoordsBuffer, true, index, planes, linesGlyphsRes2[i], singleBuffer);\\n        y -= lineHeight;\\n    }\\n\\n    //get offset\\n    var originOffset = getOriginOffset(labelData.origin, maxWidth, -y);\\n    var offsetX = originOffset[0] + labelData.offset[0];\\n    var offsetY = originOffset[1] + labelData.offset[1];\\n    \\n    var p1 = point[0];\\n    var p2 = point[1];\\n    var p3 = point[2];\\n\\n    //set origin buffer and apply offset\\n    if (!singleBuffer) {\\n        for (i = lastIndex; i < index; i+=4) {\\n            vertexBuffer[i] += offsetX;\\n            vertexBuffer[i+1] -= offsetY;\\n\\n            originBuffer[index2] = p1;\\n            originBuffer[index2 + 1] = p2;\\n            originBuffer[index2 + 2] = p3;\\n            index2 += 3;\\n        }\\n    } else {\\n        for (i = lastIndex; i < index; i+=8) {\\n            singleBuffer[i] += offsetX;\\n            singleBuffer[i+1] -= offsetY;\\n            singleBuffer[i+2] += offsetX;\\n            singleBuffer[i+3] -= offsetY;\\n        }\\n\\n        labelData.pos = [p1,p2,p3];\\n        singleBuffer = new Float32Array(singleBuffer.buffer, 0, index);\\n    }\\n    \\n    var fonts = labelData.fonts;\\n    labelData.files = new Array(fonts.length);\\n\\n    for (i = 0, li= fonts.length; i < li; i++) {\\n        labelData.files[i] = [];\\n    }\\n\\n    for (var key in planes) {\\n        var fontIndex = parseInt(key);\\n        var planes2 = planes[key];\\n\\n        var files = [];\\n\\n        for (var key2 in planes2) {\\n            var plane = parseInt(key2) - (fontIndex*4000);\\n            var file = Math.round((plane - (plane % 4)) / 4);\\n            \\n            if (files.indexOf(file) == -1) {\\n                files.push(file);\\n            }\\n        }\\n\\n        labelData.files[fontIndex] = files;\\n    }\\n\\n    labelData.index = index;\\n    labelData.index2 = index2;\\n\\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + maxWidth) * 0.5 + 1, (offsetY + Math.abs(y)) *0.5];\\n};\\n\\nvar processPointArrayGeometry = function(pointArray) {\\n    var i, li, dpoints = false;\\n\\n    if (pointArray['points'] || pointArray['d-points']) {\\n        points = (pointArray['points'] || pointArray['d-points']);\\n        dpoints = (pointArray['d-points']) ? true : false;\\n\\n        if (!(Array.isArray(points) && points.length > 0)) {\\n            return;\\n        }\\n    }\\n\\n    var index = 0;\\n    var forceScale = globals.forceScale;\\n\\n    var geometryBuffer = new Float64Array(points.length);\\n\\n    var p = points[0], pp;\\n    var p1 = [p[0], p[1], p[2]], p2;\\n\\n    //add ponints\\n    for (i = 0, li = points.length; i < li; i++) {\\n\\n        if (forceScale != null) {\\n            pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n        }\\n\\n        geometryBuffer[index] = pp[0];\\n        geometryBuffer[index+1] = pp[1];\\n        geometryBuffer[index+2] = pp[2];\\n        index += 3;\\n\\n        if (i >= (li - 1)) {\\n            break;\\n        }\\n\\n        if (dpoints) {\\n            p2 = points[i+1];\\n            p1 = [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]];\\n        } else {\\n            p1 = points[i+1];\\n        }\\n    }\\n\\n    globals.signatureCounter++;\\n    postGroupMessageFast(5, 5, {\\n        'id':pointArray['id'] }, [geometryBuffer, indicesBuffer], (\\\"\\\"+globals.signatureCounter));\\n};\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n/* 6 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_style_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__worker_message_js__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__ = __webpack_require__(5);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return processPolygonPass; });\\n\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"a\\\" /* globals */];\\nvar getLayerPropertyValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\\\"c\\\" /* getLayerPropertyValue */];\\nvar postGroupMessageFast = __WEBPACK_IMPORTED_MODULE_2__worker_message_js__[\\\"a\\\" /* postGroupMessageFast */];\\nvar processLineStringPass = __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__[\\\"a\\\" /* processLineStringPass */];\\nvar processPointArrayPass = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\\\"a\\\" /* processPointArrayPass */];\\n\\nvar processPolygonPass = function(polygon, lod, style, featureIndex, zIndex, eventInfo) {\\n    var vertices = polygon['vertices'] || [];\\n    if (vertices.length == 0) {\\n        return;\\n    }\\n    \\n    // borders as points\\n    if (getLayerPropertyValue(style, 'point', polygon, lod) ||\\n        getLayerPropertyValue(style, 'label', polygon, lod)) {\\n        processPolygonLines(polygon, vertices, lod, style, zIndex, eventInfo, false);\\n    }\\n    \\n    // borders as lines\\n    if (getLayerPropertyValue(style, 'line', polygon, lod) ||\\n        getLayerPropertyValue(style, 'line-label', polygon, lod)) {\\n        processPolygonLines(polygon, vertices, lod, style, zIndex, eventInfo, true);\\n    }\\n    \\n    var spolygon = getLayerPropertyValue(style, 'polygon', polygon, lod);\\n    \\n    if (!spolygon) {\\n        return;\\n    }\\n    \\n    var surface = polygon['surface'] || [];\\n    if (surface.length == 0) {\\n        return;\\n    }\\n    \\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', polygon, lod);\\n    var clickEvent = getLayerPropertyValue(style, 'click-event', polygon, lod);\\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', polygon, lod);\\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', polygon, lod);\\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', polygon, lod);\\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', polygon, lod);\\n\\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', polygon, lod);\\n    \\n    var polygonColor = getLayerPropertyValue(style, 'polygon-color', polygon, lod);\\n    \\n    var center = [0,0,0];\\n   \\n    // allocate vertex buffer\\n    var trisCount = surface.length / 3;\\n    var vertexCount = trisCount * 3;\\n    var vertexBuffer = new Array (vertexCount * 3);\\n    \\n    var surfaceI = 0;\\n    var index = 0;\\n    var p1;\\n    var offs;\\n\\n    var tileX = globals.tileX;\\n    var tileY = globals.tileY;\\n    var forceOrigin = globals.forceOrigin;\\n    var forceScale = globals.forceScale;    \\n    \\n    //console.log(\\\"vertexCount = \\\" + vertexCount);\\n    //add tris\\n    for (var i = 0; i < vertexCount; i++) {\\n        offs = 3 * surface[surfaceI++];\\n        p1 = [vertices[offs++], vertices[offs++], vertices[offs]];\\n        \\n        if (forceOrigin) {\\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\\n        }\\n\\n        if (forceScale != null) {\\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\\n        }\\n        \\n        center[0] += p1[0];\\n        center[1] += p1[1];\\n        center[2] += p1[2];\\n\\n        //add vertex\\n        vertexBuffer[index++] = p1[0];\\n        vertexBuffer[index++] = p1[1];\\n        vertexBuffer[index++] = p1[2];\\n    }\\n    \\n    //console.log( \\\"vertexBuffer: \\\" + vertexBuffer );\\n    \\n    if (vertexCount > 0) {\\n        var k = 1.0 / vertexCount;\\n        center[0] *= k;\\n        center[1] *= k;\\n        center[2] *= k;\\n    }\\n\\n    center[0] += globals.groupOrigin[0];\\n    center[1] += globals.groupOrigin[1];\\n    center[2] += globals.groupOrigin[2];\\n\\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\\n    \\n    postGroupMessageFast(5, 6, {\\n        'color':polygonColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit,\\n        'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\\n        'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\\n        'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\\n        'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, texcoordsBuffer], signature);\\n};\\n\\nvar createEmptyFeatureFromPolygon = function(polygon) {\\n    var feature = {};\\n    for(var key in polygon) {\\n        if(key != 'surface' && key != 'vertices' && key != 'borders') {\\n            feature[key] = polygon[key];\\n        }\\n    }\\n    return feature;\\n};\\n\\nvar processPolygonLines = function(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, processLines) {\\n    var borders = polygon['borders'] || [];\\n    if (borders.length == 0) {\\n        return;\\n    }\\n    var feature = createEmptyFeatureFromPolygon(polygon);\\n    var bordersCount = borders.length;\\n    for (var j = 0; j < bordersCount; j++) {\\n        var border = borders[j], offset;\\n        var pointsCount = border.length;\\n        var pointsCount2 = 0;\\n        if (pointsCount > 0) {\\n            var points, i;\\n            if (processLines) {\\n                points = new Array(pointsCount + 1);\\n            } else {\\n                points = new Array(pointsCount);\\n            }\\n            for (i = 0; i < pointsCount; i++) {\\n                if (border[i] >= 0) {\\n                    offset = 3 * border[i];\\n                    pointsCount2++; // count vertices with positive index\\n                } else {\\n                    offset = 3 * (-border[i]);\\n                }\\n                points[i] = [vertices[offset], vertices[offset+1], vertices[offset+2]];\\n                if (processLines && i == 0) {\\n                    points[pointsCount] = points[0];\\n                }\\n            }\\n\\n            var points2 = new Array(pointsCount2);\\n            var i2 = 0;\\n            //debugger\\n\\n            //create array of points only for vertices with positive value\\n            for (i = 0; i < pointsCount; i++) {\\n                if (border[i] >= 0) {\\n                    offset = 3 * border[i];\\n                    points2[i2] = [vertices[offset], vertices[offset+1], vertices[offset+2]];\\n                    i2++;\\n                }\\n            }\\n\\n            if(processLines) {\\n                feature['lines'] = [points];\\n                processLineStringPass(feature, lod, style, featureIndex, zIndex, eventInfo);\\n            } else {\\n                feature['points'] = points2;\\n                processPointArrayPass(feature, lod, style, featureIndex, zIndex, eventInfo);\\n            }\\n        }\\n    }\\n};\\n \\n\\n\\n\\n/***/ }),\\n/* 7 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return bidi; });\\n/* Copyright 2012 Mozilla Foundation\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// Character types for symbols from 0000 to 00FF.\\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\\nvar baseTypes = [\\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'S', 'B', 'S',\\n  'WS', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\\n  'BN', 'BN', 'BN', 'BN', 'B', 'B', 'B', 'S', 'WS', 'ON', 'ON', 'ET',\\n  'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'ON', 'ES', 'CS', 'ES', 'CS', 'CS',\\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'CS', 'ON',\\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON',\\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'BN', 'BN', 'BN', 'BN', 'BN',\\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'CS', 'ON', 'ET',\\n  'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'L', 'ON', 'ON', 'BN', 'ON',\\n  'ON', 'ET', 'ET', 'EN', 'EN', 'ON', 'L', 'ON', 'ON', 'ON', 'EN', 'L',\\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\\n  'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'\\n];\\n\\n// Character types for symbols from 0600 to 06FF.\\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\\n// Note that 061D does not exist in the Unicode standard (see\\n// http://unicode.org/charts/PDF/U0600.pdf), so we replace it with an\\n// empty string and issue a warning if we encounter this character. The\\n// empty string is required to properly index the items after it.\\nvar arabicTypes = [\\n  'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ON', 'ON', 'AL', 'ET', 'ET', 'AL',\\n  'CS', 'AL', 'ON', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\\n  'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', '', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\\n  'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\\n  'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN',\\n  'AN', 'AN', 'AN', 'ET', 'AN', 'AN', 'AL', 'AL', 'AL', 'NSM', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\\n  'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN',\\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'NSM', 'NSM',\\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'EN', 'EN', 'EN', 'EN',\\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL'\\n];\\n\\nfunction isOdd(i) {\\n  return (i & 1) !== 0;\\n}\\n\\nfunction isEven(i) {\\n  return (i & 1) === 0;\\n}\\n\\nfunction findUnequal(arr, start, value) {\\n  for (var j = start, jj = arr.length; j < jj; ++j) {\\n    if (arr[j] !== value) {\\n      return j;\\n    }\\n  }\\n  return j;\\n}\\n\\nfunction setValues(arr, start, end, value) {\\n  for (var j = start; j < end; ++j) {\\n    arr[j] = value;\\n  }\\n}\\n\\nfunction reverseValues(arr, arr2, start, end) {\\n  for (var i = start, j = end - 1; i < j; ++i, --j) {\\n    var temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n    temp = arr2[i];\\n    arr2[i] = arr2[j];\\n    arr2[j] = temp;\\n  }\\n}\\n\\nfunction createBidiText(str, isLTR, vertical) {\\n  return {\\n    str: str,\\n    indices: indices,\\n    types : types,\\n    dir: (vertical ? 'ttb' : (isLTR ? 'ltr' : 'rtl')),\\n  };\\n}\\n\\n// These are used in bidi(), which is called frequently. We re-use them on\\n// each call to avoid unnecessary allocations.\\nvar chars = [];\\nvar types = [];\\nvar indices = [];\\n\\nfunction bidi(str, startLevel, vertical) {\\n  var isLTR = true;\\n  var strLength = str.length;\\n  if (strLength === 0 || vertical) {\\n    return createBidiText(str, isLTR, vertical);\\n  }\\n\\n  // Get types and fill arrays\\n  chars.length = strLength;\\n  types.length = strLength;\\n  var numBidi = 0;\\n\\n  var i, ii;\\n  for (i = 0; i < strLength; ++i) {\\n    chars[i] = str.charAt(i);\\n    indices[i] = i;\\n\\n    var charCode = str.charCodeAt(i);\\n    var charType = 'L';\\n    if (charCode <= 0x00ff) {\\n      charType = baseTypes[charCode];\\n    } else if (0x0590 <= charCode && charCode <= 0x05f4) {\\n      charType = 'R';\\n    } else if (0x0600 <= charCode && charCode <= 0x06ff) {\\n      charType = arabicTypes[charCode & 0xff];\\n      if (!charType) {\\n        //console.log('Bidi: invalid Unicode character ' + charCode.toString(16));\\n      }\\n    } else if (0x0700 <= charCode && charCode <= 0x08AC) {\\n      charType = 'AL';\\n    }\\n    if (charType === 'R' || charType === 'AL' || charType === 'AN') {\\n      numBidi++;\\n    }\\n    types[i] = charType;\\n  }\\n\\n  // Detect the bidi method\\n  // - If there are no rtl characters then no bidi needed\\n  // - If less than 30% chars are rtl then string is primarily ltr\\n  // - If more than 30% chars are rtl then string is primarily rtl\\n  if (numBidi === 0) {\\n    isLTR = true;\\n    return createBidiText(str, isLTR);\\n  }\\n\\n  if (startLevel === -1) {\\n    if ((numBidi / strLength) < 0.3) {\\n      isLTR = true;\\n      startLevel = 0;\\n    } else {\\n      isLTR = false;\\n      startLevel = 1;\\n    }\\n  }\\n\\n  var levels = [];\\n  for (i = 0; i < strLength; ++i) {\\n    levels[i] = startLevel;\\n  }\\n\\n  /*\\n   X1-X10: skip most of this, since we are NOT doing the embeddings.\\n   */\\n  var e = (isOdd(startLevel) ? 'R' : 'L');\\n  var sor = e;\\n  var eor = sor;\\n\\n  /*\\n   W1. Examine each non-spacing mark (NSM) in the level run, and change the\\n   type of the NSM to the type of the previous character. If the NSM is at the\\n   start of the level run, it will get the type of sor.\\n   */\\n  var lastType = sor;\\n  for (i = 0; i < strLength; ++i) {\\n    if (types[i] === 'NSM') {\\n      types[i] = lastType;\\n    } else {\\n      lastType = types[i];\\n    }\\n  }\\n\\n  /*\\n   W2. Search backwards from each instance of a European number until the\\n   first strong type (R, L, AL, or sor) is found.  If an AL is found, change\\n   the type of the European number to Arabic number.\\n   */\\n  lastType = sor;\\n  var t;\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (t === 'EN') {\\n      types[i] = (lastType === 'AL') ? 'AN' : 'EN';\\n    } else if (t === 'R' || t === 'L' || t === 'AL') {\\n      lastType = t;\\n    }\\n  }\\n\\n  /*\\n   W3. Change all ALs to R.\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (t === 'AL') {\\n      types[i] = 'R';\\n    }\\n  }\\n\\n  /*\\n   W4. A single European separator between two European numbers changes to a\\n   European number. A single common separator between two numbers of the same\\n   type changes to that type:\\n   */\\n  for (i = 1; i < strLength - 1; ++i) {\\n    if (types[i] === 'ES' && types[i - 1] === 'EN' && types[i + 1] === 'EN') {\\n      types[i] = 'EN';\\n    }\\n    if (types[i] === 'CS' &&\\n        (types[i - 1] === 'EN' || types[i - 1] === 'AN') &&\\n        types[i + 1] === types[i - 1]) {\\n      types[i] = types[i - 1];\\n    }\\n  }\\n\\n  /*\\n   W5. A sequence of European terminators adjacent to European numbers changes\\n   to all European numbers:\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    if (types[i] === 'EN') {\\n      // do before\\n      var j;\\n      for (j = i - 1; j >= 0; --j) {\\n        if (types[j] !== 'ET') {\\n          break;\\n        }\\n        types[j] = 'EN';\\n      }\\n      // do after\\n      for (j = i + 1; j < strLength; ++j) {\\n        if (types[j] !== 'ET') {\\n          break;\\n        }\\n        types[j] = 'EN';\\n      }\\n    }\\n  }\\n\\n  /*\\n   W6. Otherwise, separators and terminators change to Other Neutral:\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (t === 'WS' || t === 'ES' || t === 'ET' || t === 'CS') {\\n      types[i] = 'ON';\\n    }\\n  }\\n\\n  /*\\n   W7. Search backwards from each instance of a European number until the\\n   first strong type (R, L, or sor) is found. If an L is found,  then change\\n   the type of the European number to L.\\n   */\\n  lastType = sor;\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (t === 'EN') {\\n      types[i] = ((lastType === 'L') ? 'L' : 'EN');\\n    } else if (t === 'R' || t === 'L') {\\n      lastType = t;\\n    }\\n  }\\n\\n  /*\\n   N1. A sequence of neutrals takes the direction of the surrounding strong\\n   text if the text on both sides has the same direction. European and Arabic\\n   numbers are treated as though they were R. Start-of-level-run (sor) and\\n   end-of-level-run (eor) are used at level run boundaries.\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    if (types[i] === 'ON') {\\n      var end = findUnequal(types, i + 1, 'ON');\\n      var before = sor;\\n      if (i > 0) {\\n        before = types[i - 1];\\n      }\\n\\n      var after = eor;\\n      if (end + 1 < strLength) {\\n        after = types[end + 1];\\n      }\\n      if (before !== 'L') {\\n        before = 'R';\\n      }\\n      if (after !== 'L') {\\n        after = 'R';\\n      }\\n      if (before === after) {\\n        setValues(types, i, end, before);\\n      }\\n      i = end - 1; // reset to end (-1 so next iteration is ok)\\n    }\\n  }\\n\\n  /*\\n   N2. Any remaining neutrals take the embedding direction.\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    if (types[i] === 'ON') {\\n      types[i] = e;\\n    }\\n  }\\n\\n  /*\\n   I1. For all characters with an even (left-to-right) embedding direction,\\n   those of type R go up one level and those of type AN or EN go up two\\n   levels.\\n   I2. For all characters with an odd (right-to-left) embedding direction,\\n   those of type L, EN or AN go up one level.\\n   */\\n  for (i = 0; i < strLength; ++i) {\\n    t = types[i];\\n    if (isEven(levels[i])) {\\n      if (t === 'R') {\\n        levels[i] += 1;\\n      } else if (t === 'AN' || t === 'EN') {\\n        levels[i] += 2;\\n      }\\n    } else { // isOdd\\n      if (t === 'L' || t === 'AN' || t === 'EN') {\\n        levels[i] += 1;\\n      }\\n    }\\n  }\\n\\n  /*\\n   L1. On each line, reset the embedding level of the following characters to\\n   the paragraph embedding level:\\n\\n   segment separators,\\n   paragraph separators,\\n   any sequence of whitespace characters preceding a segment separator or\\n   paragraph separator, and any sequence of white space characters at the end\\n   of the line.\\n   */\\n\\n  // don't bother as text is only single line\\n\\n  /*\\n   L2. From the highest level found in the text to the lowest odd level on\\n   each line, reverse any contiguous sequence of characters that are at that\\n   level or higher.\\n   */\\n\\n  // find highest level & lowest odd level\\n  var highestLevel = -1;\\n  var lowestOddLevel = 99;\\n  var level;\\n  for (i = 0, ii = levels.length; i < ii; ++i) {\\n    level = levels[i];\\n    if (highestLevel < level) {\\n      highestLevel = level;\\n    }\\n    if (lowestOddLevel > level && isOdd(level)) {\\n      lowestOddLevel = level;\\n    }\\n  }\\n\\n  // now reverse between those limits\\n  for (level = highestLevel; level >= lowestOddLevel; --level) {\\n    // find segments to reverse\\n    var start = -1;\\n    for (i = 0, ii = levels.length; i < ii; ++i) {\\n      if (levels[i] < level) {\\n        if (start >= 0) {\\n          reverseValues(chars, indices, start, i);\\n          start = -1;\\n        }\\n      } else if (start < 0) {\\n        start = i;\\n      }\\n    }\\n    if (start >= 0) {\\n      reverseValues(chars, indices, start, levels.length);\\n    }\\n  }\\n\\n  /*\\n   L3. Combining marks applied to a right-to-left base character will at this\\n   point precede their base character. If the rendering engine expects them to\\n   follow the base characters in the final display process, then the ordering\\n   of the marks and the base character must be reversed.\\n   */\\n\\n  // don't bother for now\\n\\n  /*\\n   L4. A character that possesses the mirrored property as specified by\\n   Section 4.7, Mirrored, must be depicted by a mirrored glyph if the resolved\\n   directionality of that character is R.\\n   */\\n\\n  // don't mirror as characters are already mirrored in the pdf\\n\\n  // Finally, return string\\n  for (i = 0, ii = chars.length; i < ii; ++i) {\\n    var ch = chars[i];\\n    if (ch === '<' || ch === '>') {\\n      chars[i] = '';\\n    }\\n  }\\n  return createBidiText(chars.join(''), isLTR);\\n}\\n\\n\\n\\n\\n\\n/***/ }),\\n/* 8 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_bidi_js__ = __webpack_require__(7);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return Typr; });\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar bidi = __WEBPACK_IMPORTED_MODULE_0__worker_bidi_js__[\\\"a\\\" /* bidi */];\\n\\n\\nvar Typr = {};\\n\\nTypr.parse = function(buff) {\\n    var bin = Typr._bin;\\n    var data = new Uint8Array(buff);\\n    var offset = 0;\\n    \\n    var sfnt_version = bin.readFixed(data, offset);\\n    offset += 4;\\n    var numTables = bin.readUshort(data, offset);\\n    offset += 2;\\n    var searchRange = bin.readUshort(data, offset);\\n    offset += 2;\\n    var entrySelector = bin.readUshort(data, offset);\\n    offset += 2;\\n    var rangeShift = bin.readUshort(data, offset);\\n    offset += 2;\\n    \\n    var tags = [\\n        \\\"cmap\\\",\\n        \\\"head\\\",\\n        \\\"hhea\\\",\\n        \\\"maxp\\\",\\n        \\\"hmtx\\\",\\n        //\\\"name\\\",\\n        //\\\"OS/2\\\",\\n        //\\\"post\\\",\\n        \\n        //\\\"cvt\\\",\\n        //\\\"fpgm\\\",\\n        //\\\"loca\\\",\\n        //\\\"glyf\\\",\\n        \\\"kern\\\",\\n        \\n        //\\\"prep\\\"\\n        //\\\"gasp\\\"\\n        \\n        \\\"GPOS\\\",\\n        \\\"GSUB\\\"\\n        //\\\"VORG\\\",\\n        ];\\n    \\n    var obj = {_data:data};\\n    //console.log(sfnt_version, numTables, searchRange, entrySelector, rangeShift);\\n    \\n    var tabs = {};\\n    var tablesOffset = 0;\\n    \\n    for(var i=0; i<numTables; i++) {\\n        var tag = bin.readASCII(data, offset, 4);   offset += 4;\\n        var checkSum = bin.readUint(data, offset);  offset += 4;\\n        var toffset = bin.readUint(data, offset);   offset += 4;\\n        var length = bin.readUint(data, offset);    offset += 4;\\n        tabs[tag] = {offset:toffset, length:length};\\n        tablesOffset = toffset + length;\\n        //if(tags.indexOf(tag)==-1) console.log(\\\"unknown tag\\\", tag);\\n    }\\n    \\n    for(var i=0; i< tags.length; i++) {\\n        var t = tags[i];\\n        //console.log(t);\\n        //if(tabs[t]) console.log(t, tabs[t].offset, tabs[t].length);\\n        if(tabs[t]) obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj);\\n    }\\n\\n    obj._tabs = tabs;\\n\\n    Typr._processGlyphs(data, tablesOffset, tabs, obj);\\n\\n    //get tables\\n    var gsub = obj['GSUB'];\\n    if (gsub) {\\n        var llist = gsub.lookupList, flist = gsub.featureList;\\n\\n        obj.gsubIsolTable = [];\\n        obj.gsubInitTable = [];\\n        obj.gsubFinaTable = [];\\n        obj.gsubMediTable = [];\\n\\n        obj.gsubRligLigaTable = [];\\n\\n        for(var fi = 0; fi < flist.length; fi++) {\\n            var tag = flist[fi].tag;\\n\\n            switch (tag) {\\n                case 'isol':\\n                case 'init':\\n                case 'fina':\\n                case 'medi':\\n\\n                    for(var ti = 0; ti < flist[fi].tab.length; ti++) {\\n                        var tab = llist[flist[fi].tab[ti]];\\n                        \\n                        if(tab.ltype == 1) {\\n                            switch (tag) {\\n                                case 'isol': obj.gsubIsolTable.push(tab.tabs); break;\\n                                case 'init': obj.gsubInitTable.push(tab.tabs); break;\\n                                case 'fina': obj.gsubFinaTable.push(tab.tabs); break;\\n                                case 'medi': obj.gsubMediTable.push(tab.tabs); break;\\n                            }\\n                        }\\n                    }\\n\\n                    break;\\n\\n                case 'rlig':\\n                case 'liga':\\n\\n                    for(var ti = 0; ti < flist[fi].tab.length; ti++) {\\n                        var tab = llist[flist[fi].tab[ti]];\\n                        \\n                        if(tab.ltype == 4) {\\n                            obj.gsubRligLigaTable.push(tab.tabs);\\n                        }\\n                    }\\n\\n                    break;\\n            }\\n\\n        }\\n    }\\n   \\n    return obj;\\n}\\n\\nTypr._processGlyphs = function(data, index, tabs, obj) {\\n    var version = data[index]; index += 1;\\n    var textureLX = (data[index] << 8) | (data[index+1]); index += 2;\\n    var textureLY = (data[index] << 8) | (data[index+1]); index += 2;\\n    var size = data[index]; index += 1;\\n    var flags = data[index]; index += 1;\\n\\n    obj.version = version;\\n    obj.textureLX = textureLX;\\n    obj.textureLY = textureLY;\\n    obj.size = size;\\n    obj.cly = size * 1.5;\\n    obj.flags = flags;\\n\\n    var glyphs = new Array(obj.maxp.numGlyphs);\\n    var fx = 1.0 / textureLX, fy = 1.0 / textureLY;\\n    var step = (textureLX > 256) ? 7 : 6;\\n\\n    var filesIndicesIndex = index + obj.maxp.numGlyphs * step;\\n    var filesIndicesCount = (data[filesIndicesIndex] << 8) | data[filesIndicesIndex+1];\\n    var files = new Array(filesIndicesCount);\\n\\n    filesIndicesIndex += 2;\\n\\n    for (var i = 0, li = filesIndicesCount; i < li; i++) {\\n        files[i] = (data[filesIndicesIndex+i*2] << 8) | data[filesIndicesIndex+i*2+1];\\n    }\\n\\n    var fileIndex = 0;\\n\\n    for (i = 0, li = obj.maxp.numGlyphs; i < li; i++) {\\n        if (i == files[fileIndex]) {\\n            fileIndex++;\\n        }\\n\\n        glyphs[i] = Typr._processGlyph(data, index, fx, fy, textureLX, obj, i, fileIndex);\\n        index += step;\\n    }\\n\\n    obj.glyphs = glyphs;\\n}\\n\\nTypr._processGlyph = function(data, index, fx, fy, textureLX, font, glyphIndex, fileIndex) {\\n    var value = (data[index] << 24) | (data[index+1] << 16) | (data[index+2] << 8) | (data[index+3]);\\n\\n    // w 6bit | h 6bit | sx sign 1bit | abs sx 6bit | sy sign 1bit | abs sy 6bit | plane 2bit \\n    var w = (value >> 22) & 63;\\n    var h = (value >> 16) & 63;\\n    var sx = ((value >> 9) & 63) * (((value >> 15) & 1) ? -1 : 1);\\n    var sy = -((value >> 2) & 63) * (((value >> 8) & 1) ? -1 : 1);\\n    var plane = (value & 3) + (fileIndex * 4);\\n\\n    if (textureLX > 256) {\\n        value = (data[index+4] << 16) | (data[index+5] << 8) | (data[index+6]);\\n    } else {\\n        value = (data[index+4] << 8) | (data[index+5]);\\n    }    \\n\\n    var scale = ((font.size/0.75) / font.head.unitsPerEm) * 0.75;\\n    var x, y, step = font.hmtx.aWidth[glyphIndex] * scale;\\n\\n    //store glyph position\\n    switch (textureLX) {\\n        case 2048: // x 11bit | y 11bit\\n            x = ((value >> 11) & 2047), y = (value & 2047); break;\\n                   \\n        case 1024: // x 10bit | y 10bit\\n            x = ((value >> 10) & 1023), y = (value & 1023); break;\\n\\n        case 512:  // x 9bit | y 9bit\\n            x = ((value >> 9) & 511), y = (value & 511); break;\\n\\n        default:   // x 8bit | y 8bit\\n            x = ((value >> 8) & 255), y = (value & 255); break;\\n    }\\n\\n    return {\\n        u1 : (x) * fx,\\n        v1 : (y * fy) + plane,\\n        u2 : (x + w) * fx,\\n        v2 : ((y + h) * fy) + plane,\\n        lx : w,\\n        ly : h,\\n        sx : sx, \\n        sy : sy, \\n        step : (step), \\n        plane: plane\\n    };\\n}\\n\\nTypr._tabOffset = function(data, tab) {\\n    var bin = Typr._bin;\\n    var numTables = bin.readUshort(data, 4);\\n    var offset = 12;\\n    for(var i=0; i<numTables; i++) {\\n        var tag = bin.readASCII(data, offset, 4);   offset += 4;\\n        var checkSum = bin.readUint(data, offset);  offset += 4;\\n        var toffset = bin.readUint(data, offset);   offset += 4;\\n        var length = bin.readUint(data, offset);    offset += 4;\\n        if(tag==tab) return toffset;\\n    }\\n    return 0;\\n}\\n\\n\\n\\n\\nTypr._bin = {\\n    readFixed : function(data, o) {\\n        return ((data[o]<<8) | data[o+1]) +  (((data[o+2]<<8)|data[o+3])/(256*256+4));\\n    },\\n\\n    readF2dot14 : function(data, o) {\\n        var num = Typr._bin.readShort(data, o);\\n        return num / 16384;\\n        \\n        var intg = (num >> 14), frac = ((num & 0x3fff)/(0x3fff+1));\\n        return (intg>0) ? (intg+frac) : (intg-frac);\\n    },\\n\\n    readInt : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var a = Typr._bin.t.uint8;\\n        a[0] = buff[p+3];\\n        a[1] = buff[p+2];\\n        a[2] = buff[p+1];\\n        a[3] = buff[p];\\n        return Typr._bin.t.int32[0];\\n    },\\n    \\n    readInt8 : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var a = Typr._bin.t.uint8;\\n        a[0] = buff[p];\\n        return Typr._bin.t.int8[0];\\n    },\\n\\n    readShort : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var a = Typr._bin.t.uint8;\\n        a[1] = buff[p]; a[0] = buff[p+1];\\n        return Typr._bin.t.int16[0];\\n    },\\n\\n    readUshort : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        return (buff[p]<<8) | buff[p+1];\\n    },\\n\\n    readUshorts : function(buff, p, len) {\\n        var arr = [];\\n        for(var i=0; i<len; i++) arr.push(Typr._bin.readUshort(buff, p+i*2));\\n        return arr;\\n    },\\n\\n    readUint : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var a = Typr._bin.t.uint8;\\n        a[3] = buff[p];  a[2] = buff[p+1];  a[1] = buff[p+2];  a[0] = buff[p+3];\\n        return Typr._bin.t.uint32[0];\\n    },\\n\\n    readUint64 : function(buff, p) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        return (Typr._bin.readUint(buff, p)*(0xffffffff+1)) + Typr._bin.readUint(buff, p+4);\\n    },\\n\\n    readASCII : function(buff, p, l) {   // l : length in Characters (not Bytes)\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var s = \\\"\\\";\\n        for(var i = 0; i < l; i++) s += String.fromCharCode(buff[p+i]);\\n        return s;\\n    },\\n\\n    readUnicode : function(buff, p, l) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var s = \\\"\\\";\\n        for(var i = 0; i < l; i++)  \\n        {\\n            var c = (buff[p++]<<8) | buff[p++];\\n            s += String.fromCharCode(c);\\n        }\\n        return s;\\n    },\\n\\n    readBytes : function(buff, p, l) {\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var arr = [];\\n        for(var i=0; i<l; i++) arr.push(buff[p+i]);\\n        return arr;\\n    },\\n\\n    readASCIIArray : function(buff, p, l) {  // l : length in Characters (not Bytes)\\n        //if(p>=buff.length) throw \\\"error\\\";\\n        var s = [];\\n        for(var i = 0; i < l; i++)  \\n            s.push(String.fromCharCode(buff[p+i]));\\n        return s;\\n    }\\n};\\n\\nTypr._bin.t = {\\n    buff: new ArrayBuffer(8),\\n};\\nTypr._bin.t.int8   = new Int8Array  (Typr._bin.t.buff);\\nTypr._bin.t.uint8  = new Uint8Array (Typr._bin.t.buff);\\nTypr._bin.t.int16  = new Int16Array (Typr._bin.t.buff);\\nTypr._bin.t.uint16 = new Uint16Array(Typr._bin.t.buff);\\nTypr._bin.t.int32  = new Int32Array (Typr._bin.t.buff);\\nTypr._bin.t.uint32 = new Uint32Array(Typr._bin.t.buff);\\n\\n\\n\\n\\n\\n// OpenType Layout Common Table Formats\\n\\nTypr._lctf = {};\\n\\nTypr._lctf.parse = function(data, offset, length, font, subt) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    var offset0 = offset;\\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\\n    \\n    var offScriptList  = bin.readUshort(data, offset);  offset += 2;\\n    var offFeatureList = bin.readUshort(data, offset);  offset += 2;\\n    var offLookupList  = bin.readUshort(data, offset);  offset += 2;\\n    \\n    \\n    obj.scriptList  = Typr._lctf.readScriptList (data, offset0 + offScriptList);\\n    obj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);\\n    obj.lookupList  = Typr._lctf.readLookupList (data, offset0 + offLookupList, subt);\\n    \\n    return obj;\\n}\\n\\nTypr._lctf.readLookupList = function(data, offset, subt) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = [];\\n    var count = bin.readUshort(data, offset);  offset+=2;\\n\\n    for(var i=0; i<count; i++) \\n    {\\n        var noff = bin.readUshort(data, offset);  offset+=2;\\n        var lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);\\n        obj.push(lut);\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readLookupTable = function(data, offset, subt) {\\n    //console.log(\\\"Parsing lookup table\\\", offset);\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {tabs:[]};\\n    \\n    obj.ltype = bin.readUshort(data, offset);  offset+=2;\\n    obj.flag  = bin.readUshort(data, offset);  offset+=2;\\n    var cnt   = bin.readUshort(data, offset);  offset+=2;\\n    \\n    for(var i=0; i<cnt; i++) {\\n        var noff = bin.readUshort(data, offset);  offset+=2;\\n        var tab = subt(data, obj.ltype, offset0 + noff);\\n        //console.log(obj.type, tab);\\n        obj.tabs.push(tab);\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.numOfOnes = function(n) {\\n    var num = 0;\\n    for(var i=0; i<32; i++) if(((n>>>i)&1) != 0) num++;\\n    return num;\\n}\\n\\nTypr._lctf.readClassDef = function(data, offset) {\\n    var bin = Typr._bin;\\n    var obj = { start:[], end:[], class:[] };\\n    var format = bin.readUshort(data, offset);  offset+=2;\\n\\n    if(format==1) {\\n        var startGlyph  = bin.readUshort(data, offset);  offset+=2;\\n        var glyphCount  = bin.readUshort(data, offset);  offset+=2;\\n        for(var i=0; i<glyphCount; i++) {\\n            obj.start.push(startGlyph+i);\\n            obj.end  .push(startGlyph+i);\\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\\n        }\\n    }\\n\\n    if(format==2) {\\n        var count = bin.readUshort(data, offset);  offset+=2;\\n        for(var i=0; i<count; i++) {\\n            obj.start.push(bin.readUshort(data, offset));  offset+=2;\\n            obj.end  .push(bin.readUshort(data, offset));  offset+=2;\\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\\n        }\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readValueRecord = function(data, offset, valFmt) {\\n    var bin = Typr._bin;\\n    var arr = [];\\n    arr.push( (valFmt&1) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&1) ? 2 : 0;\\n    arr.push( (valFmt&2) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&2) ? 2 : 0;\\n    arr.push( (valFmt&4) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&4) ? 2 : 0;\\n    arr.push( (valFmt&8) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&8) ? 2 : 0;\\n    return arr;\\n}\\n\\nTypr._lctf.readCoverage = function(data, offset) {\\n    var bin = Typr._bin;\\n    var cvg = {};\\n    cvg.fmt   = bin.readUshort(data, offset);  offset+=2;\\n    var count = bin.readUshort(data, offset);  offset+=2;\\n    //console.log(\\\"parsing coverage\\\", offset-4, format, count);\\n    if(cvg.fmt==1) cvg.tab = bin.readUshorts(data, offset, count); \\n    if(cvg.fmt==2) cvg.tab = bin.readUshorts(data, offset, count*3);\\n\\n    //get min,max\\n\\n    var min = Number.POSITIVE_INFINITY, max = 0;\\n    var tab = cvg.tab;\\n\\n    if(cvg.fmt==1) {\\n\\n        for(var i=0; i<tab.length; i++) {\\n            var v = tab[i];\\n            if (v > max) max = v;\\n            if (v < min) min = v;\\n        }\\n    }\\n\\n    if(cvg.fmt==2) {\\n        for(var i=0; i<tab.length; i+=3) {\\n            var start = tab[i], end = tab[i+1];\\n            if (start > max) max = start;\\n            if (start < min) min = start;\\n            if (end > max) max = end;\\n            if (end < min) min = end;\\n        }\\n    }\\n\\n    cvg.min = min;\\n    cvg.max = max;\\n\\n    return cvg;\\n}\\n\\nTypr._lctf.coverageIndex = function(cvg, val) {\\n    if (val < cvg.min || val > cvg.max) {\\n        return -1;\\n    }\\n\\n    var tab = cvg.tab;\\n    if(cvg.fmt==1) return tab.indexOf(val);\\n    \\n    for(var i=0; i<tab.length; i+=3) {\\n        var start = tab[i], end = tab[i+1], index = tab[i+2];\\n        if(start<=val && val<=end) return index + (val-start);\\n    }\\n    return -1;\\n}\\n\\nTypr._lctf.readFeatureList = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = [];\\n    \\n    var count = bin.readUshort(data, offset);  offset+=2;\\n    \\n    for(var i=0; i<count; i++) {\\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\\n        var noff = bin.readUshort(data, offset);  offset+=2;\\n        obj.push({tag: tag.trim(), tab:Typr._lctf.readFeatureTable(data, offset0 + noff)});\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readFeatureTable = function(data, offset) {\\n    var bin = Typr._bin;\\n    \\n    var featureParams = bin.readUshort(data, offset);  offset+=2;   // = 0\\n    var lookupCount = bin.readUshort(data, offset);  offset+=2;\\n    \\n    var indices = [];\\n    for(var i=0; i<lookupCount; i++) indices.push(bin.readUshort(data, offset+2*i));\\n    return indices;\\n}\\n\\n\\nTypr._lctf.readScriptList = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    var count = bin.readUshort(data, offset);  offset+=2;\\n    \\n    for(var i=0; i<count; i++) {\\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\\n        var noff = bin.readUshort(data, offset);  offset+=2;\\n        obj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readScriptTable = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    var defLangSysOff = bin.readUshort(data, offset);  offset+=2;\\n    obj.default = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);\\n    \\n    var langSysCount = bin.readUshort(data, offset);  offset+=2;\\n    \\n    for(var i=0; i<langSysCount; i++) {\\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\\n        var langSysOff = bin.readUshort(data, offset);  offset+=2;\\n        obj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);\\n    }\\n    return obj;\\n}\\n\\nTypr._lctf.readLangSysTable = function(data, offset) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    \\n    var lookupOrder = bin.readUshort(data, offset);  offset+=2;\\n    //if(lookupOrder!=0)  throw \\\"lookupOrder not 0\\\";\\n    obj.reqFeature = bin.readUshort(data, offset);  offset+=2;\\n    //if(obj.reqFeature != 0xffff) throw \\\"reqFeatureIndex != 0xffff\\\";\\n    \\n    //console.log(lookupOrder, obj.reqFeature);\\n    \\n    var featureCount = bin.readUshort(data, offset);  offset+=2;\\n    obj.features = bin.readUshorts(data, offset, featureCount);\\n    return obj;\\n}\\n\\n\\nTypr.cmap = {};\\nTypr.cmap.parse = function(data, offset, length) {\\n    data = new Uint8Array(data.buffer, offset, length);\\n    offset = 0;\\n\\n    var offset0 = offset;\\n    var bin = Typr._bin;\\n    var obj = {};\\n    var version   = bin.readUshort(data, offset);  offset += 2;\\n    var numTables = bin.readUshort(data, offset);  offset += 2;\\n    \\n    //console.log(version, numTables);\\n    \\n    var offs = [];\\n    obj.tables = [];\\n    \\n    \\n    for(var i=0; i<numTables; i++) {\\n        var platformID = bin.readUshort(data, offset);  offset += 2;\\n        var encodingID = bin.readUshort(data, offset);  offset += 2;\\n        var noffset = bin.readUint(data, offset);       offset += 4;\\n        \\n        var id = \\\"p\\\"+platformID+\\\"e\\\"+encodingID;\\n        \\n        //console.log(\\\"cmap subtable\\\", platformID, encodingID, noffset);\\n                \\n        var tind = offs.indexOf(noffset);\\n        \\n        if(tind==-1) {\\n            tind = obj.tables.length;\\n            var subt;\\n            offs.push(noffset);\\n            var format = bin.readUshort(data, noffset);\\n            if     (format== 0) subt = Typr.cmap.parse0(data, noffset);\\n            else if(format== 4) subt = Typr.cmap.parse4(data, noffset);\\n            else if(format== 6) subt = Typr.cmap.parse6(data, noffset);\\n            else if(format==12) subt = Typr.cmap.parse12(data,noffset);\\n            else console.log(\\\"unknown format: \\\"+format, platformID, encodingID, noffset);\\n            obj.tables.push(subt);\\n        }\\n        \\n        if(obj[id]!=null) throw \\\"multiple tables for one platform+encoding\\\";\\n        obj[id] = tind;\\n    }\\n    return obj;\\n}\\n\\nTypr.cmap.parse0 = function(data, offset) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    obj.format = bin.readUshort(data, offset);  offset += 2;\\n    var len    = bin.readUshort(data, offset);  offset += 2;\\n    var lang   = bin.readUshort(data, offset);  offset += 2;\\n    obj.map = [];\\n    for(var i=0; i<len-6; i++) obj.map.push(data[offset+i]);\\n    return obj;\\n}\\n\\nTypr.cmap.parse4 = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    obj.format = bin.readUshort(data, offset);  offset+=2;\\n    var length = bin.readUshort(data, offset);  offset+=2;\\n    var language = bin.readUshort(data, offset);  offset+=2;\\n    var segCountX2 = bin.readUshort(data, offset);  offset+=2;\\n    var segCount = segCountX2/2;\\n    obj.searchRange = bin.readUshort(data, offset);  offset+=2;\\n    obj.entrySelector = bin.readUshort(data, offset);  offset+=2;\\n    obj.rangeShift = bin.readUshort(data, offset);  offset+=2;\\n    obj.endCount   = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\\n    offset+=2;\\n    obj.startCount = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\\n    obj.idDelta = [];\\n    for(var i=0; i<segCount; i++) {obj.idDelta.push(bin.readShort(data, offset));  offset+=2;}\\n    obj.idRangeOffset = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\\n    obj.glyphIdArray = [];\\n    while(offset< offset0+length) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\\n    return obj;\\n}\\n\\nTypr.cmap.parse6 = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    obj.format = bin.readUshort(data, offset);  offset+=2;\\n    var length = bin.readUshort(data, offset);  offset+=2;\\n    var language = bin.readUshort(data, offset);  offset+=2;\\n    obj.firstCode = bin.readUshort(data, offset);  offset+=2;\\n    var entryCount = bin.readUshort(data, offset);  offset+=2;\\n    obj.glyphIdArray = [];\\n    for(var i=0; i<entryCount; i++) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\\n    \\n    return obj;\\n}\\n\\nTypr.cmap.parse12 = function(data, offset) {\\n    var bin = Typr._bin;\\n    var offset0 = offset;\\n    var obj = {};\\n    \\n    obj.format = bin.readUshort(data, offset);  offset+=2;\\n    offset += 2;\\n    var length = bin.readUint(data, offset);  offset+=4;\\n    var lang   = bin.readUint(data, offset);  offset+=4;\\n    var nGroups= bin.readUint(data, offset);  offset+=4;\\n    obj.groups = [];\\n    \\n    for(var i=0; i<nGroups; i++) {\\n        var off = offset + i * 12;\\n        var startCharCode = bin.readUint(data, off+0);\\n        var endCharCode   = bin.readUint(data, off+4);\\n        var startGlyphID  = bin.readUint(data, off+8);\\n        obj.groups.push([  startCharCode, endCharCode, startGlyphID  ]);\\n    }\\n    return obj;\\n}\\n\\n\\n\\nTypr.GPOS = {};\\nTypr.GPOS.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);  }\\n\\n\\n\\nTypr.GPOS.subt = function(data, ltype, offset) { // lookup type\\n    if(ltype!=2) return null;\\n    \\n    var bin = Typr._bin, offset0 = offset, tab = {};\\n    \\n    tab.format  = bin.readUshort(data, offset);  offset+=2;\\n    var covOff  = bin.readUshort(data, offset);  offset+=2;\\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);\\n    tab.valFmt1 = bin.readUshort(data, offset);  offset+=2;\\n    tab.valFmt2 = bin.readUshort(data, offset);  offset+=2;\\n    var ones1 = Typr._lctf.numOfOnes(tab.valFmt1);\\n    var ones2 = Typr._lctf.numOfOnes(tab.valFmt2);\\n\\n    if(tab.format==1) {\\n        tab.pairsets = [];\\n        var count = bin.readUshort(data, offset);  offset+=2;\\n        \\n        for(var i=0; i<count; i++) {\\n            var psoff = bin.readUshort(data, offset);  offset+=2;\\n            psoff += offset0;\\n            var pvcount = bin.readUshort(data, psoff);  psoff+=2;\\n            var arr = [];\\n\\n            for(var j=0; j<pvcount; j++) {\\n                var gid2 = bin.readUshort(data, psoff);  psoff+=2;\\n                var value1, value2;\\n                if(tab.valFmt1!=0) {  value1 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt1);  psoff+=ones1*2;  }\\n                if(tab.valFmt2!=0) {  value2 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt2);  psoff+=ones2*2;  }\\n                arr.push({gid2:gid2, val1:value1, val2:value2});\\n            }\\n            tab.pairsets.push(arr);\\n        }\\n    }\\n\\n    if(tab.format==2) {\\n        var classDef1 = bin.readUshort(data, offset);  offset+=2;\\n        var classDef2 = bin.readUshort(data, offset);  offset+=2;\\n        var class1Count = bin.readUshort(data, offset);  offset+=2;\\n        var class2Count = bin.readUshort(data, offset);  offset+=2;\\n        \\n        tab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);\\n        tab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);\\n        \\n        tab.matrix = [];\\n        for(var i=0; i<class1Count; i++) {\\n            var row = [];\\n            for(var j=0; j<class2Count; j++) {\\n                var value1 = null, value2 = null;\\n                if(tab.valFmt1!=0) { value1 = Typr._lctf.readValueRecord(data, offset, tab.valFmt1);  offset+=ones1*2; }\\n                if(tab.valFmt2!=0) { value2 = Typr._lctf.readValueRecord(data, offset, tab.valFmt2);  offset+=ones2*2; }\\n                row.push({val1:value1, val2:value2});\\n            }\\n            tab.matrix.push(row);\\n        }\\n    }\\n    return tab;\\n}\\n\\nTypr.GSUB = {};\\nTypr.GSUB.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);  }\\n\\n\\nTypr.GSUB.subt = function(data, ltype, offset) { // lookup type\\n    var bin = Typr._bin, offset0 = offset, tab = {};\\n    \\n    if(ltype!=1 && ltype!=4) return null;\\n    \\n    tab.fmt  = bin.readUshort(data, offset);  offset+=2;\\n    var covOff  = bin.readUshort(data, offset);  offset+=2;\\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);   // not always is coverage here\\n    \\n    if(false) {}\\n    else if(ltype==1) {\\n        if(tab.fmt==1) {\\n            tab.delta = bin.readShort(data, offset);  offset+=2;\\n        }\\n        else if(tab.fmt==2) {\\n            var cnt = bin.readUshort(data, offset);  offset+=2;\\n            tab.newg = bin.readUshorts(data, offset, cnt);  offset+=tab.newg.length*2;\\n        }\\n    }\\n    else if(ltype==4) {\\n        tab.vals = [];\\n        var cnt = bin.readUshort(data, offset);  offset+=2;\\n        for(var i=0; i<cnt; i++) {\\n            var loff = bin.readUshort(data, offset);  offset+=2;\\n            tab.vals.push(Typr.GSUB.readLigatureSet(data, offset0+loff));\\n        }\\n        //console.log(tab.coverage);\\n        //console.log(tab.vals);\\n    } \\n    \\n    return tab;\\n}\\n\\nTypr.GSUB.readChainSubClassSet = function(data, offset) {\\n    var bin = Typr._bin, offset0 = offset, lset = [];\\n    var cnt = bin.readUshort(data, offset);  offset+=2;\\n    for(var i=0; i<cnt; i++) {\\n        var loff = bin.readUshort(data, offset);  offset+=2;\\n        lset.push(Typr.GSUB.readChainSubClassRule(data, offset0+loff));\\n    }\\n    return lset;\\n}\\n\\nTypr.GSUB.readChainSubClassRule= function(data, offset) {\\n    var bin = Typr._bin, offset0 = offset, rule = {};\\n    var pps = [\\\"backtrack\\\", \\\"input\\\", \\\"lookahead\\\"];\\n    for(var pi=0; pi<pps.length; pi++) {\\n        var cnt = bin.readUshort(data, offset);  offset+=2;  if(pi==1) cnt--;\\n        rule[pps[pi]]=bin.readUshorts(data, offset, cnt);  offset+= rule[pps[pi]].length*2;\\n    }\\n    var cnt = bin.readUshort(data, offset);  offset+=2;\\n    rule.subst = bin.readUshorts(data, offset, cnt*2);  offset += rule.subst.length*2;\\n    return rule;\\n}\\n\\nTypr.GSUB.readLigatureSet = function(data, offset) {\\n    var bin = Typr._bin, offset0 = offset, lset = [];\\n    var lcnt = bin.readUshort(data, offset);  offset+=2;\\n    for(var j=0; j<lcnt; j++) {\\n        var loff = bin.readUshort(data, offset);  offset+=2;\\n        lset.push(Typr.GSUB.readLigature(data, offset0+loff));\\n    }\\n    return lset;\\n}\\n\\nTypr.GSUB.readLigature = function(data, offset) {\\n    var bin = Typr._bin, lig = {chain:[]};\\n    lig.nglyph = bin.readUshort(data, offset);  offset+=2;\\n    var ccnt = bin.readUshort(data, offset);  offset+=2;\\n    for(var k=0; k<ccnt-1; k++) {  lig.chain.push(bin.readUshort(data, offset));  offset+=2;  }\\n    return lig;\\n}\\n\\n\\n\\nTypr.head = {};\\nTypr.head.parse = function(data, offset, length) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\\n    obj.fontRevision = bin.readFixed(data, offset);  offset += 4;\\n    var checkSumAdjustment = bin.readUint(data, offset);  offset += 4;\\n    var magicNumber = bin.readUint(data, offset);  offset += 4;\\n    obj.flags = bin.readUshort(data, offset);  offset += 2;\\n    obj.unitsPerEm = bin.readUshort(data, offset);  offset += 2;\\n    obj.created  = bin.readUint64(data, offset);  offset += 8;\\n    obj.modified = bin.readUint64(data, offset);  offset += 8;\\n    obj.xMin = bin.readShort(data, offset);  offset += 2;\\n    obj.yMin = bin.readShort(data, offset);  offset += 2;\\n    obj.xMax = bin.readShort(data, offset);  offset += 2;\\n    obj.yMax = bin.readShort(data, offset);  offset += 2;\\n    obj.macStyle = bin.readUshort(data, offset);  offset += 2;\\n    obj.lowestRecPPEM = bin.readUshort(data, offset);  offset += 2;\\n    obj.fontDirectionHint = bin.readShort(data, offset);  offset += 2;\\n    obj.indexToLocFormat  = bin.readShort(data, offset);  offset += 2;\\n    obj.glyphDataFormat   = bin.readShort(data, offset);  offset += 2;\\n    return obj;\\n}\\n\\n\\nTypr.hhea = {};\\nTypr.hhea.parse = function(data, offset, length) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\\n    obj.ascender  = bin.readShort(data, offset);  offset += 2;\\n    obj.descender = bin.readShort(data, offset);  offset += 2;\\n    obj.lineGap = bin.readShort(data, offset);  offset += 2;\\n    \\n    obj.advanceWidthMax = bin.readUshort(data, offset);  offset += 2;\\n    obj.minLeftSideBearing  = bin.readShort(data, offset);  offset += 2;\\n    obj.minRightSideBearing = bin.readShort(data, offset);  offset += 2;\\n    obj.xMaxExtent = bin.readShort(data, offset);  offset += 2;\\n    \\n    obj.caretSlopeRise = bin.readShort(data, offset);  offset += 2;\\n    obj.caretSlopeRun  = bin.readShort(data, offset);  offset += 2;\\n    obj.caretOffset    = bin.readShort(data, offset);  offset += 2;\\n    \\n    offset += 4*2;\\n    \\n    obj.metricDataFormat = bin.readShort (data, offset);  offset += 2;\\n    obj.numberOfHMetrics = bin.readUshort(data, offset);  offset += 2;\\n    return obj;\\n}\\n\\n\\nTypr.hmtx = {};\\nTypr.hmtx.parse = function(data, offset, length, font) {\\n    var bin = Typr._bin;\\n    var obj = {};\\n    \\n    obj.aWidth = [];\\n    obj.lsBearing = [];\\n        \\n    var aw = 0, lsb = 0;\\n    \\n    for(var i=0; i<font.maxp.numGlyphs; i++) {\\n        if(i<font.hhea.numberOfHMetrics) {  aw=bin.readUshort(data, offset);  offset += 2;  lsb=bin.readShort(data, offset);  offset+=2;  }\\n        obj.aWidth.push(aw);\\n        obj.lsBearing.push(lsb);\\n    }\\n    \\n    return obj;\\n}\\n\\n\\nTypr.kern = {};\\nTypr.kern.parse = function(data, offset, length, font) {\\n    var bin = Typr._bin;\\n    \\n    var version = bin.readUshort(data, offset);  offset+=2;\\n    if(version==1) return Typr.kern.parseV1(data, offset-2, length, font);\\n    var nTables = bin.readUshort(data, offset);  offset+=2;\\n    \\n    var map = {glyph1: [], rval:[]};\\n    for(var i=0; i<nTables; i++) {\\n        offset+=2;  // skip version\\n        var length  = bin.readUshort(data, offset);  offset+=2;\\n        var coverage = bin.readUshort(data, offset);  offset+=2;\\n        var format = coverage>>>8;\\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\\n        else throw \\\"unknown kern table format: \\\"+format;\\n    }\\n    return map;\\n}\\n\\nTypr.kern.parseV1 = function(data, offset, length, font) {\\n    var bin = Typr._bin;\\n    \\n    var version = bin.readFixed(data, offset);  offset+=4;\\n    var nTables = bin.readUint(data, offset);  offset+=4;\\n    \\n    var map = {glyph1: [], rval:[]};\\n    for(var i=0; i<nTables; i++) {\\n        var length = bin.readUint(data, offset);   offset+=4;\\n        var coverage = bin.readUshort(data, offset);  offset+=2;\\n        var tupleIndex = bin.readUshort(data, offset);  offset+=2;\\n        var format = coverage>>>8;\\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\\n        else throw \\\"unknown kern table format: \\\"+format;\\n    }\\n    return map;\\n}\\n\\nTypr.kern.readFormat0 = function(data, offset, map) {\\n    var bin = Typr._bin;\\n    var pleft = -1;\\n    var nPairs        = bin.readUshort(data, offset);  offset+=2;\\n    var searchRange   = bin.readUshort(data, offset);  offset+=2;\\n    var entrySelector = bin.readUshort(data, offset);  offset+=2;\\n    var rangeShift    = bin.readUshort(data, offset);  offset+=2;\\n    for(var j=0; j<nPairs; j++) {\\n        var left  = bin.readUshort(data, offset);  offset+=2;\\n        var right = bin.readUshort(data, offset);  offset+=2;\\n        var value = bin.readShort (data, offset);  offset+=2;\\n        if(left!=pleft) { map.glyph1.push(left);  map.rval.push({ glyph2:[], vals:[] }) }\\n        var rval = map.rval[map.rval.length-1];\\n        rval.glyph2.push(right);   rval.vals.push(value);\\n        pleft = left;\\n    }\\n    return offset;\\n}\\n\\n\\n\\nTypr.maxp = {};\\nTypr.maxp.parse = function(data, offset, length) {\\n    //console.log(data.length, offset, length);\\n    \\n    var bin = Typr._bin;\\n    var obj = {};\\n    \\n    // both versions 0.5 and 1.0\\n    var ver = bin.readUint(data, offset); offset += 4;\\n    obj.numGlyphs = bin.readUshort(data, offset);  offset += 2;\\n    \\n    // only 1.0\\n    if(ver == 0x00010000) {\\n        obj.maxPoints             = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxContours           = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxCompositePoints    = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxCompositeContours  = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxZones              = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxTwilightPoints     = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxStorage            = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxFunctionDefs       = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxInstructionDefs    = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxStackElements      = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxSizeOfInstructions = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxComponentElements  = bin.readUshort(data, offset);  offset += 2;\\n        obj.maxComponentDepth     = bin.readUshort(data, offset);  offset += 2;\\n    }\\n    \\n    return obj;\\n}\\n\\n\\nTypr.U = {};\\n\\nTypr.U.codeToGlyph = function(font, code) {\\n    var cmap = font.cmap;\\n    \\n    \\n    var tind = -1;\\n    if(cmap.p0e4!=null) tind = cmap.p0e4;\\n    else if(cmap.p3e1!=null) tind = cmap.p3e1;\\n    else if(cmap.p1e0!=null) tind = cmap.p1e0;\\n    \\n    if(tind==-1) throw \\\"no familiar platform and encoding!\\\";\\n    \\n    var tab = cmap.tables[tind];\\n    \\n    if (tab.format==0) {\\n        if(code>=tab.map.length) return 0;\\n        return tab.map[code];\\n    } else if(tab.format==4) {\\n        var sind = -1;\\n        for(var i=0; i<tab.endCount.length; i++)   if(code<=tab.endCount[i]){  sind=i;  break;  } \\n        if(sind==-1) return 0;\\n        if(tab.startCount[sind]>code) return 0;\\n        \\n        var gli = 0;\\n        if(tab.idRangeOffset[sind]!=0) gli = tab.glyphIdArray[(code-tab.startCount[sind]) + (tab.idRangeOffset[sind]>>1) - (tab.idRangeOffset.length-sind)];\\n        else                           gli = code + tab.idDelta[sind];\\n        return gli & 0xFFFF;\\n    } else if(tab.format==12) {\\n        if(code>tab.groups[tab.groups.length-1][1]) return 0;\\n        for(var i=0; i<tab.groups.length; i++) {\\n            var grp = tab.groups[i];\\n            if(grp[0]<=code && code<=grp[1]) return grp[2] + (code-grp[0]);\\n        }\\n        return 0;\\n    }\\n    else throw \\\"unknown cmap table format \\\"+tab.format;\\n}\\n\\n\\nTypr.U._getGlyphClass = function(g, cd) {\\n    for(var i=0; i<cd.start.length; i++) \\n        if(cd.start[i]<=g && cd.end[i]>=g) return cd.class[i];\\n    return 0;\\n}\\n\\nTypr.U.getPairAdjustment = function(font, g1, g2) {\\n    if(font.GPOS) {\\n        var ltab = null;\\n        for(var i = 0; i < font.GPOS.featureList.length; i++) {\\n            var fl = font.GPOS.featureList[i];\\n            if (fl.tag==\\\"kern\\\")\\n                for(var j=0; j<fl.tab.length; j++) \\n                    if(font.GPOS.lookupList[fl.tab[j]].ltype==2) ltab=font.GPOS.lookupList[fl.tab[j]];\\n        }\\n        if(ltab) {\\n            for(var i = 0; i < ltab.tabs.length; i++) {\\n                var tab = ltab.tabs[i];\\n                var ind = Typr._lctf.coverageIndex(tab.coverage, g1);\\n                if (ind==-1) continue;\\n                var adj = 0;\\n                if (tab.format==1) {\\n                    var right = tab.pairsets[ind];\\n                    for (var j=0; j<right.length; j++) if (right[j].gid2==g2) adj = right[j];\\n                    if (adj==null) continue;\\n                } else if (tab.format==2) {\\n                    var c1 = Typr.U._getGlyphClass(g1, tab.classDef1);\\n                    var c2 = Typr.U._getGlyphClass(g2, tab.classDef2);\\n                    adj = tab.matrix[c1][c2];\\n                }\\n                return adj.val1[2];\\n            }\\n        }\\n    }\\n    if(font.kern) {\\n        var ind1 = font.kern.glyph1.indexOf(g1);\\n        if(ind1!=-1) {\\n            var ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);\\n            if(ind2!=-1) return font.kern.rval[ind1].vals[ind2];\\n        }\\n    }\\n    \\n    return 0;\\n}\\n\\n/*\\nTypr.U.isRTL = function(str) {           \\n    var weakChars       = '\\\\u0000-\\\\u0040\\\\u005B-\\\\u0060\\\\u007B-\\\\u00BF\\\\u00D7\\\\u00F7\\\\u02B9-\\\\u02FF\\\\u2000-\\\\u2BFF\\\\u2010-\\\\u2029\\\\u202C\\\\u202F-\\\\u2BFF',\\n        rtlChars        = '\\\\u0591-\\\\u07FF\\\\u200F\\\\u202B\\\\u202E\\\\uFB1D-\\\\uFDFD\\\\uFE70-\\\\uFEFC',\\n        rtlDirCheck     = new RegExp('^['+weakChars+']*['+rtlChars+']');\\n\\n    return rtlDirCheck.test(str);\\n};*/\\n\\n// var wsep = \\\"\\\\n\\\\t\\\\\\\" ,.:;!?()  ،\\\";\\n//Typr.U.WSepTable = [9, 10, 32, 33, 34, 40, 41, 44, 46, 58, 59, 63, 1548]\\n\\n//var L = \\\"ꡲ્૗\\\";\\n//Typr.U.LTable = [ 2765, 2775, 43122 ]\\n\\n//var R = \\\"آأؤإاةدذرزوٱٲٳٵٶٷڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙۀۃۄۅۆۇۈۉۊۋۍۏےۓەۮۯܐܕܖܗܘܙܞܨܪܬܯݍݙݚݛݫݬݱݳݴݸݹࡀࡆࡇࡉࡔࡧࡩࡪࢪࢫࢬࢮࢱࢲࢹૅેૉ૊૎૏ૐ૑૒૝ૡ૤૯஁ஃ஄அஉ஌எஏ஑னப஫஬\\\";\\nTypr.U.RTable = [\\n    1570, 1571, 1572, 1573, 1575, 1577, 1583, 1584, 1585, 1586,\\n    1608, 1649, 1650, 1651, 1653, 1654, 1655, 1672, 1673, 1674,\\n    1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684,\\n    1685, 1686, 1687, 1688, 1689, 1728, 1731, 1732, 1733, 1734,\\n    1735, 1736, 1737, 1738, 1739, 1741, 1743, 1746, 1747, 1749,\\n    1774, 1775, 1808, 1813, 1814, 1815, 1816, 1817, 1822, 1832,\\n    1834, 1836, 1839, 1869, 1881, 1882, 1883, 1899, 1900, 1905,\\n    1907, 1908, 1912, 1913, 2112, 2118, 2119, 2121, 2132, 2151,\\n    2153, 2154, 2218, 2219, 2220, 2222, 2225, 2226, 2233, 2757,\\n    2759, 2761, 2762, 2766, 2767, 2768, 2769, 2770, 2781, 2785,\\n    2788, 2799, 2945, 2947, 2948, 2949, 2953, 2956, 2958, 2959,\\n    2961, 2985, 2986, 2987, 2988 ];\\n\\n\\nTypr.U.stringToGlyphs = function(fonts, str) {\\n    var gls = [], g, i, li, j, lj, k, ti, c, c2, gsub, font, llist, flist, t, gsubTable;\\n    var gl, gfonts = [], codes = [], scodes = [], scodesType = [], str2 = '';\\n\\n    var bidiResult = bidi(str, -1, false);\\n\\n    var rtable = Typr.U.RTable;\\n\\n   for (i = 0, li = str.length; i < li; i++) {\\n        c = str.charCodeAt(i);\\n        scodes.push(c);\\n        scodesType.push(0);\\n\\n        //types wsep = 1, L = 2, R = 3\\n\\n        if (c == 2765 || c == 2775 || c == 43122) { // L\\n            scodesType[i] = 2;\\n        } else if (c == 1548) { // wsep\\n            scodesType[i] = 1;\\n        } else if (c <= 63) { // wsep\\n            if (c == 9 || c == 10 || c == 32 || c == 33 || c == 34 || c == 40 || c == 41 || c == 44 || c == 46 || c == 58 || c == 59 || c == 63) {\\n                scodesType[i] = 1;\\n            }\\n        } else if (c >= 1570 && c <= 2988) { // R\\n            if (rtable.indexOf(c) != -1) {\\n                scodesType[i] = 3;\\n            }\\n        }\\n    }\\n\\n    //basic shaping\\n    for (i = 0, li = str.length; i < li; i++) {\\n        c = scodes[i];\\n\\n        if (scodesType[i] != 1) { //not wsep\\n            if (i < li - 2) {\\n                c2 = scodes[i+1];\\n\\n                //myanmar \\n                if (c2 == 0x103c) { //medial ra - prebase substitution\\n                    scodes[i] = c2;\\n                    scodes[i+1] = c;\\n                    i++;\\n                    continue;\\n                }\\n            }\\n        }\\n    }\\n\\n    //get glyphs and fonts for codes\\n    for (i = 0, li = str.length; i < li; i++) {\\n        c = scodes[i];\\n\\n        for (j = 0, lj = fonts.length; j < lj; j++) {\\n            font = fonts[j];\\n            g = Typr.U.codeToGlyph(font, c);\\n            if (g) {\\n                break;\\n            }\\n        }\\n\\n        gls.push(g);\\n        gfonts.push(g ? j : 0);\\n    }\\n\\n    codes = scodes;\\n    font = null;\\n    \\n    \\n    for(var ci = 0; ci < gls.length; ci++) {\\n        gl = gls[ci];\\n\\n        if (font != gfonts[ci]) {\\n            font = fonts[gfonts[ci]];\\n            gsub = font['GSUB'];\\n        }\\n\\n        if(!gsub) {\\n            continue;\\n        }\\n\\n        var t1 = scodesType[ci-1], t2 = scodesType[ci], t3 = scodesType[ci+1];\\n\\n        var slft = (ci==0) || (t1 == 1);\\n        var srgt = (ci==gls.length-1) || (t3 == 1);\\n        \\n        if(!slft && (t1 == 3)) slft=true;\\n        if(!srgt && (t2 == 3)) srgt=true;\\n        \\n        if(!srgt && (t3 == 2)) srgt=true;\\n        if(!slft && (t2 == 2)) slft=true;\\n        \\n        gsubTable = null;\\n        if (slft) {\\n            gsubTable = srgt ? font.gsubIsolTable : font.gsubInitTable;        \\n        } else {\\n            gsubTable = srgt ? font.gsubFinaTable : font.gsubMediTable;            \\n        }\\n        \\n        if (gsubTable) {\\n            for(ti = 0; ti < gsubTable.length; ti++) {\\n                var tab = gsubTable[ti];\\n\\n                for(j = 0; j < tab.length; j++) {\\n                    var ttab = tab[j];\\n                    var ind = Typr._lctf.coverageIndex(ttab.coverage,gl);\\n                    if(ind == -1) continue;  \\n\\n                    if(ttab.fmt == 0) {\\n                        gls[ci] = ind+ttab.delta;\\n                    } else {\\n                        if (!ttab.newg) {\\n                            gls[ci] = gl;\\n                            console.log(ci, gl, 'subst-error', ' original:', str);\\n                        } else {\\n                            gls[ci] = ttab.newg[ind];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    font = null;\\n    \\n    for(var ci=0; ci<gls.length; ci++) {\\n        gl = gls[ci];\\n\\n        if (font != gfonts[ci]) {\\n            font = fonts[gfonts[ci]];\\n            gsub = font['GSUB'];\\n        }\\n\\n        if(!gsub) {\\n            continue;\\n        }\\n\\n        gsubTable = font.gsubRligLigaTable;\\n\\n        if (gsubTable) {\\n            var rlim = Math.min(3, gls.length-ci-1);\\n\\n            for(ti = 0; ti < gsubTable.length; ti++) {\\n                var tab = gsubTable[ti];\\n\\n                for(j = 0; j < tab.length; j++) {\\n                    var ttab = tab[j];\\n                    var ind = Typr._lctf.coverageIndex(ttab.coverage, gl);\\n                    if(ind==-1) continue;  \\n\\n                    var vals = ttab.vals[ind];\\n                    \\n                    for(k=0; k<vals.length; k++) {\\n                        var lig = vals[k], rl = lig.chain.length;  if(rl>rlim) continue;\\n                        var good = true;\\n                        for(var l=0; l<rl; l++) if(lig.chain[l]!=gls[ci+(1+l)]) good=false;\\n                        if(!good) continue;\\n                        gls[ci]=lig.nglyph;\\n                        for(var l=0; l<rl; l++) gls[ci+l+1]=-1;\\n                        //console.log(\\\"lig\\\", fl.tag,  gl, lig.chain, lig.nglyph);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    var indices = bidiResult.indices;\\n    var gls2 = gls.slice();\\n    var codes2 = gls.slice();\\n\\n    for (i = 0, li = gls.length; i < li; i++) {\\n        c = indices[i];\\n        gls2[i] = gls[c];\\n        codes2[i] = codes[c];\\n    }\\n\\n    return [gls2, gfonts, codes2];\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n/***/ }),\\n/* 9 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_text_js__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__worker_style_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__worker_polygon_js__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__worker_message_js__ = __webpack_require__(1);\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//get rid of compiler mess\\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\\\"a\\\" /* globals */];\\nvar setFont = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\\\"a\\\" /* setFont */];\\nvar setFontMap = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\\\"b\\\" /* setFontMap */], makeFasterFilter = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\\\"a\\\" /* makeFasterFilter */];\\nvar getLayer = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\\\"b\\\" /* getLayer */], getLayerPropertyValue = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\\\"c\\\" /* getLayerPropertyValue */],\\n    processStylesheet = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\\\"d\\\" /* processStylesheet */], getFilterResult = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\\\"e\\\" /* getFilterResult */];\\nvar processLineStringPass = __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__[\\\"a\\\" /* processLineStringPass */];\\nvar processPointArrayPass = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\\\"a\\\" /* processPointArrayPass */];\\nvar processPointArrayVSwitchPass = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\\\"b\\\" /* processPointArrayVSwitchPass */];\\nvar processPolygonPass = __WEBPACK_IMPORTED_MODULE_5__worker_polygon_js__[\\\"a\\\" /* processPolygonPass */];\\nvar processLineStringGeometry = __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__[\\\"b\\\" /* processLineStringGeometry */];\\nvar processPointArrayGeometry = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\\\"c\\\" /* processPointArrayGeometry */];\\nvar postGroupMessageFast = __WEBPACK_IMPORTED_MODULE_6__worker_message_js__[\\\"a\\\" /* postGroupMessageFast */], \\n    postGroupMessageLite = __WEBPACK_IMPORTED_MODULE_6__worker_message_js__[\\\"b\\\" /* postGroupMessageLite */], optimizeGroupMessages = __WEBPACK_IMPORTED_MODULE_6__worker_message_js__[\\\"c\\\" /* optimizeGroupMessages */];\\nvar getLayerPropertyValueInner = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\\\"f\\\" /* getLayerPropertyValueInner */];\\n\\nvar exportedGeometries = [];\\nvar featureCache = new Array(1024), featureCacheIndex = 0, finalFeatureCache = new Array(1024), finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\\n\\n\\nfunction processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo) {\\n\\n    switch(type) {\\n    case 'line-string':\\n        if (getLayerPropertyValue(layer, 'point', feature, lod) ||\\n            getLayerPropertyValue(layer, 'label', feature, lod)) {\\n            processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n        }\\n\\n        processLineStringPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n        break;\\n\\n    case 'point-array':\\n        processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n        break;\\n            \\n    case 'polygon':\\n        processPolygonPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n        break;     \\n    }\\n\\n}\\n\\nfunction processFeatures(type, features, lod, featureType, group) {\\n    var reduceParams = globals.reduceParams;\\n\\n    //loop layers\\n    for (var key in globals.stylesheetLayers) {\\n        var layer = globals.stylesheetLayers[key];\\n\\n        if (type == 'point-array') {\\n            var importance = layer['importance-source'];\\n\\n            if (!importance && features[0] && features[0]['importance']) {\\n                importance = '$importance';\\n            }\\n\\n            if (importance) {\\n                //importance = '$importance';\\n                switch (globals.reduceMode) {\\n                    case 'scr-count1': \\n                    case 'scr-count2': \\n                        layer['reduce'] = ['top',100,importance];\\n                        layer['dynamic-reduce'] = ['scr-count2', reduceParams[0], reduceParams[1]];\\n                        break;\\n                    case 'scr-count4': \\n                        layer['dynamic-reduce'] = ['scr-count4',importance];\\n                        break;\\n                    case 'scr-count5': \\n                        layer['dynamic-reduce'] = ['scr-count5',importance];\\n                        break;\\n                    case 'scr-count6': \\n                        layer['dynamic-reduce'] = ['scr-count6',importance];\\n                        layer['label-no-overlap-margin'] = [reduceParams[0]*reduceParams[3], reduceParams[0]*reduceParams[3]];\\n                        layer['icon-no-overlap-margin'] = [reduceParams[0]*reduceParams[3], reduceParams[0]*reduceParams[3]];\\n                        break;\\n\\n                }\\n            }\\n        }\\n\\n        var filter =  layer['filter'];\\n        var reduce =  layer['reduce'], i, li, j, lj;\\n\\n        if (filter) {\\n            filter = layer['#filter'];\\n            if (!filter) {\\n                layer['#filter'] = makeFasterFilter(layer['filter']);\\n                filter = layer['#filter'];\\n            }\\n        }\\n\\n        featureCacheIndex = 0, finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\\n\\n        for (i = 0, li = features.length; i < li; i++) {\\n            var feature = features[i];\\n            feature.properties = feature['properties'] || {};\\n\\n            if (feature['id']) {\\n                feature.properties['#id'] = feature['id']; \\n            }\\n            \\n            if (!filter || getFilterResult(filter, feature, featureType, group, layer, 'filter', lod, 0, true)) {\\n                if (reduce) {\\n                    featureCache[featureCacheIndex] = feature;\\n                    featureCacheIndex++;\\n                } else {\\n                    processLayerFeature(type, feature, lod, layer, i);\\n                }\\n            }\\n        }\\n\\n        if (reduce) {\\n\\n            var count = reduce[1];\\n            var property = reduce[2];\\n\\n            switch (reduce[0]) {\\n                case 'top':\\n                case 'bottom':\\n\\n                    if (typeof property === 'string' && property.charAt(0) == '@') {\\n                        property = globals.stylesheetConstants[property];\\n\\n                        if (typeof property === 'undefined') {\\n                            break;\\n                        }\\n                    }\\n\\n                    if ((typeof property === 'string' && property.charAt(0) == '$') || (typeof property === 'object')) {\\n                        var complexProperty = (typeof property === 'object');\\n\\n                        if (!complexProperty) {\\n                            property = property.substr(1);\\n                        }\\n\\n                        if (count > featureCacheIndex) {\\n                            count = featureCacheIndex;\\n                        }\\n\\n                        var top = (reduce[0] == 'top'), value;\\n                        var currentIndex = 0;\\n                        var currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\\n\\n                        do {\\n                            var currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\\n                            finalFeatureCacheIndex2 = finalFeatureCacheIndex;\\n\\n                            for (i = 0, li = featureCacheIndex; i < li; i++) {\\n                                feature = featureCache[i];\\n\\n                                if (!currentIndex) {\\n                                    if (!complexProperty) {\\n                                        value = parseFloat(feature.properties[property]);\\n                                    } else {\\n                                        value = getLayerPropertyValueInner(layer, null, feature, lod, property, 0);\\n                                    }\\n                                    feature.tmp = value;\\n                                } else {\\n                                    value = feature.tmp;\\n                                }\\n\\n                                if (!isNaN(value) && ((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {\\n                                    if (currentValue != value) {\\n                                        finalFeatureCacheIndex = finalFeatureCacheIndex2;\\n                                    }\\n\\n                                    finalFeatureCache[finalFeatureCacheIndex] = feature;\\n                                    finalFeatureCacheIndex++;\\n                                    currentValue = value;\\n                                }\\n                            }\\n\\n                            currentValue2 = currentValue;\\n                            currentIndex++;\\n\\n                        } while(currentIndex < count);\\n                    }\\n\\n                    break;\\n\\n                case 'odd':\\n                case 'even':\\n\\n                    for (i = (reduce[0] == 'odd') ? 1 : 0, li = featureCacheIndex; i < li; i+=2) {\\n                        feature = featureCache[i];\\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\\n                        finalFeatureCacheIndex++;\\n                    }\\n\\n                case 'every':\\n\\n                    if (count > featureCacheIndex) {\\n                        count = featureCacheIndex;\\n                    }\\n\\n                    for (i = 0, li = featureCacheIndex; i < li; i += count) {\\n                        feature = featureCache[i];\\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\\n                        finalFeatureCacheIndex++;\\n                    }\\n\\n                    break;\\n            }\\n\\n            //process reduced features\\n            for (i = 0, li = finalFeatureCacheIndex; i < li; i++) {\\n                feature = finalFeatureCache[i];\\n                processLayerFeature(type, finalFeatureCache[i], lod, layer, i);\\n            }\\n\\n        }\\n\\n    }\\n}\\n\\n\\nfunction processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo) {\\n    var multiPass = getLayerPropertyValue(layer, 'next-pass', feature, lod);\\n\\n    var mylayer;\\n\\n    if (multiPass != null) {\\n        for (var i = 0, li = multiPass.length; i < li; i++) {\\n            var zIndex = multiPass[i][0];\\n            mylayer = getLayer(multiPass[i][1], type, featureIndex);\\n            \\n            if (!getLayerPropertyValue(mylayer, 'visible', feature, lod)) {\\n                continue;\\n            }\\n\\n            var selectedLayerId = getLayerPropertyValue(mylayer, 'selected-layer', feature, lod);\\n            var selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\\n\\n            var selectedHoverLayerId = getLayerPropertyValue(mylayer, 'selected-hover-layer', feature, lod);\\n            var selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\\n\\n            var hoverLayerId = getLayerPropertyValue(mylayer, 'hover-layer', feature, lod);\\n            var hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\\n\\n            var flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\\n\\n            var lastHitState = globals.hitState;\\n\\n            if (selectedLayer != null) {\\n                globals.hitState = flags | 2;\\n                processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\\n            }\\n\\n            if (selectedHoverLayer != null) {\\n                globals.hitState = flags | 3;\\n                processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\\n            }\\n\\n            if (hoverLayer != null) {\\n                globals.hitState = flags | 1;\\n                processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\\n            }\\n                \\n            //globals.hitState = flags | 0;\\n            processLayerFeaturePass(type, feature, lod, mylayer, featureIndex, zIndex, eventInfo);\\n\\n            globals.hitState = lastHitState;\\n        }\\n    }\\n}\\n\\n\\nfunction processLayerFeature(type, feature, lod, layer, featureIndex, skipPack) {\\n    if (!getLayerPropertyValue(layer, 'visible', feature, lod)) {\\n        return;\\n    }\\n\\n    if (type == 'point-array') {\\n        if (layer['visibility-switch']) {\\n            postGroupMessageLite(5, 15);\\n            //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-begin'});\\n            var zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\\n            var eventInfo = feature.properties;\\n            processPointArrayVSwitchPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\\n\\n            var vswitch = layer['visibility-switch'];\\n            for (var i = 0, li = vswitch.length; i <li; i++) {\\n                if (vswitch[i][1]) {\\n                    var slayer = getLayer(vswitch[i][1], type, featureIndex);\\n                    processLayerFeature(type, feature, lod, slayer, featureIndex);\\n                }\\n                postGroupMessageLite(5, 16, vswitch[i][0]);\\n                //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-store', 'viewExtent': vswitch[i][0]});\\n            }\\n\\n            postGroupMessageLite(5, 17);\\n            //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-end'});\\n            return;\\n        }\\n    }\\n\\n    if (!skipPack && layer['pack'] == true) {\\n        postGroupMessageLite(5, 13);\\n        //postGroupMessage({'command':'addRenderJob', 'type':'pack-begin'});\\n        processLayerFeature(type, feature, lod, layer, featureIndex, true);\\n        postGroupMessageLite(5, 14);\\n        //postGroupMessage({'command':'addRenderJob', 'type':'pack-end'});\\n        return;\\n    }\\n\\n    var zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\\n\\n    if (getLayerPropertyValue(layer, 'export-geometry', feature, lod) && (typeof feature['id'] !== 'undefined')) {\\n        if (!exportedGeometries[feature]) {\\n\\n            switch(type) {\\n            case 'line-string':\\n                processLineStringGeometry(feature);\\n                break;\\n\\n            case 'point-array':\\n                processPointArrayGeometry(feature);\\n                break;\\n                    \\n            case 'polygon':\\n                break;     \\n            }\\n\\n            exportedGeometries[feature] = true;\\n        }\\n    }\\n\\n    var eventInfo = feature.properties;\\n\\n    var selectedLayerId = getLayerPropertyValue(layer, 'selected-layer', feature, lod);\\n    var selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\\n\\n    var selectedHoverLayerId = getLayerPropertyValue(layer, 'selected-hover-layer', feature, lod);\\n    var selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\\n\\n    var hoverLayerId = getLayerPropertyValue(layer, 'hover-layer', feature, lod);\\n    var hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\\n\\n    var flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\\n\\n    if (selectedLayer != null) {\\n        globals.hitState = flags | 2;\\n        processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\\n        processLayerFeatureMultipass(type, feature, lod, selectedLayer, featureIndex, eventInfo);\\n    }\\n\\n    if (selectedHoverLayer != null) {\\n        globals.hitState = flags | 3;\\n        processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\\n        processLayerFeatureMultipass(type, feature, lod, selectedHoverLayer, featureIndex, eventInfo);\\n    }\\n\\n    if (hoverLayer != null) {\\n        globals.hitState = flags | 1;\\n        processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\\n        processLayerFeatureMultipass(type, feature, lod, hoverLayer, featureIndex, eventInfo);\\n    }\\n\\n    globals.hitState = flags | 0;\\n    processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo);\\n    processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo);\\n}\\n\\nfunction processGroup(group, lod) {\\n    var i, li;\\n    var groupId = group['id'] || '';\\n    globals.groupId = groupId;\\n\\n    var bbox = group['bbox'];    \\n    if (!bbox) {\\n        return;\\n    }\\n          \\n    var bboxMin = bbox[0];\\n    var bboxMax = bbox[1];\\n    globals.bboxMin = bboxMin;\\n    globals.bboxMax = bboxMax;\\n\\n    var bboxDelta = [bbox[1][0] - bbox[0][0],\\n        bbox[1][1] - bbox[0][1],\\n        bbox[1][2] - bbox[0][2]];\\n    var bboxResolution = group['resolution'] || 4096;\\n    \\n    globals.groupOrigin = [0,0,0];\\n    globals.forceScale = [bboxDelta[0] / bboxResolution,\\n        bboxDelta[1] / bboxResolution,\\n        bboxDelta[2] / bboxResolution];\\n\\n    postGroupMessageFast(9, 0, {'id': group['id'], 'bbox': [bboxMin, bboxMax], 'origin': bboxMin}, [], \\\"\\\");\\n    //postGroupMessage({'command':'beginGroup', 'id': group['id'], 'bbox': [bboxMin, bboxMax], 'origin': bboxMin});\\n\\n    //process points\\n    var points = group['points'] || [];\\n    globals.featureType = 'point';\\n    processFeatures('point-array', points, lod, 'point', groupId);\\n\\n    //process lines\\n    var lines = group['lines'] || [];\\n    globals.featureType = 'line';\\n    processFeatures('line-string', lines, lod, 'line', groupId);\\n\\n    //process polygons\\n    var polygons = group['polygons'] || [];\\n    globals.featureType = 'polygon';\\n    processFeatures('polygon', polygons, lod, 'polygon', groupId);\\n\\n    postGroupMessageLite(10, 0);\\n    //postGroupMessage({'command':'endGroup'});\\n\\n    if (globals.groupOptimize) {\\n        optimizeGroupMessages();\\n    }\\n\\n    //optimizeGroupMessagesFast();\\n}\\n\\n\\nfunction processGeodata(data, lod) {\\n    //console.log(\\\"processGeodata\\\");\\n\\n    //create object from JSON\\n    if ((typeof data) == 'string') {\\n        try {\\n            var geodata = JSON.parse(data);\\n        } catch (e) {\\n            geodata = null;\\n        }\\n    } else {\\n        geodata = data;\\n    }\\n\\n    if (geodata) {\\n\\n        var groups = geodata['groups'] || [];\\n\\n        //process layers\\n        for (var i = 0, li = groups.length; i < li; i++) {\\n            processGroup(groups[i], lod);\\n        }\\n    }\\n\\n    //console.log(\\\"processGeodata-ready\\\");\\n}\\n\\n\\nself.onmessage = function (e) {\\n    var message = e.data;\\n    var command = message['command'];\\n    var data = message['data'];\\n\\n    //console.log(\\\"workeronmessage: \\\" + command);\\n\\n    switch(command) {\\n\\n    case 'setStylesheet':\\n        if (data) {\\n            globals.geocent = data['geocent'];\\n            globals.metricUnits = data['metric'];\\n            globals.reduceMode = data['reduceMode'];\\n            globals.reduceParams = data['reduceParams'];\\n            globals.log = data['log'];\\n            processStylesheet(data['data']);\\n        }\\n        //postMessage({'command' : 'ready'});\\n        break;\\n\\n    case 'setFont':\\n        setFont(data);\\n        //postMessage({'command' : 'ready'});\\n        break;\\n\\n    case 'setFontMap':\\n        setFontMap(data);\\n        postMessage({'command' : 'styleDone'});\\n        postMessage({'command' : 'ready'});\\n        break;\\n\\n    case 'processGeodata':\\n        globals.tileLod = message['lod'] || 0;\\n        globals.tileSize = message['tileSize'] || 1;\\n        globals.pixelSize = message['pixelSize'] || 1;\\n        globals.pixelFactor = message['dpr'] || 1;\\n        globals.invPixelFactor = 1.0 / globals.pixelFactor;\\n        data = JSON.parse(data);            \\n        exportedGeometries = [];\\n        processGeodata(data, globals.tileLod);\\n\\n        postGroupMessageLite(7, 0);\\n            \\n        if (globals.groupOptimize) {  //we need send all processed message\\n            optimizeGroupMessages();\\n        }\\n            \\n        //postMessage({'command' : 'allProcessed'});\\n        postMessage({'command' : 'ready'});\\n        break;\\n    }\\n};\\n\\n\\n\\n/***/ })\\n/******/ ]);\\n//# sourceMappingURL=ced900b6b661859085f5.worker.js.map\", null);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/worker-loader?inline&fallback=false!./src/core/map/geodata-processor/worker-main.js\n// module id = 117\n// module chunks = 0 1","\nvar InspectorGraphs = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorGraphs.prototype.init = function() {\n    var inspector = this.inspector;\n\n    inspector.addStyle( ''\n        + '#vts-graphs-panel {'\n            + 'position:absolute;'\n            + 'left:10px;'\n            + 'top:10px;'\n            + 'z-index: 7;'\n            + 'background-color: #FFFFFF;'\n            + 'padding: 5px;'\n            + 'border-radius: 4px;'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'color:#000000;'\n            + 'text-align: left;'\n            + 'font-size: 12px;'\n            + 'display:none;'\n        + '}'\n\n        + '.vts-graphs-canvas {'\n            + 'border: solid 1px #bbb;'\n            + 'image-rendering : pixelated;'\n        + '}'\n\n        + '.vts-graphs-info {'\n            + 'padding: 5px 2px;'\n            + 'font-size: 10px;'\n        + '}'\n\n        + '.vts-graphs-button {'\n            + 'padding: 2px 5px;'\n            + 'display:inline-block;'\n            + 'margin-right: 4px;'\n            + 'border-radius: 4px;'\n            + 'cursor:pointer;'\n        + '}'\n\n        + '.vts-graphs-button:hover {'\n            + 'box-shadow: 0 0 1px #0066ff;'\n        + '}'\n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-graphs-panel';\n    this.element.innerHTML = ''\n        + '<canvas id=\"vts-graphs-render\" class=\"vts-graphs-canvas\" width=\"900\" height=\"100\" ></canvas>'\n        + '<div id=\"vts-graphs-info\" class=\"vts-graphs-info\" >&FilledSmallSquare; Frame: 1234 &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Render: 1234 &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Mesh: 1234 &nbsp <span style=\"color:#00bb00\">&FilledSmallSquare;</span> GpuMesh: 1234</div>'\n        + '<canvas id=\"vts-graphs-cache\" class=\"vts-graphs-canvas\" width=\"900\" height=\"100\" ></canvas>'\n        + '<div id=\"vts-graphs-info2\" class=\"vts-graphs-info\" >&FilledSmallSquare; Cache: 1234 &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Used: 123 &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style=\"color:#00bb00\">&FilledSmallSquare;</span> Mesh: &nbsp 1234</div>'\n        + '<div id=\"vts-graphs-rec\" class=\"vts-graphs-button\" >Recording On</div>'\n        + '<div id=\"vts-graphs-ref\" class=\"vts-graphs-button\" >Refresh On</div>'\n        + '<div id=\"vts-graphs-res\" class=\"vts-graphs-button\" >Reset</div>'\n        + '<div id=\"vts-graphs-zoom\" class=\"vts-graphs-button\" >Scale: Max value</div>'\n        + '<div id=\"vts-graphs-magnify\" class=\"vts-graphs-button\" >Magnify Off</div>'\n        + '<div id=\"vts-graphs-graph\" class=\"vts-graphs-button\" >Graph: Cache</div>';\n\n    this.core.element.appendChild(this.element);\n    this.canvasRender = document.getElementById('vts-graphs-render');\n    this.canvasCache = document.getElementById('vts-graphs-cache');\n    this.canvasRenderCtx = this.canvasRender.getContext('2d');\n    this.canvasCacheCtx = this.canvasCache.getContext('2d');\n\n    document.getElementById('vts-graphs-rec').onclick = this.recordingPressed.bind(this);\n\n    document.getElementById('vts-graphs-rec').onclick = this.recordingPressed.bind(this);\n    document.getElementById('vts-graphs-ref').onclick = this.refreshPressed.bind(this);\n    document.getElementById('vts-graphs-res').onclick = this.resetPressed.bind(this);\n    document.getElementById('vts-graphs-zoom').onclick = this.zoomPressed.bind(this);\n    document.getElementById('vts-graphs-magnify').onclick = this.magnifyPressed.bind(this);\n    document.getElementById('vts-graphs-graph').onclick = this.graphPressed.bind(this);\n\n    document.getElementById('vts-graphs-render').onmousemove = this.onMouseMove.bind(this);\n    document.getElementById('vts-graphs-render').onmouseout = this.onMouseOut.bind(this);\n    document.getElementById('vts-graphs-cache').onmousemove = this.onMouseMove.bind(this);\n    document.getElementById('vts-graphs-cache').onmouseout = this.onMouseOut.bind(this);\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.zoom = 'max';\n    this.graph = 'Cache';\n    this.refresh = true;\n\n    this.panelVisible = false;\n};\n\n\nInspectorGraphs.prototype.showPanel = function() {\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n    this.recordingPressed(true);\n};\n\n\nInspectorGraphs.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n    this.recordingPressed(true);\n};\n\n\nInspectorGraphs.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorGraphs.prototype.recordingPressed = function(state) {\n    var map = this.core.getMap();\n\n    if (!map) {\n        return;\n    }\n\n    map.stats.recordGraphs = (state == null) ? state : !map.stats.recordGraphs;\n    this.updateGraphsPanel();\n    this.updateGraphs(null, true);\n};\n\n\nInspectorGraphs.prototype.refreshPressed = function() {\n    this.refresh = !this.refresh;\n    this.updateGraphsPanel();\n    this.updateGraphs();\n};\n\n\nInspectorGraphs.prototype.resetPressed = function() {\n    var map = this.core.getMap();\n\n    if (!map) {\n        return;\n    }\n\n    map.stats.resetGraphs();\n    this.updateGraphs(null, true);\n};\n\n\nInspectorGraphs.prototype.zoomPressed = function() {\n    switch (this.zoom) {\n    case 'max':     this.zoom = '120avrg'; break;\n    case '120avrg': this.zoom = '180avrg'; break;\n    case '180avrg': this.zoom = 'max'; break;\n    }\n\n    this.updateGraphsPanel();\n    this.updateGraphs();\n};\n\n\nInspectorGraphs.prototype.graphPressed = function() {\n    switch (this.graph) {\n    case 'Cache':      this.graph = 'Polygons'; break;\n    case 'Polygons':   this.graph = 'Processing'; break;\n    case 'Processing': this.graph = 'LODs'; break;\n    case 'LODs':       this.graph = 'Flux'; break;\n    case 'Flux':       this.graph = 'Cache'; break;\n    }\n\n    this.updateGraphsPanel();\n    this.updateGraphs();\n};\n\n\nInspectorGraphs.prototype.magnifyPressed = function() {\n    this.magnify = !this.magnify;\n\n    if (this.magnify) {\n        this.canvasRender.style.width = '1400px';\n        this.canvasRender.style.height = '200px';\n        this.canvasCache.style.width = '1400px';\n        this.canvasCache.style.height = '200px';\n        document.getElementById('vts-graphs-magnify').innerHTML = 'Magnify On';\n    } else {\n        this.canvasRender.style.width = '900px';\n        this.canvasRender.style.height = '100px';\n        this.canvasCache.style.width = '900px';\n        this.canvasCache.style.height = '100px';\n        document.getElementById('vts-graphs-magnify').innerHTML = 'Magnify Off';\n    }\n\n    this.updateGraphsPanel();\n    this.updateGraphs();\n};\n\n\nInspectorGraphs.prototype.updateGraphsPanel = function() {\n    var map = this.core.getMap();\n\n    if (!map) {\n        return;\n    }\n\n    if (map.stats.recordGraphs) {\n        document.getElementById('vts-graphs-rec').innerHTML = 'Recording On';\n    } else {\n        document.getElementById('vts-graphs-rec').innerHTML = 'Recording Off';\n    }\n\n    if (this.refresh) {\n        document.getElementById('vts-graphs-ref').innerHTML = 'Refresh On';\n    } else {\n        document.getElementById('vts-graphs-ref').innerHTML = 'Refresh Off';\n    }\n\n    switch (this.zoom) {\n    case 'max':\n        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: Max value';\n        break;\n\n    case '120avrg':\n        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: 100% Avrg';\n        break;\n\n    case '180avrg':\n        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: 50% Avrg';\n        break;\n    }\n\n    document.getElementById('vts-graphs-graph').innerHTML = 'Graph: ' + this.graph;\n};\n\n\nInspectorGraphs.prototype.onMouseMove = function(event) {\n    var x = event.clientX - this.canvasRender.getBoundingClientRect().left;\n    this.showCursor = true;\n\n    if (this.magnify) {\n        x = Math.floor(x * 900/1400);\n    }\n\n    this.cursorIndex = x;\n\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    if (!map.stats.recordGraphs) {\n        this.updateGraphs(null);\n    }\n};\n\n\nInspectorGraphs.prototype.onMouseOut = function() {\n    this.showCursor = false;\n    this.updateGraphs(null);\n};\n\n\nInspectorGraphs.prototype.updateGraphs = function(stats, ignoreRefresh) {\n    var map = this.core.getMap();\n\n    if (!map || (!this.refresh && !ignoreRefresh) || !this.panelVisible) {\n        return;\n    }\n\n    stats = stats || map.stats;\n\n    var width = this.canvasRender.width;\n    var height = this.canvasRender.height;\n    var ctx = this.canvasRenderCtx;\n\n    var samples = stats.graphsTimeSamples;\n    var samplesIndex = stats.graphsTimeIndex;\n\n    var factorX = width / samples;\n\n    ctx.clearRect(0, 0, width, height);\n\n    var maxValue = 0;\n    var totalFrame = 0;\n    var totalRender = 0;\n    var totalTexture = 0;\n    var totalMeshes = 0;\n    var totalGpuMeshes = 0;\n    var realCount = 0, i, j, lj;\n    var index, value, values, str, y, factorY, max, min;\n\n    var valuesFrame = stats.graphsFrameTimes;\n    var valuesRender = stats.graphsRenderTimes;\n    var valuesTextures = stats.graphsCreateTextureTimes;\n    var valuesMeshes = stats.graphsCreateMeshTimes;\n    var valuesGpuMeshes = stats.graphsCreateGpuMeshTimes;\n    var valuesGeodata;\n\n    for (i = 0; i < samples; i++) {\n        totalFrame += valuesFrame[i];\n        totalRender += valuesRender[i];\n        totalTexture += valuesTextures[i];\n        totalMeshes += valuesMeshes[i];\n        totalGpuMeshes += valuesGpuMeshes[i];\n\n        var v = valuesFrame[i];\n\n        if (v > maxValue) {\n            maxValue = v;\n        }\n\n        if (v > 0) {\n            realCount++;\n        }\n    }\n\n    if (this.zoom == '120avrg') {\n        maxValue = (totalFrame / realCount) * 1.0;\n    }\n\n    if (this.zoom == '180avrg') {\n        maxValue = (totalFrame / realCount) * 0.5;\n    }\n\n    factorY = height / maxValue;\n\n    for (i = 0; i < samples; i++) {\n        index = samplesIndex + i;\n        index %= samples;\n\n        ctx.fillStyle='#000000';\n        ctx.fillRect(i*factorX, height, 1, -(valuesFrame[index])*factorY);\n        ctx.fillStyle='#ff0000';\n        ctx.fillRect(i*factorX, height, 1, -(valuesRender[index])*factorY);\n\n        ctx.fillStyle='#0000ff';\n        ctx.fillRect(i*factorX, height, 1, -(valuesTextures[index])*factorY);\n\n        y = height -(valuesTextures[index])*factorY;\n\n        ctx.fillStyle='#007700';\n        ctx.fillRect(i*factorX, y, 1, -(valuesMeshes[index])*factorY);\n\n        y -= (valuesMeshes[index])*factorY;\n\n        ctx.fillStyle='#00ff00';\n        ctx.fillRect(i*factorX, y, 1, -(valuesGpuMeshes[index])*factorY);\n\n    }\n\n    if (this.showCursor) {\n        ctx.fillStyle='#aa00aa';\n        index = (this.cursorIndex) % samples;\n        ctx.fillRect(Math.floor(index*factorX)-1, 0, 1, height);\n        ctx.fillRect(Math.floor(index*factorX)+1, 0, 1, height);\n        index = (this.cursorIndex + samplesIndex) % samples;\n\n        str = '&FilledSmallSquare; Frame: ' + valuesFrame[index].toFixed(2) +\n              ' &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Render: ' + valuesRender[index].toFixed(2) +\n              ' &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Textures: ' + valuesTextures[index].toFixed(2) +\n              ' &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Meshes: ' + valuesMeshes[index].toFixed(2) +\n              ' &nbsp <span style=\"color:#00bb00\">&FilledSmallSquare;</span> GpuMeshes: ' + valuesGpuMeshes[index].toFixed(2) + '</div>';\n    } else {\n        str = '&FilledSmallSquare; Frame: ' + Math.round(totalFrame) +\n              ' &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Render: ' + Math.round(totalRender) +\n              ' &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Textures: ' + Math.round(totalTexture) +\n              ' &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Meshes: ' + Math.round(totalMeshes) +\n              ' &nbsp <span style=\"color:#00bb00\">&FilledSmallSquare;</span> GpuMeshes: ' + Math.round(totalGpuMeshes) +'</div>';\n    }\n\n    document.getElementById('vts-graphs-info').innerHTML = str;\n\n    width = this.canvasCache.width;\n    height = this.canvasCache.height;\n    ctx = this.canvasCacheCtx;\n\n    factorX = width / samples;\n\n    ctx.clearRect(0, 0, width, height);\n\n    switch (this.graph) {\n    case 'Cache':\n        {\n            factorY = height / ((map.gpuCache.maxCost+map.resourcesCache.maxCost+map.metatileCache.maxCost));\n\n            var maxMetatiles = 0;\n            var maxResources = 0;\n            var maxTextures = 0;\n            var maxMeshes = 0;\n            var maxGeodata = 0;\n            var maxGpu = 0;\n\n            var valuesMetatiles = stats.graphsCpuMemoryMetatiles;\n            var valuesResources = stats.graphsCpuMemoryUsed;\n            var valuesGpu = stats.graphsGpuMemoryRender;\n            valuesGeodata = stats.graphsGpuMemoryGeodata;\n            valuesTextures = stats.graphsGpuMemoryTextures;\n            valuesMeshes = stats.graphsGpuMemoryMeshes;\n\n            for (i = 0; i < samples; i++) {\n                maxMetatiles = valuesMetatiles[i] > maxMetatiles ? valuesMetatiles[i] : maxMetatiles;\n                maxResources = valuesResources[i] > maxResources ? valuesResources[i] : maxResources;\n                maxTextures = valuesTextures[i] > maxTextures ? valuesTextures[i] : maxTextures;\n                maxMeshes = valuesMeshes[i] > maxMeshes ? valuesMeshes[i] : maxMeshes;\n                maxGeodata = valuesGeodata[i] > maxGeodata ? valuesGeodata[i] : maxGeodata;\n                maxGpu = valuesGpu[i] > maxGpu ? valuesGpu[i] : maxGpu;\n            }\n\n            for (i = 0; i < samples; i++) {\n                index = samplesIndex + i;\n                index %= samples;\n\n                value = valuesMetatiles[index] + valuesMeshes[index] + valuesTextures[index] + valuesGeodata[index] + valuesResources[index];\n                ctx.fillStyle='#000000';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n                value -= valuesResources[index];\n\n                ctx.fillStyle='#0000ff';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n                value -= valuesTextures[index];\n\n                ctx.fillStyle='#009999';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n                value -= valuesGeodata[index];\n\n                ctx.fillStyle='#007700';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n                value -= valuesMeshes[index];\n\n                ctx.fillStyle='#ff0000';\n                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);\n\n                value = valuesGpu[index];\n                ctx.fillStyle='#ffff00';\n                ctx.fillRect(i*factorX, height -(value)*factorY, 1, 1);\n            }\n\n            if (this.showCursor) {\n                index = (this.cursorIndex + samplesIndex) % samples;\n                str = '<span style=\"color:#555\">&FilledSmallSquare;</span> Total: ' + Math.ceil((valuesMetatiles[index] + valuesResources[index] + valuesTextures[index] + valuesMeshes[index])/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#000000\">&FilledSmallSquare;</span> CPU: ' + Math.ceil(valuesResources[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#000000\">&FilledSmallSquare;</span> GPU: ' + Math.ceil((valuesTextures[index] + valuesMeshes[index])/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Te: ' + Math.ceil(valuesTextures[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Me: ' + Math.ceil(valuesMeshes[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#009999\">&FilledSmallSquare;</span> Ge: ' + Math.ceil(valuesGeodata[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Met: ' + Math.ceil(valuesMetatiles[index]/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#ffff00\">&FilledSmallSquare;</span> Render: ' + Math.ceil(valuesGpu[index]/(1024*1024)) + 'MB' +'</div>';\n            } else {\n                str = '<span style=\"color:#555\">&FilledSmallSquare;</span> Total: ' + Math.round((maxMetatiles + maxResources + maxTextures + maxMeshes)/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#000000\">&FilledSmallSquare;</span> CPU: ' + Math.ceil(maxResources/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#000000\">&FilledSmallSquare;</span> GPU: ' + Math.ceil((maxTextures + maxMeshes)/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#0000ff\">&FilledSmallSquare;</span> Te ' + Math.ceil(maxTextures/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#005500\">&FilledSmallSquare;</span> Me: ' + Math.ceil(maxMeshes/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#009999\">&FilledSmallSquare;</span> Ge: ' + Math.ceil(maxGeodata/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#ff0000\">&FilledSmallSquare;</span> Met: ' + Math.ceil(maxMetatiles/(1024*1024)) + 'MB' +\n                      ' &nbsp <span style=\"color:#ffff00\">&FilledSmallSquare;</span> Render: ' + Math.ceil(maxGpu/(1024*1024)) + 'MB' +'</div>';\n            }\n\n        }\n        break;\n\n\n    case 'Polygons':\n    case 'Processing':\n        {\n            max = 0;\n            min = 99999999999;\n            realCount = 0;\n            values = (this.graph == 'Polygons') ? stats.graphsPolygons : stats.graphsBuild;\n            var total = 0;\n\n            for (i = 0; i < samples; i++) {\n                max = values[i] > max ? values[i] : max;\n\n                if (values[i] > 0) {\n                    min = values[i] < min ? values[i] : min;\n                    total += values[i];\n                    realCount++;\n                }\n            }\n\n            factorY = height / max;\n\n            for (i = 0; i < samples; i++) {\n                index = samplesIndex + i;\n                index %= samples;\n\n                ctx.fillStyle='#007700';\n                ctx.fillRect(i*factorX, height, 1, -(values[index])*factorY);\n            }\n\n            if (this.showCursor) {\n                index = (this.cursorIndex + samplesIndex) % samples;\n                str = '<span style=\"color:#007700\">&FilledSmallSquare;</span> ' + this.graph + ' Max: ' + Math.round(values[index]) +'</div>';\n            } else {\n                str = '<span style=\"color:#007700\">&FilledSmallSquare;</span> ' + this.graph + ' Max: ' + max +'</div>';\n                str += ' &nbsp Min: ' + min;\n                str += ' &nbsp Avrg: ' + Math.round(total / realCount) +'</div>';\n            }\n        }\n        break;\n\n\n    case 'LODs':\n        {\n            max = 0;\n            values = stats.graphsLODs;\n\n            for (i = 0; i < samples; i++) {\n                max = values[i][0] > max ? values[i][0] : max;\n            }\n\n            factorY = height / max;\n\n            ctx.fillStyle='#000000';\n            ctx.fillRect(0, 0, width, height);\n\n            var lods;\n\n            for (i = 0; i < samples; i++) {\n                index = samplesIndex + i;\n                index %= samples;\n\n                //ctx.fillStyle=\"#000000\";\n                //ctx.fillRect(i*factorX, height, 1, -(values[index][0])*factorY);\n\n                y = height;\n                \n                lods = values[index][1]; \n\n                for (j = 0, lj = lods.length; j < lj; j++) {\n                    if (lods[j]) {\n                        ctx.fillStyle='hsl('+((j*23)%360)+',100%,50%)';\n                        value = Math.round((lods[j])*factorY);\n                        ctx.fillRect(i*factorX, y, 1, -value);\n                        y -= value;\n                    }\n                }\n\n            }\n\n            if (this.showCursor) {\n                index = (this.cursorIndex + samplesIndex) % samples;\n\n                str = 'LODs:' + values[index][0];\n                lods = values[index][1]; \n\n                for (j = 0, lj = lods.length; j < lj; j++) {\n                    if (lods[j]) {\n                        str += '<span style=\"color:hsl('+((j*23)%360)+',100%,50%)\">&FilledSmallSquare;</span>'+j+':'+lods[j];\n                    }\n                }\n\n            } else {\n                str = 'LODs:' + values[index][0];\n            }\n\n            str += '</div>';\n        }\n        break;\n\n    case 'Flux':\n        {\n            var maxCount = 0;\n            var maxSize = 0;\n\n            var maxTexPlusCount = 0;\n            var maxTexPlusSize = 0;\n            var maxTexMinusCount = 0;\n            var maxTexMinusSize = 0;\n\n            var maxMeshPlusCount = 0;\n            var maxMeshPlusSize = 0;\n            var maxMeshMinusCount = 0;\n            var maxMeshMinusSize = 0;\n\n            var maxGeodataPlusCount = 0;\n            var maxGeodataPlusSize = 0;\n            var maxGeodataMinusCount = 0;\n            var maxGeodataMinusSize = 0;\n\n            valuesTextures = stats.graphsFluxTextures;\n            valuesMeshes = stats.graphsFluxMeshes;\n            valuesGeodata = stats.graphsFluxGeodatas;\n\n            for (i = 0; i < samples; i++) {\n                var tmp = valuesTextures[i][0][0] + valuesMeshes[i][0][0];\n                maxCount = tmp > maxCount ? tmp : maxCount;\n                tmp = valuesTextures[i][1][0] + valuesMeshes[i][1][0];\n                maxCount = tmp > maxCount ? tmp : maxCount;\n\n                tmp = valuesTextures[i][0][1] + valuesMeshes[i][0][1];\n                maxSize = tmp > maxSize ? tmp : maxSize;\n                tmp = valuesTextures[i][1][1] + valuesMeshes[i][1][1];\n                maxSize = tmp > maxSize ? tmp : maxSize;\n\n                maxTexPlusCount = valuesTextures[i][0][0] > maxTexPlusCount ? valuesTextures[i][0][0] : maxTexPlusCount;\n                maxTexPlusSize = valuesTextures[i][0][1] > maxTexPlusSize ? valuesTextures[i][0][1] : maxTexPlusSize;\n                maxTexMinusCount = valuesTextures[i][1][0] > maxTexMinusCount ? valuesTextures[i][1][0] : maxTexMinusCount;\n                maxTexMinusSize = valuesTextures[i][1][1] ? valuesTextures[i][1][1] : maxTexMinusSize;\n\n                maxMeshPlusCount = valuesMeshes[i][0][0] > maxMeshPlusCount ? valuesMeshes[i][0][0] : maxMeshPlusCount;\n                maxMeshPlusSize = valuesMeshes[i][0][1] > maxMeshPlusSize ? valuesMeshes[i][0][1] : maxMeshPlusSize;\n                maxMeshMinusCount = valuesMeshes[i][1][0] > maxMeshMinusCount ? valuesMeshes[i][1][0] : maxMeshMinusCount;\n                maxMeshMinusSize = valuesMeshes[i][1][1] > maxMeshMinusSize ? valuesMeshes[i][1][1] : maxMeshMinusSize;\n\n                maxGeodataPlusCount = valuesGeodata[i][0][0] > maxGeodataPlusCount ? valuesGeodata[i][0][0] : maxGeodataPlusCount;\n                maxGeodataPlusSize = valuesGeodata[i][0][1] > maxGeodataPlusSize ? valuesGeodata[i][0][1] : maxGeodataPlusSize;\n                maxGeodataMinusCount = valuesGeodata[i][1][0] > maxGeodataMinusCount ? valuesGeodata[i][1][0] : maxGeodataMinusCount;\n                maxGeodataMinusSize = valuesGeodata[i][1][1] > maxGeodataMinusSize ? valuesGeodata[i][1][1] : maxGeodataMinusSize;\n            }\n\n            factorY = (height*0.25-2) / maxCount;\n            var factorY2 = (height*0.25-2) / maxSize;\n\n            var base = Math.floor(height*0.25);\n            var base2 = Math.floor(height*0.75);\n\n            for (i = 0; i < samples; i++) {\n                index = samplesIndex + i;\n                index %= samples;\n                \n                var y1Up = base;\n                var y1Down = base+1;\n                var y2Up = base2;\n                var y2Down = base2+1;\n\n                ctx.fillStyle='#0000aa';\n                ctx.fillRect(i*factorX, y1Up, 1, -(valuesTextures[index][0][0])*factorY);\n                ctx.fillRect(i*factorX, y1Down, 1, (valuesTextures[index][1][0])*factorY);\n\n                ctx.fillRect(i*factorX, y2Up, 1, -(valuesTextures[index][0][1])*factorY2);\n                ctx.fillRect(i*factorX, y2Down, 1, (valuesTextures[index][1][1])*factorY2);\n\n                y1Up -= (valuesTextures[index][0][0])*factorY;\n                y1Down += (valuesTextures[index][1][0])*factorY;\n                y2Up -= (valuesTextures[index][0][1])*factorY2;\n                y2Down += (valuesTextures[index][1][1])*factorY2;\n\n                ctx.fillStyle='#007700';\n                ctx.fillRect(i*factorX, y1Up, 1, -(valuesMeshes[index][0][0])*factorY);\n                ctx.fillRect(i*factorX, y1Down, 1, (valuesMeshes[index][1][0])*factorY);\n\n                ctx.fillRect(i*factorX, y2Up, 1, -(valuesMeshes[index][0][1])*factorY2);\n                ctx.fillRect(i*factorX, y2Down, 1, (valuesMeshes[index][1][1])*factorY2);\n\n                y1Up -= (valuesMeshes[index][0][0])*factorY;\n                y1Down += (valuesMeshes[index][1][0])*factorY;\n                y2Up -= (valuesMeshes[index][0][1])*factorY2;\n                y2Down += (valuesMeshes[index][1][1])*factorY2;\n\n                ctx.fillStyle='#009999';\n                ctx.fillRect(i*factorX, y1Up, 1, -(valuesGeodata[index][0][0])*factorY);\n                ctx.fillRect(i*factorX, y1Down, 1, (valuesGeodata[index][1][0])*factorY);\n\n                ctx.fillRect(i*factorX, y2Up, 1, -(valuesGeodata[index][0][1])*factorY2);\n                ctx.fillRect(i*factorX, y2Down, 1, (valuesGeodata[index][1][1])*factorY2);\n\n                ctx.fillStyle='#aaaaaa';\n                ctx.fillRect(0, Math.floor(height*0.5), width, 1);\n                ctx.fillStyle='#dddddd';\n                ctx.fillRect(0, base, width, 1);\n                ctx.fillRect(0, base2, width, 1);\n            }\n\n\n            if (this.showCursor) {\n                index = (this.cursorIndex + samplesIndex) % samples;\n                str = '<span style=\"color:#007700\">&FilledSmallSquare;</span> Textures Count +/-: ' + valuesTextures[index][0][0] + '/' + valuesTextures[index][1][0];\n                str += ' &nbsp Size +/-: ' + (valuesTextures[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesTextures[index][1][1]/1024/1024).toFixed(2);\n                str += ' &nbsp <span style=\"color:#0000aa\">&FilledSmallSquare;</span> Meshes Count +/-: ' + valuesMeshes[index][0][0] + '/' + valuesMeshes[index][1][0];\n                str += ' &nbsp Size +/-: ' + (valuesMeshes[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesMeshes[index][1][1]/1024/1024).toFixed(2);\n                str += ' &nbsp <span style=\"color:#009999\">&FilledSmallSquare;</span> Geodata Count +/-: ' + valuesGeodata[index][0][0] + '/' + valuesGeodata[index][1][0];\n                str += ' &nbsp Size +/-: ' + (valuesGeodata[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesGeodata[index][1][1]/1024/1024).toFixed(2);\n                str += '</div>';\n            } else {\n                str = '<span style=\"color:#007700\">&FilledSmallSquare;</span> Textures Count +/-: ' + maxTexPlusCount + '/' + maxTexMinusCount;\n                str += ' &nbsp Size +/-: ' + (maxTexPlusSize/1024/1024).toFixed(2) + '/' + (maxTexMinusSize/1024/1024).toFixed(2);\n                str += ' &nbsp <span style=\"color:#0000aa\">&FilledSmallSquare;</span> Meshes Count +/-: ' + maxMeshPlusCount + '/' + maxMeshMinusCount;\n                str += ' &nbsp Size +/-: ' + (maxMeshPlusSize/1024/1024).toFixed(2) + '/' + (maxMeshMinusSize/1024/1024).toFixed(2);\n                str += ' &nbsp <span style=\"color:#009999\">&FilledSmallSquare;</span> Geodata Count +/-: ' + maxGeodataPlusCount + '/' + maxGeodataMinusCount;\n                str += ' &nbsp Size +/-: ' + (maxGeodataPlusSize/1024/1024).toFixed(2) + '/' + (maxGeodataMinusSize/1024/1024).toFixed(2);\n                str += '</div>';\n            }\n\n        }\n        break;\n\n    }\n\n    if (this.showCursor) {\n        ctx.fillStyle='#aa00aa';\n        index = (this.cursorIndex) % samples;\n        ctx.fillRect(Math.floor(index*factorX)-1, 0, 1, height);\n        ctx.fillRect(Math.floor(index*factorX)+1, 0, 1, height);\n    }\n\n    document.getElementById('vts-graphs-info2').innerHTML = str;\n};\n\n\nexport default InspectorGraphs;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/inspector/graphs.js\n// module id = 118\n// module chunks = 0 1","\n\nvar InspectorInput = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorInput.prototype.init = function() {\n    //mouse events\n    //document.addEventListener(\"click\", this.onKeyClick.bind(this), false);\n\n    //keyboard events\n    document.addEventListener('keyup', this.onKeyUp.bind(this), false);\n    document.addEventListener('keypress', this.onKeyPress.bind(this), false);\n    document.addEventListener('keydown', this.onKeyDown.bind(this), false);\n};\n\n\n//keyboard events\nInspectorInput.prototype.onKeyDown = function(event) {\n    if (typeof event == 'undefined') {\n        event = window.event;\n    }\n\n    this.altDown = event.altKey;\n    this.ctrlDown = event.ctrlKey;\n    this.shiftDown = event.shiftKey;\n\n    this.onKeyUp(event, true);\n};\n\n\nInspectorInput.prototype.onKeyPress = function(event) {\n    this.onKeyUp(event, true);\n};\n\n\nInspectorInput.prototype.onKeyUp = function(event, press) {\n    if (typeof event == 'undefined') {\n        event = window.event;\n    }\n\n    var map = this.core.getMap();\n    var inspector = this.inspector;\n\n    if (!map) {\n        return;\n    }\n\n    var debug = map.draw.debug;\n\n    this.altDown = event.altKey;\n    this.ctrlDown = event.ctrlKey;\n    this.shiftDown = event.shiftKey;\n\n    var hit = false;\n    var blockHit = true;\n\n    if (event) {\n        var keyCode;\n\n        if (window.event) {         // eg. IE\n            keyCode = window.event.keyCode;\n        } else if (event.which) {   // eg. Firefox\n            keyCode = event.which;\n        } else {\n            keyCode = event.charCode;\n        }\n\n        if (this.shiftDown) {\n            if (this.ctrlDown) {\n                switch(keyCode) {\n                case 68:\n                case 100:\n                    inspector.preventDefault(event); break;  //key D pressed\n                }\n            }\n        }\n\n        if (this.shiftDown && press !== true) {\n\n            switch(keyCode) {\n            case 76:\n            case 108:\n                /*this.showMenu(); this.toolbarItemSelected('link'); done();*/  break;  //key L pressed\n\n            case 71:\n            case 103:\n                /*this.showMenu(); this.toolbarItemSelected('position'); done();*/ break; //key G pressed\n            }\n\n            if (this.ctrlDown) {\n\n                switch(keyCode) {\n                case 68:\n                case 100:\n                    \n                    inspector.enableInspector();\n                    this.diagnosticMode = true; hit = true; break;  //key D pressed\n                }\n            }\n\n            if (this.diagnosticMode) {\n                blockHit = true;\n\n                switch(keyCode) {\n\n                case 67:\n                case 99:\n                    map.config.mapDegradeHorizon = !map.config.mapDegradeHorizon;\n\n                        //this.measureMode = !this.measureMode;\n                        //this.measurePoints = [];\n                        //var pos = this.core.hitTest(this.mouseX, this.mouseY, \"all\");\n                        //console.log(\"hit pos: \" + pos[0] + \" \" + pos[1] + \" \" + pos[2] + \" \" + pos[3] + \" d \" + pos[4]); //key T pressed\n\n                    break; //key C pressed\n\n                case 49: /*this.core.setControlMode(\"manual\"); done();*/  break;  //key 1 pressed\n                case 50: /*this.core.setControlMode(\"drone\"); done();*/   break;  //key 2 pressed\n                case 51: /*this.core.setControlMode(\"observer\"); done();*/ break; //key 3 pressed\n\n                case 48:  //key 0 pressed\n                        /*this.core.setOption(\"noForwardMovement\" , !this.core.getOption(\"noForwardMovement\"));*/\n                    break;\n\n                    //case 84: //key T pressed\n                    //case 116:\n                        /*var pos = this.core.hitTest(this.mouseX, this.mouseY, \"all\");\n                        console.log(\"hit pos: \" + pos[0] + \" \" + pos[1] + \" \" + pos[2] + \" \" + pos[3] + \" d \" + pos[4]); //key T pressed\n                        this.core.logTile(pos);*/\n                        //break;\n\n                case 72:\n                case 104:\n                    debug.heightmapOnly = !debug.heightmapOnly;\n\n                        /*\n                        var pos = map.getPosition();\n                        pos.setHeight(pos.setHeight() * 0.9);\n                        map.setPosition(pos);*/\n\n                    break;  //key H pressed\n\n                case 81:\n                case 113:\n                    var pos = map.getPosition();\n                    // eslint-disable-next-line\n                    console.log('pos-before: ' + JSON.stringify(pos.pos));\n                    map.convert.convertPositionViewMode(pos, (pos.getViewMode() == 'obj') ? 'subj' : 'obj');\n                    // eslint-disable-next-line\n                    console.log('new mode: ' + pos.getViewMode());\n                    // eslint-disable-next-line\n                    console.log('pos-after: ' + JSON.stringify(pos.pos));\n                    map.setPosition(pos);\n                    /*this.core.saveScreenshot(pos);*/\n\n                    if (this.altDown && pos.getViewMode() != 'obj') {\n                        map.camera.near = 0.1;\n                    } else {\n                        map.camera.near = 2;\n                    }\n\n                    inspector.preventDefault(event);\n\n                    break;  //key Q pressed\n\n                case 80:\n                case 112:\n                    map.renderer.saveScreenshot('file', 'vts-screenshot.png', 'png'); break;  //key P pressed\n\n                case 83:\n                case 115:\n                    inspector.stats.switchPanel(); break; //key S pressed\n\n                case 86:\n                case 118:\n                    inspector.layers.switchPanel(); break; //key V pressed\n\n                case 69:\n                case 101:\n                    inspector.stylesheets.switchPanel(); break; //key E pressed\n\n                case 84:\n                case 116:\n                    inspector.replay.switchPanel(); break; //key T pressed\n\n                case 66:\n                case 98:\n                    debug.drawBBoxes = !debug.drawBBoxes; break; //key B pressed\n\n                case 65:\n                case 97:\n                    debug.drawLabelBoxes = !debug.drawLabelBoxes; break; //key A pressed\n\n                case 75:\n                case 107:\n                   debug.drawAllLabels = !debug.drawAllLabels; break; //key K pressed\n\n                case 73:\n                case 105:\n                    debug.drawGridCells = !debug.drawGridCells; break; //key I pressed\n\n                case 87:\n                case 119:\n                    var value = debug.drawWireframe + 1;\n                    debug.drawWireframe = value > 2 ? 0 : value;\n                    break; //key W pressed\n\n                case 70:\n                case 102:\n                    debug.drawWireframe = debug.drawWireframe != 3 ? 3 : 0;\n                    break; //key F pressed\n\n                case 77:\n                case 109:\n                    map.loaderSuspended = !map.loaderSuspended;            \n                    // eslint-disable-next-line\n                    console.log('loader state ' + map.loaderSuspended);\n\n                    break; //key M pressed\n\n                case 74:\n                case 106:\n                    debug.drawEarth = !debug.drawEarth; hit = true; break; //key J pressed\n\n                case 88:\n                case 120:\n                    debug.drawFog = !debug.drawFog; hit = true; break; //key X pressed\n\n                case 82:\n                case 114:\n                    inspector.graphs.switchPanel(); break; //key R pressed\n\n                case 79:\n                case 111:\n                    map.camera.camera.setOrtho(!map.camera.camera.getOrtho()); break; //key O pressed\n\n                case 76:\n                case 108:\n                    inspector.drawRadar = !inspector.drawRadar; break; //key L pressed\n\n                case 90:\n                case 122:\n                    debug.maxZoom = !debug.maxZoom; break; //key Z pressed\n\n                case 78:\n                case 110:\n                    inspector.shakeCamera = !inspector.shakeCamera; break; //key N pressed\n\n                default:\n                    blockHit = false;\n                    break;\n\n                }\n\n                if (blockHit) {\n                    hit = true;\n                }\n            }\n        }\n\n        if (this.diagnosticMode && debug.drawWireframe && !press) {\n            if (keyCode >= 96 && keyCode <= 105) {\n                if (this.altDown) {\n                    debug.drawTestData = keyCode - 96;\n                    if (this.ctrlDown) {\n                        debug.drawTestData += 10;\n                    }\n                } else {\n                    debug.drawTestMode = keyCode - 96;\n                }\n\n                hit = true;\n            } \n        }\n\n        if (this.diagnosticMode && inspector.drawRadar && !this.shiftDown && !press) {\n            blockHit = true;\n\n            switch(keyCode) {\n            case 43:\n            case 107:\n                if (inspector.radarLod == null) { inspector.radarLod = 8;}\n                inspector.radarLod++; /*console.log(\"radarLOD: \" + this.radarLod);*/ break; //key mun + pressed\n\n            case 45:\n            case 109:\n                if (inspector.radarLod == null) { inspector.radarLod = 8;}\n                inspector.radarLod = Math.max(0,inspector.radarLod-1); /*console.log(\"radarLOD: \" + this.radarLod);*/ break; //key mun - pressed\n\n            case 42:\n            case 106:\n                inspector.radarLod = null; /*console.log(\"radarLOD: auto\");*/ break; //key mun * pressed\n\n            default:\n                blockHit = false;\n                break;\n            }\n\n            if (blockHit) {\n                hit = true;\n            }\n        }\n\n        if (this.diagnosticMode && debug.drawBBoxes && !this.shiftDown && !press) {\n            blockHit = true;\n\n            switch(keyCode) {\n            case 76:\n            case 108:\n                debug.drawLods = !debug.drawLods; break; //key L pressed\n\n            case 80:\n            case 112:\n                debug.drawPositions = !debug.drawPositions; break; //key P pressed\n\n            case 84:\n            case 116:\n                debug.drawTextureSize = !debug.drawTextureSize; break; //key T pressed\n\n            case 70:\n            case 102:\n                debug.drawFaceCount = !debug.drawFaceCount; break; //key F pressed\n\n            case 71:\n            case 103:\n                debug.drawGeodataOnly = !debug.drawGeodataOnly; break; //key G pressed\n\n            case 68:\n            case 100:\n                debug.drawDistance = !debug.drawDistance; break; //key D pressed\n\n            case 78:\n            case 110:\n                debug.drawNodeInfo = !debug.drawNodeInfo; break; //key N pressed\n\n            case 77:\n            case 109:\n                debug.drawMeshBBox = !debug.drawMeshBBox; break; //key M pressed\n\n            case 73:\n            case 105:\n                debug.drawIndices = !debug.drawIndices; break; //key I pressed\n\n            case 66:\n            case 98:\n                debug.drawBoundLayers = !debug.drawBoundLayers; break; //key B pressed\n\n            case 83:\n            case 115:\n                debug.drawSurfaces = !debug.drawSurfaces; break; //key S pressed\n\n            case 67:\n            case 99:\n                debug.drawCredits = !debug.drawCredits; break; //key C pressed\n\n            case 79:\n            case 111:\n                debug.drawOrder = !debug.drawOrder; break; //key O pressed\n\n            case 69:\n            case 101:\n                debug.debugTextSize = (debug.debugTextSize == 2.0) ? 3.0 : 2.0; break; //key E pressed\n\n            case 88:\n            case 120:\n                map.config.mapPreciseBBoxTest = !map.config.mapPreciseBBoxTest; break; //key X pressed\n\n            case 90:\n            case 122:\n                map.config.mapPreciseDistanceTest = !map.config.mapPreciseDistanceTest; break; //key Z pressed\n\n            case 75:\n            case 107:\n                debug.drawGPixelSize = !debug.drawGPixelSize; break; //key K pressed\n\n            default:\n                blockHit = false;\n                break;\n            }\n\n            if (blockHit) {\n                hit = true;\n            }\n        }\n\n    }\n\n    if (hit) {\n        map.markDirty();\n        inspector.preventDefault(event);\n    }\n\n    //console.log(\"key\" + keyCode);\n};\n\n\nInspectorInput.prototype.setParameter = function(key, value) {\n    var map = this.core.getMap();\n    var inspector = this.inspector;\n\n    if (!map) {\n        return;\n    }\n\n    var debug = map.draw.debug;\n    var getBool = (function(a){ return (value === true || value == 'true' || value == '1') });\n\n    switch(key) {\n        case 'debugBBox':\n            debug.drawBBoxes = true;\n            var has = (function(a){ return (value.indexOf(a)!=-1); });\n            if (has('L')) debug.drawLods = true;\n            if (has('P')) debug.drawPositions = true;\n            if (has('T')) debug.drawTextureSize = true;\n            if (has('F')) debug.drawFaceCount = true;\n            if (has('G')) debug.drawGeodataOnly = true;\n            if (has('D')) debug.drawDistance = true;\n            if (has('N')) debug.drawNodeInfo = true;\n            if (has('M')) debug.drawMeshBBox = true;\n            if (has('I')) debug.drawIndices = true;\n            if (has('B')) debug.drawBoundLayers = true;\n            if (has('S')) debug.drawSurfaces = true;\n            if (has('C')) debug.drawCredits = true;\n            if (has('O')) debug.drawOrder = true;\n            if (has('E')) debug.debugTextSize = 3.0;\n            if (has('K')) debug.drawGPixelSize = true;\n            break;\n        case 'debugLBox': debug.drawLabelBoxes = getBool(value); break;\n        case 'debugNoEarth': debug.drawEarth = !getBool(value); break;\n        case 'debugShader': debug.drawWireframe = parseInt(value); break;\n        case 'debugHeightmap': debug.heightmapOnly = getBool(value); break;\n        case 'debugGridCells': debug.drawGridCells = getBool(value); break;\n        case 'debugRadar':\n            inspector.enableInspector();\n            inspector.drawRadar = true;\n            inspector.radarLod = parseInt(value);\n            if (isNaN(inspector.radarLod)) {\n                inspector.radarLod = null;\n            } \n            break;\n\n    }\n\n    map.markDirty();\n};\n\nexport default InspectorInput;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/inspector/input.js\n// module id = 119\n// module chunks = 0 1","\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport {utils as utils_} from '../utils/utils';\nimport InspectorInput_ from './input';\nimport InspectorStats_ from './stats';\nimport InspectorGraphs_ from './graphs';\nimport InspectorLayers_ from './layers';\nimport InspectorReplay_ from './replay';\nimport InspectorStylesheets_ from './stylesheets';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\nvar math = math_;\nvar utils = utils_;\nvar InspectorInput = InspectorInput_;\nvar InspectorStats = InspectorStats_;\nvar InspectorGraphs = InspectorGraphs_;\nvar InspectorLayers = InspectorLayers_;\nvar InspectorReplay = InspectorReplay_;\nvar InspectorStylesheets = InspectorStylesheets_;\n\n\nvar Inspector = function(core) {\n    this.core = core;\n    this.enabled = false;\n    this.input = new InspectorInput(this);\n    this.stats = new InspectorStats(this);\n    this.graphs = new InspectorGraphs(this);\n    this.layers = new InspectorLayers(this);\n    this.replay = new InspectorReplay(this);\n    this.stylesheets = new InspectorStylesheets(this);\n\n    if (this.core.config.inspector) {\n        this.input.init();\n    }\n\n    this.shakeCamera = false; \n    this.drawReplayCamera = false; \n    this.drawRadar = false;\n    this.radarLod = null;\n    this.debugValue = 0;\n    this.measureMode = false;\n    this.measurePoints = [];\n};\n\n\nInspector.prototype.enableInspector = function() {\n    if (!this.enabled) {\n        this.stats.init();\n        this.graphs.init();\n        this.layers.init();\n        this.replay.init();\n        this.stylesheets.init();\n\n        //load image    \n        if (!this.circleImage) {\n            this.circleImage = utils.loadImage(\n                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QAAAAAAAD5Q7t/AAAACW9GRnMAAAAgAAAA4ACD+EAUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVRYw+2VPwqDMBTG3dz1Am56EnH2XLroETxGuwc3Z7cOdhY8QJpfSUBspUvStJAPPggvD973/uQligICAgL+DKViqygUV02hbaXLwJlio7gpyhNu2idzEXwwgfI8H+u6vnZdN/V9P3EuimLcCRlsiyArGcfxjWDLsmzyAGzc4aNFNDZ7/iw7AeQH4LNrh5WZYLgkJTaZCyHuVVVdkiSZ0zSdOWMzlaBFWkRrQ4A4Zk/A4wBie1MFYUMAz0wybCYAmR8FUAlzj6+2r18TgM2VAO8tOB1Cyk7mrofQ+zP0voheVjHtIBjDxjrmvCu7k1Xs/TP6ie84ICDAGR5uCYdPo0MWiAAAAABJRU5ErkJggg==',\n                    //\"http://maps.google.com/mapfiles/kml/shapes/placemarkcircle.png\",\n                    (function(){\n                        this.circleTexture = this.core.getRendererInterface().createTexture({ 'source': this.circleImage });\n                    }).bind(this)\n                );\n        }\n\n        this.core.on('map-update', this.onMapUpdate.bind(this));\n        this.enabled = true;\n    }\n};\n\n\nInspector.prototype.setParameter = function(key, value) {\n    this.input.setParameter(key, value);\n};\n\nInspector.prototype.addStyle = function(string) {\n    var style = document.createElement('style');\n    style.type = 'text/css';\n    style.innerHTML = string;\n    document.getElementsByTagName('head')[0].appendChild(style);\n};\n\n\n//used to block mouse events\nInspector.prototype.doNothing = function(e) {\n    e.stopPropagation();\n    return false;\n};\n\n\nInspector.prototype.preventDefault = function(e) {\n    if (e.preventDefault) {\n        e.preventDefault();\n    } else {\n        e.returnValue = false;\n    }\n};\n\n\nInspector.prototype.onMapUpdate = function() {\n    var map = this.core.getMapInterface();\n    if (!map) {\n        return;\n    }\n\n    if (this.shakeCamera) {\n        map.redraw();\n    } \n\n    /*if (this.measureMode) {\n        var renderer = this.core.getRenderer();\n        var p = map.convertCoordsFromPhysToNav(this.measurePoints[0]);\n        map.convertCoordsFromPhysToCanvas(this.measurePoints[0]);\n    }*/\n\n    var renderer = this.core.getRendererInterface(), i, li, j, lj, lines, slines, p;\n\n    if (this.replay.drawGlobe) {\n        p = map.convertCoordsFromPhysToCameraSpace([0,0,0]);\n        var renderer2 = this.core.getRenderer();\n        renderer2.draw.drawTBall(p, 12742000 * 0.5, renderer2.progStardome, this.replay.globeTexture, 12742000 * 0.5, true);\n    }\n\n    if (this.replay.drawCamera) {\n        lines = this.replay.cameraLines;\n        slines = []; \n        for (i = 0, li = lines.length; i < li; i++) {\n            slines.push(map.convertCoordsFromPhysToCanvas(lines[i]));\n        }\n        \n        renderer.drawLineString({\n            points : slines,\n            size : 2.0,\n            screenSpace : true,\n            color : [0,128,255,255],\n            depthTest : false,\n            blend : false\n        });            \n\n        lines = this.replay.cameraLines3;\n        for (i = 0, li = lines.length; i < li; i++) {\n            slines = []; \n            for (j = 0, lj = lines[i].length; j < lj; j++) {\n                slines.push(map.convertCoordsFromPhysToCanvas(lines[i][j]));\n            }\n\n            renderer.drawLineString({\n                points : slines,\n                size : 2.0,\n                screenSpace : true,\n                color : [0,255,128,255],\n                depthTest : false,\n                blend : false\n            });   \n        }\n\n        lines = this.replay.cameraLines2;\n        for (i = 0, li = lines.length; i < li; i++) {\n            slines = []; \n            for (j = 0, lj = lines[i].length; j < lj; j++) {\n                slines.push(map.convertCoordsFromPhysToCanvas(lines[i][j]));\n            }\n\n            renderer.drawLineString({\n                points : slines,\n                size : 2.0,\n                screenSpace : true,\n                color : [0,255,255,255],\n                depthTest : false,\n                blend : false\n            });   \n        }\n\n\n        var cameInfo = map.getCameraInfo();\n        var p1 = map.convertCoordsFromPhysToCameraSpace(this.replay.cameraLines[0]);\n\n        //var map2 = this.core.getMap();\n    \n        //var m2 = map2.camera.getRotationviewMatrix();\n        var mv = mat4.create(this.replay.cameraMatrix);\n        //mat4.inverse(m2, mv);\n    \n        //matrix which tranforms mesh position and scale\n        /*\n        var mv = [\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            p1[0], p1[1], p1[2], 1\n        ];*/\n        mv[12] = p1[0];\n        mv[13] = p1[1];\n        mv[14] = p1[2];\n    \n        //setup material \n        var material = [ \n            255,128,128, 0, //ambient,\n            0,0,0,0, //diffuse\n            0,0,0,0, //specular \n            0,0.5,0,0 //shininess, alpha,0,0\n        ];\n    \n        //multiply cube matrix with camera view matrix\n        mat4.multiply(cameInfo.viewMatrix, mv, mv);\n    \n        var norm = [\n            0,0,0,\n            0,0,0,\n            0,0,0\n        ];\n    \n        //normal transformation matrix\n        mat4.toInverseMat3(mv, norm);\n    \n        renderer.setState(this.replay.frustumState);\n    \n        //draw cube\n        renderer.drawMesh({\n            mesh : this.replay.frustumMesh,\n            texture : null,\n            shader : 'shaded',\n            shaderVariables : {\n                'uMV' : ['mat4', mv],\n                'uNorm' : ['mat3', norm],\n                'uMaterial' : ['mat4', material]\n            }\n        });\n    }\n    \n    if (this.drawRadar && this.circleTexture) {\n        //var renderer = this.core.getRendererInterface();\n        var pos = map.getPosition();\n        var count = 16;\n        var step = pos.getViewExtent() / (count * 4);\n\n        var cbuffer = new Array(count * count);\n\n/*        \n        var coords = pos.getCoords();\n\n        for (var j = 0; j < count; j++) {\n            for (var i = 0; i < count; i++) {\n                var screenCoords = map.convertCoordsFromNavToCanvas([coords[0] + i*step - count*0.5*step,\n                                                                       coords[1] + j*step - count*0.5*step, 0], \"float\", this.radarLod);\n        \n                cbuffer[j * count + i] = screenCoords;\n            }            \n        }\n*/\n\n\n        for (j = 0; j < count; j++) {\n            for (i = 0; i < count; i++) {\n                var dx =  i*step - count*0.5*step;\n                var dy =  j*step - count*0.5*step;\n                var a = Math.atan2(dy, dx);\n                var l = Math.sqrt(dx*dx + dy*dy);\n\n                var pos2 = map.movePositionCoordsTo(pos, math.degrees(a), l);\n                var coords = pos2.getCoords();\n                \n                var screenCoords = map.convertCoordsFromNavToCanvas([coords[0], coords[1], 0], 'float', this.radarLod);\n\n                cbuffer[j * count + i] = screenCoords;\n            }            \n        }\n\n\n        var lbuffer = new Array(count);\n\n        for (j = 0; j < count; j++) {\n            for (i = 0; i < count; i++) {\n                lbuffer[i] =  cbuffer[j * count + i];\n            }\n            \n            renderer.drawLineString({\n                points : lbuffer,\n                size : 2.0,\n                screenSpace : true,\n                color : [0,255,255,255],\n                depthTest : false,\n                blend : false\n            });            \n        }\n\n\n        for (i = 0; i < count; i++) {\n            for (j = 0; j < count; j++) {\n                lbuffer[j] =  cbuffer[j * count + i];\n            }\n            \n            renderer.drawLineString({\n                points : lbuffer,\n                size : 2.0,\n                screenSpace : true,\n                color : [0,255,255,255],\n                depthTest : false,\n                blend : false\n            });            \n        }\n\n        for (i = 0, li = cbuffer.length; i < li; i++) {\n            p = cbuffer[i];\n            renderer.drawImage({\n                rect : [p[0]-10, p[1]-10, 20, 20],\n                texture : this.circleTexture,\n                color : [255,0,255,255],\n                depth : p[2],\n                depthTest : false,\n                blend : true\n            });\n        }\n    }\n};\n\n\nexport default Inspector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/inspector/inspector.js\n// module id = 120\n// module chunks = 0 1","\nvar InspectorLayers = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorLayers.prototype.init = function() {\n    var inspector = this.inspector;\n    inspector.addStyle(\n        '#vts-layers-panel {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'display: none;'\n            + 'padding:15px;'\n            + 'font-size: 14px;'\n            + 'position: absolute;'\n            + 'right: 10px;'\n            + 'bottom: 10px;'\n            + 'cursor: default;'\n            + 'background-color: rgba(255,255,255,0.95);'\n            + 'border-radius: 5px;'\n            + 'border: solid 1px #ccc;'\n            + 'text-align: left;'\n            + 'z-index: 7;'\n            + 'padding: 10px;'\n        + '}'\n\n        + '#vts-layers-panel button {'\n            + 'max-width: 23px;'\n            + 'max-height: 21px;'\n        + '}'\n\n        + '#vts-layers-panel-title {'\n            + 'margin-bottom: 3px;'\n        + '}'\n\n        + '#vts-layers-views-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-layers-views-items {'\n            + 'width: 191px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border: 1px solid #ddd;'\n        + '}'\n        \n        + '#vts-layers-surfaces-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'        \n        \n        + '#vts-layers-surfaces-items {'\n            + 'width: 150px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border-top: 1px solid #ddd;'\n            + 'border-bottom: 1px solid #ddd;'\n        + '}'\n         \n        + '#vts-layers-boundlayers-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-layers-boundlayers-items {'\n            + 'width: 250px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border: 1px solid #ddd;'\n            + 'border-right: none;'\n        + '}'\n\n        + '#vts-layers-freelayers-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-layers-freelayers-items {'\n            + 'width: 150px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border: 1px solid #ddd;'\n        + '}'\n\n        + '#vts-layers-fl-properties-panel {'\n            + 'margin-top: 5px;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-layers-fl-properties-items {'\n            + 'width: 250px;'\n            + 'overflow-y: scroll;'\n            + 'overflow-x: hidden;'\n            + 'height: 200px;'\n            + 'border: 1px solid #ddd;'\n            + 'border-right: none;'\n        + '}'\n\n        + '#vts-layers-json-panel {'\n            + 'margin-top: 5px;'\n            + 'float: right;'\n        + '}'\n\n        + '#vts-layers-json-text {'\n            + 'width: 200px;'\n            + 'resize: none;'\n            + 'height: 180px;'\n            + 'border: 1px solid #ddd;'\n            + 'white-space: pre;'\n            + 'padding: 0px;'\n        + '}'\n\n        + '#vts-layers-json-text2 {'\n            + 'width: 200px;'\n            + 'height: 21px;'\n            + 'border: 1px solid #ddd;'\n        + '}'\n        \n        + '.vts-layers-panel-title {'\n            + 'margin: 0px;'\n            + 'margin-bottom: 5px;'\n        + '}'\n\n        + '.vts-layers-item {'\n            + 'width: 100%;'\n        + '}'        \n        \n        + '.vts-layers-item input[type=number]{'\n            + 'width: 43px;'\n        + '}'\n        \n        + '.vts-layers-name {'\n            + 'width: 120px;'\n            + 'display: inline-block;'\n            + 'overflow: hidden;'\n            + 'text-overflow: ellipsis;'\n            + 'white-space: nowrap;'       \n        + '}'          \n\n        + '.vts-layers-name2 {'\n            + 'width: 126px;'\n            + 'display: inline-block;'\n            + 'overflow: hidden;'\n            + 'text-overflow: ellipsis;'\n            + 'white-space: nowrap;'       \n        + '}'\n         \n        + '#vts-layers-fl-properties-style {'\n            + 'width: 175px;'\n            + 'height: 21px;'\n        + '}'\n\n        + '.vts-surface-item {'\n            + 'width: 100%;'\n            + 'overflow: hidden;'\n            + 'text-overflow: ellipsis;'\n            + 'white-space: nowrap;'    \n        + '}' \n        \n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-layers-panel';\n    this.element.innerHTML = ''\n        + '<div id=\"vts-layers-views-panel\"><p class=\"vts-layers-panel-title\">Named Views:</p>'\n           + '<div id=\"vts-layers-views-items\"></div></div>'\n        + '<div id=\"vts-layers-surfaces-panel\"><p class=\"vts-layers-panel-title\">Surfaces:</p>'\n           + '<div id=\"vts-layers-surfaces-items\"></div></div>'\n        + '<div id=\"vts-layers-boundlayers-panel\"><p class=\"vts-layers-panel-title\">Surface Bound Layers:</p>'\n           + '<div id=\"vts-layers-boundlayers-items\"></div></div>'\n        + '<div id=\"vts-layers-freelayers-panel\"><p class=\"vts-layers-panel-title\">Free Layers:</p>'\n           + '<div id=\"vts-layers-freelayers-items\"></div></div>'\n        + '<div id=\"vts-layers-fl-properties-panel\"><p class=\"vts-layers-panel-title\">Free Layer Properties:</p>'\n           + '<div id=\"vts-layers-fl-properties-items\"></div></div>'\n        + '<div id=\"vts-layers-json-panel\"><p class=\"vts-layers-panel-title\">Definition:</p>'\n           + '<textarea id=\"vts-layers-json-text\" cols=\"48\"></textarea><br/>'\n           + '<input id=\"vts-layers-json-text2\" type=\"text\"></div>';\n\n    this.core.element.appendChild(this.element);\n    this.viewItems = document.getElementById('vts-layers-views-items');\n    this.surfacesItems = document.getElementById('vts-layers-surfaces-items');\n    this.boundLayersItems = document.getElementById('vts-layers-boundlayers-items');\n    this.freeLayersItems = document.getElementById('vts-layers-freelayers-items');\n    this.freeLayersPropertiesItems = document.getElementById('vts-layers-fl-properties-items');\n    this.jsonText = document.getElementById('vts-layers-json-text');\n    this.jsonText2 = document.getElementById('vts-layers-json-text2');\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.views = [];\n    \n    this.panelVisible = false;\n    this.panelInitialized = false;\n    this.currentView = '';\n    this.currentSurface = '';\n    this.currentFreeLayer = '';\n};\n\n\nInspectorLayers.prototype.initViews = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var views = map.getNamedViews(), freeLayer;\n    var id = '--initial--';\n    var i, li, j, lj, layers, states, index, view, surfaces, skey;\n\n\n    this.views[id] = {\n        surfaces : {},\n        freeLayers : {},\n        original : JSON.parse(JSON.stringify(map.getView()))\n    };\n\n    for (i = 0, li = views.length; i < li; i++) {\n        view = views[i];\n        this.views[view] = {\n            surfaces : {},\n            freeLayers : {},\n            original : JSON.parse(JSON.stringify(map.getNamedView(view).getInfo()))\n        };\n    }\n    \n    this.currentView = id;\n    views = this.views;\n    \n    for (var key in views) {\n        view = views[key];\n        surfaces = map.getSurfaces();   \n        \n        for (i = 0, li = surfaces.length; i < li; i++) {\n            id = surfaces[i];\n            surface = map.getSurface(id);\n            layers = map.getBoundLayers();\n            states = []; \n    \n            for (j = 0, lj = layers.length; j < lj; j++) {\n                //layer = map.getBoundLayerById(layers[j]);\n                \n                states.push({\n                    id : layers[j],\n                    alpha : 100,\n                    enabled : false\n                });\n            }\n            \n            view.surfaces[id] = {\n                enabled : false,\n                layers : states \n            };\n        }         \n\n        var freeLayers = map.getFreeLayers();   \n        \n        for (i = 0, li = freeLayers.length; i < li; i++) {\n            id = freeLayers[i];\n            layers = map.getBoundLayers();\n            states = []; \n    \n            for (j = 0, lj = layers.length; j < lj; j++) {\n                //layer = map.getBoundLayerById(layers[j]);\n                \n                states.push({\n                    id : layers[j],\n                    alpha : 100,\n                    enabled : false\n                });\n            }\n            \n            freeLayer = map.getFreeLayer(id);\n            var freeLayerInfo = freeLayer.getInfo(); \n            \n            view.freeLayers[id] = {\n                enabled : false,\n                style : null,\n                originalStyle : freeLayerInfo['style'],\n                depthShift : 0,\n                depthShift2 : 0,\n                depthShift3 : 0,\n                layers : states \n            };\n        }\n        \n        var viewSurfaces = view.original['surfaces'];\n        \n        for (skey in viewSurfaces) {\n            layers = viewSurfaces[skey];\n            \n            if (view.surfaces[skey]) {\n                var surface = view.surfaces[skey]; \n                surface.enabled = true;\n\n                for (i = 0, li = layers.length; i < li; i++) {\n                    if (typeof layers[i] === 'string') {\n                        index = this.findIdInArray(surface.layers, layers[i]);\n                        if (index != -1 && surface.layers[index]) {\n                            surface.layers[index].enabled = true;\n                            surface.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);\n                        }    \n                    } else {\n                        id = layers[i]['id'];\n                        index = this.findIdInArray(surface.layers, id);\n                        if (index != -1 && surface.layers[index]) {\n                            surface.layers[index].enabled = true;\n                            surface.layers[index].alpha = layers[i]['alpha'] ? (parseFloat(layers[i]['alpha'])*100) : 100;\n                            surface.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);\n                        }    \n                    }\n                }\n            }\n        }\n\n        var viewfreeLayers = view.original['freeLayers'];\n        \n        for (skey in viewfreeLayers) {\n            var freeLayerProperties = viewfreeLayers[skey];\n            \n            if (view.freeLayers[skey]) {\n                freeLayer = view.freeLayers[skey]; \n                freeLayer.enabled = true;\n                var depthShift = freeLayerProperties['depthOffset'] || [0,0,0];\n                freeLayer.depthShift = depthShift[0];\n                freeLayer.depthShift2 = depthShift[1];\n                freeLayer.depthShift3 = depthShift[2];\n                freeLayer.style = freeLayerProperties['style'];\n                //freeLayer.originalStyle = freeLayer.style;\n                \n                layers = freeLayerProperties['boundLayers'] || [];\n                //freeLayer.layers = layers;\n                \n                for (i = 0, li = layers.length; i < li; i++) {\n                    if (typeof layers[i] === 'string') {\n                        index = this.findIdInArray(freeLayer.layers, layers[i]);\n                        if (index != -1 && freeLayer.layers[index]) {\n                            freeLayer.layers[index].enabled = true;\n                            freeLayer.layers.splice(i, 0, freeLayer.layers.splice(index, 1)[0]);\n                        }    \n                    } else {\n                        id = layers[i]['id'];\n                        index = this.findIdInArray(freeLayer.layers, id);\n                        if (index != -1 && surface.layers[index]) {\n                            freeLayer.layers[index].enabled = true;\n                            freeLayer.layers[index].alpha = layers[i]['alpha'] ? (parseFloat(layers[i]['alpha'])*100) : 100;\n                            freeLayer.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);\n                        }    \n                    }\n                }\n            }\n        }        \n    }\n};\n\n\nInspectorLayers.prototype.findIdInArray = function(array, id) {\n    for (var i = 0, li = array.length; i < li; i++) {\n        if (array[i].id == id) {\n            return i;\n        } \n    }\n    \n    return -1;\n};\n\n\nInspectorLayers.prototype.buildViews = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var views = this.views;\n    var html = '';\n\n    for (var key in views) {\n        html += '<div class=\"vts-views-item\" id=\"vts-views-item-' + key + '\">'\n                 + '<div class=\"vts-layers-name2\">' + key + '</div>'\n                 + '<button id=\"vts-views-cbutton-' + key + '\" type=\"button\" title=\"Clone\">C</button>' \n                 + '<button id=\"vts-views-xbutton-' + key + '\" type=\"button\" title=\"Remove\">X</button>' \n                 + '</div>';\n    }\n\n    this.viewItems.innerHTML = html;\n\n    for (key in views) {\n        htmlId = 'vts-views-cbutton-' + key;\n        document.getElementById(htmlId).onclick = this.switchView.bind(this, key, htmlId, 'clone');\n        htmlId = 'vts-views-xbutton-' + key;\n        document.getElementById(htmlId).onclick = this.switchView.bind(this, key, htmlId, 'remove');\n        var htmlId = 'vts-views-item-' + key;\n        document.getElementById(htmlId).onclick = this.selectView.bind(this, key);\n    }\n};\n\n\nInspectorLayers.prototype.buildSurfaces = function() {\n    var view = this.views[this.currentView];\n    var surfaces = view.surfaces;\n    var html = '', htmlId;\n    var firstKey = null, key;\n    \n    for (key in surfaces) {\n        html += '<div id=\"vts-surface-item-' + key + '\" class=\"vts-surface-item\"><input id=\"vts-surface-checkbox-'\n                 + key + '\" type=\"checkbox\"/><span title=' + key + '>' + key + '</span></div>';\n                 \n        if (firstKey === null) {\n            firstKey = key;\n        }\n    }\n\n    this.surfacesItems.innerHTML = html;\n    this.currentSurface = firstKey;\n\n    for (key in surfaces) {\n        if (surfaces[key].enabled) {\n            htmlId = 'vts-surface-checkbox-' + key;\n            document.getElementById(htmlId).checked = true;\n        }\n    }\n\n    for (key in surfaces) {\n        htmlId = 'vts-surface-checkbox-' + key;\n        document.getElementById(htmlId).onchange = this.switchSurface.bind(this, key, htmlId);\n        htmlId = 'vts-surface-item-' + key;\n        document.getElementById(htmlId).onclick = this.selectSurface.bind(this, key);\n    }\n};\n\n\nInspectorLayers.prototype.buildBoundLayers = function(id) {\n    var view = this.views[this.currentView];\n    var html = '';\n\n    if (view.surfaces[id]) {\n        var layers = view.surfaces[id].layers;\n\n        for (var i = 0, li = layers.length; i < li; i++) {\n            var layer = layers[i];\n\n            html += '<div class=\"vts-layers-item\"><input id=\"vts-boundlayer-checkbox-' + layer.id + '\" type=\"checkbox\" ' + (layer.enabled ? 'checked' : '')   + '/>'\n                     + '<div class=\"vts-layers-name\">' + layer.id + '</div>'\n                     + '<input id=\"vts-boundlayer-spinner-' + layer.id + '\" type=\"number\" title=\"Alpha\" min=\"0\" max=\"100\" step=\"10\" value=\"' + layer.alpha + '\">'\n                     + '<button id=\"vts-boundlayer-ubutton-' + layer.id + '\" type=\"button\" title=\"Move Above\">&uarr;</button>' \n                     + '<button id=\"vts-boundlayer-dbutton-' + layer.id + '\" type=\"button\" title=\"Move Bellow\">&darr;</button>' \n                     + '</div>';\n        }\n    }\n\n    this.boundLayersItems.innerHTML = html;\n\n    if (view.surfaces[id]) {\n        for (i = 0, li = layers.length; i < li; i++) {\n            var htmlId = 'vts-boundlayer-checkbox-' + layers[i].id;\n            document.getElementById(htmlId).onchange = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'enable');\n            htmlId = 'vts-boundlayer-spinner-' + layers[i].id;\n            document.getElementById(htmlId).onchange = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'alpha');\n            htmlId = 'vts-boundlayer-ubutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'up');\n            htmlId = 'vts-boundlayer-dbutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'down');\n        }\n    }\n};\n\n\nInspectorLayers.prototype.buildFreeLayers = function() {\n    var view = this.views[this.currentView];\n    var layers = view.freeLayers;\n    var html = '';\n\n    for (var key in layers) {\n        //var layer = layers[key];\n        html += '<div class=\"vts-surface-item\" id=\"vts-freelayer-item-' + key\n                  + '\"><input id=\"vts-freelayer-checkbox-' + key + '\" type=\"checkbox\" '\n                  + (layers[key].enabled ? 'checked' : '') + '/><span title=' + key + '>' + key + '</span></div>';\n    }\n\n    this.freeLayersItems.innerHTML = html;\n\n    for (key in layers) {\n        var htmlId = 'vts-freelayer-checkbox-' + key;\n        document.getElementById(htmlId).onchange = this.switchFreeLayer.bind(this, key, htmlId);\n        htmlId = 'vts-freelayer-item-' + key;\n        document.getElementById(htmlId).onclick = this.selectFreeLayer.bind(this, key);\n    }\n};\n\n\nInspectorLayers.prototype.buildFreeLayerProperties = function(id) {\n    var map = this.core.getMap();\n    var view = this.views[this.currentView];\n    var layers = view.freeLayers[id].layers;\n    var html = '', i, li, htmlId;\n    \n    if (!map || !map.getFreeLayer(id)) {\n        return;\n    }\n\n    var layerInfo = map.getFreeLayer(id).getInfo();\n    var layerType = layerInfo['type']; \n\n    switch(layerType) {\n    case 'mesh':\n    case 'mesh-tiles':\n\n        html += '<div class=\"vts-layers-item\"><div class=\"vts-layers-name\" style=\"width:90px\">' + 'DepthOffset:' + '</div>'\n                     + '<input id=\"vts-fl-properties-depth-shift\" type=\"number\" min=\"-100\" max=\"100\" step=\"1\" value=\"' + view.freeLayers[id].depthShift + '\">'\n                     + '<input id=\"vts-fl-properties-depth-shift2\" type=\"number\" min=\"-100\" max=\"100\" step=\"1\" value=\"' + view.freeLayers[id].depthShift2 + '\">'\n                     + '<input id=\"vts-fl-properties-depth-shift3\" type=\"number\" min=\"-100\" max=\"100\" step=\"1\" value=\"' + view.freeLayers[id].depthShift3 + '\">'\n                     + '</div>';\n    \n        html += '<div class=\"vts-layers-item\"><div class=\"vts-layers-name\">' + 'BoundLayers:' + '</div></div>';\n        \n        for (i = 0, li = layers.length; i < li; i++) {\n            var layer = layers[i];\n        \n            html += '<div class=\"vts-layers-item\"><input id=\"vts-fl-properties-checkbox-' + layer.id + '\" type=\"checkbox\" ' + (layer.enabled ? 'checked' : '')   + '/>'\n                         + '<div class=\"vts-layers-name\">' + layer.id + '</div>'\n                         + '<input id=\"vts-fl-properties-spinner-' + layer.id + '\" type=\"number\" title=\"Alpha\" min=\"0\" max=\"100\" step=\"10\" value=\"' + layer.alpha + '\">'\n                         + '<button id=\"vts-fl-properties-ubutton-' + layer.id + '\" type=\"button\" title=\"Move Above\">&uarr;</button>' \n                         + '<button id=\"vts-fl-properties-dbutton-' + layer.id + '\" type=\"button\" title=\"Move Bellow\">&darr;</button>' \n                         + '</div>';\n        }\n        \n        this.freeLayersPropertiesItems.innerHTML = html;\n    \n        htmlId = 'vts-fl-properties-depth-shift';\n        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift');\n        htmlId = 'vts-fl-properties-depth-shift2';\n        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift2');\n        htmlId = 'vts-fl-properties-depth-shift3';\n        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift3');\n        \n        for (i = 0, li = layers.length; i < li; i++) {\n            htmlId = 'vts-fl-properties-checkbox-' + layers[i].id;\n            document.getElementById(htmlId).onchange = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'enable');\n            htmlId = 'vts-fl-properties-spinner-' + layers[i].id;\n            document.getElementById(htmlId).onchange = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'alpha');\n            htmlId = 'vts-fl-properties-ubutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'up');\n            htmlId = 'vts-fl-properties-dbutton-' + layers[i].id;\n            document.getElementById(htmlId).onclick = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'down');\n        }\n            \n        break;\n\n    case 'geodata':\n    case 'geodata-tiles':\n\n        html += '<div class=\"vts-layers-item\"><div class=\"vts-layers-name\" style=\"width:50px\">' + 'Style:' + '</div>'\n                    + '<select id=\"vts-layers-fl-properties-style\">';\n                    \n        var styles = map.getStylesheets();\n        var index = styles.indexOf(view.freeLayers[id].style || view.freeLayers[id].originalStyle); // || layerInfo[\"style\"]); \n            \n        for (i = 0, li = styles.length; i < li; i++) {\n            html += '<option value=\"' + styles[i] + '\" ' + ((i == index) ? 'selected' : '') + '>' + styles[i] + '</option>';\n        }\n                    \n        html += '</select>' + '</div>';\n\n        this.freeLayersPropertiesItems.innerHTML = html;\n\n        htmlId = 'vts-layers-fl-properties-style';\n        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'style');\n       \n        break;\n    }\n};\n\n\nInspectorLayers.prototype.selectView = function(id) {\n    if (!this.views[id]) {\n        return;\n    }\n\n    var element;\n\n    //deselect previous\n    if (this.currentView) {\n        element = document.getElementById('vts-views-item-' + this.currentView);\n        if (element) {\n            element.style.backgroundColor = 'initial';\n        }\n    }\n\n    //select new one\n    element = document.getElementById('vts-views-item-' + id);\n    element.style.backgroundColor = '#ddd';\n    this.currentView = id;\n    //this.buildBoundLayers(this.currentSurface);\n\n    this.buildSurfaces();\n    this.selectSurface(this.currentSurface);\n    this.buildFreeLayers();\n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.switchView = function(id, htmlId, action) {\n    //var element = document.getElementById(htmlId);\n    var views = this.views;\n    \n    for (var key in this.views) {\n        if (key == id) {\n            switch(action) {\n            case 'clone':\n                    //layers[i].enabled = element.checked;\n                var i = 2;\n                    \n                // eslint-disable-next-line\n                while(true) {\n                    if (!views[id + ' #' + i]) {\n                        views[id + ' #' + i] = JSON.parse(JSON.stringify(views[id]));\n                        break;\n                    } \n                    i++;\n                }\n                \n                this.buildViews();\n                    \n                break;\n            case 'remove':\n                \n                var count = 0;\n                \n                for (key in views) {\n                    count++;\n                }\n                \n                if (count > 1) {\n                    delete views[id];\n                    this.buildViews();\n\n                    if (this.currentView == id) {\n                        for (key in views) {\n                            this.selectView(key);\n                            break;\n                        }\n                    } else {\n                        this.selectView(this.currentView);\n                    }\n                }\n                    \n                break;\n            }\n            \n            break;\n        }\n    }\n};\n\n\nInspectorLayers.prototype.switchSurface = function(id, htmlId) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    view.surfaces[id].enabled = element.checked;\n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.selectSurface = function(id) {\n    var element;\n    //deselect previous\n    if (this.currentSurface) {\n        element = document.getElementById('vts-surface-item-' + this.currentSurface);\n        element.style.backgroundColor = 'initial';\n    }\n\n    //select new one\n    element = document.getElementById('vts-surface-item-' + id);\n    if (element) {\n        element.style.backgroundColor = '#ddd';\n    }\n    this.currentSurface = id;\n    this.buildBoundLayers(this.currentSurface);\n};\n\n\nInspectorLayers.prototype.switchBoundLayer = function(id, htmlId, action) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    var layers = view.surfaces[this.currentSurface].layers;\n    \n    for (var i = 0, li = layers.length; i < li; i++) {\n        if (layers[i].id == id) {\n            switch(action) {\n            case 'enable':\n                layers[i].enabled = element.checked;\n                break;\n            case 'alpha':\n                layers[i].alpha = parseInt(element.value, 10);\n                break;\n            case 'up':\n                layers.splice(Math.max(0,i-1), 0, layers.splice(i, 1)[0]);\n                this.selectSurface(this.currentSurface);\n                break;\n            case 'down':\n                layers.splice(Math.max(0,i+1), 0, layers.splice(i, 1)[0]);\n                this.selectSurface(this.currentSurface);\n                break;\n            }\n            \n            break;\n        }\n    }\n    \n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.switchFreeLayer = function(id, htmlId) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    view.freeLayers[id].enabled = element.checked;\n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.selectFreeLayer = function(id) {\n    var element;\n    //deselect previous\n    if (this.currentFreeLayer) {\n        element = document.getElementById('vts-freelayer-item-' + this.currentFreeLayer);\n        element.style.backgroundColor = 'initial';\n    }\n\n    //select new one\n    element = document.getElementById('vts-freelayer-item-' + id);\n    element.style.backgroundColor = '#ddd';\n    this.currentFreeLayer = id;\n    this.buildFreeLayerProperties(this.currentFreeLayer);\n};\n\n\nInspectorLayers.prototype.switchFreeLayerBoundLayer = function(id, htmlId, action) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    var layers = view.freeLayers[this.currentFreeLayer].layers;\n    \n    for (var i = 0, li = layers.length; i < li; i++) {\n        if (layers[i].id == id) {\n            switch(action) {\n            case 'enable':\n                layers[i].enabled = element.checked;\n                break;\n            case 'alpha':\n                layers[i].alpha = parseInt(element.value, 10);\n                break;\n            case 'up':\n                layers.splice(Math.max(0,i-1), 0, layers.splice(i, 1)[0]);\n                this.selectFreeLayer(this.currentFreeLayer);\n                break;\n            case 'down':\n                layers.splice(Math.max(0,i+1), 0, layers.splice(i, 1)[0]);\n                this.selectFreeLayer(this.currentFreeLayer);\n                break;\n            }\n            \n            break;\n        }\n    }\n    \n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.switchFreeLayerProperty = function(htmlId, action) {\n    var element = document.getElementById(htmlId);\n    var view = this.views[this.currentView];\n    var layer = view.freeLayers[this.currentFreeLayer];\n\n    switch(action) {\n    case 'depthShift':  layer.depthShift = parseInt(element.value, 10); break;\n    case 'depthShift2': layer.depthShift2 = parseInt(element.value, 10); break;\n    case 'depthShift3': layer.depthShift3 = parseInt(element.value, 10); break;\n    case 'style':       layer.style = element.value; break;\n    }\n    \n    this.applyMapView();\n};\n\n\nInspectorLayers.prototype.applyMapView = function(jsonOnly) {\n    var view = {\n        'surfaces' : {},\n        'freeLayers' : {}\n    };\n\n    var sourceView = this.views[this.currentView];\n    var surfaces = sourceView.surfaces, i, li, layers;\n    \n    for (var key in surfaces) {\n        if (surfaces[key].enabled) {\n            var surfaceBoundLayers = [];\n            layers = surfaces[key].layers; //bound layers\n            \n            for (i = 0, li = layers.length; i < li; i++) {\n                if (layers[i].enabled) {\n                    \n                    if (layers[i].alpha < 100) {\n                        surfaceBoundLayers.push({'id':layers[i].id, 'alpha':(layers[i].alpha*0.01).toFixed(2)});\n                    } else {\n                        surfaceBoundLayers.push(layers[i].id);\n                    }\n                }\n            }\n            \n            view['surfaces'][key] = surfaceBoundLayers;\n        }\n    }\n\n    var freeLayers = sourceView.freeLayers;\n    \n    for (key in freeLayers) {\n        if (freeLayers[key].enabled) {\n            var freeLayerBoundLayers = [];\n            layers = freeLayers[key].layers; //bound layers\n            \n            for (i = 0, li = layers.length; i < li; i++) {\n                if (layers[i].enabled) {\n                    \n                    if (layers[i].alpha < 100) {\n                        freeLayerBoundLayers.push({'id':layers[i].id, 'alpha':parseFloat((layers[i].alpha*0.01).toFixed(2))});\n                    } else {\n                        freeLayerBoundLayers.push(layers[i].id);\n                    }\n                }\n            }\n            \n            view['freeLayers'][key] = {};\n            \n            if (freeLayerBoundLayers.length > 0) {\n                view['freeLayers'][key]['boundLayers'] = freeLayerBoundLayers;\n            }\n\n            if (freeLayers[key].style && freeLayers[key].style != freeLayers[key].originalStyle) {\n                view['freeLayers'][key]['style'] = freeLayers[key].style;\n            }\n            \n            if (!(freeLayers[key].depthShift == 0 && freeLayers[key].depthShift2 == 0 && freeLayers[key].depthShift3 == 0)) {\n                view['freeLayers'][key]['depthOffset'] = [\n                    parseFloat((freeLayers[key].depthShift).toFixed(2)),\n                    parseFloat((freeLayers[key].depthShift2).toFixed(2)),\n                    parseFloat((freeLayers[key].depthShift3).toFixed(2)) ];\n            } \n            \n        }\n    }\n\n    this.jsonText.value = JSON.stringify(view, null, '  ');\n    this.jsonText2.value = encodeURIComponent(JSON.stringify(view));\n\n    if (!jsonOnly) {\n        var map = this.core.getMap();\n        if (!map) {\n            return;\n        }\n        \n        map.setView(view);\n    }\n};\n\n\nInspectorLayers.prototype.showPanel = function() {\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n    this.updatePanel();\n};\n\n\nInspectorLayers.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n};\n\n\nInspectorLayers.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorLayers.prototype.updatePanel = function() {\n    if (!this.panelInitialized) {\n        this.panelInitialized = false;\n        this.initViews();\n        this.buildViews();\n        this.selectView(this.currentView);\n        /*\n        this.buildSurfaces();\n        this.selectSurface(this.currentSurface);\n        this.buildFreeLayers();\n        this.applyMapView(true);\n        */\n    }\n};\n\n\nexport default InspectorLayers;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/inspector/layers.js\n// module id = 121\n// module chunks = 0 1","\nimport GpuTexture_ from '../renderer/gpu/texture';\nimport {math as math_} from '../utils/math';\nimport {vec3 as vec3_, mat4 as mat4_} from '../utils/matrix';\n\n//get rid of compiler mess\nvar math = math_;\nvar GpuTexture = GpuTexture_;\nvar vec3 = vec3_, mat4 = mat4_;\n\n\nvar InspectorReplay = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorReplay.prototype.init = function() {\n    var inspector = this.inspector;\n    inspector.addStyle(\n        '#vts-replay-panel {'\n            + 'font-family: Arial, \\'Helvetica Neue\\', Helvetica, sans-serif;'\n            + 'display: none;'\n            + 'padding:15px;'\n            + 'width: 618px;'\n            + 'font-size: 14px;'\n            + 'position: absolute;'\n            + 'right: 10px;'\n            + 'top: 10px;'\n            + 'cursor: default;'\n            + 'background-color: rgba(255,255,255,0.95);'\n            + 'border-radius: 5px;'\n            + 'border: solid 1px #ccc;'\n            + 'text-align: left;'\n            + 'z-index: 7;'\n            + 'padding: 10px;'\n        + '}'\n\n        + '#vts-replay-panel-left {'\n            + 'width: 253px;'\n            + 'height: 100%;'\n            + 'float: left;'\n        + '}'\n\n        + '#vts-replay-panel-right {'\n            + 'width: 340px;'\n            + 'height: 100%;'\n            + 'float: right;'\n        + '}'\n\n        + '#vts-replay-items {'\n            + 'width: 240px;'\n            + 'overflow-x: hidden;'\n            + 'border: 1px solid #ddd;'\n            + 'padding-right: 5px;'\n        + '}'\n\n        + '.vts-replay-item {'\n            + 'width: 100%;'\n            + 'overflow: hidden;'\n            + 'text-overflow: ellipsis;'\n            + 'white-space: nowrap;'    \n        + '}' \n\n        + '#vts-replay-lod-slider {'\n            + 'width: 240px;'\n        + '}'\n\n        + '#vts-replay-lod-text {'\n            + 'width: 60px;'\n            + 'margin-left: 10px;'\n            + 'margin-right: 10px;'\n        + '}'\n\n        + '#vts-replay-lod-single {'\n            + 'margin-left: 10px;'\n        + '}'\n    \n        + '#vts-replay-time-slider {'\n            + 'width: 330px;'\n        + '}'\n\n        + '#vts-replay-time-text {'\n            + 'width: 60px;'\n            + 'margin-left: 10px;'\n            + 'margin-right: 10px;'\n        + '}'\n\n        + '#vts-replay-time-single {'\n            + 'margin-left: 10px;'\n        + '}'\n\n        + '#vts-replay-panel-gtime canvas{'\n            + 'border: 1px solid #555;'\n        + '}'\n\n        + '#vts-replay-panel-gtime span{'\n            + 'font-size: 10px;'\n        + '}'\n\n        + '#vts-replay-info {'\n            + 'width: 240px;'\n            + 'height: 140px;'\n            + 'overflow-x: hidden;'\n            + 'border: 1px solid #ddd;'\n            + 'padding-right: 5px;'\n            + 'margin-top: 10px;'            \n            + 'font-size: 12px;'\n            + 'word-wrap: break-word;'   \n        + '}'\n       \n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-replay-panel';\n    this.element.innerHTML =\n            '<div id=\"vts-replay-panel-left\">'\n            + '<div id=\"vts-replay-items\"></div>'\n            + '<div id=\"vts-replay-panel-lod\">'  \n                + '<input id=\"vts-replay-lod-slider\" type=\"range\" min=\"0\" max=\"30\" step=\"1\" value=\"30\" /><br/>'\n                + '<span>LOD:</span>'\n                + '<input id=\"vts-replay-lod-text\" type=\"text\" value=\"30\"/>'\n                + '<input id=\"vts-replay-lod-up\" type=\"button\" value=\"<\"/>'\n                + '<input id=\"vts-replay-lod-down\" type=\"button\" value=\">\"/>'\n                + '<input id=\"vts-replay-lod-single\" type=\"checkbox\"/>'\n                + '<span>Single</span>'\n            + '</div>'\n            + '<div id=\"vts-replay-info\"></div>'\n          + '</div>'\n          + '<div id=\"vts-replay-panel-right\">'\n            + '<div id=\"vts-replay-panel-gtime\">'  \n                + '<span id=\"vts-replay-info-meshes\">Meshes Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-meshes\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-textures\">Internal Textures Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-textures\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-textures2\">External Textures Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-textures2\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-geodata\">Geodata Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-geodata\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-metatiles\">Metatiles Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-metatiles\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-intervals\">Interval Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'\n                + '<canvas id=\"vts-replay-canvas-intervals\" width=340 height=30></canvas><br/>'  \n                + '<span id=\"vts-replay-info-threads\">Threads Min/Max: 0/0 Avg. 0 </span><br/>'\n                + '<canvas id=\"vts-replay-canvas-threads\" width=340 height=30></canvas><br/>'  \n            + '</div>'\n\n            + '<div id=\"vts-replay-panel-time\">'  \n                + '<input id=\"vts-replay-time-slider\" type=\"range\" min=\"0\" max=\"2000\" value=\"0\" /><br/>'\n                + '<span>File:</span>'\n                + '<input id=\"vts-replay-time-text\" type=\"text\" value=\"0\"/>'\n                + '<input id=\"vts-replay-time-up\" type=\"button\" value=\"<\"/>'\n                + '<input id=\"vts-replay-time-down\" type=\"button\" value=\">\"/>'\n                + '<input id=\"vts-replay-time-single\" type=\"checkbox\"/>'\n                + '<span>Single</span>'\n            + '</div>'\n          + '</div>';\n\n    this.core.element.appendChild(this.element);\n\n    this.items = document.getElementById('vts-replay-items');\n\n    this.lodSlider = document.getElementById('vts-replay-lod-slider');\n    this.lodSlider.onchange = this.onSliderChange.bind(this, 'lod');\n    this.lodSlider.oninput = this.onSliderChange.bind(this, 'lod');\n\n    this.lodText = document.getElementById('vts-replay-lod-text');\n    this.lodText.onchange = this.onTextChange.bind(this, 'lod');\n    \n    document.getElementById('vts-replay-lod-up').onclick = this.onSliderChange.bind(this, 'lod', 'down');\n    document.getElementById('vts-replay-lod-down').onclick = this.onSliderChange.bind(this, 'lod', 'up');\n    document.getElementById('vts-replay-lod-single').onclick = this.onSliderChange.bind(this, 'lod', 'single');\n    \n    this.timeSlider = document.getElementById('vts-replay-time-slider');\n    this.timeSlider.onchange = this.onSliderChange.bind(this, 'time');\n    this.timeSlider.oninput = this.onSliderChange.bind(this, 'time');\n\n    this.timeText = document.getElementById('vts-replay-time-text');\n    this.timeText.onchange = this.onTextChange.bind(this, 'time');\n\n    this.timeInfo = document.getElementById('vts-replay-info');\n\n    document.getElementById('vts-replay-time-up').onclick = this.onSliderChange.bind(this, 'time', 'down');\n    document.getElementById('vts-replay-time-down').onclick = this.onSliderChange.bind(this, 'time', 'up');\n    document.getElementById('vts-replay-time-single').onclick = this.onSliderChange.bind(this, 'time', 'single');\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.infoMeshes = document.getElementById('vts-replay-info-meshes');\n    this.ctxMeshes = document.getElementById('vts-replay-canvas-meshes').getContext('2d');  \n    this.infoTextures = document.getElementById('vts-replay-info-textures');\n    this.ctxTextures = document.getElementById('vts-replay-canvas-textures').getContext('2d');  \n    this.infoTextures2 = document.getElementById('vts-replay-info-textures2');\n    this.ctxTextures2 = document.getElementById('vts-replay-canvas-textures2').getContext('2d');  \n    this.infoGeodata = document.getElementById('vts-replay-info-geodata');\n    this.ctxGeodata = document.getElementById('vts-replay-canvas-geodata').getContext('2d');  \n    this.infoMetatiles = document.getElementById('vts-replay-info-metatiles');\n    this.ctxMetatiles = document.getElementById('vts-replay-canvas-metatiles').getContext('2d');  \n    this.infoIntervals = document.getElementById('vts-replay-info-intervals');\n    this.ctxIntervals = document.getElementById('vts-replay-canvas-intervals').getContext('2d');  \n    this.infoThreads = document.getElementById('vts-replay-info-threads');\n    this.ctxThreads = document.getElementById('vts-replay-canvas-threads').getContext('2d');  \n\n    this.cameraLines = [];\n    this.cameraLines2 = [];\n    this.cameraLines3 = [];\n    this.cameraGenarated = false;\n\n    this.panelVisible = false;\n};\n\n\nInspectorReplay.prototype.showPanel = function() {\n    this.buildReplayCombo();\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n    this.updateFileInfo(replay.loadedIndex);\n    this.updateLoadGraphs();\n};\n\n\nInspectorReplay.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n};\n\n\nInspectorReplay.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorReplay.prototype.onSliderChange = function(type, button) {\n    if (type == 'lod') {\n        switch (button) {\n        case 'up':\n            this.lodSlider.stepUp();\n            this.lodText.value = this.lodSlider.value;    \n            break;\n            \n        case 'down':\n            this.lodSlider.stepDown();\n            this.lodText.value = this.lodSlider.value;    \n            break;\n\n        default:\n            this.lodText.value = this.lodSlider.value;    \n        } \n    } else {\n        switch (button) {\n        case 'up':\n            this.timeSlider.stepUp();\n            this.timeText.value = this.timeSlider.value;    \n            break;\n            \n        case 'down':\n            this.timeSlider.stepDown();\n            this.timeText.value = this.timeSlider.value;    \n            break;\n\n        default:\n            this.timeText.value = this.timeSlider.value;    \n        } \n    }\n\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n\n    if (type == 'lod') {\n        replay.lod = parseFloat(this.lodText.value);\n        replay.singleLod = document.getElementById('vts-replay-lod-single').checked;\n    } else {\n        replay.loadedIndex = parseFloat(this.timeText.value);\n        replay.singleLodedIndex = document.getElementById('vts-replay-time-single').checked;\n        this.updateFileInfo(replay.loadedIndex);\n        this.updateLoadGraphs();\n    }\n\n    map.markDirty();\n};\n\n\nInspectorReplay.prototype.onTextChange = function(type) {\n    if (type == 'lod') {\n        this.lodSlider.value = this.lodText.value;    \n    } else {\n        this.timeSlider.value = this.timeText.value;    \n    }\n\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n\n    if (type == 'lod') {\n        replay.lod = parseFloat(this.lodText.value);\n    } else {\n        replay.loadedIndex = parseFloat(this.timeText.value);\n        this.updateFileInfo(replay.loadedIndex);\n        this.updateLoadGraphs();\n    }\n\n    map.markDirty();\n};\n\n\nInspectorReplay.prototype.generateCameraLines = function(camera) {\n    var renderer = this.core.getRendererInterface();\n    var p1 = camera.position;\n    var p2 = camera.center;\n\n    this.cameraLines = [p1, p2];\n/*        \n    var screenSize = renderer.getCanvasSize();\n    \n    var v1 = map.getScreenRay(0+1,0+1);\n    var v2 = map.getScreenRay(screenSize[0]-1,0+1);\n    var v3 = map.getScreenRay(screenSize[0]-1,screenSize[1]-1);\n    var v4 = map.getScreenRay(0+1,screenSize[1]-1);\n    var v5 = map.getScreenRay(screenSize[0]*0.5,screenSize[1]*0.5);\n    \n    var l = camera.distance;\n    \n    //l = map.getPositionViewExtent(pos);    \n    \n    vec3.scale(v1, l*10);\n    //vec3.scale(v2, l);\n    //vec3.scale(v3, l);\n    //vec3.scale(v4, l);\n    //vec3.scale(v5, l);\n    \n    vec3.add(v1, p1);\n    //vec3.add(v2, p1);\n    //vec3.add(v3, p1);\n    //vec3.add(v4, p1);\n    //vec3.add(v5, p1);\n\n    this.cameraLines3 = [p1, v1]; //, p1, v2, p1, v3, p1, v4, v1, v2, v3, v4];//, v5, p1];\n    */\n/*\n    this.cameraLines2 = [p1];\n    \n    for (var y = 0; y < screenSize[1]*0.5; y += 100) {\n        for (var x = screenSize[0]*0.5; x < screenSize[0]; x += 100) {\n\n            var v1 = map.getScreenRay(x,y);\n            vec3.scale(v1, l);\n            vec3.add(v1, p1);\n            \n            this.cameraLines2.push(v1);\n        }\n    }    \n*/\n    this.cameraLines2 = [[p1], [p1], [p1], [p1]];\n    \n    var segments = 16;\n\n    var map2 = this.core.getMap();\n\n    var m2 = map2.camera.getRotationviewMatrix();\n    var m = mat4.create();\n    mat4.inverse(m2, m);\n    \n    this.cameraMatrix = m;\n    \n    var a = Math.tan(math.radians(map2.camera.getFov()));\n    var b = a * map2.camera.getAspect();\n    var c = Math.sqrt(a*a + b*b);\n    \n    var dfov = Math.atan(c/1);\n    \n    var l = camera.cameraDistance / segments;\n    var l2 = 0.5 * l * Math.tan(dfov);\n    var l3 = l2 * map2.camera.getAspect();\n    var v1, v2, v3, v4;\n\n    for (var i = 0; i < segments; i++) {\n        v1 = [-l3, -l2, -l];\n        v2 = [l3, -l2, -l];\n        v3 = [l3, l2, -l];\n        v4 = [-l3, l2, -l];\n\n        vec3.scale(v1, (i+1));\n        vec3.scale(v2, (i+1));\n        vec3.scale(v3, (i+1));\n        vec3.scale(v4, (i+1));\n        \n        mat4.multiplyVec3(m, v1);\n        mat4.multiplyVec3(m, v2);\n        mat4.multiplyVec3(m, v3);\n        mat4.multiplyVec3(m, v4);\n    \n        vec3.add(v1, p1);\n        vec3.add(v2, p1);\n        vec3.add(v3, p1);\n        vec3.add(v4, p1);\n        \n        this.cameraLines2[0].push(v1);\n        this.cameraLines2[1].push(v2);\n        this.cameraLines2[2].push(v3);\n        this.cameraLines2[3].push(v4);\n    }\n    \n    this.cameraLines3 = [[p1], [p1], [p1], [p1]];\n\n    segments = 256;\n    l = (camera.distance + 12742000 * 1.1) / segments;\n    //l = (camera.distance * 20.1) / segments;\n    l2 = 0.5 * l * Math.tan(dfov);\n    l3 = l2 * map2.camera.getAspect();\n    \n    for (i = 0; i < segments; i++) {\n        v1 = [-l3, -l2, -l];\n        v2 = [l3, -l2, -l];\n        v3 = [l3, l2, -l];\n        v4 = [-l3, l2, -l];\n\n        vec3.scale(v1, (i+1));\n        vec3.scale(v2, (i+1));\n        vec3.scale(v3, (i+1));\n        vec3.scale(v4, (i+1));\n        \n        mat4.multiplyVec3(m, v1);\n        mat4.multiplyVec3(m, v2);\n        mat4.multiplyVec3(m, v3);\n        mat4.multiplyVec3(m, v4);\n    \n        vec3.add(v1, p1);\n        vec3.add(v2, p1);\n        vec3.add(v3, p1);\n        vec3.add(v4, p1);\n        \n        this.cameraLines3[0].push(v1);\n        this.cameraLines3[1].push(v2);\n        this.cameraLines3[2].push(v3);\n        this.cameraLines3[3].push(v4);\n    }\n\n    v1 = [-l3, -l2, -l];\n    v2 = [l3, -l2, -l];\n    v3 = [l3, l2, -l];\n    v4 = [-l3, l2, -l];\n\n    vec3.scale(v1, segments);\n    vec3.scale(v2, segments);\n    vec3.scale(v3, segments);\n    vec3.scale(v4, segments);\n    \n    p1 = [0,0,0];\n    \n    var vertices = [ p1[0], p1[1], p1[2],\n        v1[0], v1[1], v1[2],\n        v2[0], v2[1], v2[2],\n\n        p1[0], p1[1], p1[2],\n        v2[0], v2[1], v2[2],\n        v3[0], v3[1], v3[2],\n\n        p1[0], p1[1], p1[2],\n        v3[0], v3[1], v3[2],\n        v4[0], v4[1], v4[2],\n\n        p1[0], p1[1], p1[2],\n        v4[0], v4[1], v4[2],\n        v1[0], v1[1], v1[2]\n    ];\n                      \n    var uvs = [ 0,0, 0,0, 0,0,\n        0,0, 0,0, 0,0,\n        0,0, 0,0, 0,0,\n        0,0, 0,0, 0,0 ];\n\n    var normals = [ 0,0,1, 0,0,1, 0,0,1,\n        0,0,1, 0,0,1, 0,0,1,\n        0,0,1, 0,0,1, 0,0,1,\n        0,0,1, 0,0,1, 0,0,1 ];\n\n    this.frustumState = renderer.createState({\n        'blend' : true,\n        'zwrite' : false,\n        'ztest' : true,\n        'culling' : false\n    });\n    \n    this.frustumMesh = renderer.createMesh({ 'vertices': vertices, 'uvs': uvs, 'normals': normals });\n    this.cameraGenarated = true;\n};\n\n\nInspectorReplay.prototype.itemButton = function(item, button) {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;    \n    \n    switch (item) {\n    case 'DrawnTiles':\n        replay.storeTiles = true;\n        break;\n\n    case 'DrawnTilesFreeLayers':\n        replay.storeFreeTiles = true;\n        break;\n\n    case 'TracedNodes':\n        replay.storeNodes = true;\n        break;\n\n    case 'TracedNodesFreeLayers':\n        replay.storeFreeNodes = true;\n        break;\n\n    case 'LoadSequence':\n        replay.storeLoaded = (button == 'S');\n\n        if (button == 'S') {\n            replay.loadedIndex = 0;\n            replay.loaded = [];\n        } else {\n            this.updateFileInfo(replay.loadedIndex);\n            this.updateLoadGraphs();\n        }\n        break;\n\n    case 'Camera':\n\n        if (button == 'S') {\n            var camera = replay.camera = {\n                distance : map.camera.distance,\n                position : map.camera.position.slice(),\n                vector : map.camera.vector.slice(),\n                center : map.camera.center.slice(),\n                height : map.camera.height\n            };\n\n            replay.cameraPos = map.getPosition();\n            this.generateCameraLines(camera);\n        } else {\n            if (replay.cameraPos) {\n                map.setPosition(replay.cameraPos);\n            }\n        }\n\n        break;\n            \n    case 'Globe':\n                        \n        break;\n    }\n\n    map.markDirty();\n};\n\n\nInspectorReplay.prototype.switchItem = function(item, htmlId) {\n    var element = document.getElementById(htmlId);\n    //element.checked;\n    //this.applyMapView();\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n\n    switch (item) {\n    case 'DrawnTiles':\n        replay.drawTiles = element.checked;\n        break;\n\n    case 'DrawnTilesFreeLayers':\n        replay.drawFreeTiles = element.checked;\n        break;\n\n    case 'TracedNodes':\n        replay.drawNodes = element.checked;\n        break;\n\n    case 'TracedNodesFreeLayers':\n        replay.drawFreeNodes = element.checked;\n        break;\n\n    case 'LoadSequence':\n        replay.drawLoaded = element.checked;\n        break;\n\n    case 'Camera':\n        \n        if (!this.cameraGenarated) {\n            this.itemButton('Camera');\n        }\n        \n        this.drawCamera = element.checked;\n        break;\n            \n    case 'Globe':\n        var renderer = this.core.getRenderer();\n        \n        if (!this.globeTexture) {\n            var texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAMAAADyTj5VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Mzk4RkVFMzlGNjUxMUU2OTBDM0I0OEM1NjU0RURBMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Mzk4RkVFNDlGNjUxMUU2OTBDM0I0OEM1NjU0RURBMyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQzOThGRUUxOUY2NTExRTY5MEMzQjQ4QzU2NTRFREEzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQzOThGRUUyOUY2NTExRTY5MEMzQjQ4QzU2NTRFREEzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+5rvbhAAAAAZQTFRFwcHBLS0tMDfv/wAAAiZJREFUeNrs2LENAEEIA0HTf9ME5DTgIZn8ta+TnLjymzuW6kMIwIcQgA8hAAqAAmBdAM4O4E/wBPgQAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACoAAoANoBnB2AngAKgAKgACgACoB2AGcHoCeAAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACoAAoANoBnB2AngAKgAKgACgACoB2AGcHoCeAAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACEIAPIQAfwg7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABSAAH0IAPoQAfAgB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQAPxcAQYAZt2IEFFJhxsAAAAASUVORK5CYII=';        \n            this.globeTexture = new GpuTexture(renderer.gpu, texture, this.core, null, true);\n        }\n\n        this.drawGlobe = element.checked;\n        this.drawGlobe = this.drawGlobe;\n        break;\n    }\n\n    map.markDirty();\n};\n\n\nInspectorReplay.prototype.updateLoadGraphs = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n    var loaded = replay.loaded;\n    var index = replay.loadedIndex;\n\n    this.timeSlider.max = loaded.length; \n\n    var ctx;   \n    var lx = 340;\n    var ly = 30;\n\n    this.ctxMeshes.fillStyle = '#000000';\n    this.ctxMeshes.fillRect(0, 0, lx, ly);\n    this.ctxTextures.fillStyle = '#000000';\n    this.ctxTextures.fillRect(0, 0, lx, ly);\n    this.ctxTextures2.fillStyle = '#000000';\n    this.ctxTextures2.fillRect(0, 0, lx, ly);\n    this.ctxGeodata.fillStyle = '#000000';\n    this.ctxGeodata.fillRect(0, 0, lx, ly);\n    this.ctxMetatiles.fillStyle = '#000000';\n    this.ctxMetatiles.fillRect(0, 0, lx, ly);\n    this.ctxIntervals.fillStyle = '#000000';\n    this.ctxIntervals.fillRect(0, 0, lx, ly);\n    this.ctxThreads.fillStyle = '#000000';\n    this.ctxThreads.fillRect(0, 0, lx, ly);\n\n    var i = Math.floor(replay.loadedIndex / lx) * lx, li = (lx-1);\n    var shift = i, file;\n    \n    for (i = 0; i < li; i++) {\n        file = loaded[i + shift];\n        \n        if (file) {\n            switch(file.kind) {\n            case 'mesh':       ctx = this.ctxMeshes; break;\n            case 'texture-in': ctx = this.ctxTextures; break;\n            case 'texture-ex': ctx = this.ctxTextures2; break;\n            case 'geodata':    ctx = this.ctxGeodata; break;\n            case 'metatile':   ctx = this.ctxMetatiles; break;\n            default:\n                continue;\n            }\n\n            var grey = Math.round(Math.min(255, 60+20 * Math.max(1, file.duration / 300)));\n            ctx.fillStyle='rgb('+grey+','+grey+','+grey+')';\n\n            var h = (file.duration / 300) * 30;                 \n            ctx.fillRect(i, ly, 1, -h);\n\n            //interval\n            grey = Math.round(Math.min(255, 60+20 * Math.max(1, file.interval / 300)));\n            this.ctxIntervals.fillStyle='rgb('+grey+','+grey+','+grey+')';\n            h = (file.interval / 300) * 30;                 \n            this.ctxIntervals.fillRect(i, ly, 1, -h);\n\n            //interval\n            this.ctxThreads.fillStyle='rgb(80,80,80)';\n            h = (file.threads / map.config.mapDownloadThreads) * 30;                 \n            this.ctxThreads.fillRect(i, ly, 1, -h);\n        }\n    }\n\n    var minMeshes = Number.MAX_VALUE, maxMeshes = 0, avgMeshes = 0, avgMeshesCount = 0;\n    var minTextures = Number.MAX_VALUE, maxTextures = 0, avgTextures = 0, avgTexturesCount = 0;\n    var minTextures2 = Number.MAX_VALUE, maxTextures2 = 0, avgTextures2 = 0, avgTextures2Count = 0;\n    var minGeodata = Number.MAX_VALUE, maxGeodata = 0, avgGeodata = 0, avgGeodataCount = 0;\n    var minMetatiles = Number.MAX_VALUE, maxMetatiles = 0, avgMetatiles = 0, avgMetatilesCount = 0;\n    var minThreads = Number.MAX_VALUE, maxThreads = 0, avgThreads = 0, avgThreadsCount = 0;\n    var minIntervals = Number.MAX_VALUE, maxIntervals = 0, avgIntervals = 0, avgIntervalsCount = 0;\n    \n    li = loaded.length;\n\n    for (i = 0; i < li; i++) {\n        file = loaded[i];\n        \n        if (file) {\n            \n            switch(file.kind) {\n            case 'mesh':\n                if (file.duration < minMeshes) minMeshes = file.duration; \n                if (file.duration > maxMeshes) maxMeshes = file.duration; \n                avgMeshes += file.duration;\n                avgMeshesCount++;  \n                break;\n                    \n            case 'texture-in':\n                if (file.duration < minTextures) minTextures = file.duration; \n                if (file.duration > maxTextures) maxTextures = file.duration; \n                avgTextures += file.duration;\n                avgTexturesCount++;  \n                break;\n                    \n            case 'texture-ex':\n                if (file.duration < minTextures2) minTextures2 = file.duration; \n                if (file.duration > maxTextures2) maxTextures2 = file.duration; \n                avgTextures2 += file.duration;\n                avgTextures2Count++;  \n                break;\n                    \n            case 'geodata':\n                if (file.duration < minGeodata) minGeodata = file.duration; \n                if (file.duration > maxGeodata) maxGeodata = file.duration; \n                avgGeodata += file.duration;\n                avgGeodataCount++;  \n                break;\n                    \n            case 'metatile':\n                if (file.duration < minMetatiles) minMetatiles = file.duration; \n                if (file.duration > maxMetatiles) maxMetatiles = file.duration; \n                avgMetatiles += file.duration;\n                avgMetatilesCount++;  \n                break;\n\n            default:\n                continue;\n            }\n                \n            if (file.threads < minThreads) minThreads = file.threads; \n            if (file.threads > maxThreads) maxThreads = file.threads; \n            avgThreads += file.threads;\n            avgThreadsCount++;  \n\n            if (file.threads < minIntervals) minIntervals = file.threads; \n            if (file.threads > maxIntervals) maxIntervals = file.threads; \n            avgIntervals += file.threads;\n            avgIntervalsCount++;  \n        }\n    }\n    \n    index -= shift;\n\n    this.ctxMeshes.fillStyle = '#ff0000';\n    this.ctxMeshes.fillRect(index - 1, 0, 1, ly);\n    this.ctxMeshes.fillRect(index + 1, 0, 1, ly);\n    this.ctxTextures.fillStyle = '#ff0000';\n    this.ctxTextures.fillRect(index - 1, 0, 1, ly);\n    this.ctxTextures.fillRect(index + 1, 0, 1, ly);\n    this.ctxTextures2.fillStyle = '#ff0000';\n    this.ctxTextures2.fillRect(index - 1, 0, 1, ly);\n    this.ctxTextures2.fillRect(index + 1, 0, 1, ly);\n    this.ctxGeodata.fillStyle = '#ff0000';\n    this.ctxGeodata.fillRect(index - 1, 0, 1, ly);\n    this.ctxGeodata.fillRect(index + 1, 0, 1, ly);\n    this.ctxMetatiles.fillStyle = '#ff0000';\n    this.ctxMetatiles.fillRect(index - 1, 0, 1, ly);\n    this.ctxMetatiles.fillRect(index + 1, 0, 1, ly);\n    this.ctxIntervals.fillStyle = '#ff0000';\n    this.ctxIntervals.fillRect(index - 1, 0, 1, ly);\n    this.ctxIntervals.fillRect(index + 1, 0, 1, ly);\n    this.ctxThreads.fillStyle = '#ff0000';\n    this.ctxThreads.fillRect(index - 1, 0, 1, ly);\n    this.ctxThreads.fillRect(index + 1, 0, 1, ly);\n\n    if (!avgMeshesCount) { minMeshes = 0, maxMeshes = 0; }\n    if (!avgTexturesCount) { minTextures = 0, maxTextures = 0; }\n    if (!avgTextures2Count) { minTextures2 = 0, maxTextures2 = 0; }\n    if (!avgGeodataCount) { minGeodata = 0, maxGeodata = 0; }\n    if (!avgMetatilesCount) { minMetatiles = 0, maxMetatiles = 0; }\n    if (!avgThreadsCount) { minThreads = 0, maxThreads = 0; }\n    if (!avgIntervalsCount) { minIntervals = 0, maxIntervals = 0; }\n\n    avgMeshes = avgMeshesCount ? (avgMeshes/avgMeshesCount) : 0;\n    avgTextures = avgTexturesCount ? (avgTextures/avgTexturesCount) : 0;\n    avgTextures2 = avgTextures2Count ? (avgTextures2/avgTextures2Count) : 0;\n    avgGeodata = avgGeodataCount ? (avgGeodata/avgGeodataCount) : 0;\n    avgMetatiles = avgMetatilesCount ? (avgMetatiles/avgMetatilesCount) : 0;\n    avgIntervals = avgIntervalsCount ? (avgIntervals/avgIntervalsCount) : 0;\n    avgThreads = avgThreadsCount ? (avgThreads/avgThreadsCount) : 0;\n\n    this.infoMeshes.innerHTML = 'Meshes Min/Max/Avg/Count: ' + minMeshes.toFixed(0) + '/' + maxMeshes.toFixed(0) + '/' + avgMeshes.toFixed(1) + '/' + avgMeshesCount;\n    this.infoTextures.innerHTML = 'Internal Textures Min/Max/Avg/Count: ' + minTextures.toFixed(0) + '/' + maxTextures.toFixed(0) + '/' + avgTextures.toFixed(1) + '/' + avgTexturesCount;\n    this.infoTextures2.innerHTML = 'External Textures Min/Max/Avg/Count: ' + minTextures2.toFixed(0) + '/' + maxTextures2.toFixed(0) + '/' + avgTextures2.toFixed(1) + '/' + avgTextures2Count;\n    this.infoGeodata.innerHTML = 'Geodata Min/Max/Avg/Count: ' + minGeodata.toFixed(0) + '/' + maxGeodata.toFixed(0) + '/' + avgGeodata.toFixed(1) + '/' + avgGeodataCount;\n    this.infoMetatiles.innerHTML = 'Metatiles Min/Max/Avg/Count: ' + minMetatiles.toFixed(0) + '/' + maxMetatiles.toFixed(0) + '/' + avgMetatiles.toFixed(1) + '/' + avgMetatilesCount;\n    this.infoIntervals.innerHTML = 'Intervals Min/Max/Avg: ' + minIntervals.toFixed(0) + '/' + maxIntervals.toFixed(0) + '/' + avgIntervals.toFixed(1);  \n    this.infoThreads.innerHTML = 'Threads Min/Max/Avg: ' + minThreads + '/' + maxThreads + '/' + avgThreads.toFixed(1);  \n};\n\n\nInspectorReplay.prototype.updateFileInfo = function(index) {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var replay = map.draw.replay;\n    var file = replay.loaded[index];\n\n    if (file) {\n        this.timeInfo.innerHTML = ''\n            + 'Resource Kind: ' + file.kind + '<br/>'\n            + 'Time: ' + file.time.toFixed(2) + '<br/>'\n            + 'Duration: ' + file.duration.toFixed(2) + '<br/>'\n            + 'Interval: ' + file.interval.toFixed(2) + '<br/>'\n            + 'Priority: ' + file.priority.toFixed(2) + '<br/>'\n            + 'Threads: ' + file.threads + '<br/>'\n            + '' + file.url;\n    } else {\n        this.timeInfo.innerHTML = '';\n    }\n};\n\n\nInspectorReplay.prototype.buildReplayCombo = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var items = [\n        ['Drawn Tiles',1],\n        ['Drawn Tiles - Free Layers',1],\n        ['Traced Nodes',1],\n        ['Traced Nodes - Free Layers',1],\n        ['Load Sequence',2],\n        ['Camera',2],\n        ['Globe',0]\n    ];\n\n    var keys = [\n        'DrawnTiles',\n        'DrawnTilesFreeLayers',\n        'TracedNodes',\n        'TracedNodesFreeLayers',\n        'LoadSequence',\n        'Camera',\n        'Globe'\n    ];\n\n    var html = '', i, li, htmlId;\n\n    for (i = 0, li = items.length; i < li; i++) {\n        html += '<div id=\"vts-replay-item-' + keys[i] + '\" class=\"vts-replay-item\">'\n                 + '<input id=\"vts-replay-checkbox-' + keys[i] + '\" type=\"checkbox\"/>'\n                 + '<span title=' + items[i][0] + '>' + items[i][0] + '&nbsp;&nbsp;</span>';\n                 \n        if (items[i][1] > 0) {\n            html += '<input id=\"vts-replay-sbutton-' + keys[i] + '\" type=\"button\" value=\"S\"/>';\n        }\n        \n        if (items[i][1] > 1) {\n            html += '<input id=\"vts-replay-fbutton-' + keys[i] + '\" type=\"button\" value=\"' + ((keys[i] == 'Camera') ? 'R' : 'F') + '\"/>';\n        }\n        \n        html += '</div>';\n    }\n\n    this.items.innerHTML = html;\n    //this.currentItem = keys[0];\n\n    for (i = 0, li = items.length; i < li; i++) {\n        htmlId = 'vts-replay-checkbox-' + keys[i];\n        document.getElementById(htmlId).onchange = this.switchItem.bind(this, keys[i], htmlId);\n        //var htmlId = \"vts-replay-item-\" + keys[i];\n        //document.getElementById(htmlId).onclick = this.selectReplayItem.bind(this, keys[i]);\n\n        if (items[i][1] > 0) {\n            htmlId = 'vts-replay-sbutton-' + keys[i];\n            document.getElementById(htmlId).onclick = this.itemButton.bind(this, keys[i], 'S');\n        }\n\n        if (items[i][1] > 1) {\n            htmlId = 'vts-replay-fbutton-' + keys[i];\n            document.getElementById(htmlId).onclick = this.itemButton.bind(this, keys[i], ((keys[i] == 'Camera') ? 'R' : 'F'));\n        }\n    }\n};\n\n\nexport default InspectorReplay;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/inspector/replay.js\n// module id = 122\n// module chunks = 0 1","\n\nimport {getCoreVersion} from '../core';\n\n\nvar InspectorStats = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorStats.prototype.init = function() {\n    var inspector = this.inspector;\n    inspector.addStyle(\n        '#vts-stats-panel {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'display: none;'\n            + 'padding:15px;'\n            + 'width: 305px;'\n            + 'font-size: 14px;'\n            + 'position: absolute;'\n            + 'right: 10px;'\n            + 'top: 10px;'\n            + 'cursor: default;'\n            + 'background-color: rgba(255,255,255,0.95);'\n            + 'border-radius: 5px;'\n            + 'border: solid 1px #ccc;'\n            + 'text-align: left;'\n            + 'z-index: 7;'\n            + 'padding: 10px;'\n        + '}'\n\n        + '#vts-stats-panel-info {'\n            + 'margin-top: 5px;'\n            + 'margin-bottom: 3px;'\n            + 'overflow: hidden;'\n        + '}'\n\n        + '#vts-stats-panel-info table {'\n            + 'color:#000000;'\n            + 'text-align: left;'\n            + 'font-size: 12px;'\n        + '}'\n\n        + '#vts-stats-panel-info table td {'\n            + 'vertical-align: top;'\n        + '}'\n\n        + '#vts-stats-panel-pos {'\n            + 'width: 100%;'\n        + '}'\n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-stats-panel';\n    this.element.innerHTML =\n        '<span id=\"vts-stats-panel-title\">Render statistics &nbsp;&nbsp;&nbsp;v' + getCoreVersion() + '</h3>'+\n        '<p id=\"vts-stats-panel-info\"></p>'+\n        '<input id=\"vts-stats-panel-pos\" type=\"text\">';\n\n    this.core.element.appendChild(this.element);\n    this.infoElement = document.getElementById('vts-stats-panel-info');\n    this.posElement = document.getElementById('vts-stats-panel-pos');\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.panelVisible = false;\n};\n\n\nInspectorStats.prototype.showPanel = function() {\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n};\n\n\nInspectorStats.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n};\n\n\nInspectorStats.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorStats.prototype.updateStatsPanel = function(stats) {\n    if (!this.infoElement || !this.panelVisible) {\n        return;\n    }\n    var inspector = this.inspector;\n    \n    var text2 =\n            'FPS: ' + Math.round(stats.fps) + '<br/>' +\n            'Render time: ' + Math.round(stats.renderTime*1000) + '<br/>' +\n            ' - resources: ' + Math.round(stats.gpuRenderUsed/(1024*1024)) + 'MB<br/>' +\n            ' - topdown: ' + Math.round(stats.gpuNeeded/(1024*1024)) + 'MB<br/>' +\n            //\" - resources: \" + (stats.gpuRenderUsed) + \" --- \" + (stats.gpuRenderUsed / stats.drawnTiles) + \"<br/>\" +\n            'GPU Cache: ' + Math.round(stats.gpuUsed/(1024*1024)) + 'MB<br/>' +\n            ' - textures: ' + Math.round(stats.gpuTextures/(1024*1024)) + 'MB<br/>' +\n            ' - meshes: ' + Math.round(stats.gpuMeshes/(1024*1024)) + 'MB<br/>' +\n            ' - geodata: ' + Math.round(stats.gpuGeodata/(1024*1024)) + 'MB<br/>' +\n            'CPU Cache: ' + Math.round(stats.resourcesUsed/(1024*1024)) + 'MB<br/>' +\n            'Metaile Cache: ' + Math.round(stats.metaUsed/(1024*1024)) + 'MB<br/>' +\n//            \"FOV: \" + Math.round(this.core.getOption(\"fov\")) + \" deg<br/>\" +\n//            \"viewHeight: \" + Math.round(this.core.getOption(\"viewHeight\")) + \" m<br/>\" +\n//            \"distance: \" + Math.round(this.core.renderer.cameraDistance) + \" m<br/>\" +\n            'Draw calls: ' + (stats.drawCalls) + '<br/>' +\n            'Polygons: ' + (stats.drawnFaces) + '<br/><br/>' +\n            'Terrain Height: ' + (stats.heightTerrain.toFixed(2)) + '<br/>' +\n            '- float: ' + (stats.heightDelta.toFixed(2)) + '<br/>' +\n            '- desired lod: ' + (stats.heightLod.toFixed(2)) + '<br/>' +\n            '- used lod: ' + (stats.heightNode.toFixed(2)) + '<br/>' +\n            '- used source: ' + ((stats.heightClass == 2 ? 'navtile' : stats.heightClass == 1 ? 'node': '---') ) + '<br/>' +\n            'Terrain Radar Lod: ' + (inspector.radarLod) + '<br/><br/>' + \n            'Loaded/Errors: ' + (stats.loadedCount) + ' / ' + (stats.loadErrorCount) + '<br/>' +\n            'Load time: ' + ((stats.loadLast - stats.loadFirst)*0.001).toFixed(2) + 's <br/>';\n\n    var renderer = this.core.renderer;\n\n    if (renderer) {\n        text2 += '<br/>Render jobs: ' + renderer.totalJobs + '<br/>' +\n                 'Drawn jobs: ' + renderer.drawnJobs + '<br/>' +\n                 'Jobs total time: ' +  Math.round((renderer.jobsTimer2 - renderer.jobsTimer1)*1000) + '<br/>' +\n                 'Jobs reduce time: ' + Math.round((renderer.jobsTimer4)*1000) + '<br/>';\n    }\n\n    if (stats.debugStr) {\n        text2 += stats.debugStr + '<br/>';        \n    }\n\n    var text3 = 'Metatiles: ' + (stats.processedMetatiles) +'<br/>'+\n                 'Metanodes: ' + (stats.processedNodes) + ' / ' + (stats.usedNodes) + '<br/>'+\n                 'GeodataTiles: ' + (stats.drawnGeodataTiles) + '<br/><br/>' +\n                 //'GVGeodataTiles: ' + (stats.drawnGeodataTilesPerLayer) +'<br/><br/>' +\n                 'Tiles: ' + (stats.drawnTiles) +'<br/>';\n\n    for (var i =0, li = stats.renderedLods.length; i < li; i++) {\n        if (stats.renderedLods[i]) {\n            text3 += 'LOD ' + i + ': ' + (stats.renderedLods[i]) +'<br/>';\n        }\n    }\n\n\n    var text = '<table style=\"width:305px\"><tr><td>' + text2 + '</td><td>' + text3 + '</td></tr></table>';\n\n    this.infoElement.innerHTML = text;\n\n    var map = this.core.getMap();\n\n    if (map != null) {\n        var p = map.getPosition();\n        var s = '';\n        s += p.getViewMode() + ',';\n        var c = p.getCoords();\n        s += c[0] + ',' + c[1] + ',' + p.getHeightMode() + ',' + c[2].toFixed(2) + ',';\n        var o = p.getOrientation();\n        s += o[0].toFixed(2) + ',' + o[1].toFixed(2) + ',' + o[2].toFixed(2) + ',';\n        s += p.getViewExtent().toFixed(2) + ',' + p.getFov().toFixed(2);\n        \n        //var value = JSON.stringify(p.pos);\n\n        if (this.posElement.value != s) {\n            this.posElement.value = s;\n        }\n    }\n};\n\n\nexport default InspectorStats;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/inspector/stats.js\n// module id = 123\n// module chunks = 0 1","\nvar InspectorStylesheets = function(inspector) {\n    this.inspector = inspector;\n    this.core = inspector.core;\n};\n\n\nInspectorStylesheets.prototype.init = function() {\n    var inspector = this.inspector;\n    inspector.addStyle(\n        '#vts-stylesheets-panel * {'\n            + 'all: initial;'\n        + '}'\n\n        + '#vts-stylesheets-panel {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'display: none;'\n            + 'padding:15px;'\n            + 'width: 1200px;'\n            + 'height: 350px;'\n            + 'font-size: 14px;'\n            + 'position: absolute;'\n            + 'right: 10px;'\n            + 'bottom: 10px;'\n            + 'cursor: default;'\n            + 'background-color: rgba(255,255,255,0.95);'\n            + 'border-radius: 5px;'\n            + 'border: solid 1px #ccc;'\n            + 'text-align: left;'\n            + 'z-index: 7;'\n            + 'padding: 10px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-header {'\n            + 'width: 100%;'\n            + 'height: 28px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-combo {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'font-size: 13px;'\n            + 'border: 1px solid #a9a9a9;'\n            + 'width: 1070px;'\n            + 'height: 17px;'\n            + 'padding: 2px;'\n            + 'margin-bottom: 5px;'\n            + '-webkit-appearance: menulist;'\n            + '-moz-appearance: menulist;'\n        + '}'\n\n        + '#vts-stylesheets-panel-combo option {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'font-size: 13px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-update-button {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'font-size: 14px;'\n            + 'float: right;'\n            + 'background-color: #dedede;'\n            + 'padding: 3px 2px 2px 2px;'\n            + 'border: 1px solid #a0a0a0;'\n            + 'border-radius: 2px;'\n            + 'margin-right: 5px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-hide-button {'\n            + 'font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;'\n            + 'font-size: 14px;'\n            + 'float: right;'\n            + 'background-color: #dedede;'\n            + 'padding: 3px 2px 2px 2px;'\n            + 'border: 1px solid #a0a0a0;'\n            + 'border-radius: 2px;'\n        + '}'\n\n        + '#vts-stylesheets-panel-text {'\n            + 'font-family: monospace;'\n            + 'border: 1px solid #a9a9a9;'\n            + 'padding: 2px 0px 0px 2px;'\n            + 'width: 100%;'\n            + 'height: 300px;'\n            + 'resize: none;'\n            + 'white-space: pre;'\n        + '}'\n    );\n\n    this.element = document.createElement('div');\n    this.element.id = 'vts-stylesheets-panel';\n    this.element.innerHTML =\n            '<div id=\"vts-stylesheets-panel-header\">'\n            + '<select id=\"vts-stylesheets-panel-combo\"></select>'\n            + '<button id=\"vts-stylesheets-panel-hide-button\" type=\"button\" title=\"Hide\">Hide</button>'\n            + '<button id=\"vts-stylesheets-panel-update-button\" type=\"button\" title=\"Update\">Update</button>'\n          + '</div>'\n          + '<textarea id=\"vts-stylesheets-panel-text\" rows=\"4\" cols=\"50\">aa\\naa\\n</textarea>';\n\n    //this.inspectorElement.appendChild(this.element);\n    this.core.element.appendChild(this.element);\n\n    this.optionsElement = document.getElementById('vts-stylesheets-panel-combo');\n    this.optionsElement.onchange = this.onComboSwitched.bind(this);\n\n    this.textElement = document.getElementById('vts-stylesheets-panel-text');\n    \n    document.getElementById('vts-stylesheets-panel-update-button').onclick = this.onUpdate.bind(this);\n    document.getElementById('vts-stylesheets-panel-hide-button').onclick = this.hidePanel.bind(this);\n\n    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);\n    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);\n    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);\n\n    this.textElement.addEventListener('keyup', inspector.doNothing.bind(this), false);\n    this.textElement.addEventListener('keydown', inspector.doNothing.bind(this), false);\n\n    this.panelVisible = false;\n};\n\n\nInspectorStylesheets.prototype.showPanel = function() {\n    this.buildStylesheetsCombo();\n    this.element.style.display = 'block';\n    this.panelVisible = true;\n};\n\n\nInspectorStylesheets.prototype.hidePanel = function() {\n    this.element.style.display = 'none';\n    this.panelVisible = false;\n};\n\n\nInspectorStylesheets.prototype.switchPanel = function() {\n    if (this.panelVisible) {\n        this.hidePanel();\n    } else {\n        this.showPanel();\n    }\n};\n\n\nInspectorStylesheets.prototype.onComboSwitched = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var stylesheet = map.getStylesheet(this.optionsElement.value);\n    this.textElement.value = this.niceStyleFormat(stylesheet);\n};\n\n\nInspectorStylesheets.prototype.onUpdate = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    map.setStylesheetData(this.optionsElement.value, JSON.parse(this.textElement.value));\n};\n\n\nInspectorStylesheets.prototype.niceStyleFormat = function(data) {\n    if (!data || !data.data) {\n        return '';\n    }\n    \n    data = data.data;\n\n    //return JSON.stringify(data, null, \"  \");\n    \n    var tmp = '';\n    tmp += '{\\n';\n\n    var elements = [];\n\n    if (data['constants']) {\n        elements.push('constants');\n    } \n\n    if (data['bitmaps']) {\n        elements.push('bitmaps');\n    } \n\n    if (data['fonts']) {\n        elements.push('fonts');\n    } \n\n    if (data['layers']) {\n        elements.push('layers');\n    } \n    \n    for (var j = 0, lj = elements.length; j < lj; j++) {\n        var type = elements[j];\n        tmp += '  \"' + type + '\": {\\n';\n\n        var element = data[type];\n\n        var buff = [];\n        for (var key in element) {\n            buff.push(key);\n        }\n\n        for (var i = 0, li = buff.length; i < li; i++) {\n            if (type == 'layers') {\n                \n                var element2 = element[buff[i]];\n                \n                var buff2 = [];\n                for (var key2 in element2) {\n                    buff2.push(key2);\n                }\n\n                tmp += '    \"' + buff[i] + '\": {\\n';\n\n                for (var k = 0, lk = buff2.length; k < lk; k++) {\n                    tmp += '      \"' + buff2[k] + '\": ' + JSON.stringify(element2[buff2[k]]) + (k == (lk - 1) ? '' : ',') + '\\n';\n                }\n                \n                tmp += '    }'  + (i == (li - 1) ? '' : ',\\n');\n            } else {\n                tmp += '    \"' + buff[i] + '\": ' + JSON.stringify(element[buff[i]]) + (i == (li - 1) ? '' : ',') + '\\n';\n            }\n        }\n        \n        tmp += '\\n  }' + (j == (lj - 1) ? '' : ',\\n');\n    }\n    \n    tmp += '\\n}';\n    \n    return tmp;\n};\n\n\nInspectorStylesheets.prototype.buildStylesheetsCombo = function() {\n    var map = this.core.getMap();\n    if (!map) {\n        return;\n    }\n\n    var html = '';\n\n    var styles = map.getStylesheets();\n    \n    for (var i = 0, li = styles.length; i < li; i++) {\n        html += '<option value=\"' + styles[i] + '\">' + styles[i] + '</option>';\n    }    \n    \n    this.optionsElement.innerHTML = html;\n    \n    var stylesheet = map.getStylesheet(styles[0]);\n    this.textElement.value = this.niceStyleFormat(stylesheet);\n};\n\n\nexport default InspectorStylesheets;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/inspector/stylesheets.js\n// module id = 124\n// module chunks = 0 1","\nvar MapBody = function(map, json) {\n    //this.map = map;\n    //this.id = json[\"id\"] || null;\n    this.parse(json);\n};\n\n\nMapBody.prototype.parse = function(json) {\n    this.class = json['class'] || '';\n    this.comment = json['comment'] || '';\n    this.parent = json['parent'] || '';\n    this.atmosphere = json['atmosphere'] || null;\n\n    if (this.atmosphere) {\n        if (!this.atmosphere['colorHorizon']) this.atmosphere['colorHorizon'] = [0,0,0,0];\n        if (!this.atmosphere['colorZenith']) this.atmosphere['colorZenith'] = [0,0,0,0];\n        if (!this.atmosphere['thickness'])  this.atmosphere['thickness'] = 100000;\n        if (!this.atmosphere['visibility'])  this.atmosphere['visibility'] = 100000;\n    }\n};\n\n\nMapBody.prototype.getInfo = function() {\n    return {\n        'class' : this.class,\n        'comment' : this.comment,\n        'parent' : this.parent,\n        'atmosphere' : JSON.parse(JSON.stringify(this.atmosphere)),\n    };\n};\n\n\nexport default MapBody;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/body.js\n// module id = 125\n// module chunks = 0 1","\n\nvar MapCache = function(map, maxCost) {\n    this.map = map;\n    this.maxCost = (maxCost != null) ? maxCost : Number.MAX_VALUE;\n    this.skipCostCheck = false;\n    this.last = null;\n    this.first = null;\n\n    this.totalCost = 0;\n    this.totalItems = 0;\n};\n\n\nMapCache.prototype.updateItem = function(item) {\n    if (item == null) {\n        return;\n    }\n\n    if (this.first == item) {\n        return;\n    }\n\n    //remove item from list\n    if (item.prev != null) {\n        item.prev.next = item.next;\n    }\n\n    if (item.next != null) {\n        item.next.prev = item.prev;\n    }\n\n    if (this.last == item) {\n        this.last = item.prev;\n    }\n\n    var first = this.first;\n\n    //add item as first\n    this.first = item;\n    this.first.next = first;\n    this.first.prev = null;\n\n    first.prev = this.first;\n};\n\n\nMapCache.prototype.getMaxCost = function() {\n    return this.maxCost;\n};\n\n\nMapCache.prototype.setMaxCost = function(cost) {\n    this.maxCost = cost;\n    this.checkCost();\n};\n\n\nMapCache.prototype.clear = function() {\n    var item = this.first;\n\n    while (item != null) {\n        if (item.destructor != null) {\n            item.destructor();\n        }\n        item = item.next;\n    }\n\n    this.last = null;\n    this.first = null;\n\n    this.totalCost = 0;\n    this.totalItems = 0;\n};\n\n\nMapCache.prototype.insert = function(destructor, cost) {\n    this.totalItems++;\n\n    //console.log(\"insert: \" + hash + \" items: \" + this.totalItems);\n\n    var item = { destructor:destructor, cost:cost, prev: null, next:this.first };\n\n    if (this.first != null) {\n        this.first.prev = item;\n    }\n\n    //add item as first in list\n    this.first = item;\n\n    if (this.last == null) {\n        this.last = item;\n    }\n\n    this.totalCost += cost;\n\n    //console.log(\"MapCache.prototype.insert:\" + this.totalCost + \" / \" + this.maxCost);\n\n    this.checkCost();\n\n    return item;\n};\n\n\nMapCache.prototype.remove = function(item) {\n    this.totalItems++;\n    var hit = false;\n\n    if (item == this.first) {\n        this.first = item.next;\n        hit = true;\n\n        if (this.first != null) {\n            this.first.prev = null;\n        }\n    }\n\n    if (item == this.last) {\n        this.last = item.prev;\n        hit = true;\n\n        if (this.last != null) {\n            this.last.next = null;\n        }\n    }\n\n    if (!hit) {\n    //if (item != this.last && item != this.first) {\n\n        if (!item.prev) {\n            //debugger;\n        } else {\n            item.prev.next = item.next;\n        }\n        \n        if (!item.next) {\n            //debugger;\n        } else {\n            item.next.prev = item.prev;\n        }\n        \n    }\n\n    this.totalCost -= item.cost;\n\n    //destroy item\n    item.destructor();\n\n    //console.log(\"MapCache.prototype.remove:\" + this.totalCost + \" / \" + this.maxCost);\n\n    this.checkCost();\n};\n\n\nMapCache.prototype.checkCost = function() {\n    if (this.skipCostCheck) {\n        return;\n    }\n\n    while (this.totalCost > this.maxCost) {\n\n        this.totalItems--;\n\n        //console.log(\"remove: \" + this.last.hash + \" prev: \" + this.last.prev + \" items: \" + this.totalItems);\n\n        var last = this.last;\n\n        if (last != null) {\n            //set new last\n            this.last = this.last.prev;\n\n            if (this.last != null) {\n                this.last.next = null;\n            }\n\n            this.totalCost -= last.cost;\n\n            //destroy item\n            last.destructor();\n\n        } else {\n            break;\n        }\n    }\n};\n\n\nMapCache.prototype.addItem = function(cost, destructor) {\n    return this.insert(destructor, cost);\n};\n\n\nMapCache.prototype.removeItem = function(item) {\n    return this.remove(item);\n};\n\n\nMapCache.prototype.itemUsed = function(item) {\n    return this.updateItem(item);\n};\n\n/*\nMapCache.prototype[\"addItem\"] = MapCache.prototype.addItem;\nMapCache.prototype[\"removeItem\"] = MapCache.prototype.removeItem;\nMapCache.prototype[\"itemUsed\"] = MapCache.prototype.itemUsed;\n*/\n\nexport default MapCache;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/cache.js\n// module id = 126\n// module chunks = 0 1","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar math = math_;\n\n\nvar MapCamera = function(map) {\n    this.map = map;\n    this.camera = map.renderer.camera;\n    this.distance = 10;\n    this.distance2 = 10;\n    this.position = [0,0,0];\n    this.vector = [0,0,1];\n    this.vector2 = [0,0,1,1];\n    this.center = [0,0,0];\n    this.height = 0;\n    this.terrainHeight = 0;\n    this.lastTerrainHeight = 0;\n    this.near = 2;\n};\n\n\nMapCamera.prototype.update = function() {\n    var map = this.map;\n\n    //check position orientaion ...\n    map.position.check();\n\n    //var height = 227;\n    var height = map.position.getHeight();\n\n    var lod =  map.measure.getOptimalHeightLod(map.position.getCoords(), map.position.getViewExtent(), map.config.mapNavSamplesPerViewExtent);\n    //var surfaceHeight = [226,true,true]; //map.getSurfaceHeight(map.position.getCoords(), lod, true);\n    var surfaceHeight = map.measure.getSurfaceHeight(map.position.getCoords(), lod, true);\n    \n    map.stats.heightTerrain = surfaceHeight[0];\n    map.stats.heightDelta = height;\n\n    //console.log(\"terrain height:\" + surfaceHeight[0] + \"  pos height:\" + map.position.getHeight());\n\n    if (map.position.getHeightMode() == 'float') {\n        height += surfaceHeight[0];\n    }\n\n    var camInfo = map.measure.getPositionCameraInfo(map.position, map.getNavigationSrs().isProjected());\n\n    this.camera.setPosition(camInfo.orbitCoords);\n    this.camera.setRotationMatrix(camInfo.rotMatrix);\n    this.vector = camInfo.vector;\n    this.vector2 = camInfo.vector2;\n    this.position = camInfo.orbitCoords;\n    this.height = camInfo.orbitHeight + height;\n    this.terrainHeight = this.height - surfaceHeight[0];\n\n    //get camera distance\n    this.distance2 = map.position.getViewDistance();\n    this.distance = Math.max(this.terrainHeight, this.distance2);\n    this.distance = math.clamp(this.distance, 0.1, this.camera.getFar());\n\n    this.distanceFactor = Math.tan(math.radians(map.position.getFov()*0.5)); \n\n    this.perceivedDistance = Math.max(this.terrainHeight, this.distance2 * this.distanceFactor);\n    \n    //this.renderer.cameraDistance = camInfo.distance; //needed for fog\n    map.renderer.cameraDistance = this.distance; //needed for fog\n    map.renderer.viewExtent = map.position.getViewExtent();\n\n    this.camera.setViewHeight(map.position.getViewExtent());\n    //this.camera.setOrtho(true);\n\n    //convert nav coords to physical\n    var coords = map.position.getCoords();\n    var worldPos = map.convert.convertCoords([coords[0], coords[1], height], 'navigation', 'physical');\n    this.center = [worldPos[0], worldPos[1], worldPos[2]];\n    worldPos[0] += camInfo.orbitCoords[0];\n    worldPos[1] += camInfo.orbitCoords[1];\n    worldPos[2] += camInfo.orbitCoords[2];\n    this.camera.setPosition([0,0,0]); //always zeros\n    this.position = worldPos;\n\n    this.vector2 = [-worldPos[0], -worldPos[1], -worldPos[2], 1];\n    vec3.normalize(this.vector2);\n\n    this.mapIsProjected = map.getNavigationSrs().isProjected();\n\n    if (!this.mapIsProjected) { //HACK!!!!!!!!\n        this.geocentDistance = vec3.length(this.position);\n\n        var n = [0,0,0];\n        vec3.normalize(this.position, n);\n        this.geocentNormal = n;\n    } else {\n        this.vector2[3] = 0;\n    }\n    \n    //console.log(\"word-pos: \" + JSON.stringify(worldPos));\n\n    //set near and far of camera by distance of orbit\n    var factor = Math.max(this.height, this.distance) / 600000;\n\n    var near = Math.max(this.near, this.near * (factor * 20));\n    factor = Math.max(1.0, factor);\n    var far = 600000 * (factor * 10);\n\n    //console.log(\"near: \" + near + \"  far: \" + far);\n\n    this.camera.setParams(map.position.getFov()*0.5, near, far * 2.0);\n    \n    return camInfo;\n};\n\n\nMapCamera.prototype.getCameraHeight = function() {\n    //TODO: get camera height\n    //var cameraPos = this.camera.position;\n    //return (this.camera.getPosition()[2] - this.planet.surfaceHeight([this.position[0] + cameraPos[0], this.position[1] + cameraPos[1]])[0]);\n\n    //hack - distance intead of height\n    //return this.cameraDistance;\n    return this.cameraHeight;\n};\n\n\nMapCamera.prototype.getMvpMatrix = function() {\n    return this.camera.getMvpMatrix();\n};\n\n\nMapCamera.prototype.getRotationMatrix = function() {\n    return this.camera.getRotationMatrix();\n};\n\n\nMapCamera.prototype.getRotationviewMatrix = function() {\n    return this.camera.getRotationviewMatrix();\n};\n\n\nMapCamera.prototype.getFar = function() {\n    return this.camera.getFar();\n};\n\n\nMapCamera.prototype.getFov = function() {\n    return this.camera.getFov();\n};\n\n\nMapCamera.prototype.getAspect = function() {\n    return this.camera.getAspect();\n};\n\n\nexport default MapCamera;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/camera.js\n// module id = 127\n// module chunks = 0 1","\nimport MapBoundLayer_ from './bound-layer';\nimport MapCredit_ from './credit';\nimport MapRefFrame_ from './refframe';\nimport MapView_ from './view';\nimport MapSrs_ from './srs';\nimport MapBody_ from './body';\nimport MapSurface_ from './surface';\nimport MapVirtualSurface_ from './virtual-surface';\nimport MapStylesheet_ from './stylesheet';\n\n//get rid of compiler mess\nvar MapCredit = MapCredit_;\nvar MapBoundLayer = MapBoundLayer_;\nvar MapRefFrame = MapRefFrame_;\nvar MapView = MapView_;\nvar MapSrs = MapSrs_;\nvar MapBody = MapBody_;\nvar MapSurface = MapSurface_;\nvar MapVirtualSurface = MapVirtualSurface_;\nvar MapStylesheet = MapStylesheet_;\n\n\nvar MapConfig = function(map, config) {\n    this.map = map;\n    this.mapConfig = config;\n    this.parseConfig();\n};\n\n\nMapConfig.prototype.parseConfig = function() {\n    if (!(this.parseSrses() && this.parseBodies() && this.parseReferenceFrame() &&\n          this.parseCredits() && this.parseStylesheets() && \n          this.parseSurfaces() && this.parseGlues() && \n          this.parseVirtualSurfaces() && this.parseBoundLayers() &&\n          this.parseFreeLayers() && this.parseViews() &&\n          this.parseParams() && this.parseBrowserOptions() )) {\n        //wrong config file\n    }\n\n    var stats = this.map.stats;\n    stats.loadedCount = 0;\n    stats.loadErrorCount = 0;\n    stats.loadFirst = performance.now();\n    stats.loadLast = this.map.loadFirst;\n};\n\n\nMapConfig.prototype.afterConfigParsed = function() {\n    if (this.mapConfig['position'] != null) {\n        this.map.setPosition(this.mapConfig['position'], false);\n    }\n\n    this.map.setView(this.map.initialView);\n};\n\n\nMapConfig.prototype.parseSrses = function() {\n    var srses = this.mapConfig['srses'];\n    this.map.srses = {};\n\n    if (srses == null) {\n        return false;\n    }\n\n    for (var key in srses) {\n        this.map.addSrs(key, new MapSrs(this.map, key, srses[key]));\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseBodies = function() {\n    var bodies = this.mapConfig['bodies'];\n    this.map.bodies = {};\n\n    if (bodies == null) {\n        return true;//false;\n    }\n\n    for (var key in bodies) {\n        this.map.addBody(key, new MapBody(this.map, bodies[key]));\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseReferenceFrame = function() {\n    var rf = this.mapConfig['referenceFrame'];\n\n    if (rf == null) {\n        return false;\n    }\n\n    this.map.referenceFrame = new MapRefFrame(this.map, rf);\n\n    if (!this.map.referenceFrame.valid) {\n        return false;\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseCredits = function() {\n    var credits = this.mapConfig['credits'];\n    this.map.credits = {};\n\n    if (credits == null) {\n        return false;\n    }\n\n    for (var key in credits) {\n        this.map.addCredit(key, new MapCredit(this.map, credits[key]));\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseSurfaces = function() {\n    var surfaces = this.mapConfig['surfaces'];\n    this.map.surfaces = [];\n\n    if (surfaces == null) {\n        return false;\n    }\n\n    for (var i = 0, li = surfaces.length; i < li; i++) {\n        var surface = new MapSurface(this.map, surfaces[i]);\n        this.map.addSurface(surface.id, surface);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseVirtualSurfaces = function() {\n    var surfaces = this.mapConfig['virtualSurfaces'];\n    this.map.virtualSurfaces = [];\n\n    if (!this.map.config.mapVirtualSurfaces) {\n        return true;\n    }\n\n    if (surfaces == null) {\n        return true;\n    }\n\n    for (var i = 0, li = surfaces.length; i < li; i++) {\n        var surface = new MapVirtualSurface(this.map, surfaces[i]);\n        this.map.virtualSurfaces[surface.strId] = surface;\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseViews = function() {\n    var views = this.mapConfig['namedViews'];\n    this.map.namedViews = [];\n\n    if (views) {\n        for (var key in views) {\n            this.map.addNamedView(key, new MapView(this.map, views[key]));\n        }\n    }\n\n    var view = this.mapConfig['view'];\n\n    if (typeof view === 'string') {\n        view = this.map.namedViews[view];\n    }\n\n    if (!view) {\n        return true;\n    }\n\n    this.map.initialView = JSON.parse(JSON.stringify(view));\n    return true;\n};\n\n\nMapConfig.prototype.parseGlues = function() {\n    var glues = this.mapConfig['glue'];\n    this.map.glues = [];\n\n    if (glues == null) {\n        return true;\n    }\n\n    for (var i = 0, li = glues.length; i < li; i++) {\n        var surface = new MapSurface(this.map, glues[i], 'glue');\n        this.map.addGlue(surface.id.join(';'), surface);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseBoundLayers = function() {\n    var layers = this.mapConfig['boundLayers'];\n    this.map.boundLayers = [];\n\n    if (layers == null) {\n        return true;\n    }\n\n    for (var key in layers) {\n        var layer = new MapBoundLayer(this.map, layers[key], key);\n        this.map.addBoundLayer(key, layer);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseFreeLayers = function() {\n    var layers = this.mapConfig['freeLayers'];\n    this.map.freeLayers = [];\n\n    if (layers == null) {\n        return true;\n    }\n\n    for (var key in layers) {\n        var layer = new MapSurface(this.map, layers[key], 'free');\n        this.map.addFreeLayer(key, layer);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseStylesheets = function() {\n    var styles = this.mapConfig['stylesheets'];\n    this.map.stylesheets = [];\n\n    if (styles == null) {\n        return true;\n    }\n\n    for (var key in styles) {\n        var style = new MapStylesheet(this.map, key, styles[key]);\n        this.map.addStylesheet(key, style);\n    }\n\n    return true;\n};\n\n\nMapConfig.prototype.parseParams = function() {\n    return true;\n};\n\n\nMapConfig.prototype.parseBrowserOptions = function() {\n    var options = this.mapConfig['browserOptions'];\n    this.map.browserOptions = {};\n    \n    if (options == null) {\n        return true;\n    }\n    \n    this.map.browserOptions = JSON.parse(JSON.stringify(options));\n    return true;\n};\n\n\nMapConfig.prototype.cloneConfig = function() {\n    var json = JSON.parse(JSON.stringify(this.mapConfig));\n    return json;\n};\n\n\nexport default MapConfig;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/config.js\n// module id = 128\n// module chunks = 0 1","\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport GeographicLib_ from 'geographiclib';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\nvar math = math_;\nvar GeographicLib = GeographicLib_;\n\n\nvar MapConvert = function(map) {\n    this.map = map;\n    this.config = map.config;\n    this.measure = map.measure;\n    this.isProjected = this.map.getNavigationSrs().isProjected();\n};\n\n\nMapConvert.prototype.convertCoords = function(coords, source, destination) {\n    return this.map.referenceFrame.convertCoords(coords, source, destination);\n};\n\n\nMapConvert.prototype.movePositionCoordsTo = function(position, azimuth, distance, azimuthCorrectionFactor) {\n    var coords = position.getCoords();\n    var navigationSrsInfo = this.map.getNavigationSrs().getSrsInfo();\n    azimuthCorrectionFactor = (azimuthCorrectionFactor == null) ? 1 : azimuthCorrectionFactor; \n\n    if (this.isProjected) {\n        var yaw = math.radians(azimuth);\n        var forward = [-Math.sin(yaw), Math.cos(yaw)];\n\n        position.setCoords2([coords[0] + (forward[0]*distance),\n            coords[1] + (forward[1]*distance)]);\n    } else {\n        var geod = this.measure.getGeodesic();\n\n        var r = geod.Direct(coords[1], coords[0], azimuth, distance);\n        position.setCoords2([r.lon2, r.lat2]);\n\n        var orientation = position.getOrientation();\n\n        //console.log(\"corerction: \" + (r.azi1 - r.azi2));\n\n        orientation[0] -= (r.azi1 - r.azi2) * azimuthCorrectionFactor;\n        //orientation[0] -= (r.azi1 - r.azi2); \n\n        //if (!skipOrientation) {\n        position.setOrientation(orientation);\n        //}\n        \n        //console.log(\"azimuthCorrection: \" + azimuthCorrectionFactor);\n        //console.log(\"oldpos: \" + JSON.stringify(this));\n        //console.log(\"newpos: \" + JSON.stringify(pos2));\n    }\n    \n    return position;\n};\n\n\nMapConvert.prototype.convertPositionViewMode = function(position, mode) {\n    if (mode == position.pos[0]) {\n        return position;\n    }\n\n    if (mode == 'obj') {\n        if (position.getHeightMode() == 'float') {\n            var covertToFloat = true;\n            this.convertPositionHeightMode(position, 'fix', true);\n        }\n        \n        var distance = position.getViewDistance(), coords;\n        var orientation = position.getOrientation();\n        \n        //get height delta\n        var pich = math.radians(-orientation[1]);\n        var heightDelta = distance * Math.sin(pich);\n\n        //reduce distance by pich\n        distance *= Math.cos(pich);\n\n        if (this.isProjected) {\n            //get forward vector\n            var yaw = math.radians(orientation[0]);\n            var forward = [-Math.sin(yaw), Math.cos(yaw)];\n    \n            //get center coords \n            coords = position.getCoords();\n            coords[0] = coords[0] + (forward[0] * distance);\n            coords[1] = coords[1] + (forward[1] * distance);\n        } else {\n            this.movePositionCoordsTo(position, -orientation[0], distance);\n            coords = position.getCoords();\n        }\n        \n        coords[2] -= heightDelta;\n        position.setCoords(coords);\n\n        if (covertToFloat) {\n            this.convertPositionHeightMode(position, 'float', true);\n        }\n        \n    } else if (mode == 'subj') {\n        coords = this.getPositionCameraCoords(position, position.getHeightMode());\n        position.setCoords(coords);\n                \n        //TODO: take in accout planet ellipsoid\n    }\n\n    position.pos[0] = mode;\n\n    return position;\n};\n\n\nMapConvert.prototype.convertPositionHeightMode = function(position, mode, noPrecisionCheck) {\n    if (position.pos[3] == mode) {\n        return position;\n    }\n\n    var lod =  this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n    var height = this.measure.getSurfaceHeight(position.getCoords(), lod);\n\n    if (!height[1] && !noPrecisionCheck) {\n        //return null;\n    }\n\n    //set new height\n    if (mode == 'float') {\n        position.pos[3] = mode;\n        position.pos[4] = position.pos[4] - height[0];\n    } else if (mode == 'fix') {\n        position.pos[3] = mode;\n        position.pos[4] = position.pos[4] + height[0];\n    }\n\n    return position;\n};\n\n\nMapConvert.prototype.getPositionCameraCoords = function(position, heightMode) {\n    var orientation = position.getOrientation();\n    var rotMatrix = mat4.create();\n    mat4.multiply(math.rotationMatrix(2, math.radians(-orientation[0])), math.rotationMatrix(0, math.radians(orientation[1])), rotMatrix);\n\n    var coords, terrainHeight = 0, surfaceHeight, lod = -1;\n\n    if (position.getViewMode() == 'obj') {\n        coords = position.getCoords();\n\n        //convert height to fix\n        if (position.getHeightMode() == 'float') {\n            lod = this.measure.getOptimalHeightLod(coords, position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n            surfaceHeight = this.measure.getSurfaceHeight(coords, lod);\n            terrainHeight = surfaceHeight[0];\n        }\n\n        var camInfo = this.measure.getPositionCameraInfo(position, this.isProjected);\n\n        if (this.isProjected) {\n            //var distance = (this.getViewExtent()) / Math.tan(math.radians(this.getFov()*0.5));\n            //var orbitPos = [0, -distance, 0];\n            //math.mat4.multiplyVec3(rotMatrix, orbitPos);\n\n            coords[0] += camInfo.orbitCoords[0];\n            coords[1] += camInfo.orbitCoords[1];\n            coords[2] += camInfo.orbitCoords[2] + terrainHeight;\n        } else {\n            var worldPos = this.convertCoords([coords[0], coords[1], coords[2] + terrainHeight], 'navigation', 'physical');\n            worldPos[0] += camInfo.orbitCoords[0];\n            worldPos[1] += camInfo.orbitCoords[1];\n            worldPos[2] += camInfo.orbitCoords[2];// + terrainHeight;\n\n            coords = this.convertCoords(worldPos, 'physical', 'navigation');\n        }\n\n        if (heightMode == 'fix') {\n            return coords;\n        } else {\n            //get float height for new coords\n            if (lod == -1) {\n                lod =  this.measure.getOptimalHeightLod(coords, position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n            }\n            \n            surfaceHeight = this.measure.getSurfaceHeight(coords, lod);\n            coords[2] -= surfaceHeight[0];\n\n            return coords;\n        }\n\n    } else {\n\n        if (position.getHeightMode() == heightMode) {\n            return position.getCoords();\n        } else {\n            lod =  this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n            surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n            //height += surfaceHeight[0];\n\n            coords = position.getCoords();\n\n            if (heightMode == 'fix') {\n                coords[2] += surfaceHeight[0];\n            } else {\n                coords[2] -= surfaceHeight[0];\n            }\n\n            return coords;\n        }\n    }\n};\n\nMapConvert.prototype.getPositionNavCoordsFromPublic = function(position, lod) {\n    var coords = position.getCoords();\n\n    if (position.getHeightMode() == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n        coords[2] += surfaceHeight[0]; \n    }\n\n    return this.convertCoords(coords, 'public', 'navigation');\n};\n\nMapConvert.prototype.getPositionPublicCoords = function(position, lod) {\n    var coords = position.getCoords();\n\n    if (position.getHeightMode() == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n        coords[2] += surfaceHeight[0]; \n    }\n\n    return this.convertCoords(coords, 'navigation', 'public');\n};\n\n\nMapConvert.prototype.getPositionPhysCoords = function(position, lod) {\n    var coords = position.getCoords();\n\n    if (position.getHeightMode() == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n        coords[2] += surfaceHeight[0]; \n    }\n\n    return this.convertCoords(coords, 'navigation', 'physical');\n};\n\n\nMapConvert.prototype.getPositionCameraSpaceCoords = function(position, lod) {\n    var coords = position.getCoords();\n\n    if (position.getHeightMode() == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);\n        coords[2] += surfaceHeight[0]; \n    }\n\n    var worldPos = this.convertCoords(coords, 'navigation', 'physical');\n    var camPos = this.map.camera.position;\n    worldPos[0] -= camPos[0];\n    worldPos[1] -= camPos[1];\n    worldPos[2] -= camPos[2];\n  \n    return worldPos;\n};\n\n\nMapConvert.prototype.getPositionCanvasCoords = function(position, lod, physical) {\n    var worldPos;\n    if (physical) {\n        var camPos = this.map.camera.position;\n        var coords = position.getCoords();\n        worldPos = [coords[0] - camPos[0],\n            coords[1] - camPos[1],\n            coords[2] - camPos[2]];\n    } else {\n        worldPos = this.getPositionCameraSpaceCoords(position, lod);\n    }\n    \n    return this.map.renderer.project2(worldPos, this.map.camera.getMvpMatrix());\n};\n\nMapConvert.prototype.convertCoordsFromPhysToNav = function(coords, mode, lod) {\n    coords = this.convertCoords(coords, 'physical', 'navigation');\n\n    if (mode == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(coords, 10, this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(coords, lod);\n        coords[2] -= surfaceHeight[0]; \n    }\n\n    return coords;\n};\n\nMapConvert.prototype.getGeodesicLinePoints = function(coords, coords2, height, density) {\n    var geod, r, length, azimuth, minStep, d;\n    var navigationSrsInfo = this.measure.navigationSrsInfo;\n    var dx = coords2[0] - coords[0];\n    var dy = coords2[1] - coords[1];\n    var dz = coords2[2] - coords[2];\n\n    if (this.isProjected) {\n        length = Math.sqrt(dx*dx + dy*dy + dz*dz);\n        minStep = 1000000; //just big number\n    } else {\n        geod = this.measure.getGeodesic();\n        r = geod.Inverse(coords[1], coords[0], coords2[1], coords2[0]);\n        length = r.s12;\n        azimuth = r.azi1;\n        minStep = 10 * ((navigationSrsInfo['a'] * 2 * Math.PI) / 4007.5); //aprox 100km for earth\n    }\n\n    var points = [coords];\n    var distance = minStep;\n\n    for (;distance < length; distance += minStep) {\n        d = distance / length;\n\n        if (this.isProjected) {\n            points.push([ coords[0] + dx * d, coords[1] + dy * d, coords[2] + dz * d ]);\n        } else {\n            r = geod.Direct(coords[1], coords[0], azimuth, distance);\n            points.push([r.lon2, r.lat2, coords[2] + dz * d]);\n        }\n    }\n\n    points.push(coords2);\n\n    return points;\n};\n\nexport default MapConvert;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/convert.js\n// module id = 129\n// module chunks = 0 1","\nvar MapDivisionNode = function(map, id, srs, extents, heightRange, partitioning) {\n    this.map = map;\n    this.id = id;\n    this.srs = this.map.getMapsSrs(srs);\n    this.extents = extents;\n    this.heightRange =  heightRange;\n    this.partitioning = partitioning;\n    this.isPole = (id[0] == 1 && ((id[1] == 0 && id[2] == 1)||(id[1] == 1 && id[2] == 0)));\n};\n\n\nMapDivisionNode.prototype.getInnerCoords = function (coords) {\n    return this.srs.convertCoordsFrom(coords, this.map.getNavigationSrs());\n};\n\n\nMapDivisionNode.prototype.getOuterCoords = function (coords) {\n    return this.srs.convertCoordsTo(coords, this.map.getNavigationSrs());\n};\n\n\nMapDivisionNode.prototype.getPhysicalCoords = function (coords, skipVerticalAdjust) {\n    return this.srs.convertCoordsTo(coords, this.map.getPhysicalSrs(), skipVerticalAdjust);\n};\n\n\nMapDivisionNode.prototype.getPhysicalCoordsFast = function (coords, skipVerticalAdjust, coords2, index, index2) {\n    return this.srs.convertCoordsToFast(coords, this.map.getPhysicalSrs(), skipVerticalAdjust, coords2, index, index2);\n};\n\n\nMapDivisionNode.prototype.getExtents = function (coords) {\n    return this.srs.convertCoordsFrom(coords, this.map.getNavigationSrs());\n};\n\n\nexport default MapDivisionNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/division-node.js\n// module id = 130\n// module chunks = 0 1","\nimport MapGeodataView_ from './geodata-view';\n\n//get rid of compiler mess\nvar MapGeodataView = MapGeodataView_;\n\n\nvar MapDrawTiles = function(map, draw) {\n    this.map = map;\n    this.config = map.config;\n    this.isProjected = this.map.getNavigationSrs().isProjected();\n    this.stats = map.stats;\n    this.draw = draw;\n    this.debug = draw.debug;\n    this.core = map.core;\n    this.camera = map.camera;\n\n    this.renderer = map.renderer;\n\n    this.getTextSize = this.renderer.draw.getTextSize.bind(this.renderer.draw);\n    this.drawText = this.renderer.draw.drawText.bind(this.renderer.draw);\n};\n\n\nMapDrawTiles.prototype.drawSurfaceTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {\n    if (this.stats.gpuRenderUsed >= this.draw.maxGpuUsed) {\n        return false;\n    }\n\n    tile.renderReady = false;\n    \n    if (tile.surface) {\n        if (node.hasGeometry()) {\n\n            if (this.debug.drawBBoxes && !preventRedener) {\n                if (tile.surface.geodata || !this.debug.drawGeodataOnly) {\n                    this.drawTileInfo(tile, node, cameraPos, tile.surfaceMesh, pixelSize);\n                }\n            }\n\n            if (this.debug.heightmapOnly && !preventRedener) {\n                if (!tile.surface.geodata) {\n                    tile.drawGrid(cameraPos);\n                }\n                return true;\n            }\n           \n            if (!preventRedener) {\n                this.stats.renderedLods[tile.id[0]]++;\n                this.stats.drawnTiles++;\n\n                if (tile.surface.geodata && this.renderer.drawnGeodataTilesUsed) {    //used in scr-count2 !!! legacy mode, do not remove\n\n                    var pp = this.renderer.project2(\n                        [(node.bbox2[12] + node.bbox2[15] + node.bbox2[18] + node.bbox2[21])*0.25 - cameraPos[0],\n                         (node.bbox2[13] + node.bbox2[16] + node.bbox2[19] + node.bbox2[22])*0.25 - cameraPos[1],\n                         (node.bbox2[14] + node.bbox2[17] + node.bbox2[20] + node.bbox2[23])*0.25 - cameraPos[2]],\n                         this.camera.getMvpMatrix());\n\n                    if (!(pp[0] < 0 || pp[1] < 0 || pp[0] > this.renderer.curSize[0] || pp[1] > this.renderer.curSize[1])) {\n                        this.stats.drawnGeodataTilesPerLayer++;\n                        this.stats.drawnGeodataTilesFactor += Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR);\n                    }\n\n                    this.stats.drawnGeodataTiles++;\n                }\n            }\n\n            var count = 0;\n           \n            do {\n\n                if (tile.resetDrawCommands) {\n                    tile.drawCommands = [[], [], []];\n                    tile.updateBounds = true;\n            \n                    if (tile.bounds) {\n                        for (var key in tile.bounds) {\n                            tile.bounds[key].viewCoutner = 0; \n                        }\n                    }\n                    \n                    tile.resetDrawCommands = false;\n                }\n\n                var ret;\n\n                if (!tile.surface.geodata) {\n                    ret = this.drawMeshTile(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu);\n                } else {\n                    ret = this.drawGeodataTile(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu);\n                }\n\n                //if (count > 0) console.log('loop: ' + count);\n\n                count++;\n\n                if (count > 10) {\n                    break; //prevent infinite loop\n                }\n\n            } while(tile.resetDrawCommands);\n\n            return ret;\n        } else {\n            return true;\n        }\n    } else {\n        if (!preventRedener && tile.lastRenderState) {\n            var channel = this.draw.drawChannel;\n            this.draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);\n            this.map.applyCredits(tile);\n            return true;\n        }\n    }\n};\n\n\n\nMapDrawTiles.prototype.drawMeshTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {\n    var path;\n\n    if (!tile.surfaceMesh) {\n        if (tile.resourceSurface.virtual) {\n            return true;\n        }\n        \n        path = tile.resourceSurface.getMeshUrl(tile.id);\n        tile.surfaceMesh = tile.resources.getMesh(path, tile);\n    }\n\n    var draw = this.draw, texture, layer, credits;\n    var channel = draw.drawChannel;\n    var ret = false;\n\n    //we have commnad so we can draw them\n    if (tile.drawCommands[channel].length > 0 && this.draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n        if (!preventRedener) {\n            draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);\n            this.map.applyCredits(tile);\n        }\n        tile.lastRenderState = null;\n        return true;\n    } else if (tile.lastRenderState){ //we do not have cammnds or command are not redy yet, so we can draw last state if present and ready\n\n        if (tile.surfaceMesh.isReady(true, priority, doNotCheckGpu) && tile.drawCommands[channel].length > 0) {\n            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n                if (!preventRedener) {\n                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);\n                    this.map.applyCredits(tile);\n                }\n                return true; // commands are generated so we can return from function here\n            } // else ret = false\n        } else {\n            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n                if (!preventRedener) {\n                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);\n                    this.map.applyCredits(tile);\n                }\n                ret = true;\n            }\n        }\n    }\n\n    if (tile.drawCommands[channel].length > 0) {  //command are generated but not ready, we can return from the function\n        if (this.config.mapHeightfiledWhenUnloaded && !preventRedener) {\n            tile.drawGrid(cameraPos);\n            return false;\n        } else {\n            return false;\n        }\n    } \n\n    // information about support for extarnal or internal textures are present in the mesh,  \n    // so we have to wait until is mesh ready and then we can generate commands\n    if (tile.surfaceMesh.isReady(preventLoad, priority, doNotCheckGpu) && !preventLoad) {\n        var submeshes = tile.surfaceMesh.submeshes;\n\n        tile.drawCommands = [[], [], []]; //??\n        tile.imageryCredits = {};\n        tile.boundsDebug = {}; //used for inspector\n\n        var specificity = 0;\n        var i, li, j, lj, k, lk, surface;\n\n        surface = tile.resourceSurface;\n\n        if (!surface) {\n            surface = tile.surface;\n        }\n        \n        if (surface.glue) {\n            var surfaces = surface.id; \n            for (i = 0, li = surfaces.length; i < li; i++) {\n                var surface2 = this.map.getSurface(surfaces[i]);\n                if (surface2) {\n                    specificity = Math.max(specificity, surface2.specificity);\n                }\n            }\n\n            //set credits\n            for (k = 0, lk = node.credits.length; k < lk; k++) {\n                tile.glueImageryCredits[node.credits[k]] = specificity;  \n            }\n\n        } else {\n            specificity = surface.specificity;\n\n            //set credits\n            for (k = 0, lk = node.credits.length; k < lk; k++) {\n                tile.imageryCredits[node.credits[k]] = specificity;  \n            }\n        }\n\n\n        for (i = 0, li = submeshes.length; i < li; i++) {\n            var submesh = submeshes[i];\n            \n            //debug bbox\n            if (this.debug.drawBBoxes && this.debug.drawMeshBBox && !preventRedener) {\n                submesh.drawBBox(cameraPos);\n            }\n\n            if (submesh.externalUVs) {\n                if (tile.updateBounds) {\n                    tile.updateBounds = false;\n                    \n                    this.updateTileBounds(tile, submeshes);\n                }\n                \n                surface = tile.resourceSurface;\n                if (tile.resourceSurface.glue /*&& submesh.surfaceReference != 0*/) { //glue have multiple surfaces per tile\n                    surface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);\n                }\n\n                if (surface != null) {\n                    var bounds = tile.bounds[surface.id];\n                    \n                    if (bounds) {\n                        if (submesh.externalUVs) {\n\n                            //draw bound layers\n                            if (bounds.sequence.length > 0) {\n                                if (bounds.transparent) {\n                                    if (submesh.internalUVs) {  //draw surface\n                                        if (tile.surfaceTextures[i] == null) {\n                                            path = tile.resourceSurface.getTextureUrl(tile.id, i);\n                                            tile.surfaceTextures[i] = tile.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, tile, true);\n                                        }\n                                                \n                                        tile.drawCommands[0].push({\n                                            type : VTS_DRAWCOMMAND_SUBMESH,\n                                            mesh : tile.surfaceMesh,\n                                            submesh : i,\n                                            texture : tile.surfaceTextures[i],\n                                            material : VTS_MATERIAL_INTERNAL_NOFOG\n                                        });\n                                    }\n    \n                                    tile.drawCommands[0].push({\n                                        type : VTS_DRAWCOMMAND_STATE,\n                                        state : draw.drawBlendedTileState\n                                    });            \n                                    \n                                    var layers = bounds.sequence;\n                                    for (j = 0, lj = layers.length; j < lj; j++) {\n                                        texture = tile.boundTextures[layers[j]];\n                                        if (texture) {\n\n                                            //debug stuff\n                                            if (!tile.boundsDebug[surface.id]) {\n                                                tile.boundsDebug[surface.id] = [];\n                                            }\n                                            tile.boundsDebug[surface.id].push(layers[j]);\n\n                                            //set credits\n                                            layer = tile.boundLayers[layers[j]];\n                                            credits = layer.credits;\n                                            for (k = 0, lk = credits.length; k < lk; k++) {\n                                                tile.imageryCredits[credits[k]] = layer.specificity;  \n                                            }\n\n                                            tile.drawCommands[0].push({\n                                                type : VTS_DRAWCOMMAND_SUBMESH,\n                                                mesh : tile.surfaceMesh,\n                                                submesh : i,\n                                                texture : texture,\n                                                alpha : bounds.alpha[layers[j]][1],\n                                                material : VTS_MATERIAL_EXTERNAL_NOFOG,\n                                                layer : layer\n                                            });\n                                        }\n                                    }\n                                    \n                                    tile.drawCommands[0].push({\n                                        type : VTS_DRAWCOMMAND_SUBMESH,\n                                        mesh : tile.surfaceMesh,\n                                        submesh : i,\n                                        texture : null,\n                                        material : VTS_MATERIAL_FOG\n                                    });                                                \n\n                                    tile.drawCommands[0].push({\n                                        type : VTS_DRAWCOMMAND_STATE,\n                                        state : draw.drawTileState\n                                    });  \n                                } else {\n                                    var layerId = bounds.sequence[bounds.sequence.length-1];\n                                    texture = tile.boundTextures[layerId];\n                                    if (texture) {\n\n                                        //debug stuff\n                                        if (!tile.boundsDebug[surface.id]) {\n                                            tile.boundsDebug[surface.id] = [];\n                                        }\n                                        tile.boundsDebug[surface.id].push(layerId);\n                                        \n                                        //set credits\n                                        layer = tile.boundLayers[layerId];\n                                        credits = layer.credits;\n                                        for (k = 0, lk = credits.length; k < lk; k++) {\n                                            tile.imageryCredits[credits[k]] = layer.specificity;  \n                                        }\n                                        \n                                        tile.drawCommands[0].push({\n                                            type : VTS_DRAWCOMMAND_SUBMESH,\n                                            mesh : tile.surfaceMesh,\n                                            submesh : i,\n                                            texture : texture,\n                                            material : VTS_MATERIAL_EXTERNAL,\n                                            layer : layer\n                                        });\n                                    }\n                                }\n                               \n                            } else {\n                                if (submesh.textureLayer) {\n                                    \n                                    layer = this.map.getBoundLayerByNumber(submesh.textureLayer);\n                                    \n                                    if (layer) {\n                                        texture = tile.boundTextures[layer.id];\n                                        \n                                        if (texture) {\n                                            \n                                            //debug stuff\n                                            if (!tile.boundsDebug[surface.id]) {\n                                                tile.boundsDebug[surface.id] = [];\n                                            }\n                                            tile.boundsDebug[surface.id].push(layer.id);\n                                            \n                                            //set credits\n                                            layer = tile.boundLayers[layer.id];\n                                            credits = layer.credits;\n                                            for (k = 0, lk = credits.length; k < lk; k++) {\n                                                tile.imageryCredits[credits[k]] = layer.specificity;  \n                                            }\n                                            \n                                            //draw mesh\n                                            tile.drawCommands[0].push({\n                                                type : VTS_DRAWCOMMAND_SUBMESH,\n                                                mesh : tile.surfaceMesh,\n                                                submesh : i,\n                                                texture : texture,\n                                                material : VTS_MATERIAL_EXTERNAL,\n                                                layer : layer\n                                            });\n                                        }\n                                    }\n                                   \n                                } else {\n    \n                                    if (submesh.internalUVs) {  //draw surface\n                                        if (tile.surfaceTextures[i] == null) {\n                                            path = tile.resourceSurface.getTextureUrl(tile.id, i);\n                                            tile.surfaceTextures[i] = tile.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, tile, true);\n                                        }\n\n                                        //draw mesh\n                                        tile.drawCommands[0].push({\n                                            type : VTS_DRAWCOMMAND_SUBMESH,\n                                            mesh : tile.surfaceMesh,\n                                            submesh : i,\n                                            texture : tile.surfaceTextures[i],\n                                            material : VTS_MATERIAL_INTERNAL\n                                        });\n                                    } else {\n                                        tile.drawCommands[0].push({\n                                            type : VTS_DRAWCOMMAND_SUBMESH,\n                                            mesh : tile.surfaceMesh,\n                                            submesh : i,\n                                            texture : null,\n                                            material : VTS_MATERIAL_FLAT\n                                        });\n                                    }\n    \n                                }\n                            }\n    \n                        } else if (submesh.internalUVs) {\n    \n                            if (tile.surfaceTextures[i] == null) {\n                                path = tile.resourceSurface.getTextureUrl(tile.id, i);\n                                tile.surfaceTextures[i] = tile.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, tile, true);\n                            } //else {\n                            tile.drawCommands[0].push({\n                                type : VTS_DRAWCOMMAND_SUBMESH,\n                                mesh : tile.surfaceMesh,\n                                submesh : i,\n                                texture : tile.surfaceTextures[i],\n                                material : VTS_MATERIAL_INTERNAL\n                            });                                                \n                            //}\n                        }\n                    }                            \n                }\n            } else if (submesh.internalUVs) {\n\n                if (tile.surfaceTextures[i] == null) {\n                    path = tile.resourceSurface.getTextureUrl(tile.id, i);\n                    tile.surfaceTextures[i] = tile.resources.getTexture(path, VTS_TEXTURETYPE_COLOR, null, null, tile, true);\n                } //else {\n                tile.drawCommands[0].push({\n                    type : VTS_DRAWCOMMAND_SUBMESH,\n                    mesh : tile.surfaceMesh,\n                    submesh : i,\n                    texture : tile.surfaceTextures[i],\n                    material : VTS_MATERIAL_INTERNAL\n                });                                                \n                //}\n            }\n            \n            //depth path\n            tile.drawCommands[1].push({\n                type : VTS_DRAWCOMMAND_SUBMESH,\n                mesh : tile.surfaceMesh,\n                submesh : i,\n                material : VTS_MATERIAL_DEPTH\n            });\n            \n        }\n\n        if (surface.pipeline > VTS_PIPELINE_BASIC) {\n            this.updateTileHmap(tile, node);\n\n            for (j = 0; j < 2; j++) {\n                var commands = tile.drawCommands[j];\n                for (i = 0, li = commands.length; i < li; i++) {\n                    if (commands[i].type == VTS_DRAWCOMMAND_SUBMESH) {\n                        commands[i].pipeline = surface.pipeline;\n                        commands[i].hmap = tile.hmap;\n                    }\n                }\n            }\n        }\n\n        if (tile.resetDrawCommands) {\n            return false;\n        }\n\n        if (draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n\n            if (tile.resetDrawCommands) {\n                return false;\n            }\n\n            if (!preventRedener) {\n                draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);\n                this.map.applyCredits(tile);\n            }\n            \n            tile.lastRenderState = null;\n            ret = true;\n        } else if (tile.lastRenderState) {\n            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n                if (!preventRedener) {\n                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);\n                    this.map.applyCredits(tile);\n                }\n                ret = true;\n            } //else ret = false\n        } else {\n            if (this.config.mapHeightfiledWhenUnloaded && !preventRedener) {\n                //node.drawPlane(cameraPos, tile);\n                tile.drawGrid(cameraPos);\n                ret = !(tile.drawCommands[channel].length > 0);\n            }\n        }\n        \n    } else {\n        \n        if (!tile.lastRenderState && this.config.mapHeightfiledWhenUnloaded && !preventRedener) {\n            //node.drawPlane(cameraPos, tile);\n            tile.drawGrid(cameraPos);\n            ret = !(tile.drawCommands[channel].length > 0);\n        }        \n    }\n    \n    return ret;\n};\n\n\nMapDrawTiles.prototype.drawGeodataTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {\n    if (tile.id[0] <= 1) {\n        return true;\n    }\n\n    if (tile.surfaceGeodata == null) {\n        var path;\n        \n        if (tile.surface.geodataNavtileInfo) {  //remove this code??? no longer used\n            var navtile = this.tree.findNavTile(tile.id);\n            \n            if (navtile && navtile.surface) {\n                var navtileStr = navtile.surface.getNavUrl(navtile.id) + ';'\n                                  + navtile.id[0] + '-' + navtile.id[1] + '-' + navtile.id[2] + ';'      \n                                  + navtile.metanode.minHeight + ';' + navtile.metanode.maxHeight;     \n                path = tile.surface.getGeodataUrl(tile.id, encodeURIComponent(navtileStr));\n            }\n        }\n        \n        if (!path) {\n            path = tile.resourceSurface.getGeodataUrl(tile.id, '');\n        }\n\n        tile.surfaceGeodata = tile.resources.getGeodata(path, {tile:tile, surface:tile.surface});\n    }\n\n    var channel = this.draw.drawChannel;\n    \n    if (tile.geodataCounter != tile.surface.geodataCounter) {\n        tile.drawCommands = [[],[],[]];\n\n        if (tile.surfaceGeodataView != null) {\n            tile.surfaceGeodataView.kill();\n        }\n        \n        tile.surfaceGeodataView = null;\n        tile.geodataCounter = tile.surface.geodataCounter;\n    }\n\n    if (tile.drawCommands[channel].length > 0 && this.draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {\n        if (!preventRedener) {\n            this.draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);\n            this.map.applyCredits(tile);\n        }\n        tile.lastRenderState = null;\n        return true;\n    }\n\n    if (!tile.surfaceGeodataView) {\n        if (tile.surfaceGeodata.isReady(preventLoad, priority, doNotCheckGpu) && !preventLoad) {\n            tile.surfaceGeodataView = new MapGeodataView(this.map, tile.surfaceGeodata, {tile:tile, surface:tile.surface});\n        }\n    }\n\n    if (tile.surfaceGeodataView) {\n        tile.mapdataCredits = {};\n        \n        var specificity = (tile.surface) ? tile.surface.specificity : 0;\n\n        //set credits\n        for (var k = 0, lk = node.credits.length; k < lk; k++) {\n            tile.mapdataCredits[node.credits[k]] = specificity;  \n        }\n\n        tile.drawCommands[channel][0] = {\n            type : VTS_DRAWCOMMAND_GEODATA,\n            geodataView : tile.surfaceGeodataView \n        };\n\n        return tile.surfaceGeodataView.isReady();\n    }\n\n    return false;\n};\n\n\nMapDrawTiles.prototype.updateTileHmap = function(tile, node) {\n    if (node && node.hasNavtile() && tile.surface) { \n\n        if (!tile.surface || !tile.resourceSurface) { //surface.virtual) {\n            return false; //is it best way how to do it?\n        }\n            \n        if (!tile.resourceSurface.getHMapUrl) { //virtual surface is as resource surface. Is it bug??!!\n            return false; //is it best way how to do it?\n        }\n            \n        var path = tile.resourceSurface.getHMapUrl(tile.id, true);\n        tile.hmap = tile.resources.getTexture(path);\n\n        //var path = tile.surface.getNavUrl(tile.id);\n        //tile.hmap = tile.resources.getTexture(path, null, null, null, tile, true);\n    } else {\n\n        //get parent with nav tile\n        var parent = tile.parent;\n        var extraBound = null; \n\n        while(parent && parent.id[0] > 0) {\n            if (parent.metanode && parent.metanode.hasNavtile()) {\n                extraBound = {\n                    sourceTile : parent,\n                    sourceTexture : null,\n                    hmap : true,\n                    tile : tile \n                };\n\n                break;\n            }\n\n            parent = parent.parent;\n        }\n\n        //does parent with navtile exist\n        if (extraBound) {\n            var path = tile.resourceSurface.getHMapUrl(tile.id, true);\n            tile.hmap = tile.resources.getTexture(path, null, extraBound, {tile: tile, hmap: true}, tile, false);\n\n            if (tile.hmap.neverReady) {\n                tile.hmap = null;\n            }\n        } else {\n            tile.hmap = null;\n        }\n    }\n};\n\n\nMapDrawTiles.prototype.updateTileBounds = function(tile, submeshes) {\n    for (var i = 0, li = submeshes.length; i < li; i++) {\n        var submesh = submeshes[i];\n        \n        if (submesh.externalUVs) {\n            var submeshSurface = tile.resourceSurface;\n\n            //if (tile.resourceSurface.glue) { //glue have multiple surfaces per tile\n              //  submeshSurface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);\n            //}\n\n            if (tile.resourceSurface.glue) { //glue have multiple surfaces per tile\n                submeshSurface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);\n            }\n\n            \n            if (submeshSurface) {\n                var bounds = tile.bounds[submeshSurface.id];\n                \n                if (!bounds) {\n                    bounds = {\n                        sequence : [],\n                        alpha : [],\n                        transparent : false,\n                        viewCoutner : 0\n                    };\n                    \n                    tile.bounds[submeshSurface.id] = bounds;\n                } \n                \n                if (bounds.viewCoutner != tile.viewCoutner) {\n                    this.updateTileSurfaceBounds(tile, submesh, submeshSurface, bounds, bounds.viewCoutner != tile.viewCoutner);\n                    //bounds.viewCoutner = tile.viewCoutner;\n                }  \n            }\n        }\n    }\n\n    for (var key in tile.bounds) {\n        tile.bounds[key].viewCoutner = tile.viewCoutner;\n    }\n};\n\n\nMapDrawTiles.prototype.getParentTile = function(tile, lod) {\n    while(tile && tile.id[0] > lod) {\n        tile = tile.parent;\n    }\n    \n    return tile;\n};\n\n\nMapDrawTiles.prototype.getTileTextureTransform = function(sourceTile, targetTile) {\n    var shift = targetTile.id[0] - sourceTile.id[0];\n    var x = sourceTile.id[1] << shift;\n    var y = sourceTile.id[2] << shift;\n    var s = 1.0 / Math.pow(2.0, shift);\n    return [ s, s, (targetTile.id[1] - x) * s, (targetTile.id[2] - y) * s ];\n};\n\n\nMapDrawTiles.prototype.updateTileSurfaceBounds = function(tile, submesh, surface, bound, fullUpdate) {\n    var path, extraBound, layer, texture;\n\n    if (this.config.mapNoTextures) {\n        return;\n    }\n\n    //search map view\n    if (surface.boundLayerSequence.length > 0) {\n        if (fullUpdate) {\n            bound.sequence = [];\n            var sequenceFullAndOpaque = [];\n            var sequenceMaskPosible = [];\n            var fullAndOpaqueCounter = 0;\n            \n            for (var j = 0, lj = surface.boundLayerSequence.length; j < lj; j++) {\n                layer = surface.boundLayerSequence[j][0];\n                \n                if (layer && layer.ready && layer.hasTileOrInfluence(tile.id) && surface.boundLayerSequence[j][1] > 0) {\n                    extraBound = null; \n                    \n                    if (tile.id[0] > layer.lodRange[1]) {\n                        extraBound = {\n                            sourceTile : this.getParentTile(tile, layer.lodRange[1]),\n                            sourceTexture : null,\n                            layer : layer,\n                            tile : tile \n                        };\n                    }\n\n                    texture = tile.boundTextures[layer.id];\n\n                    if (!texture) { //TODO: make sure that we load only textures which we need  \n                        path = layer.getUrl(tile.id);\n                        texture = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);\n\n                        if (texture.checkType == VTS_TEXTURECHECK_MEATATILE) {\n                            texture.checkMask = true;\n                        }\n\n                        texture.isReady(true); //check for mask but do not load\n                        tile.boundTextures[layer.id] = texture; \n                    } \n\n                    if (texture.neverReady) {\n                        continue; //do not use this layer\n                    }\n\n                    var maskPosible = false;\n                    var skipOther = false;\n\n                    if (texture.isMaskPosible()) {\n                        if (texture.isMaskInfoReady()) {\n                            if (texture.getMaskTexture()) {\n                                bound.transparent = true;\n                                maskPosible = true;\n                            }\n                        } else {\n                            skipOther = true;\n                            maskPosible = true;\n                        }\n                    }\n\n                    sequenceMaskPosible.push(maskPosible);\n                    \n                    //var fullAndOpaque = !((surface.boundLayerSequence[j][1] < 1.0) || texture.extraBound || texture.getMaskTexture() || layer.isTransparent);\n                    var fullAndOpaque = !((surface.boundLayerSequence[j][1] < 1.0) || maskPosible || layer.isTransparent);\n                    if (fullAndOpaque) {\n                        fullAndOpaqueCounter++;\n                    }\n                            \n                    sequenceFullAndOpaque.push(fullAndOpaque);\n                    \n                    bound.sequence.push(layer.id);\n                    bound.alpha[layer.id] = surface.boundLayerSequence[j];\n                    tile.boundLayers[layer.id] = layer;\n                    if (bound.alpha[layer.id][1] < 1.0 || layer.isTransparent) {\n                        bound.transparent = true;\n                    }\n\n                    if (skipOther) {\n                        break; //wait until mask info is loaded\n                    }\n                }\n            }\n\n            //filter out extra bounds if they are not needed\n            //and remove all layer after first FullAndOpaque \n            if (fullAndOpaqueCounter > 0) {\n                var newSequence = [];\n                \n                for (var i = bound.sequence.length - 1; i >= 0; i--) {\n                    var layerId = bound.sequence[i];\n                    \n                    if (sequenceFullAndOpaque[i]) {\n                        newSequence.unshift(layerId);   \n                        break;\n                    } else {\n                        texture = tile.boundTextures[layerId];\n\n                        if (bound.alpha[layerId][1] < 1.0 ||\n                            tile.boundLayers[layerId].isTransparent ||\n                            (sequenceMaskPosible[i] /*texture.getMaskTexture() /*&& !texture.extraBound*/)) {\n                            newSequence.unshift(layerId);    \n                        }\n                    }\n                }\n                \n                bound.sequence = newSequence; \n            }\n            \n        }\n    } else if (surface.textureLayer != null) { //search surface\n        if (fullUpdate) {\n            layer = this.map.getBoundLayerById(surface.textureLayer);\n            if (layer && layer.hasTileOrInfluence(tile.id)) {\n                extraBound = null; \n                \n                if (tile.id[0] > layer.lodRange[1]) {\n                    extraBound = {\n                        sourceTile : this.getParentTile(tile, layer.lodRange[1]),\n                        sourceTexture : null,\n                        layer : layer,\n                        tile : tile \n                    };\n                }\n\n                bound.sequence.push(layer.id);\n                tile.boundLayers[layer.id] = layer;\n                if (!tile.boundTextures[layer.id]) {\n                    path = layer.getUrl(tile.id);\n                    tile.boundTextures[layer.id] = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);\n                }\n            }\n        }\n    } else { //search submeshes\n        if (submesh.textureLayer != 0) {\n            layer = this.map.getBoundLayerByNumber(submesh.textureLayer);\n\n            if (layer && layer.hasTileOrInfluence(tile.id)) {\n                extraBound = null; \n                \n                if (tile.id[0] > layer.lodRange[1]) {\n                    extraBound = {\n                        sourceTile : this.getParentTile(tile, layer.lodRange[1]),\n                        sourceTexture : null,\n                        layer : layer,\n                        tile : tile \n                    };\n                }\n\n                //submeshes[j].textureLayerId = tile.id;\n                tile.boundLayers[layer.id] = layer;\n                if (!tile.boundTextures[layer.id]) {\n                    path = layer.getUrl(tile.id);\n                    tile.boundTextures[layer.id] = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);\n                }\n            }\n        }\n    }\n};\n\n\nMapDrawTiles.prototype.drawTileInfo = function(tile, node, cameraPos, mesh) {\n    var debug = this.debug, pos;\n\n    if (!debug.drawMeshBBox) {\n        node.drawBBox(cameraPos);\n    }\n\n    //get screen pos of node\n    if (node.metatile.useVersion < 4) {\n        var min = node.bbox.min;\n        var max = node.bbox.max;\n    \n        pos =  this.core.getRendererInterface().getCanvasCoords(\n            [(min[0] + (max[0] - min[0])*0.5) - cameraPos[0],\n                (min[1] + (max[1] - min[1])*0.5) - cameraPos[1],\n                (max[2]) - cameraPos[2]],\n             this.camera.getMvpMatrix());\n    \n        pos[2] = pos[2] * 0.9992;\n    } else {\n        var dx = node.bbox2[3] - node.bbox2[0]; \n        var dy = node.bbox2[4] - node.bbox2[1]; \n        var dz = node.bbox2[5] - node.bbox2[2]; \n    \n        var d = Math.sqrt(dx*dx + dy*dy + dz*dz);\n    \n        pos =  this.core.getRendererInterface().getCanvasCoords(\n            [(node.bbox2[12] + node.bbox2[15] + node.bbox2[18] + node.bbox2[21])*0.25 + node.diskNormal[0] * d*0.1 - cameraPos[0],\n                (node.bbox2[13] + node.bbox2[16] + node.bbox2[19] + node.bbox2[22])*0.25 + node.diskNormal[1] * d*0.1 - cameraPos[1],\n                (node.bbox2[14] + node.bbox2[17] + node.bbox2[20] + node.bbox2[23])*0.25 + node.diskNormal[2] * d*0.1 - cameraPos[2]],\n             this.camera.getMvpMatrix());\n        \n        /*\n            var pos =  this.core.getRendererInterface().getCanvasCoords(\n                            [(node.diskPos[0] + node.diskNormal[0] * node.bboxHeight) - cameraPos[0],\n                             (node.diskPos[1] + node.diskNormal[1] * node.bboxHeight) - cameraPos[1],\n                             (node.diskPos[2] + node.diskNormal[2] * node.bboxHeight) - cameraPos[2]],\n                             this.camera.getMvpMatrix());\n        */\n    }\n\n    var factor = debug.debugTextSize, text, i, li;\n\n    //draw lods\n    if (debug.drawLods) {\n        text = '' + tile.id[0]; // + ' ta:' + Math.abs(tile.tiltAngle).toFixed(3);\n        //text = '' + tile.id[0] + ' c:' + (50*(Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR) / Math.max(0.00001, this.renderer.drawnGeodataTilesFactor))).toFixed(3) + \n          //     ' l:' + Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR).toFixed(3) + ' g:' + this.renderer.drawnGeodataTilesFactor.toFixed(3);\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-4*factor), 4*factor, text, [1,0,0,1], pos[2]);\n    }\n\n    //draw indices\n    if (debug.drawIndices) {\n        text = '' + tile.id[1] + ' ' + tile.id[2];\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-11*factor), 4*factor, text, [0,1,1,1], pos[2]);\n    }\n\n    //draw positions\n    if (debug.drawPositions) {\n        //text = \"\" + min[0].toFixed(1) + \" \" + min[1].toFixed(1) + \" \" + min[2].toFixed(1);\n        //text = \"\" + Math.floor(node.corners[0]) + \" \" + Math.floor(node.corners[1]) + \" \" + Math.floor(node.corners[2]) + \" \" + Math.floor(node.corners[3]);\n        \n        var b = node.border2;\n        if (b) {\n            text = '' + Math.floor(b[0]) + ' ' + Math.floor(b[1]) + ' ' + Math.floor(b[2]) + ' ' + Math.floor(b[3]) + ' ' + Math.floor(b[4]) + ' ' + Math.floor(b[5]) + ' ' + Math.floor(b[6]) + ' ' + Math.floor(b[7]) + ' ' + Math.floor(b[8]);\n            this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,1,1], pos[2]);\n        }\n\n        b = node.border;\n        if (b) {\n            text = '' + Math.floor(b[0]) + ' ' + Math.floor(b[1]) + ' ' + Math.floor(b[2]) + ' ' + Math.floor(b[3]) + ' ' + Math.floor(b[4]) + ' ' + Math.floor(b[5]) + ' ' + Math.floor(b[6]) + ' ' + Math.floor(b[7]) + ' ' + Math.floor(b[8]);\n            this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,1,1], pos[2]);\n        }\n\n        //text = 'llx:' + Math.floor(node.llx) + ' lly:' + Math.floor(node.lly) + ' urx:' + Math.floor(node.urx) + ' ury:' + Math.floor(node.ury);\n        //this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,1,1], pos[2]);\n    }\n\n    //draw face count\n    if (debug.drawFaceCount && mesh) {\n        text = '' + mesh.faces + ' - ' + mesh.submeshes.length + ((tile.surface && tile.surface.glue) ? ' - 1' : ' - 0');\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n    }\n\n    //draw geodata pixel size\n    if (debug.drawGPixelSize) {\n        text = '' + ((Math.tan(tile.metanode.diskAngle2A) * tile.metanode.diskDistance * 0.70710678118) / node.displaySize).toFixed(2);\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n    }\n\n    //draw order\n    if (debug.drawOrder) {\n        text = '' + this.drawTileCounter + ' cmds: ' + (tile.drawCommands[0].length);\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);\n    }\n\n    if (debug.drawSurfaces) {\n        text = JSON.stringify(tile.surface.id);\n        if (node.alien) {\n            text = '[A]' + text;\n        }\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);\n    }\n\n    if (debug.drawBoundLayers) {\n        if (tile.boundsDebug) {\n            var surface = tile.resourceSurface;\n            if (surface.glue) { \n              \n                for (i = 0, li = surface.id.length; i < li; i++) {\n                    if (tile.boundsDebug[surface.id[i]]) {\n                        text = '< ' + surface.id[i] + ' >';\n                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(10+i*7*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n                        text = JSON.stringify(tile.boundsDebug[surface.id[i]]);\n                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*7*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n                    }\n                }\n                \n            } else if (tile.boundsDebug[surface.id]) {\n                text = '< ' + surface.id + ' >';\n                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);\n    \n                text = JSON.stringify(tile.boundsDebug[surface.id]);\n                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [1,1,1,1], pos[2]);\n            }\n        }\n    }\n\n    if (debug.drawCredits) {\n        text = '{ ';\n       \n        for (var key in tile.imageryCredits) {\n            if (tile.imageryCredits[key]) {\n                text += key + ':' + tile.imageryCredits[key] + ', ';\n            }\n        }\n\n        for (key in tile.glueImageryCredits) {\n            if (!tile.imageryCredits[key]) {\n                text += key + ':' + tile.glueImageryCredits[key] + ', ';\n                //text += key + \", \";\n            }\n        }\n\n        text += '}';\n\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);\n    }\n\n    //draw distance\n    if (debug.drawDistance) {\n        text = '' + tile.distance.toFixed(2) + '  ' + tile.texelSize.toFixed(3) + '  ' + node.pixelSize.toFixed(3);\n        text += '--' + tile.texelSize2.toFixed(3); \n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [1,0,1,1], pos[2]);\n    }\n\n    //draw node info\n    if (debug.drawNodeInfo) {\n        var children = ((node.flags & ((15)<<4))>>4);\n        text = 'v' + node.metatile.version + '-' + node.flags.toString(2) + '-' + ((children & 1) ? '1' : '0') + ((children & 2) ? '1' : '0') + ((children & 4) ? '1' : '0') + ((children & 8) ? '1' : '0');\n        text += '-' + node.minHeight + '/' + node.maxHeight+ '-' + Math.floor(node.minZ) + '/' + Math.floor(node.maxZ)+ '-' + Math.floor(node.surrogatez);\n        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-18*factor), 4*factor, text, [1,0,1,1], pos[2]);\n    }\n    \n    //draw texture size\n    if (debug.drawTextureSize && mesh) {\n        var submeshes = mesh.submeshes;\n        for (i = 0, li = submeshes.length; i < li; i++) {\n\n            if (submeshes[i].internalUVs) {\n                var texture = tile.surfaceTextures[i];\n                if (texture) {\n                    var gpuTexture = texture.getGpuTexture();\n                    if (gpuTexture) {\n                        text = '[' + i + ']: ' + gpuTexture.width + ' x ' + gpuTexture.height;\n                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n                    }\n                }\n            } else {\n                text = '[' + i + ']: 256 x 256';\n                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);\n            }\n        }\n    }\n\n};\n\n\nexport default MapDrawTiles;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/draw-tiles.js\n// module id = 131\n// module chunks = 0 1","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport MapGeodata_ from './geodata';\nimport MapGeodataView_ from './geodata-view';\nimport MapDrawTiles_ from './draw-tiles';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar math = math_;\nvar MapDrawTiles = MapDrawTiles_;\nvar MapGeodataView = MapGeodataView_;\nvar MapGeodata = MapGeodata_;\n\nvar MapDraw = function(map) {\n    this.map = map;\n    this.config = map.config;\n    this.isProjected = map.getNavigationSrs().isProjected();\n    this.isGeocent = map.isGeocent;\n\n    this.renderer = map.renderer;\n    this.stats = map.stats;\n    this.camera = map.camera;\n    this.tree = map.tree;\n\n    this.ndcToScreenPixel = this.renderer.curSize[0] * 0.5;\n\n    this.debug = {\n        heightmapOnly : false,\n        blendHeightmap : true,\n        drawBBoxes :  false,\n        drawMeshBBox : false,\n        drawLods : false,\n        drawPositions : false,\n        drawTexelSize : false,\n        drawWireframe : 0,\n        drawTestMode : 0,\n        drawTestData : 0,\n        drawFaceCount : false,\n        drawDistance : false,\n        drawMaxLod : false,\n        drawGeodataOnly : false,\n        drawTextureSize : false,\n        drawNodeInfo : false,\n        drawLayers : true,\n        drawBoundLayers : false,\n        drawSurfaces : false,\n        drawCredits : false,\n        drawOrder : false,\n        drawLabelBoxes : false,\n        drawAllLabels : false,\n        drawEarth : true, \n        drawGridCells : false,\n        drawTileCounter : 0,\n        drawFog : this.config.mapFog,\n        drawGPixelSize : false,\n        debugTextSize : 2.0,\n        ignoreTexelSize : false,\n        maxZoom : false\n    };\n\n    this.gridFlat = false;\n    this.gridGlues = false;\n    this.gridSkipped = false;\n\n    this.atmoColor = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];\n    this.atmoColor2 = [72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0];\n    this.atmoHeight = 50000;\n    this.atmoHeightFactor = 1; //this.atmoHeight / 50000;\n    this.atmoDensity = 1; //this.atmoHeight / 50000;\n\n    this.fogDensity = 0;\n    this.zFactor = 0;\n    //this.zFactor2 = 0.000012;\n    this.zFactor2 = 0.003;\n    this.zbufferOffset = null;    \n    this.zShift = 0;\n    this.zLastShift = 0;\n    this.bestMeshTexelSize = 1;\n    this.bestGeodataTexelSize = 1;\n    this.log8 = Math.log(8);\n    this.log2 = Math.log(2);\n\n    this.geodataTilesPerLayer = 0;\n\n    this.drawCounter = 0;\n    this.drawChannel = 0;\n    this.drawChannelNames = ['base', 'hit'];\n\n    this.planetRadius = this.isGeocent ? map.getNavigationSrs().getSrsInfo()['a'] : 100;\n    this.tileBuffer = new Array(500);\n    this.processBuffer = new Array(60000);\n    this.processBuffer2 = new Array(60000);\n    this.drawBuffer = new Array(60000);\n    this.tmpVec3 = new Array(3);\n    this.tmpVec5 = new Array(5);\n    this.bboxBuffer = new Float32Array(8*3);\n    this.planeBuffer = new Float32Array(9*3);\n\n    var gpu = this.renderer.gpu;\n    this.drawTileState = gpu.createState({});\n    this.drawStardomeState = gpu.createState({zwrite:false, ztest:false});\n    this.drawBlendedTileState = gpu.createState({zequal:true, blend:true});\n    this.drawAuraState = gpu.createState({zwrite:false, blend:true});\n    this.drawAtmoState = gpu.createState({zwrite:false, ztest:false, blend:true});\n    this.drawAtmoState2 = gpu.createState({zwrite:false, ztest:true, blend:false});\n\n    this.degradeHorizonFactor = 0;\n    this.degradeHorizonTiltFactor = 0;\n\n    this.replay = {\n        camera : null,\n        drawnTiles : null,\n        drawnFreeTiles : null,\n        nodeBuffer : null,\n        tracedNodes : null,\n        tracedFreeNodes : null,\n        storeTiles : false,\n        storeFreeTiles : false,\n        storeNodes : false,\n        storeFreeNodes : false,\n        storeLoaded : this.config.mapStoreLoadStats,\n        drawGlobe : false,\n        drawTiles : false,\n        drawNodes : false,\n        drawFreeTiles : false,\n        drawFreeNodes : false,\n        drawLoaded : false,\n        lod : 30,\n        singleLod : false,\n        loadedIndex : 0,\n        singleLodedIndex : 0,\n        loaded : [],\n        loadFirst : 0,\n        loadLast : 0\n    };\n\n    this.drawTiles = new MapDrawTiles(map, this);\n};\n\n\nMapDraw.prototype.drawMap = function(skipFreeLayers) {\n    var map = this.map;\n    var renderer = this.renderer;\n    var camera = this.camera;\n    var replay = this.replay;\n    var gpu = renderer.gpu;\n    var debug = this.debug;\n\n    if (this.drawChannel != 1) {\n        gpu.setViewport();\n\n        map.visibleCredits = {\n            imagery : {},\n            glueImagery : {},\n            mapdata : {}\n        };\n    }\n\n    var projected = this.isProjected;\n\n    switch (this.config.mapGridMode) {\n        case 'none':       this.gridSkipped = true; this.gridFlat = false; this.gridGlues = false;  break;\n        case 'flat':       this.gridSkipped = false; this.gridFlat = true; this.gridGlues = false;  break;\n        case 'linear':     this.gridSkipped = false; this.gridFlat = false; this.gridGlues = true;  break;\n        case 'fastlinear': this.gridSkipped = false; this.gridFlat = false; this.gridGlues = false; break;\n    }\n\n    var drawTiles = this.drawTiles;\n    var camInfo = camera.update();\n    var renderer = this.renderer;\n\n    renderer.debugStr = 'AsyncImageDecode: ' + this.config.mapAsyncImageDecode;\n    renderer.dirty = true;\n    renderer.drawFog = this.debug.drawFog;\n    renderer.debug = this.debug; \n\n    if (this.config.mapForceFrameTime) {\n        if (this.config.mapForceFrameTime != -1) {\n            renderer.frameTime = this.config.mapForceFrameTime;\n        } else {\n            renderer.frameTime = 0;\n        }\n    } else {\n        renderer.frameTime = this.stats.frameTime;        \n    }\n\n    renderer.hoverFeatureCounter = 0;\n    renderer.hoverFeatureList = map.hoverFeatureList;\n    renderer.hoverFeature = map.hoverFeature;\n\n    renderer.cameraPosition = camera.position;\n    renderer.cameraOrientation = map.position.getOrientation();\n    renderer.cameraTiltFator = Math.cos(math.radians(renderer.cameraOrientation[1]));\n    renderer.cameraVector = camera.vector; \n    renderer.cameraViewExtent = map.position.getViewExtent();\n    renderer.cameraViewExtent2 = Math.pow(2.0, Math.max(1.0, Math.floor(Math.log(map.position.getViewExtent()) / Math.log(2))));\n    renderer.drawLabelBoxes = this.debug.drawLabelBoxes;\n    renderer.drawGridCells = this.debug.drawGridCells;\n    renderer.drawAllLabels = this.debug.drawAllLabels;\n    renderer.debug = this.debug;\n    renderer.fmaxDist = Number.NEGATIVE_INFINITY;\n    renderer.fminDist = Number.POSITIVE_INFINITY;\n\n\n    if (projected) {\n        var yaw = math.radians(renderer.cameraOrientation[0]);\n        renderer.labelVector = [-Math.sin(yaw), Math.cos(yaw), 0, 0, 0];\n    } else {\n        var v = camInfo.vector;\n        renderer.labelVector = [v[0], v[1], v[2], 0]; \n    }\n\n    renderer.distanceFactor = 1 / Math.max(1,Math.log(camera.distance) / Math.log(1.04));\n    renderer.tiltFactor = (Math.abs(renderer.cameraOrientation[1]/-90));\n    renderer.localViewExtentFactor = 2 * Math.tan(math.radians(map.position.getFov()*0.5));\n\n    this.degradeHorizonFactor = 200.0 * this.config.mapDegradeHorizonParams[0];\n    this.degradeHorizonTiltFactor = 0.5*(1.0+Math.cos(math.radians(Math.min(180,Math.abs(renderer.cameraOrientation[1]*2*3)))));\n   \n    if (this.drawChannel != 1) {\n        if (debug.drawWireframe == 2) {\n            gpu.clear(true, true, [255,255,255,255]);\n        } else {\n            gpu.clear(true, true, [0,0,0,255]);\n        }\n    } else { //render depth map\n        gpu.clear(true, true, [255,255,255,255]);\n    }\n\n    gpu.setState(this.drawStardomeState);\n\n    /*\n    if (this.drawChannel != 1) {\n        if (debug.drawWireframe == 2) {\n            renderer.draw.drawSkydome(renderer.whiteTexture, renderer.progStardome);\n        } else {\n            renderer.draw.drawSkydome(renderer.blackTexture, renderer.progStardome);\n        }\n    }*/\n\n    gpu.setState(this.drawTileState);\n\n    this.setupDetailDegradation();\n\n    map.loader.setChannel(0); //0 = hires channel\n    this.zFactor = 0;\n\n    this.ndcToScreenPixel = renderer.curSize[0] * 0.5;\n    this.updateFogDensity();\n    this.updateGridFactors();\n    this.maxGpuUsed = Math.max(32*102*1204, map.gpuCache.getMaxCost() - 32*102*1204); \n    //this.cameraCenter = this.position.getCoords();\n    this.stats.renderBuild = 0;\n    this.drawTileCounter = 0;\n    var cameraPos = camera.position;\n    var i, li, j, lj, tile, tiles, tmp, layer, drawnTiles, nodeBuffer;\n\n    if (map.freeLayersHaveGeodata && this.drawChannel == 0) {\n        renderer.draw.clearJobBuffer();\n    }\n\n    if (this.debug.drawEarth) {\n        if (replay.storeNodes || replay.storeFreeNodes) {\n            replay.nodeBuffer = [];\n        }\n        \n        if (replay.drawGlobe || replay.drawTiles || replay.drawFreeTiles||\n            replay.drawNodes || replay.drawFreeNodes || replay.drawLoaded) { //used only in inspector\n    \n            var lod = replay.lod; \n            var single = replay.singleLod; \n    \n            if (replay.drawTiles && replay.drawnTiles) {\n                tiles = replay.drawnTiles;\n                for (i = 0, li = tiles.length; i < li; i++) {\n                    if (!tiles[i][1]) { //skip grids\n                        tile = tiles[i][0];\n                        if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {\n                            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);\n                        }\n                    } else {\n                        tile = tiles[i][0];\n                        if (drawTiles.debug.drawBBoxes) {\n                            drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);\n                        }\n\n                        tile.drawGrid(cameraPos); \n                    }\n                }\n            }\n            \n            if (replay.drawFreeTiles && replay.drawnFreeTiles) {\n                tiles = replay.drawnFreeTiles;\n                for (i = 0, li = tiles.length; i < li; i++) {\n                    if (!tiles[i][1]) { //skip grids\n                        tile = tiles[i][0];\n                        if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {\n                            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);\n                        }\n                    }\n                }\n            }\n    \n            if (replay.drawNodes && replay.tracedNodes) {\n                tiles = replay.tracedNodes;\n                tmp = debug.drawBBoxes;\n                debug.drawBBoxes = true;  \n                for (i = 0, li = tiles.length; i < li; i++) {\n                    tile = tiles[i];\n                    if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {\n                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);\n                    }\n                }\n                debug.drawBBoxes = tmp;\n            }\n    \n            if (replay.drawFreeNodes && replay.tracedFreeNodes) {\n                tiles = replay.tracedFreeNodes;\n                tmp = debug.drawBBoxes;\n                debug.drawBBoxes = true;  \n                for (i = 0, li = tiles.length; i < li; i++) {\n                    tile = tiles[i];\n                    if ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod)) {\n                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);\n                    }\n                }\n                debug.drawBBoxes = tmp;\n            }\n    \n            var index = replay.loadedIndex; \n            var singleIndex = replay.singleLodedIndex; \n    \n            if (replay.drawLoaded && replay.loaded) {\n                var  loaded = replay.loaded;\n                debug.drawBBoxes = true;  \n                for (i = 0, li = loaded.length; i < li; i++) {\n                    var file = loaded[i];\n                    if (file && file.tile && file.tile.id) {\n                        tile = file.tile;\n                        if (((singleIndex && i == index) || (!singleIndex && i <= index)) &&\n                             ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod)) ) {\n                            if (tile.metanode) {\n                                if (tile.metanode.hasGeometry()) {\n                                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);\n                                } else {\n                                    drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);\n                                }\n                            }\n                        }\n                    }\n                }\n                debug.drawBBoxes = tmp;\n            }\n    \n            if ((replay.drawFreeTiles && replay.drawnFreeTiles) ||\n                (replay.drawLoaded && replay.loaded)) {\n                    \n                if (this.freeLayersHaveGeodata && this.drawChannel == 0) {\n                    renderer.drawnGeodataTiles = this.stats.drawnGeodataTilesPerLayer; //drawnGeodataTiles;\n                    renderer.drawnGeodataTilesFactor = this.stats.drawnGeodataTilesFactor;\n                    renderer.draw.drawGpuJobs();\n                }\n            }\n    \n            return;\n        }    \n        \n        for (i = 0, li = this.tileBuffer.length; i < li; i++) {  //todo remove this\n            this.tileBuffer[i] = null;    \n        }\n    \n        if (this.tree.surfaceSequence.length > 0) {\n            this.tree.draw();\n        }\n    \n        if (replay.storeTiles) { //used only in inspectors\n            drawnTiles = [];\n    \n            for (i = 0, li = this.tileBuffer.length; i < li; i++) {\n                tiles = this.tileBuffer[i];\n               \n                if (tiles) {\n                    for (j = 0, lj = tiles.length; j < lj; j++) {\n                        drawnTiles.push(tiles[j]);\n                    }\n                }\n            }\n            \n            replay.cameraPos = cameraPos; \n            replay.drawnTiles = drawnTiles;\n            replay.storeTiles = false; \n        }\n    \n        if (replay.storeNodes) { //used only in inspector\n            nodeBuffer = []; \n    \n            for (i = 0, li = replay.nodeBuffer.length; i < li; i++) {\n                tile = replay.nodeBuffer[i];\n                nodeBuffer.push(tile);\n            }\n    \n            replay.cameraPos = cameraPos; \n            replay.tracedNodes = nodeBuffer;\n            replay.storeNodes = false; \n        }\n    \n        //draw free layers    \n        for (i = 0, li = map.freeLayerSequence.length; i < li; i++) {\n            layer = map.freeLayerSequence[i];\n            if (layer.ready && layer.tree && \n                (!layer.geodata || (layer.stylesheet && layer.stylesheet.isReady())) && this.drawChannel == 0) {\n                \n                if (layer.zFactor) {\n                    this.zbufferOffset = layer.zFactor;\n                }\n\n                if (layer.type == 'geodata') {\n                    this.drawMonoliticGeodata(layer);\n                } else {\n                    layer.tree.draw();\n                }\n\n                this.zbufferOffset = null;\n            }\n        }\n    \n        if (replay.storeFreeTiles) { //used only in inspector\n            drawnTiles = [];\n    \n            for (i = 0, li = this.tileBuffer.length; i < li; i++) {\n                tiles = this.tileBuffer[i];\n               \n                if (tiles) {\n                    for (j = 0, lj = tiles.length; j < lj; j++) {\n                        tile = tiles[j];\n                        if (tile.surface && tile.surface.free) { //do no draw free layers\n                            drawnTiles.push(tile);\n                        }\n                    }\n                }\n            }\n            \n            replay.cameraPos = cameraPos; \n            replay.drawnFreeTiles = drawnTiles;\n            replay.storeFreeTiles = false; \n        }\n    \n        if (replay.storeFreeNodes) { //used only in inspector\n            nodeBuffer = []; \n    \n            for (i = 0, li = replay.nodeBuffer.length; i < li; i++) {\n                tile = replay.nodeBuffer[i];\n                if (tile.surface && tile.surface.free) { //do no draw free layers\n                    nodeBuffer.push(tile);\n                }\n            }\n    \n            replay.cameraPos = cameraPos; \n            replay.tracedFreeNodes = nodeBuffer;\n            replay.storeFreeNodes = false; \n        }\n    }\n\n    var body = map.referenceFrame.body;\n\n    //draw skydome before geodata\n    if (this.drawChannel != 1 && !projected && debug.drawFog &&\n        ((body && body.atmosphere) || map.referenceFrame.id == 'melown2015' || map.referenceFrame.id == 'mars-qsc' || map.referenceFrame.id == 'earth-qsc') &&\n        renderer.progAtmo.isReady() && renderer.progAtmo2.isReady()) {    \n\n        var navigationSrsInfo = map.getNavigationSrs().getSrsInfo();\n        var earthRadius =  navigationSrsInfo['a'];\n        var earthRadius2 =  navigationSrsInfo['b'];\n        var atmoSize = this.atmoHeight;\n        \n        var cameraPosToEarthCenter = [0,0,0,0];\n        vec3.normalize(camera.position, cameraPosToEarthCenter);\n\n        var pos = map.getPosition();\n        //var orientation = pos.getOrientation();\n        //var tiltFactor = (Math.max(5,-orientation[1])/90);\n\n        //var cameraHeight = Math.max(atmoSize * 0.1, camera.geocentDistance - earthRadius);\n        var heightFactor = 1-math.clamp(Math.max(atmoSize * 0.1, camera.geocentDistance - earthRadius) / (atmoSize*(10)), 0, 1);\n\n        var params = [Math.max(2,heightFactor*128),0,0,0], params2, params3;\n        \n        /*\n        if (cameraHeight > earthRadius*2) { //prevent foggy earth from larger distance\n            params[0] = 2-Math.min(1.0, (camera.height - earthRadius*2) / (earthRadius*2));\n        }*/\n\n        //gpu.setState(this.drawAtmoState);\n        //renderer.draw.drawBall([-camera.position[0], -camera.position[1], -camera.position[2]],\n          //                       earthRadius + 3000, earthRadius2 + 3000, renderer.progAtmo2, params,  cameraPosToEarthCenter, null, this.atmoColor3, this.atmoColor2, true);// this.cameraHeight > atmoSize ? 1 : -1);\n        \n        var safetyFactor = 2.0; \n        params = [safetyFactor, safetyFactor * ((earthRadius + atmoSize) / earthRadius), 0.25, safetyFactor* ((earthRadius + atmoSize) / earthRadius)];\n        var factor = (1 / (earthRadius) ) * safetyFactor;  \n        params2 = [camera.position[0] * factor, camera.position[1] * factor, camera.position[2] * factor, 1];\n        \n        var distance = (pos.getViewExtent()*0.5) / Math.tan(math.radians(pos.getFov()*0.5));\n        var a1 = (earthRadius / (distance + earthRadius)); //get angle to horion\n\n        //var n2 = 10.05;\n        var n2 = 5.00;\n\n        var t1 = math.mix(4.4, 1.01, a1);\n        var t2 = math.mix(n2, 1.05, a1); // * 1.0176;\n\n        params3 = [t1, 1 ,t2,0];\n\n        //console.log(\"a1: \" + a1 + \" t2: \" + t2);\n\n        gpu.setState(this.drawAuraState);\n        renderer.draw.drawBall([-camera.position[0], -camera.position[1], -camera.position[2]],\n                                 earthRadius + atmoSize, earthRadius2 + atmoSize, renderer.progAtmo, params,  params2, params3, this.atmoColor, this.atmoColor2);// this.camera.height > atmoSize ? 1 : -1);\n\n        gpu.setState(this.drawTileState);\n    }\n\n    if (debug.drawEarth) {\n        if (!skipFreeLayers) {\n            if (map.freeLayersHaveGeodata && this.drawChannel == 0) {\n                renderer.drawnGeodataTiles = this.stats.drawnGeodataTilesPerLayer; //drawnGeodataTiles;\n                renderer.drawnGeodataTilesFactor = this.stats.drawnGeodataTilesFactor;\n                renderer.draw.drawGpuJobs();\n            }\n        }\n    }\n\n    if (this.config.mapForceFrameTime) {\n        if (this.config.mapForceFrameTime != -1) {\n            renderer.frameTime = 0;\n            this.config.mapForceFrameTime = -1;\n        }\n    }\n};\n\nMapDraw.prototype.drawToTexture = function(texture) {\n    this.renderer.switchToFramebuffer('texture', texture);\n    this.drawChannel = 0;\n    this.map.renderSlots.processRenderSlots();\n    this.renderer.switchToFramebuffer('base');\n};\n\n\nMapDraw.prototype.drawHitmap = function() {\n    this.drawChannel = 1;\n    this.renderer.switchToFramebuffer('depth');\n    this.map.renderSlots.processRenderSlots();    \n    this.renderer.switchToFramebuffer('base');\n    this.drawChannel = 0;\n    this.map.hitMapDirty = false;\n};\n\n\nMapDraw.prototype.drawGeodataHitmap = function() {\n    this.renderer.gpu.setState(this.drawTileState);\n    this.renderer.switchToFramebuffer('geo');\n    this.renderer.draw.drawGpuJobs();\n\n    if (this.renderer.advancedPassNeeded) {\n        this.renderer.switchToFramebuffer('geo2');\n        this.renderer.draw.drawGpuJobs();\n    }\n\n    this.renderer.switchToFramebuffer('base');\n    this.map.geoHitMapDirty = false;\n};\n\nMapDraw.prototype.getDrawCommandsGpuSize = function(commands) {\n    var gpuNeeded = 0;\n    \n    for (var i = 0, li = commands.length; i < li; i++) {\n        var command = commands[i];\n        \n        switch (command.type) {\n        case VTS_DRAWCOMMAND_SUBMESH:\n               \n            var mesh = command.mesh; \n            var texture = this.config.mapNoTextures ? 0 : command.texture; \n\n            if (mesh) {\n                gpuNeeded += mesh.gpuSize;\n            }\n\n            if (texture) {\n                gpuNeeded += texture.getGpuSize();\n            }\n                \n            break;\n\n        case VTS_DRAWCOMMAND_GEODATA:\n                \n            var geodataView = command.geodataView; \n                \n            if (geodataView) {\n                gpuNeeded += geodataView.size;\n            }\n                \n            break;\n        }\n    }\n    \n    return gpuNeeded;\n};\n\n\nMapDraw.prototype.areDrawCommandsReady = function(commands, priority, doNotLoad, doNotCheckGpu) {\n    var ready = true;\n    var checkGpu = doNotCheckGpu ? true : false;\n    \n    for (var i = 0, li = commands.length; i < li; i++) {\n        var command = commands[i];\n        \n        switch (command.type) {\n        case VTS_DRAWCOMMAND_SUBMESH:\n\n            var pipeline = command.pipeline;\n            if (pipeline) {\n                var hmap = command.hmap;\n    \n                if (!(hmap && hmap.isReady(doNotLoad, priority))) {\n                    ready = false;\n                }\n\n                if (this.debug.drawTestMode == 9) {\n                    var texture = command.texture; \n                    var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority, checkGpu)));\n                        \n                    if (!textureReady) {\n                        ready = false;   \n                    }\n                }\n\n                break;\n            }\n                \n            var mesh = command.mesh; \n            var texture = command.texture; \n                \n            var meshReady = (mesh && mesh.isReady(doNotLoad, priority, checkGpu));\n            var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority, checkGpu)));\n                \n            if (!(meshReady && textureReady) ) {\n                ready = false;   \n            }\n\n               \n            break;\n\n        case VTS_DRAWCOMMAND_GEODATA:\n                \n            var geodataView = command.geodataView; \n                \n            if (!(geodataView && geodataView.isReady(doNotLoad, priority, checkGpu))) {\n                ready = false;   \n            }\n                \n            break;\n        }\n    }\n    \n    return ready;\n};\n\n\nMapDraw.prototype.processDrawCommands = function(cameraPos, commands, priority, doNotLoad, tile) {\n    if (commands.length > 0) {\n        this.drawTileCounter++;\n    }\n\n    for (var i = 0, li = commands.length; i < li; i++) {\n        var command = commands[i];\n        \n        switch (command.type) {\n        case VTS_DRAWCOMMAND_STATE:\n            this.renderer.gpu.setState(command.state);\n            break;\n\n        case VTS_DRAWCOMMAND_SUBMESH:\n\n            var pipeline = command.pipeline;\n            if (pipeline) {\n                var hmap = command.hmap;\n    \n                if (this.debug.drawTestMode == 9) {\n                    var texture = command.texture; \n                    var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority)));\n                        \n                    if (textureReady) {\n                        if (hmap && hmap.isReady(doNotLoad, priority)) {\n                            tile.drawHmapTile(cameraPos, null, null, pipeline, texture);\n                        }\n                    }\n                } else {\n                    if (hmap && hmap.isReady(doNotLoad, priority)) {\n                        tile.drawHmapTile(cameraPos, null, null, pipeline);\n                    }\n                }\n\n                return;\n            }\n\n            var mesh = command.mesh; \n            var texture = command.texture;\n\n            var meshReady = (mesh && mesh.isReady(doNotLoad, priority)), textureReady;\n\n            if (this.config.mapNoTextures) {\n                textureReady = true;\n                texture = null;\n            } else {\n                textureReady = (!texture || (texture && texture.isReady(doNotLoad, priority)));\n            }\n                \n            if (meshReady && textureReady) {\n                    //debug bbox\n                if (this.debug.drawBBoxes && this.debug.drawMeshBBox) {\n                    mesh.submeshes[command.submesh].drawBBox(cameraPos);\n                }\n                    \n                if (!texture) {\n                    var material = command.material;\n                    switch (material) {\n                            //case \"fog\":\n                    case VTS_MATERIAL_EXTERNAL:\n                    case VTS_MATERIAL_INTERNAL:\n                        material = VTS_MATERIAL_FLAT;\n                        break; \n                    }\n                    mesh.drawSubmesh(cameraPos, command.submesh, texture, material, command.alpha, command.layer);\n                } else {\n                    //tile.renderHappen = true;\n                    mesh.drawSubmesh(cameraPos, command.submesh, texture, command.material, command.alpha, command.layer);\n                }\n\n            }\n                \n            break;\n                \n        case VTS_DRAWCOMMAND_GEODATA:\n                \n            var geodataView = command.geodataView; \n            //tile.renderHappen = true;\n                \n            if (geodataView && geodataView.isReady(doNotLoad, priority, true)) {\n                geodataView.draw(cameraPos);\n            }\n                \n            break;\n        }\n    }\n};\n\n\nMapDraw.prototype.drawMonoliticGeodata = function(surface) {\n    if (!surface || this.drawChannel != 0) {\n        return;\n    }\n\n    if (!this.camera.camera.bboxVisible(surface.extents, this.camera.position)) {\n        return;\n    }\n\n    var path;\n\n    if (surface.monoGeodata == null) {\n        if (typeof surface.geodataUrl === 'object') {\n            path = surface.geodataUrl;\n        } else {\n            path = surface.getMonoGeodataUrl(surface.id);\n        }\n\n        surface.monoGeodata = new MapGeodata(this.map, path, {tile:null, surface:surface});\n    }\n\n    if (surface.monoGeodataCounter != surface.geodataCounter) {\n        surface.monoGeodataView = null;\n        surface.monoGeodataCounter = surface.geodataCounter;\n    }\n\n    if (surface.monoGeodata.isReady()) {\n\n        if (!surface.monoGeodataView) {\n            surface.monoGeodataView = new MapGeodataView(this.map, surface.monoGeodata, {tile:null, surface:surface});\n        }\n        \n        if (surface.monoGeodataView.isReady()) {\n            var mapdataCredits = this.map.visibleCredits.mapdata\n\n            for (var i = 0, li = surface.credits.length; i < li; i++) {\n                var key = surface.credits[i]\n                var value = 10; //fixed specificity\n                var value2 = mapdataCredits[key];\n\n                if (value2) {\n                    mapdataCredits[key] = value > value2 ? value : value2;\n                } else {\n                    mapdataCredits[key] = value;\n                }\n            }\n\n            surface.monoGeodataView.draw(this.camera.position);\n        }\n    }\n};\n\n\nMapDraw.prototype.updateFogDensity = function() {\n    // the fog equation is: exp(-density*distance), this gives the fraction\n    // of the original color that is still visible at some distance\n\n    // we define visibility as a distance where only 5% of the original color\n    // is visible; from this it is easy to calculate the correct fog density\n\n    //var density = Math.log(0.05) / this.core.coreConfig.cameraVisibility;\n    var pos = this.map.getPosition();\n    var orientation = pos.getOrientation();\n    \n    var cameraVisibility = this.camera.getFar();\n    \n    var tiltFactor = (Math.max(5,-orientation[1])/90);\n    var density = Math.log(0.05) / ((this.atmoDensity * cameraVisibility * this.atmoHeightFactor * Math.max(1,this.camera.height*0.0001))* tiltFactor);\n    density *= (5.0) / (Math.min(50000, Math.max(this.camera.distance, 1000)) /5000);\n\n    if (!this.debug.drawFog) {\n        density = 0;\n    }\n    \n    //reduce fog when camera is facing down\n    //density *= 1.0 - (-this.orientation[0]/90)\n    \n    this.fogDensity = density;\n    this.renderer.fogDensity = density; \n\n    //console.log(\"fden: \" + density);\n};\n\n\nMapDraw.prototype.updateGridFactors = function() {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i]; \n        var embed = 8;\n\n        var altitude = Math.max(10, this.camera.distance + 20);\n        //var altitude = Math.max(1.1, this.cameraDistance);\n        var maxDistance = (node.extents.ur[0] - node.extents.ll[0])*2;\n        var gridSelect = Math.log(Math.min(maxDistance,altitude)) / this.log8;\n        var gridMax = Math.log(maxDistance) / this.log8;\n    \n        gridSelect = gridMax - gridSelect;\n    \n        node.gridBlend = (gridSelect - Math.floor(gridSelect));\n        \n        gridSelect = Math.floor(Math.floor(gridSelect))+1;\n        node.gridStep1 = Math.pow(embed, gridSelect);\n        node.gridStep2 = node.gridStep1 * 8; \n    }\n};\n\n\nMapDraw.prototype.setupDetailDegradation = function(degradeMore) {\n    var factor = 0;\n    \n    if (this.map.mobile) {\n        factor = this.config.mapMobileDetailDegradation;\n    }\n\n    if (degradeMore) {\n        factor += degradeMore;        \n    }\n\n    this.texelSizeFit = this.config.mapTexelSizeFit * Math.pow(2,factor);      \n};\n\n\nexport default MapDraw;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/draw.js\n// module id = 132\n// module chunks = 0 1","\nimport MapGeodataGeometry_ from './geodata-geometry';\nimport MapGeodataImportGeoJSON_ from './geodata-import/geojson';\nimport MapGeodataImportVTSGeodata_ from './geodata-import/vts-geodata';\n//import GeographicLib_ from 'geographiclib';\nimport {vec3 as vec3_, mat4 as mat4_,} from '../utils/matrix';\n\n//get rid of compiler mess\nvar MapGeodataGeometry = MapGeodataGeometry_;\nvar MapGeodataImportGeoJSON = MapGeodataImportGeoJSON_;\nvar MapGeodataImportVTSGeodata = MapGeodataImportVTSGeodata_;\n//var GeographicLib = GeographicLib_;\nvar vec3 = vec3_;\nvar mat4 = mat4_;\n\n\nvar MapGeodataBuilder = function(map) {\n    this.map = map;\n    this.groups = [];\n    this.currentGroup = null;\n    this.bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n    this.bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n\n    this.navSrs = this.map.getNavigationSrs();\n    //this.navSrs = this.map.getPublicSrs();\n    this.physSrs = this.map.getPhysicalSrs();\n\n    this.heightsToProcess = 0;\n    this.heightsProcessBuffer = null;\n    this.heightsProcessBufferFirst = null;\n    this.heightsProcessBufferLast = null;\n\n    this.heightsLod = 8;\n    this.heightsSource = \"heightmap-by-precision\";\n    this.updateCallback = null;\n    this.processingHeights = false;\n    this.processHeightsCalls = [];\n};\n\n\nMapGeodataBuilder.prototype.addToHeightsBuffer = function(coords) {\n\n    var item = { coords: coords, prev: null, next: this.heightsProcessBufferFirst };\n\n    if (this.heightsProcessBufferFirst != null) {\n        this.heightsProcessBufferFirst.prev = item;\n    }\n\n    //add item as first in list\n    this.heightsProcessBufferFirst = item;\n\n    if (this.heightsProcessBufferLast == null) {\n        this.heightsProcessBufferLast = item;\n    }\n};\n\n\nMapGeodataBuilder.prototype.removeFromHeightsBuffer = function(item) {\n    var hit = false;\n\n    if (item == this.heightsProcessBufferFirst) {\n        this.heightsProcessBufferFirst = item.next;\n        hit = true;\n\n        if (this.heightsProcessBufferFirst != null) {\n            this.heightsProcessBufferFirst.prev = null;\n        }\n    }\n\n    if (item == this.heightsProcessBufferLast) {\n        this.heightsProcessBufferLast = item.prev;\n        hit = true;\n\n        if (this.heightsProcessBufferLast != null) {\n            this.heightsProcessBufferLast.next = null;\n        }\n    }\n\n    if (!hit) {\n        if (!item.prev) {\n            //debugger;\n        } else {\n            item.prev.next = item.next;\n        }\n        \n        if (!item.next) {\n            //debugger;\n        } else {\n            item.next.prev = item.prev;\n        }\n    }\n};\n\n\nMapGeodataBuilder.prototype.addGroup = function(id) {\n    this.groups.push({\n        points: [],\n        lines: [],\n        polygons: [],\n        id: id\n    });\n\n    this.currentGroup = this.groups[this.groups.length - 1];\n\n    return this;\n};\n\nMapGeodataBuilder.prototype.addPoint = function(point, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\"), coords;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    if (floatHeight) {\n        coords = [point[0], point[1], point[2] || 0, feature, null, null ];\n        this.addToHeightsBuffer(coords);\n\n        feature.points = [ coords ];\n        feature.floatHeights = true;\n        feature.srs = srs ? srs : this.navSrs;\n        feature.heightsToProcess = 1;\n        this.heightsToProcess++;\n    } else {\n        if (directCopy) {\n            feature.points = [ [point[0], point[1], point[2]] ];\n        } else {\n            feature.points = [ this.physSrs.convertCoordsFrom(point, srs ? srs : this.navSrs) ];\n        }\n    }\n\n    this.currentGroup.points.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addPointArray = function(points, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\"), i, li, point, coords;\n    srs = srs ? srs : this.navSrs;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    var featurePoints = new Array(points.length);\n\n    if (floatHeight) {\n        \n        for (i = 0, li = points.length; i < li; i++) {\n            point = points[i];\n            coords = [point[0], point[1], point[2] || 0, feature, null, null ];\n            this.addToHeightsBuffer(coords);\n\n            featurePoints[i] = coords;\n        }\n\n        feature.floatHeights = true;\n        feature.srs = srs;\n        feature.heightsToProcess = li;\n        this.heightsToProcess++;\n    } else {\n        if (directCopy) {\n            for (i = 0, li = points.length; i < li; i++) {\n                point = points[i];\n                featurePoints[i] = [point[0], point[1], point[2]];\n            }\n        } else {\n            for (i = 0, li = points.length; i < li; i++) {\n                featurePoints[i] = this.physSrs.convertCoordsFrom(points[i], srs);\n            }\n        }\n    }\n\n    feature.points = featurePoints;\n    this.currentGroup.points.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addLineString = function(linePoints, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\"), i, li, point, coords;\n    srs = srs ? srs : this.navSrs;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    var featurePoints = new Array(linePoints.length);\n\n    if (floatHeight) {\n        \n        for (i = 0, li = linePoints.length; i < li; i++) {\n            point = linePoints[i];\n            coords = [point[0], point[1], point[2] || 0, feature, null, null ];\n            this.addToHeightsBuffer(coords);\n\n            featurePoints[i] = coords;\n        }\n\n        feature.floatHeights = true;\n        feature.srs = srs;\n        feature.heightsToProcess = li;\n        this.heightsToProcess += li;\n    } else {\n        if (directCopy) {\n            for (i = 0, li = linePoints.length; i < li; i++) {\n                point = linePoints[i];\n                featurePoints[i] = [point[0], point[1], point[2]];\n            }\n        } else {\n            for (i = 0, li = linePoints.length; i < li; i++) {\n                featurePoints[i] = this.physSrs.convertCoordsFrom(linePoints[i], srs);\n            }\n        }\n    }\n\n    feature.lines = [featurePoints];\n    this.currentGroup.lines.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addLineStringArray = function(lines, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\");\n    var subline, points, i, li, j, lj, point, coords;\n    srs = srs ? srs : this.navSrs;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    var featureLines = new Array(lines.length);\n\n    if (floatHeight) {\n        var totalHeights = 0;\n        \n        for (i = 0, li = lines.length; i < li; i++) {\n            subline = lines[i];\n            points = new Array(subline.length);\n\n            for (j = 0, lj = subline.length; j < lj; j++) {\n                point = subline[j];\n                coords = [point[0], point[1], point[2] || 0, feature, null, null];\n                this.addToHeightsBuffer(coords);\n                points[j] = coords;\n            }\n\n            totalHeights += lj;\n            featureLines[i] = points;\n        }\n\n        feature.floatHeights = true;\n        feature.srs = srs;\n        feature.heightsToProcess = totalHeights;\n        this.heightsToProcess += totalHeights;\n    } else {\n\n        for (i = 0, li = lines.length; i < li; i++) {\n            subline = lines[i];\n            points = new Array(subline.length);\n\n            if (directCopy) {\n                for (j = 0, lj = subline.length; j < lj; j++) {\n                    point = subline[j];\n                    points[j] = [point[0], point[1], point[2]];\n                }\n            } else {\n                for (j = 0, lj = subline.length; j < lj; j++) {\n                    points[j] = this.physSrs.convertCoordsFrom(subline[j], srs);\n                }\n            }\n\n            featureLines[i] = points;\n        }\n    }\n\n    feature.lines = featureLines;\n    this.currentGroup.lines.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.addPolygon = function(shape, holes, middle, heightMode, properties, id, srs) {\n    srs = srs ? srs : this.navSrs.srsProj4;\n    holes = holes || [];\n\n    var flatShape = shape, flatHoles = holes, i, li, j, k, lk, l, hole, coords, proj, holesIndices, vertices;\n\n    //convert shape and holes to flat space\n    if (srs.indexOf('+proj=longlat') != -1) {\n        proj = this.map.proj4(srs, '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');\n    }\n\n    var totalPoints = shape.length*3;\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        totalPoints += holes[i].length*3;\n    }\n\n    flatShape = new Array(totalPoints);\n    vertices = new Array(totalPoints);\n    j = 0;\n\n    var borders = new Array(holes.length + 1);\n    var border = new Array(shape.length);\n    borders[0] = border;\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        border[i] = i;\n        coords = shape[i];\n        vertices[j] = coords[0]; \n        vertices[j+1] = coords[1]; \n        vertices[j+2] = coords[2]; \n        coords = proj ? proj.forward(shape[i]) : shape[i];\n        flatShape[j] = coords[0]; \n        flatShape[j+1] = coords[1]; \n        flatShape[j+2] = coords[2]; \n        j+=3;\n    }\n\n    flatHoles = new Array(holes.length);\n    holesIndices = new Array(holes.length);\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        holesIndices[i] = Math.round(j/3);\n\n        border = new Array(hole.length);\n        borders[i + 1] = border;\n\n        l = Math.floor(j /3);\n\n        for (k = 0, lk = hole.length; k < lk; k++) {\n            coords = hole[k];\n            vertices[j] = coords[0]; \n            vertices[j+1] = coords[1]; \n            vertices[j+2] = coords[2]; \n            coords = proj ? proj.forward(hole[k]) : hole[k];\n            flatShape[j] = coords[0]; \n            flatShape[j+1] = coords[1]; \n            flatShape[j+2] = coords[2]; \n            j+=3;\n            border[k] = l++;\n        }\n    }\n\n    var surface = vts.earcut(flatShape, holesIndices, 3);\n\n    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.getPolygonCenter = function(shape, projected, proj) {\n    if (shape && !shape.length) {\n        return [0,0];\n    }\n\n    var sumX = 0, sumY = 0, sumZ = 0; //, convertLong = false;\n\n    if (projected) {\n        for (var i = 0, li = shape.length; i < li; i++) {\n            var coords = shape[i];\n            sumX += coords[0];\n            sumY += coords[1];\n            sumZ += coords[2];\n        }\n\n        return [sumX / li, sumY / li, sumZ / li];\n    } else {\n        for (var i = 0, li = shape.length; i < li; i++) {\n            var coords = shape[i];\n\n            coords = proj.forward(coords);\n            sumX += coords[0];\n            sumY += coords[1];\n            sumZ += coords[2];\n\n            //if (Math.abs(Math.abs(coords[0])-180) < 0.001) {\n              //  convertLong = true;\n            //}\n\n            /*\n            var lng = coords[0] * Math.PI / 180; //deg to rad\n            var lat = coords[1] * Math.PI / 180;\n\n            // sum of cartesian coordinates\n            sumX += Math.cos(lat) * Math.cos(lng);\n            sumY += Math.cos(lat) * Math.sin(lng);\n            sumZ += Math.sin(lat);\n            */\n        }\n\n        var avgX = sumX / li;\n        var avgY = sumY / li;\n        var avgZ = sumZ / li;\n\n        // convert average x, y, z coordinate to latitude and longtitude\n        /*\n        var lng = Math.atan2(avgY, avgX);\n        var hyp = Math.sqrt(avgX * avgX + avgY * avgY);\n        var lat = Math.atan2(avgZ, hyp);\n\n        return [lng * 180 / Math.PI, lat *  180 / Math.PI, avgZ]; //rad to deg\n        */\n\n        coords = proj.inverse([avgX, avgY, avgZ]);\n\n        return [coords[0], coords[1], 0];\n    }\n};\n\n\nMapGeodataBuilder.prototype.addPolygon2 = function(shape, holes, middle, heightMode, properties, id, srs) {\n    srs = srs ? srs : this.navSrs.srsProj4;\n    holes = holes || [];\n\n    var flatShape = shape, flatHoles = holes, i, li, j, k, lk, l, hole, coords, proj, holesIndices, vertices;\n    var projected = true;\n\n    //convert shape and holes to flat space\n    if (srs.indexOf('+proj=longlat') != -1) {\n        projected = false;\n        //proj = this.map.proj4(srs, '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');\n        //proj = this.map.proj4(srs, '+proj=merc +lat_ts=' + center[1] + ' +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');\n        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');\n    }\n\n    var c = document.getElementById(\"dbg-canvas\");\n    var ctx = c.getContext(\"2d\");\n    var sx = 300;\n    var fx = 300 / 7500000;\n\n    var center = this.getPolygonCenter(shape, projected, proj), north, east, dir;\n\n    this.addPoint(center, 'fix', {}, 'aaa');\n\n//    var ned = this.map.measure.getNewNED(center, true);\n    var ned = this.map.measure.getNewNED(center);\n\n    dir = ned.direction;\n    north = ned.north;\n    east = ned.east;\n\n    //var center2 = proj.forward(center);\n\n    coords = proj.forward(center);\n    var coords2 = [coords[0]+1000000*east[0], coords[1]+1000000*east[1], coords[2]+1000000*east[2]];\n\n    this.addLineString([coords, coords2], 'fix', {}, 'line', null, true);\n    var coords2 = [coords[0]+1000000*dir[0], coords[1]+1000000*dir[1], coords[2]+1000000*dir[2]];\n\n    this.addLineString([coords, coords2], 'fix', {}, 'line', null, true);\n    var coords2 = [coords[0]+1000000*north[0], coords[1]+1000000*north[1], coords[2]+1000000*north[2]];\n\n\n    this.addLineString([coords, coords2], 'fix', {}, 'line', null, true);\n    //ned = this.map.measure.getNewNED(center, true);\n\n    if (!projected) {\n        var pos = this.map.getPosition();\n        pos.setCoords(center);\n        pos.setOrientation([0,0,-90]);\n        var ret = this.map.measure.getPositionCameraInfo(pos, false, false);\n        ned = ret.rotMatrix;\n\n        mat4.inverse(ned);\n        dir = [ned[2], ned[6], ned[10]];\n        north = [ned[1], ned[5], ned[9]];\n        east = [ned[0], ned[4], ned[8]];\n    }\n\n    var totalPoints = shape.length*3;\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        totalPoints += holes[i].length*3;\n    }\n\n    flatShape = new Array(totalPoints);\n    vertices = new Array(totalPoints);\n    j = 0;\n\n    var borders = new Array(holes.length + 1);\n    var border = new Array(shape.length);\n    borders[0] = border;\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        border[i] = i;\n        coords = shape[i];\n        vertices[j] = coords[0]; \n        vertices[j+1] = coords[1]; \n        vertices[j+2] = coords[2];\n\n        if (proj) {\n            coords = proj.forward(shape[i]);\n            //coords[0] -= center2[0];\n            //coords[1] -= center2[1];\n            //coords[2] -= center2[2];\n            coords[0] = east[0] * coords[0] + east[1] * coords[1] + east[2] * coords[2];\n            coords[1] = dir[0] * coords[0] + dir[1] * coords[1] + dir[2] * coords[2];\n            coords[2] = 0;\n        } else {\n            coords = shape[i];\n        }\n\n        if (i ==0) {\n            ctx.moveTo(coords[0]*fx+sx,coords[1]*fx+sx);\n        } else {\n            ctx.lineTo(coords[0]*fx+sx,coords[1]*fx+sx);\n        }\n\n        flatShape[j] = coords[0]; \n        flatShape[j+1] = coords[1]; \n        flatShape[j+2] = coords[2]; \n        j+=3;\n    }\n\n    flatHoles = new Array(holes.length);\n    holesIndices = new Array(holes.length);\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        holesIndices[i] = Math.round(j/3);\n\n        border = new Array(hole.length);\n        borders[i + 1] = border;\n\n        l = Math.floor(j /3);\n\n        for (k = 0, lk = hole.length; k < lk; k++) {\n            coords = hole[k];\n            vertices[j] = coords[0]; \n            vertices[j+1] = coords[1]; \n            vertices[j+2] = coords[2]; \n\n            if (proj) {\n                coords = proj.forward(hole[k]);\n                coords[0] = east[0] * coords[0] + east[1] * coords[1] + east[2] * coords[2];\n                coords[1] = dir[0] * coords[0] + dir[1] * coords[1] + dir[2] * coords[2];\n                coords[2] = 0;\n            } else {\n                coords = hole[k];\n            }\n\n            if (k ==0) {\n                ctx.moveTo(coords[0]*fx+sx,coords[1]*fx+sx);\n            } else {\n                ctx.lineTo(coords[0]*fx+sx,coords[1]*fx+sx);\n            }\n\n\n            flatShape[j] = coords[0]; \n            flatShape[j+1] = coords[1]; \n            flatShape[j+2] = coords[2]; \n            j+=3;\n            border[k] = l++;\n        }\n    }\n\n    ctx.strokeStyle = \"#ff0000\";\n    ctx.stroke();\n\n\n    var surface = vts.earcut(flatShape, holesIndices, 3);\n\n    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.insidePolygon = function(point, vertices, verticesLength) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vertices.length - 1, li = (verticesLength || vertices.length); i < li; j = i++) {\n        var xi = vertices[i*3], yi = vertices[i*3+1];\n        var xj = vertices[j*3], yj = vertices[j*3+1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};    \n\n\nMapGeodataBuilder.prototype.addPolygon3 = function(shape, holes, middle, heightMode, properties, id, srs) {\n    srs = srs ? srs : this.navSrs.srsProj4;\n    holes = holes || [];\n\n    var flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords, proj, holesIndices, vertices;\n    var projected = true, dx, dy, dd, maxDistance = 0, maxDistanceCoords, flatCenter, trueHolesCount = holes.length;\n    var density = 19;\n\n    //convert shape and holes to flat space\n    if (srs.indexOf('+proj=longlat') != -1) {\n        projected = false;\n        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');\n    }\n\n    var center = this.getPolygonCenter(shape, projected, proj), north, east, dir;\n\n    if (!projected) {\n        var pos = this.map.getPosition();\n        pos.setCoords(center);\n        pos.setOrientation([0,0,-90]);\n        var ret = this.map.measure.getPositionCameraInfo(pos, false, false);\n        var ned = ret.rotMatrix;\n\n        mat4.inverse(ned);\n        dir = [ned[2], ned[6], ned[10]];\n        north = [ned[1], ned[5], ned[9]];\n        east = [ned[0], ned[4], ned[8]];\n    }\n\n\n    var center2 = proj.forward(center);\n    center2[0] = east[0] * center2[0] + east[1] * center2[1] + east[2] * center2[2];\n    center2[1] = dir[0] * center2[0] + dir[1] * center2[1] + dir[2] * center2[2];\n    center2[2] = 0;\n\n    var totalPoints = shape.length*3;\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        totalPoints += holes[i].length*3;\n    }\n\n    flatShape = new Array(totalPoints);\n    vertices = new Array(totalPoints);\n    j = 0;\n\n    var borders = new Array(holes.length + 1);\n    var border = new Array(shape.length);\n    borders[0] = border;\n\n    if (proj) {\n        coords = proj.forward(center);\n        coords[0] = east[0] * coords[0] + east[1] * coords[1] + east[2] * coords[2];\n        coords[1] = north[0] * coords[0] + north[1] * coords[1] + north[2] * coords[2];\n        coords[2] = 0;\n        flatCenter = coords;\n    }\n\n    for (i = 0, li = shape.length; i < li; i++) {\n        border[i] = i;\n        coords = shape[i];\n        vertices[j] = coords[0]; \n        vertices[j+1] = coords[1]; \n        vertices[j+2] = coords[2];\n\n        if (proj) {\n            coords = proj.forward(shape[i]);\n            coords[0] = east[0] * coords[0] + east[1] * coords[1] + east[2] * coords[2];\n            coords[1] = dir[0] * coords[0] + dir[1] * coords[1] + dir[2] * coords[2];\n            coords[2] = 0;\n        } else {\n            coords = shape[i];\n        }\n\n        dx = coords[0] - center2[0];\n        dy = coords[1] - center2[1];\n        dd = dx * dx + dy * dy;\n        if (dd > maxDistance) {\n            maxDistance = dd;\n            maxDistanceCoords = shape[i]\n        }\n\n        flatShape[j] = coords[0]; \n        flatShape[j+1] = coords[1]; \n        flatShape[j+2] = coords[2]; \n        j+=3;\n    }\n\n    flatHoles = new Array(holes.length);\n    holesIndices = new Array(holes.length);\n\n    for (i = 0, li = holes.length; i < li; i++) {\n        hole = holes[i];\n        holesIndices[i] = Math.round(j/3);\n\n        if (i < trueHolesCount) {\n            border = new Array(hole.length);\n            borders[i + 1] = border;\n        }\n\n        l = Math.floor(j /3);\n\n        for (k = 0, lk = hole.length; k < lk; k++) {\n            coords = hole[k];\n            vertices[j] = coords[0]; \n            vertices[j+1] = coords[1]; \n            vertices[j+2] = coords[2]; \n\n            if (proj) {\n                coords = proj.forward(hole[k]);\n                coords[0] = east[0] * coords[0] + east[1] * coords[1] + east[2] * coords[2];\n                coords[1] = dir[0] * coords[0] + dir[1] * coords[1] + dir[2] * coords[2];\n                coords[2] = 0;\n            } else {\n                coords = hole[k];\n            }\n\n            flatShape[j] = coords[0]; \n            flatShape[j+1] = coords[1]; \n            flatShape[j+2] = coords[2]; \n            j+=3;\n\n            if (i < trueHolesCount) {\n                border[k] = l++;\n            }\n        }\n    }\n\n    var surface = vts.earcut(flatShape, holesIndices, 3);\n\n    var maxFaceLength = Math.sqrt(maxDistance) / density;\n    var v1, v2, v3, p1, p2, p3, p4, p5, p6;\n\n    /*\n    for (k = 0; k < 5; k++) {\n\n        var vertices2 = new Array(vertices.length * 2);\n        var surface2 = new Array(surface.length * 4);\n\n        j = vertices.length\n        l = 0;\n\n        for (i = 0, li = vertices.length; i < li; i +=3) {\n            vertices2[i] = vertices[i];\n            vertices2[i+1] = vertices[i+1];\n            vertices2[i+2] = vertices[i+2];\n        }\n\n        for (i = 0, li = surface.length; i < li; i +=3) {\n            v1 = surface[i];\n            v2 = surface[i+1];\n            v3 = surface[i+2];\n\n            p1 = [vertices[v1*3], vertices[v1*3+1], vertices[v1*3+2]];\n            p2 = [vertices[v2*3], vertices[v2*3+1], vertices[v2*3+2]];\n            p3 = [vertices[v3*3], vertices[v3*3+1], vertices[v3*3+2]];\n            p1 = proj.forward(p1);\n            p2 = proj.forward(p2);\n            p3 = proj.forward(p3);\n\n            p4 = [(p1[0]+p2[0])*0.5, (p1[1]+p2[1])*0.5, (p1[2]+p2[2])*0.5];\n            p5 = [(p2[0]+p3[0])*0.5, (p2[1]+p3[1])*0.5, (p2[2]+p3[2])*0.5];\n            p6 = [(p3[0]+p1[0])*0.5, (p3[1]+p1[1])*0.5, (p3[2]+p1[2])*0.5];\n            p4 = proj.inverse(p4); p4[2] = (vertices[v1*3+2]+vertices[v2*3+2])*0.5;\n            p5 = proj.inverse(p5); p5[2] = (vertices[v2*3+2]+vertices[v3*3+2])*0.5;\n            p6 = proj.inverse(p6); p6[2] = (vertices[v3*3+2]+vertices[v1*3+2])*0.5;\n\n            jj = j * 3;\n\n            vertices2[jj] = p4[0];\n            vertices2[jj+1] = p4[1];\n            vertices2[jj+2] = p4[2];\n\n            vertices2[jj+3] = p5[0];\n            vertices2[jj+4] = p5[1];\n            vertices2[jj+5] = p5[2];\n\n            vertices2[jj+6] = p6[0];\n            vertices2[jj+7] = p6[1];\n            vertices2[jj+8] = p6[2];\n\n            surface2[l] = v1;\n            surface2[l+1] = j;\n            surface2[l+2] = j + 2;\n\n            surface2[l+3] = j;\n            surface2[l+4] = v2;\n            surface2[l+5] = j + 1;\n\n            surface2[l+6] = j + 2;\n            surface2[l+7] = j + 1;\n            surface2[l+8] = v3;\n\n            surface2[l+9] = j + 2;\n            surface2[l+10] = j;\n            surface2[l+11] = j + 1;\n\n            j += 3;\n            l += 12;\n        }\n\n        vertices = vertices2;\n        surface = surface2;\n    }\n\n    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);\n    //this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);\n\n    return this;\n    */\n\n    //this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);\n    //return this;\n\n    //copy bordes\n    var borders2 = new Array(borders.length), border2; \n    for (i = 0, li = borders.length; i < li; i++) {\n        borders2[i] = borders[i].slice();\n    }\n\n    var sbuffer = new Array(65536*3);\n    var sbuffer2 = new Array(65536*3);\n    var sbuffer3 = new Array(65536*3);\n\n    var sbufferIndex = 0, l1, l2, l3, vv1, vv2, vv3;\n    var sbufferIndex2 = 0;//, i1, i2, i3;\n    var sbufferIndex3 = 0;\n\n    var vbuffer = new Array(65536*3);\n\n    //copy vertices\n    for (i = 0, li = vertices.length; i < li; i +=3) { \n        vbuffer[i] = vertices[i];\n        vbuffer[i+1] = vertices[i+1];\n        vbuffer[i+2] = vertices[i+2];\n    }\n\n    var m = Math.round(li / 3);\n\n\n    var lastMaxFaceLength = maxFaceLength;\n\n    for (i = 0, li = surface.length; i < li; i +=3) { \n\n        v1 = surface[i];\n        v2 = surface[i+1];\n        v3 = surface[i+2];\n        sbufferIndex = 3;\n\n        //find face edges in borders\n        var edge1 = null, edge2 = null, edge3 = null;\n        //var edge1, edge2, edge3;\n        for (j = 0, lj = borders.length; j < lj; j++) { \n            border = borders[j];\n            border2 = borders2[j];\n\n            for (k = 0, lk = border.length; k < lk; k++) {\n                var k2 = (k < border.length - 1) ? k + 1 : 0;\n\n                if ((v1 == border[k] && v2 == border[k2]) || (v1 == border[k2] && v2 == border[k])) {\n                    border2[k] = [border[k]];\n                    edge1 = border2[k];\n                }\n\n                if ((v2 == border[k] && v3 == border[k2]) || (v2 == border[k2] && v3 == border[k])) {\n                    border2[k] = [border[k]];\n                    edge2 = border2[k];\n                }\n\n                if ((v3 == border[k] && v1 == border[k2]) || (v1 == border[k2] && v3 == border[k])) {\n                    border2[k] = [border[k]];\n                    edge3 = border2[k];\n                }\n            }\n        }\n\n        sbuffer[0] = [v1, edge1];\n        sbuffer[1] = [v2, edge2];\n        sbuffer[2] = [v3, edge3];\n\n        var depth = 0;\n        //maxFaceLength = Number.POSITIVE_INFINITY;\n\n        //loop until subdivision is finished\n        do {\n\n            for (j = 0, lj = sbufferIndex; j < lj; j+=3) {\n                //face indices\n                vv1 = sbuffer[j][0];\n                vv2 = sbuffer[j+1][0];\n                vv3 = sbuffer[j+2][0];\n                //face edges\n                edge1 = sbuffer[j][1];\n                edge2 = sbuffer[j+1][1];\n                edge3 = sbuffer[j+2][1];\n\n                /*console.log('v1: ' + vv1 + ' v2:' + vv2 + ' v3:' + vv3);\n                console.log('e1: ' + (Array.isArray(edge1) ? 'a' : '') + edge1 + ' e2:' + (Array.isArray(edge2) ? 'a' : '') + edge2 + ' e3:' + (Array.isArray(edge3) ? 'a' : '') + edge3);\n                */\n\n                //get face vertices\n                p1 = [vbuffer[vv1*3], vbuffer[vv1*3+1], vbuffer[vv1*3+2]];\n                p2 = [vbuffer[vv2*3], vbuffer[vv2*3+1], vbuffer[vv2*3+2]];\n                p3 = [vbuffer[vv3*3], vbuffer[vv3*3+1], vbuffer[vv3*3+2]];\n\n                //covert coords to geocent\n                p1 = proj.forward(p1);\n                p2 = proj.forward(p2);\n                p3 = proj.forward(p3);\n\n                //get face edges lengths\n                l1 = vec3.length([p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]]);\n                l2 = vec3.length([p2[0] - p3[0], p2[1] - p3[1], p2[2] - p3[2]]);\n                l3 = vec3.length([p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]]);\n\n                //get max length\n                l = Math.max(l1,l2,l3);\n\n                //console.log('ll:' + l);\n\n                //is length below threshold\n                if (l < maxFaceLength) {  \n                    //add to final buffer\n                    sbuffer3[sbufferIndex3] = vv1;\n                    sbuffer3[sbufferIndex3+1] = vv2;\n                    sbuffer3[sbufferIndex3+2] = vv3;\n                    sbufferIndex3 += 3;\n                } else {\n\n                    //crete new vertices in the midle of edges\n                    p4 = [(p1[0]+p2[0])*0.5, (p1[1]+p2[1])*0.5, (p1[2]+p2[2])*0.5];\n                    p5 = [(p2[0]+p3[0])*0.5, (p2[1]+p3[1])*0.5, (p2[2]+p3[2])*0.5];\n                    p6 = [(p3[0]+p1[0])*0.5, (p3[1]+p1[1])*0.5, (p3[2]+p1[2])*0.5];\n\n                    //convert coords back to long lat\n                    p4 = proj.inverse(p4); p4[2] = (vertices[v1*3+2]+vertices[v2*3+2])*0.5;\n                    p5 = proj.inverse(p5); p5[2] = (vertices[v2*3+2]+vertices[v3*3+2])*0.5;\n                    p6 = proj.inverse(p6); p6[2] = (vertices[v3*3+2]+vertices[v1*3+2])*0.5;\n\n                    var mm = m * 3;\n\n                    /*if (false) {\n\n                        //add new vertices to the buffer\n                        vbuffer[mm] = p4[0];\n                        vbuffer[mm+1] = p4[1];\n                        vbuffer[mm+2] = p4[2];\n\n                        vbuffer[mm+3] = p5[0];\n                        vbuffer[mm+4] = p5[1];\n                        vbuffer[mm+5] = p5[2];\n\n                        vbuffer[mm+6] = p6[0];\n                        vbuffer[mm+7] = p6[1];\n                        vbuffer[mm+8] = p6[2];\n\n                        //create new edges\n                        if (edge1) {\n                            edge1[0] = [[edge1[0]], [k]];\n                            edge1 = edge1[0];\n                        }\n\n                        if (edge2) {\n                            edge2[0] = [[edge2[0]], [k+1]];\n                            edge2 = edge2[0];\n                        }\n\n                        if (edge3) {\n                            edge3[0] = [[edge3[0]], [k+2]];\n                            edge3 = edge3[0];\n                        }\n\n                        l = sbufferIndex2;\n\n                        //store new faces with edges\n                        sbuffer2[l] = [vv1, edge1 ? edge1[0] : null];\n                        sbuffer2[l+1] = [m, null];\n                        sbuffer2[l+2] = [m + 2, edge3 ? edge3[1] : null];\n\n                        sbuffer2[l+3] = [m, edge1 ? edge1[1] : null];\n                        sbuffer2[l+4] = [vv2, edge2 ? edge2[0] : null];\n                        sbuffer2[l+5] = [m + 1, null];\n\n                        sbuffer2[l+6] = [m + 2, null];\n                        sbuffer2[l+7] = [m + 1, edge2 ? edge2[1] : null];\n                        sbuffer2[l+8] = [vv3, edge3 ? edge3[0] : null];\n\n                        sbuffer2[l+9] = [m + 2, null];\n                        sbuffer2[l+10] = [m, null];\n                        sbuffer2[l+11] = [m + 1, null];\n\n                        m += 3;\n                        sbufferIndex2 += 12;\n                    } else {*/\n\n                        if (l1 == l) {\n                            //console.log('l1');\n\n                            //add new vertices to the buffer\n                            vbuffer[mm] = p4[0];\n                            vbuffer[mm+1] = p4[1];\n                            vbuffer[mm+2] = p4[2];\n\n                            //create new edges\n                            if (edge1) {\n                                edge1[0] = [[edge1[0]], [-m]];\n                                edge1 = edge1[0];\n                            }\n\n                            l = sbufferIndex2;\n\n                            //store new faces with edges\n                            sbuffer2[l] = [vv1, edge1 ? edge1[0] : null];\n                            sbuffer2[l+1] = [m, null];\n                            sbuffer2[l+2] = [vv3, edge3 ? edge3 : null];\n                            /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);\n                            console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + \n                                       ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +\n                                       ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/\n\n\n                            sbuffer2[l+3] = [m, edge1 ? edge1[1] : null];\n                            sbuffer2[l+4] = [vv2, edge2 ? edge2 : null];\n                            sbuffer2[l+5] = [vv3, null];\n                            /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);\n                            console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + \n                                       ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +\n                                       ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/\n\n                        } else if (l2 == l) {\n                            //console.log('l2');\n\n                            //add new vertices to the buffer\n                            vbuffer[mm] = p5[0];\n                            vbuffer[mm+1] = p5[1];\n                            vbuffer[mm+2] = p5[2];\n\n                            //create new edges\n                            if (edge2) {\n                                edge2[0] = [[edge2[0]], [-m]];\n                                edge2 = edge2[0];\n                            }\n\n                            l = sbufferIndex2;\n\n                            //store new faces with edges\n                            sbuffer2[l] = [vv1, edge1 ? edge1 : null];\n                            sbuffer2[l+1] = [vv2, edge2 ? edge2[0] : null];\n                            sbuffer2[l+2] = [m, null];\n                            /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);\n                            console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + \n                                       ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +\n                                       ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/\n\n                            sbuffer2[l+3] = [m, edge2 ? edge2[1] : null];\n                            sbuffer2[l+4] = [vv3, edge3 ? edge3 : null];\n                            sbuffer2[l+5] = [vv1, null];\n                            /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);\n                            console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + \n                                       ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +\n                                       ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/\n\n                        } else if (l3 == l) {\n                            //console.log('l3');\n\n                            //add new vertices to the buffer\n                            vbuffer[mm] = p6[0];\n                            vbuffer[mm+1] = p6[1];\n                            vbuffer[mm+2] = p6[2];\n\n                            //create new edges\n                            if (edge3) {\n                                edge3[0] = [[edge3[0]], [-m]];\n                                edge3 = edge3[0];\n                            }\n\n                            l = sbufferIndex2;\n\n                            //store new faces with edges\n                            sbuffer2[l] = [vv1, edge1 ? edge1 : null];\n                            sbuffer2[l+1] = [vv2, null];\n                            sbuffer2[l+2] = [m, edge3 ? edge3[1] : null];\n                            /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);\n                            console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + \n                                       ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +\n                                       ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/\n\n                            sbuffer2[l+3] = [m, null]; \n                            sbuffer2[l+4] =  [vv2, edge2 ? edge2 : null]; \n                            sbuffer2[l+5] = [vv3, edge3 ? edge3[0] : null];\n                            /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);\n                            console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + \n                                       ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +\n                                       ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/\n\n                        }\n    \n                        m += 1;\n                        sbufferIndex2 += 6;\n                    //}\n\n                }\n            }\n\n            var tmp = sbuffer;\n            sbuffer = sbuffer2;\n            sbuffer2 = tmp;\n            sbufferIndex = sbufferIndex2;\n            sbufferIndex2 = 0;\n\n            //if (sbufferIndex3 > 1000) {\n                //break;\n            //}\n\n            depth++;\n\n            //if (depth == 2) {\n                //maxFaceLength = Number.POSITIVE_INFINITY;\n            //}\n\n\n        } while(sbufferIndex > 0);\n\n        maxFaceLength = lastMaxFaceLength;\n\n    }\n\n\n    //loop faces\n        //call subdivide face\n\n    var ebuffer = new Array(65536*3), ebufferIndex = 0;\n\n    var unrollBorder = (function(borderArray) {\n        for (var o = 0, lo = borderArray.length; o < lo; o++) {\n            if (Array.isArray(borderArray[o])) {\n                unrollBorder(borderArray[o]);\n            } else {\n                ebuffer[ebufferIndex] = borderArray[o];\n                ebufferIndex++;\n            }\n        }\n    });\n\n    var lastEbufferIndex = 0;\n\n    //unroll edges\n    for (i = 0, li = borders2.length; i < li; i++) {\n        unrollBorder(borders2[i]);\n        borders2[i] = ebuffer.slice(lastEbufferIndex, ebufferIndex);\n        lastEbufferIndex = ebufferIndex;\n    }\n\n    surface = new Array(sbufferIndex);\n\n    for (i = 0, li = sbufferIndex3; i < li; i+=3) {\n        surface[i] = sbuffer3[i];\n        surface[i+1] = sbuffer3[i+1];\n        surface[i+2] = sbuffer3[i+2];\n    }\n\n    vertices = new Array(m * 3);\n    j = 0;\n\n    for (i = 0, li = m*3; i < li; i+=3) {\n        vertices[i] = vbuffer[i];\n        vertices[i+1] = vbuffer[i+1];\n        vertices[i+2] = vbuffer[i+2];\n        //this.addPoint([vertices[i], vertices[i+1], vertices[i+2]], 'fix', {name:(''+j)}, 'aaa');\n        j++;\n    }\n\n    this.addPolygonRAW(vertices, surface, borders2, middle, heightMode, properties, id, srs);\n};\n\n\n\nMapGeodataBuilder.prototype.addTerrainPolygon = function(shape, holes, middle, density, heightMode, properties, id, srs) {\n\n    //https://github.com/substack/point-in-polygon\n\n    /*\n    function insidePolygon (point, vs) {\n        // ray-casting algorithm based on\n        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n        \n        var x = point[0], y = point[1];\n        \n        var inside = false;\n        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n            var xi = vs[i][0], yi = vs[i][1];\n            var xj = vs[j][0], yj = vs[j][1];\n            \n            var intersect = ((yi > y) != (yj > y))\n                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n            if (intersect) inside = !inside;\n        }\n        \n        return inside;\n    };*/    \n\n    /*\n        function rad2degr(rad) { return rad * 180 / Math.PI; }\n        function degr2rad(degr) { return degr * Math.PI / 180; }\n\n        function getLatLngCenter(latLngInDegr) {\n            var LATIDX = 0;\n            var LNGIDX = 1;\n            var sumX = 0;\n            var sumY = 0;\n            var sumZ = 0;\n\n            for (var i=0; i<latLngInDegr.length; i++) {\n                var lat = degr2rad(latLngInDegr[i][LATIDX]);\n                var lng = degr2rad(latLngInDegr[i][LNGIDX]);\n                // sum of cartesian coordinates\n                sumX += Math.cos(lat) * Math.cos(lng);\n                sumY += Math.cos(lat) * Math.sin(lng);\n                sumZ += Math.sin(lat);\n            }\n\n            var avgX = sumX / latLngInDegr.length;\n            var avgY = sumY / latLngInDegr.length;\n            var avgZ = sumZ / latLngInDegr.length;\n\n            // convert average x, y, z coordinate to latitude and longtitude\n            var lng = Math.atan2(avgY, avgX);\n            var hyp = Math.sqrt(avgX * avgX + avgY * avgY);\n            var lat = Math.atan2(avgZ, hyp);\n\n            return ([rad2degr(lat), rad2degr(lng)]);\n        }\n    */\n\n    //get center of polygon\n\n    //detect Math.abs(Math.abs(lon)-180) < 0.001\n       // if true then add 360 to negative lon values\n\n    //construct merc projection with +lat_ts == polygon_center_lat\n\n    //convert vertices to merc flat space\n      //get polygon extents in merc projection\n\n    //divide merc extents in to the grid\n      // test each grid point is is polygon and not in hole\n\n};\n\nMapGeodataBuilder.prototype.addPolygonRAW = function(vertices, surface, borders, middle, heightMode, properties, id, srs, directCopy) {\n    if (!this.currentGroup) {\n        this.addGroup('some-group');\n    }\n\n    var floatHeight = (!heightMode || heightMode == \"float\");\n    var i, li, j = 0, coords;\n    srs = srs ? srs : this.navSrs;\n\n    var feature = {\n        id : id,\n        properties : properties\n    };\n\n    var featureVertices = new Array(Math.round(vertices.length/3));\n\n    if (floatHeight) {\n        for (i = 0, li = vertices.length; i < li; i+=3) {\n            coords = [vertices[i], vertices[i+1], vertices[i+2], feature, null, null];\n            this.addToHeightsBuffer(coords);\n            featureVertices[j++] = coords;\n        }\n\n        feature.floatHeights = true;\n        feature.srs = srs;\n        feature.heightsToProcess = featureVertices.length;\n        this.heightsToProcess += featureVertices.length;\n    } else {\n\n        for (i = 0, li = vertices.length; i < li; i+=3) {\n            coords = [vertices[i], vertices[i+1], vertices[i+2]];\n\n            if (directCopy) {\n                featureVertices[j++] = coords;\n            } else {\n                featureVertices[j++] = this.physSrs.convertCoordsFrom(coords, srs);\n            }\n        }\n    }\n\n    var featureSurface = surface.slice();\n    var featureBorders = new Array(borders.length);\n\n    for (i = 0, li = borders.length; i < li; i++) {\n        featureBorders[i] = borders[i].slice();\n    }\n\n    feature.vertices = featureVertices;\n    feature.surface = featureSurface;\n    feature.borders = featureBorders;\n    this.currentGroup.polygons.push(feature);\n\n    return this;\n};\n\n\nMapGeodataBuilder.prototype.importVTSGeodata = function(json, groupIdPrefix, dontCreateGroups) {\n    var importer = new MapGeodataImportVTSGeodata(this, groupIdPrefix, dontCreateGroups);\n    return importer.processJSON(json);\n};\n\n\nMapGeodataBuilder.prototype.importGeoJson = function(json, heightMode, srs, groupIdPrefix, dontCreateGroups) {\n    var importer = new MapGeodataImportGeoJSON(this, heightMode, srs, groupIdPrefix, dontCreateGroups);\n    return importer.processJSON(json);\n};\n\n\nMapGeodataBuilder.prototype.processHeights = function(heightsSource, precision, onProcessed) {\n    if (this.heightsToProcess <= 0) {\n        if (onProcessed) {\n            onProcessed(this);\n        }\n\n        return;\n    }\n\n    if (this.processingHeights) {\n        this.processHeightsCalls.push(this.processHeights.bind(this, heightsSource, precision));\n    }\n\n    this.processingHeights = true;\n    this.heightsSource = heightsSource;\n    this.heightsLod = precision;\n\n    var item = this.heightsProcessBufferFirst, lastItem;\n    //var item = this.heightsProcessBuffer, lastItem;\n    var p, res, nodeOnly, heightsLod, nodeOnly, coords;\n\n    switch (heightsSource) {\n        case \"node-by-precision\":\n            nodeOnly = true;\n        case \"heightmap-by-precision\":\n\n            coords = item.coords;\n\n            if (coords[3].srs) {\n                p = this.navSrs.convertCoordsFrom(coords, coords[3].srs);\n            } else {\n                p = coords;\n            }\n\n            heightsLod = this.map.measure.getOptimalHeightLodBySampleSize(p, precision);\n            break;\n\n        case \"node-by-lod\":\n            nodeOnly = true;\n        case \"heightmap-by-lod\":\n            heightsLod = precision;\n            break;\n    }\n\n    do {\n        coords = item.coords;\n\n        if (coords[4] == null) {\n            if (coords[3].srs) {\n                p = this.navSrs.convertCoordsFrom(coords, coords[3].srs);\n            } else {\n                p = coords;\n            }\n\n            res = this.map.measure.getSpatialDivisionNode(p);\n\n            coords[4] = res[0];\n            coords[5] = res[1];\n\n            //coords[4] = p;\n        }\n\n        res = this.map.measure.getSurfaceHeight(coords, heightsLod, null, coords[4], coords[5], null, nodeOnly);\n        //res = this.map.measure.getSurfaceHeight(coords[4], heightsLod, null, null, null, null, nodeOnly);\n\n        //console.log(JSON.stringify(res));\n\n        //if (res[1] || res[2]) { //precisin reached or not aviable\n            //res = this.map.measure.getSurfaceHeight(coords[4], heightsLod, null, null, null, null, nodeOnly);\n            //res = this.map.measure.getSurfaceHeight(coords, heightsLod, null, coords[4], coords[5], null, nodeOnly);\n        //}\n\n        if (res[1] || res[2]) { //precision reached or not aviable\n\n            //console.log(JSON.stringify(res));\n\n            coords[2] += res[0]; //convet float height to fixed\n            this.removeFromHeightsBuffer(item, lastItem);\n            coords[3].heightsToProcess--;\n            this.heightsToProcess--;\n\n            if (coords[3].heightsToProcess <= 0) { //this prevents multiple conversions\n                coords[3].floatHeights = false;\n            }\n\n            p = [coords[0], coords[1], coords[2]];\n\n            //console.log(JSON.stringify(p) + \"  srs  \" + coords[3].srs);\n\n            p = this.physSrs.convertCoordsFrom(p, coords[3].srs);\n\n            coords[0] = p[0];\n            coords[1] = p[1];\n            coords[2] = p[2];\n        }\n\n        lastItem = item;\n        item = item.next;\n\n    } while(item);\n\n    if (this.heightsToProcess <= 0) {\n        if (this.updateCallback) {\n            this.updateCallback(); //remove callback\n        }\n\n        this.processingHeights = false;\n\n        if (onProcessed) {\n            onProcessed(this);\n        }\n\n        if (this.processHeightsCalls.length > 1) {\n            (this.processHeightsCalls.shift())();\n        }\n\n    } else {\n        if (!this.updateCallback) {\n            this.updateCallback = this.map.core.on(\"map-update\", this.processHeights.bind(this, this.heightsSource, this.heightsLod, onProcessed));\n        }\n    }\n\n};\n\nMapGeodataBuilder.prototype.extractGeometry = function(id) {\n    var feature, i, li, j, lj, points, lines,\n        vertexBuffer, indexBuffer, index, p;\n\n\n    for (var i = 0, li = this.groups.length; i < li; i++) {\n        var group = this.groups[i];\n\n        var groupPoints = group.points;\n        var groupLines = group.lines;\n        var groupPolygons = group.polygons, j, lj;\n\n        //get group bbox\n        for (j = 0, lj = groupPoints.length; j < lj; j++) {\n            if (groupPoints[j].id == id) {\n                feature = groupPoints[j];\n            }\n        }\n\n        for (j = 0, lj = groupLines.length; j < lj; j++) {\n            if (groupLines[j].id == id) {\n                feature = groupLines[j];\n            }\n        }\n\n        for (j = 0, lj = groupPolygons.length; j < lj; j++) {\n            if (groupPolygons[j].id == id) {\n                feature = groupPolygons[j];\n            }\n        }\n    }\n\n    if (feature) {\n        if (feature.points) {\n\n            points = feature.points;\n\n            if (points.length > 0) {\n                vertexBuffer = new Float64Array(points.length * 3);\n\n                for (i = 0, li = points.length; i < li; i++) {\n                    index = i * 3;\n                    p = points[i];\n                    vertexBuffer[index] = p[0];\n                    vertexBuffer[index+1] = p[1];\n                    vertexBuffer[index+2] = p[2];\n                }\n            }\n\n            return new MapGeodataGeometry(this.map, {'type': 'point-geometry', 'id':feature.id, 'geometryBuffer': vertexBuffer });\n\n        } else if (feature.lines) {\n\n            lines = feature.lines;\n\n            if (lines.length > 0) {\n                \n                var totalPoints = 0;\n\n                for (i = 0, li = lines.length; i < li; i++) {\n                    totalPoints += lines[i].length;\n                }\n\n                vertexBuffer = new Float64Array(totalPoints * 3);\n                indexBuffer = new Uint32Array(li);\n                index = 0;\n\n                for (i = 0, li = lines.length; i < li; i++) {\n\n                    var points = lines[i];\n\n                    for (j = 0, lj = points.length; j < lj; j++) {\n                        p = points[j];\n                        vertexBuffer[index] = p[0];\n                        vertexBuffer[index+1] = p[1];\n                        vertexBuffer[index+2] = p[2];\n                        index += 3;\n                    }\n                }\n            }\n\n            return new MapGeodataGeometry(this.map, {'type': 'line-geometry', 'id':feature.id, 'geometryBuffer': vertexBuffer, 'indicesBuffer': indexBuffer });\n        } else if (feature.vertices) {\n\n            /*feature.vertices = featureVertices;\n            feature.surface = featureSurface;\n            feature.borders = featureBorders;*/\n\n            return new MapGeodataGeometry(this.map, {'type': 'polygon-geometry', 'id':feature.id, 'geometryBuffer': feature.vertices, 'surface': feature.surface });\n        }\n\n        return;\n    }\n\n};\n\n\nMapGeodataBuilder.prototype.compileGroup = function(group, resolution) {\n    var bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n    var bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n    var geodataGroup = {};\n    var groupPoints = group.points, points, p, feature, finalFeature;\n    var groupLines = group.lines, lines, line, i, li, j, lj, k, lk;\n    var groupPolygons = group.polygons, borders;\n\n    geodataGroup.id = group.id;\n\n    //get group bbox\n    for (i = 0, li = groupPoints.length; i < li; i++) {\n        points = groupPoints[i].points;\n\n        for (j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n\n            if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }\n            if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }\n            if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }\n\n            if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }\n            if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }\n            if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }\n        }\n    }\n\n    for (i = 0, li = groupLines.length; i < li; i++) {\n        lines = groupLines[i].lines;\n\n        for (j = 0, lj = lines.length; j < lj; j++) {\n            line = lines[j];\n\n            for (k = 0, lk = line.length; k < lk; k++) {\n                p = line[k];\n\n                if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }\n                if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }\n                if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }\n\n                if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }\n                if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }\n                if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }\n            }\n        }\n    }\n\n    for (i = 0, li = groupPolygons.length; i < li; i++) {\n        points = groupPolygons[i].vertices;\n\n        for (j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n\n            if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }\n            if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }\n            if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }\n\n            if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }\n            if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }\n            if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }\n        }\n    }\n\n    if (!resolution) {\n        var maxDelta = Math.max((bboxMax[0] - bboxMin[0]) + 1, (bboxMax[1] - bboxMin[1]) + 1, (bboxMax[2] - bboxMin[2]) + 1);\n\n        //25cm resolution\n        resolution = maxDelta / 0.25;\n        resolution = Math.max(resolution, 1024);\n        resolution = Math.min(resolution, (2<<20));\n    }\n\n    geodataGroup.resolution = resolution;\n\n    //process coords to resolution\n    var bboxScaleFactor = [resolution/((bboxMax[0] - bboxMin[0]) + 1),\n                           resolution/((bboxMax[1] - bboxMin[1]) + 1),\n                           resolution/((bboxMax[2] - bboxMin[2]) + 1)];\n\n    geodataGroup.points = new Array(groupPoints.length);\n\n    for (i = 0, li = groupPoints.length; i < li; i++) {\n        feature = groupPoints[i]; \n        points = feature.points;\n\n        var finalPoints = new Array(points.length);\n\n        for (j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n\n            finalPoints[j] = [ Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]),\n                               Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]),\n                               Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]) ];\n        }\n\n        finalFeature = {\n            points : finalPoints\n        };\n\n        if (feature.id) {\n            finalFeature.id = feature.id;\n        }\n\n        if (feature.properties) {\n            finalFeature.properties = feature.properties;\n        }\n\n        geodataGroup.points[i] = finalFeature;\n    }\n\n    geodataGroup.lines = new Array(groupLines.length);\n\n    for (i = 0, li = groupLines.length; i < li; i++) {\n        feature = groupLines[i]; \n        lines = feature.lines;\n\n        var finalLines = new Array(lines.length);\n\n        for (j = 0, lj = lines.length; j < lj; j++) {\n            line = lines[j];\n\n            finalPoints = new Array(line.length);\n\n            for (k = 0, lk = line.length; k < lk; k++) {\n                p = line[k];\n\n                finalPoints[k] = [ Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]),\n                                   Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]),\n                                   Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]) ];\n            }\n\n            finalLines[j] = finalPoints;\n        }\n\n        finalFeature = {\n            lines : finalLines\n        };\n\n        if (feature.id) {\n            finalFeature.id = feature.id;\n        }\n\n        if (feature.properties) {\n            finalFeature.properties = feature.properties;\n        }\n\n        geodataGroup.lines[i] = finalFeature;\n    }\n\n\n    geodataGroup.polygons = new Array(groupPolygons.length);\n\n    for (i = 0, li = groupPolygons.length; i < li; i++) {\n        feature = groupPolygons[i]; \n        points = feature.vertices;\n\n        var finalVertices = new Array(points.length);\n        k = 0;\n\n        for (j = 0, lj = points.length; j < lj; j++) {\n            p = points[j];\n            finalVertices[k++] = Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]);\n            finalVertices[k++] = Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]);\n            finalVertices[k++] = Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]);\n        }\n\n        finalFeature = {\n            vertices : finalVertices,\n            surface : feature.surface.slice()\n        };\n\n        borders = feature.borders;\n        var finalBorders = new Array(borders.length);\n\n        for (j = 0, lj = finalBorders.length; j < lj; j++) {\n            finalBorders[j] = borders[j].slice();\n        }\n\n        finalFeature.borders = finalBorders;\n\n        if (feature.id) {\n            finalFeature.id = feature.id;\n        }\n\n        if (feature.properties) {\n            finalFeature.properties = feature.properties;\n        }\n\n        geodataGroup.polygons[i] = finalFeature;\n    }\n\n    geodataGroup.bbox = [ bboxMin, bboxMax ];\n\n    if (bboxMax[0] > this.bboxMax[0]) { this.bboxMax[0] = bboxMax[0]; }\n    if (bboxMax[1] > this.bboxMax[1]) { this.bboxMax[1] = bboxMax[1]; }\n    if (bboxMax[2] > this.bboxMax[2]) { this.bboxMax[2] = bboxMax[2]; }\n\n    if (bboxMin[0] < this.bboxMin[0]) { this.bboxMin[0] = bboxMin[0]; }\n    if (bboxMin[1] < this.bboxMin[1]) { this.bboxMin[1] = bboxMin[1]; }\n    if (bboxMin[2] < this.bboxMin[2]) { this.bboxMin[2] = bboxMin[2]; }\n\n    return geodataGroup;\n};\n\n\nMapGeodataBuilder.prototype.makeGeodata = function(resolution) {\n    this.bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n    this.bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n\n    var geodata = {\n        \"version\" : 1,\n        \"groups\" : []\n    }\n\n    for (var i = 0, li = this.groups.length; i < li; i++) {\n        geodata[\"groups\"].push(this.compileGroup(this.groups[i], resolution));\n    }\n\n    return geodata;\n};\n\n\nMapGeodataBuilder.prototype.makeFreeLayer = function(style, resolution) {\n    var geodata = this.makeGeodata(resolution);\n\n    if (!style) {\n        style = {\n            \"layers\" : {\n                \"my-lines\" : {\n                    \"filter\" : [\"==\", \"#type\", \"line\"],\n                    \"line\": true,\n                    \"line-width\" : 4,\n                    \"line-color\": [255,0,255,255],\n                    \"zbuffer-offset\" : [-5,0,0]\n                },\n                \"my-points\" : {\n                    \"filter\" : [\"==\", \"#type\", \"point\"],\n                    \"point\": true,\n                    \"point-radius\" : 10,\n                    \"point-color\": [0,0,255,255],\n                    \"zbuffer-offset\" : [-5,0,0]\n                }\n            }\n        }        \n    }\n\n    var freeLayer = {\n            'credits' : [],\n            'displaySize' : 1024,\n            'extents' : {\n                'll' : this.bboxMin,\n                'ur' : this.bboxMax\n            },\n            'geodata' : geodata,\n            'style' : style,\n            'type' : 'geodata'\n        };\n\n    return freeLayer;        \n};\n\nexport default MapGeodataBuilder;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-builder.js\n// module id = 133\n// module chunks = 0 1","\nimport {vec3 as vec3_} from '../utils/matrix';\n/*import {math as math_} from '../utils/math';*/\n\n//get rid of compiler mess\nvar vec3 = vec3_;\n/*var math = math_;*/\n\n\nvar MapGeodataGeometry = function(map, data) {\n    this.map = map;\n    this.data = data;\n    this.camera = map.camera;\n    this.renderer = map.renderer;\n\n    switch (data.type) {\n        case 'point-geometry':   \n            this.type = 1;\n            this.vertexBuffer = this.data.geometryBuffer;\n            break;\n        case 'line-geometry':\n            this.type = 2;\n            this.vertexBuffer = this.data.geometryBuffer;\n            this.indicesBuffer = this.data.indicesBuffer;\n            break;\n        case 'polygon-geometry':\n            this.type = 3;\n            this.vertexBuffer = this.data.geometryBuffer;\n            this.surface = this.data.surface;\n            this.borders = this.data.borders;\n            break;\n    }\n};\n\nMapGeodataGeometry.prototype.getType = function() {\n    switch(this.type) {\n        case 1: return 'point';\n        case 2: return 'line';\n        case 3: return 'polygon';\n    }\n};\n\nMapGeodataGeometry.prototype.getElement = function(index) {\n    var v = this.vertexBuffer, i = index * 3;\n    switch(this.type) {\n        case 1: return [v[i], v[i+1], v[i+2]]; //point\n        case 2: return [[v[i], v[i+1], v[i+2]],  [v[i+3], v[i+4], v[i+5]]]; //line\n        case 3: \n            var s = this.surface;\n            var i1 = s[i], i2 = s[i+1], i3 = s[i+2];\n            return [[v[i1][0], v[i1][1], v[i1][2]],  [v[i2][0], v[i2][1], v[i2][2]],  [v[i3][0], v[i3][1], v[i3][2]]]; //polygon\n    }\n};\n\nMapGeodataGeometry.prototype.getElements = function(pathIndex) {\n    switch(this.type) {\n        case 1: //point\n        case 3: return this.surface.length / 3; //polygon\n        case 2:  //line\n            \n            pathIndex = pathIndex || 0;\n            var si = (this.indicesBuffer[pathIndex]) * 3;\n            var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n            return Math.max(0, ((ei - si) / 3) - 1);\n    }\n};\n\nMapGeodataGeometry.prototype.getRelationToCanvasPoint = function(index, screenX, screenY) {\n    var v = this.vertexBuffer, i = index * 3;\n    var c1, cv, p, r = [0,0,0];\n    var a, b, c, d, e, D, sc, tc, u, v, w;\n\n    c1 = this.camera.position;\n    //cv = this.camera.vector;\n\n    cv = this.renderer.getScreenRay(screenX, screenY);\n\n    //console.log(JSON.stringify(c1) + \"  \" + JSON.stringify(cv));\n\n    switch(this.type) {\n        case 1: \n\n            //get point\n            var p = [v[i], v[i+1], v[i+2]];\n\n            var cp = [p[0] - c[0], p[0] - c[0],]\n\n            //distance = vec3.coss(ray.direction, point - ray.origin).magnitude;\n            vec3.cross(cv, cp, r)\n            d = vec3.length(p);\n\n            return {\n                'distance' : d,\n                'point' : p\n            }\n\n        case 2: \n\n            //line points\n            var p1 = [v[i], v[i+1], v[i+2]];\n            var p2 = [v[i+3], v[i+4], v[i+5]]; \n\n            //distance = http://geomalgorithms.com/a07-_distance.html\n\n            u = cv;\n            v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            w = [c1[0] - p1[0], c1[1] - p1[1], c1[2] - p1[2]];\n            a = vec3.dot(u,u);    // always >= 0\n            b = vec3.dot(u,v);\n            c = vec3.dot(v,v);    // always >= 0\n            d = vec3.dot(u,w);\n            e = vec3.dot(v,w);\n            D = a*c - b*b;        // always >= 0\n\n            // compute the line parameters of the two closest points\n            if (D < 0.0000001) {          // the lines are almost parallel\n                sc = 0.0;\n                tc = (b>c ? d/b : e/c);    // use the largest denominator\n            }\n            else {\n                sc = (b*e - c*d) / D;\n                tc = (a*e - b*d) / D;\n            }\n\n            // get the difference of the two closest points\n            var dP = [ w[0] + (u[0] * sc) - (v[0] * tc),\n                       w[1] + (u[1] * sc) - (v[1] * tc),\n                       w[2] + (u[2] * sc) - (v[2] * tc) ];\n\n            return {\n                'closest' : [ p1[0] + (v[0] * tc), p1[1] + (v[1] * tc), p1[2] + (v[2] * tc) ],\n                'line-distance' : vec3.length(dP),\n                'distance' : tc,\n                'line' : [p1, p2]\n            }\n    }\n};\n\nMapGeodataGeometry.prototype.getPathElement = function(index, pathIndex) {\n    if (this.type != 2) {\n        return null;\n    }\n\n    var i = (this.indicesBuffer[pathIndex || 0] + index) * 3, v = this.vertexBuffer;\n    return [[v[i], v[i+1], v[i+2]],  [v[i+3], v[i+4], v[i+5]]];\n};\n\nMapGeodataGeometry.prototype.getPathPoint = function(distance, pathIndex) {\n    pathIndex = pathIndex || 0;\n\n    var si = (this.indicesBuffer[pathIndex]) * 3;\n    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n    var totalLength = 0, delta, length, v = this.vertexBuffer;\n\n    for (var i = si; i < (ei-3); i+=3) {\n        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];\n        length = vec3.length(delta);\n\n        if (totalLength + length > distance) {\n            var factor =  (distance - totalLength) / length;\n            return [v[i] + delta[0] * factor, v[i+1] + delta[1] * factor, v[i+2] + delta[2] * factor];\n        }\n\n        totalLength += length;    \n    }\n\n    return [v[ei-3], v[ei-2], v[ei-1]];\n};\n\nMapGeodataGeometry.prototype.getPathNED = function(distance, withoutSlope, pathIndex) {\n    pathIndex = pathIndex || 0;\n\n    var si = (this.indicesBuffer[pathIndex]) * 3;\n    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n    var totalLength = 0, p, delta, length, v = this.vertexBuffer;\n\n    for (var i = si; i < (ei-5); i+=3) {\n        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];\n        length = vec3.length(delta);\n\n        if (totalLength + length > distance) {\n            var factor = (totalLength + length) / distance;\n            p = [v[i] + d[0] * factor, v[i+1] + d[1] * factor, v[i+2] + d[2] * factor];\n            break;\n        }\n\n        totalLength += length;    \n    }\n\n    if (!p) {\n        p = [v[ei-3], v[ei-2], v[ei-1]];\n    }\n\n    var vv = [0, 0, 0];\n    var nn = [0, 0, 0];\n    var pp = [0, 0, 0];\n\n    vec3.nomalize(delta, vv);\n    vec3.nomalize(p, pp);\n    vec3.cross(pp, vv, nn);    \n\n    if (withoutSlope) {\n        vec3.cross(pp, nn, vv);    \n    }\n\n    var east = nn;\n    var direction = vv;\n    var north = pp;\n\n    return {\n        'east'  : east, \n        'direction' : direction,\n        'north' : north,\n        'position' : p,\n        'matrix' : [\n            east[0], east[1], east[2], 0,\n            north[0], north[1], north[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            0, 0, 0, 1\n        ] \n    };    \n};\n\n\nMapGeodataGeometry.prototype.getPathLengthToElement = function(index, pathIndex) {\n    pathIndex = pathIndex || 0;\n\n    var si = (this.indicesBuffer[pathIndex]) * 3;\n    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n    var totalLength = 0, delta, length, v = this.vertexBuffer, elementIndex = 0;\n\n    for (var i = si; i < (ei-5); i+=3) {\n        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];\n        length = vec3.length(delta);\n\n        if (index == elementIndex) {\n            return {\n                'lengthToElement' : totalLength,\n                'elementLengh' : length\n            }\n        }\n\n        elementIndex++\n        totalLength += length;\n    }\n\n    return totalLength;\n};\n\n\nMapGeodataGeometry.prototype.getPathLength = function(pathIndex) {\n    pathIndex = pathIndex || 0;\n\n    var si = (this.indicesBuffer[pathIndex]) * 3;\n    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);\n\n    var totalLength = 0, delta, length, v = this.vertexBuffer;\n\n    for (var i = si; i < (ei-5); i+=3) {\n        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];\n        length = vec3.length(delta);\n\n        totalLength += length;\n    }\n\n    return totalLength;\n};\n\n\nMapGeodataGeometry.prototype.getPathsCount = function() {\n    if (this.type != 2) {\n        return 0;\n    }\n\n    return this.indicesBuffer.length;\n};\n\n\nMapGeodataGeometry.prototype.getSurfaceArea = function() {\n    if (this.type != 3) {\n        return 0;\n    }\n\n    if (!this.surfaceArea) {\n        var v = this.vertexBuffer, s = this.surface;\n        var p1, p2, p3, l1, l2, l3, dx, dy, dz, perimeter, area;\n\n        this.surfaceArea = 0;\n        for (var i = 0, li = s.length; i < li; i+= 3) {\n            p1 = v[s[i]];\n            p2 = v[s[i+1]];\n            p3 = v[s[i+2]];\n\n            dx = p2[0] - p1[0];\n            dy = p2[1] - p1[1];\n            dz = p2[2] - p1[2];\n            l1 = Math.sqrt(dx*dx + dy*dy + dz*dz); \n\n            dx = p2[0] - p3[0];\n            dy = p2[1] - p3[1];\n            dz = p2[2] - p3[2];\n            l2 = Math.sqrt(dx*dx + dy*dy + dz*dz); \n\n            dx = p3[0] - p1[0];\n            dy = p3[1] - p1[1];\n            dz = p3[2] - p1[2];\n            l3 = Math.sqrt(dx*dx + dy*dy + dz*dz); \n\n            //Heron's formula\n            perimeter = (l1 + l2 + l3)/2;\n            area =  Math.sqrt(perimeter*((perimeter-l1)*(perimeter-l2)*(perimeter-l3)));\n\n            this.surfaceArea += area;\n        }\n    }\n\n    return this.surfaceArea;\n};\n\nexport default MapGeodataGeometry;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-geometry.js\n// module id = 134\n// module chunks = 0 1","\nvar MapGeodataImportGeoJSON = function(builder, heightMode, srs, groupIdPrefix, dontCreateGroups) {\n    this.builder = builder;\n    this.map = builder.map;\n    this.heightMode = heightMode || 'float';\n    this.srs = srs;\n    this.groupIdPrefix = groupIdPrefix || '';\n    this.dontCreateGroups = dontCreateGroups;\n    //this.processJSON(json);\n};\n\nMapGeodataImportGeoJSON.prototype.processGeometry = function(geometry, feature) {\n    var coords = geometry['coordinates'];\n    if (!coords) {\n        return;\n    }\n\n    switch(geometry['type']) {\n        case 'Point':\n            this.builder.addPoint(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);\n            break;\n\n        case 'MultiPoint':\n            this.builder.addPointArray(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);\n            break;\n\n        case 'LineString':\n            this.builder.addLineString(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);\n            break;\n\n        case 'MultiLineString':\n            this.builder.addLineStringArray(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);\n            break;\n\n        case 'GeometryCollection':\n\n            var geometries = geometry['gemetries'];\n\n            if (geometries) {\n                for (var i = 0, li = geometries.length; i < li; i++) {\n                    this.processGeometry(geometries[i], feature);\n                }\n            }\n    }\n};\n\nMapGeodataImportGeoJSON.prototype.processFeature = function(json) {\n    var geometry = json['geometry'];\n\n    if (geometry) {\n        this.processGeometry(geometry, json);\n    }\n};\n\nMapGeodataImportGeoJSON.prototype.processCollection = function(json) {\n    var features = json['features'];\n\n    if (!features) {\n        return;\n    }\n\n    for (var i = 0, li = features.length; i < li; i++) {\n        this.processFeature(features[i]);\n    }\n};\n\nMapGeodataImportGeoJSON.prototype.processJSON = function(json) {\n    if (!json) {\n        return;\n    }\n\n    if (json['type']) {\n\n        switch (json['type']) {\n            case 'FeatureCollection':\n\n                if (!this.dontCreateGroups) {\n                    this.builder.addGroup(this.groupIdPrefix != '' ? this.groupIdPrefix : null);\n                }\n\n                this.processCollection(json);\n                break;\n            case 'Feature':\n\n                if (!this.dontCreateGroups) {\n                    this.builder.addGroup(this.groupIdPrefix != '' ? this.groupIdPrefix : null);\n                }\n\n                this.processFeature(json);\n                break;\n        }\n\n    } else {\n\n        for (var key in json) {\n            var item = json[key];\n\n            if (!this.dontCreateGroups) {\n                this.builder.addGroup(this.groupIdPrefix + key);\n            }\n\n            switch (json['type']) {\n                case 'FeatureCollection':\n                    this.processCollection(item);\n                    break;\n                case 'Feature':\n                    this.processFeature(item);\n                    break;\n            }\n        }\n    }\n\n};\n\nexport default MapGeodataImportGeoJSON;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-import/geojson.js\n// module id = 135\n// module chunks = 0 1","\nvar MapGeodataImportVTSGeodata = function(builder, groupIdPrefix, dontCreateGroups) {\n    this.builder = builder;\n    this.map = builder.map;\n    this.groupIdPrefix = groupIdPrefix || '';\n    this.dontCreateGroups = dontCreateGroups;\n    //this.processJSON(json);\n};\n\nMapGeodataImportVTSGeodata.prototype.processJSON = function(json) {\n    if (!json) {\n        return;\n    }\n\n    var groups = json['groups'], i, li, j, lj, k, lk, p;\n    var builder = this.builder, newPoints, points;\n\n    if (!groups) {\n        return;\n    }\n\n    for (i = 0, li = groups.length; i < li; i++) {\n        var group = groups[i];\n\n        var bbox = group['bbox'],\n            resolution = group['resolution'];\n\n        if (!bbox || !resolution) {\n            continue;\n        }\n\n        var bboxMin = bbox[0];\n        var bboxMax = bbox[1];\n\n        if (!bboxMin || !bboxMax) {\n            continue;\n        }\n\n        if (!this.dontCreateGroups) {\n            builder.addGroup(this.groupIdPrefix + (group['id'] || ''));\n        }\n\n        var fx = (bboxMax[0] - bboxMin[0]) / resolution;\n        var fy = (bboxMax[1] - bboxMin[1]) / resolution;\n        var fz = (bboxMax[2] - bboxMin[2]) / resolution;\n\n        //import group points\n        var pointsFeatures = group['points'];\n        if (pointsFeatures) {\n\n            points = pointsFeatures['points']\n\n            for (j = 0, lj = pointsFeatures.length; j < lj; j++) {\n                var point = pointsFeatures[j];\n                var subpoints = point['points'];\n                var newSubpoints = new Array(subpoints.length);\n\n                for (k = 0, lk = subpoints.length; k < lk; k++) {\n                    p = subpoints[k];\n                    newSubpoints[k] = [bboxMin[0] + p[0] * fx, bboxMin[1] + p[1] * fy, bboxMin[2] + p[2] * fz];\n                }\n\n                builder.addPointArray(newSubpoints, 'fix', point['properties'], point['id'], null, true);\n            }\n        }\n\n        //import group lines\n        var linesFeatures = group['lines'];\n        if (linesFeatures) {\n            for (j = 0, lj = linesFeatures.length; j < lj; j++) {\n                var line = linesFeatures[j];\n                var sublines = line['lines'];\n                var newSublines = new Array(sublines.length);\n\n                for (k = 0, lk = sublines.length; k < lk; k++) {\n\n                    points = sublines[k];\n                    newPoints = new Array(points.length);\n\n                    for (var l  = 0, ll = points.length; l < ll; l++) {\n                        p = points[l];\n                        newPoints[l] = [bboxMin[0] + p[0] * fx, bboxMin[1] + p[1] * fy, bboxMin[2] + p[2] * fz];\n                    }\n\n                    newSublines[k] = newPoints;\n                }\n\n                builder.addLineStringArray(newSublines, 'fix', line['properties'], line['id'], null, true);\n            }\n        }\n    }\n\n};\n\nexport default MapGeodataImportVTSGeodata;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-import/vts-geodata.js\n// module id = 136\n// module chunks = 0 1","\nvar MapGeodataProcessor = function(surface, listener) {\n    this.layer = surface;\n    this.map = surface.map;\n    this.renderer = this.map.renderer;\n    this.killed = false;\n    this.listener = listener;\n    this.busy = false;\n    this.ready = true;\n    this.waitingForStylesheet = false;\n    this.stylesheet = null;\n    this.fonts = {};\n    this.processCounter = 0;\n\n\n    // eslint-disable-next-line\n    var worker = require('worker-loader?inline&fallback=false!./worker-main');\n    //var worker = require('worker-loader?!./worker-main');\n\n    //debug worker\n    this.processWorker = new worker;\n    \n    this.processWorker.onerror = function(event){\n        throw new Error(event.message + ' (' + event.filename + ':' + event.lineno + ')');\n    };\n\n    this.processWorker.onmessage = this.onMessage.bind(this);\n};\n\n\nMapGeodataProcessor.prototype.kill = function() {\n    if (this.killed) {\n        return;\n    }\n\n    this.killed = true;\n\n    if (this.processWorker != null) {\n        this.processWorker.terminate();\n    }\n};\n\n\nMapGeodataProcessor.prototype.isReady = function() {\n    if (this.waitingForStylesheet) {\n        this.waitingForStylesheet = !(this.stylesheet.isReady());\n    }\n\n    return ((this.ready && !this.busy) || this.killed) && !this.waitingForStylesheet;\n};\n\n\nMapGeodataProcessor.prototype.onMessage = function(message) {\n    if (this.killed) {\n        return;\n    }\n\n    message = message.data;\n    \n    var command = message['command'];\n\n    //console.log('onmessage ' + command);\n\n    //if (typeof message === \"string\" && message == \"ready\") {\n    if (command == 'ready') {\n        this.ready = true;\n        //console.log(\"ready\");\n    } else if (command == 'styleDone') {\n        this.busy = false;\n    } else if (command == 'loadBitmaps') {\n        var bitmaps = message['bitmaps'];\n\n        for (var key in bitmaps) {\n            var bitmap = bitmaps[key];\n            this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false, bitmap['hash'], true);\n        }\n\n        message['command']        \n    }\n\n    if (this.listener != null) {\n        this.listener(command, message);\n    }\n};\n\n\nMapGeodataProcessor.prototype.setListener = function(listener) {\n    this.listener = listener;\n};\n\n\nMapGeodataProcessor.prototype.sendCommand = function(command, data, tile, dpr) {\n    if (this.killed) {\n        return;\n    }\n\n    this.ready = false;\n    \n    var message = {'command': command, 'data':data};\n\n    //console.log('sendCommand ' + command);\n    \n    if (tile && tile.id) { \n        message['lod'] = tile.id[0];\n\n        if (tile.metanode) {\n            message['tileSize'] = Math.tan(tile.metanode.diskAngle2A) * tile.metanode.diskDistance;\n            message['pixelSize'] =  (message['tileSize'] * 0.70710678118) / tile.metanode.displaySize;\n        }\n    }\n\n    if (dpr) {\n        message['dpr'] = dpr;\n    }\n\n    this.processWorker.postMessage(message);\n};\n\nMapGeodataProcessor.prototype.setStylesheet = function(stylesheet, fontsOnly) {\n    this.stylesheet = stylesheet;\n\n    if (!stylesheet.isReady()) {\n        this.waitingForStylesheet = true;\n        return;\n    }\n\n    this.busy = true;\n\n    var ppi = 96 * (window.devicePixelRatio || 1);\n    var config = this.map.config;\n    var params = config.mapFeaturesReduceParams;\n    var isDef = (function(val){ return (typeof val !== 'undefined') });\n\n    switch (config.mapFeaturesReduceMode) {\n        case 'scr-count1':\n        case 'scr-count2':\n            if (!params) {\n                params = [1,50,0];\n            } else {\n                params[0] = isDef(params[0]) ? params[0] : 1;\n                params[1] = isDef(params[1]) ? params[1] : 50;\n                params[2] = isDef(params[2]) ? params[2] : 0;\n            }\n            config.mapFeaturesSortByTop = (config.mapFeaturesReduceMode == 'scr-count2') ? true : false;\n            break;\n\n        case 'scr-count4':\n            if (!params) {\n                params = [0.18,0,0];\n            } else {\n                params[0] = isDef(params[0]) ? params[0] : 0.18;\n                params[1] = isDef(params[1]) ? params[1] : 0;\n                params[2] = isDef(params[2]) ? params[2] : 1;\n            }\n            config.mapFeaturesSortByTop = true;\n            break;\n\n        case 'scr-count5':\n            if (!params) {\n                params = [2,1,0];\n            } else {\n                params[0] = isDef(params[0]) ? params[0] : 2;\n                params[1] = isDef(params[1]) ? params[1] : 1;\n                params[2] = isDef(params[2]) ? params[2] : 1;\n            }\n            config.mapFeaturesSortByTop = true;\n            break;\n\n        case 'scr-count6':\n            if (!params) {\n                params = [0.2,0,0];\n            } else {\n                params[0] = (isDef(params[0]) ? params[0] : 0.2);\n                params[1] = isDef(params[1]) ? params[1] : 0;\n                params[2] = isDef(params[2]) ? params[2] : 1;\n                params[3] = ppi;\n                config.mapFeaturesSortByTop = true;\n            }\n            break;\n\n    }\n\n    config.mapFeaturesReduceFactor = params[2];\n\n    if (!config.mapFeaturesReduceParams) {\n        switch(config.mapFeaturesReduceMode) {\n            case 'scr-count1':\n            case 'scr-count2': config.mapFeaturesReduceParams = [1, 50, 0]; break;\n            case 'scr-count4': config.mapFeaturesReduceParams = [0.18, 0, 1]; break;\n            case 'scr-count5': config.mapFeaturesReduceParams = [2, 1, 1]; break;\n            case 'scr-count6': config.mapFeaturesReduceParams = [0.2, 0, 1, ppi]; break;\n        }\n    }\n\n    //this.setFont('#default', this.renderer.font);\n    this.sendCommand('setStylesheet', { 'data' : stylesheet.data,\n                                        'geocent' : (!this.map.getNavigationSrs().isProjected()), 'metric': config.mapMetricUnits,\n                                        'reduceMode': config.mapFeaturesReduceMode,\n                                        'reduceParams': config.mapFeaturesReduceParams,\n                                        'log': config.mapLogGeodataStyles } );\n\n    var fonts = stylesheet.fonts;\n    var fontMap = {}; //'#default' : '#default' };\n\n    for (var key in fonts) {\n        var fontUrl = fonts[key];\n        var font = this.renderer.fonts[fontUrl];\n        fontMap[key] = fontUrl;\n\n        if (font) {\n            this.setFont(fontUrl, font);\n        }\n    }\n\n    this.processCounter++;\n    this.sendCommand('setFontMap', { 'map' : fontMap });\n};\n\nMapGeodataProcessor.prototype.setFont = function(url, font) {\n    if (!this.fonts[url]) {\n        this.fonts[url] = font;\n        this.sendCommand('setFont', {'url' : url, 'data': font.data}, [font.data]);\n    }\n};\n\n\nexport default MapGeodataProcessor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/geodata-processor/processor.js\n// module id = 137\n// module chunks = 0 1","\nimport MapTrajectory_ from './trajectory';\nimport MapBoundLayer_ from './bound-layer';\nimport MapSurface_ from './surface';\nimport MapPosition_ from './position';\nimport MapGeodataBuilder_ from './geodata-builder';\n\n//get rid of compiler mess\nvar MapTrajectory = MapTrajectory_;\nvar MapBoundLayer = MapBoundLayer_;\nvar MapSurface = MapSurface_;\nvar MapPosition = MapPosition_;\nvar MapGeodataBuilder = MapGeodataBuilder_;\n\n\nvar MapInterface = function(map) {\n    this.map = map;\n    this.config = map.config;\n};\n\n\nMapInterface.prototype.setPosition = function(position) {\n    this.map.setPosition(position);\n    return this;    \n};\n\n\nMapInterface.prototype.getPosition = function() {\n    return this.map.getPosition();\n};\n\n\nMapInterface.prototype.setView = function(view) {\n    this.map.setView(view);\n    return this;    \n};\n\n\nMapInterface.prototype.getView = function() {\n    return this.map.getView();\n};\n\n\nMapInterface.prototype.getCredits = function() {\n    return this.map.getCredits();\n};\n\n\nMapInterface.prototype.getCurrentCredits = function() {\n    return this.map.getVisibleCredits();\n};\n\n\nMapInterface.prototype.getCreditInfo = function(creditId) {\n    var credit = this.map.getCreditById(creditId);\n    return credit ? credit.getInfo() : {};\n};\n\n\nMapInterface.prototype.getViews = function() {\n    return this.map.getNamedViews();\n};\n\n\nMapInterface.prototype.getViewInfo = function(viewId) {\n    var view = this.map.getNamedView(viewId);\n    return view ? view.getInfo() : {};\n};\n\n\nMapInterface.prototype.getBoundLayers = function() {\n    return this.map.getBoundLayers();\n};\n\n\nMapInterface.prototype.getBoundLayerInfo = function(layerId) {\n    return this.map.getBoundLayerInfo(layerId);\n};\n\n\nMapInterface.prototype.getFreeLayers = function() {\n    return this.map.getFreeLayers();\n};\n\n\nMapInterface.prototype.getFreeLayerInfo = function(layerId) {\n    var layer = this.map.getFreeLayer(layerId);\n    return layer ? layer.getInfo() : {};\n};\n\n\nMapInterface.prototype.getSurfaces = function() {\n    return this.map.getSurfaces();\n};\n\n\nMapInterface.prototype.getSurfaceInfo = function(surfaceId) {\n    var surface = this.map.getFreeLayer(surfaceId);\n    return surface ? surface.getInfo() : {};\n};\n\n\nMapInterface.prototype.getSrses = function() {\n    return this.map.getSrses();\n};\n\n\nMapInterface.prototype.getSrsInfo = function(srsId) {\n    var srs = this.map.getSrs(srsId);\n    return srs ? srs.getInfo() : {};\n};\n\n\nMapInterface.prototype.getReferenceFrame = function() {\n    return this.map.referenceFrame.getInfo();\n};\n\n\nMapInterface.prototype.addFreeLayer = function(id, options) {\n    var layer = new MapSurface(this.map, options, 'free');\n    this.map.addFreeLayer(id, layer);\n};\n\n\nMapInterface.prototype.removeFreeLayer = function(id) {\n    this.map.removeFreeLayer(id); \n};\n\n\n/* MapInterface.prototype.setFreeLayerOptions = function(id, options) {\n    this.map.setFreeLayerOptions(id, options); \n};\n\n\nMapInterface.prototype.getFreeLayerOptions = function(id) {\n    return this.map.getFreeLayerOptions(id); \n}; */\n\n\nMapInterface.prototype.addBoundLayer = function(id, options) {\n    var layer = new MapBoundLayer(this.map, options, id);\n    this.map.addBoundLayer(id, layer); \n};\n\n\nMapInterface.prototype.removeBoundLayer = function(id) {\n    this.map.removeBoundLayer(id); \n};\n\n\n/* MapInterface.prototype.setBoundLayerOptions = function(id, options) {\n    this.map.setBoundLayerOptions(id, options); \n};\n\n\nMapInterface.prototype.getBoundLayerOptions = function(id) {\n    return this.map.setBoundLayerOptions(id); \n};*/\n\nMapInterface.prototype.convertPositionViewMode = function(position, mode) {\n    return this.map.convert.convertPositionViewMode((new MapPosition(position)), mode);\n};\n\n\nMapInterface.prototype.convertPositionHeightMode = function(position, mode, noPrecisionCheck) {\n    return this.map.convert.convertPositionHeightMode((new MapPosition(position)), mode, noPrecisionCheck);\n};\n\n\nMapInterface.prototype.convertCoords = function(sourceSrs, destinationSrs, coords) {\n    var srs = this.map.getSrs(sourceSrs);\n    var srs2 = this.map.getSrs(destinationSrs);\n    if (!srs || !srs2) {\n        return null;\n    }\n\n    return srs2.convertCoordsFrom(coords, srs);\n};\n\n\nMapInterface.prototype.convertCoordsFromNavToPublic = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionPublicCoords((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPublicToNav = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionNavCoordsFromPublic((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPhysToPublic = function(pos) {\n    return this.map.convert.convertCoords(pos, 'physical', 'public');\n};\n\n\nMapInterface.prototype.convertCoordsFromNavToPhys = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionPhysCoords((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPhysToNav = function(pos, mode, lod) {\n    return this.map.convert.convertCoordsFromPhysToNav(pos, mode, lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromNavToCanvas = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionCanvasCoords((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPhysToCanvas = function(pos) {\n    var p = ['obj', pos[0], pos[1], 'fix', pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionCanvasCoords((new MapPosition(p)), null, true);\n};\n\n\nMapInterface.prototype.convertCoordsFromNavToCameraSpace = function(pos, mode, lod) {\n    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];\n    return this.map.convert.getPositionCameraSpaceCoords((new MapPosition(p)), lod);\n};\n\n\nMapInterface.prototype.convertCoordsFromPhysToCameraSpace = function(pos) {\n    var p = this.map.camera.position;\n    return [pos[0] - p[0], pos[1] - p[1], pos[2] - p[2]];\n};\n\n\nMapInterface.prototype.getPositionCanvasCoords = function(position, lod) {\n    return this.map.convert.getPositionCanvasCoords(new MapPosition(position), lod);\n};\n\n\nMapInterface.prototype.getPositionCameraCoords = function(position, mode) {\n    return this.map.convert.getPositionCameraCoords(new MapPosition(position), mode);\n};\n\n\nMapInterface.prototype.movePositionCoordsTo = function(position, azimuth, distance, skipOrientation) {\n    return this.map.convert.movePositionCoordsTo(new MapPosition(position), azimuth, distance, skipOrientation);\n};\n\n\nMapInterface.prototype.getGeodesicLinePoints = function(coords, coords2, height, density) {\n    return this.map.convert.getGeodesicLinePoints(coords, coords2, height, density);\n};\n\n\nMapInterface.prototype.getSurfaceHeight = function(coords, precision) {\n    return this.map.measure.getSurfaceHeight(coords, this.map.measure.getOptimalHeightLodBySampleSize(coords, precision));\n};\n\n\nMapInterface.prototype.getSurfaceAreaGeometry = function(coords, radius, mode, limit, callback, loadTextures) {\n    var res = this.map.measure.getSurfaceAreaGeometry(coords, radius, mode, limit, true, loadTextures);\n    //console.log('getSurfaceAreaGeometry');\n\n    if (!res[0]) {\n        return this.map.core.once('map-update', this.getSurfaceAreaGeometry.bind(this, coords, radius, mode, limit, callback, loadTextures), 1);\n    } else {\n        var buffer = res[1], ret = [], map = this.map;        \n\n        if (map.tree) {\n            map.storedTilesRes = [];\n            map.tree.storeGeometry(buffer, buffer.length);\n            ret = map.storedTilesRes;\n            map.storedTilesRes = [];\n        }\n\n        callback(ret);\n        return (function(){});\n    }\n};\n\n\nMapInterface.prototype.getDistance = function(coords, coords2, includingHeights, usePublic) {\n    return this.map.measure.getDistance(coords, coords2, includingHeights, usePublic);\n};\n\n\nMapInterface.prototype.getAzimuthCorrection = function(coords, coords2) {\n    return this.map.measure.getAzimuthCorrection(coords, coords2);\n};\n\n\nMapInterface.prototype.getNED = function(coords, onlyMatrix) {\n    return this.map.measure.getNewNED(coords, (onlyMatrix === false) ? false : true);\n};\n\n\nMapInterface.prototype.getCameraInfo = function() {\n    var camera = this.map.camera;\n    return {\n        'projectionMatrix' : camera.camera.projection.slice(),\n        'viewMatrix' : camera.camera.modelview.slice(),\n        'viewProjectionMatrix' : camera.camera.mvp.slice(),\n        'rotationMatrix' : camera.camera.rotationview.slice(),\n        'position' : this.map.camera.position.slice(),\n        'vector' : this.map.camera.vector.slice(),\n        'distance' : this.map.camera.distance,\n        'height' : this.map.camera.height\n    };\n};\n\n\nMapInterface.prototype.isPointInsideCameraFrustum = function(point) {\n    return this.map.camera.camera.pointVisible(point, this.map.camera.position);\n};\n\n\nMapInterface.prototype.isBBoxInsideCameraFrustum = function(bbox) {\n    return this.map.camera.camera.bboxVisible({min:bbox[0], max:bbox[1]}, this.map.camera.position);\n};\n\n\nMapInterface.prototype.generateTrajectory = function(p1, p2, options) {\n    p1 = new MapPosition(p1);\n    p2 = new MapPosition(p2);\n    return (new MapTrajectory(this.map, p1, p2, options)).generate();\n};\n\n\nMapInterface.prototype.generatePIHTrajectory = function(position, azimuth, distance, options) {\n    var p = new MapPosition(position);\n    options['distance'] = distance;\n    options['azimuth'] = azimuth;\n    options['distanceAzimuth'] = true;\n    return (new MapTrajectory(this.map, p, p, options)).generate();\n};\n\n\nMapInterface.prototype.setConfigParams = function(params) {\n    this.map.setConfigParams(params);\n    return this;\n};\n\n\nMapInterface.prototype.setConfigParam = function(key, value) {\n    this.map.setConfigParam(key, value);\n    return this;\n};\n\n\nMapInterface.prototype.getConfigParam = function(key) {\n    return this.map.getConfigParam(key);\n};\n\n\nMapInterface.prototype.redraw = function() {\n    this.map.markDirty();\n    return this;\n};\n\n\nMapInterface.prototype.addRenderSlot = function(id, callback, enabled) {\n    this.map.renderSlots.addRenderSlot(id, callback, enabled);\n    return this;    \n};\n\n\nMapInterface.prototype.moveRenderSlotBefore = function(whichId, whereId) {\n    this.map.renderSlots.moveRenderSlotBefore(whichId, whereId);\n    return this;    \n};\n\n\nMapInterface.prototype.moveRenderSlotAfter = function(whichId, whereId) {\n    this.map.renderSlots.moveRenderSlotAfter(whichId, whereId);\n    return this;    \n};\n\n\nMapInterface.prototype.removeRenderSlot = function(id) {\n    this.map.renderSlots.removeRenderSlot(id);\n    return this;    \n};\n\n\nMapInterface.prototype.setRenderSlotEnabled = function(id, state) {\n    this.map.renderSlots.setRenderSlotEnabled(id, state);\n    return this;    \n};\n\n\nMapInterface.prototype.getRenderSlotEnabled = function(id) {\n    return this.map.renderSlots.getRenderSlotEnabled(id);\n};\n\n\nMapInterface.prototype.setLoaderSuspended = function(state) {\n    this.map.loaderSuspended = state;\n    return this;\n};\n\n\nMapInterface.prototype.getLoaderSuspended = function() {\n    return this.map.loaderSuspended;\n};\n\n\nMapInterface.prototype.getGpuCache = function() {\n    return this.map.gpuCache;\n};\n\n\nMapInterface.prototype.getHitCoords = function(screenX, screenY, mode, lod) {\n    return this.map.getHitCoords(screenX, screenY, mode, lod);\n};\n\n\nMapInterface.prototype.getScreenRay = function(screenX, screenY) {\n    return this.map.getScreenRay(screenX, screenY);\n};\n\n\nMapInterface.prototype.renderToImage = function() {\n    return this.map.renderToImage();\n};\n\n\nMapInterface.prototype.getCurrentGeometry = function() {\n    return this.map.getCurrentGeometry();\n};\n\n\nMapInterface.prototype.getStats = function(switches) {\n    if (switches) {\n        return {\n            'maxZoom' : this.map.draw.debug.maxZoom\n        };\n    }\n\n    var busyWorkers = 0;\n    for (var i = 0, li = this.map.geodataProcessors; i < li; i++) {\n        if (this.map.geodataProcessors[i].busy) {\n            busyWorkers++;\n        }        \n    }\n\n    return {\n        'bestMeshTexelSize' : this.map.bestMeshTexelSize,\n        'bestGeodataTexelSize' : this.map.bestGeodataTexelSize, \n        'downloading' : this.map.loader.downloading.length,\n        'lastDownload' : this.map.loader.lastDownloadTime, \n        'surfaces' : this.map.tree.surfaceSequence.length,\n        'freeLayers' : this.map.freeLayerSequence.length,\n        'texelSizeFit' : this.map.texelSizeFit,\n        'loadMode' : this.map.config.mapLoadMode,\n        'processingTasks' : this.map.processingTasks.length,\n        'busyWorkers' : busyWorkers,\n        'dirty' : this.map.dirty,\n        'drawnTiles' : this.map.stats.drawnTiles,\n        'drawnGeodataTiles' : this.map.stats.drawnGeodataTiles\n    };\n};\n\n\nMapInterface.prototype.click = function(screenX, screenY, state) {\n    this.map.click(screenX, screenY, state);\n};\n\n\nMapInterface.prototype.hover = function(screenX, screenY, persistent, state) {\n    this.map.hover(screenX, screenY, persistent, state);\n};\n\nMapInterface.prototype.createGeodata = function() {\n    return new MapGeodataBuilder(this.map);\n};\n\nMapInterface.prototype.getGeodataGeometry = function(id) {\n    return this.map.renderer.geometries[id];\n};\n\nMapInterface.prototype.setGeodataSelection = function(selection) {\n    this.map.renderer.geodataSelection = selection;\n    this.map.markDirty();\n    return this;\n};\n\nMapInterface.prototype.getGeodataSelection = function() {\n    return this.map.renderer.geodataSelection;\n};\n\n\nexport default MapInterface;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/interface.js\n// module id = 138\n// module chunks = 0 1","\nvar MapLoader = function(map, maxThreads) {\n    this.map = map;\n    this.core = map.core;\n\n    this.maxThreads = maxThreads || 1;\n    this.usedThreads = 0;\n    this.maxPending = this.maxThreads * 2;\n    this.fadeout = 19 / 20;\n\n    this.pending = [[],[]];\n    this.channel = 0;\n\n    this.downloading = [];\n    this.downloadingTime = [];\n    this.lastDownloadTime = 0;\n    this.downloaded = 0;\n    this.updateThreadCount();\n};\n\n\nMapLoader.prototype.updateThreadCount = function() {\n    this.maxThreads = this.map.config.mapDownloadThreads;\n    this.maxPending = Math.max(20, this.maxThreads * 2);\n    this.fadeout = (this.maxPending-1) / this.maxPending;\n};\n\n\nMapLoader.prototype.setChannel = function(channel) {\n    this.channel = channel;\n};\n\n\nMapLoader.prototype.load = function(path, downloadFunction, priority, id, kind) {\n    var index = this.downloading.indexOf(path);\n\n    if (index != -1) {\n        return;\n    }\n\n    // update the pending list\n    var pending = this.pending[this.channel];\n\n   // put the request to the beginning of the pending list\n    index = this.map.searchArrayIndexById(pending, path);\n    if (index != -1) {\n        pending[index].priority = priority; \n    } else {\n        pending.unshift({id:path, call: downloadFunction, priority : (priority || 0), tile:id, kind:kind });\n    }\n\n    //sort pending list by priority\n    do {\n        var sorted = true;\n        \n        for (var i = 0, li = pending.length - 1; i < li; i++) {\n            if (pending[i].priority > pending[i+1].priority) {\n                var t = pending[i];\n                pending[i] = pending[i+1];\n                pending[i+1] = t;\n    \n                sorted = false;\n            } \n        }\n        \n    } while(!sorted);\n\n    // keep the pending list at reasonable length\n    if (pending.length > this.maxPending) {\n        pending.pop();\n    }\n};\n\n\nMapLoader.prototype.remove = function(path) {\n    var index = this.map.searchArrayIndexById(this.pending[this.channel], path);\n    if (index != -1) {\n        this.pending[this.channel].splice(index, 1);\n    }\n};\n\n\nMapLoader.prototype.onLoaded = function(item) {\n    var index = this.downloading.indexOf(item.id);\n    var timer = performance.now();\n    var stats = this.map.stats;\n    var recordStats = this.map.draw.replay.storeLoaded;\n\n    if (recordStats) {\n        this.map.draw.replay.loaded.push({\n            url : item.id,\n            kind : item.kind,\n            tile: item.tile,\n            priority : item.priority,\n            time : timer,\n            duration : timer - this.downloadingTime[index],\n            interval : timer - this.lastDownloadTime,\n            threads : this.downloading.length\n        });\n\n        //var a = (timer - this.downloadingTime[index]);\n        //if (Number.isNaN(a)) {\n            //a = a; \n        //}\n\n    }\n\n    this.downloading.splice(index, 1);\n    this.downloadingTime.splice(index, 1);\n    //this.lastDownloadTime = Date.now();\n    this.lastDownloadTime = timer;\n    this.usedThreads--;\n    this.map.markDirty();\n    this.update();\n    stats.loadedCount++;\n    stats.loadLast = timer;\n};\n\n\nMapLoader.prototype.onLoadError = function(item) {\n    var index = this.downloading.indexOf(item.id);\n    var timer = performance.now();\n    var stats = this.map.stats;\n    var recordStats = this.map.draw.replay.storeLoaded;\n\n    if (recordStats) {\n        this.map.draw.replay.loaded.push({\n            url : item.id,\n            kind : item.kind,\n            tile: item.tile,\n            priority : item.priority,\n            time : timer,\n            duration : timer - this.downloadingTime[index],\n            interval : timer - this.lastDownloadTime,\n            threads : this.downloading.length\n        });\n    }\n\n    this.downloading.splice(index, 1);\n    this.downloadingTime.splice(index, 1);\n    //this.lastDownloadTime = Date.now();\n    this.lastDownloadTime = timer;\n    this.usedThreads--;\n    this.map.markDirty();\n    this.update();\n    stats.loadErrorCount++;\n    stats.loadLast = timer;\n};\n\n\nMapLoader.prototype.updateChannel = function(channel) {\n    var pending = this.pending[channel];\n    this.updateThreadCount();\n\n    //reduce priority for pending stuff\n    for (var i = 0, li = pending.length; i < li; i++) {\n        pending[i].priority *= this.fadeout;\n    }\n\n    var timer = performance.now();\n\n    while (pending.length > 0 && this.usedThreads < this.maxThreads) {\n        var item = pending.shift();\n\n        if (this.downloading.indexOf(item.id) == -1 && item.call != null) {\n            this.downloading.push(item.id);\n            this.downloadingTime.push(timer);\n            this.usedThreads++;\n            this.downloaded++;\n\n            item.call(item.id, this.onLoaded.bind(this, item), this.onLoadError.bind(this, item));\n        }\n    }\n};\n\n\nMapLoader.prototype.update = function() {\n    if (this.map.loaderSuspended || this.core.contextLost) {\n        return;\n    }\n\n    for (var i = this.pending.length - 1; i >= 0; i--) {\n        if (this.pending[i].length > 0) {\n            this.updateChannel(i);\n            break;\n        }\n    }\n};\n\n\nexport default MapLoader;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/loader.js\n// module id = 139\n// module chunks = 0 1","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport {utils as utils_} from '../utils/utils';\nimport {platform as platform_} from '../utils/platform';\nimport MapView_ from './view';\nimport MapSurfaceTree_ from './surface-tree';\nimport MapResourceTree_ from './resource-tree';\nimport MapSrs_ from './srs';\nimport MapCache_ from './cache';\nimport MapCamera_ from './camera';\nimport MapConfig_ from './config';\nimport MapConvert_ from './convert';\nimport MapMeasure_ from './measure';\nimport MapDraw_ from './draw';\nimport MapLoader_ from './loader';\nimport MapPosition_ from './position';\nimport MapRenderSlots_ from './render-slots';\nimport MapStats_ from './stats';\nimport MapSurfaceSequence_ from './surface-sequence';\nimport MapUrl_ from './url';\nimport GpuTexture_ from '../renderer/gpu/texture';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar utils = utils_;\nvar platform = platform_;\nvar MapView = MapView_;\nvar MapSurfaceTree = MapSurfaceTree_;\nvar MapResourceTree = MapResourceTree_;\nvar MapSrs = MapSrs_;\nvar MapCache = MapCache_;\nvar MapCamera = MapCamera_;\nvar MapConfig = MapConfig_;\nvar MapConvert = MapConvert_;\nvar MapMeasure = MapMeasure_;\nvar MapDraw = MapDraw_;\nvar MapLoader = MapLoader_;\nvar MapPosition = MapPosition_;\nvar MapRenderSlots = MapRenderSlots_;\nvar MapStats = MapStats_;\nvar MapSurfaceSequence = MapSurfaceSequence_;\nvar MapUrl = MapUrl_;\nvar GpuTexture = GpuTexture_;\n\n\nvar Map = function(core, mapConfig, path, config) {\n    this.config = config || {};\n    this.setConfigParams(config);\n    this.core = core;\n    this.proj4 = this.core.getProj4();\n    this.coreConfig = core.coreConfig;\n    this.killed = false;\n    this.config = config || {};\n    this.loaderSuspended = false;\n\n    this.url = new MapUrl(this, path);\n\n    this.position = new MapPosition(['obj', 0, 0, 'fix', 0,  0, 0, 0,  0, 0]);\n    this.lastPosition = this.position.clone();\n\n    this.srses = {};\n    this.bodies = {};\n    this.referenceFrame = {};\n    this.credits = {};\n    this.creditsByNumber = {};\n    this.surfaces = [];\n    this.virtualSurfaces = {};\n    this.glues = {};\n    this.freeLayers = [];\n    this.boundLayers = [];\n    this.dynamicLayers = [];\n    this.stylesheets = [];\n    this.processingTasks = [];\n    this.processingTasks2 = [];\n    this.geodataProcessors = [];\n\n    this.surfaceSequence = new MapSurfaceSequence(this);\n\n    this.initialView = null;\n    this.currentView = new MapView(this, {});\n    this.currentViewString = '';\n    this.namedViews = [];\n    this.viewCounter = 0;\n    this.srsReady = false;\n\n    this.freeLayerSequence = [];\n    this.freeLayersHaveGeodata = false;\n\n    this.visibleCredits = {\n        imagery : {},\n        glueImagery : {},\n        mapdata : {}\n    };\n    \n    this.mobile = false;\n    this.metanodeBuffer = new Uint8Array(1024);\n   \n    this.gpuCache = new MapCache(this, this.config.mapGPUCache*1024*1024);\n    this.resourcesCache = new MapCache(this, this.config.mapCache*1024*1024);\n    this.metatileCache = new MapCache(this, this.config.mapMetatileCache*1024*1024);\n\n    this.setupMobileMode(this.config.mapMobileMode);\n    this.setupCache();\n\n    this.loader = new MapLoader(this, this.config.mapDownloadThreads);\n\n    this.renderer = this.core.renderer;\n    this.camera = new MapCamera(this);\n\n    this.stats = new MapStats(this);\n    this.resourcesTree = new MapResourceTree(this);\n   \n    this.mapConfig = new MapConfig(this, mapConfig);\n    this.convert = new MapConvert(this);\n    this.measure = new MapMeasure(this);\n    this.convert.measure = this.measure;\n\n    this.isGeocent = !this.getNavigationSrs().isProjected();\n\n    this.tree = new MapSurfaceTree(this, false);\n    this.mapConfig.afterConfigParsed();\n\n    this.updateCoutner = 0;\n\n    this.dirty = true;\n    this.dirtyCountdown = 0;\n    this.hitMapDirty = true;\n    this.geoHitMapDirty = true;\n\n    this.clickEvent = null;\n    this.hoverEvent = null;\n    this.hoverFeature = null;\n    this.hoverFeatureId = null;\n    this.lastHoverFeature = null;\n    this.lastHoverFeatureId = null;\n    this.hoverFeatureCounter = 0;\n    this.hoverFeatureList = [];\n    \n    this.draw = new MapDraw(this);\n    this.draw.setupDetailDegradation();\n\n    var body = this.referenceFrame.body, c;\n\n    if (body && body.atmosphere) {\n        c = body.atmosphere.colorHorizon;\n        this.draw.atmoColor = [c[0]/255.0, c[1]/255.0, c[2]/255.0, c[3]/255.0];\n        c = body.atmosphere.colorZenith;\n        this.draw.atmoColor2 = [c[0]/255.0, c[1]/255.0, c[2]/255.0, c[3]/255.0];\n        this.draw.atmoHeight = 50000 * (body.atmosphere.thickness / 100000);\n        this.draw.atmoDensity = (body.atmosphere.visibility / 100000) * (100000 / body.atmosphere.thickness);\n    } else {\n        switch(this.referenceFrame.id) {\n            case 'melown2015':\n            case 'earth-qsc':\n                this.draw.atmoColor = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];\n                this.draw.atmoColor2 = [72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0];\n                //this.draw.atmoColor3 = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];\n                this.draw.atmoHeight = 50000;\n                break;\n\n            case 'mars-qsc':\n                this.draw.atmoColor = [255.0/255.0, 187.0/255.0, 157.0/255.0, 1.0];\n                this.draw.atmoColor2 = [255.0/255.0, 155.0/255.0, 113.0/255.0, 1.0];\n                //this.draw.atmoColor3 = [255.0/255.0, 187.0/255.0, 157.0/255.0, 0.5];\n                this.draw.atmoHeight = 25000;\n                this.draw.atmoDensity = 1.0 / 0.25;\n                break;\n        }\n    }\n\n    this.draw.atmoHeightFactor = this.draw.atmoHeight / 50000;\n\n    this.renderSlots = new MapRenderSlots(this);\n    this.renderSlots.addRenderSlot('map', this.drawMap.bind(this), true);\n};\n\n\nMap.prototype.kill = function() {\n    this.killed = true;\n    \n    if (this.tree) {\n        this.tree.kill();\n    }\n\n    for (var key in this.freeLayers) {\n        var layer = this.freeLayers[key];\n        if (layer && layer.tree) {\n            layer.tree.kill();\n        }\n    }\n\n    this.gpuCache.clear();\n    this.resourcesCache.clear();\n    this.metatileCache.clear();\n\n    if (this.renderer != null) {\n        this.renderer.kill();\n        this.renderer = null;\n    }\n};\n\n\nMap.prototype.setupMobileMode = function() {\n    this.mobile = this.config.mapMobileMode;\n\n    if (!this.mobile && this.config.mapMobileModeAutodect) {\n        this.mobile = platform.isMobile();        \n    }\n\n    this.setupCache();\n};\n\n\nMap.prototype.setupCache = function() {\n    if (!this.resourcesCache) {\n        return;\n    }\n\n    var factor = 1 / (this.mobile ? Math.pow(2, Math.max(0,this.config.mapMobileDetailDegradation-1)) : 1);\n    var factor2 = 1 / (this.mobile ? Math.pow(2, this.config.mapMobileDetailDegradation) : 1);\n    factor = (factor + factor2) * 0.5;\n    this.resourcesCache.setMaxCost(this.config.mapCache*1024*1024*factor);\n    this.gpuCache.setMaxCost(this.config.mapGPUCache*1024*1024*factor);\n    this.metatileCache.setMaxCost(this.config.mapMetatileCache*1024*1024*(factor < 0.8 ? 0.5 : 1));\n};\n\n\nMap.prototype.getCoreInterface = function() {\n    return this.core.interface;\n};\n\n\nMap.prototype.getRendererInterface = function() {\n    return this.core.interface.getRendererInterface();\n};\n\n\nMap.prototype.setOption = function(/*key, value*/) {\n};\n\n\nMap.prototype.getOption = function(/*key*/) {\n};\n\n\nMap.prototype.addSrs = function(id, srs) {\n    this.srses[id] = srs;\n};\n\n\nMap.prototype.getSrs = function(srsId) {\n    return this.srses[srsId];\n};\n\n\nMap.prototype.getSrses = function() {\n    return this.getMapKeys(this.srses);\n};\n\n\nMap.prototype.addBody = function(id, body) {\n    this.bodies[id] = body;\n};\n\n\nMap.prototype.getBody = function(id) {\n    return this.bodies[id];\n};\n\n\nMap.prototype.getBodies = function() {\n    return this.getMapKeys(this.bodies);\n};\n\n\nMap.prototype.setReferenceFrame = function(referenceFrame) {\n    this.referenceFrame = referenceFrame;\n};\n\n\nMap.prototype.addCredit = function(id, credit) {\n    this.credits[id] = credit;\n    this.creditsByNumber[credit.id] = credit;\n    credit.key = id;\n};\n\n\nMap.prototype.getCreditByNumber = function(id) {\n    return this.creditsByNumber[id];\n};\n\n\nMap.prototype.getCreditById = function(id) {\n    return this.credits[id];\n};\n\n\nMap.prototype.getCredits = function() {\n    return this.getMapKeys(this.credits);\n};\n\n\nMap.prototype.getVisibleCredits = function() {\n    var imagery = this.visibleCredits.imagery;\n    var glueImagery = this.visibleCredits.glueImagery;\n    var imageryArray = []; \n    var imagerySpecificity = [];\n    var i, li, t, sorted;\n\n    for (var key in glueImagery) {\n        if (!imagery[key]) {\n            imagery[key] = glueImagery[key];\n        }\n    }\n    \n    this.visibleCredits.glueImagery = {};\n    \n    for (key in imagery) {\n        imageryArray.push(key);\n        imagerySpecificity.push(imagery[key]); \n    }\n\n    //sort imagery\n    do {\n        sorted = true;\n        \n        for (i = 0, li = imagerySpecificity.length - 1; i < li; i++) {\n            if (imagerySpecificity[i] < imagerySpecificity[i+1]) {\n                t = imagerySpecificity[i];\n                imagerySpecificity[i] = imagerySpecificity[i+1];\n                imagerySpecificity[i+1] = t;\n                t = imageryArray[i];\n                imageryArray[i] = imageryArray[i+1];\n                imageryArray[i+1] = t;\n                sorted = false;\n            } \n        }\n        \n    } while(!sorted);\n\n    var mapdata = this.visibleCredits.mapdata;\n    var mapdataArray = []; \n    var mapdataSpecificity = []; \n\n    for (key in mapdata) {\n        mapdataArray.push(key);\n        mapdataSpecificity.push(mapdata[key]); \n    }\n    \n    //sort imagery\n    do {\n        sorted = true;\n        \n        for (i = 0, li = mapdataSpecificity.length - 1; i < li; i++) {\n            if (mapdataSpecificity[i] < mapdataSpecificity[i+1]) {\n                t = mapdataSpecificity[i];\n                mapdataSpecificity[i] = mapdataSpecificity[i+1];\n                mapdataSpecificity[i+1] = t;\n                t = mapdataArray[i];\n                mapdataArray[i] = mapdataArray[i+1];\n                mapdataArray[i+1] = t;\n                sorted = false;\n            } \n        }\n        \n    } while(!sorted);\n\n    return {\n        '3D' : [], \n        'imagery' : imageryArray, \n        'mapdata' : mapdataArray \n    };\n};\n\n\nMap.prototype.addSurface = function(id, surface) {\n    this.surfaces.push(surface);\n    surface.index = this.surfaces.length - 1; \n};\n\n\nMap.prototype.getSurface = function(id) {\n    return this.searchArrayById(this.surfaces, id);\n};\n\n\nMap.prototype.getSurfaces = function() {\n    var keys = [];\n    for (var i = 0, li = this.surfaces.length; i < li; i++) {\n        keys.push(this.surfaces[i].id);\n    }\n    return keys;\n};\n\n\nMap.prototype.addGlue = function(id, glue) {\n    this.glues[id] = glue;\n};\n\n\nMap.prototype.getGlue = function(id) {\n    return this.glues[id];\n};\n\n\nMap.prototype.addBoundLayer = function(id, layer) {\n    this.boundLayers[id] = layer;\n};\n\n\nMap.prototype.setBoundLayerOptions = function(id, options) {\n    if (this.boundLayers[id]) {\n        this.boundLayers[id].setOptions(options);\n    }\n};\n\n\nMap.prototype.getBoundLayerOptions = function(id) {\n    if (this.boundLayers[id]) {\n        return this.boundLayers[id].getOptions();\n    }\n    \n    return null;\n};\n\n\nMap.prototype.removeBoundLayer = function(id) {\n    if (this.boundLayers[id]) {\n        this.boundLayers[id].kill();\n        this.boundLayers[id] = null;\n    }\n};\n\n\nMap.prototype.getBoundLayerByNumber = function(number) {\n    var layers = this.boundLayers;\n    for (var key in layers) {\n        if (layers[key].numberId == number) {\n            return layers[key];\n        }\n    }\n\n    return null;\n};\n\n\nMap.prototype.getBoundLayerById = function(id) {\n    return this.boundLayers[id];\n};\n\n\nMap.prototype.getBoundLayers = function() {\n    return this.getMapKeys(this.boundLayers);\n};\n\n\nMap.prototype.addFreeLayer = function(id, layer) {\n    this.freeLayers[id] = layer;\n    this.setView(this.getView());\n    this.markDirty();\n};\n\n\nMap.prototype.removeFreeLayer = function(id) {\n    if (this.freeLayers[id]) {\n        this.freeLayers[id].kill();\n        this.freeLayers[id] = null;\n        this.setView(this.getView());\n        this.markDirty();\n    }\n};\n\n\nMap.prototype.setFreeLayerOptions = function(id, options) {\n    if (this.freeLayers[id]) {\n        this.freeLayers[id].setOptions(options);\n    }\n};\n\n\nMap.prototype.getFreeLayerOptions = function(id) {\n    if (this.freeLayers[id]) {\n        return this.freeLayers[id].getOptions();\n    }\n    \n    return null;\n};\n\n\nMap.prototype.getFreeLayer = function(id) {\n    return this.freeLayers[id];\n    //return this.searchArrayById(this.freeLayers, id);\n};\n\n\nMap.prototype.getFreeLayers = function() {\n    var keys = [];\n    for (var key in this.freeLayers) {\n        keys.push(key);\n    }\n    return keys;    \n};\n\n\nMap.prototype.getMapsSrs = function(srs) {\n    if (srs == null) {\n        return null;\n    }\n\n    //is it proj4 string?\n    if (srs.indexOf('+proj') != -1) {\n        return new MapSrs(this, {'srsDef':srs});\n    }\n\n    //search existing srs\n    return this.srses[srs];\n};\n\n\nMap.prototype.addNamedView = function(id, view) {\n    this.namedViews[id] = view;\n};\n\n\nMap.prototype.getNamedView = function(id) {\n    return this.namedViews[id];\n};\n\n\nMap.prototype.getNamedViews = function() {\n    return this.getMapKeys(this.namedViews);\n};\n\n\nMap.prototype.setView = function(view, forceRefresh) {\n    if (view == null) {\n        return;\n    }\n    \n    if (typeof view === 'string') {\n        view = view.trim();\n        \n        if (view.charAt(0) == '{') {\n            try {\n                view = JSON.parse(view);\n            } catch(e){\n                return;            \n            }\n        } else {\n            view = this.getNamedView(view);\n\n            if (!view) {\n                return;\n            }\n            \n            //view = JSON.parse(JSON.stringify(view));\n            view = view.getInfo();\n        }\n    }\n\n    var string = JSON.stringify(view);\n    if (string != this.currentViewString || forceRefresh) {\n        this.currentView.parse(view);\n        this.currentViewString = string;\n        this.viewCounter++;\n    }\n\n    this.surfaceSequence.generateSurfaceSequence();\n    this.surfaceSequence.generateBoundLayerSequence();\n\n    this.refreshFreelayesInView();\n\n    this.markDirty();\n};\n\n\nMap.prototype.addStylesheet = function(id, style) {\n    this.stylesheets[id] = style;\n};\n\n\nMap.prototype.getStylesheet = function(id) {\n    return this.stylesheets[id];\n    //return this.searchArrayById(this.stylesheets, id);\n};\n\n\nMap.prototype.getStylesheets = function() {\n    var keys = [];\n\n    for (var key in this.stylesheets) {\n        keys.push(key);\n    }\n    return keys;\n};\n\n\nMap.prototype.getStylesheetData = function(id) {\n    var stylesheet = this.getStylesheet(id);\n\n    if (stylesheet) {\n        return {'url':stylesheet.url, 'data': stylesheet.data};\n    }\n    \n    return {'url':null, 'data':{}};\n};\n\n\nMap.prototype.setStylesheetData = function(id, data) {\n    var stylesheet = this.getStylesheet(id);\n    \n    //if (stylesheet) {\n      //  stylesheet.data = data;\n    //}\n\n    this.renderer.draw.clearJobHBuffer();\n\n    if (stylesheet) {\n        if (data) {\n            stylesheet.setData(data);\n        }\n\n        for (var key in this.freeLayers) {\n            var freeLayer = this.getFreeLayer(key);\n            if (freeLayer && freeLayer.geodata && freeLayer.stylesheet == stylesheet) {\n                \n                if (freeLayer.geodataProcessor) {\n                    freeLayer.geodataProcessor.setStylesheet(freeLayer.stylesheet);\n                }\n\n                freeLayer.geodataCounter++;\n            }\n        }\n    }\n\n    this.markDirty();\n        \n    //TODO: reset geodatview in free layers\n};\n\n\nMap.prototype.getView = function() {\n    return this.currentView.getInfo();\n};\n\n\nMap.prototype.refreshFreelayesInView = function() {\n    var freeLayers = this.currentView.freeLayers;\n    this.freeLayerSequence = [];\n\n    for (var key in freeLayers) {\n        var freeLayer = this.getFreeLayer(key);\n        \n        if (freeLayer) {\n            \n            freeLayer.zFactor = freeLayers[key]['depthOffset'];\n            \n            this.freeLayerSequence.push(freeLayer);\n            \n            if (freeLayers[key]['style']) {\n                freeLayer.setStyle(freeLayers[key]['style']);\n            } else {\n                freeLayer.setStyle(freeLayer.originalStyle);\n            }\n            \n            //TODO: generate bound layer seqence for      \n        }\n    }\n};\n\nMap.prototype.refreshView = function() {\n    this.viewCounter++;\n    this.surfaceSequence.generateSurfaceSequence();\n    this.surfaceSequence.generateBoundLayerSequence();\n    this.refreshFreelayesInView();\n    this.markDirty();\n};\n\n\nMap.prototype.searchArrayIndexById = function(array, id) {\n    for (var i = 0, li = array.length; i < li; i++) {\n        if (array[i].id == id) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\n\nMap.prototype.searchArrayById = function(array, id) {\n    for (var i = 0, li = array.length; i < li; i++) {\n        if (array[i].id == id) {\n            return array[i];\n        }\n    }\n\n    return null;\n};\n\n\nMap.prototype.searchMapByInnerId = function(map, id) {\n    for (var key in map) {\n        if (map[key].id == id) {\n            return map[key];\n        }\n    }\n\n    return null;\n};\n\n\nMap.prototype.getMapKeys = function(map) {\n    var keys = [];\n    for (var key in map) {\n        keys.push(key);\n    }\n\n    return keys;\n};\n\n\nMap.prototype.getMapIds = function(map) {\n    var keys = [];\n    for (var key in map) {\n        keys.push(key.id);\n    }\n\n    return keys;\n};\n\n\nMap.prototype.setPosition = function(pos) {\n    this.position = new MapPosition(pos);\n    this.markDirty();\n};\n\n\nMap.prototype.isReferenceFrameReady = function() {\n    return this.referenceFrame.model.physicalSrs.isReady() &&\n           this.referenceFrame.model.publicSrs.isReady() &&\n           this.referenceFrame.model.navigationSrs.isReady();\n};\n\n\nMap.prototype.getPhysicalSrs = function() {\n    return this.referenceFrame.model.physicalSrs;\n};\n\n\nMap.prototype.getPublicSrs = function() {\n    return this.referenceFrame.model.publicSrs;\n};\n\n\nMap.prototype.getNavigationSrs = function() {\n    return this.referenceFrame.model.navigationSrs;\n};\n\n\nMap.prototype.getPosition = function() {\n    return this.position.clone();\n};\n\n\nMap.prototype.setConfigParams = function(params) {\n    if (typeof params === 'object' && params !== null) {\n        for (var key in params) {\n            this.setConfigParam(key, params[key]);\n        }\n    }\n};\n\n\nMap.prototype.setConfigParam = function(key, value) {\n    switch (key) {\n    case 'map':                           this.config.map = utils.validateString(value, null); break;\n    case 'mapCache':                      this.config.mapCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 900); this.setupCache(); break;\n    case 'mapGPUCache':                   this.config.mapGPUCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 360); this.setupCache(); break;\n    case 'mapMetatileCache':              this.config.mapMetatileCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 60); this.setupCache(); break;\n    case 'mapTexelSizeFit':               this.config.mapTexelSizeFit = utils.validateNumber(value, 0.0001, Number.MAXINTEGER, 1.1); break;\n    case 'mapDownloadThreads':            this.config.mapDownloadThreads = utils.validateNumber(value, 1, Number.MAXINTEGER, 6); break;\n    case 'mapMaxProcessingTime':          this.config.mapMaxProcessingTime = utils.validateNumber(value, 1, Number.MAXINTEGER, 1000/20); break;\n    case 'mapMaxGeodataProcessingTime':   this.config.mapMaxGeodataProcessingTime = utils.validateNumber(value, 1, Number.MAXINTEGER, 10); break;\n    case 'mapMobileMode':                 this.config.mapMobileMode = utils.validateBool(value, false); this.setupMobileMode(); break;\n    case 'mapMobileModeAutodect':         this.config.mapMobileModeAutodect = utils.validateBool(value, false); break;\n    case 'mapMobileDetailDegradation':    this.config.mapMobileDetailDegradation = utils.validateNumber(value, 1, Number.MAXINTEGER, 2); break;\n    case 'mapNavSamplesPerViewExtent':    this.config.mapNavSamplesPerViewExtent = utils.validateNumber(value, 0.00000000001, Number.MAXINTEGER, 4); break;\n    case 'mapFog':                        this.config.mapFog = utils.validateBool(value, false); if(this.draw){ this.draw.debug.drawFog = this.config.mapFog; this.dirty = true; } break;\n    case 'mapFlatshade':                  this.config.mapFlatshade = utils.validateBool(value, false); if(this.draw){ this.draw.debug.drawWireframe = this.config.mapFlatshade ? 3 : 0; this.dirty = true; } break;\n    case 'mapIgnoreNavtiles':             this.config.mapIgnoreNavtiles = utils.validateBool(value, false); break;\n    case 'mapAllowHires':                 this.config.mapAllowHires = utils.validateBool(value, true); break;\n    case 'mapAllowLowres':                this.config.mapAllowLowres = utils.validateBool(value, true); break;\n    case 'mapAllowSmartSwitching':        this.config.mapAllowSmartSwitching = utils.validateBool(value, true); break;\n    case 'mapDisableCulling':             this.config.mapDisableCulling = utils.validateBool(value, false); break;\n    case 'mapPreciseCulling':             this.config.mapPreciseCulling = utils.validateBool(value, false); break;\n    case 'mapHeightLodBlend':             this.config.mapHeightLodBlend = utils.validateBool(value, true); break;\n    case 'mapHeightNodeBlend':            this.config.mapHeightNodeBlend = utils.validateBool(value, true); break;\n    case 'mapBasicTileSequence':          this.config.mapBasicTileSequence = utils.validateBool(value, true); break;\n    case 'mapSmartNodeParsing':           this.config.mapSmartNodeParsing = utils.validateBool(value, true); break;\n    case 'mapStoreLoadStats':             this.config.mapStoreLoadStats = utils.validateBool(value, true);  if (this.draw && this.draw.replay) this.draw.replay.storeLoaded = this.config.mapStoreLoadStats; break;\n    case 'mapXhrImageLoad':               this.config.mapXhrImageLoad = utils.validateBool(value, false); break;\n    case 'mapLoadMode':                   this.config.mapLoadMode = utils.validateString(value, 'topdown'); break;\n    case 'mapGeodataLoadMode':            this.config.mapGeodataLoadMode = utils.validateString(value, 'fit'); break;\n    case 'mapGridMode':                   this.config.mapGridMode = utils.validateString(value, 'linear'); break;\n    case 'mapGridSurrogatez':             this.config.mapGridSurrogatez = utils.validateBool(value, false); break;\n    case 'mapGridUnderSurface':           this.config.mapGridUnderSurface = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;\n    case 'mapGridTextureLevel':           this.config.mapGridTextureLevel = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, -1); break;\n    case 'mapGridTextureLayer':           this.config.mapGridTextureLayer = utils.validateString(value, ''); break;\n    case 'mapPreciseBBoxTest':            this.config.mapPreciseBBoxTest = utils.validateBool(value, true); break;\n    case 'mapPreciseDistanceTest':        this.config.mapPreciseDistanceTest = utils.validateBool(value, false); break;\n    case 'mapHeightfiledWhenUnloaded':    this.config.mapHeightfiledWhenUnloaded = utils.validateBool(value, false); break;\n    case 'mapForceMetatileV3':            this.config.mapForceMetatileV3 = utils.validateBool(value, false); break;\n    case 'mapVirtualSurfaces':            this.config.mapVirtualSurfaces = utils.validateBool(value, true); break;\n    case 'mapDegradeHorizon':             this.config.mapDegradeHorizon = utils.validateBool(value, true); break;\n    case 'mapDegradeHorizonParams':       this.config.mapDegradeHorizonParams = utils.validateNumberArray(value, 4, [0,1,1,1], [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], [1, 3000, 15000, 7000]); break;\n    case 'mapRefreshCycles':              this.config.mapRefreshCycles = utils.validateNumber(value, 0, Number.MAXINTEGER, 3); break;\n    case 'mapDefaultFont':                this.config.mapDefaultFont =  utils.validateString(value, ''); break;\n    case 'mapMetricUnits':                this.config.mapMetricUnits = utils.validateBool(value, true); break;\n    case 'mapNoTextures':                 this.config.mapNoTextures = this.config.mapDisableCulling = utils.validateBool(value, false); break;\n    case 'mapForceFrameTime':             this.config.mapForceFrameTime = utils.validateNumber(value, -1, Number.MAXINTEGER, 0); break;\n    case 'mapForcePipeline':              this.config.mapForcePipeline = utils.validateNumber(value, 0, Number.MAXINTEGER, 0); break;\n    case 'mapFeatureGridCells':           this.config.mapFeatureGridCells = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;\n    case 'mapFeaturesPerSquareInch':      this.config.mapFeaturesPerSquareInch = utils.validateNumber(value, 0.000001, Number.MAXINTEGER, 0); break;\n    case 'mapFeaturesSortByTop':          this.config.mapFeaturesSortByTop = utils.validateBool(value, false); break;\n    case 'mapFeaturesReduceParams':       this.config.mapFeaturesReduceParams = value; break;\n    case 'mapLogGeodataStyles':           this.config.mapLogGeodataStyles = utils.validateBool(value, true); break;\n    case 'map16bitMeshes':                this.config.map16bitMeshes = utils.validateBool(value, false); break;\n    case 'mapOnlyOneUVs':                 this.config.mapOnlyOneUVs = utils.validateBool(value, false); break;\n    case 'mapIndexBuffers':               this.config.mapIndexBuffers = utils.validateBool(value, false); break;\n    case 'mapSoftViewSwitch':             this.config.mapSoftViewSwitch = utils.validateBool(value, true); break;\n    case 'mapAsyncImageDecode':           this.config.mapAsyncImageDecode = (utils.validateBool(value, false) && (typeof createImageBitmap !== 'undefined')) ? true : false; break;\n    case 'mapFeatureStickMode':           this.config.mapFeatureStickMode = utils.validateNumberArray(value, 2, [0,1], [Number.MAX_VALUE, Number.MAX_VALUE], [0, 1]); break;\n    case 'mario':                         this.config.mario = utils.validateBool(value, true); break;\n    case 'mapFeaturesReduceMode':         \n        value = utils.validateString(value, 'scr-count4');\n        if (value == 'auto') value = 'scr-count2';\n        if (value == 'legacy') value = 'scr-count2';\n        if (value == 'gridcells') value = 'scr-count4';\n        if (value == 'singlepass') value = 'scr-count5';\n        if (value == 'margin') value = 'scr-count6';\n        this.config.mapFeaturesReduceMode = value;\n        break;\n\n    }\n};\n\n\nMap.prototype.getConfigParam = function(key) {\n    switch (key) {\n    case 'map':                           return this.config.map;\n    case 'mapCache':                      return this.config.mapCache;\n    case 'mapGPUCache':                   return this.config.mapGPUCache;\n    case 'mapMetatileCache':              return this.config.mapMetatileCache;\n    case 'mapTexelSizeFit':               return this.config.mapTexelSizeFit;\n    case 'mapDownloadThreads':            return this.config.mapDownloadThreads;\n    case 'mapMaxProcessingTime':          return this.config.mapMaxProcessingTime;\n    case 'mapMaxGeodataProcessingTime':   return this.config.mapMaxGeodataProcessingTime;\n    case 'mapMobileMode':                 return this.config.mapMobileMode;\n    case 'mapMobileModeAutodect':         return this.config.mapMobileModeAutodect;\n    case 'mapMobileDetailDegradation':    return this.config.mapMobileDetailDegradation;\n    case 'mapNavSamplesPerViewExtent':    return this.config.mapNavSamplesPerViewExtent;\n    case 'mapFog':                        return this.config.mapFog;\n    case 'mapFlatshade':                  return this.config.mapFlatshade;\n    case 'mapIgnoreNavtiles':             return this.config.mapIgnoreNavtiles;\n    case 'mapAllowHires':                 return this.config.mapAllowHires;\n    case 'mapAllowLowres':                return this.config.mapAllowLowres;\n    case 'mapAllowSmartSwitching':        return this.config.mapAllowSmartSwitching;\n    case 'mapDisableCulling':             return this.config.mapDisableCulling;\n    case 'mapPreciseCulling':             return this.config.mapPreciseCulling;\n    case 'mapHeightLodBlend':             return this.config.mapHeightLodBlend;\n    case 'mapHeightNodeBlend':            return this.config.mapHeightNodeBlend;\n    case 'mapBasicTileSequence':          return this.config.mapBasicTileSequence;\n    case 'mapSmartNodeParsing':           return this.config.mapSmartNodeParsing;\n    case 'mapStoreLoadStats':             return this.config.mapStoreLoadStats;\n    case 'mapXhrImageLoad':               return this.config.mapXhrImageLoad;\n    case 'mapLoadMode':                   return this.config.mapLoadMode;\n    case 'mapGeodataLoadMode':            return this.config.mapGeodataLoadMode;\n    case 'mapGridMode':                   return this.config.mapGridMode;\n    case 'mapGridSurrogatez':             return this.config.mapGridSurrogatez;\n    case 'mapGridUnderSurface':           return this.config.mapGridUnderSurface;\n    case 'mapGridTextureLevel':           return this.config.mapGridTextureLevel;\n    case 'mapGridTextureLayer':           return this.config.mapGridTextureLayer;\n    case 'mapPreciseBBoxTest':            return this.config.mapPreciseBBoxTest;\n    case 'mapPreciseDistanceTest':        return this.config.mapPreciseDistanceTest;\n    case 'mapHeightfiledWhenUnloaded':    return this.config.mapHeightfiledWhenUnloaded;\n    case 'mapForceMetatileV3':            return this.config.mapForceMetatileV3;\n    case 'mapVirtualSurfaces':            return this.config.mapVirtualSurfaces;\n    case 'mapDegradeHorizon':             return this.config.mapDegradeHorizon;\n    case 'mapDegradeHorizonParams':       return this.config.mapDegradeHorizonParams;\n    case 'mapRefreshCycles':              return this.config.mapRefreshCycles;\n    case 'mapDefaultFont':                return this.config.mapDefaultFont;\n    case 'mapMetricUnits':                return this.config.mapMetricUnits;\n    case 'mapNoTextures':                 return this.config.mapNoTextures;\n    case 'mapForceFrameTime':             return this.config.mapForceFrameTime;\n    case 'mapForcePipeline':              return this.config.mapForcePipeline;\n    case 'mapFeatureGridCells':           return this.config.mapFeatureGridCells;\n    case 'mapFeaturesPerSquareInch':      return this.config.mapFeaturesPerSquareInch;\n    case 'mapFeaturesSortByTop':          return this.config.mapFeaturesSortByTop;\n    case 'mapFeaturesReduceMode':         return this.config.mapFeaturesReduceMode;\n    case 'mapFeaturesReduceParams':       return this.config.mapFeaturesReduceParams;\n    case 'mapLogGeodataStyles':           return this.config.mapLogGeodataStyles;\n    case 'map16bitMeshes':                return this.config.map16bitMeshes;\n    case 'mapOnlyOneUVs':                 return this.config.mapOnlyOneUVs;\n    case 'mapIndexBuffers':               return this.config.mapIndexBuffers;\n    case 'mapSoftViewSwitch':             return this.config.mapSoftViewSwitch;\n    case 'mapAsyncImageDecode':           return this.config.mapAsyncImageDecode;\n    case 'mapFeatureStickMode':           return this.config.mapFeatureStickMode;\n    case 'mario':                         return this.config.mario;\n    }\n};\n\nMap.prototype.click = function(screenX, screenY, state) {\n    this.clickEvent = [screenX, screenY, state];\n};\n\n\nMap.prototype.hover = function(screenX, screenY, persistent, state) {\n    this.hoverEvent = [screenX, screenY, persistent, state];\n};\n\n\nMap.prototype.markDirty = function() {\n    this.dirty = true;\n    this.hitMapDirty = true;\n    this.geoHitMapDirty = true;\n};\n\n\nMap.prototype.getScreenRay = function(screenX, screenY) {\n    return this.renderer.getScreenRay(screenX, screenY);\n};\n\n\nMap.prototype.renderToImage = function(texture) {\n    //var renderer = this.renderer;\n    var canvas = this.renderer.gpu.canvas;\n    var w = canvas.width;\n    var h = canvas.height;\n    var w2 = utils.fitToPowerOfTwo(w);\n    var h2 = utils.fitToPowerOfTwo(h);\n\n    var data = new Uint8Array( w2 * h2 * 4 );\n\n    var texture = new GpuTexture(this.renderer.gpu);\n    texture.createFromData(w2, h2, data);\n    texture.createFramebuffer(w2, h2);\n\n    this.draw.drawToTexture(texture);\n\n    data = texture.readFramebufferPixels(0, 0, w, h);\n\n    texture.kill();\n\n    //flip vertically\n    var data2 = new Uint8Array( w * h * 4 );\n    for (var y = 0; y < h; y++) {\n        var index = y * w * 4;\n        var index2 = (h - y - 1) * w * 4; \n\n        for (var x = 0; x < w; x++) {\n            data2[index2] = data[index];\n            data2[index2+1] = data[index+1];\n            data2[index2+2] = data[index+2];\n            data2[index2+3] = data[index+3];\n            index += 4;\n            index2 += 4;\n        }\n    }\n\n    return { 'width': w, 'height': h, 'data': data2};\n};\n\n\nMap.prototype.getHitCoords = function(screenX, screenY, mode, lod) {\n    if (this.hitMapDirty) {\n        this.draw.drawHitmap();\n    }\n\n    var cameraSpaceCoords = this.renderer.hitTest(screenX, screenY);\n    \n    var fallbackUsed = false; \n    var cameraPos = this.camera.position;\n    var worldPos;\n\n    var ray = cameraSpaceCoords[4], a, d;\n\n    if (this.getNavigationSrs().isProjected()) { //plane fallback\n        var planePos = [0,0,Math.min(-1000,this.referenceFrame.getGlobalHeightRange()[0])];\n        var planeNormal = [0,0,1];\n\n        d = vec3.dot(planeNormal, ray); //minification is wrong there\n        //if (d > 1e-6) {\n        a = [planePos[0] - cameraPos[0], planePos[1] - cameraPos[1], planePos[2] - cameraPos[2]];\n        t = vec3.dot(a, planeNormal) / d;\n            \n            //var t = (vec3.dot(cameraPos, planeNormal) + (-500)) / d;            \n        if (t >= 0) {\n            if (!cameraSpaceCoords[3] || t < cameraSpaceCoords[5]) {\n                worldPos = [ (ray[0] * t) + cameraPos[0],\n                    (ray[1] * t) + cameraPos[1],\n                    (ray[2] * t) + cameraPos[2] ];\n    \n                fallbackUsed = true;\n            }\n        }\n        //}\n\n    } else /*if (false)*/ { //elipsoid fallback\n        var navigationSrsInfo = this.getNavigationSrs().getSrsInfo();\n        var planetRadius = navigationSrsInfo['b'] + this.referenceFrame.getGlobalHeightRange()[0];\n    \n        var offset = [cameraPos[0], cameraPos[1], cameraPos[2]];\n        a = vec3.dot(ray, ray); //minification is wrong there\n        var b = 2 * vec3.dot(ray, offset);\n        var c = vec3.dot(offset, offset) - planetRadius * planetRadius;\n        d = b * b - 4 * a * c;\n        \n        if (d > 0) {\n            d = Math.sqrt(d);\n            var t1 = (-b - d) / (2*a);\n            var t2 = (-b + d) / (2*a);\n            var t = (t1 < t2) ? t1 : t2;\n\n            //console.log(\"hit: \" + t + \",   \" + cameraSpaceCoords[5]);\n            \n            if (!cameraSpaceCoords[3] || t < cameraSpaceCoords[5]) {\n                worldPos = [ (ray[0] * t) + cameraPos[0],\n                    (ray[1] * t) + cameraPos[1],\n                    (ray[2] * t) + cameraPos[2] ];\n\n                fallbackUsed = true;\n            }\n        }   \n    }\n    \n    if (!cameraSpaceCoords[3] && !fallbackUsed) {\n        return null;\n    }\n    \n    if (!fallbackUsed) {\n        worldPos = [ cameraSpaceCoords[0] + cameraPos[0],\n            cameraSpaceCoords[1] + cameraPos[1],\n            cameraSpaceCoords[2] + cameraPos[2] ];\n    }\n\n    var navCoords = this.convert.convertCoords(worldPos, 'physical', 'navigation');\n\n    if (mode == 'float') {\n        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(navCoords, 100, this.config.mapNavSamplesPerViewExtent);\n        var surfaceHeight = this.measure.getSurfaceHeight(navCoords, lod);\n        navCoords[2] -= surfaceHeight[0]; \n    }\n\n    return navCoords;\n};\n\n\nMap.prototype.hitTestGeoLayers = function(screenX, screenY, mode) {\n    if (this.geoHitMapDirty) {\n        if (this.freeLayersHaveGeodata) {\n            this.draw.drawGeodataHitmap();\n        }\n    }\n\n    if (!this.freeLayersHaveGeodata) {\n        this.lastHoverFeature = null;\n        this.lastHoverFeatureId = null;\n        this.hoverFeature = null;\n        this.hoverFeatureId = null;\n\n        return [null, false, []];\n    }\n\n    var res = this.renderer.hitTestGeoLayers(screenX, screenY);\n    var relatedEvents, elementIndex;\n\n    if (res[0]) { //do we hit something?\n        //console.log(JSON.stringify([id, JSON.stringify(this.hoverFeatureList[id])]));\n       \n        var id = (res[1]) + (res[2]<<8);\n\t\t\n        var feature = this.hoverFeatureList[id];\n\n        if (!feature) {\n            return [null, false, [], elementIndex];\n        }\n\n        if (feature[6]) { //advanced hit feature?\n            res = this.renderer.hitTestGeoLayers(screenX, screenY, true);\n        \n            if (res[0]) { //do we hit something?\n                elementIndex = (res[1]) + (res[2]<<8);\n            }\n        }\n\n        if (mode == 'hover') {\n            this.lastHoverFeature = this.hoverFeature;\n            this.lastHoverFeatureId = this.hoverFeatureId;\n            \n            if (feature && feature[3]) {\n                this.hoverFeature = feature;\n                this.hoverFeatureId = (feature != null) ? feature[0]['#id'] : null;\n            } else {\n                this.hoverFeature = null;\n                this.hoverFeatureId = null;\n            }\n\n            relatedEvents = [];\n\n            if (this.hoverFeatureId != this.lastHoverFeatureId) {\n                if (this.lastHoverFeatureId != null) {\n                    relatedEvents.push(['leave', this.lastHoverFeature, this.lastHoverFeatureId]);\n                }\n\n                if (this.hoverFeatureId != null) {\n                    relatedEvents.push(['enter', this.hoverFeature, this.hoverFeatureId]);\n                }\n\n                this.dirty = true;\n            }\n\n            if (this.hoverFeature != null && this.hoverFeature[3]) {\n                return [this.hoverFeature, true, relatedEvents, elementIndex];\n            } else {\n                return [null, false, relatedEvents, elementIndex];\n            }\n        }\n\n        if (mode == 'click') {\n            if (feature != null && feature[2]) {\n                return [feature, true, [], elementIndex];\n            } else {\n                return [null, false, [], elementIndex];\n            }\n        }\n    } else {\n        relatedEvents = [];\n\n        if (mode == 'hover') {\n            this.lastHoverFeature = this.hoverFeature;\n            this.lastHoverFeatureId = this.hoverFeatureId;\n            this.hoverFeature = null;\n            this.hoverFeatureId = null;\n\n            if (this.lastHoverFeatureId != null) {\n                if (this.lastHoverFeatureId != null) {\n                    relatedEvents.push(['leave', this.lastHoverFeature, this.lastHoverFeatureId]);\n                }\n\n                this.dirty = true;\n            }\n        }\n\n        return [null, false, relatedEvents, elementIndex];\n    }\n};\n\nMap.prototype.getCurrentGeometry = function() {\n    if (this.draw.tree.surfaceSequence.length > 0) {\n        this.draw.tree.draw(true);\n        var res = this.storedTilesRes;\n        this.storedTilesRes = [];\n        return res;\n    }\n\n    return res;\n};\n\nMap.prototype.applyCredits = function(tile) {\n    var value, value2;\n    for (var key in tile.imageryCredits) {\n        value = tile.imageryCredits[key];\n        value2 = this.visibleCredits.imagery[key];\n\n        if (value2) {\n            this.visibleCredits.imagery[key] = value > value2 ? value : value2;\n        } else {\n            this.visibleCredits.imagery[key] = value;\n        }\n    }\n    for (key in tile.glueImageryCredits) {\n        value = tile.glueImageryCredits[key];\n        value2 = this.visibleCredits.imagery[key];\n\n        if (value2) {\n            this.visibleCredits.glueImagery[key] = value > value2 ? value : value2;\n        } else {\n            this.visibleCredits.glueImagery[key] = value;\n        }\n    }\n    for (key in tile.mapdataCredits) {\n        value = tile.mapdataCredits[key];\n        value2 = this.visibleCredits.mapdata[key];\n\n        if (value2) {\n            this.visibleCredits.mapdata[key] = value > value2 ? value : value2;\n        } else {\n            this.visibleCredits.mapdata[key] = value;\n        }\n    }\n    \n    /*if (this.drawBBoxes) {\n        console.log(JSON.stringify(tile.id) + \" \" + JSON.stringify(this.visibleCredits));\n    }*/\n};\n\n\nMap.prototype.drawMap = function() {\n    this.draw.drawMap(null);\n};\n\n\nMap.prototype.processProcessingTasks = function() {\n    while (this.processingTasks.length > 0) {\n        if (this.stats.renderBuild > this.config.mapMaxProcessingTime) {\n            this.markDirty();\n            return;\n        }\n\n        this.processingTasks[0]();\n        this.processingTasks.shift();\n    }\n\n    while (this.processingTasks2.length > 0) {\n        if (this.processingTasks2[0]() != -123) {\n            this.processingTasks2.shift();\n        } else {\n            break;\n        }\n    }\n\n};\n\n\nMap.prototype.addProcessingTask = function(task) {\n    this.processingTasks.push(task);\n};\n\nMap.prototype.addProcessingTask2 = function(task) {\n    this.processingTasks2.push(task);\n};\n\n\nMap.prototype.update = function() {\n    if (this.killed) {\n        return;\n    }\n\n    if (this.core.tokenExpiration) {\n        if (Date.now() > (this.core.tokenExpiration - (1000*60))) {\n            this.core.tokenExpirationCallback();\n        }\n    }\n\n    if (!this.srsReady) {\n        this.loader.update();\n        return;\n    }\n\n    if (this.div && this.div.style.visibility == 'hidden'){\n        //loop heartbeat\n        //window.requestAnimFrame(this.update.bind(this));\n        return;\n    }\n\n    if (!this.position.isSame(this.lastPosition)) {\n        this.core.callListener('map-position-changed', {'position':this.position.toArray(), 'last-position':this.lastPosition.toArray()});\n    }\n\n    if (this.camera.lastTerrainHeight != this.camera.terrainHeight) {\n        this.core.callListener('map-position-fixed-height-changed', {'height':this.camera.terrainHeight, 'last-height':this.camera.lastTerrainHeight});\n    }\n\n    this.lastPosition = this.position.clone();\n    this.camera.lastTerrainHeight = this.camera.terrainHeight;\n    this.drawFog = this.config.mapFog;\n\n    var rect = this.renderer.div.getBoundingClientRect();\n    var renderer = this.renderer, p;\n    var camPos = renderer.cameraPosition;\n\n    if (renderer.curSize[0] != rect.width || renderer.curSize[1] != rect.height) {\n        renderer.onResize();\n        this.dirty = true;\n    }\n\n    var dirty = (this.dirty || this.dirtyCountdown > 0), result;\n    this.stats.begin(dirty);\n\n    this.loader.update();\n\n    this.processProcessingTasks();\n\n    if (dirty) {\n        if (this.dirty) {\n            this.dirtyCountdown = this.config.mapRefreshCycles;\n        } else {\n            this.dirtyCountdown--;\n        }\n\n        this.dirty = false;\n        this.bestMeshTexelSize = 0;//Number.MAX_VALUE;\n        this.bestGeodataTexelSize = 0;//Number.MAX_VALUE;\n        \n        this.renderSlots.processRenderSlots();\n\n        this.loader.update();\n        \n        this.core.callListener('map-update', {});\n\n        //this.renderer.gpu.setState(this.drawTileState);\n        //this.renderer.gpu.gl.disable(this.renderer.gpu.gl.BLEND);\n        //this.renderer.drawImage(300, 0, 256, 256, this.renderer.hitmapTexture, null, null, null, null, false);\n        //this.renderer.drawImage(558, 0, 256, 256, this.renderer.hitmapTexture, null, null, null, null, false);\n\n        //console.log(\"\" + this.stats.gpuRenderUsed);\n    }\n\n    //hover and click events\n    if (this.clickEvent != null || this.hoverEvent != null) {\n        //this.updateGeoHitmap = this.dirty;\n\n        if (this.hoverEvent != null) {\n            result = this.hitTestGeoLayers(this.hoverEvent[0], this.hoverEvent[1], 'hover');\n\n            var relatedEvents = result[2];\n\n            if (relatedEvents != null) {\n                for(var i = 0, li = relatedEvents.length; i < li; i++) {\n                    var event = relatedEvents[i];\n\n                    switch(event[0]) {\n                    case 'enter':\n                        p = event[1][1];\n                        this.core.callListener('geo-feature-enter', {'feature': event[1][0], 'canvas-coords':renderer.project2(event[1][1], renderer.camera.mvp, camPos),\n                            'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3] });\n                        break;\n\n                    case 'leave':\n                        p = event[1][1];\n                        this.core.callListener('geo-feature-leave', {'feature':event[1][0], 'canvas-coords':renderer.project2(event[1][1], renderer.camera.mvp, camPos),\n                            'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3] });\n                        break;\n                    }\n                }\n            }\n\n            if (result[1] && result[0] != null) {\n                p = result[0][1];\n                this.core.callListener('geo-feature-hover', {'feature': result[0][0], 'canvas-coords':renderer.project2(result[0][1], renderer.camera.mvp, camPos),\n                    'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3]});\n            }\n\n            //is it persistent event?\n            if (this.hoverEvent[2] !== true) {\n                this.hoverEvent = null;\n            }\n        }\n\n        if (this.clickEvent != null) {\n            result = this.hitTestGeoLayers(this.clickEvent[0], this.clickEvent[1], 'click');\n\n            if (result[1] && result[0] != null) {\n                p = result[0][1];\n                this.core.callListener('geo-feature-click', {'feature': result[0][0], 'canvas-coords':renderer.project2(result[0][1], renderer.camera.mvp, camPos),\n                    'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.clickEvent[2], 'element': result[3] });\n            }\n\n            this.clickEvent = null;\n        }\n\n    }\n\n\n    this.stats.end(dirty);\n};\n\nexport default Map;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/map.js\n// module id = 140\n// module chunks = 0 1","\nimport {vec3 as vec3_, mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport GeographicLib_ from 'geographiclib';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat4 = mat4_;\nvar math = math_;\nvar GeographicLib = GeographicLib_;\n\n\nvar MapMeasure = function(map) {\n    this.map = map;\n    this.config = map.config;\n    this.convert = map.convert;\n    this.getPhysicalSrs = this.map.getPhysicalSrs();\n    this.navigationSrs = this.map.getNavigationSrs();\n    this.publicSrs = this.map.getPublicSrs();\n    this.navigationSrsInfo = this.navigationSrs.getSrsInfo();\n    this.isProjected = this.navigationSrs.isProjected();\n\n    var res = this.getSpatialDivisionNodeDepths();\n\n    this.minDivisionNodeDepth = res[0];\n    this.maxDivisionNodeDepth = res[1];\n};\n\nMapMeasure.prototype.getSurfaceAreaGeometry = function(coords, radius, mode, limit, loadMeshes, loadTextures) {\n    var tree = this.map.tree;\n\n    if (tree.surfaceSequence.length == 0) {\n        reurn [true, []];\n    }\n\n    var center = this.convert.convertCoords(coords, 'navigation', 'physical');\n    var coneVec = [0,0,0];\n\n    vec3.normalize(center, coneVec);\n\n    var distance = vec3.length(center);\n    var coneAngle = Math.atan(Math.tan(radius / distance));\n\n    tree.params = {\n        coneVec : coneVec,\n        coneAngle : coneAngle,\n        mode : mode,\n        limit : limit,\n        loaded : true,\n        areaTiles : [],\n        loadMeshes: (loadMeshes === true),\n        loadTextures: (loadTextures === true)\n    };\n\n    //priority = 0, noReadInly = false\n    tree.traceAreaTiles(tree.surfaceTree, 0, false);\n\n    return [tree.params.loaded, tree.params.areaTiles];\n};\n\nMapMeasure.prototype.getSurfaceHeight = function(coords, lod, storeStats, node, nodeCoords, coordsArray, useNodeOnly) {\n    var tree = this.map.tree;\n\n    if (tree.surfaceSequence.length == 0) {\n        return [0, true, true, null, null, null];\n    }\n\n    if (!node) {\n        var result = this.getSpatialDivisionNode(coords);\n        node = result[0];\n        nodeCoords = result[1];\n    }\n    \n    if (!this.config.mapHeightLodBlend) {\n        lod = Math.floor(lod);\n    }\n\n    if (useNodeOnly || this.config.mapIgnoreNavtiles) {\n        return this.getSurfaceHeightNodeOnly(null, lod + 8, storeStats, lod, null, node, nodeCoords, coordsArray);        \n    }\n\n    if (node != null && lod !== null) {\n        var root = tree.findSurfaceTile(node.id);\n\n        var extents = {\n            ll : node.extents.ll.slice(),\n            ur : node.extents.ur.slice()\n        };\n        var params = {\n            coords : nodeCoords,\n            desiredLod : Math.ceil(lod),\n            extents : extents,\n            metanode : null,\n            heightMap : null,\n            heightMapExtents : null,\n            traceHeight : true,\n            waitingForNode : false,\n            finalNode : false,\n            bestHeightMap : 999\n        };\n\n        tree.traceHeight(root, params, false);\n\n        var metanode = params.metanode, i, li, height;\n\n        if (params.heightMap) {\n            if (storeStats) {\n                var stats = this.map.stats;\n                stats.heightClass = 2;\n                stats.heightLod = lod;\n                stats.heightNode = metanode.id[0];                        \n            }\n            \n            var res = metanode.id[0] >= Math.ceil(lod);\n            var arrayRes, height1, height2;\n           \n            if (this.config.mapHeightLodBlend && metanode.id[0] > 0 &&\n                params.parent && params.parent.heightMap && lod <= metanode.id[0]) {\n                height1 = this.getHeightmapValue(nodeCoords, params.parent.metanode, params.parent);  \n                height2 = this.getHeightmapValue(nodeCoords, metanode, params);  \n                var factor = lod - Math.floor(lod);\n                height = height1 + (height2 - height1) * factor;\n\n                if (coordsArray) {\n                    arrayRes = new Array(coordsArray.length);\n                    \n                    for (i = 0, li = coordsArray.length; i < li; i++) {\n                        var nodeCoords2 = coordsArray[i];//node.getInnerCoords(coordsArray[i]);\n                        height1 = this.getHeightmapValue(nodeCoords2, params.parent.metanode, params.parent);  \n                        height2 = this.getHeightmapValue(nodeCoords2, metanode, params);  \n\n                        arrayRes[i] = [height1 + (height2 - height1) * factor, res, true];\n                    }\n                }\n                \n                //console.log(\"lod: \" + lod + \" h1: \" + height1 + \" h2: \" + height2 + \" h: \" + height);  \n            } else {\n                height = this.getHeightmapValue(nodeCoords, metanode, params);  \n\n                if (coordsArray) {\n                    arrayRes = new Array(coordsArray.length);\n                    \n                    for (i = 0, li = coordsArray.length; i < li; i++) {\n                        height2 = this.getHeightmapValue(coordsArray[i], metanode, params);  \n\n                        arrayRes[i] = [height2, res, true];\n                    }\n                }\n            }\n\n            return [height, res, true, null, null, arrayRes];\n\n        } else if (metanode /*&& metanode.id[0] == lod && !metanode.hasNavtile()*/){\n            res = this.getSurfaceHeightNodeOnly(coords, lod + 8, storeStats, lod, null, node, nodeCoords, coordsArray);\n\n            //console.log(\"lod2: \" + lod + \" h: \" + height[0]);  \n            //return [res[0], res[1], true, null, null, res[5]];\n\n            return [res[0], res[1], res[2], null, null, res[5]];\n        }\n\n        /*\n        if (metanode != null) {\n            var height = metanode.minHeight + (metanode.maxHeight - metanode.minHeight) * 0.5;\n            return [height, metanode.id[0] >= lod, true];\n        }*/\n    }\n\n    return [0, false, false, null, null, null];\n};\n\n\nMapMeasure.prototype.getSurfaceHeightNodeOnly = function(coords, lod, storeStats, statsLod, deltaSample, node, nodeCoords, coordsArray) {\n    var arrayRes, height, stats = this.map.stats; \n\n    var tree = this.map.tree;\n\n    if (tree.surfaceSequence.length == 0) {\n        return [0, true, true, null, null, null];\n    }\n    \n    if (!deltaSample) {\n        if (!node) {\n            var result = this.getSpatialDivisionNode(coords);\n            node = result[0];\n            nodeCoords = result[1];\n        }\n        \n        if (coordsArray) {\n            arrayRes = new Array(coordsArray.length);\n            \n            for (var i = 0, li = coordsArray.length; i < li; i++) {\n                arrayRes[i] = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, deltaSample, node, coordsArray[i]);\n            }\n        }\n        \n    } else {\n        node = deltaSample[0];\n        nodeCoords = deltaSample[1];\n    }\n\n    if (!this.config.mapHeightLodBlend) {\n        lod = Math.floor(lod);\n    }\n\n    if (!deltaSample && this.config.mapHeightNodeBlend) {\n        var res1 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0], nodeCoords[1], nodeCoords[2]]]);\n        \n        if (res1[2]) {\n            var sx = res1[3].ur[0] - res1[3].ll[0];\n            var sy = res1[3].ur[1] - res1[3].ll[1];\n            \n            var fx = (nodeCoords[0] - res1[3].ll[0]) / sx;\n            var fy = (nodeCoords[1] - res1[3].ll[1]) / sy;\n            \n            /*\n            var c2 = node.getOuterCoords([nodeCoords[0] + sx, nodeCoords[1], nodeCoords[2]]);\n            var c3 = node.getOuterCoords([nodeCoords[0], nodeCoords[1] + sy, nodeCoords[2]]);\n            var c4 = node.getOuterCoords([nodeCoords[0] + sx, nodeCoords[1] + sy, nodeCoords[2]]);\n    \n            var res2 = this.getSurfaceHeightNodeOnly(c2, lod, storeStats, statsLod, true);\n            var res3 = this.getSurfaceHeightNodeOnly(c3, lod, storeStats, statsLod, true);\n            var res4 = this.getSurfaceHeightNodeOnly(c4, lod, storeStats, statsLod, true);\n            */\n            \n            var res2 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0] + sx, nodeCoords[1], nodeCoords[2]]]);\n            var res3 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0], nodeCoords[1] + sy, nodeCoords[2]]]);\n            var res4 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0] + sx, nodeCoords[1] + sy, nodeCoords[2]]]);\n\n            var w0 = (res1[0] + (res2[0] - res1[0])*fx);\n            var w1 = (res3[0] + (res4[0] - res3[0])*fx);\n            height = (w0 + (w1 - w0)*fy);\n            \n            //console.log(\"h: \" + height + \"fx: \" + fx + \"fy: \" + fy + \"s1234: \" + res1[0] + \" \"  + res2[0] + \" \"  + res3[0] + \" \"  + res4[0]);            \n            /*\n            if (res1[4] && res2[4] && res3[4] && res4[4]){\n                console.log(\"h: \" + height + \"fx: \" + fx + \"fy: \" + fy + \"s1234: \" + JSON.stringify(res1[4].id) + \" \"  + JSON.stringify(res2[4].id) + \" \"  + JSON.stringify(res3[4].id) + \" \"  + JSON.stringify(res4[4].id));            \n            }*/\n\n            return [height, res1[1], res1[2], res1[3], null, arrayRes];                \n        } else {\n            return [res1[0], res1[1], res1[2], res1[3], null, arrayRes];                \n        }\n        //convert new coords to nav coords\n        //blend values\n    }\n\n    if (node != null && lod !== null) {\n        var root = tree.findSurfaceTile(node.id);\n\n        var extents = {\n            ll : node.extents.ll.slice(),\n            ur : node.extents.ur.slice()\n        };\n        var params = {\n            coords : nodeCoords,\n            desiredLod : Math.ceil(lod),\n            extents : extents,\n            metanode : null,\n            heightMap : null,\n            heightMapExtents : null,\n            traceHeight : true,\n            waitingForNode : false,\n            finalNode : false,\n            bestHeightMap : 999\n        };\n\n        tree.traceHeight(root, params, true);\n\n        var metanode = params.metanode;\n\n        if (metanode != null) { // && metanode.id[0] == lod){\n            var center = metanode.bbox.center();\n            center = this.convert.convertCoords(center, 'physical', 'navigation');\n\n            //console.log(\"lod2: \" + lod + \" nodelod: \" + metanode.id[0] + \" h: \" + center[2]/1.55);  \n\n            if (storeStats) {\n                stats.heightClass = 1;\n                stats.heightLod = statsLod;\n                stats.heightNode = metanode.id[0];                        \n            }\n\n            if (this.config.mapHeightLodBlend && metanode.id[0] > 0 &&\n                params.parent && params.parent.metanode) {\n                var center2 = this.convert.convertCoords(params.parent.metanode.bbox.center(), 'physical', 'navigation');\n\n                var factor = lod - Math.floor(lod);\n                height = center[2] + (center2[2] - center[2]) * factor;\n               \n                //extetnts = params.extents;\n                //return [height, true, true, params.extents, metanode, arrayRes];\n\n                return [height, (metanode.id[0] >= Math.floor(lod) || params.finalNode), \n                        (!params.waitingForNode || metanode.id[0] >= Math.floor(lod) || params.finalNode),\n                        params.extents, metanode, arrayRes];\n                                      \n\n                //console.log(\"lod: \" + lod + \" h1: \" + center[2] + \" h2: \" + center2[2] + \" h: \" + height);  \n            } else {\n                return [center[2], (metanode.id[0] >= Math.floor(lod) || params.finalNode), \n                        (!params.waitingForNode || metanode.id[0] >= Math.floor(lod) || params.finalNode),\n                        params.extents, metanode, arrayRes];\n\n                //return [center[2], true, true, params.extents, metanode, arrayRes];\n            }\n        }\n\n        /*\n        if (metanode != null) {\n            var height = metanode.minHeight + (metanode.maxHeight - metanode.minHeight) * 0.5;\n            return [height, metanode.id[0] >= lod, true];\n        }*/\n    }\n\n    //coords\n    //console.log(\"lod3: \" + lod + \" h: 0\");  \n\n    if (storeStats) {\n        stats.heightClass = 0;\n        stats.heightLod = statsLod;\n        stats.heightNode = 0;                        \n    }\n\n\n    return [0, false, false, null, null, arrayRes];\n};\n\n\nMapMeasure.prototype.getHeightmapValue = function(coords, node, params) {\n    var heightMap = params.heightMap;\n    var data = heightMap.getImageData();\n    var dataExtents = heightMap.getImageExtents();\n    var mapExtents = params.heightMapExtents;\n\n    //relative tile coords\n    var x = coords[0] - mapExtents.ll[0];\n    //var y = nodeCoords[1] - mapExtents.ll[1];\n    var y = mapExtents.ur[1] - coords[1];\n\n    var maxX = (dataExtents[0]-1);\n    var maxY = (dataExtents[1]-1);\n    \n    //data coords\n    x = (maxX) * (x / (mapExtents.ur[0] - mapExtents.ll[0]));\n    y = (maxY) * (y / (mapExtents.ur[1] - mapExtents.ll[1]));\n\n    if (x < 0) { x = 0; }\n    if (y < 0) { y = 0; }\n    if (x > maxX) { x = maxX; }\n    if (y > maxY) { y = maxY; }\n\n    var ix = Math.floor(x);\n    var iy = Math.floor(y);\n    var fx = x - ix;\n    var fy = y - iy;\n\n    var index = iy * dataExtents[0];\n    var index2 = (iy == maxY) ? index : index + dataExtents[0];\n    var ix2 = (ix == maxX) ? ix : ix + 1; \n    var h00 = data[(index + ix)*4];\n    var h01 = data[(index + ix2)*4];\n    var h10 = data[(index2 + ix)*4];\n    var h11 = data[(index2 + ix2)*4];\n    var w0 = (h00 + (h01 - h00)*fx);\n    var w1 = (h10 + (h11 - h10)*fx);\n    var height = (w0 + (w1 - w0)*fy);\n\n    height = node.minHeight + (node.maxHeight - node.minHeight) * (height/255);\n    \n    return height;\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNode = function(coords) {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n\n    var bestNode = null;\n    var bestLod = -1;\n    var bestCoords = [0,0];\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i];\n        var nodeCoords = node.getInnerCoords(coords);\n        var extents = node.extents;\n\n        if (nodeCoords[0] >= extents.ll[0] && nodeCoords[0] <= extents.ur[0] &&\n            nodeCoords[1] >= extents.ll[1] && nodeCoords[1] <= extents.ur[1]) {\n\n            if (node.id[0] > bestLod) {\n                bestNode = node;\n                bestLod = node.id[0];\n                bestCoords = nodeCoords;\n            }\n        }\n    }\n\n    return [bestNode, bestCoords];\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNodeAndExtents = function(id) {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n\n    var bestNode = null;\n    //var bestLod = -1;\n    var bestNodeCoords = [0,0], shift;\n    //var bestExtents = {ll:[0,0], ur:[1,1]};\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i];\n        \n        //has division node this tile node \n        //var shift = node.id[0] - this.lodRange[0];\n        shift = id[0] - node.id[0];\n\n        if (shift >= 0) {\n            var x = id[1] >> shift;\n            var y = id[2] >> shift;\n            \n            if (node.id[1] == x && node.id[2] == y) {\n                bestNode = node;\n                //bestLod = node.id[0];\n                //bestExtents = node.extents;\n                bestNodeCoords = [node.id[1] << shift, node.id[2] << shift];                \n            }\n        }\n    }\n    \n    if (!bestNode) {\n        return null;\n    }\n    \n    shift = id[0] - bestNode.id[0];\n    \n    var factor = 1.0 / Math.pow(2, shift);\n    var ur = bestNode.extents.ur;\n    var ll = bestNode.extents.ll;\n    \n    //extents ll ur but tiles are ul lr!!!! \n    \n    var dx = (ur[0] - ll[0]) * factor; \n    var dy = (ll[1] - ur[1]) * factor;\n    \n    var nx = id[1] - bestNodeCoords[0];\n    var ny = id[2] - bestNodeCoords[1];\n\n    return [bestNode, [[ll[0] + dx * nx, ur[1] + dy * ny], [ll[0] + dx * (nx+1), ur[1] + dy * (ny+1)] ]];\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNodeFromId = function(id) {\n    var shift = id[0] - this.maxDivisionNodeDepth;\n    var nx = id[1] >> shift;\n    var ny = id[2] >> shift;\n    \n    return this.map.referenceFrame.nodesMap['' + this.maxDivisionNodeDepth + '.'  + nx + '.' + ny];\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNodeAndExtents2 = function(id, res, divisionNode) {\n    if (!divisionNode) {\n        return [null, 0,0,0,0];\n    }\n    \n    var shift = id[0] - divisionNode.id[0];\n    var factor = 1.0 / Math.pow(2, shift);\n    var ur = divisionNode.extents.ur;\n    var ll = divisionNode.extents.ll;\n    \n    //extents ll ur but tiles are ul lr!!!! \n    \n    var dx = (ur[0] - ll[0]) * factor; \n    var dy = (ll[1] - ur[1]) * factor;\n    \n    var nx = id[1] - (divisionNode.id[1] << shift);\n    var ny = id[2] - (divisionNode.id[2] << shift);\n    \n    res[0] = divisionNode;\n    res[1] = ll[0] + dx * nx;\n    res[2] = ur[1] + dy * ny;\n    res[3] = ll[0] + dx * (nx+1);\n    res[4] = ur[1] + dy * (ny+1);\n};\n\n\nMapMeasure.prototype.getSpatialDivisionNodeDepths = function() {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n    var maxLod = -1;\n    var minLod = Number.MAX_VALUE;\n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i];\n\n        if (node.id[0] < minLod) {\n            minLod = node.id[0];\n        } \n        \n        if (node.id[0] > maxLod) {\n            maxLod = node.id[0];\n        } \n    }\n\n    return [minLod, maxLod];\n};\n\n\nMapMeasure.prototype.getOptimalHeightLodBySampleSize = function(coords, desiredSamplesSize) {\n    var result = this.getSpatialDivisionNode(coords);\n    var node = result[0];\n\n    if (node != null) {\n        var nodeLod = node.id[0];\n        var nodeExtent = node.extents.ur[1] - node.extents.ll[1];\n\n        var lod = Math.log(nodeExtent / desiredSamplesSize) / Math.log(2);\n        //lod = Math.round(lod) - 8 + nodeLod;\n        lod = lod - 8 + nodeLod;\n\n        return Math.max(0, lod);\n    }\n\n    return null;\n};\n\n\nMapMeasure.prototype.getOptimalHeightLod = function(coords, viewExtent, desiredSamplesPerViewExtent) {\n    var result = this.getSpatialDivisionNode(coords);\n    var node = result[0];\n\n    if (node != null) {\n        var nodeLod = node.id[0];\n        var nodeExtent = node.extents.ur[1] - node.extents.ll[1];\n\n        var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / Math.log(2);\n        //lod = Math.round(lod) - 8 + nodeLod;\n        lod = lod - 8 + nodeLod;\n\n        return Math.max(0, lod);\n    }\n\n    return null;\n};\n\n\nMapMeasure.prototype.getDistance = function(coords, coords2, includingHeight, usePublic) {\n    var sourceSrs = usePublic ? this.publicSrs : this.navigationSrs;\n    var p1 = this.getPhysicalSrs.convertCoordsFrom(coords,  sourceSrs);\n    var p2 = this.getPhysicalSrs.convertCoordsFrom(coords2, sourceSrs);\n    var d = 0;\n\n    var dx = p2[0] - p1[0];\n    var dy = p2[1] - p1[1];\n    var dz = p2[2] - p1[2];\n\n    var dd = Math.sqrt(dx*dx + dy*dy + dz*dz);\n    var navigationSrsInfo = this.navigationSrsInfo;\n\n    if (!this.isProjected) {\n        var geod = this.getGeodesic(); //new GeographicLib[\"Geodesic\"][\"Geodesic\"](navigationSrsInfo[\"a\"],\n                                       //                   (navigationSrsInfo[\"a\"] / navigationSrsInfo[\"b\"]) - 1.0);\n\n        var r = geod.Inverse(coords[1], coords[0], coords2[1], coords2[0]);\n\n        if (r.s12 > (navigationSrsInfo['a'] * 2 * Math.PI) / 4007.5) { //aprox 10km for earth\n            if (includingHeight) {\n                return [Math.sqrt(r.s12*r.s12 + dz*dz), -r.azi1, dd];\n            } else {\n                return [r.s12, -r.azi1, dd];\n            }\n        } else {\n            if (includingHeight) {\n                return [Math.sqrt(dx*dx + dy*dy + dz*dz), -r.azi1, dd];\n            } else {\n                return [r.s12, -r.azi1, dd];\n            }\n        }\n\n    } else {\n        return [Math.sqrt(dx*dx + dy*dy), math.degrees(Math.atan2(dx, dy)), dd];\n    }\n};\n\n\nMapMeasure.prototype.getGeodesic = function() {\n    var navigationSrsInfo = this.navigationSrsInfo;\n\n    var geodesic = new GeographicLib.Geodesic.Geodesic(navigationSrsInfo['a'],\n                                                      (navigationSrsInfo['a'] / navigationSrsInfo['b']) - 1.0);\n\n    return geodesic;\n};\n\n\nMapMeasure.prototype.getAzimuthCorrection = function(coords, coords2) {\n    if (!this.getNavigationSrs().isProjected()) {\n        var geodesic = this.getGeodesic();\n        var r = geodesic.Inverse(coords[0], coords[1], coords2[0], coords2[1]);\n        var ret = (r.azi1 - r.azi2);\n        if (isNaN(ret)) {\n            ret = 0;\n        } \n        return ret; \n    }\n    return 0;\n};\n\n\nMapMeasure.prototype.getNED = function(coords) {\n    var centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');\n    var upCoords, rightCoords;\n\n    if (this.isProjected) {\n        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');\n        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');\n    } else {\n        var cy = (coords[1] + 90) - 0.0001;\n        var cx = (coords[0] + 180) + 0.0001;\n\n        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated\n            var geodesic = this.getGeodesic();\n        \n            //up coords\n            var r = geodesic.Direct(coords[1], coords[0], 0, -100);\n            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');\n    \n            //right coords\n            r = geodesic.Direct(coords[1], coords[0], 90, 100);\n            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');\n        } else {\n            // substraction instead of addition is probably case of complicated view matrix calculation\n            upCoords = this.convert.convertCoords([coords[0], coords[1] - 0.0001, 0], 'navigation', 'physical');\n            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');\n        }\n    }\n\n    var up = [upCoords[0] - centerCoords[0],\n        upCoords[1] - centerCoords[1],\n        upCoords[2] - centerCoords[2]]; \n\n    var right = [rightCoords[0] - centerCoords[0],\n        rightCoords[1] - centerCoords[1],\n        rightCoords[2] - centerCoords[2]]; \n\n    var dir = [0,0,0];\n    vec3.normalize(up);\n    vec3.normalize(right);\n    vec3.cross(up, right, dir);\n    vec3.normalize(dir);\n\n    return {\n        east  : right, \n        direction : up,\n        north : dir        \n    };\n};\n\nMapMeasure.prototype.getNewNED = function(coords, returnMatrix) {\n    var centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');\n    var upCoords, rightCoords;\n\n    if (this.isProjected) {\n        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');\n        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');\n    } else {\n        //get NED for latlon coordinates\n        //http://www.mathworks.com/help/aeroblks/directioncosinematrixeceftoned.html\n        /*        \n        var coords = this.position.getCoords();\n        var lon = math.radians(coords[0]);\n        var lat = math.radians(coords[1]);\n\n        //NED vectors for sphere\n        var east = [-Math.sin(lat)*Math.cos(lon), -Math.sin(lat)*Math.sin(lon), Math.cos(lat)];\n        var direction = [-Math.sin(lon), Math.cos(lon), 0];\n        var north = [-Math.cos(lat)*Math.cos(lon), -Math.cos(lat)*Math.sin(lon), -Math.sin(lat)];\n\n        north = vec3.negate(north);\n        east  = vec3.negate(east);\n        \n        //get elipsoid factor\n        var navigationSrsInfo = this.getNavigationSrs().getSrsInfo();\n        var factor = navigationSrsInfo[\"b\"] / navigationSrsInfo[\"a\"];\n\n        //flaten vectors\n        north[2] *= factor;\n        east[2] *= factor;\n        direction[2] *= factor;\n\n        //normalize vectors\n        north = vec3.normalize(north);\n        east  = vec3.normalize(east);\n        direction = vec3.normalize(direction);\n        */\n\n        var cy = (coords[1] + 90) + 0.0001;\n        var cx = (coords[0] + 180) + 0.0001;\n\n        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated\n            var geodesic = this.getGeodesic();\n        \n            //up coords\n            var r = geodesic.Direct(coords[1], coords[0], 0, -100);\n            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');\n    \n            //right coords\n            r = geodesic.Direct(coords[1], coords[0], 90, -100);\n            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');\n        } else {\n            // substraction instead of addition is probably case of complicated view matrix calculation\n            upCoords = this.convert.convertCoords([coords[0], coords[1] + 0.0001, 0], 'navigation', 'physical');\n            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');\n        }\n    }\n\n    var up = [upCoords[0] - centerCoords[0],\n        upCoords[1] - centerCoords[1],\n        upCoords[2] - centerCoords[2]]; \n\n    var right = [rightCoords[0] - centerCoords[0],\n        rightCoords[1] - centerCoords[1],\n        rightCoords[2] - centerCoords[2]]; \n\n    var dir = [0,0,0];\n    vec3.normalize(up);\n    vec3.normalize(right);\n    vec3.cross(up, right, dir);\n    vec3.normalize(dir);\n\n    if (returnMatrix) {\n        var east = right;\n        var direction = up;\n        var north = dir;\n\n        return [\n            east[0], east[1], east[2], 0,\n            north[0], north[1], north[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            0, 0, 0, 1\n        ];        \n    }\n\n    return {\n        east  : right, \n        direction : up,\n        north : dir        \n    };\n};\n\n//TODO: use getNewNED \nMapMeasure.prototype.getPositionCameraInfo = function(position, projected, clampTilt) {\n    //var position = [0,0,0];\n    var orientation = position.getOrientation();\n    var distance = position.getViewDistance();\n    \n    if (clampTilt) { //used for street labels\n        orientation[1] = math.clamp(orientation[1], -89.0, 90.0);\n    }\n\n    var roty = math.clamp(orientation[1], -89.5, 89.5);\n\n    var tmpMatrix = mat4.create();\n    mat4.multiply(math.rotationMatrix(2, math.radians(-orientation[0])), math.rotationMatrix(0, math.radians(roty)), tmpMatrix);\n    var orbitPos, ned, north, east, direction, spaceMatrix, rotationMatrix;\n    var east2, north2, direction2, dir, up, right;\n\n    if (position.getViewMode() == 'obj') {\n        orbitPos = [0, -distance, 0];\n        mat4.multiplyVec3(tmpMatrix, orbitPos);\n    } else {\n        orbitPos = [0, 0, 0];\n    }\n\n    //this.cameraVector = [0, 0, 1];\n    //mat4.multiplyVec3(this.updateCameraMatrix, this.cameraVector);\n\n    var ret = {\n        orbitCoords : null,\n        distance : distance,\n        rotMatrix : null,\n        vector : null,\n        orbitHeight : orbitPos[2]  \n    };\n\n    var coords = position.getCoords();\n\n    if (projected) {\n        \n        tmpMatrix = mat4.create();\n        mat4.multiply(math.rotationMatrix(0, math.radians(-roty - 90.0)), math.rotationMatrix(2, math.radians(orientation[0])), tmpMatrix);\n\n        ned = this.getNED(coords);\n        north = ned.north;\n        east  = ned.east;\n        direction = ned.direction;\n\n        spaceMatrix = [\n            east[0], east[1], east[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            north[0], north[1], north[2], 0,\n            0, 0, 0, 1\n        ];\n        \n        east2  = [1,0,0];\n        direction2 = [0,1,0];\n        north2 = [0,0,1];\n\n        dir = [1,0,0];\n        up = [0,0,-1];\n        right = [0,0,0];\n        vec3.cross(dir, up, right);\n\n        //rotate vectors according to eulers\n        mat4.multiplyVec3(tmpMatrix, north2);\n        mat4.multiplyVec3(tmpMatrix, east2);\n        mat4.multiplyVec3(tmpMatrix, direction2);\n\n        mat4.multiplyVec3(tmpMatrix, dir);\n        mat4.multiplyVec3(tmpMatrix, up);\n        mat4.multiplyVec3(tmpMatrix, right);\n\n        var t = 0;\n        t = dir[0]; dir[0] = dir[1]; dir[1] = t;\n        t = up[0]; up[0] = up[1]; up[1] = t;\n        t = right[0]; right[0] = right[1]; right[1] = t;\n        \n        dir[2] = -dir[2];\n        up[2] = -up[2];\n        right[2] = -right[2];\n\n        /*\n        mat4.multiplyVec3(spaceMatrix, north2);\n        mat4.multiplyVec3(spaceMatrix, east2);\n        mat4.multiplyVec3(spaceMatrix, direction2);\n        */\n\n        //get rotation matrix\n        rotationMatrix = [\n            east2[0], east2[1], east2[2], 0,\n            direction2[0], direction2[1], direction2[2], 0,\n            north2[0], north2[1], north2[2], 0,\n            0, 0, 0, 1\n        ];\n\n       // mat4.multiplyVec3(spaceMatrix, orbitPos);\n/*\n        //get rotation matrix\n        var rotationMatrix = [\n            east[0], east[1], east[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            north[0], north[1], north[2], 0,\n            0, 0, 0, 1\n        ];\n*/\n        ret.vector = vec3.normalize([-orbitPos[0], -orbitPos[1], -orbitPos[2]]); \n        ret.vector2 = ret.vector; //vector2 is probably hack for tree.js bboxVisible \n        \n        ret.orbitCoords = orbitPos;\n        ret.rotMatrix = rotationMatrix; \n\n    } else { //geographics\n\n      \n        ned = this.getNED(coords);\n        north = ned.north;\n        east  = ned.east;\n        direction = ned.direction;\n        \n\n        spaceMatrix = [\n            east[0], east[1], east[2], 0,\n            direction[0], direction[1], direction[2], 0,\n            north[0], north[1], north[2], 0,\n            0, 0, 0, 1\n        ];\n        \n        //spaceMatrix = mat4.inverse(spaceMatrix);\n        \n        var localRotMatrix = mat4.create();\n        mat4.multiply(math.rotationMatrix(0, math.radians(-roty - 90.0)), math.rotationMatrix(2, math.radians(orientation[0])), localRotMatrix);\n\n        east2  = [1,0,0];\n        direction2 = [0,1,0];\n        north2 = [0,0,1];\n\n        coords = position.getCoords();\n        var latlonMatrix = mat4.create();\n        mat4.multiply(math.rotationMatrix(0, math.radians((coords[1] - 90.0))), math.rotationMatrix(2, math.radians((-coords[0]-90))), latlonMatrix);\n//      mat4.multiply(math.rotationMatrix(2, math.radians((coords[0]-90))), math.rotationMatrix(0, math.radians((coords[1] - 90.0))), latlonMatrix);\n\n\n        //mat4.multiply(math.rotationMatrix(0, math.radians(0)), math.rotationMatrix(2, math.radians(-(coords[0]+90))), latlonMatrix);\n        //mat4.multiply(math.rotationMatrix(0, math.radians(0)), math.rotationMatrix(2, math.radians(0)), latlonMatrix);\n\n        //rotate vectors according to latlon\n        mat4.multiplyVec3(latlonMatrix, north2);\n        mat4.multiplyVec3(latlonMatrix, east2);\n        mat4.multiplyVec3(latlonMatrix, direction2);\n\n\n        spaceMatrix = [\n            east2[0], east2[1], east2[2], 0,\n            direction2[0], direction2[1], direction2[2], 0,\n            north2[0], north2[1], north2[2], 0,\n            0, 0, 0, 1\n        ];\n\n        right = [1,0,0];\n        dir = [0,1,0];\n        up = [0,0,1];\n        //vec3.cross(dir, up, right);\n\n        //rotate vectors according to eulers\n        //mat4.multiplyVec3(this.updateCameraMatrix, north2);\n        //mat4.multiplyVec3(this.updateCameraMatrix, east2);\n        //mat4.multiplyVec3(this.updateCameraMatrix, direction2);\n\n        mat4.multiplyVec3(spaceMatrix, dir);\n        mat4.multiplyVec3(spaceMatrix, up);\n        mat4.multiplyVec3(spaceMatrix, right);\n\n        mat4.multiplyVec3(localRotMatrix, right);\n        mat4.multiplyVec3(localRotMatrix, dir);\n        mat4.multiplyVec3(localRotMatrix, up);\n        \n        //mat4.multiplyVec3(spaceMatrix, north2);\n        //mat4.multiplyVec3(spaceMatrix, east2);\n        //mat4.multiplyVec3(spaceMatrix, direction2);\n\n\n        //get rotation matrix\n/*        \n        var rotationMatrix = [\n            east2[0], east2[1], east2[2], 0,\n            direction2[0], direction2[1], direction2[2], 0,\n            north2[0], north2[1], north2[2], 0,\n            0, 0, 0, 1\n        ];\n*/        \n\n        rotationMatrix = [\n            right[0], right[1], right[2], 0,\n            dir[0], dir[1], dir[2], 0,\n            up[0], up[1], up[2], 0,\n            0, 0, 0, 1\n        ];\n\n        //get orbit pos\n        spaceMatrix = mat4.inverse(spaceMatrix);\n        mat4.multiplyVec3(spaceMatrix, orbitPos);\n\n        //ret.vector2 = [-spaceMatrix[8], -spaceMatrix[9], -spaceMatrix[10]]; //vector2 is probably hack for tree.js bboxVisible \n        ret.vector = [-rotationMatrix[2], -rotationMatrix[6], -rotationMatrix[10]];\n\n        //var ray = this.map.renderer.getScreenRay(800,400);\n\n        //get camera direction\n        //mat4.inverse(rotationMatrix, spaceMatrix);\n        //ret.vector = [-spaceMatrix[8], -spaceMatrix[9], -spaceMatrix[10]]; \n        \n        //console.log(\"cam vec: \" + JSON.stringify(this.cameraVector));\n         \n        //this.position.setHeight(0); !!!!!!!!!!!!!!!\n    }\n\n    ret.orbitCoords = orbitPos;\n    ret.rotMatrix = rotationMatrix;\n    return ret; \n};\n\n\nexport default MapMeasure;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/measure.js\n// module id = 141\n// module chunks = 0 1","\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {utils as utils_} from '../utils/utils';\nimport MapSubmesh_ from './submesh';\nimport BBox_ from '../renderer/bbox';\nimport GpuProgram_ from '../renderer/gpu/program';\nimport GpuShaders_ from '../renderer/gpu/shaders';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\nvar BBox = BBox_;\nvar MapSubmesh = MapSubmesh_;\nvar utils = utils_;\nvar GpuProgram = GpuProgram_;\nvar GpuShaders = GpuShaders_;\n\nvar MapMesh = function(map, url, tile) {\n    this.generateLines = true;\n    this.map = map;\n    this.stats = map.stats;\n    this.mapLoaderUrl  = url;\n    this.tile = tile; // used only for stats\n    this.use16bit = map.config.map16bitMeshes;\n\n    this.bbox = new BBox();\n    this.size = 0;\n    this.gpuSize = 0;\n    this.fileSize = 0;\n    this.faces = 0;\n\n    this.cacheItem = null;  //store killSubmeshes\n    this.gpuCacheItem = null; //store killGpuSubmeshes\n\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n\n    this.mBuffer = new Float32Array(16);\n    this.mBuffer2 = new Float32Array(16);\n    this.vBuffer = new Float32Array(4);\n\n    this.submeshes = [];\n    this.gpuSubmeshes = [];\n    this.submeshesKilled = false;\n};\n\n\nMapMesh.prototype.kill = function() {\n    this.bbox = null;\n    this.killSubmeshes();\n    this.killGpuSubmeshes();\n};\n\n\nMapMesh.prototype.killSubmeshes = function(killedByCache) {\n    for (var i = 0, li = this.submeshes.length; i < li; i++) {\n        this.submeshes[i].kill();\n    }\n    //this.submeshes = [];\n    this.submeshesKilled = true;\n\n    if (killedByCache !== true && this.cacheItem) {\n        this.map.resourcesCache.remove(this.cacheItem);\n        //this.tile.validate();\n    }\n\n    if (this.gpuSubmeshes.length == 0) {\n        this.loadState = 0;\n    }\n\n    this.cacheItem = null;\n};\n\n\nMapMesh.prototype.killGpuSubmeshes = function(killedByCache) {\n    var size = 0;\n    for (var i = 0, li = this.gpuSubmeshes.length; i < li; i++) {\n        this.gpuSubmeshes[i].kill();\n        size += this.gpuSubmeshes[i].size;\n    }\n\n    if (li > 0) {\n        this.stats.gpuMeshes -= size;\n        this.stats.graphsFluxMesh[1][0]++;\n        this.stats.graphsFluxMesh[1][1] += size;\n    }\n\n    this.gpuSubmeshes = [];\n\n    if (killedByCache !== true && this.gpuCacheItem) {\n        this.map.gpuCache.remove(this.gpuCacheItem);\n        //this.tile.validate();\n    }\n\n    //console.log(\"kill: \" + this.stats.counter + \"   \" + this.mapLoaderUrl);\n\n//    if (this.submeshes.length == 0) {\n    if (this.submeshesKilled) {\n        this.loadState = 0;\n    }\n\n    this.gpuCacheItem = null;\n};\n\n\nMapMesh.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {\n    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);\n    doNotLoad = doNotLoad || doNotUseGpu;\n    \n    //if (doNotUseGpu) {\n      //  doNotUseGpu = doNotUseGpu;\n    //}\n    \n    //if (this.mapLoaderUrl == \"https://cdn.vts.com/mario/proxy/melown2015/surface/vts/cz10/12-1107-688.bin?0\") {\n      //  this.mapLoaderUrl = this.mapLoaderUrl;\n    //}    \n\n    if (this.loadState == 2) { //loaded\n        if (this.cacheItem) {\n            this.map.resourcesCache.updateItem(this.cacheItem);\n        }\n        \n        if (doNotCheckGpu) {\n            return true;\n        }\n\n        if (this.gpuSubmeshes.length == 0) {\n            if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {\n                return false;\n            }\n\n            if (this.stats.renderBuild > this.map.config.mapMaxProcessingTime) {\n                this.map.markDirty();\n                return false;\n            }\n\n            if (doNotUseGpu) {\n                return false;\n            }\n\n            var t = performance.now();\n            this.buildGpuSubmeshes();\n            this.stats.renderBuild += performance.now() - t; \n        }\n\n        if (!doNotLoad && this.gpuCacheItem) {\n            this.map.gpuCache.updateItem(this.gpuCacheItem);\n        }\n        return true;\n    } else {\n        if (this.loadState == 0) { \n            if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                  //  this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            } else {\n                //not loaded\n                //add to loading queue or top position in queue\n                this.scheduleLoad(priority);\n            }\n        } else if (this.loadState == 3) { //loadError\n            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n    \n                this.scheduleLoad(priority);                    \n            }\n        } //else load in progress\n    }\n\n    return false;\n};\n\n\nMapMesh.prototype.scheduleLoad = function(priority) {\n    if (!this.mapLoaderUrl) {\n        this.mapLoaderUrl = this.map.url.makeUrl(this.tile.resourceSurface.meshUrl, {lod:this.tile.id[0], ix:this.tile.id[1], iy:this.tile.id[2] });\n    }\n\n    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.tile, 'mesh');\n};\n\n\nMapMesh.prototype.onLoad = function(url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    utils.loadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n    this.loadState = 1;\n};\n\n\nMapMesh.prototype.onLoadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    this.loadState = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n    \n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n    \n    this.mapLoaderCallError();\n};\n\n\nMapMesh.prototype.onLoaded = function(data, task) {\n    if (this.map.killed){\n        return;\n    }\n\n    if (!task) {\n        //this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {\n        this.map.markDirty();\n        this.map.addProcessingTask(this.onLoaded.bind(this, data, true));\n        return;\n    }\n\n    this.fileSize= data.byteLength;\n\n    var stream = {data: new DataView(data), buffer:data, index:0};\n\n    var t = performance.now();\n    this.parseMapMesh(stream);\n    this.map.stats.renderBuild += performance.now() - t; \n    \n    this.submeshesKilled = false;\n\n    this.cacheItem = this.map.resourcesCache.insert(this.killSubmeshes.bind(this, true), this.size);\n\n    this.map.markDirty();\n    this.loadState = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.mapLoaderCallLoaded();\n};\n\n\n// Returns RAM usage in bytes.\n//MapMesh.prototype.size = function () {\n  //  return this.size;\n//};\n\n//MapMesh.prototype.fileSize = function () {\n    //return this.fileSize;\n//};\n\n// Returns RAM usage in bytes.\nMapMesh.prototype.parseMapMesh = function (stream) {\n/*\n    struct MapMesh {\n        struct MapMeshHeader {\n            char magic[2];                // letters \"ME\"\n            ushort version;               // currently 1\n            double meanUndulation;        // read more about undulation below\n            ushort numSubmeshes;          // number of submeshes\n        } header;\n        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property\n    };\n*/\n    this.killSubmeshes(); //just in case\n\n    //parase header\n    var streamData = stream.data;\n    var magic = '';\n\n    if (streamData.length < 2) {\n        return false;\n    }\n\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n\n    if (magic != 'ME') {\n        return false;\n    }\n\n    this.version = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    if (this.version > 3) {\n        return false;\n    }\n    \n    //if (this.version >= 3) {\n    stream.uint8Data = new Uint8Array(stream.buffer);\n    //}\n\n    this.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;\n    this.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    this.submeshes = [];\n    this.gpuSize = 0; \n    this.faces = 0;\n\n    for (var i = 0, li = this.numSubmeshes; i < li; i++) {\n        var submesh = new MapSubmesh(this, stream);\n        if (submesh.valid) {\n            this.submeshes.push(submesh); \n            this.size += submesh.size;\n            this.faces += submesh.faces;\n\n            //aproximate size\n            var varSize = this.use16bit ? 2 : 4;\n            this.gpuSize += (submesh.vertices ? submesh.vertices.length : 0) * 3 * varSize +\n                            (submesh.internalUVs ? submesh.internalUVs.length : 0) * 2 * varSize +\n                            (submesh.externalUVs ? submesh.externalUVs.length : 0) * 2 * varSize;\n        }\n    }\n    \n    this.numSubmeshes = this.submeshes.length;\n};\n\n\nMapMesh.prototype.addSubmesh = function(submesh) {\n    this.submeshes.push(submesh);\n    this.size += submesh.size;\n    this.faces += submesh.faces;\n};\n\n\nMapMesh.prototype.buildGpuSubmeshes = function() {\n    var size = 0;\n    this.gpuSubmeshes = new Array(this.submeshes.length);\n\n    for (var i = 0, li = this.submeshes.length; i < li; i++) {\n        this.gpuSubmeshes[i] = this.submeshes[i].buildGpuMesh();\n        size += this.gpuSubmeshes[i].size;\n    }\n\n    this.stats.gpuMeshes += size;\n    this.stats.graphsFluxMesh[0][0]++;\n    this.stats.graphsFluxMesh[0][1] += size;\n\n    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuSubmeshes.bind(this, true), size);\n    this.gpuSize = size;\n\n    //console.log(\"build: \" + this.stats.counter + \"   \" + this.mapLoaderUrl);\n};\n\n\nMapMesh.prototype.drawSubmesh = function (cameraPos, index, texture, type, alpha, layer) {\n    if (this.gpuSubmeshes[index] == null && this.submeshes[index] != null && !this.submeshes[index].killed) {\n        this.gpuSubmeshes[index] = this.submeshes[index].buildGpuMesh();\n    }\n\n    var submesh = this.submeshes[index];\n    var gpuSubmesh = this.gpuSubmeshes[index];\n\n    if (!gpuSubmesh) {\n        return;\n    }\n\n    var renderer = this.map.renderer;\n    var draw = this.map.draw;\n    var program = null;\n    var gpuMask = null; \n\n    var texcoordsAttr = null;\n    var texcoords2Attr = null;\n    var drawWireframe = draw.debug.drawWireframe;\n    var attributes = (drawWireframe != 0) ?  ['aPosition', 'aBarycentric'] : ['aPosition'];\n\n    if (type == VTS_MATERIAL_DEPTH) {\n        program = renderer.progDepthTile;\n        //texcoordsAttr = \"aTexCoord\";\n    } else if (type == VTS_MATERIAL_FLAT) {\n        program = renderer.progFlatShadeTile;\n    } else {\n        if (drawWireframe > 0) {\n            switch (drawWireframe) {\n            case 2: program = renderer.progWireframeTile2;  break;\n            case 3: program = renderer.progFlatShadeTile;  break;\n            case 1:\n    \n                switch(type) {\n                case VTS_MATERIAL_INTERNAL:\n                case VTS_MATERIAL_INTERNAL_NOFOG:\n                    program = renderer.progWireframeTile;\n                    texcoordsAttr = 'aTexCoord';\n                    attributes.push('aTexCoord');\n                    break;\n    \n                case VTS_MATERIAL_EXTERNAL:\n                case VTS_MATERIAL_EXTERNAL_NOFOG:\n                    program = renderer.progWireframeTile3;\n                    texcoords2Attr = 'aTexCoord2';\n                    attributes.push('aTexCoord2');\n                    break;\n    \n                case VTS_MATERIAL_FOG:\n                    return;\n                }\n    \n                break;\n            }\n        } else {\n            switch(type) {\n            case VTS_MATERIAL_INTERNAL:\n            case VTS_MATERIAL_INTERNAL_NOFOG:\n                program = renderer.progTile;\n                texcoordsAttr = 'aTexCoord';\n                attributes.push('aTexCoord');\n                break;\n    \n            case VTS_MATERIAL_EXTERNAL:\n            case VTS_MATERIAL_EXTERNAL_NOFOG:\n\n                program = renderer.progTile2;\n                    \n                if (texture) {\n                    gpuMask = texture.getGpuMaskTexture();\n                    if (gpuMask) {\n                        program = renderer.progTile3;\n                    }\n                } \n                \n                if (layer && layer.shaderFilter) {\n                    var id = (gpuMask) ? 'progTile3' : 'progTile2';\n                    var renderer = this.map.renderer;\n                    id += layer.shaderFilter;\n\n                    program = renderer.progMap[id];\n\n                    if (!program) {\n                        var gpu = renderer.gpu, pixelShader = gpuMask ? GpuShaders.tile3FragmentShader : GpuShaders.tile2FragmentShader;\n                        program = new GpuProgram(gpu, GpuShaders.tile2VertexShader, pixelShader.replace('__FILTER__', layer.shaderFilter));\n                        renderer.progMap[id] = program;\n                    }\n                }\n                    \n                texcoords2Attr = 'aTexCoord2';  \n                attributes.push('aTexCoord2');\n                break;\n    \n            case VTS_MATERIAL_FOG:\n                program = renderer.progFogTile;\n                break;\n            }\n        }\n    }\n\n    if (!program || !program.isReady()) {\n        return;\n    }\n\n    renderer.gpu.useProgram(program, attributes, gpuMask);\n\n    if (texture) {\n        var gpuTexture = texture.getGpuTexture();\n        \n        if (gpuTexture) {\n            if (texture.statsCoutner != this.stats.counter) {\n                texture.statsCoutner = this.stats.counter;\n                this.stats.gpuRenderUsed += gpuTexture.size;\n            }\n            \n            renderer.gpu.bindTexture(gpuTexture);\n\n            if (gpuMask) {\n                renderer.gpu.bindTexture(gpuMask, 1);\n            }\n            \n        } else {\n            return;\n        }\n    } else if (type != VTS_MATERIAL_FOG && type != VTS_MATERIAL_DEPTH && type != VTS_MATERIAL_FLAT) {\n        return;\n    }\n\n    var mv = this.mBuffer, m = this.mBuffer2, v = this.vBuffer;\n    mat4.multiply(renderer.camera.getModelviewFMatrix(), submesh.getWorldMatrix(cameraPos, m), mv);\n    var proj = renderer.camera.getProjectionFMatrix();\n\n    program.setMat4('uMV', mv);\n\n    if (draw.zbufferOffset) {\n        program.setMat4('uProj', proj, renderer.getZoffsetFactor(draw.zbufferOffset));\n    } else {\n        program.setMat4('uProj', proj);\n    }\n\n    if (drawWireframe == 0) {\n        var cv = this.map.camera.vector2, c = draw.atmoColor, t, bmin = submesh.bbox.min, bmax = submesh.bbox.max;\n\n        switch(type) {\n        case VTS_MATERIAL_INTERNAL:\n        case VTS_MATERIAL_FOG:\n        case VTS_MATERIAL_INTERNAL_NOFOG:\n\n            m[0] = draw.zFactor, m[1] = (type == VTS_MATERIAL_INTERNAL_NOFOG) ? 0 : draw.fogDensity;\n            m[2] = bmax[0] - bmin[0], m[3] = bmax[1] - bmin[1],\n            m[4] = cv[0], m[5] = cv[1], m[6] = cv[2], m[7] = cv[3],\n            m[12] = bmax[2] - bmin[2], m[13] = bmin[0], m[14] = bmin[1], m[15] = bmin[2];\n\n            program.setMat4('uParams', m);\n                                /*[draw.zFactor, (type == VTS_MATERIAL_INTERNAL_NOFOG) ? 0 : draw.fogDensity, bmax[0] - bmin[0], bmax[1] - bmin[1],\n                                        v[0], v[1], v[2], v[3],\n                                        0,0,0,0,\n                                        bmax[2] - bmin[2], bmin[0], bmin[1], bmin[2]]);*/\n\n            v[0] = c[0], v[1] = c[1], v[2] = c[2];\n            program.setVec4('uParams2', v);\n            break;\n\n        case VTS_MATERIAL_EXTERNAL:\n        case VTS_MATERIAL_EXTERNAL_NOFOG:\n\n            t = texture.getTransform();\n\n            m[0] = draw.zFactor, m[1] = (type == VTS_MATERIAL_EXTERNAL) ? draw.fogDensity : 0;\n            m[2] = bmax[0] - bmin[0], m[3] = bmax[1] - bmin[1],\n            m[4] = cv[0], m[5] = cv[1], m[6] = cv[2], m[7] = cv[3],\n            m[8] = t[0], m[9] = t[1], m[10] = t[2], m[11] = t[3],\n            m[12] = bmax[2] - bmin[2], m[13] = bmin[0], m[14] = bmin[1], m[15] = bmin[2];\n\n            program.setMat4('uParams', m);\n\n            /* [draw.zFactor, (type == VTS_MATERIAL_EXTERNAL) ? draw.fogDensity : 0, bmax[0] - bmin[0], bmax[1] - bmin[1],\n                                        v[0], v[1], v[2], v[3],\n                                        t[0], t[1], t[2], t[3],\n                                        bmax[2] - bmin[2], bmin[0], bmin[1], bmin[2]]);*/\n\n            v[0] = c[0], v[1] = c[1], v[2] = c[2]; v[3] = (type == VTS_MATERIAL_EXTERNAL) ? 1 : alpha;\n            program.setVec4('uParams2', v);\n            break;\n        }\n    }\n\n    if (submesh.statsCoutner != this.stats.counter) {\n        submesh.statsCoutner = this.stats.counter;\n        this.stats.gpuRenderUsed += gpuSubmesh.size;\n    } \n\n    gpuSubmesh.draw(program, 'aPosition', texcoordsAttr, texcoords2Attr, drawWireframe != 0 ? 'aBarycentric' : null);\n\n    this.stats.drawnFaces += this.faces;\n    this.stats.drawCalls ++;\n};\n\n\nexport default MapMesh;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/mesh.js\n// module id = 142\n// module chunks = 0 1","\nimport {vec3 as vec3_, mat4 as mat4_} from '../utils/matrix';\nimport {utils as utils_} from '../utils/utils';\nimport {math as math_} from '../utils/math';\nimport BBox_ from '../renderer/bbox';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat4 = mat4_;\nvar BBox = BBox_;\nvar math = math_;\nvar utils = utils_;\n\n\nvar MapMetanode = function(metatile, id, stream, divisionNode) {\n    this.metatile = metatile;\n    this.map = metatile.map;\n    this.id = id;\n    this.credits = [];\n    this.alien = false;\n    this.ready = false;\n    this.heightReady = false;\n    this.divisionNode = divisionNode;\n\n    this.diskPos = new Array(3);\n    this.diskDistance = 1; \n    this.diskNormal = new Array(3); \n    this.diskAngle = 1;\n    this.diskAngle2 = 1;\n    this.diskAngle2A = 1;\n    //this.bboxHeight = 1;\n    this.bbox2 = new Array(24);\n\n    //this.flagsGeometryPresent =  1;\n    //this.flagsNavtilePresent =  3;\n    //this.flagsInternalTexturePresent =  7;\n    //this.flagsCoarsenessControl =  15;\n    //this.flagsChildShift =  3;\n\n    if (stream) {\n        this.parseMetanode(stream);\n    }\n};\n\n\nMapMetanode.prototype.kill = function() {\n};\n\n\nMapMetanode.prototype.hasChild = function(index) {\n    return ((this.flags & (1<<(index+4))) != 0);\n};\n\n\nMapMetanode.prototype.hasChildById = function(id) {\n    var ix = id[1] - (this.id[1]<<1); \n    var iy = id[2] - (this.id[2]<<1);\n    \n    //ul,ur,ll,lr\n    return this.hasChild((iy<<1) + ix); \n};\n\n\nMapMetanode.prototype.hasChildren = function() {\n    return ((this.flags & ((15)<<4)) != 0);\n};\n\n\nMapMetanode.prototype.parseExtentBits = function(extentBytes, extentBits, index) {\n    var value = 0;\n\n    for (var i = 0, li = extentBits; i < li; i++) {\n        var byteIndex = index >> 3;\n        var bitIndex = index & 0x7;\n\n        if (extentBytes[byteIndex] & (1 << (7-bitIndex))) {\n            value = value | (1 << (li - i - 1));\n        }\n\n        index ++;\n    }\n\n    value /= (1 << li) - 1;\n//    value *= maxExtent;\n\n    return value;\n};\n\n\nMapMetanode.prototype.hasGeometry = function() {\n    return ((this.flags & 1) != 0);\n};\n\n\nMapMetanode.prototype.hasNavtile = function() {\n    return ((this.flags & (1 << 1)) != 0);\n};\n\n\nMapMetanode.prototype.usedTexelSize = function() {\n    return ((this.flags & (1 << 2)) != 0);\n};\n\n\nMapMetanode.prototype.usedDisplaySize = function() {\n    return ((this.flags & (1 << 3)) != 0);\n};\n\nMapMetanode.prototype.parseMetanode = function(stream) {\n\n/*\nstruct Metanode {\n    char flags;                   // #0 - geometry present, #1 - navtile present #2 - applyTexelSize,\n                                  // #3 - applyPixelSize, #4,5,6,7 - ul,ur,ll,lr child exists\n    char geomExtents[];           // a packed array of 6 bit sequences, each lod+2 long, in the following order:\n                                  // minx,maxx,miny,maxy,minz,maxz, undefined if no geometry present\n    uchar internalTextureCount;   // number of internal textures in geometry\n    hfloat texelSize;             // internal texel size in physical srs units, undef unless applyTexelSize is set\n    ushort displaySize;           // desired display size, undef unless applyDisplay size is set\n    short minHeight, maxHeight;   // navigation tile value range, undef if no navtile present\n}\n*/\n\n    var streamData = stream.data;\n    //var lastIndex = stream.index;\n    var version = this.metatile.version;\n\n    this.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    if (version < 5) {\n        var extentsSize = (((this.id[0] + 2) * 6 + 7) >> 3);\n        var extentsBytes = this.map.metanodeBuffer;//new Uint8Array(extentsSize);\n    \n        for (var i = 0, li = extentsSize; i < li; i++) {\n            extentsBytes[i] = streamData.getUint8(stream.index, true); stream.index += 1;\n        }\n    \n        var extentBits = this.id[0] + 2;\n    \n        var minExtents = [0,0,0];\n        var maxExtents = [0,0,0];\n    \n        var index = 0;\n        var spaceExtentSize = this.map.spaceExtentSize;\n        var spaceExtentOffset = this.map.spaceExtentOffset;\n    \n        for (i = 0; i < 3; i++) {\n            minExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index) * spaceExtentSize[i] + spaceExtentOffset[i];\n            //minExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index, 1.0);\n            index += extentBits;\n            maxExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index) * spaceExtentSize[i] + spaceExtentOffset[i];\n            //maxExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index, 1.0);\n            index += extentBits;\n        }\n    \n        //check zero bbox\n        var extentsBytesSum = 0;\n        for (i = 0, li = extentsBytes.length; i < li; i++) {\n            extentsBytesSum += extentsBytes[i];\n        }\n        \n        //extent bytes are empty and therefore bbox is empty also\n        if (extentsBytesSum == 0 ) {\n            //console.log(\"empty-node: id: \" + JSON.stringify(this.id));\n            //console.log(\"empty-node: surafce: \" + this.metatile.surface.id);\n    \n            minExtents[0] = Number.POSITIVE_INFINITY;\n            minExtents[1] = Number.POSITIVE_INFINITY;\n            minExtents[2] = Number.POSITIVE_INFINITY;\n            maxExtents[0] = Number.NEGATIVE_INFINITY;\n            maxExtents[1] = Number.NEGATIVE_INFINITY;\n            maxExtents[2] = Number.NEGATIVE_INFINITY;\n        }\n    \n        this.bbox = new BBox(minExtents[0], minExtents[1], minExtents[2], maxExtents[0], maxExtents[1], maxExtents[2]);\n    }    \n\n    //this.surrogatezHeight = 0;\n\n    if (version >= 4) {\n        this.minZ = streamData.getFloat32(stream.index, true); stream.index += 4;\n        this.maxZ = streamData.getFloat32(stream.index, true); stream.index += 4;\n        this.surrogatez = streamData.getFloat32(stream.index, true); stream.index += 4;\n\n        //if (!(this.minZ > this.maxZ || this.surrogatez == Number.NEGATIVE_INFINITY)) {\n          //  this.surrogatezHeight = this.surrogatez; //have to converted to nav srs height\n        //}\n    }\n\n\n\n    this.internalTextureCount = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    this.pixelSize = utils.decodeFloat16( streamData.getUint16(stream.index, true) ); stream.index += 2;\n    this.displaySize = streamData.getUint16(stream.index, true); stream.index += 2;\n    this.displaySize = 1024;\n    if ((this.flags & (1 << 2)) == 0) {\n        this.pixelSize = Number.POSITIVE_INFINITY;\n    }\n\n    if ((this.flags & (1 << 3)) == 0) {\n        this.displaySize = 256;\n    }\n\n    this.minHeight = streamData.getInt16(stream.index, true); stream.index += 2;\n    this.maxHeight = streamData.getInt16(stream.index, true); stream.index += 2;\n\n    if (version < 4) {\n        this.minZ = this.minHeight;\n        this.maxZ = this.maxHeight;\n        this.surrogatez =this.minHeight;\n    }\n    \n    if (this.metatile.version >= 3) {\n        if (this.metatile.flags & (1<<7)) {\n            this.sourceReference = streamData.getUint16(stream.index, true); stream.index += 2;\n        } else if (this.metatile.flags & (1<<6)) {\n            this.sourceReference = streamData.getUint8(stream.index, true); stream.index += 1;\n        }\n    }\n\n    this.heightReady = this.hasNavtile();\n    \n    this.alien = false;\n\n    //var nodeSize2 = stream.index - lastIndex;\n\n    //if (!this.map.config.mapSmartNodeParsing) {\n    this.generateCullingHelpers();\n    //}    \n};\n\n\nMapMetanode.prototype.clone = function() {\n    var node = new  MapMetanode(this.metatile, this.id);\n    node.flags = this.flags;\n    node.minHeight = this.minHeight;\n    node.maxHeight = this.maxHeight;\n    node.minZ = this.minZ;\n    node.maxZ = this.maxZ;\n    node.llx = this.llx;\n    node.lly = this.lly;\n    node.urx = this.urx;\n    node.ury = this.ury;\n    node.surrogatez = this.surrogatez;\n    node.internalTextureCount = this.internalTextureCount;\n    node.pixelSize = this.pixelSize;\n    node.displaySize = this.displaySize;\n    node.ready = this.ready;\n    node.stream = this.stream;\n    node.heightReady = this.heightReady;\n    \n    //copy credits\n    node.credits = new Array(this.credits.length);\n    \n    for (var i = 0, li = this.credits.length; i < li; i++) {\n        node.credits[i] = this.credits[i];\n    }\n\n    if (this.bbox) {\n        node.bbox = this.bbox.clone();\n    }\n\n\n//    if (this.map.config.mapGeocentCulling) {\n    node.diskPos = this.diskPos;\n    node.diskNormal = this.diskNormal; \n    node.diskAngle = this.diskAngle;\n    node.diskAngle2 = this.diskAngle2;\n    node.diskAngle2A = this.diskAngle2A;\n    node.diskDistance = this.diskDistance; \n    node.bbox2 = this.bbox2;  \n\n    node.divisionNode = this.divisionNode;\n\n //   }\n\n    if (this.plane) {\n        node.plane = this.plane.slice();\n    }\n\n    return node;\n};\n\n\nMapMetanode.prototype.generateCullingHelpers = function(virtual) {\n    this.ready = true;\n    \n    var map = this.map;\n    var draw = map.draw;\n    var geocent = map.isGeocent;\n    var version = this.metatile.useVersion;\n\n    if (this.id[0] < map.measure.minDivisionNodeDepth || (!geocent && version < 4)) {\n        return;\n    }\n\n    if (map.config.mapPreciseCulling || version >= 4) { //use division node srs\n        if (virtual) {\n            return; //result is same for each tile id\n        }\n\n        var divisionNode;\n        var llx, lly, urx, ury;\n        var pos = draw.tmpVec3;\n        \n        if (this.id[0] > map.measure.maxDivisionNodeDepth) {\n            var pos2 = draw.tmpVec5;\n            \n            divisionNode = map.measure.getSpatialDivisionNodeFromId(this.id);\n\n            if (!divisionNode) {\n                return;\n            }\n\n            map.measure.getSpatialDivisionNodeAndExtents2(this.id, pos2, divisionNode);\n            //var node = pos2[0]; \n            llx = pos2[1];\n            lly = pos2[2];\n            urx = pos2[3];\n            ury = pos2[4];\n\n            this.divisionNode = divisionNode;\n\n            /*if (this.id[0] == 2 && this.id[1] == 0 && this.id[2] == 2) {\n                var res = this.map.measure.getSpatialDivisionNodeAndExtents(this.id);\n                res = res;\n            }*/\n            \n        } else {\n            var res = map.measure.getSpatialDivisionNodeAndExtents(this.id);\n            divisionNode = res ? res[0] : null; \n\n            if (!divisionNode) {\n                return;\n            }\n                        \n            llx = res[1][0][0];\n            lly = res[1][0][1];\n            urx = res[1][1][0];\n            ury = res[1][1][1];\n            this.divisionNode = divisionNode;\n        }\n\n        this.llx = llx;\n        this.lly = lly;\n        this.urx = urx;\n        this.ury = ury;\n        \n        var h = this.minZ;\n        //var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5, h];\n        //var normal = [0,0,0];\n        \n        pos[0] = (urx + llx)* 0.5; \n        pos[1] = (ury + lly)* 0.5; \n        pos[2] = h; \n        \n        divisionNode.getPhysicalCoordsFast(pos, true, this.diskPos, 0, 0);\n        \n        if (geocent) {\n            this.diskDistance = vec3.length(this.diskPos); \n            vec3.normalize(this.diskPos, this.diskNormal);\n        } else {\n            this.diskNormal[0] = 0;\n            this.diskNormal[1] = 0;\n            this.diskNormal[2] = 1;\n        }\n        //this.diskNormal = normal;   \n        var normal = this.diskNormal;\n        \n        \n        //if (divisionNode.id[0] == 1 && divisionNode.id[1] ==  1 && divisionNode.id[2] == 0) {   //???? debug?????\n          //  var res = this.map.getSpatialDivisionNodeAndExtents(this.id);\n          //  node = node;\n        //}\n        \n        pos[0] = urx; \n        pos[1] = ury; \n        pos[2] = h; \n\n        /*if (this.id[0] == 17 && this.id[1] == 53306 && this.id[2] == 30754) {\n            normal = normal;\n        }*/\n        \n        var bbox = this.bbox2;\n\n        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 0);\n\n        pos[1] = lly; \n        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 3);\n        \n        pos[0] = llx; \n        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 6);\n        \n        pos[1] = ury; \n        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 9);\n\n        var height;\n\n        if (!geocent) {\n            height = this.maxZ - h;\n            \n            bbox[12] = bbox[0];\n            bbox[13] = bbox[1];\n            bbox[14] = bbox[2] + height;\n            \n            bbox[15] = bbox[3];\n            bbox[16] = bbox[4];\n            bbox[17] = bbox[5] + height;\n        \n            bbox[18] = bbox[6];\n            bbox[19] = bbox[7];\n            bbox[20] = bbox[8] + height;\n        \n            bbox[21] = bbox[9];\n            bbox[22] = bbox[10];\n            bbox[23] = bbox[11] + height;\n            return;        \n        }\n\n        var normalize;\n        var dot = vec3.dot;\n        var d1, d2, d3, d4, maxDelta;\n\n        if (map.config.mapPreciseBBoxTest || version >= 4) { \n        //if (true) { \n            height = this.maxZ - h;\n\n            if (this.id[0] <= 3) { //get aabbox for low lods\n                normalize = vec3.normalize2; \n\n                normalize(bbox, 0, pos);\n                d1 = dot(normal, pos);\n                \n                normalize(bbox, 3, pos);\n                d2 = dot(normal, pos);\n        \n                normalize(bbox, 6, pos);\n                d3 = dot(normal, pos);\n        \n                normalize(bbox, 9, pos);\n                d4 = dot(normal, pos);\n\n                maxDelta = Math.min(d1, d2, d3, d4);\n\n                pos[0] = (urx + llx)* 0.5; \n                pos[1] = ury; \n                pos[2] = h; \n                \n                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 12);\n\n                pos[1] = lly; \n                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 15);\n\n                pos[0] = urx; \n                pos[1] = (ury + lly)* 0.5; \n                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 18);\n\n                pos[0] = llx; \n                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 21);\n\n                var mpos = this.diskPos;\n                var maxX = Math.max(bbox[0], bbox[3], bbox[6], bbox[9], bbox[12], bbox[15], bbox[18], bbox[21], mpos[0]);\n                var minX = Math.min(bbox[0], bbox[3], bbox[6], bbox[9], bbox[12], bbox[15], bbox[18], bbox[21], mpos[0]);\n                \n                var maxY = Math.max(bbox[1], bbox[4], bbox[7], bbox[10], bbox[13], bbox[16], bbox[19], bbox[22], mpos[1]);\n                var minY = Math.min(bbox[1], bbox[4], bbox[7], bbox[10], bbox[13], bbox[16], bbox[19], bbox[22], mpos[1]);\n                \n                var maxZ = Math.max(bbox[2], bbox[5], bbox[8], bbox[11], bbox[14], bbox[17], bbox[20], bbox[23], mpos[2]);\n                var minZ = Math.min(bbox[2], bbox[5], bbox[8], bbox[11], bbox[14], bbox[17], bbox[20], bbox[23], mpos[2]);\n                \n                if (this.id[0] <= 1) {\n                    pos[0] = urx + (llx-urx )* 0.25; \n                    pos[1] = (ury + lly)* 0.5; \n                    \n                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 12);\n    \n                    pos[0] = urx + (llx-urx )* 0.75; \n                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 15);\n    \n                    pos[0] = (urx + llx)* 0.5; \n                    pos[1] = ury + (lly-ury )* 0.25; \n                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 18);\n    \n                    pos[1] = ury + (lly-ury )* 0.75; \n                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 21);\n\n                    maxX =  Math.max(maxX, bbox[12], bbox[15], bbox[18], bbox[21]);\n                    minX =  Math.min(minX, bbox[12], bbox[15], bbox[18], bbox[21]);\n                    \n                    maxY =  Math.max(maxY, bbox[13], bbox[16], bbox[19], bbox[22]);\n                    minY =  Math.min(minY, bbox[13], bbox[16], bbox[19], bbox[22]);\n                    \n                    maxZ =  Math.max(maxZ, bbox[14], bbox[17], bbox[20], bbox[23]);\n                    minZ =  Math.min(minZ, bbox[14], bbox[17], bbox[20], bbox[23]);\n\n                    maxDelta = -1;//full circle;\n                }\n\n                bbox[0] = minX; bbox[1] = minY; bbox[2] = minZ;\n                bbox[3] = maxX; bbox[4] = minY; bbox[5] = minZ;\n                bbox[6] = maxX; bbox[7] = maxY; bbox[8] = minZ;\n                bbox[9] = minX; bbox[10] = maxY; bbox[11] = minZ;\n\n                bbox[12] = minX; bbox[13] = minY; bbox[14] = maxZ;\n                bbox[15] = maxX; bbox[16] = minY; bbox[17] = maxZ;\n                bbox[18] = maxX; bbox[19] = maxY; bbox[20] = maxZ;\n                bbox[21] = minX; bbox[22] = maxY; bbox[23] = maxZ;\n            } else {\n\n                normalize = vec3.normalize3; \n                dot = vec3.dot2;\n\n                normalize(bbox, 0, bbox, 12);\n                d1 = dot(normal, bbox, 12);\n                \n                normalize(bbox, 3, bbox, 15);\n                d2 = dot(normal, bbox, 15);\n        \n                normalize(bbox, 6, bbox, 18);\n                d3 = dot(normal, bbox, 18);\n        \n                normalize(bbox, 9, bbox, 21);\n                d4 = dot(normal, bbox, 21);\n    \n                maxDelta = Math.min(d1, d2, d3, d4);\n\n                if (this.id[0] <= 8) { //extend bbox because of lon curvature\n                    pos = this.diskPos;\n\n                    var expand = 0.12 / (9-4) * (5-(this.id[0]-4));\n\n                    bbox[0] += (bbox[0] - pos[0]) * expand;\n                    bbox[1] += (bbox[1] - pos[1]) * expand;\n                    bbox[2] += (bbox[2] - pos[2]) * expand;\n\n                    bbox[3] += (bbox[3] - pos[0]) * expand;\n                    bbox[4] += (bbox[4] - pos[1]) * expand;\n                    bbox[5] += (bbox[5] - pos[2]) * expand;\n\n                    bbox[6] += (bbox[6] - pos[0]) * expand;\n                    bbox[7] += (bbox[7] - pos[1]) * expand;\n                    bbox[8] += (bbox[8] - pos[2]) * expand;\n\n                    bbox[9] += (bbox[9] - pos[0]) * expand;\n                    bbox[10] += (bbox[10] - pos[1]) * expand;\n                    bbox[11] += (bbox[11] - pos[2]) * expand;\n                }\n\n                //extend bbox height by tile curvature \n                height += draw.planetRadius - (draw.planetRadius * maxDelta);  \n                \n                bbox[12] = bbox[0] + bbox[12] * height;\n                bbox[13] = bbox[1] + bbox[13] * height;\n                bbox[14] = bbox[2] + bbox[14] * height;\n                \n                bbox[15] = bbox[3] + bbox[15] * height;\n                bbox[16] = bbox[4] + bbox[16] * height;\n                bbox[17] = bbox[5] + bbox[17] * height;\n            \n                bbox[18] = bbox[6] + bbox[18] * height;\n                bbox[19] = bbox[7] + bbox[19] * height;\n                bbox[20] = bbox[8] + bbox[20] * height;\n            \n                bbox[21] = bbox[9] + bbox[21] * height;\n                bbox[22] = bbox[10] + bbox[22] * height;\n                bbox[23] = bbox[11] + bbox[23] * height;\n            }\n        \n        } else {\n            normalize = vec3.normalize2; \n\n            normalize(bbox, 0, pos);\n            d1 = dot(normal, pos);\n            \n            normalize(bbox, 3, pos);\n            d2 = dot(normal, pos);\n    \n            normalize(bbox, 6, pos);\n            d3 = dot(normal, pos);\n    \n            normalize(bbox, 9, pos);\n            d4 = dot(normal, pos);\n\n            maxDelta = Math.min(d1, d2, d3, d4);\n        }\n\n        //get cos angle based at 90deg\n        this.diskAngle = Math.cos(Math.max(0,(Math.PI * 0.5) - Math.acos(maxDelta)));\n        this.diskAngle2 = maxDelta;\n        this.diskAngle2A = Math.acos(maxDelta); //optimalization\n\n        //shift center closer to earth\n        //var factor = this.bbox.maxSize * 0.2; \n        //this.diskPos = [this.diskPos[0] - normal[0] * factor, this.diskPos[1]  - normal[1] * factor, this.diskPos[2] - normal[2] * factor];   \n    } \n};\n\n\nMapMetanode.prototype.getWorldMatrix = function(geoPos, matrix) {\n    // Note: the current camera geographic position (geoPos) is not necessary\n    // here, in theory, but for numerical stability (OpenGL ES is float only)\n    // we get rid of the large UTM numbers in the following subtractions. The\n    // camera effectively stays in the position [0,0] and the tiles travel\n    // around it. (The Z coordinate is fine and is not handled in this way.)\n\n    var m = matrix;\n\n    if (m != null) {\n        m[0] = this.bbox.side(0); m[1] = 0; m[2] = 0; m[3] = 0;\n        m[4] = 0; m[5] = this.bbox.side(1); m[6] = 0; m[7] = 0;\n        m[8] = 0; m[9] = 0; m[10] = this.bbox.side(2); m[11] = 0;\n        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;\n    } else {\n        m = mat4.create();\n\n        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),\n                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);\n    }\n\n    return m;\n};\n\n\nMapMetanode.prototype.drawBBox = function(cameraPos) {\n    if (this.metatile.useVersion >= 4) {\n        return this.drawBBox2(cameraPos);\n    }\n\n    var renderer = this.map.renderer;\n\n    renderer.gpu.useProgram(renderer.progBBox, ['aPosition']);\n\n    var mvp = mat4.create();\n    var mv = mat4.create();\n\n    mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);\n\n    var proj = renderer.camera.getProjectionMatrix();\n    mat4.multiply(proj, mv, mvp);\n\n    renderer.progBBox.setMat4('uMVP', mvp);\n\n    //draw bbox\n    renderer.bboxMesh.draw(renderer.progBBox, 'aPosition');\n};\n\n\nMapMetanode.prototype.drawBBox2 = function() {\n    //var spoints = []; \n    //for (var i = 0, li = this.bbox2.length; i < li; i++) {\n        //var pos = this.bbox2[i];\n        //pos = [\"obj\", pos[0], pos[1], \"fix\", pos[2], 0, 0, 0, 10, 90 ];\n        \n    var bbox = this.bbox2;\n    var buffer = this.map.draw.bboxBuffer;\n    var camPos = this.map.camera.position;\n    var renderer = this.map.renderer;\n    var prog = renderer.progBBox2;\n\n    for (var i = 0, li = 8*3; i < li; i+=3) {\n        //var pos = [\"obj\", bbox[i], bbox[i+1], \"fix\", bbox[i+2], 0, 0, 0, 10, 90 ];\n        //var coords = this.map.convert.getPositionCameraCoords((new MapPosition(pos)), null, true);\n\n        buffer[i] = bbox[i] - camPos[0];\n        buffer[i+1] = bbox[i+1] - camPos[1];\n        buffer[i+2] = bbox[i+2] - camPos[2];\n    }\n    \n\n    renderer.gpu.useProgram(prog, ['aPosition']);\n\n    prog.setFloatArray('uPoints', buffer);\n\n    //var mvp = mat4.create();\n    //var mv = mat4.create();\n\n    //mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);\n\n    //var proj = renderer.camera.getProjectionMatrix();\n    //mat4.multiply(proj, mv, mvp);\n\n    var mvp = renderer.camera.getMvpMatrix();\n\n    prog.setMat4('uMVP', mvp);\n\n    //draw bbox\n    renderer.bboxMesh2.draw(prog, 'aPosition');\n};\n\nMapMetanode.prototype.drawPlane = function(cameraPos, tile) {\n    var renderer = this.map.renderer;\n    var buffer = this.map.draw.planeBuffer;\n    var points = this.plane;\n    \n    if (!points) {\n        return;\n    }\n\n    renderer.gpu.useProgram(renderer.progPlane, ['aPosition', 'aTexCoord']);\n\n    var mvp = mat4.create();\n    var mv = renderer.camera.getModelviewMatrix();\n    var proj = renderer.camera.getProjectionMatrix();\n    mat4.multiply(proj, mv, mvp);\n    \n    var sx = cameraPos[0];\n    var sy = cameraPos[1];\n    var sz = cameraPos[2];\n\n    for (var i = 0; i < 9; i++) {\n        var index = i*3;\n        buffer[index] = points[index] - sx; \n        buffer[index+1] = points[index+1] - sy; \n        buffer[index+2] = points[index+2] - sz; \n    }\n    \n    var prog = renderer.progPlane; \n\n    prog.setMat4('uMV', mv);\n    prog.setMat4('uProj', proj);\n    prog.setFloatArray('uPoints', buffer);\n\n    //var minTile = 32;\n    var embed = 8;\n    var altitude = Math.max(10, tile.distance + 20);\n    var gridSelect = (Math.log(altitude) / Math.log(embed));\n    var step1 = 4;//(Math.pow(embed, Math.floor(gridSelect)));\n    var step2 = 8;//(Math.pow(embed, Math.ceil(gridSelect)));\n    var blend = (gridSelect - Math.floor(gridSelect));\n    //var blend = 0;\n\n    //prog.setVec4(\"uParams\", [0,0,1/15,0]);\n    //prog.setVec4(\"uParams\", [(minTile / step1),0,1/15,(minTile / step2)]);\n    prog.setVec4('uParams', [step1, 0, 1/15, step2]);\n\n    //prog.setVec4(\"uParams2\", [(minTile / step1), (minTile / step2), blend, 0]);\n    prog.setVec4('uParams2', [0, 0, blend, 0]);\n\n    renderer.gpu.bindTexture(renderer.heightmapTexture);\n    \n    //draw bbox\n    renderer.planeMesh.draw(renderer.progPlane, 'aPosition', 'aTexCoord');\n};\n\n\nMapMetanode.prototype.getGridHeight = function(coords, data, dataWidth) {\n    var x = coords[0] - this.llx;\n    //var y = this.ury - coords[1];\n    var y = coords[1]  - this.lly;\n    var maxX = (dataWidth-1);\n    var maxY = (dataWidth-1);\n    \n    //data coords\n    x = (maxX) * (x / (this.urx - this.llx));\n    y = (maxY) * (y / (this.ury - this.lly));\n\n    if (x < 0) { x = 0; }\n    if (y < 0) { y = 0; }\n    if (x > maxX) { x = maxX; }\n    if (y > maxY) { y = maxY; }\n\n    var ix = Math.floor(x);\n    var iy = Math.floor(y);\n    var fx = x - ix;\n    var fy = y - iy;\n\n    var index = iy * dataWidth;\n    var index2 = (iy == maxY) ? index : index + dataWidth;\n    var ix2 = (ix == maxX) ? ix : ix + 1; \n    var h00 = data[index + ix];\n    var h01 = data[index + ix2];\n    var h10 = data[index2 + ix];\n    var h11 = data[index2 + ix2];\n    var w0 = (h00 + (h01 - h00)*fx);\n    var w1 = (h10 + (h11 - h10)*fx);\n    var height = (w0 + (w1 - w0)*fy);\n\n    return height;\n};\n\nexport default MapMetanode;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/metanode.js\n// module id = 143\n// module chunks = 0 1","\nimport {utils as utils_} from '../utils/utils';\nimport MapMetanode_ from './metanode';\n\n//get rid of compiler mess\nvar utils = utils_;\nvar MapMetanode = MapMetanode_;\n\n\nvar MapMetatile = function(metaresources, surface, tile) {\n    this.metaresources= metaresources; //this is metastorage tile\n    this.map = metaresources.map;\n    this.surface = surface;\n    this.id = metaresources.id;\n    this.tile = tile; // used only for stats\n    this.nodes = [];\n    this.drawCounter = 0;\n    this.loadState = 0;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.size = 0;\n    this.cacheItem = null;\n};\n\n\nMapMetatile.prototype.kill = function(killedByCache) {\n    if (killedByCache !== true && this.cacheItem != null) {\n        this.map.metatileCache.remove(this.cacheItem);\n    }\n\n    if (this.metaresources) {\n        this.metaresources.removeMetatile(this);\n        //this.metaresources.validate();\n        //this.metaresources = null;\n    }\n\n    this.loadState = 0;\n    this.surface = 0;\n    this.cacheItem = null;\n\n    this.nodes = [];\n};\n\n\nMapMetatile.prototype.clone = function(surface) {\n    var metatile = new MapMetatile(this.metaresources, surface);\n    metatile.nodes = this.nodes;\n    metatile.loadState = this.loadState;\n    metatile.nodes = this.nodes;\n    metatile.size = this.size;\n\n    metatile.lod = this.lod;\n    metatile.metatileIdx = this.metatileIdx;\n    metatile.metatileIdy = this.metatileIdy;\n    metatile.offsetx = this.offsetx;\n    metatile.offsety = this.offsety;\n    metatile.sizex = this.sizex;\n    metatile.sizey = this.sizey;\n    metatile.version = this.version;\n    metatile.credits = this.credits;\n\n    if (this.version < 2) {\n        metatile.nodeSize = this.nodeSize;\n    } else {\n        metatile.flags = this.flags;\n        metatile.creditCount = this.creditCount;\n        metatile.flagPlanes = this.flagPlanes;\n    }\n\n    metatile.cacheItem= this.map.metatileCache.insert(metatile.kill.bind(metatile, true), metatile.size);\n    return metatile;\n};\n\n\nMapMetatile.prototype.isReady = function (/*doNotLoad,*/ priority) {\n    //if (this.id[0] == 18 &&\n    //    this.id[1] == 130400 &&\n    //    this.id[2] == 129088) {\n    //    debugger;\n    //}\n\n    if (this.loadState == 2) { //loaded\n        return true;\n    } else {\n\n        if (this.loadState == 0) { \n            //if (doNotLoad) {\n                //remove from queue\n                //if (this.mapLoaderUrl) {\n                  //  this.map.loader.remove(this.mapLoaderUrl);\n                //}\n            //} else {\n                //not loaded\n                //add to loading queue or top position in queue\n            if (this.loadState == 3) { //loadError\n                if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&\n                        performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {\n\n                    this.scheduleLoad(priority);                    \n                }\n            } else {\n                this.scheduleLoad(priority);\n            }\n            //}\n        } //else load in progress\n        \n        return false;\n    }\n};\n\n\nMapMetatile.prototype.used = function() {\n    if (this.cacheItem != null) {\n        this.map.metatileCache.updateItem(this.cacheItem);\n    }\n};\n\n\nMapMetatile.prototype.getNode = function(id) {\n    var x = id[1] - this.id[1] - this.offsetx;\n    var y = id[2] - this.id[2] - this.offsety;\n    \n    if (x < 0 || y < 0 || x >= this.sizex || y >= this.sizey) {\n        return null;\n    }\n    \n    var node = this.nodes[this.sizex * y + x];\n\n    if (!node) {\n        var index = this.sizex * y + x;\n        var stream = {data:this.data, index:this.metanodesIndex + (index * this.metanodeSize)};\n        node = (new MapMetanode(this, [this.lod, this.metatileIdx + this.offsetx + x, this.metatileIdy + this.offsety + y], stream, this.divisionNode)); \n        this.nodes[index] = node;\n        this.applyMetanodeCredits(x, y);\n        this.applyMetatanodeBitplanes(x, y); \n    }\n\n/*    \n    if (!node.ready) {\n        node.generateCullingHelpers();\n        node.ready = true;\n    }\n*/\n    \n    return node;\n};\n\n\nMapMetatile.prototype.scheduleLoad = function() {\n    if (this.mapLoaderUrl == null) {\n        this.mapLoaderUrl = this.surface.getMetaUrl(this.id);\n    }\n\n    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), null, this.tile, 'metatile');\n};\n\n\nMapMetatile.prototype.onLoad = function(url, onLoaded, onError) {\n    this.mapLoaderCallLoaded = onLoaded;\n    this.mapLoaderCallError = onError;\n\n    utils.loadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n    this.loadState = 1;\n};\n\n\nMapMetatile.prototype.onLoadError = function() {\n    if (this.map.killed){\n        return;\n    }\n\n    this.loadState = 3;\n    this.loadErrorTime = performance.now();\n    this.loadErrorCounter ++;\n\n    //make sure we try to load it again\n    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { \n        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);\n    }    \n\n    this.mapLoaderCallError();\n};\n\n\nMapMetatile.prototype.onLoaded = function(data, task) {\n    if (this.map.killed){\n        return;\n    }\n\n    if (!task) {\n    //if (this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {\n        this.map.markDirty();\n        this.map.addProcessingTask(this.onLoaded.bind(this, data, true));\n        return;\n    }\n\n    data = new DataView(data);\n\n    this.size += data.byteLength * 4;\n    \n    this.data = data;\n\n    var t = performance.now();\n    this.parseMetatatile({data:data, index: 0});\n    this.map.stats.renderBuild += performance.now() - t; \n\n    this.cacheItem= this.map.metatileCache.insert(this.kill.bind(this, true), this.size);\n\n    this.map.markDirty();\n    this.loadState = 2;\n    this.loadErrorTime = null;\n    this.loadErrorCounter = 0;\n    this.mapLoaderCallLoaded();\n};\n\n\nMapMetatile.prototype.parseMetatatile = function(stream) {\n\n/*\n    struct Header {\n\n        char magic[2];                         // letters \"MT\"\n        ushort version;                        // version\n        uchar lod;                             // common lod\n        uint metatileIdx, metatileIdy;         // id of upper left tile corner (reflected in tile name)\n        ushort offsetx, offsety;               // offset of valid data block\n        ushort sizex, sizey;                   // dimensions of metanode grid\n        uchar nodeSize;                        // size of a metanode in bytes\n        uchar creditCount;                     // total number of credit blocks (= number of attributions used by nodes)\n        ushort creditSize;                     // size of credit block in bytes\n    };\n*/\n\n    var streamData = stream.data;\n    var magic = '';\n\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n\n    if (magic != 'MT') {\n        return;\n    }\n\n    this.version = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    if (this.version > 5) {\n        return;\n    }\n\n    this.lod = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    this.metatileIdx = streamData.getUint32(stream.index, true); stream.index += 4;\n    this.metatileIdy = streamData.getUint32(stream.index, true); stream.index += 4;\n\n    this.offsetx = streamData.getUint16(stream.index, true); stream.index += 2;\n    this.offsety = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    this.sizex = streamData.getUint16(stream.index, true); stream.index += 2;\n    this.sizey = streamData.getUint16(stream.index, true); stream.index += 2;\n    \n    this.flagPlanes = new Array(8);\n\n    if (this.version < 2) {\n        this.nodeSize = streamData.getUint8(stream.index, true); stream.index += 1;\n    } else {\n        this.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n        this.creditCount = streamData.getUint8(stream.index, true); stream.index += 1;\n        this.parseFlagPlanes(stream);\n    }\n\n    this.parseMetatatileCredits(stream);\n    this.parseMetatatileNodes(stream);\n    \n    this.useVersion = (this.map.config.mapForceMetatileV3 && this.version < 5) ? 3 : this.version; \n};\n\n\nMapMetatile.prototype.parseFlagPlanes = function(stream) {\n    var streamData = stream.data;\n\n    //rounded to bytes\n    var bitplaneSize = ((this.sizex * this.sizey + 7) >> 3);\n\n    for (var i = 0; i < 6; i++) {\n        if ((this.flags & (1 << i)) != 0) {\n\n            var bitplane = new Uint8Array(bitplaneSize);\n    \n            for (var j = 0; j < bitplaneSize; j++) {\n                bitplane[j] = streamData.getUint8(stream.index, true); stream.index += 1;\n            }\n    \n            this.flagPlanes[i] = bitplane; \n        }\n    }\n};\n\n\nMapMetatile.prototype.parseMetatatileCredits = function(stream) {\n\n/*\n    struct CreditBlock {\n       ushort creditId;       // numerical creditId\n       char creditMask[];     // bitfield of size header.sizex * header.sizey, row major, row padded\n    };\n*/\n\n    var streamData = stream.data;\n    \n    if (this.version < 2) {\n        this.creditCount = streamData.getUint8(stream.index, true); stream.index += 1;\n        this.creditSize = streamData.getUint16(stream.index, true); stream.index += 2;\n    }\n    \n    if (this.creditCount == 0) {\n        this.credits = [];\n        return;\n    }\n\n    //rounded to bytes\n    var bitfieldSize = ((this.sizex * this.sizey + 7) >> 3);\n\n    this.credits = new Array(this.creditCount);\n\n    for (var i = 0, li = this.credits.length; i < li; i++) {\n        var creditId = streamData.getUint16(stream.index, true); stream.index += 2;\n        var bitfield = new Uint8Array(bitfieldSize);\n\n        for (var j = 0; j < bitfieldSize; j++) {\n            bitfield[j] = streamData.getUint8(stream.index, true); stream.index += 1;\n        }\n    \n        var credit = this.map.getCreditByNumber(creditId);\n        var stringId = credit ? credit.key : null;\n\n        this.credits[i] = { creditId : stringId, creditMask: bitfield};\n    }\n};\n\n\nMapMetatile.prototype.applyMetatatileBitplanes = function() {\n    for (var i = 0; i < 1; i++) {\n        if (this.flagPlanes[i]) {\n            \n            var bitplane = this.flagPlanes[i]; \n    \n            for (var y = 0; y < this.sizey; y++) {\n                for (var x = 0; x < this.sizex; x++) {\n                    var byteIndex = this.sizex * y + x;\n                    var bitIndex = byteIndex & 7;\n                    var bitMask = 1 << bitIndex;\n                    byteIndex >>= 3;\n                    \n                    if (bitplane[byteIndex] & bitMask) {\n                        switch(i) {\n                        case 0:\n                            this.nodes[y*this.sizex+x].alien = true;\n                            break;       \n                        }\n                    }\n                }\n            }\n        }\n    }\n};\n\n\nMapMetatile.prototype.applyMetatanodeBitplanes = function(x, y) {\n    for (var i = 0; i < 1; i++) {\n        if (this.flagPlanes[i]) {\n            var bitplane = this.flagPlanes[i]; \n            var byteIndex = this.sizex * y + x;\n            var bitIndex = byteIndex & 7;\n            var bitMask = 1 << bitIndex;\n            byteIndex >>= 3;\n            \n            if (bitplane[byteIndex] & bitMask) {\n                switch(i) {\n                case 0:\n                    this.nodes[y*this.sizex+x].alien = true;\n                    break;       \n                }\n            }\n        }\n    }\n};\n\n\nMapMetatile.prototype.applyMetatatileCredits = function() {\n    for (var y = 0; y < this.sizey; y++) {\n        for (var x = 0; x < this.sizex; x++) {\n            var byteIndex = this.sizex * y + x;\n            var bitIndex = byteIndex & 7;\n            var bitMask = 1 << bitIndex;\n            byteIndex >>= 3;\n\n            for (var i = 0, li = this.credits.length; i < li; i++) {\n                if (this.credits[i].creditMask[byteIndex] & bitMask) {\n                    var id = this.credits[i].creditId;\n                    if (id) {\n                        this.nodes[y*this.sizex+x].credits.push(id);\n                    }\n                }\n            }\n        }\n    }\n};\n\n\nMapMetatile.prototype.applyMetanodeCredits = function(x, y) {\n    var byteIndex = this.sizex * y + x;\n    var bitIndex = byteIndex & 7;\n    var bitMask = 1 << bitIndex;\n    byteIndex >>= 3;\n\n    for (var i = 0, li = this.credits.length; i < li; i++) {\n        if (this.credits[i].creditMask[byteIndex] & bitMask) {\n            var id = this.credits[i].creditId;\n            if (id) {\n                this.nodes[y*this.sizex+x].credits.push(id);\n            }\n        }\n    }\n};\n\n\nMapMetatile.prototype.parseMetatatileNodes = function(stream) {\n    this.metanodesIndex = stream.index;\n    this.metanodeSize = 1 + 1 + 2 + 2 + 2 + 2;\n    \n    if (this.version >= 5) {\n        this.metanodeSize += 3 * 4;\n    } else {\n        this.metanodeSize += Math.floor((6 * (this.id[0] + 2) + 7) / 8);\n\n        if (this.version == 4) {\n            this.metanodeSize += 3 * 4;\n        }\n    }\n\n    if (this.version >= 3) {\n        if (this.flags & (1<<7)) {\n            this.metanodeSize += 2;\n        } else if (this.flags & (1<<6)) {\n            this.metanodeSize += 1;\n        }\n    }\n\n    if (this.lod >= this.map.measure.minDivisionNodeDepth) {\n        this.divisionNode = this.map.measure.getSpatialDivisionNodeAndExtents([this.lod, this.metatileIdx + this.offsetx, this.metatileIdy + this.offsety]);\n        if (this.divisionNode) {\n            this.divisionNode = this.divisionNode[0];\n        }\n    } else {\n        this.divisionNode = null;\n    }\n    \n    this.nodes = new Array(this.sizex*this.sizey);\n    \n    /*\n    var index = 0;\n\n    for (var y = 0; y < this.sizey; y++) {\n        for (var x = 0; x < this.sizex; x++) {\n            this.nodes[index] = (new MapMetanode(this, [this.lod, this.metatileIdx + this.offsetx + x, this.metatileIdy + this.offsety + y], stream, divisionNode));\n            index++;\n        }\n    }\n    \n    this.applyMetatatileCredits();\n    this.applyMetatatileBitplanes();\n    */\n};\n\n\nexport default MapMetatile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/metatile.js\n// module id = 144\n// module chunks = 0 1","\nimport MapDivisionNode_ from './division-node';\n\n//get rid of compiler mess\nvar MapDivisionNode = MapDivisionNode_;\n\n\nvar MapRefFrame = function(map, json) {\n    this.map = map;\n    this.proj4 = map.proj4;\n    this.valid = false;\n    this.id = json['id'] || null;\n    this.description = json['description'] || '';\n    this.nodesMap = [];\n\n    var model = json['model'];\n\n    if (model == null) {\n        return;\n    }\n\n    this.model = {\n        physicalSrs : map.getMapsSrs(model['physicalSrs']),\n        navigationSrs : map.getMapsSrs(model['navigationSrs']),\n        publicSrs : map.getMapsSrs(model['publicSrs'])\n    };\n\n    this.body = json['body'] ? map.getBody(json['body']) : null;\n\n    this.params = {};\n\n    if (json['parameters'] != null) {\n        var params = json['parameters'];\n        this.params.metaBinaryOrder = params['metaBinaryOrder'] || 1;\n        this.params.navDelta = params['navDelta'] || 8;\n    }\n\n    var division = json['division'];\n\n    if (division == null) {\n        return;\n    }\n\n    this.division = {\n        rootLod : division['rootLod'] || 0,\n        arity : division['arity'] || null,\n        heightRange : division['heightRange'] || [0,1]\n    };\n\n    var extents = this.parseSpaceExtents(division['extents']);\n    this.division.extents = extents;\n\n    map.spaceExtentSize = [extents.ur[0] - extents.ll[0], extents.ur[1] - extents.ll[1], extents.ur[2] - extents.ll[2]];\n    map.spaceExtentOffset = extents.ll;\n\n    var divisionNodes = division['nodes'];\n    this.division.nodes = [];\n\n    if (divisionNodes == null) {\n        return;\n    }\n\n    this.hasPoles = (divisionNodes.length == 4); \n\n    for (var i = 0, li = divisionNodes.length; i < li; i++) {\n        var node = this.parseNode(divisionNodes[i]);\n        this.nodesMap['' + node.id[0] + '.'  + node.id[1] + '.' + node.id[2]] = node;\n        this.division.nodes.push(node);\n    }\n\n    this.valid = true;\n};\n\n\nMapRefFrame.prototype.getInfo = function() {\n    return {\n        'id' : this.id,\n        'physicalSrs' : this.model.physicalSrs.id,\n        'navigationSrs' : this.model.navigationSrs.id,\n        'publicSrs' : this.model.publicSrs.id\n    };\n};\n\n\nMapRefFrame.prototype.getGlobalHeightRange = function() {\n    return this.division.heightRange;     \n};\n\n\nMapRefFrame.prototype.parseNode = function(nodeData) {\n    var node = {\n        srs : nodeData['srs'],\n        partitioning : nodeData['partitioning']\n    };\n\n    node.extents = this.parseExtents(nodeData['extents']);\n\n    var nodeId = nodeData['id'];\n\n    if (nodeId == null) {\n        return;\n    }\n\n    node.id = {\n        lod : nodeId['lod'] || 0,\n        position : nodeId['position'] || [0,0]\n    };\n\n    return new MapDivisionNode(this.map, [node.id.lod, node.id.position[0], node.id.position[1]],\n                                           node.srs, node.extents, this.heightRange, node.partitioning);\n};\n\n\nMapRefFrame.prototype.parseExtents = function(extentsData) {\n    if (extentsData == null) {\n        return { ll : [0,0], ur : [1,1] };\n    }\n\n    return {\n        ll : extentsData['ll'] || [0,0],\n        ur : extentsData['ur'] || [1,1]\n    };\n};\n\n\nMapRefFrame.prototype.parseSpaceExtents = function(extentsData) {\n    if (extentsData == null) {\n        return { ll : [0,0,0], ur : [1,1,1] };\n    }\n\n    return {\n        ll : extentsData['ll'] || [0,0,0],\n        ur : extentsData['ur'] || [1,1,1]\n    };\n};\n\n\nMapRefFrame.prototype.getSpatialDivisionNodes = function() {\n    return this.division.nodes;\n};\n\n\nMapRefFrame.prototype.convertCoords = function(coords, source, destination) {\n    var sourceSrs, destinationSrs;\n\n    switch(source) {\n    case 'public':     sourceSrs = this.model.publicSrs;     break;\n    case 'physical':   sourceSrs = this.model.physicalSrs;   break;\n    case 'navigation': sourceSrs = this.model.navigationSrs; break;\n    }\n\n    switch(destination) {\n    case 'public':     destinationSrs = this.model.publicSrs;     break;\n    case 'physical':   destinationSrs = this.model.physicalSrs;   break;\n    case 'navigation': destinationSrs = this.model.navigationSrs; break;\n    }\n\n    return sourceSrs.convertCoordsTo(coords, destinationSrs);\n};\n\n\nexport default MapRefFrame;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/refframe.js\n// module id = 145\n// module chunks = 0 1","\n\nvar MapRenderSlots = function(map) {\n    this.map = map;\n    this.draw = map.draw;\n    this.renderer = map.renderer;\n    this.config = map.config;\n    this.renderSlots = [];\n};\n\n\nMapRenderSlots.prototype.createRenderSlot = function(id, callback, enabled) {\n    return { id:id,\n        callback:callback,\n        enabled : enabled\n    };\n};\n\n\nMapRenderSlots.prototype.addRenderSlot = function(id, callback, enabled) {\n    this.renderSlots.push(this.createRenderSlot(id, callback, enabled));\n};\n\n\nMapRenderSlots.prototype.getRenderSlotIndex = function(id) {\n    return this.map.searchArrayIndexById(this.renderSlots, id); \n};\n\n\nMapRenderSlots.prototype.checkRenderSlotId = function(id) {\n    if (id == 'after-map-render') {\n        return 'map'; \n    } else {\n        return id;\n    }\n};\n\n\nMapRenderSlots.prototype.moveRenderSlotBefore = function(whichId, whereId) {\n    var from = this.getRenderSlotIndex(this.checkRenderSlotId(whichId));\n    var to = this.getRenderSlotIndex(whereId);\n    if (from != -1 && to != -1 && to != from-1) { \n        this.renderSlots.splice(to, 0, this.renderSlots.splice(from, 1)[0]);\n    }\n};\n\n\nMapRenderSlots.prototype.moveRenderSlotAfter = function(whichId, whereId) {\n    var from = this.getRenderSlotIndex(this.checkRenderSlotId(whichId));\n    var to = this.getRenderSlotIndex(whereId);\n    if (from != -1 && to != -1 && to != from+1) {\n        to++; \n        this.renderSlots.splice(to, 0, this.renderSlots.splice(from, 1)[0]);\n    }\n};\n\n\nMapRenderSlots.prototype.removeRenderSlot = function(id) {\n    var index = this.getRenderSlotIndex(id);\n    if (index != -1) {\n        this.renderSlots.splice(index, 1);\n    }\n};\n\n\nMapRenderSlots.prototype.setRenderSlotEnabled = function(id, state) {\n    var index = this.getRenderSlotIndex(id);\n    if (index != -1) {\n        this.renderSlots[index].enabled = state;\n    }\n};\n\n\nMapRenderSlots.prototype.getRenderSlotEnabled = function(id) {\n    var index = this.getRenderSlotIndex(id);\n    if (index != -1) {\n        return this.renderSlots[index].enabled;\n    }\n    \n    return false;\n};\n\n\nMapRenderSlots.prototype.processRenderSlots = function() {\n    if (this.draw.drawChannel != 1) {\n        this.renderer.gpu.setViewport(); //just in case\n    }\n\n    for (var i = 0, li = this.renderSlots.length; i < li; i++) {\n        var slot = this.renderSlots[i];\n\n        if (slot.enabled && slot.callback) {\n            this.renderer.gpu.setState(this.draw.drawTileState);\n            slot.callback(this.draw.drawChannelNames[this.draw.drawChannel]);\n        }\n    }\n};\n\n\nexport default MapRenderSlots;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/render-slots.js\n// module id = 146\n// module chunks = 0 1","\nimport MapTexture_ from './texture';\nimport MapSubtexture_ from './subtexture';\nimport MapMetatile_ from './metatile';\nimport MapMesh_ from './mesh';\nimport MapGeodata_ from './geodata';\n\n//get rid of compiler mess\nvar MapTexture = MapTexture_;\nvar MapSubtexture = MapSubtexture_;\nvar MapMetatile = MapMetatile_;\nvar MapMesh = MapMesh_;\nvar MapGeodata = MapGeodata_;\n\n\nvar MapResourceNode = function(map, parent, id) {\n    this.map = map;\n    this.id = id;\n    this.parent = parent;\n\n    this.metatiles = {};\n    this.meshes = {};\n    this.textures = {};\n    this.subtextures = {};\n    this.geodata = {};\n    this.credits = {};\n\n    this.children = [null, null, null, null];\n};\n\n\nMapResourceNode.prototype.kill = function() {\n    //kill children\n    for (var i = 0; i < 4; i++) {\n        if (this.children[i] != null) {\n            this.children[i].kill();\n        }\n    }\n\n    this.children = [null, null, null, null];\n\n    var parent = this.parent;\n    this.parent = null;\n\n    if (parent != null) {\n        parent.removeChild(this);\n    }\n    \n    //kill resources?\n};\n\n\nMapResourceNode.prototype.addChild = function(index) {\n    if (this.children[index]) {\n        return;\n    }\n    \n    var id = this.id;\n    var childId = [id[0] + 1, id[1] << 1, id[2] << 1];\n\n    switch (index) {\n    case 1: childId[1]++; break;\n    case 2: childId[2]++; break;\n    case 3: childId[1]++; childId[2]++; break;\n    }\n\n    this.children[index] = new MapResourceNode(this.map, this, childId);\n};\n\n\nMapResourceNode.prototype.removeChildByIndex = function(index) {\n    if (this.children[index] != null) {\n        this.children[index].kill();\n        this.children[index] = null;\n    }\n};\n\n\nMapResourceNode.prototype.removeChild = function(tile) {\n    for (var i = 0; i < 4; i++) {\n        if (this.children[i] == tile) {\n            this.children[i].kill();\n            this.children[i] = null;\n        }\n    }\n};\n\n\n// Meshes ---------------------------------\n\nMapResourceNode.prototype.getMesh = function(path, tile) {\n    var mesh = this.meshes[path];\n    \n    if (!mesh) {\n        mesh = new MapMesh(this.map, path, tile);\n        this.meshes[path] = mesh;\n    }\n    \n    return mesh;\n};\n\n\n// Geodata ---------------------------------\n\nMapResourceNode.prototype.getGeodata = function(path, extraInfo) {\n    var geodata = this.geodata[path];\n    \n    if (!geodata) {\n        geodata = new MapGeodata(this.map, path, extraInfo);\n        this.geodata[path] = geodata;\n    }\n    \n    return geodata;\n};\n\n\n// Textures ---------------------------------\n\nMapResourceNode.prototype.getTexture = function(path, type, extraBound, extraInfo, tile, internal) {\n    var texture;\n    if (extraInfo && (extraInfo.layer || extraInfo.hmap)) {\n        var id = path + (extraInfo.hmap ? '' : extraInfo.layer.id);\n        texture = this.textures[id];\n        \n        if (!texture) {\n            texture = new MapTexture(this.map, path, type, extraBound, extraInfo, tile, internal);\n            this.textures[id] = texture;\n        }\n    } else {\n        texture = this.textures[path];\n        \n        if (!texture) {\n            texture = new MapTexture(this.map, path, type, extraBound, extraInfo, tile, internal);\n            this.textures[path] = texture;\n        }\n    }\n    \n    return texture;\n};\n\n\n// SubTextures ---------------------------------\n\nMapResourceNode.prototype.getSubtexture = function(texture, path, type, extraBound, extraInfo, tile, internal) {\n    texture = this.subtextures[path];\n    \n    if (!texture) {\n        texture = new MapSubtexture(this.map, path, type, extraBound, extraInfo, tile, internal);\n        this.subtextures[path] = texture;\n    }\n    \n    return texture;\n};\n\n\n// Metatiles ---------------------------------\n\nMapResourceNode.prototype.addMetatile = function(path, metatile) {\n    this.metatiles[path] = metatile;\n};\n\n\nMapResourceNode.prototype.removeMetatile = function(metatile) {\n    for (var key in this.metatiles) {\n        if (this.metatiles[key] == metatile) {\n            delete this.metatiles[key];\n        }\n    }\n};\n\n\nMapResourceNode.prototype.getMetatile = function(surface, allowCreation, tile) {\n    var metatiles = this.metatiles, metatile; \n    for (var key in metatiles) {\n        if (metatiles[key].surface == surface) {\n            return metatiles[key];\n        } \n    }\n    \n    var path = surface.getMetaUrl(this.id);\n\n    if (metatiles[path]) {\n        metatile = metatiles[path].clone(surface);\n        this.addMetatile(path, metatile);\n        return metatile;\n    }\n\n    if (allowCreation) {\n        metatile = new MapMetatile(this, surface, tile);\n        this.addMetatile(path, metatile);\n        return metatile; \n    } else {\n        return null;\n    }\n};\n\n\nexport default MapResourceNode;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/resource-node.js\n// module id = 147\n// module chunks = 0 1","\nimport MapResourceNode_ from './resource-node';\n\n//get rid of compiler mess\nvar MapResourceNode = MapResourceNode_;\n\n\nvar MapResourceTree = function(map) {\n    this.map = map;\n    this.tree = new MapResourceNode(map, null, [0,0,0]); \n};\n\n\nMapResourceTree.prototype.kill = function() {\n    this.tree.kill();\n};\n\n\nMapResourceTree.prototype.findNode = function(id, createNonexisted) {\n    var node = this.tree; //TODO: fix is it same way as findNavTile\n\n    //console.log(\"--------------findNode: \" + JSON.stringify(id));\n\n//    for (var lod = 1; lod <= id[0]; lod++) {\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((id[1] & mask) != 0) {\n            index += 1;\n        }\n\n        if ((id[2] & mask) != 0) {\n            index += 2;\n        }\n        \n        if (!node.children[index]) {\n            if (createNonexisted) {\n                node.addChild(index);\n                //console.log(\"addNode: \" + JSON.stringify(node.children[index].id));\n            } else {\n                return null;\n            }\n        } \n\n        node = node.children[index];\n    }\n    \n    return node;\n};\n\n\nMapResourceTree.prototype.findAgregatedNode = function(id, agregation, createNonexisted) {\n    //var rootLod = 0;  //TODO: fix is it same way as findNavTile\n    var node = this.tree;\n    var ix = ((id[1] >> agregation) << agregation);\n    var iy = ((id[2] >> agregation) << agregation);\n\n\n//    for (var lod = id[0]; lod > rootLod; lod--) {\n//        var i = lod - rootLod;\n//        var index = 0;\n//        var mask = 1 << (i-1);\n\n    for (var lod = id[0]; lod > 0; lod--) {\n        var mask = 1 << (lod-1);\n        var index = 0;\n\n        if ((ix & mask) != 0) {\n            index += 1;\n        }\n\n        if ((iy & mask) != 0) {\n            index += 2;\n        }\n\n        if (!node.children[index]) {\n            if (createNonexisted) {\n                node.addChild(index);\n            } else {\n                return null;\n            }\n        } \n\n        node = node.children[index];\n    }\n\n    return node;\n};\n\n\nexport default MapResourceTree;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/resource-tree.js\n// module id = 148\n// module chunks = 0 1","\nvar MapStats = function(map) {\n    this.map = map;\n    this.core = map.core;\n    this.inspector = map.core.inspector;\n    this.drawnTiles = 0;\n    this.drawnGeodataTiles = 0;\n    this.drawnGeodataTilesFactor = 0;\n    this.drawnGeodataTilesPerLayer = 0;\n    this.drawnFaces = 0;\n    this.drawCalls = 0;    \n    this.usedNodes = 0;    \n    this.processedNodes = 0;    \n    this.processedMetatiles = 0;    \n    this.counter = 0;\n    this.statsCycle = 0;\n    this.fps = 0;\n    this.frameTime = 0;\n    this.renderTime = 0;\n    this.renderTimeTmp = 0;\n    this.renderTimeBegin = 0;\n    this.renderBuild = 0;\n    this.lastRenderTime = 0;\n    this.lastFrameTime = 0;\n    this.renderedLods = new Array(32);\n    this.debugIds = {};\n\n    this.recordGraphs = false;\n    this.graphsTimeIndex = 0;\n    this.graphsLastTimeIndex = 0;\n    this.graphsTimeSamples = 900;\n    this.graphsRenderTimes = new Array(this.graphsTimeSamples);\n    this.graphsCreateMeshTimes = new Array(this.graphsTimeSamples);\n    this.graphsCreateGpuMeshTimes = new Array(this.graphsTimeSamples);\n    this.graphsCreateTextureTimes = new Array(this.graphsTimeSamples);\n    this.graphsFrameTimes = new Array(this.graphsTimeSamples);\n    this.graphsCpuMemoryMetatiles = new Array(this.graphsTimeSamples);\n    this.graphsCpuMemoryUsed = new Array(this.graphsTimeSamples);\n    this.graphsGpuMemoryTextures = new Array(this.graphsTimeSamples);\n    this.graphsGpuMemoryMeshes = new Array(this.graphsTimeSamples);\n    this.graphsGpuMemoryGeodata = new Array(this.graphsTimeSamples);\n    this.graphsGpuMemoryRender = new Array(this.graphsTimeSamples);\n    this.graphsPolygons = new Array(this.graphsTimeSamples);\n    this.graphsLODs = new Array(this.graphsTimeSamples);\n    this.graphsBuild = new Array(this.graphsTimeSamples);\n    this.graphsFluxTextures = new Array(this.graphsTimeSamples);\n    this.graphsFluxMeshes = new Array(this.graphsTimeSamples);\n    this.graphsFluxGeodatas = new Array(this.graphsTimeSamples);\n    this.graphsFluxTexture = [[0,0],[0,0]];\n    this.graphsFluxMesh = [[0,0],[0,0]];\n    this.graphsFluxGeodata = [[0,0],[0,0]];\n    this.graphsCreateTextureTime = 0;\n    this.graphsCreateGpuMeshTime = 0;\n    this.graphsCreateMeshTime = 0;\n    this.resetGraphs();\n\n    this.gpuMeshes = 0;\n    this.gpuTextures = 0;\n    this.gpuGeodata = 0;\n    this.gpuUsed = 0;\n    this.resourcesUsed = 0;\n    this.metaUsed = 0;\n    this.gpuRenderUsed = 0;\n    this.loadedCount = 0;\n    this.loadErrorCount = 0;\n    this.loadFirst = 0;\n    this.loadLast = 0;\n    this.gpuNeeded = 0;\n    this.gpuNeeded2 = 0;\n\n    this.heightClass = 0;\n    this.heightLod = 0;\n    this.heightNode = 0;\n    this.heightTerrain = 0;\n    this.heightDelta = 0;\n    this.debugStr = null;\n};\n\n//Object.defineProperty(MapStats.prototype, 'gpuNeeded', {\n    //get: function() { return this.gpuNeeded2; /*console.log(\"\"+this.gpuNeeded);*/ },\n    //set: function(value) { \n        //this.gpuNeeded2 = value; console.log(\"\"+this.gpuNeeded);\n    //}\n//});\n\n\nMapStats.prototype.resetGraphs = function() {\n    this.graphsTimeIndex = 0;\n\n    for (var i = 0; i < this.graphsTimeSamples; i++) {\n        this.graphsRenderTimes[i] = 0;\n        this.graphsCreateMeshTimes[i] = 0;\n        this.graphsCreateGpuMeshTimes[i] = 0;\n        this.graphsCreateTextureTimes[i] = 0;\n        this.graphsFrameTimes[i] = 0;\n        this.graphsCpuMemoryUsed[i] = 0;\n        this.graphsCpuMemoryMetatiles[i] = 0;\n        this.graphsGpuMemoryTextures[i] = 0;\n        this.graphsGpuMemoryMeshes[i] = 0;\n        this.graphsGpuMemoryGeodata[i] = 0;\n        this.graphsGpuMemoryRender[i] = 0;\n        this.graphsPolygons[i] = 0;\n        this.graphsLODs[i] = [0,[]];\n        this.graphsBuild[i] = 0;\n        this.graphsFluxTextures[i] = [[0,0],[0,0]];\n        this.graphsFluxMeshes[i] = [[0,0],[0,0]];\n        this.graphsFluxGeodatas[i] = [[0,0],[0,0]];\n    }\n};\n\n\nMapStats.prototype.begin = function(dirty) {\n    if (dirty) {\n        this.drawnTiles = 0;\n        this.drawnGeodataTiles = 0;\n        this.drawnGeodataTilesFactor = 0;\n        this.drawnGeodataTilesPerLayer = 0;\n        this.drawCalls = 0;        \n        this.drawnFaces = 0;\n        this.gpuRenderUsed = 0;\n        this.gpuNeeded = 0;\n        this.usedNodes = 0;    \n        this.processedNodes = 0;    \n        this.processedMetatiles = 0;    \n\n        for (var i = 0, li = this.renderedLods.length; i < li; i++) {\n            this.renderedLods[i] = 0;\n        } \n    }\n\n    this.debugIds = {};\n\n    this.counter++;\n    this.statsCycle++;\n\n    this.renderTimeBegin = performance.now();\n\n    if (dirty) {\n        if (this.lastFrameTime) {\n            this.frameTime = this.renderTimeBegin - this.lastFrameTime;\n        }\n\n        this.lastFrameTime = this.renderTimeBegin;\n    }\n};\n\n\nMapStats.prototype.end = function(dirty) {\n    var timer = performance.now();\n\n    var renderTime = timer - this.renderTimeBegin;\n    //var frameTime = timer - this.frameTime;\n    //this.frameTime = timer;\n    if (dirty) { \n        this.renderTimeTmp += renderTime;\n        this.lastRenderTime = renderTime;\n    } else {\n        this.renderTimeTmp += this.lastRenderTime;\n    }\n\n    if (this.recordGraphs) {\n        var i = this.graphsTimeIndex;\n\n        this.graphsRenderTimes[i] = renderTime;\n        this.graphsCreateMeshTimes[i] = 0;\n        this.graphsCreateGpuMeshTimes[i] = 0;\n        this.graphsCreateTextureTimes[i] = 0;\n        this.graphsFrameTimes[i] = this.frameTime;\n        this.graphsCpuMemoryUsed[i] = this.map.resourcesCache.totalCost;\n        this.graphsCpuMemoryMetatiles[i] = this.map.metatileCache.totalCost;\n        this.graphsGpuMemoryTextures[i] = this.gpuTextures;\n        this.graphsGpuMemoryMeshes[i] = this.gpuMeshes;\n        this.graphsGpuMemoryGeodata[i] = this.gpuGeodata;\n        this.graphsGpuMemoryRender[i] = this.gpuRenderUsed;\n        this.graphsPolygons[i] = this.drawnFaces;\n        this.graphsFluxTextures[i] = [[this.graphsFluxTexture[0][0], this.graphsFluxTexture[0][1]], [this.graphsFluxTexture[1][0], this.graphsFluxTexture[1][1]] ];\n        this.graphsFluxMeshes[i] = [[this.graphsFluxMesh[0][0], this.graphsFluxMesh[0][1]], [this.graphsFluxMesh[1][0], this.graphsFluxMesh[1][1]] ];\n        this.graphsFluxGeodatas[i] = [[this.graphsFluxGeodata[0][0], this.graphsFluxGeodata[0][1]], [this.graphsFluxGeodata[1][0], this.graphsFluxGeodata[1][1]] ];\n        this.graphsLODs[i] = [this.drawnTiles, this.renderedLods.slice()];\n        this.graphsBuild[i] = this.renderBuild;\n\n        this.graphsTimeIndex = (this.graphsTimeIndex + 1) % this.graphsTimeSamples;\n        \n        if (this.inspector && this.inspector.graphs) {\n            this.inspector.graphs.updateGraphs(this);\n        }\n    }\n\n\n    if ((this.statsCycle % 50) == 0) {\n        this.renderTime = this.renderTimeTmp / 100;\n        this.fps = 1000 / this.renderTime;\n        this.renderTimeTmp = 0;\n\n        if (this.inspector && this.inspector.stats) {\n            this.gpuUsed = this.map.gpuCache.totalCost;\n            this.resourcesUsed = this.map.resourcesCache.totalCost;\n            this.metaUsed = this.map.metatileCache.totalCost;\n\n            this.inspector.stats.updateStatsPanel(this);\n        }\n    }\n    \n    //do not reset flux data in begin function, because we to collect data from events which     \n    this.graphsFluxTexture = [[0,0],[0,0]];\n    this.graphsFluxMesh = [[0,0],[0,0]];\n    this.graphsFluxGeodata = [[0,0],[0,0]];\n    this.debugStr = this.map.renderer.debugStr;\n};\n\n\nexport default MapStats;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/stats.js\n// module id = 149\n// module chunks = 0 1","// An index-less mesh. Each triangle has three items in the array 'vertices'.\n\nimport {mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport GpuMesh_ from '../renderer/gpu/mesh';\nimport BBox_ from '../renderer/bbox';\n\n//get rid of compiler mess\nvar mat4 = mat4_;\nvar math = math_;\nvar GpuMesh = GpuMesh_;\nvar BBox = BBox_;\n\n\nvar MapSubmesh = function(mesh, stream) {\n    this.generateLines = true;\n    this.map = mesh.map;\n    this.vertices = null;\n    this.internalUVs = null;\n    this.externalUVs = null;\n    this.indices = null;\n    this.mesh = mesh;\n    this.statsCounter = 0;\n    this.valid = true;\n    this.killed = false;\n    this.use16bit = mesh.use16bit;\n\n    this.bbox = new BBox();\n    this.size = 0;\n    this.faces = 0;\n\n    this.flagsInternalTexcoords =  1;\n    this.flagsExternalTexcoords =  2;\n    this.flagsPerVertexUndulation =  4;\n    this.flagsTextureMode =  8;\n\n    if (stream != null) {\n        this.parseSubmesh(stream);\n    }\n};\n\n\nMapSubmesh.prototype.kill = function () {\n    this.killed = true;\n    this.vertices = null;\n    this.internalUVs = null;\n    this.externalUVs = null;\n};\n\n\n// Reads the mesh from the binary representation.\nMapSubmesh.prototype.parseSubmesh = function (stream) {\n\n/*\nstruct MapSubmesh {\n    struct MapSubmeshHeader header;\n    struct VerticesBlock vertices;\n    struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )\n    struct FacesBlock faces;\n};\n*/\n    this.parseHeader(stream);\n    if (this.mesh.version >= 3) {\n        this.parseVerticesAndFaces2(stream);\n    } else {\n        this.parseVerticesAndFaces(stream);\n    }\n};\n\n\nMapSubmesh.prototype.parseHeader = function (stream) {\n\n/*\nstruct MapSubmeshHeader {\n    char flags;                    // bit 0 - contains internal texture coords\n                                   // bit 1 - contains external texture coords\n                                   // bit 2 - contains per vertex undulation\n                                   // bit 3 - texture mode (0 - internal, 1 - external)\n    \n    uchar surfaceReference;        // reference to the surface of origin, see bellow\n    ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id\n    double boundingBox[2][3];      // read more about bounding box bellow\n};\n*/\n\n    var streamData = stream.data;\n\n    this.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    if (this.mesh.version > 1) {\n        this.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;\n    } else {\n        this.surfaceReference = 0;\n    }\n\n    this.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;\n    this.textureLayer2 = this.textureLayer; //hack for presentation\n\n    var bboxMin = this.bbox.min;\n    var bboxMax = this.bbox.max;\n\n    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n\n    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    \n    this.bbox.updateMaxSize();\n};\n\n\nMapSubmesh.prototype.parseVerticesAndFaces = function (stream) {\n/*\nstruct VerticesBlock {\n    ushort numVertices;              // number of vertices\n\n    struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n        // vertex coordinates\n        ushort x;\n        ushort y;\n        ushort z;\n\n        // if header.flags & ( 1 << 1 ): external texture coordinates\n        // values in 2^16^ range represents the 0..1 normalized texture space\n        ushort eu;\n        ushort ev;\n\n        // if header.flags & ( 1 << 2 ): undulation delta\n        float16 undulationDelta;\n    } vertices[];\n};\n*/\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n\n    var numVertices = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        this.valid = false;\n    }\n\n    var internalUVs = null;\n    var externalUVs = null;\n    var onlyOneUVs = this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords);\n\n    var vertices = this.use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n\n    if (this.flags & this.flagsExternalTexcoords) {\n        if (onlyOneUVs) {\n            externalUVs = true;\n        } else {\n            externalUVs = this.use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n        }\n    }\n\n    var uvfactor = this.use16bit ? 1.0 : (1.0 / 65535);\n    var vindex = 0;\n    var uvindex = 0;\n    var i, li;\n\n    for (i = 0; i < numVertices; i++) {\n        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;\n        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;\n        vindex += 3;\n\n        if (externalUVs) {\n            if (!onlyOneUVs) {\n                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;\n                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;\n                uvindex += 2;\n            }\n            index += 10;\n        } else {\n            index += 6;\n        }\n    }\n\n\n    this.tmpVertices = vertices;\n    this.tmpExternalUVs = externalUVs;\n   \n/*\nstruct TexcoorsBlock {\n    ushort numTexcoords;              // number of texture coordinates\n\n    struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n        // internal texture coordinates\n        // values in 2^16^ range represents the 0..1 normalized texture space\n        ushort u;\n        ushort v;\n    } texcoords[];\n};\n*/\n\n    if (this.flags & this.flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n    \n        internalUVs = this.use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        //var uvfactor = 1.0 / 65535;\n    \n        for (i = 0, li = numUVs * 2; i < li; i+=2) {\n            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;\n            index += 4;\n        }\n    \n        this.tmpInternalUVs = internalUVs;\n    }\n\n/*\nstruct FacesBlock {\n    ushort numFaces;              // number of faces\n\n    struct Face {                 // array of faces, size of array is defined by numFaces property\n\n        ushort v[3]; // array of indices to stored vertices\n        ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n    } faces[];\n};\n*/\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && !(this.flags & this.flagsInternalTexcoords));\n    var onlyInternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = this.use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (this.flags & this.flagsInternalTexcoords) {\n            internalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (this.flags & this.flagsExternalTexcoords)) {\n            externalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = this.tmpVertices;\n    var eUVs = this.tmpExternalUVs;\n    var iUVs = this.tmpInternalUVs;\n    var v1, v2, v3, vv1, vv2, vv3, sindex;\n\n    if (onlyExternalIndices) {\n        vertices = this.tmpVertices;\n        externalUVs = this.tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = this.use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = this.tmpInternalUVs;\n    }\n\n    for (i = 0; i < numFaces; i++) {\n        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));\n        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));\n        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));\n\n        if (onlyIndices) {\n            vindex = i * 3;\n\n            if (internalUVs != null) {\n                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n\n                vertices[vv1*3] = vtmp[v1*3];\n                vertices[vv1*3+1] = vtmp[v1*3+1];\n                vertices[vv1*3+2] = vtmp[v1*3+2];\n\n                vertices[vv2*3] = vtmp[v2*3];\n                vertices[vv2*3+1] = vtmp[v2*3+1];\n                vertices[vv2*3+2] = vtmp[v2*3+2];\n\n                vertices[vv3*3] = vtmp[v3*3];\n                vertices[vv3*3+1] = vtmp[v3*3+1];\n                vertices[vv3*3+2] = vtmp[v3*3+2];\n\n                indices[vindex] = vv1;\n                indices[vindex+1] = vv2;\n                indices[vindex+2] = vv3;\n\n                index += 12;\n            } else {\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n\n                index += 6;\n            }\n\n        } else {\n            vindex = i * (3 * 3);\n\n            sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n\n            if (internalUVs != null) {\n                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n                index += 12;\n\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            } else {\n                index += 6;\n            }\n        }\n    }\n\n    this.vertices = vertices;\n    this.internalUVs = internalUVs;\n    this.externalUVs = externalUVs;\n    this.indices = indices;\n\n    this.tmpVertices = null;\n    this.tmpInternalUVs = null;\n    this.tmpExternalUVs = null;\n\n    stream.index = index;\n\n    this.size = this.vertices.byteLength;\n    if (this.internalUVs) this.size += this.internalUVs.byteLength;\n    if (this.externalUVs) this.size += this.externalUVs.byteLength;\n    if (this.indices) this.size += this.indices.byteLength;\n    this.faces = numFaces;\n};\n\n\nMapSubmesh.prototype.parseWord = function (data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);\n        res[1] += 2;\n    } else {\n        res[0] = value;\n        res[1] ++;\n    }\n};\n\n\nMapSubmesh.prototype.parseDelta = function (data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        value = (value & 0x7f) | (data[res[1]+1] << 7);\n\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] += 2;\n        } else {\n            res[0] = (value >> 1); \n            res[1] += 2;\n        }\n    } else {\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] ++;\n        } else {\n            res[0] = (value >> 1); \n            res[1] ++;\n        }\n    }\n};\n\n\nMapSubmesh.prototype.parseVerticesAndFaces2 = function (stream) {\n/*\nstruct VerticesBlock {\n    ushort numVertices;              // number of vertices\n    ushort geomQuantCoef;            // geometry quantization coefficient\n\n    struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n        // vertex coordinates\n        delta x;\n        delta y;\n        delta z;\n    } vertices[];\n};\n*/\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n    var onlyOneUVs = this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords);\n\n    var numVertices = data.getUint16(index, true); index += 2;\n    var quant = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        this.valid = false;\n    }\n\n    var center = this.bbox.center();\n    var scale = this.bbox.maxSize;\n\n    var multiplier = 1.0 / quant;\n    var externalUVs = null;\n\n    var vertices = this.use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n    var vindex;\n    \n    var x = 0, y = 0,z = 0;\n    var cx = center[0], cy = center[1], cz = center[2];\n    var mx = this.bbox.min[0];\n    var my = this.bbox.min[1];\n    var mz = this.bbox.min[2];\n    var sx = 1.0 / (this.bbox.max[0] - this.bbox.min[0]);\n    var sy = 1.0 / (this.bbox.max[1] - this.bbox.min[1]);\n    var sz = 1.0 / (this.bbox.max[2] - this.bbox.min[2]);\n    \n    var res = [0, index];\n    var i, li, t;\n\n    if (this.use16bit) {\n        for (i = 0; i < numVertices; i++) {\n            this.parseDelta(uint8Data, res);\n            x += res[0];\n            this.parseDelta(uint8Data, res);\n            y += res[0];\n            this.parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            t = ((x * multiplier * scale + cx) - mx) * sx;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex] = t * 65535;\n            t = ((y * multiplier * scale + cy) - my) * sy;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+1] = t * 65535;\n            t = ((z * multiplier * scale + cz) - mz) * sz;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+2] = t * 65535;\n        }\n    } else {\n        for (i = 0; i < numVertices; i++) {\n            this.parseDelta(uint8Data, res);\n            x += res[0];\n            this.parseDelta(uint8Data, res);\n            y += res[0];\n            this.parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;\n            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;\n            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;\n        }\n    }\n    \n    index = res[1];\n\n    if (this.flags & this.flagsExternalTexcoords) {\n        quant = data.getUint16(index, true); index += 2;\n        res[1] = index;\n\n        if (onlyOneUVs) {\n\n            for (i = 0; i < numVertices; i++) {\n                this.parseDelta(uint8Data, res);\n                this.parseDelta(uint8Data, res);\n            }\n\n        } else {\n            multiplier = (this.use16bit) ? (65535 / quant) : (1.0 / quant);\n            externalUVs = this.use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n            x = 0, y = 0;\n\n            if (this.use16bit) {\n                for (i = 0; i < numVertices; i++) {\n                    this.parseDelta(uint8Data, res);\n                    x += res[0];\n                    this.parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    t = x * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex] = t;\n                    t = y * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex+1] = 65535 - t;\n                }\n            } else {\n                for (i = 0; i < numVertices; i++) {\n                    this.parseDelta(uint8Data, res);\n                    x += res[0];\n                    this.parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    externalUVs[uvindex] = x * multiplier;\n                    externalUVs[uvindex+1] = 1 - (y * multiplier);\n                }\n            }\n        }\n    }\n\n    index = res[1];\n\n    this.tmpVertices = vertices;\n    this.tmpExternalUVs = externalUVs;\n    \n/*\nstruct TexcoorsBlock {\n    ushort numTexcoords;              // number of texture coordinates\n\n    struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n        // internal texture coordinates\n        // values in 2^16^ range represents the 0..1 normalized texture space\n        ushort u;\n        ushort v;\n    } texcoords[];\n};\n*/\n\n    if (this.flags & this.flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n        var quantU = data.getUint16(index, true); index += 2;\n        var quantV = data.getUint16(index, true); index += 2;\n        var multiplierU = (this.use16bit) ? (65536.0 / quantU) : (1.0 / quantU);\n        var multiplierV = (this.use16bit) ? (65536.0 / quantV) : (1.0 / quantV);\n        x = 0, y = 0;\n    \n        var internalUVs = this.use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        res[1] = index;7\n\n        if (this.use16bit) {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                this.parseDelta(uint8Data, res);\n                x += res[0];\n                this.parseDelta(uint8Data, res);\n                y += res[0];\n\n                t = x * multiplierU;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i] = t;\n                t = y * multiplierV;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i+1] = 65535 - t;\n            }\n        } else {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                this.parseDelta(uint8Data, res);\n                x += res[0];\n                this.parseDelta(uint8Data, res);\n                y += res[0];\n\n                internalUVs[i] = x * multiplierU;\n                internalUVs[i+1] = 1 - (y * multiplierV);\n            }\n        }\n\n        index = res[1];\n    \n        this.tmpInternalUVs = internalUVs;\n    }\n\n/*\nstruct FacesBlock {\n    ushort numFaces;              // number of faces\n\n    struct Face {                 // array of faces, size of array is defined by numFaces property\n\n        ushort v[3]; // array of indices to stored vertices\n        ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n    } faces[];\n};\n*/\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && !(this.flags & this.flagsInternalTexcoords));\n    var onlyInternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = this.use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (this.flags & this.flagsInternalTexcoords) {\n            internalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (this.flags & this.flagsExternalTexcoords)) {\n            externalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = this.tmpVertices;\n    var eUVs = this.tmpExternalUVs;\n    var iUVs = this.tmpInternalUVs;\n    var high = 0;\n    var v1, v2, v3, vv1, vv2, vv3;\n    res[1] = index;\n\n    for (i = 0; i < numFaces; i++) {\n        this.parseWord(uint8Data, res);\n        v1 = high - res[0];\n        if (!res[0]) { high++; }\n\n        this.parseWord(uint8Data, res);\n        v2 = high - res[0];\n        if (!res[0]) { high++; }\n\n        this.parseWord(uint8Data, res);\n        v3 = high - res[0];\n        if (!res[0]) { high++; }\n\n        if (onlyIndices) {\n            vindex = i * 3;\n            indices[vindex] = v1;\n            indices[vindex+1] = v2;\n            indices[vindex+2] = v3;\n        } else {\n            vindex = i * (3 * 3);\n            var sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n        }\n    }\n\n    if (onlyExternalIndices) {\n        vertices = this.tmpVertices;\n        externalUVs = this.tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = this.use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = this.tmpInternalUVs;\n    }\n\n    high = 0;\n\n    if (internalUVs != null) {\n        for (i = 0; i < numFaces; i++) {\n            this.parseWord(uint8Data, res);\n            v1 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            this.parseWord(uint8Data, res);\n            v2 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            this.parseWord(uint8Data, res);\n            v3 = high - res[0];\n            if (!res[0]) { high++; }\n\n            if (onlyInternalIndices) {\n                vindex = i * 3;\n\n                vv1 = indices[vindex] * 3;\n                vv2 = indices[vindex+1] * 3;\n                vv3 = indices[vindex+2] * 3;\n\n                vertices[v1*3] = vtmp[vv1];\n                vertices[v1*3+1] = vtmp[vv1+1];\n                vertices[v1*3+2] = vtmp[vv1+2];\n\n                vertices[v2*3] = vtmp[vv2];\n                vertices[v2*3+1] = vtmp[vv2+1];\n                vertices[v2*3+2] = vtmp[vv2+2];\n\n                vertices[v3*3] = vtmp[vv3];\n                vertices[v3*3+1] = vtmp[vv3+1];\n                vertices[v3*3+2] = vtmp[vv3+2];\n\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n            } else {\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            }\n        }\n    }\n\n    index = res[1];\n\n    this.vertices = vertices;\n    this.internalUVs = internalUVs;\n    this.externalUVs = externalUVs;\n    this.indices = indices;\n\n    this.tmpVertices = null;\n    this.tmpInternalUVs = null;\n    this.tmpExternalUVs = null;\n\n    stream.index = index;\n\n    this.size = this.vertices.byteLength;\n    if (this.internalUVs) this.size += this.internalUVs.byteLength;\n    if (this.externalUVs) this.size += this.externalUVs.byteLength;\n    if (this.indices) this.size += this.indices.byteLength;\n    this.faces = numFaces;\n};\n\n\n// Returns RAM usage in bytes.\nMapSubmesh.prototype.size = function () {\n    return this.size;\n};\n\n\nMapSubmesh.prototype.fileSize = function () {\n    return this.fileSize;\n};\n\n\nMapSubmesh.prototype.buildGpuMesh = function () {\n    return new GpuMesh(this.map.renderer.gpu, {\n        bbox: this.bbox,\n        vertices: this.vertices,\n        uvs: this.internalUVs,\n        uvs2: this.externalUVs,\n        indices: this.indices\n    }, 1, this.map.core, true, this.use16bit);\n};\n\n\nMapSubmesh.prototype.getWorldMatrix = function(geoPos, matrix) {\n    // Note: the current camera geographic position (geoPos) is not necessary\n    // here, in theory, but for numerical stability (OpenGL ES is float only)\n    // we get rid of the large UTM numbers in the following subtractions. The\n    // camera effectively stays in the position [0,0] and the tiles travel\n    // around it. (The Z coordinate is fine and is not handled in this way.)\n\n    var m = matrix;\n\n    if (m != null) {\n        m[0] = this.bbox.side(0); m[1] = 0; m[2] = 0; m[3] = 0;\n        m[4] = 0; m[5] = this.bbox.side(1); m[6] = 0; m[7] = 0;\n        m[8] = 0; m[9] = 0; m[10] = this.bbox.side(2); m[11] = 0;\n        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;\n    } else {\n        m = mat4.create();\n\n        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),\n                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);\n    }\n\n    return m;\n};\n\n\nMapSubmesh.prototype.drawBBox = function(cameraPos) {\n    var renderer = this.map.renderer;\n\n    renderer.gpu.useProgram(renderer.progBBox, ['aPosition']);\n\n    var mvp = mat4.create();\n    var mv = mat4.create();\n\n    mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);\n\n    var proj = renderer.camera.getProjectionMatrix();\n    mat4.multiply(proj, mv, mvp);\n\n    renderer.progBBox.setMat4('uMVP', mvp);\n\n    //draw bbox\n    renderer.bboxMesh.draw(renderer.progBBox, 'aPosition');\n};\n\n\nexport default MapSubmesh;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/submesh.js\n// module id = 150\n// module chunks = 0 1","\nvar MapSurfaceSequence = function(map) {\n    this.map = map;\n};\n\n\nMapSurfaceSequence.prototype.generateSurfaceSequence = function() {\n    var view = this.map.currentView;\n    var tree = this.map.tree;\n    \n    if (!tree) {\n        return;\n    }\n    \n    tree.surfaceSequence = [];\n    tree.surfaceSequenceIndices = []; //probably not used\n    tree.surfaceOnlySequence = [];\n\n    var vsurfaces = {}, surface, glue; \n    var vsurfaceCount = 0;\n    var list = [], listId, i, li, j , lj, key;\n    var strId = [];\n        \n    //add surfaces to the list\n    for (key in view.surfaces) {\n        surface = this.map.getSurface(key);\n        \n        if (surface) {\n            strId.push(surface.id);\n            vsurfaceCount++;\n            vsurfaces[key] = surface.index + 1; //add one to avoid zero \n            //list.push([\"\" + (surface.index + 1), surface, true]);    \n            list.push([ [(surface.index + 1)], surface, true, false]); //[surfaceId, surface, isSurface, isAlien]    \n        }\n    }\n\n\n    if (vsurfaceCount >= 1) { //do we have virtual surface?\n        strId.sort(); \n        strId = strId.join(';');\n\n        surface = this.map.virtualSurfaces[strId];\n        if (surface) {\n            list = [ [ [(surface.index + 1)], surface, true, false] ]; //[surfaceId, surface, isSurface, isAlien]    \n            vsurfaceCount = 1;\n        }\n    }\n    \n    if (vsurfaceCount > 1) {\n        \n        var glues = [];\n    \n        //add proper glues to the list\n        for (key in this.map.glues) {\n            glue = this.map.glues[key];\n\n            //add only glue which contains desired surfaces\n\n            if (!glue || !glue.id) continue;\n\n            var id = glue.id; \n            if (id.length <= vsurfaceCount) {\n    \n                var missed = false;\n                for (j = 0, lj = id.length; j < lj; j++) {\n                    if (!vsurfaces[id[j]]) {\n                        missed = true;\n                        break;\n                    }\n                }\n    \n                if (!missed) {\n                    //var listId = \"\";\n                    listId = [];\n                    \n                    //create glue id in reverse order for sorting\n                    for (j = 0, lj = id.length; j < lj; j++) {\n                        //listId = vsurfaces[id[j]] + (j ? \".\" : \"\") + listId;\n                        listId.unshift(vsurfaces[id[j]]);\n                    }\n    \n                    glues.push([listId, glue, false, false]); //[surfaceId, surface, isSurface, isAlien]   \n                }\n            }\n        }\n    \n        //process glue flags\n        for (i = 0, li = glues.length; i < li; i++) {\n            var item = glues[i];\n            glue = item[1];\n    \n            glue.flagProper = true;\n            glue.flagAlien = true;\n    \n            if (glue.flagProper) {\n                list.push(item);  \n            }\n                    \n            if (glue.flagAlien) {\n                //remove first surface from id\n                listId = item[0].slice(1);\n                            \n                //add same glue as alien\n                list.push([listId, item[1], false, true]); //[surfaceId, surface, isSurface, isAlien]   \n            }\n        }\n    \n        //sort list alphabetically\n        do {\n            var sorted = true;\n            \n            for (i = 0, li = list.length - 1; i < li; i++) {\n                var a1 = list[i][0];\n                var a2 = list[i+1][0];\n                \n                var lesser = false;\n                \n                for (j = 0, lj = Math.min(a1.length, a2.length); j < lj; j++) {\n                    if (a1[j] < a2[j] || (j == (lj -1) && a1[j] == a2[j] && a2.length > a1.length)) {\n                        lesser = true;\n                        break;                    \n                    }\n                }\n                \n                if (lesser) {\n                    var t = list[i];\n                    list[i] = list[i+1];\n                    list[i+1] = t;\n                    sorted = false;\n                } \n            }\n            \n        } while(!sorted);\n   \n        var lastIndex = vsurfaceCount - 1;\n    \n        //convert list to surface sequence\n        for (i = 0, li = list.length; i < li; i++) {\n            tree.surfaceSequence.push([list[i][1], list[i][3]]); //[surface, isAlien]\n            //this.surfaceSequence.push(list[i][1]); \n            list[i][1].viewSurfaceIndex = lastIndex; \n            \n            if (list[i][2]) {\n                lastIndex--;\n                tree.surfaceOnlySequence.push(list[i][1]);\n            }\n        }\n    \n        //this.generateSurfaceSequenceOld();\n        \n    } else {\n        if (vsurfaceCount == 1) {\n            tree.surfaceSequence.push([list[0][1], list[0][3]]); //[surface, isAlien]\n            list[0][1].viewSurfaceIndex = vsurfaceCount - 1;\n            tree.surfaceOnlySequence = [list[0][1]];\n        }\n    }\n\n    this.map.freeLayersHaveGeodata = false;\n\n    //free layers\n    for (key in view.freeLayers) {\n        var freeLayer = this.map.getFreeLayer(key);\n        if (freeLayer) {\n            freeLayer.surfaceSequence = [freeLayer];\n            freeLayer.surfaceOnlySequence = [freeLayer];\n            \n            if (freeLayer.geodata) {\n                this.map.freeLayersHaveGeodata = true;\n            }\n        }\n    }    \n\n    //just in case\n    this.map.renderer.draw.clearJobBuffer();\n};\n\n\nMapSurfaceSequence.prototype.generateBoundLayerSequence = function() {\n    var view = this.map.currentView;\n    var key, item, layer, alpha, i, li;\n    \n    //surfaces\n    for (key in view.surfaces) {\n        var surfaceLayers = view.surfaces[key];\n        var surface = this.map.getSurface(key);\n        if (surface != null) {\n            surface.boundLayerSequence = [];\n            \n            for (i = 0, li = surfaceLayers.length; i < li; i++) {\n                item = surfaceLayers[i];\n        \n                if (typeof item === 'string') {\n                    layer = this.map.getBoundLayerById(item);\n                    if (layer) {\n                        surface.boundLayerSequence.push([layer, 1]);\n                    }\n                } else {\n                    layer = this.map.getBoundLayerById(item['id']);\n                    if (layer) {\n\n                        alpha = 1;\n                        if (typeof item['alpha'] !== 'undefined') {\n                            alpha = item['alpha'];\n                        }\n\n                        surface.boundLayerSequence.push([layer, alpha]);\n                    }\n                }\n            }\n        }\n    }\n\n    //free layers\n    for (key in view.freeLayers) {\n        var freeLayersProperties = view.freeLayers[key];\n        var freeLayer = this.map.getFreeLayer(key);\n        if (freeLayer != null && freeLayer.ready) {\n            freeLayer.boundLayerSequence = [];\n            \n            var boundLayers = freeLayersProperties['boundLayers'];\n            \n            if (boundLayers && Array.isArray(boundLayers)) {\n\n                for (i = 0, li = boundLayers.length; i < li; i++) {\n                    item = boundLayers[i];\n            \n                    if (typeof item === 'string') {\n                        layer = this.map.getBoundLayerById(item);\n                        if (layer) {\n                            freeLayer.boundLayerSequence.push([layer, 1]);\n                        }\n                    } else {\n                        layer = this.map.getBoundLayerById(item['id']);\n                        if (layer) {\n    \n                            alpha = 1;\n                            if (typeof item['alpha'] !== 'undefined') {\n                                alpha = item['alpha'];\n                            }\n    \n                            freeLayer.boundLayerSequence.push([layer, alpha]);\n                        }\n                    }\n                }\n            }  \n        }\n    }\n};\n\n\nexport default MapSurfaceSequence;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/surface-sequence.js\n// module id = 151\n// module chunks = 0 1","\nimport {vec3 as vec3_} from '../utils/matrix';\nimport GpuTexture_ from '../renderer/gpu/texture';\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\nvar GpuTexture = GpuTexture_;\nvar math = math_;\n\n var tileBorderTable = [\n    [-1, -1, 0, 0],\n    [0, -1, 0.5, 1], //\n    [1, -1, 1, 0],\n\n    [-1, 0, 0, 0.5],\n    [0, 0, 0.5, 0.5],\n    [1, 0, 1, 0.5],\n\n    [-1, 1, 0, 1],\n    [0, 1, 0.5, 0], //\n    [1, 1, 1, 1]\n];\n\nvar tileCornerTable = [\n    [0,1,3],\n    [2,1,5],\n    [6,3,7],\n    [8,7,5]\n];\n\n\nvar MapSurfaceTile = function(map, parent, id) {\n    this.map = map;\n    this.id = id;\n    this.parent = parent;\n    this.viewCounter = map.viewCounter;\n    this.drawCounter = 0;\n    this.childrenReadyCount = 0;\n    this.renderReady = false;\n    this.geodataCounter = 0;\n    this.gridRenderCounter = 0; //draw grid only once\n    this.texelSize = 1;\n    this.texelSize2 = 1;\n    this.distance = 1;\n    this.tiltAngle = 1;\n\n    this.metanode = null;  //[metanode, cacheItem]\n    this.lastMetanode = null;\n    this.boundmetaresources = null; //link to bound layers metatile storage\n\n    this.surface = null; //surface or glue\n    this.surfaceMesh = null;\n    this.surfaceGeodata = null;     //probably only used in free layers\n    this.surfaceGeodataView = null; //probably only used in free layers\n    this.surfaceTextures = [];\n    this.resourceSurface = null; //surface directing to resources\n\n    this.virtual = false;\n    this.virtualReady = false;\n    this.virtualSurfaces = [];\n    \n    this.resetDrawCommands = false;\n    this.drawCommands = [[], [], []];\n\n    this.bounds = {};\n    this.boundLayers = {};\n    this.boundTextures = {};\n    this.updateBounds = true;\n\n    this.hmap = null;\n    this.heightMap = null;\n    this.drawCommands = [[], [], []];\n    this.imageryCredits = {};\n    this.glueImageryCredits = {};\n    this.mapdataCredits = {};\n    \n    this.resources = this.map.resourcesTree.findNode(id, true);   // link to resource tree\n    this.metaresources = this.map.resourcesTree.findAgregatedNode(id, 5, true); //link to meta resource tree\n    this.boundresources = this.map.resourcesTree.findAgregatedNode(id, 8, true); //link to meta resource tree\n    \n    this.children = [null, null, null, null];\n};\n\n\nMapSurfaceTile.prototype.kill = function() {\n    //kill children\n    for (var i = 0; i < 4; i++) {\n        if (this.children[i] != null) {\n            this.children[i].kill();\n        }\n    }\n/*\n    if (this.surfaceMesh != null) {\n        this.surfaceMesh.kill();\n    }\n\n    for (var key in this.surfaceTextures) {\n        if (this.surfaceTextures[key] != null) {\n            this.surfaceTextures[key].kill();\n        }\n    }\n\n    if (this.surfaceGeodata != null) {\n        this.surfaceGeodata.kill();\n    }\n\n    if (this.surfaceGeodataView != null) {\n        this.surfaceGeodataView.kill();\n    }\n\n    if (this.heightMap != null) {\n        this.heightMap.kill();\n    }\n\n    for (var key in this.boundTextures) {\n        if (this.boundTextures[key] != null) {\n            this.boundTextures[key].kill();\n        }\n    }\n*/\n    this.resources = null;\n    this.metaresources = null;\n    this.metanode = null;\n\n    this.surface = null;\n    this.surfaceMesh = null;\n    this.surfaceTextures = [];\n    this.surfaceGeodata = null;\n    this.surfaceGeodataView = null;\n    this.resourceSurface = null;\n\n    this.bounds = {};\n    this.boundLayers = {};\n    this.boundTextures = {};\n    this.updateBounds = true;\n\n    this.virtual = false;\n    this.virtualReady = false;\n    this.virtualSurfaces = [];\n\n    this.renderReady = false;\n    this.lastSurface = null;\n    this.lastState = null;\n    this.lastRenderState = null;\n        \n    this.hmap = null;\n    this.heightMap = null;\n    this.drawCommands = [[], [], []];\n    this.imageryCredits = {};\n    this.glueImageryCredits = {};\n    this.mapdataCredits = {};\n\n    this.verifyChildren = false;\n    this.children = [null, null, null, null];\n\n    var parent = this.parent;\n    this.parent = null;\n\n    if (parent != null) {\n        parent.removeChild(this);\n    }\n};\n\n\nMapSurfaceTile.prototype.validate = function() {\n    //is tile empty?\n    if (this.metaresources == null || !this.metaresources.getMetatile(this.surface, null, this)) {\n        //this.kill();\n    }\n};\n\n\nMapSurfaceTile.prototype.viewSwitched = function() {\n    //store last state for view switching\n    this.lastSurface = this.surface;\n    this.lastState = {\n        surfaceMesh : this.surfaceMesh,\n        surfaceTextures : this.surfaceTextures,\n        boundTextures : this.boundTextures,\n        surfaceGeodata : this.surfaceGeodata,\n        surfaceGeodataView : this.surfaceGeodataView,\n        resourceSurface : this.resourceSurface \n    };    \n\n    if (this.drawCommands[0].length > 0) {  // check only visible chanel\n        this.lastRenderState = {\n            drawCommands : this.drawCommands,\n            imageryCredits : this.imageryCredits,\n            mapdataCredits : this.mapdataCredits\n        };\n    } else {\n        this.lastRenderState = null;\n    }\n    \n    //zero surface related data    \n    this.verifyChildren = true;\n    this.renderReady = false;\n    this.lastMetanode = this.metanode;\n    this.metanode = null; //quick hack for switching virtual surfaeces //keep old value for smart switching\n\n    if (!this.map.config.mapSoftViewSwitch) {\n\n        if (this.metanode) {\n            this.metanode.border = null;\n            this.metanode.border2 = null;\n            this.metanode.border3 = null;\n            this.metanode.borderNodes = null;\n            this.metanode.borderReady = null;\n        }\n\n        this.lastState = null;\n        this.lastRenderState = null;\n        this.lastMetanode = null;\n        this.metanode = null;\n        this.gridPoints = null;\n    }\n\n    //this.lastMetanode = null;\n    //this.metanode = null;\n\n    for (var key in this.bounds) {\n        this.bounds[key] = {\n            sequence : [],\n            alpha : [],\n            transparent : false,\n            viewCoutner : 0\n        };\n    }\n\n    this.boundLayers = {};\n    this.boundTextures = {};\n    this.updateBounds = true;\n    this.transparentBounds = false;\n\n    this.surface = null;\n    this.surfaceMesh = null;\n    this.surfaceTextures = [];\n    this.surfaceGeodata = null;\n    this.surfaceGeodataView = null;\n    this.resourceSurface = null;\n    \n    this.virtual = false;\n    this.virtualReady = false;\n    this.virtualSurfaces = [];\n    this.virtualSurfacesUncomplete = false;\n    \n    this.drawCommands = [[], [], []];\n    this.imageryCredits = {};\n    this.glueImageryCredits = {};\n    this.mapdataCredits = {};\n};\n\n\nMapSurfaceTile.prototype.restoreLastState = function() {\n    if (!this.lastState) {\n        return;\n    }\n    this.surfaceMesh = this.lastState.surfaceMesh;\n    this.surfaceTextures = this.lastState.surfaceTextures; \n    this.boundTextures = this.lastState.boundTextures;\n    this.surfaceGeodata = this.lastState.surfaceGeodata;\n    this.surfaceGeodataView = this.lastState.surfaceGeodataView;\n    this.resourceSurface = this.lastState.resourceSurface; \n    this.lastSurface = null;\n    this.lastState = null;\n    this.lastResourceSurface = null;\n};\n\n\nMapSurfaceTile.prototype.addChild = function(index) {\n    if (this.children[index]) {\n        return;\n    }\n    \n    var id = this.id;\n    var childId = [id[0] + 1, id[1] << 1, id[2] << 1];\n\n    switch (index) {\n    case 1: childId[1]++; break;\n    case 2: childId[2]++; break;\n    case 3: childId[1]++; childId[2]++; break;\n    }\n\n    this.children[index] = new MapSurfaceTile(this.map, this, childId);\n};\n\n\nMapSurfaceTile.prototype.removeChildByIndex = function(index) {\n    if (this.children[index] != null) {\n        this.children[index].kill();\n        this.children[index] = null;\n    }\n    \n    //remove resrource node?\n};\n\n\nMapSurfaceTile.prototype.removeChild = function(tile) {\n    for (var i = 0; i < 4; i++) {\n        if (this.children[i] == tile) {\n            this.children[i].kill();\n            this.children[i] = null;\n        }\n    }\n};\n\n\nMapSurfaceTile.prototype.isMetanodeReady = function(tree, priority, preventLoad) {\n    //has map view changed?\n    if (this.map.viewCounter != this.viewCoutner) {\n        this.viewSwitched();\n        this.viewCoutner = this.map.viewCounter;\n        this.map.markDirty(); \n    }\n        \n    if (!preventLoad) {\n   \n        //provide surface for tile\n        if (this.virtualSurfacesUncomplete || (this.surface == null && this.virtualSurfaces.length == 0) ) { //|| this.virtualSurfacesUncomplete) {\n            this.checkSurface(tree, priority);\n        }\n   \n        //provide metanode for tile\n        if (this.metanode == null || this.lastMetanode) {\n            \n            if (!this.virtualSurfacesUncomplete) {\n                var ret = this.checkMetanode(tree, priority);\n                \n                if (!ret && !(this.metanode != null && this.lastMetanode)) { //metanode is not ready yet\n                    return false;\n                }\n            }\n            \n            /*if (this.lastMetanode) {\n                processFlag2 = true;\n            }*/\n        }\n        \n    }\n\n    if (this.metanode == null) { // || processFlag3) { //only for wrong data\n        return false;\n    }\n\n    this.metanode.metatile.used();\n\n    if (this.lastSurface && this.lastSurface == this.surface) {\n        this.lastSurface = null;\n        this.restoreLastState();\n        //return;\n    }\n\n    if (this.surface) {\n        if (this.surface.virtual) {\n            this.resourceSurface = this.surface.getSurface(this.metanode.sourceReference);\n            if (!this.resourceSurface) {\n                this.resourceSurface = this.surface;\n            }\n        } else {\n            this.resourceSurface = this.surface;\n        }\n    }\n\n    return true;\n};\n\n\nMapSurfaceTile.prototype.checkSurface = function(tree, priority) {\n    this.surface = null;\n    this.virtual = false;\n    this.virtualReady = false;\n    this.virtualSurfaces = [];\n    this.virtualSurfacesUncomplete = false;\n    \n    if (tree.freeLayerSurface) {  //free layer has only one surface\n        this.surface = tree.freeLayerSurface;\n        return; \n    }\n\n    var sequence = tree.surfaceSequence;\n\n    //multiple surfaces\n    //build virtual surfaces array\n    //find surfaces with content\n    for (var i = 0, li = sequence.length; i < li; i++) {\n        var surface = sequence[i][0];\n        var alien = sequence[i][1];\n\n        var res = surface.hasTile2(this.id);\n        if (res[0]) {\n            \n            //check if tile exist\n            if (this.id[0] > 0) { //surface.lodRange[0]) {\n                // removed for debug !!!!!\n                // ????????\n                var parent = this.parent;\n                if (parent) { \n                    \n                    if (parent.virtualSurfacesUncomplete) {\n                        this.virtualSurfacesUncomplete = true;\n                        this.virtualSurfaces = [];\n                        return;\n                    }\n                    \n                    var metatile = parent.metaresources.getMetatile(surface, null, this);\n                    if (metatile) {\n                        \n                        if (!metatile.isReady(priority)) {\n                            this.virtualSurfacesUncomplete = true;\n                            continue;\n                        }\n                        \n                        var node = metatile.getNode(parent.id);\n                        if (node) {\n                            if (!node.hasChildById(this.id)) {\n                                continue;\n                            }\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                }\n            }\n    \n            //store surface\n            this.virtualSurfaces.push([surface, alien]);        \n        }\n    }\n\n    if (this.virtualSurfaces.length > 1) {\n        this.virtual = true;\n    } else {\n        this.surface = (this.virtualSurfaces[0]) ? this.virtualSurfaces[0][0] : null;\n    }\n};\n\n\nMapSurfaceTile.prototype.checkMetanode = function(tree, priority) {\n    if (this.virtual) {\n        if (this.isVirtualMetanodeReady(tree, priority)) {\n            this.metanode = this.createVirtualMetanode(tree, priority);\n            this.lastMetanode = null;\n            this.map.markDirty();\n        } else {\n            return false;\n        }\n    }\n\n    var surface = this.surface;\n\n    if (surface == null) {\n        return false;\n    }\n\n    var metatile = this.metaresources.getMetatile(surface, true, this);\n\n    if (metatile.isReady(priority)) {\n\n        if (!this.virtual) {\n            this.metanode = metatile.getNode(this.id);\n            this.lastMetanode = null;\n            this.map.markDirty(); \n        }\n\n        if (this.metanode != null) {\n            this.metanode.tile = this; //used only for validate\n            this.lastMetanode = null;\n            this.map.markDirty(); \n\n            for (var i = 0; i < 4; i++) {\n                if (this.metanode.hasChild(i)) {\n                    this.addChild(i);\n                } else {\n                    this.removeChildByIndex(i);\n                }\n            }\n        }\n\n    } else {\n        return false;\n    }\n    \n    return true;\n};\n\n\nMapSurfaceTile.prototype.isVirtualMetanodeReady = function(tree, priority) {\n    var surfaces = this.virtualSurfaces;\n    var readyCount = 0;\n\n    for (var i = 0, li = surfaces.length; i < li; i++) {\n        var surface = surfaces[i][0];\n        var metatile = this.metaresources.getMetatile(surface, true, this);\n\n        if (metatile.isReady(priority)) {\n            readyCount++;\n        }\n    }\n    \n    if (readyCount == li) {\n        return true;        \n    } else {\n        return false;\n    }\n};\n\n\nMapSurfaceTile.prototype.createVirtualMetanode = function(tree, priority) {\n    var surfaces = this.virtualSurfaces;\n    var node = null, i, li, surface, metatile, metanode;\n\n    //get top most existing surface\n    for (i = 0, li = surfaces.length; i < li; i++) {\n        surface = surfaces[i][0];\n        var alien = surfaces[i][1];\n        metatile = this.metaresources.getMetatile(surface, null, this);\n\n        if (metatile.isReady(priority)) {\n            metanode = metatile.getNode(this.id);\n\n            if (metanode != null) {\n                if (alien != metanode.alien) {\n                    continue;\n                }\n\n                //does metanode have surface reference?\n                //internalTextureCount is reference to surface\n                if (!alien && surface.glue && !metanode.hasGeometry() &&\n                    metanode.internalTextureCount > 0) {\n                    \n                    var desiredSurfaceIndex = metanode.internalTextureCount - 1;\n                    desiredSurfaceIndex = this.map.getSurface(surface.id[desiredSurfaceIndex]).viewSurfaceIndex;\n                    \n                    var jump = false; \n                        \n                    for (var j = i; j < li; j++) {\n                        if (surfaces[j].viewSurfaceIndex <= desiredSurfaceIndex) {\n                            jump = (j > i);\n                            i = j - 1;\n                            break;\n                        }\n                    }\n                    \n                    if (jump) {\n                        continue;\n                    }                         \n                }\n                \n                if (metanode.hasGeometry()) {\n                    node = metanode.clone();\n                    this.surface = surface;\n                    break;\n                }\n            }\n        }\n    }\n\n    //extend bbox, credits and children flags by other surfaces\n    for (i = 0, li = surfaces.length; i < li; i++) {\n        surface = surfaces[i][0];\n        metatile = this.metaresources.getMetatile(surface, null, this);\n\n        if (metatile.isReady(priority)) {\n            metanode = metatile.getNode(this.id);\n\n            if (metanode != null) {\n                //does metanode have surface reference?\n                //internalTextureCount is reference to surface\n                /*\n                if (surface.glue && !metanode.hasGeometry() &&\n                    metanode.internalTextureCount > 0) {\n                    i = this.map.surfaceSequenceIndices[metanode.internalTextureCount - 1] - 1;\n                    continue;\n                }*/\n\n                if (!node) { //just in case all surfaces are without geometry\n                    node = metanode.clone();\n                    this.surface = surface;\n                } else {\n                    node.flags |= metanode.flags & ((15)<<4); \n\n                    /*\n                    for (var j = 0, lj = metanode.credits.length; j <lj; j++) {\n                        if (node.credits.indexOf(metanode.credits[j]) == -1) {\n                            node.credits.push(metanode.credits[j]);\n                        } \n                    }*/\n                   \n                    if (metatile.useVersion < 4) {\n                        // removed for debug !!!!!\n                        node.bbox.min[0] = Math.min(node.bbox.min[0], metanode.bbox.min[0]); \n                        node.bbox.min[1] = Math.min(node.bbox.min[1], metanode.bbox.min[1]); \n                        node.bbox.min[2] = Math.min(node.bbox.min[2], metanode.bbox.min[2]); \n                        node.bbox.max[0] = Math.max(node.bbox.max[0], metanode.bbox.max[0]); \n                        node.bbox.max[1] = Math.max(node.bbox.max[1], metanode.bbox.max[1]); \n                        node.bbox.max[2] = Math.max(node.bbox.max[2], metanode.bbox.max[2]);\n                    }\n                }\n            }\n        }\n    }\n    \n    if (node) {\n        node.generateCullingHelpers(true);\n    }\n    \n    return node;\n};\n\n\nMapSurfaceTile.prototype.bboxVisible = function(id, bbox, cameraPos, node) {\n    var map = this.map;\n    var camera = map.camera;\n    if (id[0] < map.measure.minDivisionNodeDepth) {\n        return true;\n    }\n    \n    var skipGeoTest = map.config.mapDisableCulling;\n    if (!skipGeoTest && map.isGeocent) {\n        if (node) {\n            //if (true) {  //version with perspektive\n            var p2 = node.diskPos;\n            var p1 = camera.position;\n            var rayVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            var distance = vec3.normalize4(rayVec) * camera.distanceFactor;\n                //vec3.normalize(camVec);\n                \n            var a = vec3.dot(rayVec, node.diskNormal);\n            //} else { //version without perspektive\n            //    var a = vec3.dot(camera.vector, node.diskNormal);\n            //}\n            this.tiltAngle = a;\n            \n            if (distance > 150000 && a > node.diskAngle) {\n                return false;\n            }\n        }\n    }\n\n    if (node.metatile.useVersion >= 4) {\n        return camera.camera.pointsVisible(node.bbox2, cameraPos);\n    } else {\n        if (!(map.isGeocent && (map.config.mapPreciseBBoxTest)) || id[0] < 4) {\n            return camera.camera.bboxVisible(bbox, cameraPos);\n        } else {\n            return camera.camera.pointsVisible(node.bbox2, cameraPos);\n        }\n    }\n};\n\nMapSurfaceTile.prototype.insideCone = function(coneVec, angle, node) {\n\n    if (this.map.isGeocent) { // && node.diskPos && node.diskNormal) {\n        var a = Math.acos(vec3.dot(coneVec, node.diskNormal));\n\n        return (a < angle + node.diskAngle2A);\n    }\n\n    return false;\n};\n\n\nMapSurfaceTile.prototype.getPixelSize = function(bbox, screenPixelSize, cameraPos, worldPos, returnDistance) {\n    var min = bbox.min;\n    var max = bbox.max;\n    var tilePos1x = min[0] - cameraPos[0];\n    var tilePos1y = min[1] - cameraPos[1];\n    var tilePos2x = max[0] - cameraPos[0];\n    var tilePos2y = min[1] - cameraPos[1];\n    var tilePos3x = max[0] - cameraPos[0];\n    var tilePos3y = max[1] - cameraPos[1];\n    var tilePos4x = min[0] - cameraPos[0];\n    var tilePos4y = max[1] - cameraPos[1];\n    var h1 = min[2] - cameraPos[2];\n    var h2 = max[2] - cameraPos[2];\n    \n    //camera inside bbox\n    if (cameraPos[0] > min[0] && cameraPos[0] < max[0] &&\n        cameraPos[1] > min[1] && cameraPos[1] < max[1] &&\n        cameraPos[2] > min[2] && cameraPos[2] < max[2]) {\n\n        if (returnDistance) {\n            return [Number.POSITIVE_INFINITY, 0.1];\n        }\n    \n        return Number.POSITIVE_INFINITY;\n    }\n\n    var factor = 0;\n    var camera = this.map.camera.camera;\n\n    //find bbox sector\n    if (0 < tilePos1y) { //top row - zero means camera position in y\n        if (0 < tilePos1x) { // left top corner\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos1x, tilePos1y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos1x, tilePos1y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos1x, tilePos1y, (h1 + h2)*0.5], returnDistance);\n            }\n        } else if (0 > tilePos2x) { // right top corner\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos2x, tilePos2y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos2x, tilePos2y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos2x, tilePos2y, (h1 + h2)*0.5], returnDistance);\n            }\n        } else { //top side\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, (h1 + h2)*0.5], returnDistance);\n            }\n        }\n    } else if (0 > tilePos4y) { //bottom row\n        if (0 < tilePos4x) { // left bottom corner\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos4x, tilePos4y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos4x, tilePos4y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos4x, tilePos4y, (h1 + h2)*0.5], returnDistance);\n            }\n        } else if (0 > tilePos3x) { // right bottom corner\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos3x, tilePos3y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos3x, tilePos3y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos3x, tilePos3y, (h1 + h2)*0.5], returnDistance);\n            }\n        } else { //bottom side\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, (h1 + h2)*0.5], returnDistance);\n            }\n        }\n    } else { //middle row\n        if (0 < tilePos4x) { // left side\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);\n            }\n        } else if (0 > tilePos3x) { // right side\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);\n            }\n        } else { //center\n            if (0 > h2) { // hi\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);\n            } else if (0 < h1) { // low\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);\n            } else { // middle\n                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);\n            }\n        }\n    }\n\n    //console.log(\"new: \" + (factor * screenPixelSize) + \" old:\" + this.tilePixelSize2(node) );\n\n    if (returnDistance) {\n        return [(factor[0] * screenPixelSize), factor[1]];\n    }\n\n    return (factor * screenPixelSize);\n};\n\n\nMapSurfaceTile.prototype.getPixelSize3Old = function(node, screenPixelSize, factor) {\n    var camera = this.map.camera;\n    var d = (camera.geocentDistance*factor) - node.diskDistance;\n    if (d < 0) {\n        d = -d;\n        //return [Number.POSITIVE_INFINITY, 0.1];\n    } \n\n    var a = vec3.dot(camera.geocentNormal, node.diskNormal);\n    \n    if (a < node.diskAngle2) {\n        var a2 = Math.acos(a); \n        var a3 = Math.acos(node.diskAngle2);\n        a2 = a2 - a3; \n\n        var l1 = Math.tan(a2) * node.diskDistance;\n        d = Math.sqrt(l1*l1 + d*d);\n    }\n\n    factor = camera.camera.scaleFactor2(d);\n    return [factor * screenPixelSize, d];\n};\n\n\nMapSurfaceTile.prototype.getPixelSize3 = function(node, screenPixelSize) {\n    //if (this.map.drawIndices) {\n      //  return this.getPixelSize3Old(node, screenPixelSize, factor);\n    //}\n    var camera = this.map.camera;\n    var cameraDistance = camera.geocentDistance;// * factor;\n\n    var a = vec3.dot(camera.geocentNormal, node.diskNormal); //get angle between tile normal and cameraGeocentNormal\n    var d = cameraDistance - (node.diskDistance + (node.maxZ - node.minZ)), d2; //vertical distance from top bbox level\n\n    if (a < node.diskAngle2) { //is camera inside tile conus?\n        \n        //get horizontal distance\n        var a2 = Math.acos(a); \n        var a3 = node.diskAngle2A;\n        a2 = a2 - a3; \n        var l1 = Math.tan(a2) * node.diskDistance;// * factor;\n\n        if (d < 0) { //is camera is belown top bbox level?\n            d2 = cameraDistance - node.diskDistance;\n            if (d2 < 0) { //is camera is belown bottom bbox level?\n                d = -d2;\n                d = Math.sqrt(l1*l1 + d*d);\n            } else { //is camera inside bbox\n                d = l1;\n            }\n        } else {\n            d = Math.sqrt(l1*l1 + d*d);\n        }\n\n    } else {\n        if (d < 0) { //is camera is belown top bbox level?\n            d2 = cameraDistance - node.diskDistance;\n            if (d2 < 0) { //is camera is belown bottom bbox level?\n                d = -d2;\n            } else { //is camera inside bbox\n                return [Number.POSITIVE_INFINITY, 0.1];\n            }\n        } \n    }\n\n    return [camera.camera.scaleFactor2(d) * screenPixelSize, d];\n};\n\n/*\n\nMapSurfaceTile.prototype.getPixelSize22 = function(bbox, screenPixelSize, cameraPos, worldPos, returnDistance) {\n    var min = bbox.min;\n    var max = bbox.max;\n    var p1 = bbox.center();\n    bbox.updateMaxSize();\n    var d = bbox.maxSize * 0.5; \n    \n    var dd = [cameraPos[0]-p1[0],\n               cameraPos[1]-p1[1],\n               cameraPos[2]-p1[2]]; \n\n    var d2 = vec3.length(dd) - (bbox.maxSize * 0.5);\n\n    var factor = this.camera.scaleFactor2(d2);\n\n    if (returnDistance) {\n        return [(factor[0] * screenPixelSize), factor[1]];\n    }\n\n    return (factor * screenPixelSize);\n};\n*/\n\nMapSurfaceTile.prototype.updateTexelSize = function() {\n    var pixelSize, factor, v, p;\n    var map = this.map;\n    var draw = map.draw;\n    var camera = map.camera;\n    var texelSizeFit = draw.texelSizeFit;\n    var node = this.metanode;\n    var cameraPos = map.camera.position;\n    var preciseDistance = (map.isGeocent && (map.config.mapPreciseDistanceTest || node.metatile.useVersion >= 4));  \n\n    if (node.hasGeometry()) {\n        var screenPixelSize = Number.POSITIVE_INFINITY;\n\n        if (node.usedTexelSize()) {\n            screenPixelSize = draw.ndcToScreenPixel * node.pixelSize;\n        } else if (node.usedDisplaySize()) {\n            screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / node.displaySize);\n        }\n\n        if (camera.camera.ortho) {\n            var height = camera.camera.getViewHeight();\n            pixelSize = [(screenPixelSize*2.0) / height, height];\n        } else {\n            \n            if (node.usedDisplaySize()) { \n               \n                if (!preciseDistance) {\n                    screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / 256);\n\n                    factor = (node.displaySize / 256) * camera.distance;\n                    //var factor = (256 / 256) * this.map.cameraDistance;\n                    \n                    v = camera.vector; //move camera away hack\n                    p = [cameraPos[0] - v[0] * factor, cameraPos[1] - v[1] * factor, cameraPos[2] - v[2] * factor];\n\n                    pixelSize = this.getPixelSize(node.bbox, screenPixelSize, p, p, true);\n                } else {\n                    if (draw.isGeocent) {\n                        //screenPixelSize = draw.ndcToScreenPixel * ((node.diskAngle2A * draw.planetRadius * 2 * 0.70710678118) / 256) * (256 / node.displaySize);\n                        screenPixelSize = draw.ndcToScreenPixel * ((node.diskAngle2A * draw.planetRadius * 1.41421356236) / node.displaySize);\n                    } else {\n                        //screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / 256) * (256 / node.displaySize);\n                        screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / node.displaySize);\n                    }\n\n                    pixelSize = this.getPixelSize3(node, screenPixelSize);\n                }\n            } else {\n                \n                if (!preciseDistance && texelSizeFit > 1.1) {\n                    screenPixelSize = draw.ndcToScreenPixel * node.pixelSize * (texelSizeFit / 1.1);\n                    factor = (texelSizeFit / 1.1) * camera.distance;\n                    \n                    v = camera.vector; //move camera away hack\n                    p = [cameraPos[0] - v[0] * factor, cameraPos[1] - v[1] * factor, cameraPos[2] - v[2] * factor];\n                    \n                    pixelSize = this.getPixelSize(node.bbox, screenPixelSize, p, p, true);\n                } else {\n                    if (preciseDistance) {\n                        pixelSize = this.getPixelSize3(node, screenPixelSize);\n                    } else {\n                        pixelSize = this.getPixelSize(node.bbox, screenPixelSize, cameraPos, cameraPos, true);\n                    }\n                }\n            }\n        }\n    } else {\n        if (preciseDistance) {\n            pixelSize = this.getPixelSize3(node, 1, 1);\n        } else {\n            pixelSize = this.getPixelSize(node.bbox, 1, cameraPos, cameraPos, true);\n        }\n\n        //pixelSize = this.getPixelSize(node.bbox, 1, cameraPos, cameraPos, true);\n        pixelSize[0] = Number.POSITIVE_INFINITY;\n    }\n\n    this.texelSize = pixelSize[0];\n    this.distance = pixelSize[1];\n\n    //degrade horizont\n    if (!map.config.mapDegradeHorizon || draw.degradeHorizonFactor < 1.0) {\n        return;\n    }\n\n    var degradeHorizon = map.config.mapDegradeHorizonParams;\n    var degradeFadeStart = degradeHorizon[1];\n    var degradeFadeEnd = degradeHorizon[2];\n\n    //reduce degrade factor by tilt\n    var degradeFactor = draw.degradeHorizonFactor * draw.degradeHorizonTiltFactor; \n    var distance = this.distance * camera.distanceFactor;\n\n    //apply degrade factor smoothly from specified tile distance\n    if (distance < degradeFadeStart) {\n        degradeFactor = 1.0;\n    } else if (distance > degradeFadeStart && distance < degradeFadeEnd) {\n        degradeFactor = 1.0 + (degradeFactor-1.0) * ((distance - degradeFadeStart) / (degradeFadeEnd - degradeFadeStart));\n    }\n\n    degradeFactor = Math.max(degradeFactor, 1.0);\n\n    //reduce degrade factor by observed distance\n    var observerDistance = camera.perceivedDistance;\n    var distanceFade = degradeHorizon[3];\n\n    if (observerDistance > distanceFade) {\n        degradeFactor = 1.0;\n    } else if (observerDistance < distanceFade && degradeFactor > 1.0) {\n        degradeFactor = 1.0 + ((degradeFactor - 1.0) * (1.0-(observerDistance / distanceFade)));\n    }\n\n    //console.log(\"degrade: \" + degradeFactor);\n\n    this.texelSize /= degradeFactor;\n};\n\n\nMapSurfaceTile.prototype.drawGrid = function(cameraPos, divNode, angle, onlySetBorderData, subdiv) {\n    /* if (!(subdiv || onlySetBorderData)) {\n        if (this.gridRenderCounter != this.map.draw.drawCounter) {\n            this.gridRenderCounter = this.map.draw.drawCounter;\n        } else {\n            return; //prevent rendering same grid more then on time\n        }\n    } */\n\n    if ((this.texelSize == Number.POSITIVE_INFINITY || this.texelSize > 4.4) && this.metanode && this.metanode.hasChildren()) {\n        return;\n    }\n    \n    if (!this.metanode) {\n        return;\n    }\n\n    var map = this.map, node, ll, ur, res;\n\n    if (map.draw.gridSkipped) {\n        return;\n    }\n\n\n    if (divNode) {\n        node = divNode[0]; \n        ll = divNode[1][0];\n        ur = divNode[1][1];\n    } else {\n        res = map.measure.getSpatialDivisionNodeAndExtents(this.id);\n        node = res[0]; \n        ll = res[1][0];\n        ur = res[1][1];\n    }\n   \n    var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5];\n\n    var hasPoles = map.referenceFrame.hasPoles;\n\n    angle = angle || this.metanode.diskAngle2;\n    \n    if ((hasPoles && !node.isPole) &&  Math.acos(angle) > Math.PI*0.1) {\n        angle = Math.cos(Math.acos(angle) * 0.5); \n        \n        this.drawGrid(cameraPos, [node, [ [ll[0], ll[1]],  [middle[0], middle[1]] ] ], angle, false, true);\n        this.drawGrid(cameraPos, [node, [ [middle[0], ll[1]],  [ur[0], middle[1]] ] ], angle, false, true);\n\n        this.drawGrid(cameraPos, [node, [ [ll[0], middle[1]],  [middle[0], ur[1]] ] ], angle, false, true);\n        this.drawGrid(cameraPos, [node, [ [middle[0], middle[1]],  [ur[0], ur[1]] ] ], angle, false, true);\n       \n        return;\n    }\n     \n    var desiredSamplesPerViewExtent = 5;\n    var nodeExtent = node.extents.ur[1] - node.extents.ll[1];\n    var viewExtent = this.distance ;//* 0.1;\n    var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / map.log2;\n    lod = Math.max(0,lod - 8 + node.id[0]);\n   \n    var h, factor, prog, draw = map.draw; \n\n    var sx = cameraPos[0];\n    var sx = cameraPos[0];\n    var sy = cameraPos[1];\n    var sz = cameraPos[2];\n    var buffer = draw.planeBuffer;\n    var flatGrid = draw.gridFlat;\n    var joinGrids = draw.gridGlues; //this.map.draw.debug.drawFog;\n    var gridPoints = this.gridPoints;\n    var useSurrogatez = map.config.mapGridSurrogatez;\n\n    if (!gridPoints) {\n\n        h = useSurrogatez ? this.metanode.surrogatez : this.metanode.minZ;\n        var n1 = node.getPhysicalCoords([ur[0], ur[1], h], true);\n        var n2 = node.getPhysicalCoords([ur[0], ll[1], h], true);\n        var n3 = node.getPhysicalCoords([ll[0], ll[1], h], true);\n        var n4 = node.getPhysicalCoords([ll[0], ur[1], h], true);\n        var mtop = node.getPhysicalCoords([middle[0], ur[1], h], true);\n        var mbottom = node.getPhysicalCoords([middle[0], ll[1], h], true);\n        var mleft = node.getPhysicalCoords([ll[0], middle[1], h], true);\n        var mright = node.getPhysicalCoords([ur[0], middle[1], h], true);\n\n        middle[2] = h;\n        middle = node.getPhysicalCoords(middle, true);\n\n        if (!divNode) {\n\n            var gridPoints = [\n                n4[0], n4[1], n4[2],\n                mtop[0], mtop[1], mtop[2],\n                n1[0], n1[1], n1[2],\n\n                mleft[0], mleft[1], mleft[2],\n                middle[0], middle[1], middle[2],\n                mright[0], mright[1], mright[2],\n                \n                n3[0], n3[1], n3[2],\n                mbottom[0], mbottom[1], mbottom[2],\n                n2[0], n2[1], n2[2]\n            ];\n\n            this.gridPoints = gridPoints;\n\n        } else {\n            buffer[0] = n4[0] - sx;\n            buffer[1] = n4[1] - sy;\n            buffer[2] = n4[2] - sz;\n            \n            buffer[3] = mtop[0] - sx;\n            buffer[4] = mtop[1] - sy;\n            buffer[5] = mtop[2] - sz;\n\n            buffer[6] = n1[0] - sx;\n            buffer[7] = n1[1] - sy;\n            buffer[8] = n1[2] - sz;\n\n            buffer[9] = mleft[0] - sx;\n            buffer[10] = mleft[1] - sy;\n            buffer[11] = mleft[2] - sz;\n                    \n            buffer[12] = middle[0] - sx;\n            buffer[13] = middle[1] - sy;\n            buffer[14] = middle[2] - sz;\n                    \n            buffer[15] = mright[0] - sx;\n            buffer[16] = mright[1] - sy;\n            buffer[17] = mright[2] - sz;\n                \n            buffer[18] = n3[0] - sx;\n            buffer[19] = n3[1] - sy;\n            buffer[20] = n3[2] - sz;\n            \n            buffer[21] = mbottom[0] - sx;\n            buffer[22] = mbottom[1] - sy;\n            buffer[23] = mbottom[2] - sz;\n            \n            buffer[24] = n2[0] - sx;\n            buffer[25] = n2[1] - sy;\n            buffer[26] = n2[2] - sz;\n        }\n     }\n\n\n    if (!flatGrid) {\n\n        var mnode = this.metanode; \n           \n        var border = mnode.border, borderNodes = mnode.borderNodes;\n        var i, li, n, tree = map.tree, id = this.id;\n        \n        if (!border) {\n            mnode.border = new Array(9);\n            mnode.borderNodes = new Array(9);\n            border = mnode.border, borderNodes = mnode.borderNodes;\n            border[4] = useSurrogatez ? mnode.surrogatez : mnode.minZ;\n        }\n        \n\n        var borderTable = tileBorderTable;\n        var skip = false;\n\n        if (!mnode.borderReady) {\n            \n            for (i = 0; i < 9; i++) {\n                if (i != 4 && !borderNodes[i]) {\n                    n = tree.getNodeById([id[0], id[1] + borderTable[i][0], id[2] + borderTable[i][1]], true);\n\n                    if (n) {\n                        borderNodes[i] = n;\n                        border[i] = (useSurrogatez ? n.surrogatez : n.minZ);\n                    } else {\n                        border[i] = border[4];\n                        skip = true;\n                    }\n                }\n            }\n           \n        }\n\n        var border2 = mnode.border2;\n        h = useSurrogatez ? mnode.surrogatez : mnode.minZ\n\n        if (!border2 || !mnode.borderReady) {\n            border2 = [\n                ((border[0] + border[1] + border[3] + border[4]) * 0.25) - h, \n                ((border[1] + border[4]) * 0.5) - h,\n                ((border[2] + border[1] + border[5] + border[4]) * 0.25) - h,\n\n                ((border[3] + border[4]) * 0.5) - h,\n                border[4] - h,\n                ((border[5] + border[4]) * 0.5) - h,\n\n                ((border[6] + border[7] + border[3] + border[4]) * 0.25) - h,\n                ((border[7] + border[4]) * 0.5) - h,\n                ((border[8] + border[7] + border[5] + border[4]) * 0.25) - h\n            ];\n\n            mnode.border2 = border2;\n        }\n\n        if (!skip) {\n            mnode.borderReady = true;\n        }\n\n        if (onlySetBorderData) {\n            return;\n        }\n\n        if (joinGrids) {\n            var cornerTable = tileCornerTable;\n            var nodeTable = this.nodeTable;\n\n            if (!nodeTable) {\n                nodeTable = new Array(9);\n                this.nodeTable = nodeTable;\n            }\n\n            //get bodrer nodes\n            for (i = 0, li = borderTable.length; i < li; i++) {\n                if (i != 4) {\n                    nodeTable[i] = tree.getRenderedNodeById([id[0], id[1] + borderTable[i][0], id[2] + borderTable[i][1]], draw.drawCounter);\n                }\n            }\n\n            var border3 = mnode.border3;\n\n            if (!border3) {\n                border3 = new Array(9);\n                mnode.border3 = border3;\n            }\n\n            //solve corners\n            for (i = 0, li = cornerTable.length; i < li; i++) {\n                var lowestNode = nodeTable[cornerTable[i][0]];\n\n                for (var j = 1; j < 3; j++) {\n                    n = nodeTable[cornerTable[i][j]];\n\n                    if (n) {\n                        if (lowestNode) {\n                            if (n.id[0] < lowestNode.id[0]) {\n                                lowestNode = n;\n                            } \n                        } else {\n                            lowestNode = n;\n                        }\n                    }\n                }\n\n                nodeTable[cornerTable[i][0]] = lowestNode;\n            }\n\n            for (i = 0, li = borderTable.length; i < li; i++) {\n                n = nodeTable[i];\n\n                if (i != 4 && (n && n.id[0] < id[0])) {\n                    var bcoords;\n\n                    switch(i) {\n                        case 0:  bcoords = [mnode.llx, mnode.lly]; break;\n                        case 1:  bcoords = [(mnode.urx+mnode.llx)*0.5, mnode.lly]; break;\n                        case 2:  bcoords = [mnode.urx, mnode.lly]; break;\n                        \n                        case 3:  bcoords = [mnode.llx, (mnode.ury+mnode.lly)*0.5]; break;\n                        case 5:  bcoords = [mnode.urx, (mnode.ury+mnode.lly)*0.5]; break;\n\n                        case 6:  bcoords = [mnode.llx, mnode.ury]; break;\n                        case 7:  bcoords = [(mnode.urx+mnode.llx)*0.5, mnode.ury]; break;\n                        case 8:  bcoords = [mnode.urx, mnode.ury]; break;\n                    }\n\n                    if (!n.border2) {\n                        n.tile.drawGrid(cameraPos, divNode, angle, true);\n                    }\n\n                    if (n.border2) {\n                        mnode.border3[i] = (n.getGridHeight(bcoords, n.border2, 3) + (useSurrogatez ? n.surrogatez : n.minZ))  - h; \n                    } else {\n                        border2[i];\n                    }\n                } else {\n                    mnode.border3[i] = border2[i];\n                }\n            }\n        }                     \n    }\n\n    var renderer = map.renderer;\n    var mv = renderer.camera.getModelviewMatrix();\n    var proj = renderer.camera.getProjectionMatrix();\n\n    if (gridPoints) {\n        buffer[0] = gridPoints[0] - sx;\n        buffer[1] = gridPoints[1] - sy;\n        buffer[2] = gridPoints[2] - sz;\n        \n        buffer[3] = gridPoints[3] - sx;\n        buffer[4] = gridPoints[4] - sy;\n        buffer[5] = gridPoints[5] - sz;\n\n        buffer[6] = gridPoints[6] - sx;\n        buffer[7] = gridPoints[7] - sy;\n        buffer[8] = gridPoints[8] - sz;\n\n        buffer[9] = gridPoints[9] - sx;\n        buffer[10] = gridPoints[10] - sy;\n        buffer[11] = gridPoints[11] - sz;\n                \n        buffer[12] = gridPoints[12] - sx;\n        buffer[13] = gridPoints[13] - sy;\n        buffer[14] = gridPoints[14] - sz;\n                \n        buffer[15] = gridPoints[15] - sx;\n        buffer[16] = gridPoints[16] - sy;\n        buffer[17] = gridPoints[17] - sz;\n            \n        buffer[18] = gridPoints[18] - sx;\n        buffer[19] = gridPoints[19] - sy;\n        buffer[20] = gridPoints[20] - sz;\n        \n        buffer[21] = gridPoints[21] - sx;\n        buffer[22] = gridPoints[22] - sy;\n        buffer[23] = gridPoints[23] - sz;\n        \n        buffer[24] = gridPoints[24] - sx;\n        buffer[25] = gridPoints[25] - sy;\n        buffer[26] = gridPoints[26] - sz;\n    }\n\n    if (hasPoles && !map.poleRadius && node.id[0] == 1 && !node.isPole) {\n        var p = node.getPhysicalCoords([node.extents.ur[0], node.extents.ur[1], 0]);\n        map.poleRadius = Math.sqrt(p[0]*p[0]+p[1]*p[1]); \n        map.poleRadiusFactor = 8 * Math.pow(2.0, 552058 / map.poleRadius); \n    }\n\n    factor = 1;\n\n    var useTexture = (map.config.mapGridTextureLayer != '');\n\n    if (useTexture) {\n        if (!this.gridTexture) {\n\n            var layer = map.boundLayers[map.config.mapGridTextureLayer];\n            var sourceTile = this;\n\n            if (!layer || sourceTile < layer.lodRange[0]) {\n                useTexture = false;\n            } else {\n                var sourceLod = math.clamp(sourceTile.id[0] - map.config.mapGridTextureLevel, layer.lodRange[0], layer.lodRange[3]);\n\n                while (sourceTile.id[0] > sourceLod) {\n                    sourceTile = sourceTile.parent;\n                }\n\n                //(path, type, extraBound, extraInfo, tile, internal)\n                this.gridTexture = this.resources.getTexture(\"gmap#\"+map.config.mapGridTextureLayer, null, {sourceTile: sourceTile, layer:layer, tile: this }, null, null, null);\n                //this.gridTexture.isReady(false, 0, false);\n            }\n\n        }\n\n        if (useTexture && !this.gridTexture.isReady(false, 0, false)) {  //TODO: set params with max priority\n            useTexture = false;       \n        }     \n    }\n\n    if (hasPoles && node.isPole) {\n        factor = map.poleRadiusFactor; \n        prog = renderer.progPlane2; \n        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        prog.setVec4('uParams4', [-sx, -sy, map.poleRadius, 0]);\n    } else {\n\n        if (!flatGrid) {\n            prog = renderer.progPlane3; \n            renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n\n            var border;\n\n            if (joinGrids) {\n                border =  mnode.border3;\n            } else {\n                border = mnode.border2;\n            }\n\n            prog.setFloatArray('uHeights', border);\n            prog.setVec3('uVector', mnode.diskNormal);\n\n        } else {\n            prog = renderer.progPlane; \n            renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        }\n    }\n\n    prog.setMat4('uMV', mv);\n    prog.setMat4('uProj', proj);\n    prog.setFloatArray('uPoints', buffer);\n    \n    /*\n    var lx = (ur[0] - ll[0]);\n    var ly = (ll[1] - ur[1]);\n    var px = (ll[0] - node.extents.ll[0]) / lx;\n    var py = (ur[1] - node.extents.ll[1]) / ly;\n    \n    var llx = (node.extents.ur[0] - node.extents.ll[0]) / lx;\n    var lly = (node.extents.ur[1] - node.extents.ll[1]) / ly;\n\n    px = px / llx;\n    py = py / lly;\n    llx = 1.0/llx;\n    lly = 1.0/lly;\n    \n    llx *= step1;\n    lly *= step1;\n    px *= step1;\n    py *= step1;\n    */\n\n    var step1 = node.gridStep1 * factor;\n\n    var lx = 1.0 / (ur[0] - ll[0]);\n    var ly = 1.0 / (ll[1] - ur[1]);\n    var llx = step1 / ((node.extents.ur[0] - node.extents.ll[0]) * lx);\n    var lly = step1 / ((node.extents.ur[1] - node.extents.ll[1]) * ly);\n    var px = (ll[0] - node.extents.ll[0]) * lx * llx;\n    var py = (ur[1] - node.extents.ll[1]) * ly * lly;\n\n\n    if (useTexture) {\n        renderer.gpu.bindTexture(this.gridTexture.getGpuTexture());\n        prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/15, node.gridStep2 * factor]);\n\n        var tt = this.gridTexture.getTransform();\n\n//        prog.setVec4('uParams3', [tt[2], tt[3]+tt[1], tt[0], tt[1]]);\n        prog.setVec4('uParams3', [tt[2], tt[3], tt[0], tt[1]]);\n\n        //prog.setVec4('uParams3', [(py - Math.floor(py)), (px - Math.floor(px)), lly*0.5, llx*0.5]);\n        prog.setVec4('uParams2', [0, 0, 0, 0]);\n    } else {\n        renderer.gpu.bindTexture(renderer.heightmapTexture);       \n        prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/15, node.gridStep2 * factor]);\n        prog.setVec4('uParams3', [(py - Math.floor(py)), (px - Math.floor(px)), lly, llx]);\n        prog.setVec4('uParams2', [0, 0, node.gridBlend, 0]);\n    }\n    \n    prog.setVec4('uFogColor', draw.atmoColor);\n\n    //draw bbox\n    renderer.planeMesh.draw(prog, 'aPosition', 'aTexCoord');    \n\n    this.map.stats.drawnFaces += renderer.planeMesh.polygons;\n}; \n\n\nMapSurfaceTile.prototype.drawHmapTile = function(cameraPos, divNode, angle, pipeline, texture) {\n    //if ((this.texelSize == Number.POSITIVE_INFINITY || this.texelSize > 4.4) && this.metanode && this.metanode.hasChildren()) {\n      //  return;\n    //}\n    \n    if (!this.metanode) {\n        return;\n    }\n\n    var map = this.map, node, ll, ur, res;\n    var renderer = map.renderer;\n\n    if (!renderer.progHmapPlane) {\n        renderer.initProceduralShaders();\n    }\n\n    if (divNode) {\n        node = divNode[0]; \n        ll = divNode[1][0];\n        ur = divNode[1][1];\n    } else {\n        res = map.measure.getSpatialDivisionNodeAndExtents(this.id);\n        node = res[0]; \n        ll = res[1][0];\n        ur = res[1][1];\n    }\n   \n    var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5];\n    var hasPoles = map.referenceFrame.hasPoles;\n    angle = angle || this.metanode.diskAngle2;\n    \n    if ((hasPoles && !node.isPole) &&  Math.acos(angle) > Math.PI*0.1) {\n        angle = Math.cos(Math.acos(angle) * 0.5); \n        \n        this.drawHmapTile(cameraPos, [node, [ [ll[0], ll[1]],  [middle[0], middle[1]] ] ], angle);\n        this.drawHmapTile(cameraPos, [node, [ [middle[0], ll[1]],  [ur[0], middle[1]] ] ], angle);\n\n        this.drawHmapTile(cameraPos, [node, [ [ll[0], middle[1]],  [middle[0], ur[1]] ] ], angle);\n        this.drawHmapTile(cameraPos, [node, [ [middle[0], middle[1]],  [ur[0], ur[1]] ] ], angle);\n       \n        return;\n    }\n     \n    var desiredSamplesPerViewExtent = 5;\n    var nodeExtent = node.extents.ur[1] - node.extents.ll[1];\n    var viewExtent = this.distance ;//* 0.1;\n    var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / map.log2;\n    lod = Math.max(0,lod - 8 + node.id[0]);\n   \n    var h, factor, prog, draw = map.draw; \n\n    var sx = cameraPos[0];\n    var sx = cameraPos[0];\n    var sy = cameraPos[1];\n    var sz = cameraPos[2];\n    var buffer = draw.planeBuffer;\n    var gridPoints = this.gridPoints;\n    var useSurrogatez = map.config.mapGridSurrogatez;\n\n    if (!gridPoints) {\n\n//        h = this.metanode.minZ;\n        h = 0;//this.metanode.minHeight;\n        var n1 = node.getPhysicalCoords([ur[0], ur[1], h], true);\n        var n2 = node.getPhysicalCoords([ur[0], ll[1], h], true);\n        var n3 = node.getPhysicalCoords([ll[0], ll[1], h], true);\n        var n4 = node.getPhysicalCoords([ll[0], ur[1], h], true);\n        var mtop = node.getPhysicalCoords([middle[0], ur[1], h], true);\n        var mbottom = node.getPhysicalCoords([middle[0], ll[1], h], true);\n        var mleft = node.getPhysicalCoords([ll[0], middle[1], h], true);\n        var mright = node.getPhysicalCoords([ur[0], middle[1], h], true);\n\n        middle[2] = h;\n        middle = node.getPhysicalCoords(middle, true);\n\n        if (!divNode) {\n\n            var gridPoints = [\n                n4[0], n4[1], n4[2],\n                mtop[0], mtop[1], mtop[2],\n                n1[0], n1[1], n1[2],\n\n                mleft[0], mleft[1], mleft[2],\n                middle[0], middle[1], middle[2],\n                mright[0], mright[1], mright[2],\n                \n                n3[0], n3[1], n3[2],\n                mbottom[0], mbottom[1], mbottom[2],\n                n2[0], n2[1], n2[2]\n            ];\n\n            this.gridPoints = gridPoints;\n\n        } else {\n            buffer[0] = n4[0] - sx;\n            buffer[1] = n4[1] - sy;\n            buffer[2] = n4[2] - sz;\n            \n            buffer[3] = mtop[0] - sx;\n            buffer[4] = mtop[1] - sy;\n            buffer[5] = mtop[2] - sz;\n\n            buffer[6] = n1[0] - sx;\n            buffer[7] = n1[1] - sy;\n            buffer[8] = n1[2] - sz;\n\n            buffer[9] = mleft[0] - sx;\n            buffer[10] = mleft[1] - sy;\n            buffer[11] = mleft[2] - sz;\n                    \n            buffer[12] = middle[0] - sx;\n            buffer[13] = middle[1] - sy;\n            buffer[14] = middle[2] - sz;\n                    \n            buffer[15] = mright[0] - sx;\n            buffer[16] = mright[1] - sy;\n            buffer[17] = mright[2] - sz;\n                \n            buffer[18] = n3[0] - sx;\n            buffer[19] = n3[1] - sy;\n            buffer[20] = n3[2] - sz;\n            \n            buffer[21] = mbottom[0] - sx;\n            buffer[22] = mbottom[1] - sy;\n            buffer[23] = mbottom[2] - sz;\n            \n            buffer[24] = n2[0] - sx;\n            buffer[25] = n2[1] - sy;\n            buffer[26] = n2[2] - sz;\n        }\n     }\n\n    var mv = renderer.camera.getModelviewMatrix();\n    var proj = renderer.camera.getProjectionMatrix();\n\n    if (gridPoints) {\n        buffer[0] = gridPoints[0] - sx;\n        buffer[1] = gridPoints[1] - sy;\n        buffer[2] = gridPoints[2] - sz;\n        \n        buffer[3] = gridPoints[3] - sx;\n        buffer[4] = gridPoints[4] - sy;\n        buffer[5] = gridPoints[5] - sz;\n\n        buffer[6] = gridPoints[6] - sx;\n        buffer[7] = gridPoints[7] - sy;\n        buffer[8] = gridPoints[8] - sz;\n\n        buffer[9] = gridPoints[9] - sx;\n        buffer[10] = gridPoints[10] - sy;\n        buffer[11] = gridPoints[11] - sz;\n                \n        buffer[12] = gridPoints[12] - sx;\n        buffer[13] = gridPoints[13] - sy;\n        buffer[14] = gridPoints[14] - sz;\n                \n        buffer[15] = gridPoints[15] - sx;\n        buffer[16] = gridPoints[16] - sy;\n        buffer[17] = gridPoints[17] - sz;\n            \n        buffer[18] = gridPoints[18] - sx;\n        buffer[19] = gridPoints[19] - sy;\n        buffer[20] = gridPoints[20] - sz;\n        \n        buffer[21] = gridPoints[21] - sx;\n        buffer[22] = gridPoints[22] - sy;\n        buffer[23] = gridPoints[23] - sz;\n        \n        buffer[24] = gridPoints[24] - sx;\n        buffer[25] = gridPoints[25] - sy;\n        buffer[26] = gridPoints[26] - sz;\n    }\n\n    if (hasPoles && !map.poleRadius && node.id[0] == 1 && !node.isPole) {\n        var p = node.getPhysicalCoords([node.extents.ur[0], node.extents.ur[1], 0]);\n        map.poleRadius = Math.sqrt(p[0]*p[0]+p[1]*p[1]); \n        map.poleRadiusFactor = 8 * Math.pow(2.0, 552058 / map.poleRadius); \n    }\n\n    var mnode = this.metanode; \n    var testMode = draw.debug.drawTestMode;\n\n    factor = 1;\n\n    if (hasPoles && node.isPole) {\n        factor = map.poleRadiusFactor; \n        prog = renderer.progPlane2; \n        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        prog.setVec4('uParams4', [-sx, -sy, map.poleRadius, 0]);\n    } else {\n\n        switch(testMode) {\n            default:\n            case 0: prog = renderer.progHmapPlane; break;\n            case 1: prog = renderer.progHmapPlane2; break;\n            case 2: prog = renderer.progHmapPlane5; break;\n            case 3: prog = renderer.progHmapPlane6; break;\n            case 4: prog = renderer.progHmapPlane7; break;\n\n            case 8: prog = renderer.progHmapPlane4; break;\n            case 9: prog = pipeline == 1 ? renderer.progHmapPlane3 : renderer.progHmapPlane8; break;\n        }\n\n\n        if (testMode == 3 || testMode == 4) {\n            if (!renderer.ntextures) {\n                renderer.ntextures = [ \n                    new GpuTexture(renderer.gpu, './textures/test/test001.png', renderer.core, null), //0\n                    new GpuTexture(renderer.gpu, './textures/test/test002.png', renderer.core, null), //1\n                    new GpuTexture(renderer.gpu, './textures/test003.jpg', renderer.core, null),      //2\n                    new GpuTexture(renderer.gpu, './textures/download.png', renderer.core, null),     //3\n                    new GpuTexture(renderer.gpu, './textures/test009.jpg', renderer.core, null),      //4\n                    new GpuTexture(renderer.gpu, './textures/test004.jpg', renderer.core, null),      //5\n                    new GpuTexture(renderer.gpu, './textures/test005.jpg', renderer.core, null),      //6\n                    new GpuTexture(renderer.gpu, './textures/nor_sand.jpg', renderer.core, null),     //7\n                    new GpuTexture(renderer.gpu, './textures/test007.jpg', renderer.core, null),      //8\n                    new GpuTexture(renderer.gpu, './textures/test008.jpg', renderer.core, null),      //9\n\n                    new GpuTexture(renderer.gpu, './textures/download (1).png', renderer.core, null),  //10\n                    new GpuTexture(renderer.gpu, './textures/test010.jpg', renderer.core, null),      //11\n                    new GpuTexture(renderer.gpu, './textures/test011.jpg', renderer.core, null),      //12\n                    new GpuTexture(renderer.gpu, './textures/test012.jpg', renderer.core, null),      //13\n                    new GpuTexture(renderer.gpu, './textures/test013.jpg', renderer.core, null),      //14\n                    new GpuTexture(renderer.gpu, './textures/test014.jpg', renderer.core, null),      //15\n                    new GpuTexture(renderer.gpu, './textures/test015.jpg', renderer.core, null),      //16\n                    new GpuTexture(renderer.gpu, './textures/test016.jpg', renderer.core, null),      //17\n                    new GpuTexture(renderer.gpu, './textures/test017.jpg', renderer.core, null),      //18\n                    new GpuTexture(renderer.gpu, './textures/test018.jpg', renderer.core, null)      //18\n\n                    ];\n            }\n        }\n\n//        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aBarycentric']);\n        //renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        renderer.gpu.useProgram(prog, ['aPosition']);\n        prog.setVec3('uVector', mnode.diskNormal);\n\n        //prog.setVec3('uRight', mnode.diskNormal);\n\n        if (gridPoints) {\n            var vecRight = [gridPoints[15] - gridPoints[12], gridPoints[16] - gridPoints[13], gridPoints[17] - gridPoints[14]];\n            var vecTop = [gridPoints[21] - gridPoints[12], gridPoints[22] - gridPoints[13], gridPoints[23] - gridPoints[14]];\n\n            vec3.normalize(vecRight);\n            vec3.normalize(vecTop);\n\n            var vecDir = mnode.diskNormal.slice();\n            //vecDir = [-vecDir[0], -vecDir[1], -vecDir[2]];\n\n            //prog.setVec3('uRight', vecRight);\n            //prog.setVec3('uTop', vecTop);\n\n\n            var mv = map.camera.camera.modelview;\n            var mv2 = vts.mat3.create();\n\n            vts.mat4.toInverseMat3(mv, mv2);\n\n            //vts.mat4.toMat3(mv, mv2);\n            vts.mat3.transpose(mv2);\n\n            vts.mat3.multiplyVec3(mv2, vecTop);\n            vts.mat3.multiplyVec3(mv2, vecDir);\n            vts.mat3.multiplyVec3(mv2, vecRight);\n\n            var space = [\n                vecRight[0], vecRight[1], vecRight[2],\n                vecTop[0], vecTop[1], vecTop[2],\n                vecDir[0], vecDir[1], vecDir[2],\n            ];\n\n            /*\n            var mv3 = vts.mat3.toMat4(mv2);\n            vts.mat4.multiply(mv3, vts.mat3.toMat4(space), mv3);\n            prog.setMat3('uSpace', vts.mat4.toMat3(mv3));\n            */\n            \n            prog.setMat3('uSpace', space);\n        }\n    }\n\n    prog.setMat4('uMV', mv);\n    prog.setMat4('uProj', proj);\n    prog.setFloatArray('uPoints', buffer);\n    \n\n    var step1 = node.gridStep1 * factor;\n    prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/127, node.gridStep2 * factor]);\n\n    if (testMode >= 3 && testMode <= 4) {\n        prog.setVec4('uParams3', [1,1,0,0]);\n    } else {\n        if (texture) {\n            prog.setVec4('uParams3', texture.getTransform());\n        } else {\n            var lx = 1.0 / (ur[0] - ll[0]);\n            var ly = 1.0 / (ll[1] - ur[1]);\n            var llx = step1 / ((node.extents.ur[0] - node.extents.ll[0]) * lx);\n            var lly = step1 / ((node.extents.ur[1] - node.extents.ll[1]) * ly);\n            var px = (ll[0] - node.extents.ll[0]) * lx * llx;\n            var py = (ur[1] - node.extents.ll[1]) * ly * lly;\n\n            prog.setVec4('uParams3', [lly, llx, (py - Math.floor(py)), (px - Math.floor(px))]);\n        }\n    }\n\n    prog.setVec4('uParams2', [0, 0, node.gridBlend, 0]);\n    prog.setVec4('uFogColor', draw.atmoColor);\n\n\n    if (this.hmap.extraBound) {\n        //get height form parent\n        mnode = this.hmap.extraBound.sourceTile.metanode;\n        prog.setVec3('uHeights', [mnode.minHeight, mnode.maxHeight, (1.0/mnode.pixelSize)]);\n        prog.setVec4('uTransform', this.hmap.getTransform());\n    } else {\n        prog.setVec3('uHeights', [mnode.minHeight, mnode.maxHeight, (1.0/mnode.pixelSize)]);\n        prog.setVec4('uTransform', [1,1,0,0]);\n    }\n\n    if (testMode >= 3 && testMode <= 4) {\n        if (!renderer.ntextures[draw.debug.drawTestData].loaded) {\n            return;\n        }\n        renderer.gpu.bindTexture(renderer.ntextures[draw.debug.drawTestData]);\n    } else {\n        if (texture) {\n            renderer.gpu.bindTexture(texture.getGpuTexture());\n        } else {\n            renderer.gpu.bindTexture(renderer.heightmapTexture);\n        }\n    }\n\n    prog.setSampler('uSampler', 0);    \n\n//    if(this.hmap) {\n        renderer.gpu.bindTexture(this.hmap.getGpuTexture(), 1);\n  //  } else {\n        //renderer.gpu.bindTexture(renderer.blackTexture, 1);\n  //      renderer.gpu.bindTexture(renderer.blackTexture2, 1);\n   // }\n\n    prog.setSampler('uSampler2', 1);    \n\n    //draw bbox\n    //renderer.planeMesh2.draw(prog, 'aPosition', 'aTexCoord');    \n    renderer.planeMesh2.draw(prog, 'aPosition');    \n\n    /*\n    if (vecRight && gridPoints) {\n        //renderer.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState);\n        renderer.draw.drawLineString([[gridPoints[12], gridPoints[13], gridPoints[14]], [gridPoints[15], gridPoints[16], gridPoints[17]]], false, 4, [1,0,0,1], null, false, false, false, false);\n        renderer.draw.drawLineString([[gridPoints[12], gridPoints[13], gridPoints[14]], [gridPoints[21], gridPoints[22], gridPoints[23]]], false, 4, [0,0,1,1], null, false, false, false, false);\n\n        renderer.draw.drawLineString([[0, 0, 0], [9000000, 0, 0]], false, 4, [1,0,0,1], null, false, false, false, false);\n        renderer.draw.drawLineString([[0, 0, 0], [0, 9000000, 0, 0]], false, 4, [0,1,0,1], null, false, false, false, false);\n        renderer.draw.drawLineString([[0, 0, 0], [0, 0, 9000000]], false, 4, [0,0,1,1], null, false, false, false, false);\n    }*/\n\n\n    this.map.stats.drawnFaces += renderer.planeMesh2.polygons;\n}; \n\n\nexport default MapSurfaceTile;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/surface-tile.js\n// module id = 152\n// module chunks = 0 1","\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar math = math_;\n\n\nvar MapTrajectory = function(map, p1, p2, options) {\n    this.map = map;\n    this.p1 = p1.clone();\n    this.p2 = p2.clone();\n    this.op2 = p2.clone();\n\n    var hm1 = this.p1.getHeightMode();\n    var hm2 = this.p2.getHeightMode();\n    \n    if (hm1 == 'fix' && hm2 == 'float') {\n        this.p1 = this.map.convert.convertPositionHeightMode(this.p1, 'float', true);\n    } else if (hm1 == 'float' && hm2 == 'fix') {\n        this.p1 = this.map.convert.convertPositionHeightMode(this.p1, 'fix', true);\n    } \n    \n    var vm1 = this.p1.getViewMode();\n    var vm2 = this.p2.getViewMode();\n\n    if (vm1 == 'subj' && vm2 == 'obj') {\n        this.p2 = this.map.convert.convertPositionViewMode(this.p2, 'subj');\n    } else if (vm1 == 'obj' && vm2 == 'subj') {\n        this.p1 = this.map.convert.convertPositionViewMode(this.p1, 'subj');\n    } \n    \n    this.p1.pos[5] = this.p1.pos[5] < 0 ? (360 + (this.p1.pos[5] % 360)) : (this.p1.pos[5] % 360);  \n    this.p2.pos[5] = this.p2.pos[5] < 0 ? (360 + (this.p2.pos[5] % 360)) : (this.p2.pos[5] % 360);  \n    \n    this.pp1 = this.p1.clone();\n\n    this.mode = options['mode'] || 'auto';\n    this.submode = options['submode'] || 'none';\n    this.submode = 'none';\n    this.maxHeight = options['maxHeight'] || 1000000000;\n    this.minDuration = options['minDuration'] || 0;\n    this.maxDuration = options['maxDuration'] || 10000;\n    this.samplePeriod = options['samplePeriod'] || 10;\n    this.fade = options['fade'] || 'none';\n    this.fadePower = options['fadePower'] || 1;\n    this.yawInterpolation = options['yawInterpolation'] || 'shortest';\n\n    this.pv = options['pv'] || 0.15;\n\n    if (!this.map.getNavigationSrs().isProjected()) {\n        this.geodesic = this.map.measure.getGeodesic();\n    } \n    \n    if (options['distanceAzimuth']) {\n        this.distanceAzimuth = true;\n        \n        this.pp2 = this.p1.clone();\n        if (options['destHeight']) {\n            this.pp2.setHeight(options['destHeight']);\n        }\n\n        if (options['destOrientation']) {\n            this.pp2.setHeight(options['destOrientation']);\n        }\n        \n        if (options['destFov']) {\n            this.pp2.setHeight(options['destFov']);\n        }\n\n        this.geoAzimuth = options['azimuth'] || 0; \n        this.geoDistance = options['distance'] || 100;\n        this.distance = this.geoDistance; \n        this.azimuth = this.geoAzimuth % 360;\n        this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;\n\n    } else {\n        this.distanceAzimuth = false;\n            \n        this.pp2 = this.p2.clone();\n\n        //get distance and azimut\n        var res = this.map.measure.getDistance(this.pp1.getCoords(), this.pp2.getCoords());\n        this.distance = res[0];\n        this.azimuth = (res[1] + 90) % 360;\n        this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;\n\n        if (!this.map.getNavigationSrs().isProjected()) {\n            res = this.geodesic.Inverse(this.pp1.pos[2], this.pp1.pos[1], this.pp2.pos[2], this.pp2.pos[1]);\n            this.geoAzimuth = res.azi1; \n            this.geoDistance = res.s12;\n            this.azimuth = this.geoAzimuth % 360;\n            this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;\n        }\n    }\n    \n    //console.log(\"azim: \" + Math.round(this.azimuth) + \" p1: \" + this.p1.pos[5]  + \" p2: \" + this.p2.pos[5]);\n\n    this.detectMode();\n    this.detectDuration();\n    this.detectFlightHeight(options['height']);\n};\n\n\nMapTrajectory.prototype.detectFlightHeight = function(flightHeight) {\n    if (this.mode == 'ballistic') {\n        this.flightHeight = Math.max(this.pp1.getHeight(), this.pp2.getHeight());\n        this.flightHeight += flightHeight || (this.distance * 0.5);\n        this.flightHeight = Math.min(this.flightHeight, this.maxHeight);\n        this.flightHeight -= Math.max(this.pp1.getHeight(), this.pp2.getHeight());\n    }\n};\n\n\nMapTrajectory.prototype.detectMode = function() {\n    if (this.mode == 'auto') {\n        this.mode = (this.distance > 2000) ? 'ballistic' : 'direct';\n    }\n};\n\n\nMapTrajectory.prototype.detectDuration = function() {\n    this.duration = 0;\n    this.headingDuration = 1000;\n    \n    if (this.distance < 500) {\n        this.duration = 1000;\n    } else if (this.distance < 2000) {\n        this.duration = 2000;\n    } else {\n        this.duration = this.distance / 100;\n\n        if (this.duration < 300) {\n            this.duration = 3000;\n        } else {\n            this.headingDuration = 1500;\n        }\n        \n        if (this.duration < 6000) {\n            this.duration = 6000;\n        }\n\n        if (this.duration > 10000) {\n            this.duration = 10000;\n        }\n\n        if (this.mode != 'direct') {\n            this.duration *= 1.8;\n            this.headingDuration *= 1.8;\n        }\n    }\n    \n    if (this.mode != 'direct') {\n        var minDuration = 3 * this.headingDuration; \n        this.duration = Math.max(this.duration, minDuration);\n        \n        if (this.maxDuration < minDuration) {\n            this.duration = this.maxDuration;\n            this.headingDuration = this.maxDuration / 3;\n        }   \n    }    \n    \n    this.duration = Math.min(this.duration, this.maxDuration);\n    this.duration = Math.max(this.duration, this.minDuration);\n};\n\n    \nMapTrajectory.prototype.generate = function() {\n    var samples = new Array(Math.ceil(this.duration / this.samplePeriod)+(this.distanceAzimuth?0:1));\n    var index = 0;\n    \n    for (var time = 0; time <= this.duration; time += this.samplePeriod) {\n        var factor = time / this.duration;\n\n        var p = this.pp1.clone(), x, coords;\n        \n        if (this.mode == 'direct') {\n\n            x = factor;\n            \n            switch(this.fade) {\n            case 'in':\n                switch(this.fadePower) {\n                case 1: factor = x*x; break;\n                case 2: factor = x*x*x; break;\n                case 3: factor = x*x*x*x; break;\n                case 4: factor = x*x*x*x*x; break;\n                case 5: factor = x*x*x*x*x*x; break;\n                case 6: factor = x*x*x*x*x*x*x; break;\n                }\n                break;\n\n            case 'out':\n                x = 1 - x;\n                switch(this.fadePower) {\n                case 1: factor = 1 - (x*x); break;\n                case 2: factor = 1 - (x*x*x); break;\n                case 3: factor = 1 - (x*x*x*x); break;\n                case 4: factor = 1 - (x*x*x*x*x); break;\n                case 5: factor = 1 - (x*x*x*x*x*x); break;\n                case 6: factor = 1 - (x*x*x*x*x*x*x); break;\n                }\n                break;\n\n            case 'inout':\n                switch(this.fadePower) {\n                case 1: factor = x*x*(3 - 2*x); break;\n                case 2: factor = x*x*x * (x * (6*x - 15) + 10); break;\n                case 3: factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); break;\n                case 4: factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); break;\n                case 5: factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); break;\n                case 6: factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); break;\n                }\n                break;\n            }\n            \n            p.setCoords(this.getInterpolatedCoords(factor));\n            p.setHeight(this.getInterpolatedHeight(factor));\n            \n            var o1 = this.pp1.getOrientation(); \n            var o2 = this.pp2.getOrientation(); \n\n            p.setOrientation(this.getInterpolatedOrinetation(o1, o2, factor));\n            p.setFov(this.getInterpolatedFov(factor));\n            p.setViewExtent(this.getInterpolatedViewExtent(factor));\n            \n            samples[index] = p.pos;\n            index++;\n        } else {\n\n            //http://en.wikipedia.org/wiki/Smoothstep\n            x = factor;\n            factor =  x*x*(3 - 2*x);\n            x = factor;\n            factor =  x*x*(3 - 2*x);\n\n            //factor2 includes slow start and end of flight\n            var factor2 =  this.getSmoothFactor(time);\n            \n            if (this.submode == 'piha') {\n                \n                var distanceFactor = (this.distance / this.duration * (time - this.duration / (2 * Math.PI) * Math.sin(2 * Math.PI / this.duration * time))) / this.distance;\n\n                //var f = (time / this.duration) * Math.PI * 2;\n                //var distanceFactor = ((f - Math.sin(f)) / (2 * Math.PI));\n                \n                var pv = this.pv;\n                var h1 = this.pp1.getCoords()[2]; \n                var h2 = this.pp2.getCoords()[2]; \n\n                var height = this.distance / ((this.duration*0.001) * pv * Math.tan(math.radians(this.pp1.getFov()) * 0.5))\n                              * (1 - Math.cos(2 * Math.PI * time / this.duration))\n                              + h1 + (h2 - h1) * time  / this.duration;\n\n                coords = this.getInterpolatedCoords(distanceFactor);\n\n                p.setCoords(coords);\n                p.setHeight(height);            \n            } else {\n\n                coords = this.getInterpolatedCoords(factor2);\n    \n                p.setCoords(coords);\n                p.setHeight(this.getSineHeight(factor));            \n            }\n            \n            if (coords[3] != null) { //used for correction in planet mode\n                this.azimuth = -coords[3];\n            }\n\n            p.setOrientation(this.getFlightOrienation(time));\n            p.setFov(this.getInterpolatedFov(factor));\n            p.setViewExtent(this.getInterpolatedViewExtent(factor));\n            \n            //p.convertViewMode(\"subj\");\n            //console.log(\"pos: \" + p.toString());\n\n            samples[index] = p.pos;\n            samples[index] = p.pos;\n            index++;\n        }\n    }\n    \n    if (!this.distanceAzimuth) {\n        samples[index] = this.op2.clone().pos;\n    }\n\n    //console.log(\"pos2: \" + this.p2.toString());\n\n    return samples;\n};\n\n\nMapTrajectory.prototype.getInterpolatedCoords = function(factor) {\n    var c1 = this.pp1.getCoords(); \n    var c2 = this.pp2.getCoords(); \n\n    if (!this.map.getNavigationSrs().isProjected()) {\n        var res = this.geodesic.Direct(c1[1], c1[0], this.geoAzimuth, this.geoDistance * factor);\n\n        var azimut = res.azi1 - res.azi2;\n\n        //var azimut = (azimut - 90) % 360;\n        azimut = (this.azimuth < 0) ? (360 + azimut) : azimut;\n\n        //azimut = this.azimuth;\n\n\n        return [ res.lon2, res.lat2,\n            c1[2] + (c2[2] - c1[2]) * factor, azimut];\n\n    } else {\n        return [ c1[0] + (c2[0] - c1[0]) * factor,\n            c1[1] + (c2[1] - c1[1]) * factor,\n            c1[2] + (c2[2] - c1[2]) * factor ];\n    }\n};\n\n\nMapTrajectory.prototype.getInterpolatedOrinetation = function(o1, o2, factor) {\n    var od1 = o2[0] - o1[0];\n    var od2 = o2[1] - o1[1];\n    var od3 = o2[2] - o1[2];\n\n    if (this.yawInterpolation == 'shortest') {\n        if (Math.abs(od1) > 180) {\n            if (od1 > 0) {\n                od1 = -(360 - od1);\n            } else {\n                od1 = 360 - Math.abs(od1);\n            }\n        }\n    }\n\n    return [ o1[0] + od1 * factor,\n        o1[1] + od2 * factor,\n        o1[2] + od3 * factor ];\n};\n\n\nMapTrajectory.prototype.getInterpolatedFov = function(factor) {\n    var f1 = this.pp1.getFov(); \n    var f2 = this.pp2.getFov(); \n    return f1 + (f2 - f1) * factor;\n};\n\n\nMapTrajectory.prototype.getInterpolatedViewExtent = function(factor) {\n    var v1 = this.pp1.getViewExtent(); \n    var v2 = this.pp2.getViewExtent(); \n    return v1 + (v2 - v1) * factor;\n};\n\n\nMapTrajectory.prototype.getInterpolatedHeight = function(factor) {\n    var h1 = this.pp1.getHeight(); \n    var h2 = this.pp2.getHeight(); \n    return h1 + (h2 - h1) * factor;\n};\n\n\nMapTrajectory.prototype.getSineHeight = function(factor) {\n    var c1 = this.pp1.getCoords(); \n    var c2 = this.pp2.getCoords(); \n\n    return c1[2] + (c2[2] - c1[2]) * factor +\n           Math.sin(Math.PI * factor) * this.flightHeight;\n};\n\n\nMapTrajectory.prototype.getSmoothFactor = function(time) {\n    var x = 0;\n\n    if (time < this.headingDuration) {\n        x = 0;\n    } else if (time > (this.duration - this.headingDuration)) {\n        x = 1.0;\n    } else {\n        x = Math.min(1.0, (time-this.headingDuration) / (this.duration - this.headingDuration*2));\n    }\n\n    x = x*x*(3 - 2*x);\n    return x*x*(3 - 2*x);\n};\n\n\nMapTrajectory.prototype.getFlightOrienation = function(time) {\n    var o1 = null;\n    var o2 = null;\n    var fo = [0, -90, 0]; //flight orientation\n    var factor = 0;\n\n    //get fly direction angle\n    fo[0] = this.azimuth % 360;\n\n    if (fo[0] < 0) {\n        fo[0] = 360 - Math.abs(fo[0]);\n    }\n\n    if (time <= this.headingDuration) { //start sequence\n        factor = time / this.headingDuration;\n        o1 = this.pp1.getOrientation();\n        o2 = fo;\n    } else if (time >= this.duration - this.headingDuration) { //end sequence\n        factor = (time - (this.duration - this.headingDuration)) / this.headingDuration;\n        o1 = fo;\n        o2 = this.pp2.getOrientation();\n    } else { //fly sequence\n        factor = 0;\n        o1 = fo;\n        o2 = fo;\n    }    \n    \n    return this.getInterpolatedOrinetation(o1, o2, factor);\n};\n\n\nexport default MapTrajectory;\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/trajectory.js\n// module id = 153\n// module chunks = 0 1","\nimport {utils as utils_} from '../utils/utils';\nimport {utilsUrl as utilsUrl_} from '../utils/url';\n\n//get rid of compiler mess\nvar utilsUrl = utilsUrl_;\nvar utils = utils_;\n\n\nvar MapUrl = function(map, path) {\n    this.map = map;\n\n    path = path.trim();\n    this.baseUrl = utilsUrl.getBase(path);\n    this.baseUrlSchema = utilsUrl.getSchema(path);\n    this.baseUrlOrigin = utilsUrl.getOrigin(path); \n\n    this.urlCounter = 0;\n};\n\n\nMapUrl.prototype['quad'] = function(lod, ix, iy) {\n    var quadKey = '';\n    //ty = Math.pow(2,zoom - 1) - ty;\n    for (var i = lod; i > 0; i--) {\n        var digit = 0;\n        var mask = 1 << (i-1);\n        if ((ix & mask) != 0) {\n            digit += 1;\n        }\n\n        if ((iy & mask) != 0) {\n            digit += 2;\n        }\n\n        quadKey += digit;\n    }\n\n    return quadKey;\n};\n\n\nMapUrl.prototype['msDigit'] = function(iy, ix) {\n    return (((iy & 3) << 1) + (ix & 1));\n};\n\n\nMapUrl.prototype.hex = function(v) {\n    var s = v.toString(16);\n    while (s.length < 8) {\n        s = '0' + s;\n    }\n    return s;\n};\n\n\nMapUrl.prototype['ppx'] = function(lod, ix) {\n    return this.hex(ix << (28 - lod), 7);\n};\n\n\nMapUrl.prototype['ppy'] = function(lod, iy) {\n    return this.hex((1 << 28) - ((iy + 1) << (28 - lod)), 7);\n};\n\n\nMapUrl.prototype.processUrlFunction = function(id, counter, string) {\n    var string2, fc;\n    if (typeof string == 'string') {\n        if (string.indexOf('quad') != -1) {\n            string2 = '(function(lod,x,y,loclod,locx,locy){' + string.replace('quad', 'return this.quad') + '})';\n\n            try {\n                fc = eval(string2).bind(this);\n                return fc(id.lod, id.ix, id.iy, id.loclod, id.locx, id.locy);\n            } catch(e) {\n                return string;\n            }\n        } else if (string.indexOf('msdigit') != -1) {\n            string2 = '(function(x,y,loclod,locx,locy){' + string.replace('msdigit', 'return this.msDigit') + '})';\n\n            try {\n                fc = eval(string2).bind(this);\n                return fc(id.ix, id.iy, id.loclod, id.locx, id.locy);\n            } catch(e) {\n                return string;\n            }\n\n        } else if (string.indexOf('alt') != -1) {\n            var result = /\\(([^)]*)\\)/.exec(string);\n\n            if (result && result[1]) {\n                var strings = result[1].match(/([^,]+)/g);\n\n                if (strings.length > 0) {\n                    return strings[(counter % strings.length)];\n                }\n            }\n\n            return string;\n\n        } else if (string.indexOf('ppx') != -1) {\n            string2 = '(function(lod,x,loclod,locx){' + string.replace('ppx', 'return this.ppx') + '})';\n\n            try {\n                fc = eval(string2).bind(this);\n                return fc(id.lod, id.ix, id.loclod, id.locx);\n            } catch(e) {\n                return string;\n            }\n\n        } else if (string.indexOf('ppy') != -1) {\n            string2 = '(function(lod,y,loclod,locy){' + string.replace('ppy', 'return this.ppy') + '})';\n\n            try {\n                fc = eval(string2).bind(this);\n                return fc(id.lod, id.iy, id.loclod, id.locy);\n            } catch(e) {\n                return string;\n            }\n\n        } else {\n            return string;\n        }\n\n    } else {\n        return string;\n    }\n};\n\n\nMapUrl.prototype.findLocalRoot = function(id) {\n    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();\n    var validNodes = [];  \n\n    for (var i = 0, li = nodes.length; i < li; i++) {\n        var node = nodes[i];\n        \n        var delta = id[0] - node.id[0];\n        var ix = id[1] >> delta;\n        var iy = id[2] >> delta;\n        \n        if (ix == node.id[1] && iy == node.id[2]) {\n            validNodes.push(node);           \n        }\n    }\n\n    var bestNode = null;\n    var bestLod = -1;\n    \n    for (i = 0, li = validNodes.length; i < li; i++) {\n        if (validNodes[i].id[0] > bestLod) {\n            bestNode = validNodes[i]; \n        }\n    }\n    \n    if (bestNode) {\n        return bestNode.id.slice();\n    } else {\n        return [0,0,0];\n    }\n};\n\n\nMapUrl.prototype.makeUrl = function(templ, id, subId, skipBaseUrl) {\n    //if (templ.indexOf(\"jpg\") != -1) {\n       //templ = \"{lod}-{easting}-{northing}.jpg?v=4\";\n       //templ = \"{lod}-{x}-{y}.jpg?v=4\";\n       //templ = \"{quad(lod,x,y)}.jpg?v=4\";\n       //templ = \"{quad(lod,x+1,y*2)}.jpg?v=4\";\n       //templ = \"{lod}-{msdigit(x,y)}.jpg?v=4\";\n    //}\n    //templ = \"maps{alt(1,2,3,4)}.irist-test.citationtech.net/map/{lod}-{x}-{y}.jpg?v=4\";\n\n    var locx = 0;\n    var locy = 0;\n    var loclod = 0;\n\n    if (id.lod) {\n        var localRoot = this.findLocalRoot([id.lod, id.ix, id.iy]);    \n        loclod = id.lod - localRoot[0];\n        var mask = (1 << loclod) - 1;\n        locx = id.ix & mask;\n        locy = id.iy & mask;        \n    }\n    \n    var id2 = {\n        lod: id.lod,\n        ix : id.ix,\n        iy : id.iy,\n        loclod: loclod,\n        locx : locx,\n        locy : locy\n    };\n\n    //remove white spaces from template\n    templ = templ.replace(/ /g, '');\n\n    var url = utils.simpleFmtObjOrCall(templ, {'lod':id.lod,  'x':id.ix, 'y':id.iy, 'sub': subId,\n        'locx':locx, 'locy':locy, 'loclod':loclod, 'geonavtile': subId,\n        'hereappid': 'abcde', 'hereappcode':'12345'},\n                                               this.processUrlFunction.bind(this, id2, this.urlCounter));\n\n    this.urlCounter++;\n\n    skipBaseUrl = (url.indexOf('//') != -1);\n\n    /* //useful for debug\n    var tmp;\n\n    if (skipBaseUrl) {\n        tmp =  url;\n    } else {\n        tmp = this.baseUrl + url;\n    }\n    */\n\n    if (skipBaseUrl) {\n        if (url.indexOf('//') == 0) {\n            return this.baseUrlSchema + url;\n        } else {\n            return url;\n        }\n    } else {\n        return this.baseUrl + url;\n    }\n};\n\n\nMapUrl.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n    \n    url = url.trim();\n\n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.baseUrlOrigin + url;\n    } else {  //relative\n        return this.baseUrl + url; \n    }\n};\n\n\nexport default MapUrl;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/url.js\n// module id = 154\n// module chunks = 0 1","\nimport {utils as utils_} from '../utils/utils';\nimport BBox_ from '../renderer/bbox';\n\n//get rid of compiler mess\nvar BBox = BBox_;\nvar utils = utils_;\n\n\nvar MapVirtualSurface = function(map, json) {\n    this.map = map;\n    this.id = null;\n    this.metaUrl = '';\n    this.mappingUrl = '';\n    this.baseUrl = this.map.url.baseUrl;\n    this.baseUrlSchema = this.map.url.baseUrlSchema;\n    this.baseUrlOrigin = this.map.url.baseUrlOrigin;\n    this.lodRange = [0,0];\n    this.tileRange = [[0,0],[0,0]];\n    this.surfaces = [];\n    this.parseJson(json);\n    this.virtual = true;\n    this.ready = false;\n};\n\n\nMapVirtualSurface.prototype.parseJson = function(json) {\n    this.id = json['id'] || null;\n    this.metaUrl = this.processUrl(json['metaUrl'], '');\n    this.mappingUrl = this.processUrl(json['mapping'], '');\n    this.lodRange = json['lodRange'] || [0,0];\n    this.tileRange = json['tileRange'] || [[0,0],[0,0]];\n    this.strId = this.id ? this.id.join(';') : null;\n\n    if (this.id) {\n        var tmp = this.id.slice();\n        tmp.sort(); \n        this.strId = tmp.join(';');\n    }\n\n    if (json['extents']) {\n        var ll = json['extents']['ll'];\n        var ur = json['extents']['ur'];\n        this.extents = new BBox(ll[0], ll[1], ll[2], ur[0], ur[1], ur[2]);\n    } else {\n        this.extents = new BBox(0,0,0,1,1,1);\n    }\n\n    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    \n\n    utils.loadBinary(this.mappingUrl, this.onMappingFileLoaded.bind(this), this.onMappingFileLoadError.bind(this), (utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);\n};\n\n\nMapVirtualSurface.prototype.onMappingFileLoaded = function(data) {\n    this.parseMappingFile(new DataView(data));            \n    this.ready = true;\n    this.map.refreshView();\n};\n\n\nMapVirtualSurface.prototype.onMappingFileLoadError = function() {\n};\n\n\nMapVirtualSurface.prototype.parseMappingFile = function(data) {\n    var index = 0;\n\n    var magic = '';\n    magic += String.fromCharCode(data.getUint8(index, true)); index += 1;\n    magic += String.fromCharCode(data.getUint8(index, true)); index += 1;\n\n    if (magic != 'TM') {\n        return false;\n    }\n\n    var count = data.getUint16(index, true); index += 2;\n\n    for (var i = 0; i < count; i++) {\n        var size = data.getUint8(index, true); index += 1;\n        var id = [];\n\n        for (var j = 0; j < size; j++) {\n            var s = data.getUint16(index, true); index += 2;\n            s = this.id[s];\n            \n            if (s) {\n                id.push(s);\n            }\n        }\n        \n        if (id.length == 1) { //get surface\n            this.surfaces.push(this.map.getSurface(id[0]));\n        } else { //get glue\n            this.surfaces.push(this.map.getGlue(id.join(';')));\n        }\n    }\n\n    return true;    \n};\n\n\nMapVirtualSurface.prototype.getInfo = function() {\n    return {\n        'metaUrl' : this.metaUrl,\n        'mapping' : this.mappingUrl,\n        'lodRange' : this.lodRange,\n        'tileRange' : this.tileRange\n    };\n};\n\n\nMapVirtualSurface.prototype.processUrl = function(url, fallback) {\n    if (!url) {\n        return fallback;\n    }\n\n    url = url.trim();\n    \n    if (url.indexOf('://') != -1) { //absolute\n        return url;\n    } else if (url.indexOf('//') == 0) {  //absolute without schema\n        return this.baseUrlSchema + url;\n    } else if (url.indexOf('/') == 0) {  //absolute without host\n        return this.baseUrlOrigin + url;\n    } else {  //relative\n        return this.baseUrl + url; \n    }\n};\n\n\nMapVirtualSurface.prototype.hasTile = function(id) {\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift < 0) {\n        return false;\n    }\n\n    var x = id[1] >> shift;\n    var y = id[2] >> shift;\n\n    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||\n        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n        return false;\n    }\n\n    return true;\n};\n\n\nMapVirtualSurface.prototype.hasTile2 = function(id) {\n    var shift = id[0] - this.lodRange[0];\n    var above = (shift < 0);\n\n    if (id[0] < this.lodRange[0]) {\n        shift = -shift;\n        var x1 = this.tileRange[0][0] >> shift;\n        var y1 = this.tileRange[0][1] >> shift;\n        var x2 = this.tileRange[1][0] >> shift;\n        var y2 = this.tileRange[1][1] >> shift;\n    \n        if (id[0] > this.lodRange[1] ||\n            id[1] < x1 || id[1] > x2 ||\n            id[2] < y1 || id[2] > y2 ) {\n            return [false , false];\n        }\n    } else {\n        var x = id[1] >> shift;\n        var y = id[2] >> shift;\n    \n        if (id[0] > this.lodRange[1] ||\n            x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n            return [false , false];\n        }\n    }\n\n    return [true, above];\n};\n\n\nMapVirtualSurface.prototype.hasMetatile = function(id) {\n    if (id[0] > this.lodRange[1]) {\n        return false;\n    }\n\n    var shift = id[0] - this.lodRange[0];\n\n    if (shift >= 0) {\n        var x = id[1] >> shift;\n        var y = id[2] >> shift;\n\n        if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||\n            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {\n            return false;\n        }\n\n    } else {\n        shift = -shift;\n\n        if (id[1] < (this.tileRange[0][0]>>shift) || id[1] > (this.tileRange[1][0]>>shift) ||\n            id[2] < (this.tileRange[0][1]>>shift) || id[2] > (this.tileRange[1][1]>>shift) ) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\n//used only for glues\nMapVirtualSurface.prototype.getSurface = function(index) {\n    return this.surfaces[index - 1];\n};\n\n\nMapVirtualSurface.prototype.getMetaUrl = function(id, skipBaseUrl) {\n    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);\n};\n\n\nexport default MapVirtualSurface;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/map/virtual-surface.js\n// module id = 155\n// module chunks = 0 1","\nimport {vec3 as vec3_, vec4 as vec4_, mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\n\n//get rid of compiler mess\nvar vec3 = vec3_, vec4 = vec4_, mat4 = mat4_;\nvar math = math_;\n\n\nvar Camera = function(parent, fov, near, far) {\n    this.parent = parent;\n    this.position = [0,0,0];\n    this.orientation = [0,0,0];\n    this.aspect = 1;\n    this.fov = fov;\n    this.fovTan = Math.tan(fov * Math.PI / 180.0);\n    this.fovDist = 1;\n    this.near = near;\n    this.far = far;\n    this.rotationByMatrix = false;\n\n    // derived quantities, calculated from camera parameters by update()\n    this.modelview = mat4.create();\n    this.rotationview = mat4.create();\n    this.projection = mat4.create();\n    this.mvp = mat4.create();\n    this.mvp32 = new Float32Array(16);\n    this.modelview32 = new Float32Array(16);\n    this.rotationview32 = new Float32Array(16);\n    this.projection32 = new Float32Array(16);\n\n    this.frustumPlanes = [ [0,0,0,0], [0,0,0,0], [0,0,0,0],\n                           [0,0,0,0], [0,0,0,0], [0,0,0,0] ];\n    this.bboxPoints = [\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ],\n        [ 0, 0, 0, 1 ]\n    ];\n\n    //reduce garbage collection\n    this.scaleFactorVec = [0,0,0,0];\n    this.dirty = true;\n};\n\n\nCamera.prototype.setPosition = function(position) {\n    this.position = position;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setOrientation = function(orientation) {\n    this.rotationByMatrix = false;\n    this.orientation = orientation;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setRotationMatrix = function(matrix){\n    this.rotationByMatrix = true;\n    this.rotationview = matrix.slice();\n    this.dirty = true;\n};\n\n\n// Sets the viewport aspect ratio (width / height). Should be called\n// whenever the rendering viewport changes.\nCamera.prototype.setAspect = function(aspect) {\n    this.aspect = aspect;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setViewHeight = function(height) {\n    this.viewHeight = height;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setOrtho = function(state) {\n    this.ortho = state;\n    this.dirty = true;\n};\n\n\nCamera.prototype.setParams = function(fov, near, far) {\n    this.fov = fov;\n    this.near = near;\n    this.far = far;\n    this.dirty = true;\n};\n\n\nCamera.prototype.clone = function(newFov) {\n    var camera = new Camera(this. parent, (newFov != null) ? newFov : this.getFov(), this.getNear(), this.getFar());\n\n    camera.setPosition(this.getPosition());\n    camera.setOrientation(this.getOrientation());\n    camera.setAspect(this.getAspect());\n    camera.update();\n\n    return camera;\n};\n\n\n// simple getters\nCamera.prototype.getPosition = function(){ return [this.position[0], this.position[1], this.position[2]]; };\nCamera.prototype.getOrientation = function(){ return [this.orientation[0], this.orientation[1], this.orientation[2]]; };\nCamera.prototype.getAspect = function(){ return this.aspect; };\nCamera.prototype.getFov = function(){ return this.fov; };\nCamera.prototype.getNear = function(){ return this.near; };\nCamera.prototype.getFar = function(){ return this.far; };\nCamera.prototype.getViewHeight = function(){ return this.viewHeight; };\nCamera.prototype.getOrtho = function(){ return this.ortho; };\n\n\n// Returns rotation matrix\nCamera.prototype.getRotationviewMatrix = function() {\n    if (this.dirty) this.update();\n    return this.rotationview;\n};\n\nCamera.prototype.getRotationviewFMatrix = function() {\n    if (this.dirty) this.update();\n    return this.rotationview32;\n};\n\n// Returns a matrix that transforms the world space to camera space.\nCamera.prototype.getModelviewMatrix = function(){\n    if (this.dirty) this.update();\n    return this.modelview;\n};\n\nCamera.prototype.getModelviewFMatrix = function(){\n    if (this.dirty) this.update();\n    return this.modelview32;\n};\n\n\n// Returns a matrix that transforms the camera space to screen space.\nCamera.prototype.getProjectionMatrix = function() {\n    if (this.dirty) this.update();\n    return this.projection;\n};\n\nCamera.prototype.getProjectionFMatrix = function() {\n    if (this.dirty) this.update();\n    return this.projection32;\n};\n\n\n// Returns projectionMatrix() * modelviewMatrix()\nCamera.prototype.getMvpMatrix = function() {\n    if (this.dirty) this.update();\n    return this.mvp;\n};\n\nCamera.prototype.getMvpFMatrix = function() {\n    if (this.dirty) this.update();\n    return this.mvp32;\n};\n\n// Returns how much a length unit located at a point in world space is\n// stretched when projected to the sceen space.\nCamera.prototype.scaleFactor = function(worldPos, returnDist) {\n    if (this.dirty) this.update();\n\n    //var camPos = vec4.create();\n    //mat4.multiplyVec4(this.modelview, worldPos, camPos);\n    mat4.multiplyVec3(this.modelview, worldPos, this.scaleFactorVec);\n    var dist = vec3.length(this.scaleFactorVec); // distance from camera\n\n    // the expression \"projection(0,0) / depth\" is the derivative of the\n    // screen X position by the camera space X coordinate.\n\n    // ('dist' is used instead of camera depth (camPos(2)) to make the tile\n    // resolution independent of camera rotation)\n\n    if (returnDist) {\n        if (dist < this.near) return [Number.POSITIVE_INFINITY, dist];\n        return [this.projection[0] / dist, dist]; \n        //return [(this.projection[5]*0.5) / dist, dist]; //projection by sy\n    }\n\n    if (dist < this.near) return Number.POSITIVE_INFINITY;\n    return this.projection[0] / dist;\n    //return (this.projection[5]*0.5) / dist; //projection by sy\n};\n\n\nCamera.prototype.scaleFactor2 = function(dist) {\n    if (this.dirty) this.update();\n\n    if (dist < this.near) return Number.POSITIVE_INFINITY;\n    return this.projection[0] / dist;\n    //return (this.projection[5]*0.5) / dist; //projection by sy\n};\n\n\nCamera.prototype.distance = function(worldPos) {\n    var delta = vec3.create();\n    vec3.subtract(this.position, worldPos, delta);\n    return vec3.length(delta);\n};\n\n\n// Returns true if point is inside camera frustum.\nCamera.prototype.pointVisible = function(point, shift) {\n    if (this.dirty) this.update();\n\n    var p;\n\n    if (shift) {\n        p = [ point[0] - shift[0], point[1] - shift[1], point[2] - shift[2], 1 ];\n    } else {\n        p = [ point[0], point[1], point[2], 1 ];\n    }\n\n    // test all frustum planes quickly\n    for (var i = 0; i < 6; i++) {\n        // check if point lie on the negative side of the frustum plane\n        if (vec4.dot(this.frustumPlanes[i], p) < 0) {\n            return false;\n        }\n    }\n\n    // the box might be inside - further testing should be done here - TODO!\n    return true;\n};\n\n\n// Returns true if the box intersects the camera frustum.\nCamera.prototype.pointsVisible = function(points, shift) {\n    if (this.dirty) this.update();\n   \n    var planes = this.frustumPlanes;\n    var lj = points.length, sx, sy, sz;\n\n    if (shift) {\n        sx = shift[0];\n        sy = shift[1];\n        sz = shift[2];\n    } else {\n        sx = 0;\n        sy = 0;\n        sz = 0;\n    }\n        \n    var dot = vec4.dot3;\n\n    // test all frustum planes quickly\n    for (var i = 0; i < 6; i++) {\n        // check if all points lie on the negative side of the frustum plane\n        var negative = true;\n        var plane = planes[i];\n        for (var j = 0; j < lj; j+=3) {\n            if (dot(plane, points, j, sx, sy, sz) >= 0) {\n                //return false;\n                negative = false;\n                break;\n            }\n        }\n        if (negative) return false;\n    }\n\n    return true;\n};\n\n\n// Returns true if the box intersects the camera frustum.\nCamera.prototype.bboxVisible = function(bbox, shift) {\n    if (this.dirty) this.update();\n\n    var min = bbox.min;\n    var max = bbox.max;\n    var points = this.bboxPoints;\n    var p, minX, minY, minZ, maxX, maxY, maxZ;\n\n    if (shift) {\n        minX = min[0] - shift[0];        \n        minY = min[1] - shift[1];        \n        minZ = min[2] - shift[2];        \n       \n        maxX = max[0] - shift[0];        \n        maxY = max[1] - shift[1];        \n        maxZ = max[2] - shift[2];        \n    } else {\n        minX = min[0];        \n        minY = min[1];        \n        minZ = min[2];        \n\n        maxX = max[0];        \n        maxY = max[1];        \n        maxZ = max[2];        \n    }\n\n    p = points[0];\n    p[0] = minX;  p[1] = minY; p[2] = minZ; \n    p = points[1];\n    p[0] = minX;  p[1] = minY; p[2] = maxZ; \n    p = points[2];\n    p[0] = minX;  p[1] = maxY; p[2] = minZ; \n    p = points[3];\n    p[0] = minX;  p[1] = maxY; p[2] = maxZ; \n\n    p = points[4];\n    p[0] = maxX;  p[1] = minY; p[2] = minZ; \n    p = points[5];\n    p[0] = maxX;  p[1] = minY; p[2] = maxZ; \n    p = points[6];\n    p[0] = maxX;  p[1] = maxY; p[2] = minZ; \n    p = points[7];\n    p[0] = maxX;  p[1] = maxY; p[2] = maxZ; \n\n\n    var dot = vec4.dot2;\n    var planes = this.frustumPlanes;\n\n    // test all frustum planes quickly\n    for (var i = 0; i < 6; i++) {\n        // check if all points lie on the negative side of the frustum plane\n        var negative = true;\n        var plane = planes[i];\n        for (var j = 0; j < 8; j++) {\n            if (dot(plane, points[j]) >= 0) {\n                //return false;\n                negative = false;\n                break;\n            }\n        }\n        if (negative) return false;\n    }\n\n    // the box might be inside - further testing should be done here - TODO!\n    return true;\n};\n\n\nCamera.prototype.update = function(zoffset) {\n    // modelview matrix, this is essentially the inverse of a matrix that\n    // brings the camera from the origin to its world position (the inverse\n    // is trivial here -- negative angles, reverse order of transformations)\n    //this.modelview = mat4.create();\n\n    if (!this.rotationByMatrix) {\n        mat4.multiply(math.rotationMatrix(2, math.radians(-this.orientation[2])), math.rotationMatrix(0, math.radians(-this.orientation[1] - 90.0)), this.rotationview);\n        mat4.multiply(this.rotationview, math.rotationMatrix(2, math.radians(-this.orientation[0])), this.rotationview);\n    }\n\n    mat4.multiply(this.rotationview, math.translationMatrix(-this.position[0], -this.position[1], -this.position[2]), this.modelview);\n\n    if (this.ortho) {\n        this.projection = math.orthographicMatrix(this.viewHeight, this.aspect, this.near, this.far);\n    } else {\n        this.projection = math.perspectiveMatrix(this.fov, this.aspect, this.near, this.far);\n    }\n\n    mat4.multiply(this.projection, this.modelview, this.mvp);\n\n    // prepare frustum planes (in normalized device coordinates)\n    this.frustumPlanes[0] = [ 0, 0, 1, 1 ]; // far\n    this.frustumPlanes[1] = [ 0, 0,-1, 1 ]; // near\n    this.frustumPlanes[2] = [ 1, 0, 0, 1 ]; // left\n    this.frustumPlanes[3] = [-1, 0, 0, 1 ]; // right\n    this.frustumPlanes[4] = [ 0, 1, 0, 1 ]; // bottom\n    this.frustumPlanes[5] = [ 0,-1, 0, 1 ]; // top\n\n    // transform the frustum planes to the world space, remember that\n    // planes in homogeneous coordinates transform as p' = M^{-T} * p, where\n    // M^{-T} is the transpose of inverse of M\n    var mvpt = mat4.create();\n    mat4.transpose(this.mvp, mvpt); //without zoffset\n    for (var i = 0; i < 6; i++) {\n        this.frustumPlanes[i] = mat4.multiplyVec4(mvpt, this.frustumPlanes[i]);\n    }\n\n    this.mvp32.set(this.mvp);\n    this.projection32.set(this.projection);\n    this.modelview32.set(this.modelview);\n    this.rotationview32.set(this.rotationview);\n\n    this.fovDist = (this.parent.curSize[1] *0.5) / this.fovTan;\n\n    // the derived quantities are now in sync with the parameters\n    this.dirty = false;\n};\n\n\nexport default Camera;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/camera.js\n// module id = 156\n// module chunks = 0 1","\nimport {vec3 as vec3_, mat3 as mat3_, mat4 as mat4_} from '../utils/matrix';\nimport {math as math_} from '../utils/math';\nimport {processGMap as processGMap_, processGMap4 as processGMap4_, processGMap5 as processGMap5_ } from './gmap';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat3 = mat3_, mat4 = mat4_;\nvar math = math_;\nvar processGMap = processGMap_;\nvar processGMap4 = processGMap4_;\nvar processGMap5 = processGMap5_;\n\n\nvar RendererDraw = function(renderer) {\n    this.renderer = renderer;\n    this.core = renderer.core;\n    this.gpu = renderer.gpu;\n    this.gl = renderer.gpu.gl;\n    this.rmap = renderer.rmap;\n};\n\n\nRendererDraw.prototype.drawSkydome = function(texture, shader) {\n    if (!texture) {\n        return;\n    }\n\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n    \n    var lower = 400; // put the dome a bit lower\n    var normMat = mat4.create();\n    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);\n\n    var domeMat = mat4.create();\n\n    var pos = renderer.camera.getPosition();\n    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2] - lower), math.scaleMatrixf(Math.min(renderer.camera.getFar()*0.9,600000)), domeMat);\n\n    var mvp = mat4.create();\n    mat4.multiply(renderer.camera.getMvpMatrix(), domeMat, mvp);\n    mat4.multiply(mvp, normMat, mvp);\n\n\n    gpu.useProgram(shader, ['aPosition', 'aTexCoord']);\n    gpu.bindTexture(texture);\n\n    shader.setSampler('uSampler', 0);\n    shader.setMat4('uMVP', mvp);\n\n    gl.depthMask(false);\n\n    renderer.skydomeMesh.draw(shader, 'aPosition', 'aTexCoord');\n\n    gl.depthMask(true);\n    gl.enable(gl.CULL_FACE);\n\n    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();\n};\n\n\nRendererDraw.prototype.drawTBall = function(position, size, shader, texture, size2, nocull) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (nocull) {\n        //gl.disable(gl.CULL_FACE);\n    }\n\n    var normMat = mat4.create();\n    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);\n\n    var pos = [position[0], position[1], position[2] ];\n\n    size = (size != null) ? size : 1.5;\n\n    var domeMat = mat4.create();\n    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrix(size, size, size2 || size), domeMat);\n\n    var mvp = mat4.create();\n    mat4.multiply(renderer.camera.getMvpMatrix(), domeMat, mvp);\n    mat4.multiply(mvp, normMat, mvp);\n\n    gpu.useProgram(shader, ['aPosition', 'aTexCoord']);\n    gpu.bindTexture(texture || renderer.redTexture);\n\n    shader.setSampler('uSampler', 0);\n    shader.setMat4('uMVP', mvp);\n\n    renderer.skydomeMesh.draw(shader, 'aPosition', 'aTexCoord');\n\n    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();\n\n    if (nocull) {\n        //gl.enable(gl.CULL_FACE);\n    }\n};\n\n\nRendererDraw.prototype.drawBall = function(position, size, size2, shader, params, params2, params3, color, color2, normals) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    var normMat = mat4.create();\n    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);\n\n    var pos = [position[0], position[1], position[2] ];\n\n    var domeMat = mat4.create();\n    size = size || 1.5;\n    size2 = size2 || 1.5;\n    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrix(size, size, size2), domeMat);\n\n    var mv = mat4.create();\n    mat4.multiply(renderer.camera.getModelviewMatrix(), domeMat, mv);\n    mat4.multiply(mv, normMat, mv);\n    var proj = renderer.camera.getProjectionMatrix();\n\n    var norm = [0,0,0, 0,0,0, 0,0,0];\n    mat4.toInverseMat3(mv, norm);\n    mat3.transpose(norm);\n    \n    gpu.useProgram(shader, ['aPosition']);\n    //gpu.bindTexture(renderer.redTexture);\n\n    //shader.setSampler('uSampler', 0);\n    shader.setMat4('uProj', proj);\n    shader.setMat4('uMV', mv);\n    \n    if (normals) {\n        shader.setMat3('uNorm', norm);\n        gl.cullFace(gl.FRONT);\n        //gl.disable(gl.DEPTH_TEST);\n    }\n    \n    if (params) {\n        shader.setVec4('uParams', params);\n    }\n\n    if (params2) {\n        shader.setVec4('uParams2', params2);\n    }\n\n    if (params2) {\n        shader.setVec4('uParams3', params3);\n    }\n\n    if (color) {\n        shader.setVec4('uFogColor', color);\n    }\n\n    if (color2) {\n        shader.setVec4('uFogColor2', color2);\n    }\n\n    renderer.atmoMesh.draw(shader, 'aPosition', null /*\"aTexCoord\"*/);\n\n    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();\n\n    if (normals) {\n        gl.cullFace(gl.BACK);\n    }\n};\n\n\nRendererDraw.prototype.drawBall2 = function(position, size, shader, nfactor, dir, radius2) {\n    var gpu = this.gpu;\n    var renderer = this.renderer;\n\n    var normMat = mat4.create();\n    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);\n\n    var pos = [position[0], position[1], position[2] ];\n\n    var domeMat = mat4.create();\n    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrixf(size != null ? size : 1.5), domeMat);\n\n    var mv = mat4.create();\n    mat4.multiply(renderer.camera.getModelviewMatrix(), domeMat, mv);\n    mat4.multiply(mv, normMat, mv);\n    var proj = renderer.camera.getProjectionMatrix();\n\n    var norm = [0,0,0, 0,0,0, 0,0,0];\n    mat4.toInverseMat3(mv, norm);\n    mat3.transpose(norm);\n    \n    gpu.useProgram(shader, ['aPosition']);\n    gpu.bindTexture(renderer.redTexture);\n\n    shader.setSampler('uSampler', 0);\n    shader.setMat4('uProj', proj);\n    shader.setMat4('uMV', mv);\n    shader.setMat3('uNorm', norm);\n    shader.setFloat('uNFactor', nfactor);\n    shader.setVec3('uCenter', position);\n    shader.setVec2('uRadius', [size, radius2]);\n\n    renderer.atmoMesh.draw(shader, 'aPosition', null /*\"aTexCoord\"*/);\n    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();\n};\n\n\nRendererDraw.prototype.drawLineString = function(points, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n    var index = 0, p, i;\n\n    var totalPoints = points.length; \n   \n    if (totalPoints > 32) {\n        for (i = 0; i < totalPoints; i += 31) {\n            p = points.slice(i, i + 32); \n            this.drawLineString(p, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState);\n        }\n        return;\n    }\n\n    var plineBuffer = renderer.plineBuffer;\n\n\n    if (screenSpace) { \n\n        //fill points\n        for (i = 0; i < totalPoints; i++) {\n            p = points[i];\n            plineBuffer[index] = p[0];\n            plineBuffer[index+1] = p[1];\n            plineBuffer[index+2] = p[2] || 0;\n            index += 3;\n        }\n\n    } else { //covert points from physical space\n\n        var mvp = renderer.camera.getMvpMatrix();\n        var curSize = renderer.curSize;\n        var cameraPos = renderer.cameraPosition;\n\n        for (i = 0; i < totalPoints; i++) {\n            p = points[i];\n            p = mat4.multiplyVec4(mvp, [p[0] - cameraPos[0], p[1] - cameraPos[1], p[2] - cameraPos[2], 1 ]); \n\n            //project point coords to screen\n            if (p[3] != 0) {\n                //x and y are in screen pixels\n                plineBuffer[index] = ((p[0]/p[3])+1.0)*0.5*curSize[0];\n                plineBuffer[index+1] = (-(p[1]/p[3])+1.0)*0.5*curSize[1]; \n                plineBuffer[index+2] = p[2]/p[3]; //depth in meters\n            } else {\n                plineBuffer[index] = 0;\n                plineBuffer[index+1] = 0;\n                plineBuffer[index+2] = 0;\n            }\n\n            index += 3;\n        }\n    }\n\n    if (useState !== true) {\n        var tmpState = gpu.currentState;\n\n        gpu.setState({\n            ztest: !(depthTest !== true),\n            blend: (transparent === true),\n            zwrite: !(writeDepth === false),\n            stencil: false,\n            culling: false,\n            zequal: false\n        });\n\n        /*\n        if (depthTest !== true) {\n            gl.disable(gl.DEPTH_TEST);\n        }\n    \n        if (transparent) {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        }\n    \n        if (writeDepth === false) {\n            gl.depthMask(false); \n        }\n    \n        gl.disable(gl.STENCIL_TEST);\n        gl.disable(gl.CULL_FACE);\n        */\n    }\n\n    var prog = renderer.progLine4;   \n\n    gpu.useProgram(prog, ['aPosition']);\n    prog.setMat4('uMVP', renderer.imageProjectionMatrix, depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);\n    prog.setVec3('uScale', [(2 / renderer.curSize[0]), (2 / renderer.curSize[1]), size*0.5]);\n    prog.setVec4('uColor', (color != null ? color : [255,255,255,255]));\n    prog.setVec3('uPoints', plineBuffer);\n\n    renderer.plines.draw(prog, 'aPosition', totalPoints);\n\n    if (useState !== true) {\n        gpu.setState(tmpState);\n        /*        \n        if (depthTest !== true) {\n            gl.enable(gl.DEPTH_TEST);\n        }\n    \n        if (transparent) {\n            gl.disable(gl.BLEND);\n        }\n    \n        if (writeDepth === false) {\n            gl.depthMask(true); \n        }\n    \n        gl.enable(gl.CULL_FACE);*/\n    }\n};\n\n\n//draw 2d image - used for debuging\nRendererDraw.prototype.drawImage = function(x, y, lx, ly, texture, color, depth, depthOffset, depthTest, transparent, writeDepth, useState) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (texture == null || renderer.imageProjectionMatrix == null) {\n        return;\n    }\n\n    if (useState !== true) {\n        var tmpState = gpu.currentState;\n\n        gpu.setState({\n            ztest: !(depthTest !== true),\n            blend: (transparent === true),\n            zwrite: !(writeDepth === false),\n            stencil: false,\n            culling: false,\n            zequal: false\n        });\n\n        /*\n        if (depthTest !== true) {\n            gl.disable(gl.DEPTH_TEST);\n        }\n    \n        if (transparent) {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        }\n    \n        if (writeDepth === false) {\n            gl.depthMask(false); \n        }\n    \n        gl.disable(gl.CULL_FACE);*/\n    }\n\n    var prog = renderer.progImage;\n\n    gpu.useProgram(prog, ['aPosition']);\n    gpu.bindTexture(texture);\n\n    var vertices = renderer.rectVerticesBuffer;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n    var indices = renderer.rectIndicesBuffer;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n\n    prog.setMat4('uData', [\n        x, y,  0, 0,\n        x + lx, y,  1, 0,\n        x + lx, y + ly, 1, 1,\n        x,  y + ly,  0, 1  ]);\n\n    if (depthOffset) {\n        depth = depth * (1 + renderer.getZoffsetFactor(depthOffset) * 2);\n    }\n\n    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));\n    prog.setFloat('uDepth', depth);\n\n    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n    if (useState !== true) {\n        gpu.setState(tmpState);\n\n        /*\n        if (writeDepth === false) {\n            gl.depthMask(true); \n        }\n    \n        if (depthTest !== true) {\n            gl.enable(gl.DEPTH_TEST);\n        }\n    \n        if (transparent) {\n            gl.disable(gl.BLEND);\n        }\n    \n        gl.enable(gl.CULL_FACE);*/\n    }\n};\n\n\nRendererDraw.prototype.drawBillboard = function(mvp, texture, color, depthOffset, depthTest, transparent, writeDepth, useState) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (useState !== true) {\n        var tmpState = gpu.currentState;\n\n        gpu.setState({\n            ztest: !(depthTest !== true),\n            blend: (transparent === true),\n            zwrite: !(writeDepth === false),\n            stencil: false,\n            culling: false,\n            zequal: false\n        });\n\n        /*        \n        if (depthTest !== true) {\n            gl.disable(gl.DEPTH_TEST);\n        }\n    \n        if (transparent) {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        }\n    \n        if (writeDepth === false) {\n            gl.depthMask(false); \n        }\n    \n        gl.disable(gl.CULL_FACE);*/\n    }\n\n    var prog = renderer.progImage;\n\n    gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n    gpu.bindTexture(texture);\n    prog.setSampler('uSampler', 0);\n\n    var vertices = renderer.rectVerticesBuffer;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n    var indices = renderer.rectIndicesBuffer;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n    prog.setMat4('uProjectionMatrix', mvp, depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);\n\n    var x = 0, y = 0, lx = 1, ly = 1;\n\n    prog.setMat4('uData', [\n        x, y,  0, 0,\n        x + lx, y,  1, 0,\n        x + lx, y + ly, 1, 1,\n        x,  y + ly,  0, 1  ]);\n\n    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));\n    prog.setFloat('uDepth', 0);\n\n    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n    if (useState !== true) {\n        gpu.setState(tmpState);\n\n        /*\n        if (writeDepth === false) {\n            gl.depthMask(true); \n        }\n    \n        if (depthTest !== true) {\n            gl.enable(gl.DEPTH_TEST);\n        }\n    \n        if (transparent) {\n            gl.disable(gl.BLEND);\n        }\n    \n        gl.enable(gl.CULL_FACE);*/\n    }\n};\n\n\n//draw flat 2d image - used for debuging\nRendererDraw.prototype.drawFlatImage = function(x, y, lx, ly, texture, color, depth, depthOffset) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (texture == null || renderer.imageProjectionMatrix == null) {\n        return;\n    }\n\n    var prog = renderer.progImage;\n\n    gpu.useProgram(prog, ['aPosition']);\n    gpu.bindTexture(texture);\n\n    var vertices = renderer.rectVerticesBuffer;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n    var indices = renderer.rectIndicesBuffer;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n\n    prog.setMat4('uData', [\n        x, y,  0, 0,\n        x + lx, y,  1, 0,\n        x + lx, y + ly, 1, 1,\n        x,  y + ly,  0, 1  ]);\n\n    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));\n    prog.setFloat('uDepth', depth != null ? depth : 0);\n\n    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n};\n\n\n//draw 2d text - used for debuging\nRendererDraw.prototype.drawText = function(x, y, size, text, color, depth, useState) {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (renderer.imageProjectionMatrix == null) {\n        return;\n    }\n\n    if (useState !== true) {\n        var tmpState = gpu.currentState;\n\n        gpu.setState({\n          ztest: !(depth == null),\n          blend: false,\n          zwrite: !(depth == null),\n          stencil: false,\n          culling: false,\n          zequal: !(depth == null)\n        });\n\n        /*\n        gl.disable(gl.CULL_FACE);\n    \n    \n        if (depth == null) {\n            gl.disable(gl.DEPTH_TEST);\n        } else {\n            gl.depthFunc(gl.LEQUAL);\n            gl.enable(gl.DEPTH_TEST);\n        }*/\n    }\n\n    var prog = renderer.progImage;\n\n    gpu.useProgram(prog, ['aPosition']);\n    gpu.bindTexture(renderer.textTexture2);\n\n    var vertices = renderer.rectVerticesBuffer;\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n    var indices = renderer.rectIndicesBuffer;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n    prog.setVec4('uColor', color);\n    prog.setFloat('uDepth', depth != null ? depth : 0);\n\n    var sizeX = size - 1;\n    var sizeY = size;\n\n    var sizeX2 = Math.round(size*0.5);\n\n    var texelX = 1 / 256;\n    var texelY = 1 / 128;\n\n    var lx = this.getTextSize(size, text) + 2;\n\n    //draw black line before text\n    var char = 0;\n    var charPosX = (char & 15) << 4;\n    var charPosY = (char >> 4) << 4;\n\n    prog.setMat4('uData', [\n        x-2, y-2,  (charPosX * texelX), (charPosY * texelY),\n        x-2 + lx, y-2,  ((charPosX+15) * texelX), (charPosY * texelY),\n        x-2 + lx, y + sizeY+1, ((charPosX + 15) * texelX), ((charPosY+15) * texelY),\n        x-2,  y + sizeY+1,  (charPosX * texelX), ((charPosY+15) * texelY) ]);\n\n    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n    \n\n    for (var i = 0, li = text.length; i < li; i++) {\n        char = text.charCodeAt(i) - 32;\n        charPosX = (char & 15) << 4;\n        charPosY = (char >> 4) << 4;\n\n        switch(char) {\n        case 12:\n        case 14:\n        case 27: //:\n        case 28: //;\n        case 64: //'\n        case 73: //i\n        case 76: //l\n        case 84: //t\n\n            prog.setMat4('uData', [\n                x, y,  (charPosX * texelX), (charPosY * texelY),\n                x + sizeX2, y,  ((charPosX+8) * texelX), (charPosY * texelY),\n                x + sizeX2, y + sizeY, ((charPosX + 8) * texelX), ((charPosY+16) * texelY),\n                x,  y + sizeY,  (charPosX * texelX), ((charPosY+16) * texelY) ]);\n\n            x += sizeX2;\n            break;\n\n        default:\n\n            prog.setMat4('uData', [\n                x, y,  (charPosX * texelX), (charPosY * texelY),\n                x + sizeX, y,  ((charPosX+15) * texelX), (charPosY * texelY),\n                x + sizeX, y + sizeY, ((charPosX + 15) * texelX), ((charPosY+16) * texelY),\n                x,  y + sizeY,  (charPosX * texelX), ((charPosY+16) * texelY) ]);\n\n            x += sizeX;\n                \n            break;\n        }\n\n        gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n    }\n\n    if (useState !== true) {\n        gpu.setState(tmpState);\n\n        /*\n        gl.enable(gl.CULL_FACE);\n    \n        if (depth == null) {\n            gl.enable(gl.DEPTH_TEST);\n        }*/\n    }\n};\n\n\nRendererDraw.prototype.getTextSize = function(size, text) {\n    var sizeX = size - 1;\n    var sizeX2 = Math.round(size*0.5);\n    var x = 0;\n\n    for (var i = 0, li = text.length; i < li; i++) {\n        var char = text.charCodeAt(i) - 32;\n\n        switch(char) {\n        case 12:\n        case 14:\n        case 27: //:\n        case 28: //;7\n        case 64: //'\n        case 73: //i\n        case 76: //l\n        case 84: //t\n            x += sizeX2;\n            break;\n\n        default:\n            x += sizeX;\n            break;\n        }\n    }\n    \n    return x;\n};\n\n\nRendererDraw.prototype.drawGpuJobs = function() {\n    var gpu = this.gpu;\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    renderer.geoRenderCounter++;\n    renderer.totalJobs = 0;\n    renderer.drawnJobs = 0;\n    renderer.jobsTimer4 = 0;\n    renderer.jobsTimer3 = 0;\n    renderer.jobsTimer2 = 0;\n    renderer.jobsTimer1 = performance.now();\n\n    //setup stencil\n    gl.stencilMask(0xFF);\n    gl.clear(gl.STENCIL_BUFFER_BIT);\n    gl.stencilFunc(gl.EQUAL, 0, 0xFF);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n\n    var screenPixelSize = [1.0/renderer.curSize[0], 1.0/renderer.curSize[1]];\n    var rmap = this.rmap;\n    var clearPass = 513;\n    var clearPassIndex = 0;\n    var clearStencilPasses = renderer.clearStencilPasses;\n    var jobZBuffer = renderer.jobZBuffer;\n    var jobZBufferSize = renderer.jobZBufferSize;\n    var jobZBuffer2 = renderer.jobZBuffer2;\n    var jobZBuffer2Size = renderer.jobZBuffer2Size;\n    var onlyHitLayers = renderer.onlyHitLayers;\n    var onlyAdvancedHitLayers = renderer.onlyAdvancedHitLayers;\n    var geoRenderCounter = renderer.geoRenderCounter;\n    var job, key, hitmapRender = renderer.onlyHitLayers;\n\n    if (clearStencilPasses.length > 0) {\n        clearPass = clearStencilPasses[0];\n        clearPassIndex++;\n    }\n\n    if (this.rmap.counter != this.renderer.geoRenderCounter) {\n        this.rmap.clear();\n    }\n\n    renderer.gmapIndex = 0;\n    renderer.gmapUseVersion = 1;\n\n    var forceUpdate = false;\n\n    var ret, frameTime = renderer.frameTime, sortHbuffer = false;\n\n    //console.log(\"\" + frameTime);\n\n    //draw job buffer and also clean buffer\n    for (var i = 0, li = jobZBuffer.length; i < li; i++) {\n        var j, lj = jobZBufferSize[i], lj2 = jobZBuffer2Size[i];\n        var buffer = jobZBuffer[i];\n        var buffer2 = jobZBuffer2[i];\n        renderer.jobHBuffer = {};\n\n        renderer.totalJobs += lj;\n\n        if (lj > 0 && i >= clearPass) {\n            gl.clear(gl.STENCIL_BUFFER_BIT);\n\n            if (clearStencilPasses.length > clearPassIndex) {\n                clearPass = clearStencilPasses[clearPassIndex];\n                clearPassIndex++;\n            } else {\n                clearPass = 513;\n            }\n        }\n\n        if (onlyHitLayers) {\n            if (onlyAdvancedHitLayers) {\n                for (j = 0; j < lj; j++) {\n                    if (buffer[j].advancedHit) {\n                        this.drawGpuJob(gpu, gl, renderer, buffer[j], screenPixelSize, true);\n                    }\n                }\n            } else {\n                for (j = 0; j < lj; j++) {\n                    var job = buffer[j];\n                    if (job.hitable) {\n                        this.drawGpuJob(gpu, gl, renderer, job, screenPixelSize);\n                        if (job.advancedHit) {\n                            renderer.advancedPassNeeded = true;\n                        }\n                    }\n                }\n            }\n        } else {\n\n            for (j = 0; j < lj; j++) {\n \n                job = buffer[j];\n                this.drawGpuJob(gpu, gl, renderer, job, screenPixelSize);\n            }\n        }\n    \n        renderer.jobsTimer3 = performance.now();\n\n        if (renderer.gmapIndex > 0) {\n            switch(renderer.gmapUseVersion) {\n                case 1: //scr-count4\n                    processGMap(gpu, gl, renderer, screenPixelSize, this);\n                    break;\n                case 2:  //scr-count5\n                    processGMap4(gpu, gl, renderer, screenPixelSize, this);\n                    break;\n                case 3: //scr-count6\n                    processGMap5(gpu, gl, renderer, screenPixelSize, this);\n                    break;\n            }\n            renderer.gmapIndex = 0;\n        }\n\n        if (rmap.rectanglesCount > 0) {\n            rmap.processRectangles(gpu, gl, renderer, screenPixelSize);\n        }\n\n        renderer.jobsTimer4 += performance.now() - renderer.jobsTimer3;\n\n        //lj2 = jobZBuffer2Size[i]; //probably no op\n\n        lj2 = false;\n        var hbuffer = renderer.jobHBuffer;\n\n        for (key in hbuffer) {\n            lj2 = true;\n            break;\n        }\n\n        if (lj2) {\n\n            if (!hitmapRender) {\n\n                for (key in hbuffer) {\n                    job = hbuffer[key];\n\n                     if (job.hysteresis && job.id) {\n                        var job2 = buffer2[job.id];\n\n                        if (!job2) {\n                            job.timerShow = 0;\n                            job.timerHide = 0;\n                            job.draw = false;\n                            job.hysteresisCounter = renderer.geoRenderCounter;\n                            buffer2[job.id] = job;\n                            jobZBuffer2Size[i]++;\n                            forceUpdate = true;\n                        } else {\n\n                            if (job == job2) {\n                                job2.hysteresisCounter = renderer.geoRenderCounter;\n                            } else {\n                                job2.hysteresisBackup = job;\n                            }\n\n                        }\n\n                        //if (job.hysteresis[3] === true) {\n                            sortHbuffer = true;\n                        //}\n                    }\n                }\n            }\n\n            for (key in buffer2) {\n                job = buffer2[key];\n                job2 = hbuffer[key];\n\n                renderer.drawnJobs++;\n\n                if (!hitmapRender) {\n                    if (job2) {\n                        if (isNaN(job.timerShow)) {\n                            job.timerShow = 0;\n                            job.timerHide = 0;\n                            job.draw = false;\n                        }\n\n                        if (!job.draw) {\n                            job.timerShow += frameTime;\n\n                            if (job.timerShow > (job.hysteresis[0])) {\n                                job.draw = true;\n                                job.timerShow = 0;\n                            } else {\n                                forceUpdate = true;\n                            }\n                        } else if (job.timerHide) {\n                            job.draw = false;\n                            job.timerShow = (job.hysteresis[0]) * (1.0-(job.timerHide / (job.hysteresis[1])));\n                        }\n\n                        job.timerHide = 0;\n\n                    } else {\n                        //job = buffer2[key];\n\n                        if (job.draw) {\n                            job.timerHide += frameTime;\n\n                            if (job.timerHide > (job.hysteresis[1])) {\n                                delete buffer2[key];\n                                jobZBuffer2Size[i]--;\n                                job.draw = false;\n                                job.timerHide = 0;\n                            } else {\n                                forceUpdate = true;\n                            }\n                        } else if (job.timerShow) {\n                            job.draw = true;\n                            job.timerHide = (job.hysteresis[1]) * (1.0-(job.timerShow / (job.hysteresis[0])));\n                        }\n\n                        job.timerShow = 0;\n                    }\n                }\n\n                var draw = job.draw, fade = null;\n\n                if (!hitmapRender && job.hysteresis[3] === true) {\n \n                    if (draw) {\n                        if (job.timerHide != 0) {\n                            fade = job.timerHide / (job.hysteresis[1]+1);\n                            fade = 1.0 - Math.min(1.0, fade);\n\n                            //for debug only\n                            /*\n                            var pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n\n                            if (pp[1] > 1000) {  \n                                pp = pp;\n                            }*/\n\n                        }\n                    } else {\n                        if (job.timerShow != 0) {\n                            fade = job.timerShow / (job.hysteresis[0]+1);\n                            fade = Math.min(1.0, fade);\n                            draw = true;\n                        }\n                    }\n                }\n\n\n                if (draw) {\n\n                    if (job.hysteresisCounter != renderer.geoRenderCounter && job.hysteresisBackup) {\n                        var job3 = job.hysteresisBackup;\n                        buffer2[key] = job3;\n\n                        job3.timerShow = job.timerShow;\n                        job3.timerHide = job.timerHide;\n                        job3.draw = job.draw;\n\n                        job = job3;\n                    }\n\n                    // update job matricies\n                    if (job.renderCounter[0][0] !== geoRenderCounter && job.renderCounter[0][0] !== null) { \n                        job.updatePos = true;\n\n                        var renderCounter = job.renderCounter[0];\n\n                        var mvp = mat4.create();\n                        var mv = mat4.create();\n                        var group = renderCounter[3];\n                        var bbox = group.bbox;\n                        var geoPos = renderer.cameraPosition;\n                    \n                        var m = math.translationMatrix(bbox.min[0] - geoPos[0], bbox.min[1] - geoPos[1], bbox.min[2] - geoPos[2]);\n                        mat4.multiply(renderer.camera.getModelviewMatrix(), m, mv);\n\n                        var proj = renderer.camera.getProjectionMatrix();\n                        mat4.multiply(proj, mv, mvp);\n\n                        job.mv = mv;\n                        job.mvp = mvp;\n                    }                    \n\n                    if (job.type == VTS_JOB_VSPOINT) {\n                        var viewExtent = renderer.viewExtent;\n                        var slayers = job.vswitch[job.vswitchIndex];\n\n                        if (slayers) {\n                            slayers = slayers[1];\n\n                            for (var k = 0, lk = slayers.length; k < lk; k++) {\n                                var sjob = slayers[k];\n                                sjob.updatePos = job.updatePos;\n                                sjob.mvp = job.mvp;\n                                sjob.mv = job.mv;\n                                this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, sjob.lastSubJob, fade);\n                            }\n                        }\n\n                    } else {\n                        this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, fade);\n                    }\n\n                    job.updatePos = false;\n                }\n\n                job.hysteresisBackup = null;\n            }\n        }\n    }\n\n    if (forceUpdate) {\n        this.core.markDirty();\n    }\n\n    renderer.jobsTimer2 = performance.now();\n};\n\n\nRendererDraw.prototype.clearJobBuffer = function() {\n    var renderer = this.renderer;\n    var jobZBuffer = renderer.jobZBuffer;\n    var jobZBufferSize = renderer.jobZBufferSize;\n\n    //clean job buffer\n    for (var i = 0, li = jobZBuffer.length; i < li; i++) {\n        var lj = jobZBufferSize[i];\n        var buffer = jobZBuffer[i];\n\n        for (var j = 0; j < lj; j++) {\n            buffer[j] = null;\n        }\n\n        jobZBufferSize[i] = 0;\n    }\n};\n\n\nRendererDraw.prototype.clearJobHBuffer = function() {\n    var renderer = this.renderer;\n    var jobZBuffer2 = renderer.jobZBuffer2;\n    var jobZBuffer2Size = renderer.jobZBuffer2Size;\n\n    //clean job hbuffer\n    for (var i = 0, li = jobZBuffer2.length; i < li; i++) {\n        jobZBuffer2[i] = {};\n        jobZBuffer2Size[i] = 0;\n    }\n};\n\n\nRendererDraw.prototype.paintGL = function() {   //remove this??\n    var renderer = this.renderer;\n\n    this.gpu.clear(true, false);\n\n    if (!renderer.onlyLayers) {\n        if (!renderer.onlyDepth && !renderer.onlyHitLayers) {\n            this.drawSkydome();\n        }\n    }\n};\n\n\nRendererDraw.prototype.drawGpuJob = function(gpu, gl, renderer, job, screenPixelSize, advancedHitPass, ignoreFilters) {\n    if (!job.ready) {\n        return;\n    }\n\n    //if (!(job.tile.id[0] == 14 && job.tile.id[1] == 4383 && job.tile.id[2] == 2863)) {\n      //  return;\n    //}\n\n    if (!job.eventInfo) {\n        return;\n    }\n\n    var state = job.state & 0xff;\n    var id = job.eventInfo['#id'];\n\n    if (id != null) {\n\n        if (job.state & (2 << 8)) { //has selection layers?\n\n            if (renderer.geodataSelection.indexOf(id) != -1) {  // is selected\n\n                if (job.state & (3 << 8)) { //has hover layers?\n\n                    if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {\n                        if (state != 3) {\n                            return;\n                        }\n                    } else {\n                        if (state != 2) {\n                            return;\n                        }\n                    }\n                }\n            } else if (job.state & (1 << 8)) { //has hover layers?\n\n                if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {\n                    if (state != 1) {\n                        return;\n                    }\n                } else {\n                    if (state != 0) {\n                        return;\n                    }\n                }\n\n            } else {\n                if (state != 0) {\n                    return;\n                }        \n            }\n        \n        } else if (job.state & (1 << 8)) { //has hover layers?\n\n            if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {\n                if (state != 1) {\n                    return;\n                }\n            } else {\n                if (state != 0) {\n                    return;\n                }\n            }\n\n        } else {\n            if (state != 0) {\n                return;;\n            }        \n        }\n\n    } else {\n        if (state != 0) {\n            return;\n        }        \n    }\n\n    var mvp = job.mvp, prog, texture;\n    var vertexPositionAttribute, vertexTexcoordAttribute,\n        vertexNormalAttribute, vertexOriginAttribute, vertexElementAttribute;\n\n    var hitmapRender = job.hitable && renderer.onlyHitLayers;\n    var screenPixelSize2, color = job.color;\n\n    if (hitmapRender) {\n        var c = renderer.hoverFeatureCounter;\n        //color = [(c&255)/255, ((c>>8)&255)/255, ((c>>16)&255)/255, 1];\n        color = [(c&255)/255, ((c>>8)&255)/255, 0, 0];\n        renderer.hoverFeatureList[c] = [job.eventInfo, job.center, job.clickEvent, job.hoverEvent, job.enterEvent, job.leaveEvent, advancedHitPass];\n        renderer.hoverFeatureCounter++;\n    }\n\n    switch(job.type) {\n    case VTS_JOB_FLAT_LINE:\n        gpu.setState(hitmapRender ? renderer.stencilLineHitState : renderer.stencilLineState);\n\n        var debugWires = (gpu === 0); //just generate false value to avoid compiler warnings;\n\n        prog = advancedHitPass ? job.program2 : debugWires ? renderer.progLineWireframe : job.program;\n        gpu.useProgram(prog, advancedHitPass ? ['aPosition', 'aElement'] : debugWires ? ['aPosition', 'aBarycentric'] : ['aPosition']);\n\n        prog.setVec4('uColor', color);\n        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n\n        vertexPositionAttribute = prog.getAttribute('aPosition');\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        if (advancedHitPass) {\n            vertexElementAttribute = prog.getAttribute('aElement');\n            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);\n            gl.vertexAttribPointer(vertexElementAttribute, job.vertexElementBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n\n        if (debugWires) {\n            var barycentericAttribute = prog.getAttribute('aBarycentric');\n            gl.bindBuffer(gl.ARRAY_BUFFER, gpu.barycentricBuffer);\n            gl.vertexAttribPointer(barycentericAttribute, gpu.barycentricBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n        \n        //draw polygons\n        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n\n        break;\n\n    case VTS_JOB_FLAT_RLINE:\n    case VTS_JOB_FLAT_TLINE:\n    case VTS_JOB_PIXEL_LINE:\n    case VTS_JOB_PIXEL_TLINE:\n        gpu.setState(hitmapRender ? renderer.stencilLineHitState : renderer.stencilLineState);\n            \n        prog = advancedHitPass ? job.program2 : job.program;\n        texture = null;\n        var textureParams = [0,0,0,0];\n        screenPixelSize2 = screenPixelSize;\n\n        if (hitmapRender) {\n            if (job.type == VTS_JOB_PIXEL_TLINE) {\n                if (job.widthByRatio) {\n                    screenPixelSize2 = [ screenPixelSize[0] * renderer.curSize[1], screenPixelSize[1] * renderer.curSize[1]];\n                }\n                prog = advancedHitPass ? this.renderer.progELine3 : this.renderer.progLine3;\n                if (!prog.isReady()) {\n                    return;\n                }\n            }\n        }\n\n        if (job.type != VTS_JOB_PIXEL_LINE) {\n\n            if (job.type == VTS_JOB_FLAT_RLINE) {\n                textureParams = [0, 0, 0, job.widthByRatio ? renderer.cameraViewExtent : 1];\n            } else {\n                if (hitmapRender) {\n                    texture = renderer.whiteTexture;\n\n                    if (job.type == VTS_JOB_FLAT_TLINE || job.type == VTS_JOB_FLAT_RLINE) {\n                        textureParams = [0, 0, 0, job.widthByRatio ? renderer.cameraViewExtent : 1];\n                    }\n\n                } else {\n                    var t = job.texture;\n                    if (t == null || t[0] == null) {\n                        return;\n                    }\n\n                    texture = t[0];\n                    textureParams = [0, t[1]/t[0].height, (t[1]+t[2])/t[0].height, job.widthByRatio ? renderer.cameraViewExtent : 1];\n\n                    if (job.type == VTS_JOB_FLAT_TLINE || job.type == VTS_JOB_FLAT_RLINE) {\n                        if (job.widthByRatio) {\n                            textureParams[0] = 1/(renderer.cameraViewExtent2*job.lineWidth)/(texture.width/t[2]);\n                        } else {\n                            textureParams[0] = 1/job.lineWidth/(texture.width/t[2]);    \n                        }\n                    } else {\n                        if (job.widthByRatio) {\n                            textureParams[0] = 1/(renderer.cameraViewExtent2/renderer.curSize[1])/(texture.width/t[2]);\n                            textureParams[0] /= (renderer.curSize[1]*job.lineWidth*0.5);\n                            //textureParams[3] = renderer.curSize[1]*(1.0/job.lineWidth)*0.5;\n                            textureParams[3] = renderer.curSize[1];\n                        } else {\n                            textureParams[0] = 1/(renderer.cameraViewExtent2/renderer.curSize[1])/(texture.width/t[2]);\n                            textureParams[0] /= (job.lineWidth*0.5);\n                            textureParams[3] = 1;\n                        }    \n                    }\n                }\n\n                if (!texture.loaded) {\n                    return;\n                }\n\n                gpu.bindTexture(texture);\n            }\n\n        } else if (job.widthByRatio) {\n            screenPixelSize2 = [ screenPixelSize[0] * renderer.curSize[1], screenPixelSize[1] * renderer.curSize[1]];\n        }\n\n        gpu.useProgram(prog, advancedHitPass ? ['aPosition','aNormal','aElement'] : ['aPosition','aNormal']);\n\n        prog.setVec4('uColor', color);\n        prog.setVec2('uScale', screenPixelSize2);\n        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n\n        if (job.type != VTS_JOB_PIXEL_LINE) {\n            if (job.background != null) {\n                prog.setVec4('uColor2', hitmapRender ? [0,0,0,0] : job.background);\n            }\n            prog.setVec4('uParams', textureParams);\n            prog.setSampler('uSampler', 0);\n        }\n\n        vertexPositionAttribute = prog.getAttribute('aPosition');\n        vertexNormalAttribute = prog.getAttribute('aNormal');\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind vetex normals\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);\n        gl.vertexAttribPointer(vertexNormalAttribute, job.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        if (advancedHitPass) {\n            vertexElementAttribute = prog.getAttribute('aElement');\n            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);\n            gl.vertexAttribPointer(vertexElementAttribute, job.vertexElementBuffer.itemSize, gl.FLOAT, false, 0, 0);\n        }\n\n        //draw polygons\n        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n\n        break;\n\n    case VTS_JOB_LINE_LABEL:\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n\n        var files = job.files;\n\n        if (files.length > 0) {\n            for (var i = 0, li = files.length; i < li; i++) {\n                if (files[i].length > 0) {\n                    var font = job.fonts[i];\n                    if (font && !font.areTexturesReady(files[i])) {\n                        return;\n                    }\n                }\n            }\n\n        } else {\n            if (!hitmapRender) {\n                return;\n            }\n\n            texture = renderer.whiteTexture;\n        }\n\n        prog = job.program; //renderer.progText;\n\n        gpu.useProgram(prog, ['aPosition', 'aTexCoord']);\n        prog.setSampler('uSampler', 0);\n        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n        prog.setVec4('uVec', renderer.labelVector);\n\n        var gamma = job.outline[2] * 1.4142 / 20;\n        var gamma2 = job.outline[3] * 1.4142 / 20;\n        prog.setVec4('uColor', (hitmapRender ? color : job.color2));\n        prog.setVec2('uParams', [job.outline[0], gamma2]);\n\n        vertexPositionAttribute = prog.getAttribute('aPosition');\n        vertexTexcoordAttribute = prog.getAttribute('aTexCoord');\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind vetex texcoords\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n        gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //draw polygons\n        for(var j = 0; j < (hitmapRender ? 1 : 2); j++) {\n            if (j == 1) {\n                prog.setVec4('uColor', color);\n                prog.setVec2('uParams', [job.outline[1], gamma]);\n            }\n\n            if (files.length > 0) {\n                for (var i = 0, li = files.length; i < li; i++) {\n                    var fontFiles = files[i];\n\n                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                        var file = fontFiles[k];\n                        prog.setFloat('uFile', Math.round(file+i*1000));\n                        gpu.bindTexture(job.fonts[i].getTexture(file));\n                        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n                    }\n                }\n\n            } else {\n                gpu.bindTexture(texture);\n                gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n            }\n        }\n\n        break;\n\n    case VTS_JOB_ICON:\n    case VTS_JOB_LABEL:\n    case VTS_JOB_PACK:\n    case VTS_JOB_VSPOINT:\n\n\n        if (job.reduce && (job.reduce[0] != 7 && job.reduce[0] != 8 && job.reduce[0] != 9)) {\n            var a, r = job.reduce;\n\n            if (r[0] > 4) {\n                \n                if (r[0] == 4) {\n                    a = Math.max(r[1], Math.floor(r[2] / Math.max(1, renderer.drawnGeodataTiles)));\n\n                    if (job.index >= a) {\n                        return;\n                    } \n                    r[5] = a; //for debug\n                } else {\n                    a = Math.pow(job.texelSize * job.tiltAngle, VTS_TILE_COUNT_FACTOR); \n                    a = Math.max(r[1], Math.round(r[2] * (a / Math.max(0.00001, this.renderer.drawnGeodataTilesFactor))));\n\n                    if (job.index >= a) {\n                        return;\n                    } \n                    r[5] = a; //for debug\n                }\n\n            } else {\n                a = job.tiltAngle;\n\n                if (r[0] == 1) {\n                    a = 1.0 - (Math.acos(a) * (1.0/(Math.PI*0.5)));\n                } else if (r[0] == 3) {\n                    a = (Math.cos(Math.acos(a) * 2) + 1.0) * 0.5;\n                }\n\n                var indexLimit = (Math.round(r[1] + (a*r[2]))-1);\n\n                if (job.index > indexLimit) {\n                    return;\n                } \n                r[5] = indexLimit; //for debug\n            }\n        }\n\n        var files = job.files;\n\n        if (job.type != VTS_JOB_VSPOINT) {\n            if (job.type == VTS_JOB_PACK) {\n\n                var notready = false;\n                \n                for (var j = 0, lj = job.subjobs.length; j < lj; j++) {\n                    var subjob = job.subjobs[j];\n\n                    files = subjob.files;\n\n                    if (files.length > 0) {\n                        for (var i = 0, li = files.length; i < li; i++) {\n                            if (files[i].length > 0) {\n                                var font = subjob.fonts[i];\n                                if (font && !font.areTexturesReady(files[i])) {\n                                    notready = true;\n                                }\n                            }\n                        }\n\n                    } else {\n                        texture = hitmapRender ? renderer.whiteTexture : subjob.texture;\n                        if (!texture.loaded) {\n                            notready = true;\n                        }\n                    }\n                }\n\n                if (notready) {\n                    return;\n                }\n\n            } else {\n                files = job.files;\n\n                if (files.length > 0) {\n                    for (var i = 0, li = files.length; i < li; i++) {\n                        if (files[i].length > 0) {\n                            var font = job.fonts[i];\n                            if (font && !font.areTexturesReady(files[i])) {\n                                return;\n                            }\n                        }\n                    }\n\n                } else {\n                    texture = hitmapRender ? renderer.whiteTexture : job.texture;\n                    if (!texture.loaded) {\n                        return;\n                    }\n                }\n            }\n        }\n\n        var p1, p2, camVec, ll, l = null, localTilt;\n\n        if (job.culling != 180) {\n            p2 = job.center;\n            p1 = renderer.cameraPosition;\n            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n            if (job.visibility) {\n                l = vec3.length(camVec);\n\n                switch(job.visibility.length) {\n                    case 1:\n                        if (l > job.visibility[0]) {\n                            return;\n                        }\n                        break;\n\n                    case 2:\n                        ll = l * renderer.localViewExtentFactor;\n                        if (ll < job.visibility[0] || ll > job.visibility[1]) {\n                            return;\n                        }\n\n                        break;\n\n                    case 4:\n                        ll = l * renderer.localViewExtentFactor;\n\n                        var diameter = job.visibility[0] * job.visibility[1];\n\n                        //dinfo = [l, ll, diameter, (job.visibility[2] * ll), (job.visibility[3] * ll)];\n\n                        if (diameter < (job.visibility[2] * ll) || diameter > (job.visibility[3] * ll)) {\n                            return;\n                        }\n\n                        break;\n                }\n\n                l = 1/l;\n                camVec[0] *= l;                       \n                camVec[1] *= l;                       \n                camVec[2] *= l;                       \n            } else {\n                vec3.normalize(camVec);\n            }\n                \n            job.normal = [0,0,0];\n            vec3.normalize(job.center, job.normal);\n                \n            localTilt = -vec3.dot(camVec, job.normal);\n            if (localTilt < Math.cos(math.radians(job.culling))) {\n                return;\n            }\n        } else if (job.visibility) {\n\n            p2 = job.center;\n            p1 = renderer.cameraPosition;\n            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            l = vec3.length(camVec);\n\n            switch(job.visibility.length) {\n                case 1:\n                    if (l > job.visibility[0]) {\n                        return;\n                    }\n                    break;\n\n                case 2:\n                    l *= renderer.localViewExtentFactor;\n                    if (l < job.visibility[0] || l > job.visibility[1]) {\n                        return;\n                    }\n\n                    break;\n\n                case 4:\n                    l *= renderer.localViewExtentFactor;\n\n                    var diameter = job.visibility[0] * job.visibility[1];\n                    if (diameter < (job.visibility[2] * l) || diameter > (job.visibility[3] * l)) {\n                        return;\n                    }\n\n                    break;\n            }\n        }\n\n        if (job.type == VTS_JOB_VSPOINT) {\n            //TODO: solve switch an call render\n            var viewExtent = renderer.viewExtent;\n            var lastViewExtent = 0, vswitch = job.vswitch;\n            job.vswitchIndex = 0;\n\n            for (i = 0, li = vswitch.length; i < li; i++) {\n                if (viewExtent <= vswitch[i][0] || i == (li-1)) {\n                    job.vswitchIndex = i;\n                    var slayers = job.vswitch[i];\n\n                    if (slayers) {\n                        slayers = slayers[1];\n\n                        for (j = 0, lj = slayers.length; j < lj; j++) {\n                            var sjob = slayers[j];\n                            sjob.mv = job.mv;\n                            sjob.mvp = job.mvp;\n                            sjob.updatePos = job.updatePos;\n                            sjob.hysteresis = job.hysteresis;\n                            sjob.vswitchIndex = i;\n                            sjob.renderCounter = job.renderCounter;\n                            sjob.localTilt = localTilt;\n                            sjob.id = job.id;\n                            this.drawGpuJob(gpu, gl, renderer, sjob, screenPixelSize, advancedHitPass, ignoreFilters);\n                        }\n                    }\n\n                    return;\n                }\n            }\n\n            return;\n        }\n\n        var s = job.stick;\n        var stickShift = 0, pp, o, depth, stickMode, stickHeight;\n\n        if (s[0] != 0) {\n            stickMode = renderer.config.mapFeatureStickMode;\n            stickHeight = s[0];\n\n            if (stickMode[0]) {\n                if (!localTilt) {\n                    localTilt = job.localTilt;\n\n                    if (!localTilt) {\n                        p2 = job.center;\n                        p1 = renderer.cameraPosition;\n                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                        vec3.normalize(camVec);\n                        job.normal = [0,0,0];\n                        vec3.normalize(job.center, job.normal);\n                            \n                        localTilt = -vec3.dot(camVec, job.normal);\n                    }\n                }\n\n                if (stickMode[0] == 2) {\n\n                    var hdelta = renderer.gridHmax - renderer.gridHmin;\n\n                    if (hdelta < 0) {\n                        hdelta = 0;\n                    }\n\n                    if (hdelta < stickHeight) {\n                        stickHeight = hdelta;\n                    }\n                }\n\n                if (localTilt < 0) {\n                    localTilt = 0;\n                }\n               \n                stickShift = Math.pow(1-localTilt,stickMode[1]) * stickHeight * renderer.cameraTiltFator;\n\n            } else {\n                stickShift = renderer.cameraTiltFator * s[0];\n            }\n                \n            if (stickShift < s[1]) {\n                stickShift = 0;\n            }\n\n            if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {\n                stickShift += s[7];\n            }\n\n            //else if (s[2] != 0) {\n                pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n                pp[0] = Math.round(pp[0]);\n                pp[1] -= stickShift;\n            //}\n        }\n\n        var reduce78 = (job.reduce && (job.reduce[0] == 7 || job.reduce[0] == 8 || job.reduce[0] == 9));\n\n        if (!renderer.drawAllLabels && job.noOverlap) { \n            if (!pp) {\n                pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n            }\n\n            o = job.noOverlap, depth = pp[2];\n\n            if (depth < 0 || depth > 1.0) {\n                return;\n            }\n\n            if (!renderer.rmap.checkRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], stickShift)) {\n                return;\n            }\n\n            if (o[4] !== null) {\n                if (o[4] === VTS_NO_OVERLAP_DIRECT) {\n                    depth = o[5];\n                } else {\n                    if (l === null) {\n                        p2 = job.center;\n                        p1 = renderer.cameraPosition;\n                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                        l = vec3.length(camVec) + 0.0001;\n                    }\n\n                    if (job.reduce && (job.reduce[0] != 8 && job.reduce[0] != 9)) {  //not overlap code not used for reduce==8\n                        depth = o[5] / l;\n                    }\n                } \n            }\n\n            job.lastSubJob = [job, stickShift, texture, files, color, pp, true, depth, o];\n\n            if (reduce78) {\n                renderer.gmapUseVersion = (job.reduce[0] == 8 || job.reduce[0] == 9) ? (job.reduce[0] - 6) : 1;\n                renderer.gmap[renderer.gmapIndex] = job.lastSubJob;\n                renderer.gmapIndex++;\n\n                if (renderer.config.mapFeaturesReduceFactor == 1) { // prom / dists\n                    if (l === null) {\n                        p2 = job.center;\n                        p1 = renderer.cameraPosition;\n                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                        l = vec3.length(camVec) + 0.0001;\n                    }\n\n                    if (l > renderer.fmaxDist) renderer.fmaxDist = l;\n                    if (l < renderer.fminDist) renderer.fminDist = l;\n\n                    //job.reduce[1] = Math.log(job.reduce[2] / l) * VTS_IMPORATANCE_INV_LOG;\n                    //job.reduce[1] = Math.log(job.reduce[2] / l) / Math.log(1.0017);\n                    \n                    //job.reduce[1] = Math.log(job.reduce[2] / l) / Math.log(1.0017);\n                    job.reduce[1] = job.reduce[2];\n                    job.reduce[4] = l;\n                }\n                return;\n            }\n\n            if (!renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], depth, job.lastSubJob)) {\n                renderer.rmap.storeRemovedRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], depth, job.lastSubJob);\n                return;\n            }\n\n            return; //draw all labe from same z-index together\n        } else {\n            if (reduce78) {\n                if (!pp) {\n                    pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n                }\n\n                job.lastSubJob = [job, stickShift, texture, files, color, pp, false];\n\n                renderer.gmapUseVersion = (job.reduce[0] == 8 || job.reduce[0] == 9) ? (job.reduce[0] - 6) : 1;\n                renderer.gmap[renderer.gmapIndex] = job.lastSubJob;\n                renderer.gmapIndex++;\n\n                if (renderer.config.mapFeaturesReduceFactor == 1) { // prom / dists\n                    if (l === null) {\n                        p2 = job.center;\n                        p1 = renderer.cameraPosition;\n                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                        l = vec3.length(camVec) + 0.0001;\n                    }\n\n                    if (l > renderer.fmaxDist) renderer.fmaxDist = l;\n                    if (l < renderer.fminDist) renderer.fminDist = l;\n\n                    //job.reduce[1] = Math.log(job.reduce[2] / l) * VTS_IMPORATANCE_INV_LOG;\n                    //job.reduce[1] = Math.log(job.reduce[2] / l) / Math.log(1.0017);\n                    job.reduce[1] = job.reduce[2];\n                    job.reduce[4] = l;\n                }\n\n                return;\n            }\n        }\n\n        if (job.hysteresis && job.id) {\n            if (!pp) {\n                pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n            }\n\n            job.lastSubJob = [job, stickShift, texture, files, color, pp];\n            renderer.jobHBuffer[job.id] = job;\n            return;\n        }\n\n        if (job.type == VTS_JOB_PACK) {\n            return;\n        }\n\n        if (renderer.drawLabelBoxes) {\n            o = job.noOverlap;\n\n            if (o) {\n                if (!pp) {\n                    pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n                }\n\n                gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n                this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],\n                                     [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);\n\n                if (job.reduce) {\n                    this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);\n                }\n            }\n        }\n\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);\n\n        if (s[0] != 0 && s[2] != 0) {\n            if (!pp) {\n                pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n            }\n\n            this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], s[6]], null, null, null, null, true);\n        }\n\n        /*if (dinfo) { //debug only\n            if (!pp) {\n                pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n            }\n\n            var stmp = \"\" + dinfo[0].toFixed(0) + \" \" + dinfo[1].toFixed(0) + \" \" + dinfo[2].toFixed(0) + \" \" + dinfo[3].toFixed(0) + \" \" + dinfo[4].toFixed(0);\n            this.drawText(Math.round(pp[0]-this.getTextSize(10,stmp)*0.5), Math.round(pp[1]), 10, stmp, [1,1,1,1], 0);\n        }*/\n\n        if (job.singleBuffer) {\n            if (!pp) {\n                pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n            }\n            \n            var b = job.singleBuffer;\n\n            if (!job.singleBuffer2) {\n                job.singleBuffer2 = new Float32Array(b);\n\n                var tx = 1 / texture.width, ty = 1 / texture.height;\n                b[2] *= tx; b[3] *= ty;\n                b[6] *= tx; b[7] *= ty;\n                b[10] *= tx; b[11] *= ty;\n                b[14] *= tx; b[15] *= ty;\n            }\n\n            prog = renderer.progImage;\n            var b2 = job.singleBuffer2;\n\n            b[0] = pp[0] + b2[0];\n            b[1] = pp[1] + b2[1];\n\n            b[4] = pp[0] + b2[4];\n            b[5] = pp[1] + b2[5];\n\n            b[8] = pp[0] + b2[8];\n            b[9] = pp[1] + b2[9];\n\n            b[12] = pp[0] + b2[12];\n            b[13] = pp[1] + b2[13];\n\n            gpu.useProgram(prog, ['aPosition']);\n            gpu.bindTexture(texture);\n\n            var vertices = renderer.rectVerticesBuffer;\n            gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n            gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n            var indices = renderer.rectIndicesBuffer;\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n            prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n\n            prog.setMat4('uData', b );\n\n            prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));\n            prog.setFloat('uDepth', depth != null ? depth : 0);\n\n            gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n            \n            return;   \n        }\n\n        prog = job.program; //renderer.progIcon;\n\n        gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aOrigin']);\n        prog.setSampler('uSampler', 0);\n        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n        prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], (job.type == VTS_JOB_LABEL ? 1.0 : 1.0 / texture.width), stickShift*2]);\n\n        var j = 0, lj = 1;\n\n        if (prog != renderer.progIcon) {\n            prog.setVec4('uColor', hitmapRender ? color : job.color2);\n            prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);\n            lj = hitmapRender ? 1 : 2;\n        } else {\n            prog.setVec4('uColor', color);\n        }\n\n        vertexPositionAttribute = prog.getAttribute('aPosition');\n        vertexTexcoordAttribute = prog.getAttribute('aTexCoord');\n        vertexOriginAttribute = prog.getAttribute('aOrigin');\n\n        //bind vetex positions\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind vetex texcoordds\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n        gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //bind vetex origin\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);\n        gl.vertexAttribPointer(vertexOriginAttribute, job.vertexOriginBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n        //draw polygons\n        for(;j<lj;j++) {\n            if (j == 1) {\n                prog.setVec4('uColor', color);\n                prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);\n            }\n\n            if (files.length > 0) {\n                for (var i = 0, li = files.length; i < li; i++) {\n                    var fontFiles = files[i];\n\n                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                        var file = fontFiles[k];\n                        prog.setFloat('uFile', Math.round(file+i*1000));\n                        gpu.bindTexture(job.fonts[i].getTexture(file));\n                        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n                    }\n                }\n\n            } else {\n                gpu.bindTexture(texture);\n                gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n            }\n        }\n\n        break;\n    }\n\n    return;\n};\n\nRendererDraw.prototype.drawGpuSubJob = function(gpu, gl, renderer, screenPixelSize, subjob, fade) {\n    if (!subjob) {\n        return;\n    }\n\n    var job = subjob[0], stickShift = subjob[1], texture = subjob[2],\n        files = subjob[3], color = subjob[4], pp = subjob[5], s = job.stick,\n        o = job.noOverlap, localTilt;\n\n    if (job.hysteresis && job.id) {\n        if (job.culling != 180) {\n            var p2 = job.center;\n            var p1 = renderer.cameraPosition;\n            var camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            vec3.normalize(camVec);\n                \n            job.normal = [0,0,0];\n            vec3.normalize(job.center, job.normal);\n                \n            localTilt = -vec3.dot(camVec, job.normal);\n            if (localTilt < Math.cos(math.radians(job.culling))) {\n                return;\n            }\n        }\n\n        //if (o) {\n            //var x1 = pp[0]+o[0], y1 = pp[1]+o[1], \n              //  x2 = pp[0]+o[2], y2 = pp[1]+o[3]+stickShift;\n\n            /*\n            if (s[0] != 0) {\n                stickShift = renderer.cameraTiltFator * s[0];\n                    \n                if (stickShift < s[1]) {\n                    stickShift = 0;\n                }\n            }*/\n\n            /* \n            var rmap = renderer.rmap;\n\n            //screen including credits\n            if (x1 < 0 || x2 > rmap.slx || y1 < 0 || y2 > rmap.sly) {\n                return false;\n            }\n\n            //compass\n            if (x1 < rmap.clx && x2 > 0 && y1 <= rmap.sly && y2 > (rmap.sly - rmap.cly)) {\n                return false;\n            }\n\n            //serach bar\n            if (x1 < rmap.blx && x2 > 0 && y1 <= rmap.bly && y2 > 0) {\n                return false;\n            }*/\n        //}\n\n        if (s[0] != 0) {\n            var stickMode = renderer.config.mapFeatureStickMode;\n            var stickHeight = s[0];\n\n            if (stickMode[0]) {\n                if (!localTilt) {\n                    localTilt = job.localTilt;\n\n                    if (!localTilt) {\n                        p2 = job.center;\n                        p1 = renderer.cameraPosition;\n                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n                        vec3.normalize(camVec);\n                        job.normal = [0,0,0];\n                        vec3.normalize(job.center, job.normal);\n                            \n                        localTilt = -vec3.dot(camVec, job.normal);\n                    }\n                }\n\n                if (stickMode[0] == 2) {\n\n                    var hdelta = renderer.gridHmax - renderer.gridHmin;\n\n                    if (hdelta < 0) {\n                        hdelta = 0;\n                    }\n\n                    if (hdelta < stickHeight) {\n                        stickHeight = hdelta;\n                    }\n                }\n\n                if (localTilt < 0) {\n                    localTilt = 0;\n                }\n               \n                stickShift = Math.pow(1-localTilt,stickMode[1]) * stickHeight * renderer.cameraTiltFator;\n\n            } else {\n                stickShift = renderer.cameraTiltFator * s[0];\n            }\n              \n            if (stickShift < s[1]) {\n                stickShift = 0;\n            }\n\n            if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {\n                stickShift += s[7];\n            }\n\n\n             //else if (s[2] != 0) {\n                pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n                pp[0] = Math.round(pp[0]);\n                pp[1] -= stickShift;\n            //}\n\n        }\n\n    }\n\n    var hitmapRender = job.hitable && renderer.onlyHitLayers;\n\n    if (job.type == VTS_JOB_PACK) {\n        if (renderer.drawLabelBoxes && o) {\n            gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n            this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],\n                                 [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);\n\n            if (job.reduce) {\n                this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);\n            }\n        }\n\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);\n\n        if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {\n            this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], ((fade !== null) ? s[6] * fade : s[6]) ], null, null, null, null, true);\n            //stickShift += s[7];\n        }\n\n        for (var i = 0, li = job.subjobs.length; i < li; i++) {\n            var subjob2 = job.subjobs[i], job2;\n            subjob2.mvp = job.mvp;\n            subjob2.updatePos = job.updatePos;\n\n            var depth = subjob[7];\n\n            o = null;\n            files = subjob2.files;\n\n            if (hitmapRender) {\n                color = subjob[4];\n                texture = renderer.whiteTexture;\n            } else {\n                color = subjob2.color;\n                texture = subjob2.texture;\n            }\n\n            this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, [subjob2, stickShift, texture, files, color, pp, true, depth, o], fade);\n        }\n\n        return;\n    }\n\n\n    if (renderer.drawLabelBoxes && o) {\n        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);\n        this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],\n                             [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);\n\n        if (job.reduce) {\n            this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);\n        }\n    }\n\n    gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);\n\n    var j = 0, lj = 1, color2 = job.color2;\n\n    if (fade !== null) {\n        color = [color[0], color[1], color[2], color[3] * fade];\n\n        if (color2) {\n            color2 = [color2[0], color2[1], color2[2], color2[3] * fade];\n        }\n    }\n\n    if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {\n        this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], ((fade !== null) ? s[6] * fade : s[6]) ], null, null, null, null, true);\n    }\n\n    var prog = job.program; //renderer.progIcon;\n\n    if (job.singleBuffer) {\n\n        if (prog == renderer.progIcon) {\n            var b = job.singleBuffer;\n            prog = renderer.progImage;\n\n            if (!job.singleBuffer2) {\n                job.singleBuffer2 = new Float32Array(b);\n\n                var tx = 1 / texture.width, ty = 1 / texture.height;\n                b[2] *= tx; b[3] *= ty;\n                b[6] *= tx; b[7] *= ty;\n                b[10] *= tx; b[11] *= ty;\n                b[14] *= tx; b[15] *= ty;\n            }\n\n            if (job.updatePos) {\n                pp = renderer.project2(job.center, renderer.camera.mvp, renderer.cameraPosition);\n                pp[1] -= stickShift;\n                pp[2] = pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2);\n            }\n\n            depth = pp[2];\n\n            var b2 = job.singleBuffer2;\n\n            b[0] = pp[0] + b2[0];\n            b[1] = pp[1] + b2[1];\n\n            b[4] = pp[0] + b2[4];\n            b[5] = pp[1] + b2[5];\n\n            b[8] = pp[0] + b2[8];\n            b[9] = pp[1] + b2[9];\n\n            b[12] = pp[0] + b2[12];\n            b[13] = pp[1] + b2[13];\n\n            gpu.useProgram(prog, ['aPosition']);\n            gpu.bindTexture(texture);\n\n            var vertices = renderer.rectVerticesBuffer;\n            gl.bindBuffer(gl.ARRAY_BUFFER, vertices);\n            gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);\n\n            var indices = renderer.rectIndicesBuffer;\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n\n            prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);\n\n            prog.setMat4('uData', job.singleBuffer );\n\n            //prog.setVec4('uColor', hitmapRender ? color : color2);\n            prog.setVec4('uColor', color);\n            prog.setFloat('uDepth', depth);\n\n            gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);\n\n        } else {\n\n            var b = job.singleBuffer, bl = b.length, vbuff, vitems = (b.length / 4) * 6;\n\n            if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLabel96; } else\n            if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLabel64; } else\n            if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLabel48; } else\n            if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLabel32; }\n            else { vbuff = renderer.textQuads16; prog = renderer.progLabel16; }\n\n            gpu.useProgram(prog, ['aPosition']);\n            prog.setSampler('uSampler', 0);\n            prog.setMat4('uMVP', job.mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n            prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], 1, stickShift*2]);\n            prog.setVec3('uOrigin', job.origin);\n            prog.setVec4('uColor', hitmapRender ? color : color2);\n            prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);\n            lj = hitmapRender ? 1 : 2;\n\n            var vertexPositionAttribute = prog.getAttribute('aPosition');\n\n            prog.setVec4('uData', b);\n\n            //bind vetex positions\n            gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);\n            gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);\n\n            //draw polygons\n            for(;j<lj;j++) {\n                if (j == 1) {\n                    prog.setVec4('uColor', color);\n                    prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);\n                }\n\n                for (var i = 0, li = files.length; i < li; i++) {\n                    var fontFiles = files[i];\n\n                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                        var file = fontFiles[k];\n                        prog.setFloat('uFile', Math.round(file+i*1000));\n                        gpu.bindTexture(job.fonts[i].getTexture(file));\n                        gl.drawArrays(gl.TRIANGLES, 0, vitems);\n                    }\n                }\n            }\n\n        }\n        \n        return;   \n    }\n\n    gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aOrigin']);\n    prog.setSampler('uSampler', 0);\n    prog.setMat4('uMVP', job.mvp, renderer.getZoffsetFactor(job.zbufferOffset));\n    prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], (job.type == VTS_JOB_LABEL ? 1.0 : 1.0 / texture.width), stickShift*2]);\n\n    if (prog != renderer.progIcon) {\n        prog.setVec4('uColor', hitmapRender ? color : color2);\n        prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);\n        lj = hitmapRender ? 1 : 2;\n    } else {\n        prog.setVec4('uColor', color);\n    }\n\n    var vertexPositionAttribute = prog.getAttribute('aPosition');\n    var vertexTexcoordAttribute = prog.getAttribute('aTexCoord');\n    var vertexOriginAttribute = prog.getAttribute('aOrigin');\n\n    //bind vetex positions\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n    gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    //bind vetex texcoordds\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n    gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    //bind vetex origin\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);\n    gl.vertexAttribPointer(vertexOriginAttribute, job.vertexOriginBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    //draw polygons\n    for(;j<lj;j++) {\n        if (j == 1) {\n            prog.setVec4('uColor', color);\n            prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);\n        }\n\n        if (files.length > 0) {\n            for (var i = 0, li = files.length; i < li; i++) {\n                var fontFiles = files[i];\n\n                for (var k = 0, lk = fontFiles.length; k < lk; k++) {\n                    var file = fontFiles[k];\n                    prog.setFloat('uFile', Math.round(file+i*1000));\n                    gpu.bindTexture(job.fonts[i].getTexture(file));\n                    gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n                }\n            }\n\n        } else {\n            gpu.bindTexture(texture);\n            gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);\n        }\n    }\n};\n\nexport default RendererDraw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/draw.js\n// module id = 157\n// module chunks = 0 1","\nimport BBox_ from './bbox';\n\n//get rid of compiler mess\nvar BBox = BBox_;\n\n\nvar RendererGeometry = {};\n\n\nRendererGeometry.setFaceVertices = function(vertices, a, b, c, index) {\n    vertices[index] = a[0];\n    vertices[index+1] = a[1];\n    vertices[index+2] = a[2];\n\n    vertices[index+3] = b[0];\n    vertices[index+4] = b[1];\n    vertices[index+5] = b[2];\n\n    vertices[index+6] = c[0];\n    vertices[index+7] = c[1];\n    vertices[index+8] = c[2];\n};\n\n\nRendererGeometry.setFaceUVs = function(uvs, a, b, c, index) {\n    uvs[index] = a[0];\n    uvs[index+1] = a[1];\n\n    uvs[index+2] = b[0];\n    uvs[index+3] = b[1];\n\n    uvs[index+4] = c[0];\n    uvs[index+5] = c[1];\n};\n\n\n// Procedural mesh representing a heightmap block\n// Creates a grid of size x size vertices, all coords are [0..1].\nRendererGeometry.buildHeightmap = function(size, use16bit) {\n    size--;\n\n    var g = RendererGeometry;\n    var numFaces = (size* size) * 2;\n    var vertices = new Float32Array(numFaces * 3 * 3);//[];\n    var uvs = new Float32Array(numFaces * 3 * 2);//[];\n\n    var factor = 1.0 * size;\n    var index = 0;\n    var index2 = 0;\n\n    for (var i = 0; i < size; i++) {\n        for (var j = 0; j < size; j++) {\n            var x1 = (j) * factor;\n            var x2 = (j+1) * factor;\n\n            var y1 = (i) * factor;\n            var y2 = (i+1) * factor;\n\n            g.setFaceVertices(vertices, [x1, y1, 0], [x2, y1, 0], [x2, y2, 0], index);\n            g.setFaceUVs(uvs, [x1, y1], [x2, y1], [x2, y2], index2);\n            index += 9;\n            index2 += 6;\n\n            g.setFaceVertices(vertices, [x2, y2, 0], [x1, y2, 0], [x1, y1, 0], index);\n            g.setFaceUVs(uvs, [x2, y2], [x1, y2], [x1, y1], index2);\n            index += 9;\n            index2 += 6;\n        }\n    }\n\n    var bbox = new BBox(0,0,0,1,1,1);\n\n    if (use16bit) {\n        return { bbox:bbox, vertices:this.covnetTo16Bit(vertices), uvs: this.covnetTo16Bit(uvs)};\n    } else {\n        return { bbox:bbox, vertices:vertices, uvs: uvs};\n    }\n};\n\n\nRendererGeometry.buildPlane = function(size, use16bit) {\n    size--;\n\n    var g = RendererGeometry;\n    var numFaces = (size* size) * 2;\n    var vertices = (use16bit) ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n    var uvs = new Float32Array(numFaces * 3 * 2);//[];\n\n    var factor = 1.0 / (size);\n    var index = 0, index2 = 0;\n    var x1, y1, x2, y2, xx1, xx2, yy1, yy2;\n\n    for (var i = 0; i < size; i++) {\n        for (var j = 0; j < size; j++) {\n            x1 = j;\n            x2 = j+1;\n            y1 = i;\n            y2 = i+1;\n\n            xx1 = j * factor;\n            xx2 = (j+1) * factor;\n            yy1 = (i) * factor;\n            yy2 = (i+1) * factor;\n\n            g.setFaceVertices(vertices, [x1, y1, 0], [x1, y2, 0], [x2, y2, 0], index);\n            g.setFaceUVs(uvs, [xx1, yy1], [xx1, yy2], [xx2, yy2], index2);\n            index += 9;\n            index2 += 6;\n\n            g.setFaceVertices(vertices, [x2, y2, 0], [x2, y1, 0], [x1, y1, 0], index);\n            g.setFaceUVs(uvs, [xx2, yy2], [xx2, yy1], [xx1, yy1], index2);\n            index += 9;\n            index2 += 6;\n        }\n    }\n\n    var bbox = new BBox(0,0,0,1,1,1);\n\n    if (use16bit) {\n        return { bbox:bbox, vertices:vertices, uvs: this.covnetTo16Bit(uvs)};\n    } else {\n        return { bbox:bbox, vertices:vertices, uvs: uvs};\n    }\n};\n\nRendererGeometry.spherePos = function(lon, lat) {\n    lat *= Math.PI;\n    lon *= 2*Math.PI;\n\n    return [Math.cos(lon)*Math.sin(lat)*0.5 + 0.5,\n        Math.sin(lon)*Math.sin(lat)*0.5 + 0.5,\n        Math.cos(lat) * 0.5 + 0.5];\n};\n\n\n// Creates an approximation of a unit sphere, note that all coords are\n// in the range [0..1] and the center is in (0.5, 0.5). Triangle \"normals\"\n// are oriented inwards.\nRendererGeometry.buildSkydome = function(latitudeBands, longitudeBands, use16bit, useIndices) {\n    var g = RendererGeometry;\n    var numFaces = (latitudeBands * longitudeBands) * 2;\n    var numVertices = (latitudeBands * longitudeBands) * (useIndices ? 1 : 3);\n    var vertices = new Float32Array(numVertices * 3);\n    var uvs = new Float32Array(numVertices * 2);\n    var indices = useIndices ? (new Uint16Array(numFaces * 3)) : null;\n    var index = 0, index2 = 0;\n    var g = RendererGeometry, lat, lon, lon2, lat2, v, flon, flat;\n\n    if (useIndices) {\n\n        for (lat = 0; lat < latitudeBands; lat++) {\n            for (lon = 0; lon < longitudeBands; lon++) {\n\n                flon = lon / longitudeBands;\n                flat = lat / latitudeBands;\n                v = g.spherePos(flon, flat);\n\n                vertices[index] = v[0];\n                vertices[index+1] = v[1];\n                vertices[index+2] = v[2];\n\n                uvs[index2] = flon;\n                uvs[index2+1] = flat;\n\n                index += 3;\n                index2 += 2;\n            }\n        }\n\n        index = 0;\n\n        for (lat = 0; lat < (latitudeBands - 1); lat++) {\n            for (lon = 0; lon < longitudeBands; lon++) {\n\n                lat2 = lat + 1;\n                lon2 = lon + 1;\n\n                if (lon2 >= longitudeBands) {\n                    lon2 = 0;\n                }\n\n                indices[index] = (lat2 * longitudeBands) + lon;\n                indices[index+1] = (lat * longitudeBands) + lon;\n                indices[index+2] = (lat * longitudeBands) + lon2;\n\n                indices[index+3] = (lat * longitudeBands) + lon2;\n                indices[index+4] = (lat2 * longitudeBands) + lon2;\n                indices[index+5] = (lat2 * longitudeBands) + lon;\n\n                index += 6;\n            }\n        }\n\n    } else {\n\n        for (var lat = 0; lat < latitudeBands; lat++) {\n            for (var lon = 0; lon < longitudeBands; lon++) {\n\n                var lon1 = ((lon) / longitudeBands);\n                var lon2 = ((lon+1) / longitudeBands);\n\n                var lat1 = ((lat) / latitudeBands);\n                var lat2 = ((lat+1) / latitudeBands);\n\n                g.makeQuad(lon1, lat1, lon2, lat2, vertices, index, uvs, index2);\n                index += 9*2;\n                index2 += 6*2;\n            }\n        }\n\n    }\n\n    var bbox = new BBox(0,0,0,1,1,1);\n\n    if (use16bit) {\n        return { bbox:bbox, vertices:this.covnetTo16Bit(vertices), uvs: this.covnetTo16Bit(uvs), indices:indices};\n    } else {\n        return { bbox:bbox, vertices:vertices, uvs: uvs, indices:indices};\n    }\n};\n\nRendererGeometry.covnetTo16Bit = function(array) {\n    var t, array2 = new Uint16Array(array.length);\n\n    for (var i = 0, li = array.length; i < li; i++) {\n        t = array[i] * 65535;\n        if (t < 0) t = 0; if (t > 65535) t = 65535;\n        array2[i] = t;\n    }\n\n    return array2;\n}\n\n\nRendererGeometry.makeQuad = function(lon1, lat1, lon2, lat2, vertices, index, uvs, index2) {\n    var g = RendererGeometry;\n    var a = g.spherePos(lon1, lat1), ta = [lon1, lat1];\n    var b = g.spherePos(lon1, lat2), tb = [lon1, lat2];\n    var c = g.spherePos(lon2, lat1), tc = [lon2, lat1];\n    var d = g.spherePos(lon2, lat2), td = [lon2, lat2];\n    g.setFaceVertices(vertices, b, a, c, index);\n    g.setFaceUVs(uvs, tb, ta, tc, index2);\n    g.setFaceVertices(vertices, c, d, b, index+9);\n    g.setFaceUVs(uvs, tc, td, tb, index2+6);\n};\n\n\nexport default RendererGeometry;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/geometry.js\n// module id = 158\n// module chunks = 0 1","\n\nfunction processGMap(gpu, gl, renderer, screenPixelSize, draw) {\n    if (!renderer.config.mapFeaturesReduceParams) {\n        return;\n    }\n\n    var tileCount = renderer.config.mapFeaturesReduceParams[1]; //31; //labelGridCells\n    var featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[0]; //0.6614; //labelsPerSquareInch\n    var ppi = 96 * (window.devicePixelRatio || 1);\n    var screenLX = renderer.curSize[0];\n    var screenLY = renderer.curSize[1];\n    var featureCount = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch); \n    var i, li, top = renderer.config.mapFeaturesSortByTop;\n\n    if (tileCount <= 0) {\n        tileCount = featureCount * 2; //31; //labelGridCells\n    } else {\n        tileCount = tileCount;\n    }\n\n    //renderer.debugStr = '<br>featuresPerScr: ' + featureCount + '<br>gridCells: ' + tileCount + '';\n\n    //get top features\n    var featureCache = renderer.gmap;\n    var featureCacheSize = renderer.gmapIndex;\n    var topFeatures = renderer.gmapTop;\n    var featureCount2 = featureCount;\n\n    if (featureCount > featureCacheSize) {\n        featureCount2 = featureCacheSize;\n    }\n\n    //distribute top features\n    var tileSize = Math.floor(Math.sqrt((screenLX*screenLY) / tileCount));\n    var hitMap = renderer.gmapHit, usedFeatures = 0;\n    var tileFeatures, count, feature;\n    var drawAllLabels = renderer.drawAllLabels;\n\n    var colors = [\n        [0, 0, 255, 255],\n        [128, 0, 255, 255],\n        [255, 0, 0, 255],\n        [255, 128, 0, 255],\n        [0, 255, 0, 255],\n        [0, 255, 128, 255],\n        [128, 255, 128, 255]\n    ];\n\n    var colorIndex = 0;\n\n    do {\n        var a,b,c,d,ix,iy,is,pp,tx,ty,mx,my,v,index,o,j;\n\n        ix = screenLX / tileSize;\n        iy = screenLY / tileSize;\n        is = ix * iy;\n        mx = Math.floor(ix);\n        my = Math.floor(iy);\n        ix = ix - mx;\n        iy = iy - my;\n\n        a = 1 / is;\n        b = ix / is;\n        c = iy / is;\n        d = (ix*iy) / is;\n\n        a = Math.floor(a * featureCount);\n        b = Math.floor(b * featureCount);\n        c = Math.floor(c * featureCount);\n        d = Math.floor(d * featureCount);\n\n        var hitMap = renderer.gmapStore;\n        var hitMapCount = renderer.gmapHit;\n\n        if (renderer.drawGridCells) {\n            gpu.setState(renderer.lineLabelState);\n\n            var x = 0, y = 0, j, lj;\n\n            for (j = 0, lj = (my + 1); j < lj; j++) {\n                for (i = 0, li = (mx + 1); i < li; i++) {\n                    x = tileSize * i;\n                    y = tileSize * j;\n\n                    v = a;\n\n                    if (i >= mx) {\n                        if (j >= my) {\n                            v =d;\n                        } else {\n                            v = b;\n                        }\n\n                    } else {\n                        if (j >= my) {\n                            v = b;\n                        }\n                    }\n\n                    draw.drawLineString([[x, y, 0.5], [x+tileSize, y, 0.5],\n                                         [x+tileSize, y+tileSize, 0.5], [x, y+tileSize, 0.5]], true, 1, colors[colorIndex], null, true, null, null, null);\n\n                    draw.drawText(Math.round(x+5), Math.round(y + 5 + colorIndex * 15), 10, '' + v, colors[colorIndex], 0.5);\n                }\n            }\n\n        }\n\n\n        //clear hit-map\n        for (i = 0, li = (mx+1) * (my+1); i < li; i++) {\n            hitMap[i] = null;\n        }\n\n        for (i = 0, li = featureCacheSize; i < li; i++) {\n            feature = featureCache[i];\n            if (!feature) {\n                continue;\n            }\n\n            pp = feature[5];\n\n            if (pp[0] < 30 || pp[0] >= (screenLX-30) || pp[1] < 30 || pp[1] >= (screenLY-30)) {\n                featureCache[i] = null;\n                continue;\n            }\n\n            tx = pp[0] / tileSize;\n            ty = pp[1] / tileSize;\n\n            if (tx > mx) {\n                if (ty > my) {\n                    v = d;\n                } else {\n                    v = b;\n                }\n            } else if (ty > my) {\n                v = c;\n            } else {\n                v = a;\n            }\n\n            if (v > 0) {\n                index = Math.floor(tx) + Math.floor(ty) * (mx + 1);\n\n                tileFeatures = hitMap[index];\n\n                if (tileFeatures) {\n                    hitMap[index].push(i);\n                } else {\n                    hitMap[index] = [i];\n                    hitMapCount[index] = v;\n                }\n            }\n        }\n\n        for (i = 0, li = (mx+1) * (my+1); i < li; i++) {\n            tileFeatures = hitMap[i];\n\n            if (tileFeatures && tileFeatures.length) {\n                count = hitMapCount[i];\n\n                if (count > tileFeatures.length) {\n                    count = tileFeatures.length;\n                }\n\n                sortFeatures(tileFeatures, top, count, renderer);\n\n                for (j = 0; j < count; j++){\n                    index = topFeatures[j]\n                    feature = featureCache[index];\n                    topFeatures[j] = null;\n                    featureCache[index] = null;\n\n                    //render job\n                    if (!drawAllLabels && feature[6]) { //no-overlap \n                        pp = feature[5];\n                        o = feature[8];\n                        if (!renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob)) {\n                            renderer.rmap.storeRemovedRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob);\n                        }\n                    } else {\n                        if (feature[0].hysteresis) {\n                            renderer.jobHBuffer[feature[0].id] = feature[0];\n                        } else {\n                            draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, subjob, null);\n                        }\n                    }\n                }\n\n            }\n        }\n\n        a *= mx * my;\n        b *= mx;\n        c *= my;\n\n        usedFeatures += a + b + c + d;\n        featureCount -= a + b + c + d;\n        tileSize *= 2;\n\n        colorIndex++;\n\n    } while(usedFeatures < featureCount2);\n\n}\n\n\nfunction sortFeatures(features, top, count, renderer) {\n    var value, feature;\n    var currentIndex = 0;\n    var currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n    var topFeatures = renderer.gmapTop;\n    var topFeaturesIndex = 0;\n    var topFeaturesIndex2 = 0;\n\n    //remove feature from cache\n    var featureCache = renderer.gmap, index;\n\n\n    do {\n        var currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n        topFeaturesIndex2 = topFeaturesIndex;\n\n        for (var i = 0, li = features.length; i < li; i++) {\n            index = features[i];\n            feature = featureCache[index];\n            value = feature[0].reduce[1];\n\n            if (((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {\n                if (currentValue != value) {\n                    topFeaturesIndex = topFeaturesIndex2;\n                }\n\n                topFeatures[topFeaturesIndex] = index;\n                topFeaturesIndex++;\n                currentValue = value;\n            }\n        }\n\n        currentValue2 = currentValue;\n        currentIndex++;\n\n    } while(currentIndex < count);\n\n}\n\nfunction storeFeatureToHitmap(id, feature, ix, iy, mx, my, hitMap, hcache, hcacheSize) {\n    var x1 = ix - 1, y1 = iy - 1, x,\n        x2 = ix + 1, y2 = iy + 1, index, blockFeatures;\n\n    if (x1 < 0) x1 = 0;\n    if (y1 < 0) y1 = 0;\n    if (x2 > mx) x2 = mx;\n    if (y2 > my) y2 = my;\n\n    for (; y1 <= y2; y1++) {\n        for (x = x1; x <= x2; x++) {\n            index = (y1 * mx + x) * 2;\n            blockFeatures = hitMap[index];\n\n            if (!hitMap[index]) {\n                hitMap[index] = hcacheSize;\n                hitMap[index+1] = hcacheSize+1;\n                hcache[hcacheSize] = feature;\n                hcache[hcacheSize+1] = 0;\n                hcacheSize +=2;\n            } else {\n                hcache[hitMap[index+1]] = hcacheSize;\n                hitMap[index+1] = hcacheSize+1;\n                hcache[hcacheSize] = feature;\n                hcache[hcacheSize+1] = 0;\n                hcacheSize +=2;\n            }\n        }\n    }\n\n    return hcacheSize;\n}\n\n\nfunction processGMap4(gpu, gl, renderer, screenPixelSize, draw) {\n    if (!renderer.config.mapFeaturesReduceParams) {\n        return;\n    }\n\n    var ppi = 96 * (window.devicePixelRatio || 1);\n\n    var maxRadius = renderer.config.mapFeaturesReduceParams[0] * ppi; //mapFeatureRadius\n    var maxHitcount = renderer.config.mapFeaturesReduceParams[1]; //0.6614; //mapFeatureMaxOverlays\n\n    var screenLX = renderer.curSize[0];\n    var screenLY = renderer.curSize[1];\n    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp;\n    var feature, feature2, pp, pp2, o;\n    var drawAllLabels = renderer.drawAllLabels;\n\n    //get top features\n    var featureCache = renderer.gmap;\n    var featureCacheSize = renderer.gmapIndex;\n\n    var hcache = renderer.gmap2;\n    var hcacheSize = 1;\n    var hmap = renderer.gmap3;\n    var hmapSize = renderer.gmap3Size;\n    var hmap = renderer.gmap3;\n\n\n    var hmin = 10000;\n    var hmax = 0, h, r;\n\n    var divByDist = (renderer.config.mapFeaturesReduceFactor == 1);\n\n    if (divByDist) { // imp / dists\n        if (renderer.fmaxDist == Number.NEGATIVE_INFINITY || renderer.fminDist == Number.POSITIVE_INFINITY) {\n            return;\n        }\n\n        var ub = 1 - Math.log(renderer.fminDist) / Math.log(101);\n        var lb = -Math.log(renderer.fmaxDist) / Math.log(101); \n    }\n\n    //filter features and sort them by importance\n    for (i = 0, li = featureCacheSize; i < li; i++) {\n        feature = featureCache[i];\n        if (!feature) {\n            continue;\n        }\n\n        pp = feature[5];\n\n        if (divByDist) {\n            r = feature[0].reduce;\n            h = Math.round(-5000 + ( ( Math.log(r[1]+1) - Math.log(r[4]) ) / Math.log(101) - lb ) / ( ub-lb ) * 10000) + 5000;\n            r[5] = h; //for debug\n        } else {\n            h = Math.round(feature[0].reduce[1]);            \n        }\n\n        if (h < 0) h = 0;\n        if (h >= 10000) h = 9999;\n        if (h < hmin) hmin = h;\n        if (h > hmax) hmax = h;\n\n        hmap[h][hmapSize[h]++] = feature;\n    }\n\n    var invMaxRadius = 1 / maxRadius, index, ix, iy, features;\n    var mx = Math.floor(screenLX * invMaxRadius);\n    var my = Math.floor(screenLY * invMaxRadius);\n\n    var hitMap = renderer.gmapStore;\n    var hitMapCount = renderer.gmapHit;\n\n    //clear hit-map\n    for (i = 0, li = (mx+1) * (my+1) * 2; i < li; i+=2) {\n        hitMap[i] = 0;\n    }\n\n    //var hitCache = renderer.gmapHit2;\n    var hitCacheSize = 0, j, lj, k, lk, hitCount, dx, dy, blockFeatures;\n\n    maxRadius *= maxRadius;\n\n    for (i = hmax, li = hmin; i >= 0; i--) {\n\n        if (hmapSize[i] > 0) {\n            var features = hmap[i];\n\n            for (j = 0, lj = hmapSize[i]; j < lj; j++) {\n                feature = features[j];\n\n                hitCount = 0;\n                pp = feature[5];\n\n                //check area\n                ix = Math.floor(pp[0] * invMaxRadius);\n                iy = Math.floor(pp[1] * invMaxRadius);\n                index = ((iy * mx) + ix) * 2;\n                //blockFeatures = hitMap[index];\n\n                //check\n                if (hitMap[index]) {\n                    index = hitMap[index];\n                    do {\n                        feature2 = hcache[index];\n                        pp2 = feature2[5];\n\n                        dx = pp[0] - pp2[0];\n                        dy = pp[1] - pp2[1];\n\n                        if ((dx*dx+dy*dy) < maxRadius) {\n                            hitCount++;\n                            if (hitCount > maxHitcount) {\n                                break;\n                            }\n                        }\n\n                        index = hcache[index+1];\n                    } while (index);\n                }\n\n                // check                \n                if (hitCount <= maxHitcount) {\n                    index = hitCacheSize;\n\n                    //render job\n                    if (!drawAllLabels && feature[6]) { //no-overlap \n                        pp = feature[5];\n                        o = feature[8];\n                        if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true)) {\n                            //hitCache[hitCacheSize] = feature;\n                            hitCacheSize++;\n                        }\n                    } else {\n                        if (feature[0].hysteresis) {\n                            renderer.jobHBuffer[feature[0].id] = feature[0];\n                        } else {\n                            renderer.drawnJobs++;\n                            draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, feature[0].lastSubJob, null);\n                        }\n\n                        //hitCache[hitCacheSize] = feature;\n                        hitCacheSize++;\n                    }\n\n                    //store to hitmap\n                    if (index != hitCacheSize) {\n                        hcacheSize = storeFeatureToHitmap(index, feature, ix, iy, mx, my, hitMap, hcache, hcacheSize);\n                    }\n                }\n\n            }\n\n            hmapSize[i] = 0;  //zero size\n        }\n    }\n}\n\nfunction processGMap5(gpu, gl, renderer, screenPixelSize, draw) {\n    if (!renderer.config.mapFeaturesReduceParams) {\n        return;\n    }\n\n    var ppi = 96 * (window.devicePixelRatio || 1);\n\n    var maxRadius = renderer.config.mapFeaturesReduceParams[0] * ppi; //mapFeatureRadius\n    var maxHitcount = renderer.config.mapFeaturesReduceParams[1]; //0.6614; //mapFeatureMaxOverlays\n\n    var screenLX = renderer.curSize[0];\n    var screenLY = renderer.curSize[1];\n    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp;\n    var feature, feature2, pp, pp2, o;\n    var drawAllLabels = renderer.drawAllLabels;\n\n    //get top features\n    var featureCache = renderer.gmap;\n    var featureCacheSize = renderer.gmapIndex;\n\n    var hcache = renderer.gmap2;\n    var hcacheSize = 1;\n    var hmap = renderer.gmap3;\n    var hmapSize = renderer.gmap3Size;\n    var hmap = renderer.gmap3;\n\n\n    var hmin = 10000;\n    var hmax = 0, h, r;\n\n    var divByDist = (renderer.config.mapFeaturesReduceFactor == 1);\n\n    if (divByDist) { // imp / dists\n        if (renderer.fmaxDist == Number.NEGATIVE_INFINITY || renderer.fminDist == Number.POSITIVE_INFINITY) {\n            return;\n        }\n\n        var ub = 1 - Math.log(renderer.fminDist) / Math.log(101);\n        var lb = -Math.log(renderer.fmaxDist) / Math.log(101); \n    }\n\n    //filter features and sort them by importance\n    for (i = 0, li = featureCacheSize; i < li; i++) {\n        feature = featureCache[i];\n        if (!feature) {\n            continue;\n        }\n\n        pp = feature[5];\n\n        if (divByDist) {\n            r = feature[0].reduce;\n            h = Math.round(-5000 + ( ( Math.log(r[1]+1) - Math.log(r[4]) ) / Math.log(101) - lb ) / ( ub-lb ) * 10000) + 5000;\n            r[5] = h; //for debug\n        } else {\n            h = Math.round(feature[0].reduce[1]);            \n        }\n\n        if (h < 0) h = 0;\n        if (h >= 10000) h = 9999;\n        if (h < hmin) hmin = h;\n        if (h > hmax) hmax = h;\n\n        hmap[h][hmapSize[h]++] = feature;\n    }\n\n    var j, lj;\n\n    for (i = hmax, li = hmin; i >= 0; i--) {\n\n        if (hmapSize[i] > 0) {\n            var features = hmap[i];\n\n            for (j = 0, lj = hmapSize[i]; j < lj; j++) {\n                feature = features[j];\n\n                pp = feature[5];\n\n                // check                \n\n                //render job\n                if (!drawAllLabels && feature[6]) { //no-overlap is always enabled\n                    pp = feature[5];\n                    o = feature[8];\n                    if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true)) {\n                        //hitCache[hitCacheSize] = feature;\n                    }\n                } else {\n                    if (feature[0].hysteresis) {\n                        renderer.jobHBuffer[feature[0].id] = feature[0];\n                    } else {\n                        renderer.drawnJobs++;\n                        draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, feature[0].lastSubJob, null);\n                    }\n                }\n            }\n\n            hmapSize[i] = 0;  //zero size\n        }\n    }\n}\n\n\nexport {processGMap, processGMap4, processGMap5};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gmap.js\n// module id = 159\n// module chunks = 0 1","\n\nvar GpuBBox = function(gpu, free) {\n    this.gl = gpu.gl;\n\n    var gl = this.gl;\n\n    if (gl == null)\n        return;\n\n    this.free = free;\n    this.vertexPositionBuffer = null;\n\n    //create vertex buffer\n    this.vertexPositionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);\n\n    var vertices;\n\n    if (free) {\n        vertices = [0,0,0, 0,0,1,\n            0,0,1, 0,0,2,\n            0,0,2, 0,0,3,\n            0,0,3, 0,0,0,\n\n            0,0,4, 0,0,5,\n            0,0,5, 0,0,6,\n            0,0,6, 0,0,7,\n            0,0,7, 0,0,4,\n\n            0,0,0, 0,0,4,\n            0,0,1, 0,0,5,\n            0,0,2, 0,0,6,\n            0,0,3, 0,0,7 ];\n    } else {\n        vertices = [0,0,0, 1,0,0,\n            1,0,0, 1,1,0,\n            1,1,0, 0,1,0,\n            0,1,0, 0,0,0,\n\n            0,0,1, 1,0,1,\n            1,0,1, 1,1,1,\n            1,1,1, 0,1,1,\n            0,1,1, 0,0,1,\n\n            0,0,0, 0,0,1,\n            1,0,0, 1,0,1,\n            1,1,0, 1,1,1,\n            0,1,0, 0,1,1 ];\n    }\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    this.vertexPositionBuffer.itemSize = 3;\n    this.vertexPositionBuffer.numItems = vertices.length / 3;\n\n    this.size = 4 + 4 * 8;\n    this.lines = this.vertexPositionBuffer.numItems / 3;\n};\n\n//destructor\nGpuBBox.prototype.kill = function() {\n    this.gl.deleteBuffer(this.vertexPositionBuffer);\n};\n\n// Draws the mesh, given the two vertex shader attributes locations.\nGpuBBox.prototype.draw = function(program, attrPosition) {\n    var gl = this.gl;\n    if (gl == null)\n        return;\n\n    var vertexPositionAttribute = program.getAttribute(attrPosition);\n\n    //bind vetex positions\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);\n    gl.vertexAttribPointer(vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    //draw lines\n    gl.drawArrays(gl.LINES, 0, this.vertexPositionBuffer.numItems);\n\n};\n\n\nexport default GpuBBox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/bbox.js\n// module id = 160\n// module chunks = 0 1","\n\nvar GpuDevice = function(renderer, div, size, keepFrameBuffer, antialias, aniso) {\n    this.renderer = renderer;\n    this.div = div;\n    this.canvas =  null;\n    this.curSize = size;\n    this.currentProgram = null;\n    this.maxAttributesCount = 8;\n    this.newAttributes = new Uint8Array(this.maxAttributesCount);\n    this.enabledAttributes = new Uint8Array(this.maxAttributesCount);\n    this.noTextures = false;\n    this.barycentricBuffer = null;\n   \n    //state of device when first initialized\n    this.defaultState = this.createState({blend:false, stencil:false, zequal: false, ztest:false, zwrite: false, culling:false}); \n    this.currentState = this.defaultState;\n    this.currentOffset = 0; //used fot direct offset\n\n    this.keepFrameBuffer = (keepFrameBuffer == null) ? false : keepFrameBuffer;\n    this.antialias = antialias ? true : false;\n    this.anisoLevel = aniso;\n};\n\n\nGpuDevice.prototype.init = function() {\n    var canvas = document.createElement('canvas');\n\n    if (canvas == null) {\n        //canvas not supported\n        return;\n    }\n\n    this.canvas = canvas;\n\n    canvas.width = this.curSize[0];\n    canvas.height = this.curSize[1];\n    canvas.style.display = 'block';\n\n    if (canvas.getContext == null) {\n        //canvas not supported\n        return;\n    }\n\n    canvas.addEventListener(\"webglcontextlost\", this.contextLost.bind(this), false);\n    canvas.addEventListener(\"webglcontextrestored\", this.contextRestored.bind(this), false);\n\n    var gl;\n\n    try {\n        gl = canvas.getContext('webgl', {preserveDrawingBuffer: this.keepFrameBuffer, antialias: this.antialias, stencil: true}) || canvas.getContext('experimental-webgl', {preserveDrawingBuffer: this.keepFrameBuffer});\n    } catch(e) {\n        //webgl not supported\n    }\n\n    if (!gl) {\n        //webgl not supported\n        return;\n    }\n\n    this.gl = gl;\n\n    gl.getExtension('OES_standard_derivatives');\n\n    this.anisoExt = (\n      gl.getExtension('EXT_texture_filter_anisotropic') ||\n      gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||\n      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')\n    );\n\n    if (this.anisoExt) {\n        this.maxAniso = gl.getParameter(this.anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\n        if (this.anisoLevel) {\n            if (this.anisoLevel == -1) {\n                this.anisoLevel = this.maxAniso;\n            } else {\n                this.anisoLevel = Math.min(this.anisoLevel, this.maxAniso);\n            }\n        }\n    } else {\n        this.maxAniso = 0;\n        this.anisoLevel = 0;\n    }\n\n    this.div.appendChild(canvas);\n\n    gl.viewportWidth = canvas.width;\n    gl.viewportHeight = canvas.height;\n\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    //gl.enable(gl.DEPTH_TEST);\n\n    //initial state\n    gl.disable(gl.BLEND);\n    gl.disable(gl.STENCIL_TEST);\n    gl.depthMask(false);\n    gl.enable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LESS);\n    gl.disable(gl.CULL_FACE);\n\n    //clear screen\n    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n};\n\n\nGpuDevice.prototype.kill = function() {\n    this.div.removeChild(this.canvas);\n    delete this.canvas;\n    this.canvas = null;\n};\n\n\nGpuDevice.prototype.contextLost = function(event) {\n    event.preventDefault();\n    this.renderer.core.contextLost = true;\n    this.renderer.core.callListener('gpu-context-lost', {});\n};\n\n\nGpuDevice.prototype.contextRestored = function() {\n    this.renderer.core.callListener('gpu-context-restored', {});\n};\n\n\nGpuDevice.prototype.resize = function(size, skipCanvas) {\n    this.curSize = size;\n    var canvas = this.canvas, gl = this.gl;\n\n    if (canvas != null && skipCanvas !== true) {\n        canvas.width = this.curSize[0];\n        canvas.height = this.curSize[1];\n    }\n\n    if (gl != null) {\n        gl.viewportWidth = canvas.width;\n        gl.viewportHeight = canvas.height;\n    }\n};\n\n\nGpuDevice.prototype.getCanvas = function() {\n    return this.canvas;\n};\n\n\nGpuDevice.prototype.setViewport = function() {\n    this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);\n};\n\n\nGpuDevice.prototype.clear = function(clearDepth, clearColor, color) {\n    if (color != null) {\n        this.gl.clearColor(color[0]/255, color[1]/255, color[2]/255, color[3]/255);\n    }\n    \n    this.gl.clear((clearColor ? this.gl.COLOR_BUFFER_BIT : 0) |\n                  (clearDepth ? this.gl.DEPTH_BUFFER_BIT : 0) );\n};\n\n\nGpuDevice.prototype.useProgram = function(program, attributes, nextSampler) {\n    if (this.currentProgram != program) {\n        this.gl.useProgram(program.program);\n        this.currentProgram = program;\n\n        program.setSampler('uSampler', 0);\n        \n        if (nextSampler) {\n            program.setSampler('uSampler2', 1);\n        }\n\n        var newAttributes = this.newAttributes;\n        var enabledAttributes = this.enabledAttributes; \n       \n        //reset new attributes list\n        for (var i = 0, li = newAttributes.length; i < li; i++){\n            newAttributes[i] = 0;\n        }\n        \n        for (i = 0, li = attributes.length; i < li; i++){\n            var index = program.getAttribute(attributes[i]);\n            \n            if (index != -1){\n                newAttributes[index] = 1;\n            }\n        }\n\n        //enable or disable current attributes according to new attributes list\n        for (i = 0, li = newAttributes.length; i < li; i++){\n            if (enabledAttributes[i] != newAttributes[i]) {\n                if (newAttributes[i]) {\n                    this.gl.enableVertexAttribArray(i);\n                    enabledAttributes[i] = 1;\n                } else {\n                    this.gl.disableVertexAttribArray(i);\n                    enabledAttributes[i] = 0;\n                }\n            }\n        }\n    }\n};\n\n\nGpuDevice.prototype.bindTexture = function(texture, id) {\n    if (!texture.loaded) {\n        return;\n    }\n\n    this.gl.activeTexture(id ? this.gl.TEXTURE1 : this.gl.TEXTURE0);\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texture);\n};\n\n\nGpuDevice.prototype.setFramebuffer = function(texture) {\n    if (texture != null) {\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.framebuffer);\n    } else {\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n    }\n};\n\n\nGpuDevice.prototype.createState = function(state) {\n    if (state.blend == null) { state.blend = false; }\n    if (state.stencil == null) { state.stencil = false; }\n    if (state.zwrite == null) { state.zwrite = true; }\n    if (state.ztest == null) { state.ztest = true; }\n    if (state.zequal == null) { state.zequal = false; }\n    if (state.culling == null) { state.culling = true; }\n\n    return state;\n};\n\n\nGpuDevice.prototype.setState = function(state) {\n    if (!state) {\n        return;\n    }\n\n    var gl = this.gl;\n    var currentState = this.currentState;\n\n    if (currentState.blend != state.blend) {\n        if (state.blend) {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        } else {\n            gl.disable(gl.BLEND);\n        }\n    }\n\n    if (currentState.stencil != state.stencil) {\n        if (state.stencil) {\n            gl.enable(gl.STENCIL_TEST);\n        } else {\n            gl.disable(gl.STENCIL_TEST);\n        }\n    }\n\n    if (currentState.zwrite != state.zwrite) {\n        if (state.zwrite) {\n            gl.depthMask(true);\n        } else {\n            gl.depthMask(false);\n        }\n    }\n\n    if (currentState.ztest != state.ztest) {\n        if (state.ztest != 0) {\n            gl.enable(gl.DEPTH_TEST);\n        } else {\n            gl.disable(gl.DEPTH_TEST);\n        }\n    }\n\n    if (currentState.zequal != state.zequal) {\n        if (state.zequal != 0) {\n            gl.depthFunc(gl.LEQUAL);\n        } else {\n            gl.depthFunc(gl.LESS);\n        }\n    }\n\n    if (currentState.culling != state.culling) {\n        if (state.culling) {\n            gl.enable(gl.CULL_FACE);\n        } else {\n            gl.disable(gl.CULL_FACE);\n        }\n    }\n\n    this.currentState = state;\n};\n\n\nexport default GpuDevice;\n\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/device.js\n// module id = 161\n// module chunks = 0 1","\nimport {vec3 as vec3_, mat4 as mat4_} from '../../utils/matrix';\nimport BBox_ from '../bbox';\nimport {math as math_} from '../../utils/math';\nimport {utils as utils_} from '../../utils/utils';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat4 = mat4_;\nvar BBox = BBox_;\nvar math = math_;\nvar utils = utils_;\n\n\nvar GpuGroup = function(id, bbox, origin, gpu, renderer) {\n    this.id = id;\n    this.bbox = null;\n    this.origin = origin || [0,0,0];\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.renderer = renderer;\n    this.jobs = [];\n    this.reduced = 0;\n    this.geometries = {};\n    this.subjob = null;\n    this.mv = new Float32Array(16);\n    this.mvp = new Float32Array(16);\n\n    if (bbox != null && bbox[0] != null && bbox[1] != null) {\n        this.bbox = new BBox(bbox[0][0], bbox[0][1], bbox[0][2], bbox[1][0], bbox[1][1], bbox[1][2]);\n    }\n\n    this.size = 0;\n    this.polygons = 0;\n};7\n\n//destructor\nGpuGroup.prototype.kill = function() {\n    for (var i = 0, li = this.jobs.length; i < li; i++) {\n        var job = this.jobs[i]; \n\n        switch(job.type) {\n        case VTS_JOB_FLAT_LINE:\n            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);\n            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);\n            break;\n\n        case VTS_JOB_FLAT_TLINE:\n        case VTS_JOB_FLAT_RLINE:\n        case VTS_JOB_PIXEL_LINE:\n        case VTS_JOB_PIXEL_TLINE:\n            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);\n            if (job.vertexNormalBuffer) this.gl.deleteBuffer(job.vertexNormalBuffer);\n            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);\n            break;\n\n        case VTS_JOB_LINE_LABEL:\n            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);\n            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);\n            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);\n            break;\n\n        case VTS_JOB_ICON:\n        case VTS_JOB_LABEL:\n            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);\n            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);\n            if (job.vertexOriginBuffer) this.gl.deleteBuffer(job.vertexOriginBuffer);\n            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);\n            break;\n        }\n    }\n\n    //remove geometries\n    for (var key in this.geometries) {\n        var geometries = this.geometries[key];\n        var globalGeometry = this.renderer.geometries[key];\n        this.geometries[key] = null;\n\n        //remove geometry from glbal stack\n        for (i = 0, li = geometries.length; i < li; i++) {\n            if (geometries[i] == globalGeometry) {\n                this.renderer.geometries[key] = null;\n            }\n        }\n    }\n};\n\n\nGpuGroup.prototype.size = function() {\n    return this.size;\n};\n\n\nGpuGroup.prototype.getZbufferOffset = function() {\n    return this.size;\n};\n\nGpuGroup.prototype.addGeometry = function(data) {\n    var id = data['id'];\n\n    if (!this.geometries[id]) {\n        this.geometries[id] = [data];\n    } else {\n        this.geometries[id].push(data);\n    }\n\n    this.renderer.geometries[id] = data;\n};\n\nGpuGroup.prototype.convertColor = function(c) {\n    var f = 1.0/255;\n    return [c[0]*f, c[1]*f, c[2]*f, c[3]*f];\n};\n\nGpuGroup.prototype.addLineJob = function(data) {\n    var gl = this.gl;\n\n    var vertices = data.vertexBuffer;\n\n    var job = {};\n    job.type = VTS_JOB_FLAT_LINE;\n    job.program = this.renderer.progLine;\n    job.color = this.convertColor(data['color']);\n    job.zIndex = data['z-index'] + 256;\n    job.clickEvent = data['click-event'];\n    job.hoverEvent = data['hover-event'];\n    job.enterEvent = data['enter-event'];\n    job.leaveEvent = data['leave-event'];\n    job.advancedHit = data['advancedHit'];\n    job.hitable = data['hitable'];\n    job.eventInfo = data['eventInfo'];\n    job.state = data['state'];\n    job.center = data['center'];\n    job.lod = data['lod'];\n    job.lineWidth = data['line-width'];\n    job.zbufferOffset = data['zbuffer-offset'];\n    job.reduced = false;\n    job.ready = true;\n\n    if (!job.program.isReady()) {\n        return;\n    }\n\n    if (job.advancedHit) {\n        job.program2 = this.renderer.progELine;\n\n        if (!job.program2.isReady()) {\n            return;\n        }\n    }\n\n    //create vertex buffer\n    job.vertexPositionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n    job.vertexPositionBuffer.itemSize = 3;\n    job.vertexPositionBuffer.numItems = vertices.length / 3;\n\n    if (job.advancedHit) {\n        job.program = this.renderer.progLine;\n\n        var elements = data.elementBuffer;\n\n        job.vertexElementBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);\n        job.vertexElementBuffer.itemSize = 1;\n        job.vertexElementBuffer.numItems = elements.length;\n    }\n\n    this.jobs.push(job);\n\n    this.size += vertices.length * 4;\n    this.polygons += vertices.length / (3 * 3);\n};\n\n\nGpuGroup.prototype.addExtentedLineJob = function(data) {\n    var gl = this.gl;\n\n    var vertices = data.vertexBuffer;\n    var normals = data.normalBuffer;\n\n    var job = {};\n    job.type = data['type'];\n\n    \n    switch(job.type) {\n    case VTS_WORKER_TYPE_FLAT_LINE:  job.type = VTS_JOB_FLAT_TLINE;  break;\n    case VTS_WORKER_TYPE_FLAT_RLINE:  job.type = VTS_JOB_FLAT_RLINE;  break;\n    case VTS_WORKER_TYPE_PIXEL_LINE:  job.type = VTS_JOB_PIXEL_LINE;  break;\n    case VTS_WORKER_TYPE_PIXEL_TLINE: job.type = VTS_JOB_PIXEL_TLINE; break;\n    }\n\n    job.color = this.convertColor(data['color']);\n    job.zIndex = data['z-index'] + 256;\n    job.clickEvent = data['click-event'];\n    job.hoverEvent = data['hover-event'];\n    job.hitable = data['hitable'];\n    job.eventInfo = data['eventInfo'];\n    job.enterEvent = data['enter-event'];\n    job.leaveEvent = data['leave-event'];\n    job.advancedHit = data['advancedHit'];\n    job.widthByRatio = data['width-units'] == 'ratio',\n    job.state = data['state'];\n    job.center = data['center'];\n    job.lod = data['lod'];\n    job.lineWidth = data['line-width'];\n    job.zbufferOffset = data['zbuffer-offset'];\n    job.reduced = false;\n    job.ready = true;\n\n    if (data['texture'] != null) {\n        var texture = data['texture'];\n        var bitmap = texture[0];\n        job.texture = [this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false),\n            texture[1], texture[2], texture[3], texture[4]];\n        var background = this.convertColor(data['background']);\n\n        if (background[3] != 0) {\n            job.background = background;\n        }\n    }\n\n    switch(job.type) {\n    case VTS_JOB_FLAT_TLINE:   job.program = (background[3] != 0) ? this.renderer.progTBLine : this.renderer.progTLine;  break;\n    case VTS_JOB_FLAT_RLINE:   job.program = this.renderer.progRLine;  break;\n    case VTS_JOB_PIXEL_LINE:   job.program = this.renderer.progLine3;  break;\n    case VTS_JOB_PIXEL_TLINE:  job.program = (background[3] != 0) ? this.renderer.progTPBLine : this.renderer.progTPLine; break;\n    }\n\n    if (!job.program.isReady()) {\n        return;\n    }\n\n    if (job.advancedHit) {\n        switch(job.type) {\n        case VTS_JOB_FLAT_TLINE:   job.program2 = this.renderer.progETLine;  break;\n        case VTS_JOB_FLAT_RLINE:   job.program2 = this.renderer.progERLine;  break;\n        case VTS_JOB_PIXEL_LINE:   job.program2 = this.renderer.progELine3;  break;\n        case VTS_JOB_PIXEL_TLINE:  job.program2 = this.renderer.progETPLine; break;\n        }\n\n        if (!job.program2.isReady()) {\n            return;\n        }\n    }\n\n    //create vertex buffer\n    job.vertexPositionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n    job.vertexPositionBuffer.itemSize = 4;\n    job.vertexPositionBuffer.numItems = vertices.length / 4;\n\n    //create normal buffer\n    job.vertexNormalBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);\n    job.vertexNormalBuffer.itemSize = 4;\n    job.vertexNormalBuffer.numItems = normals.length / 4;\n\n    if (job.advancedHit) {\n        var elements = data.elementBuffer;\n\n        job.vertexElementBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);\n        job.vertexElementBuffer.itemSize = 1;\n        job.vertexElementBuffer.numItems = elements.length;\n    }\n\n    this.jobs.push(job);\n\n    this.size += vertices.length * 4 + normals.length * 4;\n    this.polygons += vertices.length / (4 * 3);\n};\n\n\nGpuGroup.prototype.addLineLabelJob = function(data) {\n    var gl = this.gl;\n\n    var vertices = data.vertexBuffer;\n    var texcoords = data.texcoordsBuffer;\n\n    var job = {};\n    job.type = VTS_JOB_LINE_LABEL;\n    job.program = this.renderer.progText;\n    job.color = this.convertColor(data['color']);\n    job.color2 = this.convertColor(data['color2']);\n    job.outline = data['outline'];\n    job.zIndex = data['z-index'] + 256;\n    job.clickEvent = data['click-event'];\n    job.hoverEvent = data['hover-event'];\n    job.enterEvent = data['enter-event'];\n    job.leaveEvent = data['leave-event'];\n    job.hitable = data['hitable'];\n    job.eventInfo = data['eventInfo'];\n    job.state = data['state'];\n    job.center = data['center'];\n    job.lod = data['lod'];\n    job.zbufferOffset = data['zbuffer-offset'];\n    job.reduced = false;\n    job.ready = true;\n\n    job.files = data['files'] || [];\n    var fonts = data['fonts'] || ['#default'];\n    job.fonts = fonts;\n\n    for (var i = 0, li = fonts.length; i < li; i++) {\n        fonts[i] = this.renderer.fonts[fonts[i]];\n    }\n\n    job.program = this.renderer.progText2;\n\n    if (!job.program.isReady()) {\n        return;\n    }\n\n    //create vertex buffer\n    job.vertexPositionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n    job.vertexPositionBuffer.itemSize = 4;\n    job.vertexPositionBuffer.numItems = vertices.length / 4;\n\n    //create normal buffer\n    job.vertexTexcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);\n    job.vertexTexcoordBuffer.itemSize = 4;\n    job.vertexTexcoordBuffer.numItems = texcoords.length / 4;\n\n    this.jobs.push(job);\n\n    this.size += vertices.length * 4 + texcoords.length * 4;\n    this.polygons += vertices.length / (4 * 3);\n};\n\n\nGpuGroup.prototype.addIconJob = function(data, label, tile) {\n    var gl = this.gl;\n\n    var vertices = data.vertexBuffer;\n    var texcoords = data.texcoordsBuffer;\n    var origins = data.originBuffer;\n    var singleBuffer = data.singleBuffer;\n    var s = data['stick'];\n    var f = 1.0/255;\n\n    var job = { tile: tile };\n    job.type = label ? VTS_JOB_LABEL : VTS_JOB_ICON;\n    job.program = this.renderer.progIcon;\n    job.color = this.convertColor(data['color']);\n    job.zIndex = data['z-index'] + 256;\n    job.visibility = data['visibility'];\n    job.culling = data['culling'];\n    job.clickEvent = data['click-event'];\n    job.hoverEvent = data['hover-event'];\n    job.enterEvent = data['enter-event'];\n    job.leaveEvent = data['leave-event'];\n    job.hitable = data['hitable'];\n    job.eventInfo = data['eventInfo'];\n    job.state = data['state'];\n    job.center = data['center'];\n    job.stick = [s[0], s[1], s[2], s[3]*f, s[4]*f, s[5]*f, s[6]*f, s[7]];\n    job.lod = data['lod'];\n    job.zbufferOffset = data['zbuffer-offset'];\n    job.hysteresis = data['hysteresis'];\n    job.noOverlap = data['noOverlap'];\n    job.id = job.hysteresis ? job.hysteresis[2] : null;\n    job.reduced = false;\n    job.ready = true;\n    job.reduce = data['reduce'];\n\n    //console.log('id: ' + job.eventInfo['#id']);\n\n    if (job.reduce) {\n        switch(job.reduce[0]) {\n            case 'tilt':       job.reduce[0] = 1; break;\n            case 'tilt-cos':   job.reduce[0] = 2; break;\n            case 'tilt-cos2':  job.reduce[0] = 3; break;\n            case 'scr-count':  job.reduce[0] = 4; break;\n            case 'scr-count2': job.reduce[0] = 5; this.renderer.drawnGeodataTilesUsed = true; break;\n            case 'scr-count3': job.reduce[0] = 6; this.renderer.drawnGeodataTilesUsed = true; break;\n            case 'scr-count4': job.reduce[0] = 7; break;\n            case 'scr-count5': job.reduce[0] = 8; break;\n            case 'scr-count6': job.reduce[0] = 9; break;\n        }\n\n        job.reduce[5] = 0; //zero debug value\n\n        if (job.reduce[0] == 7 || job.reduce[0] == 8 || job.reduce[0] == 9) {\n            job.reduce[2] = Math.abs(job.reduce[1]); //copy prominence for prom / dist support\n            //job.reduce[1] = Math.log(job.reduce[2]) * VTS_IMPORATANCE_INV_LOG;\n            //job.reduce[1] = Math.log(job.reduce[2]) / Math.log(1.0017);\n\n            if (this.renderer.config.mapFeaturesReduceFactor == 1) { // prom / dists\n                job.reduce[1] = job.reduce[2];\n            } else {\n                job.reduce[1] = Math.floor((Math.log(job.reduce[2] * 500) / Math.log(1.0017)) + 5000);\n            }\n        }\n    }\n\n    if (!job.program.isReady()) {\n        return;\n    }\n\n    if (label !== true) {\n        var icon = data['icon'];\n        job.texture = this.renderer.getBitmap(null, icon['filter'] || 'linear', icon['tiled'] || false, icon['hash'], true);\n        job.files = [];\n    } else {\n        job.color2 = this.convertColor(data['color2']);\n        job.outline = data['outline'];\n        job.size = data['size'];\n        job.origin = data['origin'];\n        job.files = data['files'] || [];\n        job.index = data['index'] || 0;\n        var fonts = data['fonts'] || ['#default'];\n        job.fonts = fonts;\n        job.gamma = [job.outline[2] * 1.4142 / job.size, job.outline[3] * 1.4142 / job.size];\n\n        if (job.origin) {\n            job.origin = new Float32Array(job.origin);\n        }\n\n        for (var i = 0, li = fonts.length; i < li; i++) {\n            fonts[i] = this.renderer.fonts[fonts[i]];\n        }\n\n        job.program = this.renderer.progIcon2;\n    }\n\n    if (job.visibility != null && !Array.isArray(job.visibility)) {\n        job.visibility = [job.visibility];\n    }\n\n    if (singleBuffer) {\n        job.singleBuffer = singleBuffer;\n        this.polygons += 2;\n\n    } else {\n        //create vertex buffer\n        job.vertexPositionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n        job.vertexPositionBuffer.itemSize = 4;\n        job.vertexPositionBuffer.numItems = vertices.length / 4;\n\n        //create normal buffer\n        job.vertexTexcoordBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);\n        job.vertexTexcoordBuffer.itemSize = 4;\n        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;\n\n        //create origin buffer\n        job.vertexOriginBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, origins, gl.STATIC_DRAW);\n        job.vertexOriginBuffer.itemSize = 3;\n        job.vertexOriginBuffer.numItems = origins.length / 3;\n\n        this.size += job.vertexPositionBuffer.numItems * 4 +\n                      job.vertexOriginBuffer.numItems * 4 +\n                      job.vertexTexcoordBuffer.numItems * 4;\n        this.polygons += job.vertexPositionBuffer.numItems / (4 * 3);\n    }\n\n\n    if (this.subjobs) {\n        this.subjobs.push(job);\n    } else {\n        if (this.vsjobs) {\n            this.vsjobs.push(job);\n        } else {\n            this.jobs.push(job);\n        }\n    }\n\n};\n\n\nGpuGroup.prototype.addPack = function(data) {\n    if (!this.subjobs.length) {\n        this.subjobs = null;\n        return;\n    }\n\n    var job = {\n        type : VTS_JOB_PACK,\n        subjobs: this.subjobs,\n        culling : 180,\n        zIndex : 0,\n        ready : true\n    };\n\n    //extract no overlap, remove it form subjobs\n    for (var i = 0, li = job.subjobs.length; i < li; i++) {\n        var subjob = job.subjobs[i];\n\n        if (subjob.noOverlap) {\n            \n            if (!job.noOverlap) {\n                job.noOverlap = subjob.noOverlap;\n            } else {\n                var o = job.noOverlap;\n                var o2 = subjob.noOverlap;\n\n                if (o2[0] < o[0]) o[0] = o2[0];\n                if (o2[1] < o[1]) o[1] = o2[1];\n                if (o2[2] > o[2]) o[2] = o2[2];\n                if (o2[3] > o[3]) o[3] = o2[3];\n            }\n\n            subjob.noOverlap = null;\n        }\n\n        if (subjob.culling <= job.culling) {\n            job.culling = subjob.culling;\n            subjob.culling = 180;\n        }\n\n        if (subjob.visibility) {\n            job.visibility = subjob.visibility;\n            subjob.visibility = null;\n        }\n\n        if (subjob.stick) {\n            job.stick = subjob.stick;\n            subjob.stick = [0,0,0,255,255,255,255,0];\n        }\n\n        if (subjob.zIndex > job.zIndex) {\n            job.zIndex = subjob.zIndex;\n        }\n\n        if (subjob.center) {\n            job.center = subjob.center;\n        }\n\n        job.eventInfo = subjob.eventInfo;\n        job.reduce = subjob.reduce;\n\n        job.hysteresis = subjob.hysteresis;\n        job.id = subjob.id;\n    }\n\n    if (this.vsjobs) {\n        this.vsjobs.push(job);\n    } else {\n        this.jobs.push(job);\n    }\n    \n    this.subjobs = null;\n};\n\n\nGpuGroup.prototype.addVSPoint = function(data, tile){\n    var job = { tile: tile };\n    job.type = VTS_JOB_VSPOINT;\n    job.zIndex = data['z-index'] + 256;\n    job.visibility = data['visibility'];\n    job.culling = data['culling'];\n    job.hitable = false;\n    job.eventInfo = data['eventInfo'];\n    job.state = data['state'];\n    job.center = data['center'];\n    job.lod = data['lod'];\n    job.hysteresis = data['hysteresis'];\n    job.id = job.hysteresis ? job.hysteresis[2] : null;\n    job.reduced = false;\n    job.ready = true;\n    job.reduce = data['reduce'];\n    job.vswitch = [];\n\n    this.vsjob = job;\n};\n\n\nGpuGroup.prototype.storeVSJobs = function(data){\n    this.vsjob.vswitch.push([data.viewExtent, this.vsjobs]);\n    this.vsjobs = [];\n};\n\n\nGpuGroup.prototype.addVSwitch = function(){\n    if (this.vsjob) {\n        this.jobs.push(this.vsjob);\n    }\n\n    this.vsjobs = null;\n};\n\n\nGpuGroup.prototype.copyBuffer = function(buffer, source, index) {\n    var tmp = new Uint8Array(buffer.buffer);\n    tmp.set(new Uint8Array(source.buffer, index, buffer.byteLength));\n    return buffer;\n};\n\n\nGpuGroup.prototype.addRenderJob2 = function(buffer, index, tile) {\n    var data, str, length, tmp;\n    var view = new DataView(buffer.buffer);\n    var type = buffer[index]; index += 1;\n\n    if (type != VTS_WORKER_TYPE_PACK_BEGIN && type != VTS_WORKER_TYPE_PACK_END && \n        type != VTS_WORKER_TYPE_VSWITCH_BEGIN && type != VTS_WORKER_TYPE_VSWITCH_END && type != VTS_WORKER_TYPE_VSWITCH_STORE) {\n\n        length = view.getUint32(index); index += 4;\n        str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;\n        data = JSON.parse(str);\n    }\n\n    switch(type) {\n        case VTS_WORKER_TYPE_FLAT_LINE:\n            data.type = type;\n            length = view.getUint32(index); index += 4;\n            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;\n\n            if (data['advancedHit']) {\n                length = view.getUint32(index); index += 4;\n                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;\n            }\n\n            this.addLineJob(data);\n            break;\n\n        case VTS_WORKER_TYPE_FLAT_TLINE:\n        case VTS_WORKER_TYPE_FLAT_RLINE:\n        case VTS_WORKER_TYPE_PIXEL_LINE:\n        case VTS_WORKER_TYPE_PIXEL_TLINE:\n            data.type = type;\n            length = view.getUint32(index); index += 4;\n            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.normalBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.normalBuffer.byteLength;\n\n            if (data['advancedHit']) {\n                length = view.getUint32(index); index += 4;\n                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;\n            }\n\n            this.addExtentedLineJob(data);\n            break;\n\n        case VTS_WORKER_TYPE_LINE_LABEL:\n\n            length = view.getUint32(index); index += 4;\n            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;\n            this.addLineLabelJob(data);\n            break;\n\n        case VTS_WORKER_TYPE_ICON:\n        case VTS_WORKER_TYPE_LABEL:\n\n            length = view.getUint32(index); index += 4;\n            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;\n            this.addIconJob(data, (type == VTS_WORKER_TYPE_LABEL), tile);\n            break;\n\n        case VTS_WORKER_TYPE_ICON2:\n        case VTS_WORKER_TYPE_LABEL2:\n\n            length = view.getUint32(index); index += 4;\n            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.originBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.originBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;\n            this.addIconJob(data, (type == VTS_WORKER_TYPE_LABEL2), tile);\n            break;\n\n        case VTS_WORKER_TYPE_POINT_GEOMETRY:\n        case VTS_WORKER_TYPE_LINE_GEOMETRY:\n\n            length = view.getUint32(index); index += 4;\n            data.geometryBuffer = this.copyBuffer(new Float64Array(length), buffer, index); index += data.originBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            data.indicesBuffer = this.copyBuffer(new Uint32Array(length), buffer, index); index += data.indicesBuffer.byteLength;\n            length = view.getUint32(index); index += 4;\n            this.addGeometry(data);\n            break;\n\n        case VTS_WORKER_TYPE_PACK_BEGIN:\n            this.subjobs = []; index += 4;\n            break;\n\n        case VTS_WORKER_TYPE_PACK_END:\n            this.addPack(); index += 4;\n            break;\n\n        case VTS_WORKER_TYPE_VSPOINT:\n            this.addVSPoint(data, tile);\n            break;\n\n        case VTS_WORKER_TYPE_VSWITCH_BEGIN:\n            this.vsjobs = []; this.vsjob = null; index += 4;\n            break;\n\n        case VTS_WORKER_TYPE_VSWITCH_END:\n            this.addVSwitch(); index += 4;\n            break;\n\n        case VTS_WORKER_TYPE_VSWITCH_STORE:\n            data = { viewExtent: view.getUint32(index) }; index += 4;\n            this.storeVSJobs(data);\n            break;\n    }\n\n    return index;\n};\n\n\nGpuGroup.prototype.addRenderJob = function(data, tile) {\n    switch(data['type']) {\n    case 'flat-line':     this.addLineJob(data); break;\n    case 'flat-tline':\n    case 'flat-rline':\n    case 'pixel-line':\n    case 'pixel-tline':    this.addExtentedLineJob(data); break;\n    case 'line-label':     this.addLineLabelJob(data); break;\n    case 'icon':           this.addIconJob(data); break;\n    case 'label':          this.addIconJob(data, true, tile); break;\n    case 'point-geometry': this.addGeometry(data); break;\n    case 'line-geometry':  this.addGeometry(data); break;\n    case 'pack-begin':     this.subjobs = []; break;\n    case 'pack-end':       this.addPack(); break;\n    case 'vspoint':        this.addVSPoint(data, tile); break;\n    case 'vswitch-begin':  this.vsjobs = []; this.vsjob = null; break;\n    case 'vswitch-store':  this.storeVSJobs(data); break;\n    case 'vswitch-end':    this.addVSwitch(); break;\n    }\n};\n\n\nGpuGroup.prototype.draw = function(mv, mvp, applyOrigin, tiltAngle, texelSize) {\n    if (this.id != null) {\n        if (this.renderer.layerGroupVisible[this.id] === false) {\n            return;\n        }\n    }\n\n    var renderer = this.renderer;\n    var renderCounter = [[renderer.geoRenderCounter, mv, mvp, this]];\n\n    if (applyOrigin) {\n        var mvp2 = mat4.create();\n        var mv2 = mat4.create();\n        var pos = this.renderer.position;\n\n        /*\n        var transform = this.renderer.layerGroupTransform[this.id];\n\n        if (transform != null) {\n            origin = transform[1];\n            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];\n            mat4.multiply(math.translationMatrix(origin[0], origin[1], origin[2]), transform[0], mv2);\n            mat4.multiply(mv, mv2, mv2);\n        } else {*/\n            var origin = this.origin;\n            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];\n            mat4.multiply(mv, math.translationMatrix(origin[0], origin[1], origin[2]), mv2);\n        /*}*/\n\n        mat4.multiply(mvp, mv2, mvp2);\n        mv = mv2;\n        mvp = mvp2;\n    }\n\n    var cameraPos = renderer.cameraPosition;\n    var jobZBuffer = renderer.jobZBuffer;\n    var jobZBufferSize = renderer.jobZBufferSize;\n    var jobZBuffer2 = renderer.jobZBuffer2;\n    var jobZBuffer2Size = renderer.jobZBuffer2Size;\n\n    var onlyHitable = renderer.onlyHitLayers;\n\n    for (var i = 0, li = this.jobs.length; i < li; i++) {\n        var job = this.jobs[i];\n\n        if ((job.type == VTS_JOB_ICON || job.type == VTS_JOB_LABEL) && job.visibility > 0) {\n            var center = job.center;\n            if (vec3.length([center[0]-cameraPos[0],\n                center[1]-cameraPos[1],\n                center[2]-cameraPos[2]]) > job.visibility) {\n                continue;\n            }\n        }\n\n        if (onlyHitable && !job.hitable) {\n            continue;\n        }\n\n        job.mv = mv;\n        job.mvp = mvp;\n        job.renderCounter = renderCounter;\n        job.tiltAngle = tiltAngle;\n        job.texelSize = texelSize;\n\n        var zIndex = job.zIndex;\n\n        jobZBuffer[zIndex][jobZBufferSize[zIndex]] = job;\n        jobZBufferSize[zIndex]++;\n    }\n};\n\n\nexport default GpuGroup;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/group.js\n// module id = 162\n// module chunks = 0 1","\nvar GpuPixelLine3 = function(gpu, core, lines, maxLines, joins, joinSides) {\n    this.bbox = null;\n    this.gpu = gpu;\n    this.gl = gpu.gl;\n    this.core = core;\n\n    var gl = this.gl;\n\n    if (gl == null){\n        return;\n    }\n\n    this.vertices = [];\n    this.normals = [];\n    this.vertexBuffer = null;\n    this.lines = lines;\n    this.joins = joins;\n    this.joinSides = joinSides;\n    this.maxLines = maxLines;\n\n    this.init();\n};\n\n//destructor\nGpuPixelLine3.prototype.kill = function() {\n    this.gl.deleteBuffer(this.vertexBuffer);\n};\n\n\nGpuPixelLine3.prototype.init = function() {\n    var i;\n    if (this.lines) {\n        if (this.joins) {\n            this.addCircle(0, this.joinSides);\n        }\n\n        for (i = 0; i < this.maxLines; i++) {\n            this.addLine(i, i+1);\n\n            if (this.joins) {\n                this.addCircle(i+1, this.joinSides);\n            }\n        }\n    } else if (this.joins) {\n        for (i = 0; i <= this.maxLines; i++) {\n            this.addCircle(i, this.joinSides);\n        }\n    }\n\n    this.compile();\n};\n\n//add line to vertices buffer\nGpuPixelLine3.prototype.addLine = function(i1, i2) {\n    var index = this.vertices.length;\n\n    //first polygon\n    this.vertices[index] = i1;\n    this.vertices[index+1] = i2;\n    this.vertices[index+2] = 1;\n\n    this.vertices[index+3] = i1;\n    this.vertices[index+4] = i2;\n    this.vertices[index+5] = -1;\n\n    this.vertices[index+6] = i2;\n    this.vertices[index+7] = i1;\n    this.vertices[index+8] = 1;\n\n    //next polygon\n    this.vertices[index+9] = i1;\n    this.vertices[index+10] = i2;\n    this.vertices[index+11] = 1;\n\n    this.vertices[index+12] = i2;\n    this.vertices[index+13] = i1;\n    this.vertices[index+14] = 1;\n\n    this.vertices[index+15] = i2;\n    this.vertices[index+16] = i1;\n    this.vertices[index+17] = -1;\n\n    this.polygons += 2;\n};\n\n//add circle to vertices buffer\nGpuPixelLine3.prototype.addCircle = function(i1, sides) {\n    var index = this.vertices.length;\n    var step = (2.0*Math.PI) / sides;\n\n    for (var i = 0; i < sides; i++) {\n        this.vertices[index] = i1;\n        this.vertices[index+1] = -1;\n        this.vertices[index+2] = 0;\n\n        this.vertices[index+3] = i1;\n        this.vertices[index+4] = -2;\n        this.vertices[index+5] = step * i;\n\n        this.vertices[index+6] = i1;\n        this.vertices[index+7] = -2;\n        this.vertices[index+8] = step * (i+1);\n\n        index += 9;\n    }\n\n    this.polygons += sides;\n};\n\n//compile content of vertices buffer into gpu buffer\nGpuPixelLine3.prototype.compile = function() {\n    var gl = this.gl;\n\n    //create vertex buffer\n    this.vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\n    this.vertexBuffer.itemSize = 3;\n    this.vertexBuffer.numItems = this.vertices.length / 3;\n\n    this.size = this.vertexBuffer.numItems * 3 * 4 * 2;\n    this.polygons = this.vertexBuffer.numItems / 3;\n};\n\n// Draws the mesh, given the two vertex shader attributes locations.\nGpuPixelLine3.prototype.draw = function(program, attrPosition, points) {\n    var gl = this.gl;\n    if (gl == null || this.vertexBuffer == null || points > this.maxLines){\n        return;\n    }\n\n    var vertexPositionAttribute = program.getAttribute(attrPosition);\n\n    //bind vetex positions\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.vertexAttribPointer(vertexPositionAttribute, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\n    var size = 0;\n\n    if (this.lines) {\n        size += ((points-1) * 3 * 2);\n    }\n\n    if (this.joins) {\n        size += points * (this.joinSides * 3);\n    }\n\n    //draw polygons\n    gl.drawArrays(gl.TRIANGLES, 0, size);\n};\n\n// Returns GPU RAM used, in bytes.\nGpuPixelLine3.prototype.size = function(){ return this.size; };\n\n\nGpuPixelLine3.prototype.bbox = function(){ return this.bbox; };\n\n\nGpuPixelLine3.prototype.getPolygons = function(){ return this.polygons; };\n\n\nexport default GpuPixelLine3;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/gpu/pixel-line3.js\n// module id = 163\n// module chunks = 0 1","\nimport RendererGeometry_ from './geometry';\nimport GpuBBox_ from './gpu/bbox';\nimport GpuFont_ from './gpu/font';\nimport GpuMesh_ from './gpu/mesh';\nimport GpuPixelLine3_ from './gpu/pixel-line3';\nimport GpuProgram_ from './gpu/program';\nimport GpuShaders_ from './gpu/shaders';\nimport GpuTexture_ from './gpu/texture';\n\n//get rid of compiler mess\nvar RendererGeometry = RendererGeometry_;\nvar GpuBBox = GpuBBox_;\nvar GpuFont = GpuFont_;\nvar GpuMesh = GpuMesh_;\nvar GpuPixelLine3 = GpuPixelLine3_;\nvar GpuProgram = GpuProgram_;\nvar GpuShaders = GpuShaders_;\nvar GpuTexture = GpuTexture_;\n\n\nvar RendererInit = function(renderer) {\n    this.renderer = renderer;\n    this.core = renderer.core;\n    this.gpu = renderer.gpu;\n\n    //renderer.font = new GpuFont(this.gpu, this.core);\n    //renderer.fonts['#default'] = renderer.font;\n    //renderer.font = new GpuFont(this.gpu, this.core, null, null, './allinone.fnt');\n\n    this.initShaders();\n    this.initHeightmap();\n    this.initSkydome();\n    this.initHitmap();\n    this.initTextMap();\n    this.initImage();\n    this.initTestMap();\n    this.initBBox();\n    this.initLines();\n    this.initBaricentricBuffer();\n};\n\n\nRendererInit.prototype.initShaders = function() {\n    var shaders = GpuShaders;\n    var renderer = this.renderer;\n    var gpu = this.gpu;\n\n    renderer.progTile = new GpuProgram(gpu, shaders.tileVertexShader, shaders.tileFragmentShader);\n    renderer.progTile2 = new GpuProgram(gpu, '#define externalTex\\n' + shaders.tileVertexShader, '#define externalTex\\n' + shaders.tileFragmentShader.replace('__FILTER__', ''));\n    renderer.progTile3 = new GpuProgram(gpu, '#define externalTex\\n' + shaders.tileVertexShader, '#define externalTex\\n#define mask\\n' + shaders.tileFragmentShader.replace('__FILTER__', ''));\n    renderer.progFogTile = new GpuProgram(gpu, '#define onlyFog\\n' + shaders.tileVertexShader, '#define onlyFog\\n' + shaders.tileFragmentShader);\n\n    renderer.progShadedTile = new GpuProgram(gpu, shaders.tileTShadedVertexShader, shaders.tileShadedFragmentShader);\n    renderer.progTShadedTile = new GpuProgram(gpu, shaders.tileTShadedVertexShader, shaders.tileTShadedFragmentShader);\n    renderer.progWireframeTile = new GpuProgram(gpu, shaders.tileWireframeVertexShader, shaders.tileWireframeFragmentShader);\n    renderer.progWireframeTile2 = new GpuProgram(gpu, shaders.tileWireframeVertexShader, shaders.tileWireframe2FragmentShader);\n    renderer.progWireframeTile3 = new GpuProgram(gpu, shaders.tileWireframe3VertexShader, shaders.tileWireframeFragmentShader);\n    renderer.progFlatShadeTile = new GpuProgram(gpu, shaders.tileFlatShadeVertexShader, shaders.tileFlatShadeFragmentShader);\n    renderer.progHeightmap = new GpuProgram(gpu, shaders.heightmapVertexShader, shaders.heightmapFragmentShader);\n    renderer.progPlane = new GpuProgram(gpu, shaders.planeVertexShader, shaders.planeFragmentShader); //flat\n    renderer.progPlane2 = new GpuProgram(gpu, shaders.planeVertex2Shader, shaders.planeFragment2Shader); //poles\n    renderer.progPlane3 = new GpuProgram(gpu, shaders.planeVertex3Shader, shaders.planeFragmentShader); // grid         \n\n    renderer.progSkydome = new GpuProgram(gpu, shaders.skydomeVertexShader, shaders.skydomeFragmentShader);\n    renderer.progStardome = new GpuProgram(gpu, shaders.skydomeVertexShader, shaders.stardomeFragmentShader);\n    \n    renderer.progAtmo2 = new GpuProgram(gpu, shaders.atmoVertexShader, shaders.atmoFragmentShader);\n    renderer.progAtmo = new GpuProgram(gpu, shaders.atmoVertexShader3, shaders.atmoFragmentShader3);\n\n    renderer.progDepthTile = new GpuProgram(gpu, shaders.tileDepthVertexShader, shaders.tileDepthFragmentShader);\n    renderer.progDepthHeightmap = new GpuProgram(gpu, shaders.heightmapDepthVertexShader, shaders.heightmapDepthFragmentShader);\n\n    renderer.progBBox = new GpuProgram(gpu, shaders.bboxVertexShader, shaders.bboxFragmentShader);\n    renderer.progBBox2 = new GpuProgram(gpu, shaders.bbox2VertexShader, shaders.bboxFragmentShader);\n\n    renderer.progLine = new GpuProgram(gpu, shaders.lineVertexShader, shaders.lineFragmentShader); //line\n    renderer.progELine = new GpuProgram(gpu, shaders.elineVertexShader, shaders.elineFragmentShader); //line elements \n    renderer.progLine3 = new GpuProgram(gpu, shaders.line3VertexShader, shaders.lineFragmentShader); //pixel line\n    renderer.progELine3 = new GpuProgram(gpu, shaders.eline3VertexShader, shaders.elineFragmentShader); //pixel line elements\n    renderer.progLine4 = new GpuProgram(gpu, shaders.line4VertexShader, shaders.lineFragmentShader); //direct linestring pixel line\n    renderer.progRLine = new GpuProgram(gpu, shaders.rlineVertexShader, shaders.lineFragmentShader); //dynamic width line\n    renderer.progERLine = new GpuProgram(gpu, shaders.erlineVertexShader, shaders.elineFragmentShader); //dynamic width line elements\n    renderer.progTLine = new GpuProgram(gpu, shaders.tlineVertexShader, shaders.tlineFragmentShader); //textured line\n    renderer.progTPLine = new GpuProgram(gpu, shaders.tplineVertexShader, shaders.tlineFragmentShader); //textured pixed line\n    renderer.progTBLine = new GpuProgram(gpu, shaders.tlineVertexShader, shaders.tblineFragmentShader); //textured line with background color\n    renderer.progTPBLine = new GpuProgram(gpu, shaders.tplineVertexShader, shaders.tblineFragmentShader); //textured pixel line with background color\n    renderer.progETLine = new GpuProgram(gpu, shaders.etlineVertexShader, shaders.elineFragmentShader); //textured line elements\n    renderer.progETPLine = new GpuProgram(gpu, shaders.etplineVertexShader, shaders.elineFragmentShader); //textured pixed line elements\n    renderer.progLineWireframe = new GpuProgram(gpu, shaders.lineWireframeVertexShader, shaders.lineWireframeFragmentShader); //line with wireframe for debugging\n\n    renderer.progPolygon = new GpuProgram(gpu, shaders.polygonVertexShader, shaders.polygonFragmentShader);\n    renderer.progText = new GpuProgram(gpu, shaders.textVertexShader, shaders.textFragmentShader);\n    renderer.progText2 = new GpuProgram(gpu, shaders.text2VertexShader, shaders.text2FragmentShader); //line label\n    renderer.progImage = new GpuProgram(gpu, shaders.imageVertexShader, shaders.imageFragmentShader);\n    renderer.progIcon = new GpuProgram(gpu, shaders.iconVertexShader, shaders.textFragmentShader); //label or icon\n    renderer.progIcon2 = new GpuProgram(gpu, shaders.icon2VertexShader, shaders.text2FragmentShader); //label\n\n    renderer.progLabel16 = new GpuProgram(gpu, '#define DSIZE 16\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); //label with singleBuffer\n    renderer.progLabel32 = new GpuProgram(gpu, '#define DSIZE 32\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);\n    renderer.progLabel48 = new GpuProgram(gpu, '#define DSIZE 48\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);\n    renderer.progLabel64 = new GpuProgram(gpu, '#define DSIZE 64\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);\n    renderer.progLabel96 = new GpuProgram(gpu, '#define DSIZE 96\\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); \n};\n\nRendererInit.prototype.initProceduralShaders = function() {\n    var shaders = GpuShaders;\n    var renderer = this.renderer;\n    var gpu = this.gpu;\n    renderer.progHmapPlane = new GpuProgram(gpu, shaders.planeVertex4Shader, shaders.planeFragmentShader2);\n    renderer.progHmapPlane2 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define grid\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane3 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define exmap\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane4 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define flat\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane5 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define normals\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane6 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define nmix\\n#define normals\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane7 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define nmix\\n' + shaders.planeFragmentShader2);\n    renderer.progHmapPlane8 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define exmap\\n#define classmap\\n' + shaders.planeFragmentShader2);\n}\n\nRendererInit.prototype.initHeightmap = function() {\n    var renderer = this.renderer;\n    var use16Bit = renderer.core.config.map16bitMeshes;\n    var gpu = this.gpu;\n\n    // initialize heightmap geometry\n    var meshData = RendererGeometry.buildHeightmap(5, true);\n    //renderer.heightmapMesh = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit);\n\n    meshData = RendererGeometry.buildPlane(16, true);\n    renderer.planeMesh = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit, true);\n\n    meshData = RendererGeometry.buildPlane(128, true);\n    renderer.planeMesh2 = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit, true);\n\n    // create heightmap texture\n    var size = 64;\n    var halfLineWidth = 1;\n    var data = new Uint8Array( size * size * 4 );\n\n    for (var i = 0; i < size; i++) {\n        for (var j = 0; j < size; j++) {\n\n            var index = (i*size+j)*4;\n\n            if (i < halfLineWidth || i >= size-halfLineWidth || j < halfLineWidth || j >= size-halfLineWidth) {\n                data[index] = 255;\n                data[index + 1] = 255;\n                data[index + 2] = 255;\n            } else {\n                data[index] = 32;\n                data[index + 1] = 32;\n                data[index + 2] = 32;\n            }\n\n            data[index + 3] = 255;\n        }\n    }\n\n\n    renderer.heightmapTexture = new GpuTexture(gpu);\n    renderer.heightmapTexture.createFromData(size, size, data, 'trilinear', true);\n};\n\n\nRendererInit.prototype.initHitmap = function() {\n    var renderer = this.renderer;\n    var size = renderer.hitmapSize;\n    var data = new Uint8Array( size * size * 4 );\n\n    renderer.hitmapTexture = new GpuTexture(this.gpu);\n    renderer.hitmapTexture.createFromData(size, size, data);\n    renderer.hitmapTexture.createFramebuffer(size, size);\n\n    renderer.geoHitmapTexture = new GpuTexture(this.gpu);\n    renderer.geoHitmapTexture.createFromData(size, size, data);\n    renderer.geoHitmapTexture.createFramebuffer(size, size);\n\n    renderer.geoHitmapTexture2 = new GpuTexture(this.gpu);\n    renderer.geoHitmapTexture2.createFromData(size, size, data);\n    renderer.geoHitmapTexture2.createFramebuffer(size, size);\n};\n\n\nRendererInit.prototype.initTestMap = function() {\n    var renderer = this.renderer;\n    var gpu = this.gpu;\n\n   // create red texture\n    var size = 16, i, j, index;\n    var data = new Uint8Array( size * size * 4 );\n\n    for (i = 0; i < size; i++) {\n        for (j = 0; j < size; j++) {\n            index = (i*size+j)*4;\n            data[index] = 255;\n            data[index + 1] = 0;\n            data[index + 2] = 0;\n            data[index + 3] = 255;\n        }\n    }\n\n    renderer.redTexture = new GpuTexture(gpu);\n    renderer.redTexture.createFromData(size, size, data);\n\n    data = new Uint8Array( size * size * 4 );\n\n    for (i = 0; i < size; i++) {\n        for (j = 0; j < size; j++) {\n            index = (i*size+j)*4;\n            data[index] = 255;\n            data[index + 1] = 255;\n            data[index + 2] = 255;\n            data[index + 3] = 255;\n        }\n    }\n\n    renderer.whiteTexture = new GpuTexture(gpu);\n    renderer.whiteTexture.createFromData(size, size, data);\n\n    data = new Uint8Array( size * size * 4 );\n\n    for (i = 0; i < size; i++) {\n        for (j = 0; j < size; j++) {\n            index = (i*size+j)*4;\n            data[index] = 0;\n            data[index + 1] = 0;\n            data[index + 2] = 0;\n            data[index + 3] = 255;\n        }\n    }\n\n    renderer.blackTexture = new GpuTexture(gpu);\n    renderer.blackTexture.createFromData(size, size, data);\n};\n\n\nRendererInit.prototype.initTextMap = function() {\n    var renderer = this.renderer;\n\n    //font texture\n    var texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACACAMAAADTa0c4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRFAAAA////pdmf3QAABIFJREFUeNrsnNuyqzAIhsP7v/Se6Yxra0L4OUVNCzetVqP5DAQItrVOiLg95739NnfOaR99RDj6esBw+CKZXiMK4PiuBkAcANoHAP3J5fzzAV2jePQIt6f4Ndb/MIChlVcCEFpAACZPfN4KUAF0/ufboDW3AuBMFgBwHTCfg2ftYgDUKBuA1ABuHKvA2P+5XdONIEt7BO2o2MdlAJoTQOsV6GEAswt0Zq/bsBhdeQQkqEDMwmIAnJHzA8i3ASkWRFKBbADyLGB3mlYD6DyhA4DfBlgsBDtirUPcBgC5woStYMgVtgKATWcB6DskKUEkGFLYrGw3+l3ydR16wKbbPDlWp4Xfo9vZwR1jtOMA6GkABrdvNmt1Vluy6pyvxu4Xt62fquyTggCTsIkCoIuv8gAA08w+ATBXAdSRY56xPDFPx/VPWFZp5v65kFMPgFjP70YASMfRsDn01xLPcwkRq1HLMoK647hR8v+nId74MQBjvIbUQePra42ZVXVcBCR3mIY89mYAlNGLflqA0V1seosCQNMg80B0bsLGAIDNwvFyiqu66ngVGGMGVBwyWwIwpty2DqEr/qf0Bq+DbjYkkcr4VUoOxiRjrYn3YY5SC4BQB/cF0Lq4kD1RCJ+tN4g6Jps5zfWu+QmSz9sUABkA0BIAXocmBwCJ99MDIASATkmtLQAIft4IgE/ZDStZ59yQbOQQAGZWYMbZ3FFCAGRHnwHQznegGAE+zwxNi8kALCOgS9tzAC4jYG1Qo0myRm0Ae/z8eleqewBoZLwfUswCsbT1KgBZD6QAzAEoXUe3K+xxVf2uLf5U3nBeMPRyACW/LtrwVX989id3PRQOG5Io6vh9XwC6stHIdGdJozun03lxNlwvH4u6UgDM8/LmJyx7ak12feEebaXmUwCOYJWk1JcYKsl74HL74wAaH93NqkE1FSKXc4cv0AjaPEEPgE4ru/ieWdvzVq/4psG3AYDFHlEAioQCuEgMgPjK1VDrqlkbTABAiQBGK38B0BlBSf9xtiAJQDM4NtDqMlaeyduTtkDjHgAtEQBj5ZGK2QE0aCcMAIxLSw0WVYlGDgOQXWE+afouAM0S398O4Nej3wIQf4cIHSfz9pbWugyep4MFIAFARvspbm8BcE2DOdvWnCJQAWFhJ/hKzh4AaB2A7NxedKmLPc+6PN4cL2S8GYC1QMIEQJvmFsJfxdvkEQAoLV4AogBS8/kNvdXlWe5GKhABvQUAZASDALJffY1XfsrToFXFbvYD1gBo6wC8LR7/uvj9CwHcfWuoUJItsVl5nwWAnhxxqsXatUq0OYCcaS/fkbK61u5H8jwAuUIEZXHNL1Jmub5oSKZWiDR9FttM4HEAigqRpn8TeB2AuWNiByAXSHCGbB7/3qYCfgCgPgADEEskbjCCaJDB/+kR6wP4P1Obl8jsBwDUB4yAxqKkthaATjX0KmCtDyCxm+yIMLjCbwBgrg94FYC3h8vLPPmfAVBSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlLy9fJPgAEAvWMULbGsSjwAAAAASUVORK5CYII=';\n    renderer.textTexture2 = new GpuTexture(this.gpu, texture, this.core, null, true);\n};\n\n\nRendererInit.prototype.initImage = function() {\n    var renderer = this.renderer;\n    var gl = this.gpu.gl;\n\n    //create vertices buffer for rect\n    renderer.rectVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, renderer.rectVerticesBuffer);\n\n    var vertices = [ 0, 0, 0, 1,   1, 0, 0, 1,   2, 0, 0, 1,   3, 0, 0, 1 ];\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    renderer.rectVerticesBuffer.itemSize = 4;\n    renderer.rectVerticesBuffer.numItems = 4;\n\n    //create indices buffer for rect\n    renderer.rectIndicesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderer.rectIndicesBuffer);\n\n    var indices = [ 0, 2, 1,    0, 3, 2 ];\n\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n    renderer.rectIndicesBuffer.itemSize = 1;\n    renderer.rectIndicesBuffer.numItems = 6;\n\n    renderer.textBuff16 = new Float32Array(16 * 4);\n    renderer.textBuff32 = new Float32Array(32 * 4);\n    renderer.textBuff48 = new Float32Array(48 * 4);\n    renderer.textBuff64 = new Float32Array(64 * 4);\n\n    renderer.textQuads16 = this.generateTextQuads(16);\n    renderer.textQuads32 = this.generateTextQuads(32);\n    renderer.textQuads48 = this.generateTextQuads(48);\n    renderer.textQuads64 = this.generateTextQuads(64);\n    renderer.textQuads96 = this.generateTextQuads(96);\n};\n\n\nRendererInit.prototype.generateTextQuads = function(num) {\n    var renderer = this.renderer;\n    var gl = this.gpu.gl;\n\n    var buffer = new Float32Array(num * 2 * 6);\n    var index, j;\n\n    for (var i = 0; i < num; i++) {\n        index = i * 6 * 2;\n\n        j = 0;\n        buffer[index] = i;\n        buffer[index+1] = j;\n\n        j = 1;\n        buffer[index+2] = i;\n        buffer[index+3] = j;\n\n        j = 2;\n        buffer[index+4] = i;\n        buffer[index+5] = j;\n\n        j = 2;\n        buffer[index+6] = i;\n        buffer[index+7] = j;\n\n        j = 3;\n        buffer[index+8] = i;\n        buffer[index+9] = j;\n\n        j = 0;\n        buffer[index+10] = i;\n        buffer[index+11] = j;\n    }\n\n    //create vertices buffer for rect\n    var vbuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);\n\n    gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n    vbuffer.itemSize = 2;\n    vbuffer.numItems = num * 6;\n\n    return vbuffer;\n};\n\nRendererInit.prototype.initSkydome = function() {\n    var renderer = this.renderer;\n    var use16Bit = renderer.core.config.map16bitMeshes;\n    var meshData = RendererGeometry.buildSkydome(32, 64, use16Bit);\n    renderer.skydomeMesh = new GpuMesh(this.gpu, meshData, null, this.core, true, use16Bit);\n    //this.skydomeTexture = new GpuTexture(this.gpu, \"./skydome.jpg\", this.core);\n\n    meshData = RendererGeometry.buildSkydome(128, 256, use16Bit, true);\n//    var meshData = RendererGeometry.buildSkydome(256, 512);\n    renderer.atmoMesh = new GpuMesh(this.gpu, meshData, null, this.core, true, use16Bit);\n};\n\n\nRendererInit.prototype.initBBox = function() {\n    var renderer = this.renderer;\n    var gpu = this.gpu;\n    renderer.bboxMesh = new GpuBBox(gpu);\n    renderer.bboxMesh2 = new GpuBBox(gpu, true);\n};\n\n\nRendererInit.prototype.initLines = function() {\n    var gpu = this.gpu;\n    var renderer = this.renderer;\n    renderer.plineBuffer = new Float32Array(32*3);\n    renderer.plines = new GpuPixelLine3(gpu, this.core, true, 64, true, 8);\n    renderer.plineJoints = new GpuPixelLine3(gpu, this.core, false, 64, true, 8);\n\n    renderer.stencilLineState = gpu.createState({blend:true, stencil:true, culling: false});\n    renderer.lineLabelState = gpu.createState({blend:true, culling: false, zequal: true, zwrite:false});\n    renderer.labelState = gpu.createState({blend:true, culling: false, zequal: true});\n    renderer.stencilLineHitState = gpu.createState({blend:false, stencil:true, culling: false});\n    renderer.lineLabelHitState = gpu.createState({blend:false, culling: false});\n};\n\n\nRendererInit.prototype.initBaricentricBuffer = function() {\n    var gpu = this.gpu;\n    var buffer = new Array(65535*3);\n\n    for (var i = 0; i < 65535*3; i+=9) {\n        buffer[i] = 1.0;\n        buffer[i+1] = 0;\n        buffer[i+2] = 0;\n\n        buffer[i+3] = 0;\n        buffer[i+4] = 1.0;\n        buffer[i+5] = 0;\n\n        buffer[i+6] = 0;\n        buffer[i+7] = 0;\n        buffer[i+8] = 1.0;\n    }\n\n    var gl = gpu.gl;\n    gpu.barycentricBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, gpu.barycentricBuffer);\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer), gl.STATIC_DRAW);\n    gpu.barycentricBuffer.itemSize = 3;\n    gpu.barycentricBuffer.numItems = buffer.length / 3;\n};\n\n\nexport default RendererInit;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/init.js\n// module id = 164\n// module chunks = 0 1","\nimport GpuTexture_ from './gpu/texture';\nimport GpuMesh_ from './gpu/mesh';\nimport GpuProgram_ from './gpu/program';\nimport {Octree as Octree_, OctreeRaycaster as OctreeRaycaster_} from './octree.js';\n\n//get rid of compiler mess\nvar GpuTexture = GpuTexture_;\nvar GpuMesh = GpuMesh_;\nvar GpuProgram = GpuProgram_;\nvar Octree = Octree_;\nvar OctreeRaycaster = OctreeRaycaster_;\n\nvar RendererInterface = function(renderer) {\n    this.renderer = renderer;\n    this.gpu = renderer.gpu;\n};\n\n\nRendererInterface.prototype.clear = function(options) {\n    if (options != null) {\n        this.gpu.clear((options['clearDepth'] || true),\n                        (options['clearColor'] || false),\n                        (options['color'] || [255,255,255,255]),\n                        ((options['depth'] != null) ? options['depth'] : 1.0) );\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.createState = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n    \n    var stateOptions = {\n        blend : (options['blend'] != null) ? options['blend'] : false,\n        stencil : (options['stencil'] != null) ? options['stencil'] : false,\n        zoffset : (options['zoffset'] != null) ? options['zoffset'] : 0,\n        zwrite : (options['zwrite'] != null) ? options['zwrite'] : true,\n        ztest : (options['ztest'] != null) ? options['ztest'] : true,\n        zequal : (options['zequal'] != null) ? options['zequal'] : true,\n        culling : (options['culling'] != null) ? options['culling'] : true\n    };\n\n    return this.gpu.createState(stateOptions);\n};\n\n\nRendererInterface.prototype.setState = function(state) {\n    if (state != null) {\n        this.gpu.setState(state);\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.createTexture = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return null;\n    }\n\n    var source = options['source'];\n    if (source == null) {\n        return null;\n    }\n\n    var filter = options['filter'] || 'linear';\n    var repeat = options['repeat'] || false, texture;\n\n    if (source instanceof Uint8Array) {\n        var width = options['width'];\n        var height = options['height'];\n\n        if (width && height) {\n            texture = new GpuTexture(this.gpu);\n            texture.createFromData(width, height, source, filter, repeat);\n            return texture;\n        }\n    }\n\n    if (source instanceof Image) {\n        texture = new GpuTexture(this.gpu);\n        texture.createFromImage(source, filter, repeat);\n        return texture;\n    }\n\n    return null;\n};\n\n\nRendererInterface.prototype.removeTexture = function(texture) {\n    if (texture) {\n        texture.kill();\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.createMesh = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return null;\n    }\n\n    var data = {\n        vertices : options['vertices'],\n        uvs : options['uvs'],\n        uvs2 : options['normals'],\n        vertexSize : options['vertexSize'],\n        uvSize : options['uvSize'],\n        uv2Size : options['normalSize'] || 3,\n        vertexAttr : options['vertexAttr'],\n        uvAttr : options['uvAttr'],\n        uv2Attr : options['normalAttr'],\n        bbox : options['bbox']\n    };\n\n    return new GpuMesh(this.gpu, data, 0, this.renderer.core);\n};\n\n\nRendererInterface.prototype.removeMesh = function(mesh) {\n    if (mesh) {\n        mesh.kill();\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.createShader = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return null;\n    }\n\n    var vertexShader = options['vertexShader'];\n    var fragmentShader = options['fragmentShader'];\n\n    if (vertexShader != null && fragmentShader) {\n        return new GpuProgram(this.gpu, vertexShader, fragmentShader);\n    }\n};\n\n\nRendererInterface.prototype.removeResource = function(resource) {\n    if (resource != null && resource.kill != null) {\n        resource.kill();\n    }\n    return this;    \n};\n\n\nRendererInterface.prototype.addJob = function(/*options*/) {\n    return this;    \n};\n\n\nRendererInterface.prototype.clearJobs = function(/*options*/) {\n    return this;    \n};\n\n\nRendererInterface.prototype.drawMesh = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (!options['mesh'] == null || !options['shaderVariables']) {\n        return this;    \n    }\n\n    //var shaderAttributes = options['shaderAttributes'];\n    var vertexAttr = options['vertex'] || 'aPosition';\n    var uvAttr = options['uv'] || 'aTexCoord';\n    var uv2Attr = options['normal'] || 'aNormal';\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n\n    var shaderVariables = options['shaderVariables'];\n    var shader = options['shader'] || 'textured';\n\n   \n    var renderer = this.renderer; \n    var mesh = options['mesh'];\n    var texture = options['texture'];\n    var mv = renderer.camera.getModelviewMatrix();\n    var proj = renderer.camera.getProjectionMatrix();\n    var fogDensity = renderer.fogDensity;\n    \n    if (typeof shader === 'string') {\n        switch(shader) {\n        case 'hit':\n\n            if (!shaderVariables['uMV']) {\n                shaderVariables['uMV'] = ['mat4', mv];\n            } \n\n            if (!shaderVariables['uProj']) {\n                shaderVariables['uProj'] = ['mat4', proj];\n            } \n\n            uvAttr = null;\n            uv2Attr = null;\n            texture = null;\n            shader = renderer.progDepthTile;\n            break;\n\n        case 'shaded':\n            uvAttr = null;\n\n        // eslint-disable-next-line\n        case 'textured':\n        case 'textured-and-shaded':\n\n            if (!shaderVariables['uMV']) {\n                shaderVariables['uMV'] = ['mat4', mv];\n            } \n\n            if (!shaderVariables['uProj']) {\n                shaderVariables['uProj'] = ['mat4', proj];\n            } \n\n            if (!shaderVariables['uFogDensity']) {\n                shaderVariables['uFogDensity'] = ['float', fogDensity];\n            } \n            \n            uv2Attr = (shader == 'textured') ? null : 'aNormal';\n            shader = (shader == 'textured') ? renderer.progTile : ((shader == 'shaded') ? renderer.progShadedTile : renderer.progTShadedTile);\n            break;\n        }\n    }\n\n    if (!shader || !shader.isReady()) {\n        return;\n    }\n\n    var attributes = [vertexAttr];\n    if (uvAttr){\n        attributes.push(uvAttr);        \n    } \n    if (uv2Attr){\n        attributes.push(uv2Attr);        \n    } \n\n    renderer.gpu.useProgram(shader, attributes);\n\n    for (var key in shaderVariables) {\n        var item = shaderVariables[key];\n        \n        if (item.length == 2) {\n            switch(item[0]){\n            case 'floatArray':\n                shader.setFloatArray(key, item[1]);\n                break;\n            case 'float':\n                shader.setFloat(key, item[1]);\n                break;\n            case 'mat3':\n                shader.setMat3(key, item[1]);\n                break;\n            case 'mat4':\n                if (depthOffset && key == 'uProj') {\n                    shader.setMat4(key, item[1], renderer.getZoffsetFactor(depthOffset));\n                } else {\n                    shader.setMat4(key, item[1]);\n                }\n                break;\n            case 'vec2':\n                shader.setVec2(key, item[1]);\n                break;\n            case 'vec3':\n                shader.setVec3(key, item[1]);\n                break;\n            case 'vec4':\n                shader.setVec4(key, item[1]);\n                break;\n            case 'sampler':\n                shader.setSampler(key, item[1]);\n                break;\n            } \n        }\n    }\n\n    if (texture) {\n        renderer.gpu.bindTexture(texture);\n    }\n    \n    //mesh.draw(shader, vertexAttr, texture ? uvAttr : null, uv2Attr, null);\n    mesh.draw(shader, vertexAttr, uvAttr, uv2Attr, null);\n    return this;    \n};\n\n\nRendererInterface.prototype.drawImage = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (options['texture'] == null || options['rect'] == null) {\n        return this;    \n    }\n\n    var rect = options['rect'];\n    var color = options['color'] || [255,255,255,255];\n    var depth = (options['depth'] != null) ? options['depth'] : 0;\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;\n    var blend = (options['blend'] != null) ? options['blend'] : false;\n    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;\n    var useState = (options['useState'] != null) ? options['useState'] : false;\n    color[0] *= 1.0/255;\n    color[1] *= 1.0/255;\n    color[2] *= 1.0/255;\n    color[3] *= 1.0/255;\n\n    this.renderer.draw.drawImage(rect[0], rect[1], rect[2], rect[3], options['texture'], color, depth, depthOffset, depthTest, blend, writeDepth, useState);\n    return this;    \n};\n\n\nRendererInterface.prototype.drawBillboard = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (options['texture'] == null || options['mvp'] == null) {\n        return this;    \n    }\n\n    var mvp = options['mvp'];\n    var color = options['color'] || [255,255,255,255];\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;\n    var blend = (options['blend'] != null) ? options['blend'] : false;\n    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;\n    var useState = (options['useState'] != null) ? options['useState'] : false;\n    color[0] *= 1.0/255;\n    color[1] *= 1.0/255;\n    color[2] *= 1.0/255;\n    color[3] *= 1.0/255;\n\n    this.renderer.draw.drawBillboard(mvp, options['texture'], color, depthOffset, depthTest, blend, writeDepth, useState);\n    return this;    \n};\n\n\nRendererInterface.prototype.drawLineString = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    if (options['points'] == null) {\n        return this;    \n    }\n\n    var points = options['points'];\n    var color = options['color'] || [255,255,255,255];\n    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;\n    var size = options['size'] || 2;\n    var screenSpace = (options['screenSpace'] != null) ? options['screenSpace'] : true;\n    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;\n    var blend = (options['blend'] != null) ? options['blend'] : false;\n    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;\n    var useState = (options['useState'] != null) ? options['useState'] : false;\n    color[0] *= 1.0/255;\n    color[1] *= 1.0/255;\n    color[2] *= 1.0/255;\n    color[3] *= 1.0/255;\n\n    this.renderer.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, blend, writeDepth, useState);\n    return this;    \n};\n\n\nRendererInterface.prototype.drawJobs = function(/*options*/) {\n    return this;    \n};\n\n\nRendererInterface.prototype.drawBBox = function(/*options*/) {\n    return this;    \n};\n\n\nRendererInterface.prototype.drawDebugText = function(options) {\n    if (options == null || typeof options !== 'object') {\n        return this;    \n    }\n\n    var text = options['text'];\n    var coords = options['coords'];\n\n    if (!text || !coords) {\n        return this;    \n    }\n    \n    var color = options['color'] || [255,255,255,255];\n    var size = options['size'] || 16;\n    var depth = options['depth'];\n    var useState = options['useState'] || false;\n    color[0] *= 1.0/255;\n    color[1] *= 1.0/255;\n    color[2] *= 1.0/255;\n    color[3] *= 1.0/255;\n\n    var lx = this.renderer.draw.getTextSize(size, text);\n\n    this.renderer.draw.drawText(coords[0] - (lx * 0.5), coords[1], size, text, color, depth, useState);\n\n    return this;    \n};\n\n\nRendererInterface.prototype.buildOctreeFromGeometry = function(geometry) {\n    var octree = new Octree();\n    octree.buildFromGeometry(geometry);\n    return octree;\n};\n\n\nRendererInterface.prototype.raycastOctreeGeometry = function(octree, rayPos, rayDir) {\n    var raycaster = new OctreeRaycaster(), intersects = [];\n    raycaster.intersectOctree(rayPos, rayDir, octree, intersects);\n    return raycaster.intersectOctants(rayPos, rayDir, intersects);\n};\n\nRendererInterface.prototype.saveScreenshot = function(output, filename, filetype) {\n    return this.renderer.saveScreenshot(output, filename, filetype);\n};\n\n\nRendererInterface.prototype.getCanvasCoords = function(point, mvp) {\n    return this.renderer.project2(point, mvp);\n};\n\n\nRendererInterface.prototype.getCanvasSize = function() {\n    return this.renderer.curSize.slice();\n};\n\n\nRendererInterface.prototype.setConfigParams = function(params) {\n    this.renderer.setConfigParams(params);\n    return this;\n};\n\n\nRendererInterface.prototype.setConfigParam = function(key, value) {\n    this.renderer.setConfigParam(key, value);\n    return this;\n};\n\n\nRendererInterface.prototype.getConfigParam = function(key) {\n    return this.renderer.getConfigParam(key);\n};\n\n\nRendererInterface.prototype.getGLInterface = function() {\n    return {\n        canvas : this.gpu.canvas,\n        gl : this.gpu.gl\n    };\n};\n\nexport default RendererInterface;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/interface.js\n// module id = 165\n// module chunks = 0 1","\nimport {vec3 as vec3_} from '../utils/matrix';\n\n//get rid of compiler mess\nvar vec3 = vec3_;\n\n\nvar Octree = function() {\n    this.root = null;\n    this.maxItemsPerNode = 20;\n    this.maxDepth = 20;\n\n    this.depthCount = [];\n    for (var i = 0; i < 1000; i++) {\n        this.depthCount[i] = 0;\n    }\n\n    /**\n     * A binary pattern that describes the standard octant layout:\n     *\n     * ```text\n     *    3____7\n     *  2/___6/|\n     *  | 1__|_5\n     *  0/___4/\n     * ```\n     *\n     * This common layout is crucial for positional assumptions.\n     *\n     */\n\n    this.pattern = [\n        new Uint8Array([0, 0, 0]),\n        new Uint8Array([0, 0, 1]),\n        new Uint8Array([0, 1, 0]),\n        new Uint8Array([0, 1, 1]),\n\n        new Uint8Array([1, 0, 0]),\n        new Uint8Array([1, 0, 1]),\n        new Uint8Array([1, 1, 0]),\n        new Uint8Array([1, 1, 1])\n    ];\n};\n\n\nOctree.prototype.clear = function() {\n};\n\n\nOctree.prototype.buildFromGeometry = function(data) {\n    if (!data) {\n        return;\n    }\n\n    var i, li, j, lj, k, lk, v, item, submeshes, submesh, bbox, index,\n        minX, minY, minZ, maxX, maxY, maxZ, geometry, vertices;\n\n    minX = minY = minZ = Number.POSITIVE_INFINITY;\n    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;\n\n    //get gemetery bbox\n    for (i = 0, li = data.length; i < li; i++) {\n        geometry = data[i];\n        if (geometry[\"type\"] == \"mesh\") {\n            submeshes = geometry[\"submeshes\"];\n\n            for (j = 0, lj = submeshes.length; j < lj; j++) {\n                submesh = submeshes[j];\n                bbox = submesh[\"bbox\"];\n                \n                if (bbox[0][0] < minX) minX = bbox[0][0];\n                if (bbox[0][1] < minY) minY = bbox[0][1];\n                if (bbox[0][2] < minZ) minZ = bbox[0][2];\n\n                if (bbox[1][0] > maxX) maxX = bbox[1][0];\n                if (bbox[1][1] > maxY) maxY = bbox[1][1];\n                if (bbox[1][2] > maxZ) maxZ = bbox[1][2];\n            }\n        }\n    }\n\n    this.root = new OctreeNode([minX, minY, minZ], [maxX, maxY, maxZ]);\n\n    //get gemetery bbox\n    for (i = 0, li = data.length; i < li; i++) {\n        geometry = data[i];\n        if (geometry[\"type\"] == \"mesh\") {\n            submeshes = geometry[\"submeshes\"];\n\n            for (j = 0, lj = submeshes.length; j < lj; j++) {\n                submesh = submeshes[j];\n\n                vertices = submesh[\"vertices\"];\n\n                for (k = 0, lk = vertices.length; k < lk; k += 9) {\n\n                    minX = minY = minZ = Number.POSITIVE_INFINITY;\n                    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;\n\n                    for (v = 0; v < 3; v ++) {\n                        index = k + v * 3;\n\n                        if (vertices[index] < minX) minX = vertices[index];\n                        if (vertices[index+1] < minY) minY = vertices[index+1];\n                        if (vertices[index+2] < minZ) minZ = vertices[index+2];\n\n                        if (vertices[index] > maxX) maxX = vertices[index];\n                        if (vertices[index+1] > maxY) maxY = vertices[index+1];\n                        if (vertices[index+2] > maxZ) maxZ = vertices[index+2];\n                    }\n\n                    //this.root.add([minX, minY, minZ], [maxX, maxY, maxZ], [vertices, k])\n                    this.root.add([minX, minY, minZ, maxX, maxY, maxZ, vertices, k], this)\n                }\n\n            }\n        }\n    }\n\n\n};\n\n\nvar OctreeNode = function(min, max) {\n    this.min = min;\n    this.max = max;\n    this.children = null;\n    this.items = null;\n};\n\nOctreeNode.prototype.add = function(item, octree, depth) {\n    if (this.children) {\n        if (!depth) {\n            depth = 0; \n        }\n\n        for (var i = 0; i < 8; i++) {\n            var child = this.children[i],\n                min = child.min,\n                max = child.max;\n\n            if (item[0] < max[0] && item[3] > min[0] &&\n                item[1] < max[1] && item[4] > min[1] &&\n                item[2] < max[2] && item[5] > min[2]) {\n\n                //collision detected, add item\n                child.add(item, octree, depth + 1);\n            }\n        }\n\n        return;\n    }\n\n    if (!this.items) {\n        this.items = [];\n    }\n\n    this.items.push(item);\n\n    if (depth < octree.maxDepth && this.items.length >= octree.maxItemsPerNode) {\n        this.split(octree, depth + 1);\n    }\n};\n\nOctreeNode.prototype.split = function(octree, depth) {\n    var min = this.min,\n        max = this.max,\n        mid = [(max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5],\n        i, li, j;\n\n    this.children = [\n        null, null,\n        null, null,\n        null, null,\n        null, null\n    ];\n\n    this.depthCount[depth]++;\n\n    for (i = 0; i < 8; i++) {\n        var combination = octree.pattern[i];\n\n        this.children[i] = new OctreeNode(\n            [\n                (combination[0] === 0) ? min[0] : mid[0],\n                (combination[1] === 0) ? min[1] : mid[1],\n                (combination[2] === 0) ? min[2] : mid[2]\n            ],\n\n            [\n                (combination[0] === 0) ? mid[0] : max[0],\n                (combination[1] === 0) ? mid[1] : max[1],\n                (combination[2] === 0) ? mid[2] : max[2]\n            ]\n        );\n    }\n\n    var items = this.items;\n\n    //distribute items\n    if (items) {\n        for (i = 0, li = items.length; i < li; i++) {\n            var item = items[i];\n\n            for (j = 0; j < 8; j++) {\n                var child = this.children[j];\n                min = child.min;\n                max = child.max;\n\n                if (item[0] < max[0] && item[3] > min[0] &&\n                    item[1] < max[1] && item[4] > min[1] &&\n                    item[2] < max[2] && item[5] > min[2]) {\n\n                    //collision detected, add item\n                    child.add(item, octree);\n                }\n            }\n        }\n    }\n\n    this.items = null;   \n};\n\n\nvar OctreeRaycaster = function() {\n\n    // A lookup-table containing octant ids. Used to determine the exit plane from an octant.\n    this.octantTable = [\n        new Uint8Array([4, 2, 1]),\n        new Uint8Array([5, 3, 8]),\n        new Uint8Array([6, 8, 3]),\n        new Uint8Array([7, 8, 8]),\n        new Uint8Array([8, 6, 5]),\n        new Uint8Array([8, 7, 8]),\n        new Uint8Array([8, 8, 7]),\n        new Uint8Array([8, 8, 8])\n    ];\n\n    // A byte that stores raycasting flags.\n    this.flags = 0;\n};\n\n\n/**\n * Finds the entry plane of the first octant that a ray travels through.\n *\n * Determining the first octant requires knowing which of the t0s is the\n * largest. The tms of the other axes must also be compared against that\n * largest t0.\n * \n * tx0, ty0,tz0 - Ray projection parameter.\n * txm, tym, tzm - Ray projection parameter mean.\n * returns - index of the first octant that the ray travels through.\n */\n\nOctreeRaycaster.prototype.findEntryOctant = function(tx0, ty0, tz0, txm, tym, tzm) {\n    var entry = 0;\n\n    // Find the entry plane.\n    if(tx0 > ty0 && tx0 > tz0) {\n\n        // YZ-plane.\n        if (tym < tx0) {\n            entry |= 2;\n        }\n\n        if (tzm < tx0) {\n            entry |= 1;\n        }\n\n    } else if (ty0 > tz0) {\n\n        // XZ-plane.\n        if (txm < ty0) {\n            entry |= 4;\n        }\n\n        if (tzm < ty0) {\n            entry |= 1;\n        }\n\n    } else {\n\n        // XY-plane.\n        if (txm < tz0) {\n            entry |= 4;\n        }\n\n        if (tym < tz0) {\n            entry |= 2;\n        }\n    }\n\n    return entry;\n}\n\n/**\n * Finds the next octant that intersects with the ray based on the exit plane of\n * the current one.\n *\n * urrentOctant - The index of the current octant.\n * tx1, ty1, tz1 - Ray projection parameter.\n * returns - index of the next octant that the ray travels through.\n */\n\nOctreeRaycaster.prototype.findNextOctant = function(currentOctant, tx1, ty1, tz1) {\n    var min;\n    var exit = 0;\n\n    // Find the exit plane.\n    if (tx1 < ty1) {\n        min = tx1;\n        exit = 0; // YZ-plane.\n    } else {\n        min = ty1;\n        exit = 1; // XZ-plane.\n    }\n\n    if (tz1 < min) {\n        exit = 2; // XY-plane.\n    }\n\n    return this.octantTable[currentOctant][exit];\n}\n\n/**\n * Finds all octants that intersect with the given ray.\n *\n * octant - The current octant.\n * tx0 - Ray projection parameter. Initial tx0 = (minX - rayOriginX) / rayDirectionX.\n * ty0 - Ray projection parameter. Initial ty0 = (minY - rayOriginY) / rayDirectionY.\n * tz0 - Ray projection parameter. Initial tz0 = (minZ - rayOriginZ) / rayDirectionZ.\n * tx1 - Ray projection parameter. Initial tx1 = (maxX - rayOriginX) / rayDirectionX.\n * ty1 - Ray projection parameter. Initial ty1 = (maxY - rayOriginY) / rayDirectionY.\n * tz1 - Ray projection parameter. Initial tz1 = (maxZ - rayOriginZ) / rayDirectionZ.\n * intersects - An array to be filled with the intersecting octants.\n * returns\n */\n\nOctreeRaycaster.prototype.raycastOctant = function(octant, tx0, ty0, tz0, tx1, ty1, tz1, intersects) {\n    var children = octant.children;\n    var currentOctant;\n    var txm, tym, tzm;\n\n    if (tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {\n\n        if (!children) {\n\n            // Leaf.\n            if (octant.items) {\n                intersects.push(octant);\n            }\n\n        } else {\n\n            // Compute means.\n            txm = 0.5 * (tx0 + tx1);\n            tym = 0.5 * (ty0 + ty1);\n            tzm = 0.5 * (tz0 + tz1);\n\n            currentOctant = this.findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);\n\n            do {\n\n                /* The possibilities for the next node are passed in the same respective\n                 * order as the t-values. Hence, if the first value is found to be the\n                 * greatest, the fourth one will be returned. If the second value is the\n                 * greatest, the fifth one will be returned, etc.\n                 */\n\n                switch(currentOctant) {\n\n                    case 0:\n                        this.raycastOctant(children[this.flags], tx0, ty0, tz0, txm, tym, tzm, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, txm, tym, tzm);\n                        break;\n\n                    case 1:\n                        this.raycastOctant(children[this.flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, txm, tym, tz1);\n                        break;\n\n                    case 2:\n                        this.raycastOctant(children[this.flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, txm, ty1, tzm);\n                        break;\n\n                    case 3:\n                        this.raycastOctant(children[this.flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, txm, ty1, tz1);\n                        break;\n\n                    case 4:\n                        this.raycastOctant(children[this.flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, tx1, tym, tzm);\n                        break;\n\n                    case 5:\n                        this.raycastOctant(children[this.flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, tx1, tym, tz1);\n                        break;\n\n                    case 6:\n                        this.raycastOctant(children[this.flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, intersects);\n                        currentOctant = this.findNextOctant(currentOctant, tx1, ty1, tzm);\n                        break;\n\n                    case 7:\n                        this.raycastOctant(children[this.flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, intersects);\n                        // Far top right octant. No other octants can be reached from here.\n                        currentOctant = 8;\n                        break;\n\n                }\n\n            } while(currentOctant < 8);\n\n        }\n\n    }\n\n}\n\nOctreeRaycaster.prototype.hitFace = function(origin, dir, index, vertices) {\n    var EPSILON = 0.0000001,\n        v1 = [vertices[index], vertices[index+1], vertices[index+2]],\n        v2 = [vertices[index+3], vertices[index+4], vertices[index+5]],\n        v3 = [vertices[index+6], vertices[index+7], vertices[index+8]];\n\n    var h = [0,0,0], q = [0,0,0], s, a, f, u, v,\n        edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]],\n        edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];\n\n    vec3.cross(dir, edge2, h);\n    a = vec3.dot(edge1, h);\n\n    if (a > -EPSILON && a < EPSILON) {\n        return [false];\n    }\n\n    f = 1/a;\n    s = [origin[0] - v1[0], origin[1] - v1[1], origin[2] - v1[2]];\n    u = f * (vec3.dot(s, h));\n\n    if (u < 0.0 || u > 1.0) {\n        return [false];\n    }\n\n    q = vec3.cross(s, edge1);\n    v = f * vec3.dot(dir, q);\n    if (v < 0.0 || u + v > 1.0) {\n        return [false];\n    }\n\n    // At this stage we can compute t to find out where the intersection point is on the line.\n    var t = f * vec3.dot(edge2, q);\n    //if (t > EPSILON) { // ray intersection\n        return [true, t]; //[origin[0] + dir[0] * t, origin[1] + dir[1] * t, origin[2] + dir[2] * t ]];\n    //} else { // This means that there is a line intersection but not a ray intersection.\n     //   return [false];\n    //}\n};\n\n\n/**\n * Finds the octants that intersect with the given ray. The intersecting\n * octants are sorted by distance, closest first.\n *\n * octree - An octree.\n * intersects - A list to be filled with intersecting octants.\n */\n\n// https://github.com/vanruesc/sparse-octree/blob/master/src/core/OctreeRaycaster.js\n\nOctreeRaycaster.prototype.intersectOctree = function(rayPos, rayDir, octree, intersects) {\n    // Translate the octree extents to the scene origin.\n    var min = [0,0,0];\n    var max = [octree.root.max[0] - octree.root.min[0],\n               octree.root.max[1] - octree.root.min[1],\n               octree.root.max[2] - octree.root.min[2]] \n\n    var dimensions = [max[0], max[1], max[2]];\n    var halfDimensions = [dimensions[0]*0.5, dimensions[1]*0.5, dimensions[2]*0.5];\n\n    var origin = [rayPos[0],rayPos[1],rayPos[2]];\n    var direction = [rayDir[0], rayDir[1], rayDir[2]];\n\n    var invDirX, invDirY, invDirZ;\n    var tx0, tx1, ty0, ty1, tz0, tz1;\n\n    var center = [(octree.root.max[0] + octree.root.min[0]) * 0.5,\n                  (octree.root.max[1] + octree.root.min[1]) * 0.5,\n                  (octree.root.max[2] + octree.root.min[2]) * 0.5] \n\n    // Translate the ray to the center of the octree.\n    //origin.sub(octree.getCenter(v[2])).add(halfDimensions);\n    origin[0] = (origin[0] - center[0]) + halfDimensions[0]; \n    origin[1] = (origin[1] - center[1]) + halfDimensions[1]; \n    origin[2] = (origin[2] - center[2]) + halfDimensions[2]; \n\n    // Reset all flags.\n    this.flags = 0;\n\n    // Handle rays with negative directions.\n    if (direction[0] < 0.0) {\n        origin[0] = dimensions[0] - origin[0];\n        direction[0] = -direction[0];\n        this.flags |= 4;\n    }\n\n    if (direction[1] < 0.0) {\n        origin[1] = dimensions[1] - origin[1];\n        direction[1] = -direction[1];\n        this.flags |= 2;\n    }\n\n    if (direction[2] < 0.0) {\n        origin[2] = dimensions[2] - origin[2];\n        direction[2] = -direction[2];\n        this.flags |= 1;\n    }\n\n    // Improve IEEE double stability.\n    invDirX = 1.0 / direction[0];\n    invDirY = 1.0 / direction[1];\n    invDirZ = 1.0 / direction[2];\n\n    // Project the ray to the root's boundaries.\n    tx0 = (min[0] - origin[0]) * invDirX;\n    tx1 = (max[0] - origin[0]) * invDirX;\n    ty0 = (min[1] - origin[1]) * invDirY;\n    ty1 = (max[1] - origin[1]) * invDirY;\n    tz0 = (min[2] - origin[2]) * invDirZ;\n    tz1 = (max[2] - origin[2]) * invDirZ;\n\n    // Check if the ray hits the octree.\n    if (Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {\n        // Find the intersecting octants.\n        this.raycastOctant(octree.root, tx0, ty0, tz0, tx1, ty1, tz1, intersects);\n    }\n};\n\nOctreeRaycaster.prototype.intersectOctants = function(rayPos, rayDir, octants) {\n    var hits = [];\n    var t = Number.POSITIVE_INFINITY;\n\n    for (var i = 0, li = octants.length; i < li; i++) {\n        var items = octants[i].items;\n\n        for (var j = 0, lj = items.length; j < lj; j++) {\n            var item = items[j];\n            var res = this.hitFace(rayPos, rayDir, item[7], item[6]);\n\n            if (res[0] && res[1] < t) {\n                t = res[1];\n            }\n        }\n    }\n\n    if (t !== Number.POSITIVE_INFINITY) {\n        hits = [t];\n    }\n\n    return hits;\n};\n\nexport {Octree, OctreeRaycaster};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/octree.js\n// module id = 166\n// module chunks = 0 1","\nimport {vec3 as vec3_, mat4 as mat4_} from '../utils/matrix';\nimport GpuDevice_ from './gpu/device';\nimport GpuTexture_ from './gpu/texture';\nimport GpuFont_ from './gpu/font';\nimport Camera_ from './camera';\nimport RenderInit_ from './init';\nimport RenderDraw_ from './draw';\nimport RenderRMap_ from './rmap';\n\n//get rid of compiler mess\nvar vec3 = vec3_, mat4 = mat4_;\nvar GpuDevice = GpuDevice_;\nvar GpuTexture = GpuTexture_;\nvar GpuFont = GpuFont_;\nvar Camera = Camera_;\nvar RenderInit = RenderInit_;\nvar RenderDraw = RenderDraw_;\nvar RenderRMap = RenderRMap_;\n\nvar Renderer = function(core, div, onUpdate, onResize, config) {\n    this.config = config || {};\n    this.core = core;\n    this.progTile = null;\n    this.progHeightmap = null;\n    this.progSkydome = null;\n    this.progWireframeTile = null;\n    this.progWireframeTile2 = null;\n    this.progText = null;\n    this.div = div;\n    this.onUpdate = onUpdate;\n    this.killed = false;\n    this.onlyDepth = false;\n    this.onlyLayers = false;\n    this.onlyHitLayers = false;\n    this.onlyAdvancedHitLayers = false;\n    this.advancedPassNeeded = false;\n    this.hitmapCounter = 0;\n    this.geoRenderCounter = 0;\n    this.geoHitmapCounter = 0;\n    this.frameTime = 0;\n    this.geometries = {};\n    this.clearStencilPasses = [];\n    this.onResizeCall = onResize;\n    //this.math = Math;\n    this.stencilLineState = null;\n    this.drawLabelBoxes = false;\n    this.drawGridCells = false;\n    this.drawAllLabels = false;\n    this.debug = {};\n\n    this.geodataSelection = [];\n    this.hoverFeatureCounter = 0;\n    this.hoverFeatureList = [];\n\n    this.touchSurfaceEvent = [];\n\n    var rect = this.div.getBoundingClientRect();\n\n    this.winSize = [rect.width, rect.height]; //QSize\n    this.curSize = [rect.width, rect.height]; //QSize\n    this.oldSize = [rect.width, rect.height]; //QSize\n    this.dirty = true;\n    this.cameraVector = [0,1,0];\n    this.viewExtent = 1;\n    //this.texelSizeLimit = this.core.mapConfig.texelSize * texelSizeFactor;\n\n    this.gpu = new GpuDevice(this, div, this.curSize, this.config.rendererAllowScreenshots, this.config.rendererAntialiasing, this.config.rendererAnisotropic);\n    this.camera = new Camera(this, 45, 2, 1200000.0);\n\n    //reduce garbage collection\n    this.drawTileMatrix = mat4.create();\n    this.drawTileMatrix2 = mat4.create();\n    this.drawTileVec = [0,0,0];\n    this.drawTileWorldMatrix = mat4.create();\n    this.pixelTileSizeMatrix = mat4.create();\n\n    this.heightmapMesh = null;\n    this.heightmapTexture = null;\n\n    this.skydomeMesh = null;\n    this.skydomeTexture = null;\n\n    this.hitmapTexture = null;\n    this.geoHitmapTexture = null;\n    this.hitmapSize = 1024;\n    this.updateHitmap = true;\n    this.updateGeoHitmap = true;\n\n    this.redTexture = null;\n\n    this.rectVerticesBuffer = null;\n    this.rectIndicesBuffer = null;\n    this.imageProjectionMatrix = null;\n\n    this.font = null;\n    this.fonts = {};\n    this.fogDensity = 0;\n\n    this.gmap = new Array(2048);\n    this.gmap2 = new Array(2048);\n    this.gmap3 = new Array(10000);\n    this.gmap3Size = new Array(10000);\n    this.gmapIndex = 0;\n    this.gmapTop = new Array(512);\n    this.gmapHit = new Array(512);\n    this.gmapStore = new Array(512);\n    this.fmaxDist = 0;\n    this.fminDist = 0;\n\n    this.jobZBuffer = new Array(512);\n    this.jobZBufferSize = new Array(512);\n\n    this.jobZBuffer2 = new Array(512);\n    this.jobZBuffer2Size = new Array(512);\n    \n    this.jobHBuffer = {};\n    this.jobHBufferSize = 0;\n\n    for (var i = 0, li = this.jobZBuffer.length; i < li; i++) {\n        this.jobZBuffer[i] = [];\n        this.jobZBufferSize[i] = 0;\n        this.jobZBuffer2[i] = {};\n        this.jobZBuffer2Size[i] = 0;\n    }\n\n    for (i = 0, li = this.gmap3.length; i < li; i++) {\n        this.gmap3[i] = [];\n        this.gmap3Size[i] = 0;\n    }\n\n    this.layerGroupVisible = [];\n    this.bitmaps = {};\n    \n    this.cameraPosition = [0,0,0];\n    this.cameraOrientation = [0,0,0];\n    this.cameraTiltFator = 1;\n    this.cameraViewExtent = 1;\n    this.distanceFactor = 1;\n    this.tiltFactor = 1;\n    this.localViewExtentFactor = 1;\n    this.cameraVector = [0,0,0];\n    this.labelVector = [0,0,0];\n    this.drawnGeodataTiles = 0;\n    this.drawnGeodataTilesFactor = 0;\n    this.drawnGeodataTilesUsed = false;\n    this.progMap = {};\n    this.gridHmax = 0;\n    this.gridHmin = 0;\n\n    //hack for vts maps\n    //this.vtsHack = true;\n    //this.vtsHack = false;\n\n    //reduce garbage collection\n    this.updateCameraMatrix = mat4.create();\n\n    //debug\n    this.lastHitPosition = [0,0,100];\n    this.logTilePos = null;\n\n    window.addEventListener('resize', (this.onResize).bind(this), false);\n\n    this.gpu.init();\n\n    //intit resources\n    // eslint-disable-next-line\n    this.init = new RenderInit(this);\n    this.rmap = new RenderRMap(this, 50);\n    this.draw = new RenderDraw(this);\n\n    var factor = 1;\n    this.resizeGL(Math.floor(this.curSize[0]*factor), Math.floor(this.curSize[1]*factor));\n};\n\nRenderer.prototype.initProceduralShaders = function() {\n    this.init.initProceduralShaders();\n};\n\n\nRenderer.prototype.onResize = function() {\n    if (this.killed){\n        return;\n    }\n\n    var rect = this.div.getBoundingClientRect();\n    this.resizeGL(Math.floor(rect.width), Math.floor(rect.height));\n    \n    if (this.onResizeCall) {\n        this.onResizeCall();\n    }\n};\n\n\nRenderer.prototype.kill = function() {\n    if (this.killed){\n        return;\n    }\n\n    this.killed = true;\n\n    if (this.heightmapMesh) this.heightmapMesh.kill();\n    if (this.heightmapTexture) this.heightmapTexture.kill();\n    if (this.skydomeMesh) this.skydomeMesh.kill();\n    if (this.skydomeTexture) this.skydomeTexture.kill();\n    if (this.hitmapTexture) this.hitmapTexture.kill();\n    if (this.geoHitmapTexture) this.geoHitmapTexture.kill();\n    if (this.redTexture) this.redTexture.kill();\n    if (this.whiteTexture) this.whiteTexture.kill();\n    if (this.blackTexture) this.blackTexture.kill();\n    if (this.lineTexture) this.lineTexture.kill();\n    if (this.textTexture2) this.textTexture2.kill();\n    if (this.atmoMesh) this.atmoMesh.kill();\n    if (this.bboxMesh) this.bboxMesh.kill();\n    if (this.font) this.font.kill();\n    if (this.plines) this.plines.kill();\n    if (this.plineJoints) this.plineJoints.kill();\n \n    this.gpu.kill();\n    //this.div.removeChild(this.gpu.getCanvas());\n};\n\n\nRenderer.prototype.resizeGL = function(width, height, skipCanvas, skipPaint) {\n    this.camera.setAspect(width / height);\n    this.curSize = [width, height];\n    this.oldSize = [width, height];\n    this.gpu.resize(this.curSize, skipCanvas);\n\n    //if (skipPaint !== true) { //remove this??\n       // this.draw.paintGL();\n    //}\n\n    var m = new Float32Array(16);\n    m[0] = 2.0/width; m[1] = 0; m[2] = 0; m[3] = 0;\n    m[4] = 0; m[5] = -2.0/height; m[6] = 0; m[7] = 0;\n    m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;\n    m[12] = -width*0.5*m[0]; m[13] = -height*0.5*m[5]; m[14] = 0; m[15] = 1;\n\n    this.imageProjectionMatrix = m;\n};\n\n\nRenderer.prototype.project2 = function(point, mvp, cameraPos) {\n    var p = [0, 0, 0, 1];\n\n    if (cameraPos) {\n        p = mat4.multiplyVec4(mvp, [point[0] - cameraPos[0], point[1] - cameraPos[1], point[2] - cameraPos[2], 1 ]);\n    } else {\n        p = mat4.multiplyVec4(mvp, [point[0], point[1], point[2], 1 ]);\n    }\n\n    //project point coords to screen\n    if (p[3] != 0) {\n        var sp = [0,0,0];\n\n        //x and y are in screen pixels\n        sp[0] = ((p[0]/p[3])+1.0)*0.5*this.curSize[0];\n        sp[1] = (-(p[1]/p[3])+1.0)*0.5*this.curSize[1];\n\n        //depth in meters\n        sp[2] = p[2]/p[3];\n\n        return sp;\n    } else {\n        return [0, 0, 0];\n    }\n};\n\n\nRenderer.prototype.project = function(point) {\n    //get mode-view-projection matrix\n    var mvp = this.camera.getMvpMatrix();\n\n    //get camera position relative to position\n    var cameraPos2 = this.camera.getPosition();\n\n    //get global camera position\n    var cameraPos = this.cameraPosition();\n\n    //get point coords relative to camera\n    var p = [point[0] - cameraPos[0] + cameraPos2[0], point[1] - cameraPos[1] + cameraPos2[1], point[2] - cameraPos[2] + cameraPos2[2], 1 ];\n\n    //project point coords to screen\n    var p2 = [0, 0, 0, 1];\n    p2 = mat4.multiplyVec4(mvp, p);\n\n    if (p2[3] != 0) {\n\n        var sp = [0,0,0];\n\n        //x and y are in screen pixels\n        sp[0] = ((p2[0]/p2[3])+1.0)*0.5*this.curSize[0];\n        sp[1] = (-(p2[1]/p2[3])+1.0)*0.5*this.curSize[1];\n\n        //depth in meters\n        sp[2] = p2[2]/p2[3];\n\n        return sp;\n    } else {\n        return [0, 0, 0];\n    }\n};\n\n\nRenderer.prototype.getScreenRay = function(screenX, screenY) {\n    if (this.camera == null) {\n        return [0,0,1.0];\n    }\n\n    this.camera.dirty = true; //???? why is projection matrix distored so I have to refresh\n\n    //conver screen coords\n    var x = (2.0 * screenX) / this.curSize[0] - 1.0;\n    var y = 1.0 - (2.0 * screenY) / this.curSize[1];\n    \n    var rayNormalizeDeviceSpace = [x, y, 1.0];\n\n    var rayClipCoords = [rayNormalizeDeviceSpace[0], rayNormalizeDeviceSpace[1], -1.0, 1.0];\n\n    var invProjection = mat4.create();\n    invProjection = mat4.inverse(this.camera.getProjectionMatrix());\n\n    //console.log(\"--\" + JSON.stringify(rayClipCoords));\n    //console.log(\"----\" + JSON.stringify(invProjection));\n\n    var rayEye = [0,0,0,0];\n    mat4.multiplyVec4(invProjection, rayClipCoords, rayEye); //inverse (projectionmatrix) * rayClipCoords;\n    rayEye[2] = -1.0;\n    rayEye[3] = 0.0;\n\n    var invView = mat4.create();\n    invView = mat4.inverse(this.camera.getModelviewMatrix());\n\n    var rayWorld = [0,0,0,0];\n    mat4.multiplyVec4(invView, rayEye, rayWorld); //inverse (projectionmatrix) * rayClipCoords;\n\n    // don't forget to normalise the vector at some point\n    rayWorld = vec3.normalize([rayWorld[0], rayWorld[1], rayWorld[2]]); //normalise (raywor);\n\n    return rayWorld;\n};\n\n\nRenderer.prototype.hitTestGeoLayers = function(screenX, screenY, secondTexture) {\n    var gl = this.gpu.gl;\n\n    //conver screen coords to texture coords\n    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {\n        return [false, 0,0,0,0];\n    }\n\n    var surfaceHit = false, pixel;\n\n    if (screenX >= 0 && screenX < this.curSize[0] &&\n        screenY >= 0 && screenY < this.curSize[1]) {\n\n        var x = 0, y = 0;\n\n        //get screen coords\n        x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));\n        y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));\n\n        //get pixel value from framebuffer\n\n        if (secondTexture) {\n            pixel = this.geoHitmapTexture2.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);\n        } else {\n            pixel = this.geoHitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);\n        }\n\n        surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);\n    }\n\n    if (surfaceHit) {\n        return [true, pixel[0], pixel[1], pixel[2], pixel[3]];\n    } \n\n    return [false, 0,0,0,0];\n};\n\n\nRenderer.prototype.switchToFramebuffer = function(type, texture) {\n    var gl = this.gpu.gl, size, width, height;\n    \n    switch(type) {\n    case 'base':\n        width = this.oldSize[0];\n        height = this.oldSize[1];\n    \n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    \n        this.gpu.setFramebuffer(null);\n    \n        this.camera.setAspect(width / height);\n        this.curSize = [width, height];\n        this.gpu.resize(this.curSize, true);\n        this.camera.update();\n            //this.updateCamera();\n        this.onlyDepth = false;\n        this.onlyHitLayers = false;\n        this.onlyAdvancedHitLayers = false;\n        this.advancedPassNeeded = false;\n        break;\n\n    case 'depth':\n        //set texture framebuffer\n        this.gpu.setFramebuffer(this.hitmapTexture);\n\n        this.oldSize = [ this.curSize[0], this.curSize[1] ];\n   \n        gl.clearColor(1.0,1.0, 1.0, 1.0);\n        gl.enable(gl.DEPTH_TEST);\n\n        size = this.hitmapSize;\n    \n        //clear screen\n        gl.viewport(0, 0, size, size);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    \n        this.curSize = [size, size];\n\n        this.gpu.clear();\n        this.camera.update();\n        this.onlyDepth = true;\n        this.onlyHitLayers = false;\n        this.onlyAdvancedHitLayers = false;\n        this.advancedPassNeeded = false;\n        break;\n\n    case 'geo':\n    case 'geo2':\n\n        this.hoverFeatureCounter = 0;\n        size = this.hitmapSize;\n            \n        //set texture framebuffer\n        this.gpu.setFramebuffer(type == 'geo' ? this.geoHitmapTexture : this.geoHitmapTexture2);\n            \n        width = size;\n        height = size;\n            \n        gl.clearColor(1.0,1.0, 1.0, 1.0);\n        gl.enable(gl.DEPTH_TEST);\n            \n        //clear screen\n        gl.viewport(0, 0, size, size);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            \n        this.curSize = [width, height];\n            \n        //render scene\n        this.onlyHitLayers = true;\n        this.advancedPassNeeded = false;\n        this.onlyAdvancedHitLayers = (type == 'geo2');\n            \n        this.gpu.clear();\n        this.camera.update();\n        break;\n\n    case 'texture':\n        //set texture framebuffer\n        this.gpu.setFramebuffer(texture);\n\n        this.oldSize = [ this.curSize[0], this.curSize[1] ];\n   \n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\n        gl.enable(gl.DEPTH_TEST);\n\n        //clear screen\n        gl.viewport(0, 0, this.gpu.canvas.width, this.gpu.canvas.height);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    \n        this.curSize = [this.gpu.canvas.width, this.gpu.canvas.height];\n\n        this.gpu.clear();\n        this.camera.update();\n        this.onlyDepth = false;\n        this.onlyHitLayers = false;\n        this.onlyAdvancedHitLayers = false;\n        this.advancedPassNeeded = false;\n        break;        \n    }\n};\n\n\nRenderer.prototype.hitTest = function(screenX, screenY) {\n    var gl = this.gpu.gl;\n\n    //get screen ray\n    var screenRay = this.getScreenRay(screenX, screenY);\n    var cameraPos = this.camera.getPosition();\n\n    //conver screen coords to texture coords\n    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {\n        return [0, 0, 0, null, screenRay, Number.MAX_VALUE, cameraPos];\n    }\n\n    var x = 0, y = 0;\n\n    //get screen coords\n    x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));\n    y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));\n\n    //get pixel value from framebuffer\n    var pixel = this.hitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);\n\n    //convert rgb values into depth\n    var depth = (pixel[0] * (1.0/255)) + (pixel[1]) + (pixel[2]*255.0) + (pixel[3]*65025.0);// + (pixel[3]*16581375.0);\n\n    var surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);\n\n    //compute hit postion\n    this.lastHitPosition = [cameraPos[0] + screenRay[0]*depth, cameraPos[1] + screenRay[1]*depth, cameraPos[2] + screenRay[2]*depth];\n\n    return [this.lastHitPosition[0], this.lastHitPosition[1], this.lastHitPosition[2], surfaceHit, screenRay, depth, cameraPos];\n};\n\n\nRenderer.prototype.getZoffsetFactor = function(params) {\n    return (params[0] + params[1]*this.distanceFactor + params[2]*this.tiltFactor)*0.0001;\n};\n\nRenderer.prototype.saveScreenshot = function(output, filename, filetype) {\n    var gl = this.gpu.gl;\n\n    //get current screen size\n    var width = this.curSize[0];\n    var height = this.curSize[1];\n\n    //read rgba data from frame buffer\n    //works only when webgl context is initialized with preserveDrawingBuffer: true\n    var data2 = new Uint8Array(width * height * 4);\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data2);\n\n    //flip image vertically\n    var data = new Uint8Array(width * height * 4);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n\n        var index2 = ((height-1) - y) * width * 4;\n\n        for (var x = 0; x < width; x++) {\n            data[index] = data2[index2];\n            data[index+1] = data2[index2+1];\n            data[index+2] = data2[index2+2];\n            data[index+3] = data2[index2+3];\n            index+=4;\n            index2+=4;\n        }\n    }\n\n    // Create a 2D canvas to store the result\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var context = canvas.getContext('2d');\n\n    // Copy the pixels to a 2D canvas\n    var imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    context.putImageData(imageData, 0, 0);\n\n    filetype = filetype || 'jpg'; \n   \n    if (output == 'file') {\n        var a = document.createElement('a');\n\n        var dataURI= canvas.toDataURL('image/' + filetype);\n\n        var byteString = atob(dataURI.split(',')[1]);\n        \n        // write the bytes of the string to an ArrayBuffer\n        var ab = new ArrayBuffer(byteString.length);\n        var ia = new Uint8Array(ab);\n        for (var i = 0; i < byteString.length; i++) {\n            ia[i] = byteString.charCodeAt(i);\n        }\n      \n        var file = new Blob([ab], {type: filetype});\n\n        var url = URL.createObjectURL(file);\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        setTimeout(function() {\n            document.body.removeChild(a);\n            window.URL.revokeObjectURL(url);  \n        }, 0); \n    } if (output == 'tab') {\n        //open image in new window\n        window.open(canvas.toDataURL('image/' + filetype));\n    }\n    \n    return imageData;\n};\n\n\nRenderer.prototype.getBitmap = function(url, filter, tiled, hash, useHash) {\n    var id = (useHash ? hash : url) + '*' + filter + '*' + tiled;\n\n    var texture = this.bitmaps[id];\n    if (!texture && url) {\n        texture = new GpuTexture(this.gpu, url, this.core, null, null, tiled, filter);\n        this.bitmaps[id] = texture;\n    }\n\n    return texture;\n};\n\nRenderer.prototype.getFont = function(url) {\n    var font = this.fonts[url];\n    if (!font) {\n        font = new GpuFont(this.gpu, this.core, null, null, url);\n        this.fonts[url] = font;\n    }\n\n    return font;\n};\n\n\nexport default Renderer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/renderer.js\n// module id = 167\n// module chunks = 0 1","\n\nvar RendererRMap = function(renderer, blockSize, maxBlockRectangles) {\n    this.renderer = renderer;\n    this.drawAllLabels = false;\n    this.maxBlockRectangles = maxBlockRectangles || 500;\n    this.blockSize = blockSize;\n    this.blockSizeFactor = 1/blockSize;\n    this.blocks = [];\n    this.blocksRCount = [];\n    this.allocatedBlocks = 0;\n    this.lx = 1;\n    this.ly = 1;\n    this.counter = 0;\n    this.rectangles = null;\n    this.rectanglesCount = 0;\n    this.rectangles2 = null;\n    this.rectangles2Count = 0;\n};\n\n\nRendererRMap.prototype.clear = function() {\n    this.slx = this.renderer.curSize[0];\n    this.sly = this.renderer.curSize[1];\n\n    //reduce by credits\n    this.sly = Math.max(1, this.sly - 55);\n    \n    //compass size\n    this.clx = 135;\n    this.cly = (150 - 35);\n\n    //search bar size\n    this.blx = 245;\n    this.bly = 45;\n\n\n    this.lx = Math.floor(this.slx * this.blockSizeFactor) + 1;\n    this.ly = Math.floor(this.sly * this.blockSizeFactor) + 1;\n\n    var totalNeeded = this.ly * this.lx;\n    \n    if (!this.rectangles) {\n        this.rectangles = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles\n    }\n\n    if (!this.rectangles2) {\n        this.rectangles2 = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles\n    }\n\n    if (this.rectanglesCount > 0 || this.allocatedBlocks != totalNeeded) {\n        this.allocatedBlocks = totalNeeded;\n\n        for (var i = 0; i < totalNeeded; i++) { //check if all rectangles are preallocated and reset coutner\n            if (!this.blocks[i]) {\n                this.blocks[i] = [];\n            }\n\n            this.blocksRCount[i] = 0;\n        }\n\n    }\n\n    this.drawAllLabels = this.renderer.debug.drawAllLabels;\n\n    this.rectanglesCount = 0;\n    this.counter = this.renderer.geoRenderCounter;\n};\n\n\nRendererRMap.prototype.storeRemovedRectangle = function(x1, y1, x2, y2, z, subjob) {\n        var rectangles2 = this.rectangles2;\n        var rectangles2Count = this.rectangles2Count;\n\n        rectangles2[rectangles2Count] = x1;\n        rectangles2[rectangles2Count+1] = y1;\n        rectangles2[rectangles2Count+2] = x2;\n        rectangles2[rectangles2Count+3] = y2;\n        rectangles2[rectangles2Count+4] = z;\n        rectangles2[rectangles2Count+5] = subjob;\n        this.rectangles2Count += 6;\n};\n\nRendererRMap.prototype.checkRectangle = function(x1, y1, x2, y2, y3) {\n    var t;\n\n    if (x1 > x2) { t = x1; x1 = x2; x2 = t; }\n    if (y1 > y2) { t = y1; y1 = y2; y2 = t; }\n\n    y3 += y2;\n    \n    //screen including credits\n    if (x1 < 0 || x2 > this.slx || y1 < 0 || y3 > this.sly) {\n        return false;\n    }\n\n    //compass\n    if (x1 < this.clx && x2 > 0 && y1 <= this.sly && y3 > (this.sly -this.cly)) {\n        return false;\n    }\n\n    //search bar\n    if (x1 < this.blx && x2 > 0 && y1 <= this.bly && y3 > 0) {\n        return false;\n    }\n\n    return true;\n}\n\nRendererRMap.prototype.addRectangle = function(x1, y1, x2, y2, z, subjob, any) {\n    var x, y, i, index, blockRectangles, blockRectanglesCount,\n        rectangleIndex, t;\n\n    if (this.drawAllLabels) {\n        return true;\n    }\n\n    if (x1 > x2) { t = x1; x1 = x2; x2 = t; }\n    if (y1 > y2) { t = y1; y1 = y2; y2 = t; }\n\n    var y3 = y2 + subjob[1]; //add stick shift\n    \n    //screen including credits\n    if (x1 < 0 || x2 > this.slx || y1 < 0 || y3 > this.sly) {\n        return false;\n    }\n\n    //compass\n    if (x1 < this.clx && x2 > 0 && y1 <= this.sly && y3 > (this.sly -this.cly)) {\n        return false;\n    }\n\n    //search bar\n    if (x1 < this.blx && x2 > 0 && y1 <= this.bly && y3 > 0) {\n        return false;\n    }\n\n    var xx1 = Math.floor(x1 * this.blockSizeFactor);\n    var yy1 = Math.floor(y1 * this.blockSizeFactor);\n    var xx2 = Math.floor(x2 * this.blockSizeFactor);\n    var yy2 = Math.floor(y2 * this.blockSizeFactor);\n\n    if (xx2 < 0 || yy2 < 0 || xx1 >= this.lx || yy1 >= this.ly) {\n        return false;\n    }\n\n    if (xx1 < 0) xx1 = 0;\n    if (xx2 >= this.lx) xx2 = this.lx - 1;\n\n    if (yy1 < 0) yy1 = 0;\n    if (yy2 >= this.ly) yy2 = this.ly - 1;\n\n    var lx = (xx2 - xx1) + 1;\n    var ly = (yy2 - yy1) + 1;\n    var removeList = {};\n    var exit = false;\n\n    var top = this.renderer.config.mapFeaturesSortByTop, rectangles = this.rectangles;\n\n    //test collision\n    for (y = 0; y < ly; y++) {\n        for (x = 0; x < lx; x++) {\n            index = (yy1 + y)*this.lx + (xx1 + x);\n\n            blockRectangles = this.blocks[index];\n            blockRectanglesCount = this.blocksRCount[index];\n\n            for (i = 0; i < blockRectanglesCount; i++) {\n                rectangleIndex = blockRectangles[i];\n\n                if (x1 < rectangles[rectangleIndex + 2] && x2 > rectangles[rectangleIndex + 0] &&\n                    y1 < rectangles[rectangleIndex + 3] && y2 > rectangles[rectangleIndex + 1]) {\n\n                    if (any) {\n                        return false;\n                    }\n\n                    if (top) {\n                        if (z < rectangles[rectangleIndex + 4]) {\n                            return false;\n                        }\n                    } else {\n                        if (z > rectangles[rectangleIndex + 4]) {\n                            return false;\n                        }\n                    }\n\n                    removeList[rectangleIndex] = true;\n                }\n            }\n\n            if ((blockRectanglesCount + 1) >= this.maxBlockRectangles) {\n                return false;\n            }\n        }\n    }\n\n    //remove rectangles\n    for (var key in removeList) {\n        this.removeRectangle(parseInt(key));\n    }\n\n    //there is no collision so we can store rectangle\n    rectangleIndex = this.rectanglesCount\n    rectangles[rectangleIndex] = x1;\n    rectangles[rectangleIndex+1] = y1;\n    rectangles[rectangleIndex+2] = x2;\n    rectangles[rectangleIndex+3] = y2;\n    rectangles[rectangleIndex+4] = z;\n    rectangles[rectangleIndex+5] = subjob;\n    this.rectanglesCount += 6;\n\n    for (y = 0; y < ly; y++) {\n        for (x = 0; x < lx; x++) {\n            index = (yy1 + y)*this.lx + (xx1 + x);\n            this.blocks[index][this.blocksRCount[index]] = rectangleIndex;\n            this.blocksRCount[index]++;\n        }\n    }\n\n    return true;\n};\n\nRendererRMap.prototype.removeRectangle = function(rectangleIndex) {\n    var rectangles = this.rectangles, x1, y1, x2, y2, x, y, i, index,\n        blockRectangles, blockRectanglesCount;\n\n    x1 = rectangles[rectangleIndex];\n    y1 = rectangles[rectangleIndex+1];\n    x2 = rectangles[rectangleIndex+2];\n    y2 = rectangles[rectangleIndex+3];\n\n    //store removed rectangels for second pass\n    var rectangles2 = this.rectangles2;\n    var rectangles2Count = this.rectangles2Count;\n\n    rectangles2[rectangles2Count] = x1;\n    rectangles2[rectangles2Count+1] = y1;\n    rectangles2[rectangles2Count+2] = x2;\n    rectangles2[rectangles2Count+3] = y2;\n    rectangles2[rectangles2Count+4] = rectangles[rectangleIndex+4];\n    rectangles2[rectangles2Count+5] = rectangles[rectangleIndex+5];\n    this.rectangles2Count += 6;\n\n    //remove subjob\n    rectangles[rectangleIndex+5] = null;\n\n    var xx1 = Math.floor(x1 * this.blockSizeFactor);\n    var yy1 = Math.floor(y1 * this.blockSizeFactor);\n    var xx2 = Math.floor(x2 * this.blockSizeFactor);\n    var yy2 = Math.floor(y2 * this.blockSizeFactor);\n\n    if (xx1 < 0) xx1 = 0;\n    if (xx2 >= this.lx) xx2 = this.lx - 1;\n\n    if (yy1 < 0) yy1 = 0;\n    if (yy2 >= this.ly) yy2 = this.ly - 1;\n\n    var lx = (xx2 - xx1) + 1;\n    var ly = (yy2 - yy1) + 1;\n\n    for (y = 0; y < ly; y++) {\n        for (x = 0; x < lx; x++) {\n            index = (yy1 + y)*this.lx + (xx1 + x);\n\n            blockRectangles = this.blocks[index];\n            blockRectanglesCount = this.blocksRCount[index];\n\n            for (i = 0; i < blockRectanglesCount; i++) {\n                if (blockRectangles[i] == rectangleIndex) {\n                    blockRectangles[i] = blockRectangles[blockRectanglesCount - 1];\n                    this.blocksRCount[index]--;\n                    break;\n                }\n            }\n\n        }\n    }\n};\n\nRendererRMap.prototype.processRectangles = function(gpu, gl, renderer, screenPixelSize) {\n    var rectangles = this.rectangles;\n    var rectangles2 = this.rectangles2;\n    var draw = renderer.draw;\n\n    // second pass\n    // add removed rectangles\n    for (var i = 0, li = this.rectangles2Count; i < li; i+=6) {\n        var x1 = rectangles2[i],\n            y1 = rectangles2[i+1],\n            x2 = rectangles2[i+2],\n            y2 = rectangles2[i+3],\n            z = rectangles2[i+4],\n            subjob = rectangles2[i+5];\n\n        this.addRectangle(x1, y1, x2, y2, z, subjob);\n    }\n\n    this.rectangles2Count = 0;\n\n    for (i = 0, li = this.rectanglesCount; i < li; i+=6) {\n        var subjob = rectangles[i+5];\n\n        if (subjob) {\n            if (subjob[0].hysteresis) {\n                renderer.jobHBuffer[subjob[0].id] = subjob[0];\n            } else {\n                renderer.drawnJobs++;\n                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, subjob, null);\n            }\n        }\n    }\n\n    this.clear();\n};\n\nexport default RendererRMap;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/renderer/rmap.js\n// module id = 168\n// module chunks = 0 1","import Proj4 from 'proj4';\nimport earcut from 'earcut';\nimport {getCoreVersion as getCoreVersion_, checkSupport as checkSupport_} from './core';\nimport {CoreInterface as CoreInterface_} from './interface';\nimport {vec2 as vec2_, vec3 as vec3_, vec4 as vec4_, mat3 as mat3_, mat4 as mat4_} from './utils/matrix';\nimport {utils as utils_} from './utils/utils';\nimport {math as math_} from './utils/math';\nimport {platform as platform_} from './utils/platform';\n\n//get rid of compiler mess\nvar getCoreVersion = getCoreVersion_, checkSupport = checkSupport_;\nvar CoreInterface = CoreInterface_;\nvar vec2 = vec2_, vec3 = vec3_, vec4 = vec4_, mat3 = mat3_, mat4 = mat4_;\nvar utils = utils_;\nvar math = math_;\nvar proj4 = Proj4;\nvar platform = platform_;\n\n\nfunction core(element, config) {\n    element = (typeof element !== 'string') ? element : document.getElementById(element);\n\n    if (checkSupport()) {\n        return new CoreInterface(element, config);\n    } else {\n        return null;\n    }\n}\n\n\nexport {vec2,vec3,vec4,mat3,mat4,math,utils,getCoreVersion,checkSupport,core,proj4,earcut,platform};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/index.js\n// module id = 203\n// module chunks = 1"],"sourceRoot":""}